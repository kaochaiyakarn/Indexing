rice university behavioral software contracts robert bruce findler thesis submitted partial fulfillment requirements degree doctor philosophy approved thesis committee matthias felleisen professor computer science robert cartwright professor computer science keith cooper professor computer science michael barlow assistant professor linguistics houston texas april behavioral software contracts robert bruce findler calvin hobbes 
reprinted permission universal press 
rights reserved 
behavioral software contracts robert bruce findler sustain market software components component producers consumers agree contracts 
contracts specify party obligations 
ensure sides meet obligations agree standards monitoring contracts assigning blame contract violations 
dissertation explores issues contracts specify sequential behavior methods procedures pre post conditions 
process main contributions dissertation shows existing contract checking systems objectoriented languages incorrectly enforce contracts presence subtyping 
dissertation shows check contracts properly 
second dissertation shows enforce pre post condition style contracts higher order procedures correctly assign blame contract violations context 
dissertation lays groundwork theory contract checking spirit theory type checking 
particular states proves soundness result contracts guaranteeing contract checker properly enforces contracts properly assigns blame contract violations 
acknowledgments owe entire academic life advisor matthias felleisen 
struggle train incredible difference life certainly easy 
matthias 
years rice worked especially closely matthew flatt shriram krishnamurthi 
patient guidance support invaluable development programmer researcher 
worked closely kevin charter john clements cormac flanagan paul graunke philippe meunier jamie raymond paul 
mario helped uncover flaw object oriented contract checkers 
clemens szyperski read early versions chapters dissertation gave excellent ideas way 
daniel jackson great comments early drafts 
gregory sullivan pointed flaw formulation contract soundness 

special ian available coffee making day manageable 
dorai sitaram teaching wonders helping great deal dissertation 
jean ready perfect word encouragement humor guidance grateful 
mother father brothers source great love encouragement 
love shaped person am today 
want wife huang love support encouragement 
life worthwhile 
baby 
contents iii acknowledgments iv table contents list illustrations viii components drscheme 
class function contracts drscheme 
flat contracts 
class contracts 
higher order contracts 
thesis statement roadmap 
behavioral subtyping related behavioral contracts 
behavioral subtyping 
contracts behavioral subtypes 
problems prior 
jass 
properly monitoring contracts 
contract compilation check contracts assign blame 
flat contract checking 
vi interface implementation 
class inheritance 
multiple inheritance 
environmental considerations 
performance 
contract soundness type soundness contract soundness 
syntax 
type elaboration 
contract elaboration 
evaluation 
contract soundness 
contracts higher order functions order function contracts higher order function contracts 
example contracts 
contracts look 
enforcement order types 
blame contravariance 
class contracts 
callbacks stateful contracts 
contract calculus 
contract monitoring 
contract implementation 
correctness 
dependent contracts 
tail recursion 
vii 
bibliography illustrations gui test suite contract 
relative percentages contract 
editor mixin contract 
editor mixin extensions 
mixin composition 
controlling drscheme printer 
behavioral subtyping condition 
behavioral subtyping condition generalized multiple inheritance behavioral subtyping interfaces 
delayed incorrect explanation contract violation 
hierarchy checking 
section overview 
pre post condition checking 
hierarchy checking 
hierarchy checking multiple inheritance 
contract java syntax contracts compiled away 
predicates relations model contract java 
predicates relations model contract java ii 
context sensitive checks type elaboration rules contract java ix context sensitive checks type elaboration rules contract java ii blame compilation 
blame compilation ii 
blame compilation iii 
blame compilation iv 
example hierarchy diagram 
elaborated console example 
operational semantics contract java 
contract specified add panel 
contract manually distributed 
abstraction predicate contracts 
preferences panel contract protecting panel 
con syntax types 
con evaluation contexts values 
reduction semantics con 
con type rules 
obligation expression insertion 
monitoring contracts con 
reducing sqrt con 
reducing sqrt wrap 
contract compiler wrapping function 
contract compiler 
simulation fw fw 
evaluators 
dependent function contracts con 
chapter modern software development requires collaboration independently operating groups developers 
developers publish components extensions combine form working system 
mcilroy proposed idea software components 
marketplace reusable components software manufacturers produce software components specified interfaces 
developers assemble systems shelf components possibly adapting wrapper code instantiating abstractions adding new ones 
component faulty developer replace different 
manufacturer improve component developer improve final product replacing link old component link new 
component marketplace components come interfaces specify key properties 
interfaces record contracts component producer component consumer 
list levels component contracts syntactic contracts type signatures behavioral contracts pre post condition invariants state semantic properties augment languages type specifications sequencing contracts thread synchronization sequencing constraints quality service contracts time space guarantees 
addition recording contracts components developers agree mechanism enforcing contracts assigning blame contract violations 
example pre condition behavioral contract fails developer wrote call corresponding method procedure blamed 
post condition fails developer wrote method procedure blamed 
properly assigned blame enables developers quickly ascertain component faulty fix problem replace faulty component 
run time enforcement behavioral contracts widely studied standard interpretation 
method procedure annotated precondition post condition 
conditions effect free program fragments evaluated method procedure called returns 
pre condition evaluated method procedure called produces false caller failed establish required conditions 
symmetrically post condition evaluated method procedure returns indicates method procedure successful 
remainder divided parts 
part presents overview component structure drscheme explains component organization facilitated program development 
second part consists series contract examples drawn drscheme motivate remainder dissertation 
note 
principle try prove correctness behavioral contracts 
example extended static checking group developed verification tools java modula attempt prove certain behavioral properties satisfied 
general languages express behavioral contracts rich intractably difficult verify statically contracts component violated 
fact extended static checking group tools complete sound believe certain amount accountability pride quality critical software production 
term blame mean programmer held accountable 
tools may indicate errors exist correct code may indicate errors exist incorrect code 
furthermore tools attempt prove behavioral contracts correct computationally expensive 
tools require training logic program verification programmers possess 
components drscheme source examples component oriented programming drscheme programming environment scheme 
supports forms extension tools plays role component deployment context 
drscheme initially provides language targeted beginners 
language small designed pedagogic clarity expense expressiveness 
students learn programming drscheme language adapts student providing students constructs 
allowing student progress tower languages drscheme shields student complexity professional programming environment allows student computational power learn fundamental principles computation 
cost simplicity instructors assign exercises involve graphics networking advanced features programming language motivate students 
address problem drscheme provides 
series definitions written full programming language dynamically injected students programming language new primitives 
typically define exercise specific gui networking primitives hide full complexity libraries allow student features solve problems 
tools drscheme tools interface allows developers enhance core programming environment new teaching languages program analyses syntax checkers algebraic extensions 
extensions loaded drscheme starts exact set tools written drscheme source code 
drscheme starts discovers tools installed loads 
allows third party developers provide tools independently main drscheme releases 
support tools drscheme requires powerful form program extension 
dynamically linked multiple times tools dynamically linked externally specified imports 
support tools drscheme uses units software component mechanism designed part mzscheme programming language 
class function contracts drscheme section motivates remainder dissertation example contracts drscheme 
contracts range simple predicates flat values invariants certain object oriented design patterns restrictions arguments results higher order functions 
contracts occur interface drscheme extensions described previous section 
flat contracts example turn drscheme automatic gui test suite library 
contains functions simulate user actions button clicks menu selections 
operations contracts guarantee gui state amenable test action 
contract test button press operation simulates button click shown 
accepts string button argument 
cases front window drscheme window get top level focus window primitive returns front window drscheme window 
argument string front window contain button label string 
argument button front window contain button 
cases button button press argument okay 
union string button boolean determines argument test button press satisfies contract define button press argument okay 
arg top level focus window get top level focus window cond string 
arg top level focus window frame 
top level focus window 
button string 
send get label arg send enabled 
send shown 

arg button top level focus window frame 
top level focus window eq 
arg send enabled 
send shown 
frame 
instanceof frame area boolean boolean determines frame contains child satisfies 
define frame 
frame test frame 
area container test send get children gui test suite contract visible enabled 
button press argument okay 
procedure returns boolean indicating fitness value argument test button press formulating contract type systems possible proving theorem prover nearly intractable depends state gui turn depends sequence user inputs submitted drscheme 
fact test suite running possible get spurious test failures person running test suite interrupts simulated stream events real mouse clicks 
causes drscheme set percentages listof number void define set percentages ps list 
ps number 
ps length ps length send get children apply ps positive 
ps error set percentages expected list positive numbers sum got ps set 
percentages map percentage ps send container relative percentages contract enter unexpected state contracts hold 
failures consequence test suite architecture 
simulated event put event queue drscheme distinguish actual event 
property important integrity test suite negative consequence test suite running programmer manipulate drscheme gui 
drscheme contains contracts independent user input proving correct goes capabilities traditional type systems 
second example consider function 
function sets relative percentages windows main drscheme frame 
boxed portion function checks contract unboxed portion performs real function 
function argument list numbers subwindow 
subwindow percentage specified list length match number subwindows 
additionally number treated percentage size total window percentage positive number sum 
practical type systems currently unable express fact length lists match series numbers sum 
define frame editor interface get editor 
implements editor get editors 
listof interface editor 
implements editor define frame editor mixin mixin frame frame editor define public get editor text define public get editors list editor define private editor editor get editor editors get editors editor implementation 
editor editor editors error frame editor result get editor match got editors editor object editor editor mixin contract class contracts standard features scheme drscheme implementation language supports class object system similar provided java 
addition classes interfaces objects supported java drscheme class system supports mixins class extensions parameterized superclass 
classes body mixin consists field method declarations 
classes programmer specify superclass mixin 
programmer specifies interface eventual superclass implement 
build class hierarchy programmer composes mixins classes mixins 
example mixin consider frame editor mixin 
mixin extends classes implement frame interface frames mixin implements frame editor interface 
body mixin supplies implementations methods frame editor 
methods frame editor establish connection frame editor visible frame 
editor method creates new editors 
uses get editor method determine class editor ensures instance class implements interfaces returned get editors get editor method get editors methods intended overridden extensions mixin 
extend frame class additional functionality depends editor programmer overrides get editors method return additional interfaces 
returning interfaces fashion guarantees editor supports new functionality 
example frame mixins see 
frame searchable mixin provides emacs searching window bottom frame 
contour mixin provides foot overview program text showing pixel character definitions window 
screen shots drscheme right hand side show drscheme window searching mixin contour mixin 
mixin overrides get editors method guarantees frame editor implements appropriate interfaces 
frame searchable mixin requires frame editor implement text searching interface safely apply search method 
similarly frame contour mixin requires editor implement text contour interface safely invoke get contour method 
construct frame editor programmer composes series frame mixins series editor mixins overrides frame get editor method return editor mixin composition 
contracts ensure editor frame match 
expression shows compose text mixins frame mixins base text frame classes 
final expression connects frame class text class 
text class implements interfaces required define frame searchable interface show hide search window define text searching interface search define frame searchable mixin mixin frame editor frame searchable inherit get editor define override get editor cons text searching super get editor 
send get editor search 
define frame contour interface show hide contour window define text contour interface get contour define frame contour mixin mixin editor frame contour inherit get editor define override get editor cons text contour super get editor 
send get editor get contour 
editor mixin extensions mixin composition contract error signaled composition 
screen shot right hand side shows resulting drscheme window searching window contour window 
define text text searchable mixin text delegate mixin text define super frame frame searchable mixin frame delegate mixin frame editor mixin frame define frame class super frame define override get editor text mixin composition higher order contracts natural expect contracts express behaviors functions languages higherorder functions 
example consider predicate default display fraction 
number boolean define default display fraction 
number 
exact 
real 
integer 
controls aspect drscheme pretty printer 
predicate returns printer uses graphical mixed notation fraction display value 
returns printer uses string ascii digits 
drscheme parameterized predicate 
allows tool extensions control fractions displayed set display fraction current functions shown 
order graphical display code properly argument set display fraction return default display fraction 
predicate may return 
current display fraction 
number boolean define current display fraction 
default display fraction 
set display fraction number boolean void define set display fraction 
set 
current display fraction 
num curr num def default display fraction 
num def curr error set display fraction predicate returned default predicate 
curr controlling drscheme printer set display fraction function contract guarantee argument returns default display fraction 
returned boxed code enforces contract 
thesis statement roadmap dissertation investigates contracts previous section explaining enforce run time automatically assign blame contracts violated 
thesis dissertation contract checking procedural languages complex requires solid theoretical foundations 
dissertation supports thesis examination existing contract checkers object oriented languages failures detect violations assign blame properly design contract system remedies flaws existing object oriented contract checkers design contract system higher order contract checking contract soundness theorems guarantee contract checkers properly enforce contracts properly assign blame contract violations 
dissertation divided chapters 

chapter explains behavioral subtyping interact contract checking 
examines related contract checking shows existing objectoriented contract checkers fail check contracts properly 
chapter presents contract compiler contract language discussed chapter checks object oriented contracts correctly 
compiler demonstrates contract checker integrated type checker 
chapter provides step theory contract soundness analogy theory type soundness 
formulates contract soundness theorem relationship program running contract checking enabled program running contract checking 
theorem guarantees program contract checking enters invalid state checked program signals appropriate error provides correct blame 
additionally guarantees program contract checking violates contract checked program unchecked program identical behavior 
chapter presents contract checking calculus languages higher order functions shows implement proves implementation matches calculus 
chapter concludes discussion dissertation contributions 
chapter behavioral subtyping related run time enforced behavioral contracts studied extensively context procedural languages 
rosenblum particular case assertions describes useful classes assertions 
contract checking added object oriented languages :10.1.1.31.7982
languages support type hierarchies contract checkers take hierarchies account properly 
particular contracts overriding methods improperly synthesized programmer original contracts 
flaw leads mis assigned delayed missing blame contract violations 
chapter organized sections 
explains behavioral contracts 
second explains behavioral subtyping 
section explains connection behavioral contracts behavioral subtyping 
section demonstrates existing contract checkers fail section shows check behavioral contracts object oriented languages properly 
behavioral contracts programs subtyping checking pre post conditions simple matter 
consider code implements wrapper class floats class float float getvalue 
float sqrt 
pre getvalue post math abs ret ret getvalue case pre condition sqrt ensures method applied positive numbers 
post condition promises square result certain tolerance original argument 
ret stand result method post condition 
case sqrt method pre post conditions fully specify correctness 
general programmers pre post conditions specify entire behavior method programmers contracts refine type specifications 
long programs inheritance contract checking simply evaluating conditions programmer stated 
programs employ inheritance contract monitoring requires sophistication 
particular subtypes classes interfaces behavioral subtypes 
behavioral subtyping behavioral subtyping guarantees objects subtype preserve original type invariants 
put differently object subtype substitutable object original type effect program observable behavior 
pre post conditions behavioral subtyping means pre condition contracts type imply pre condition contracts subtype post condition contracts subtype imply post condition contracts type 
consider 
represents class hierarchy fragment classes derived classes method overriding method distinct pre condition post condition 
interpreted fragment behavioral subtyping condition states argument method implies implies 
generalize behavioral subtyping condition multiple inheritance considering subtype relationship independently 
example consider 
contains interfaces inheritance relationship considered separately require independently substitutable program conditions void object pre post void object pre post behavioral subtyping condition program conditions void object pre post void object pre post void object pre post behavioral subtyping condition generalized multiple inheritance reflected conditions listed 
minimum requirement match spirit behavioral subtyping condition 
contracts behavioral subtypes contract checker object oriented languages verify pre condition post condition hierarchies meet behavioral subtyping requirement 
section ex possible imagine stronger constraint 
may require conditions equivalent 
applies stricter constraint mutatis mutandis 
plains example 
consider program interface iconsole int getmaxsize post ret void display string pre length getmaxsize class console implements iconsole int getmaxsize 
post ret void display string 
pre length getmaxsize iconsole interface contains methods types pre post conditions small gas station console displays messages gas pump operator 
console class provides implementation iconsole getmaxsize method returns limit message size display method changes console visible message 
post condition getmaxsize pre condition display merely guarantee invariants console ensure correctness 
consider extension console class runningconsole extends console void display string 
super display string substring 
getmaxsize 
pre true display method class creates thread displays portion string fits console updates console display scrolling message character character display advertising messages gas pumped 
pre condition display runningconsole true implied pre condition console runningconsole behavioral subtype console subtype behavioral subtype 
concretely extensions console class may pre conditions implied supertype pre condition 
consider example class prefixedconsole extends console string return void display string super display pre length getmaxsize length prefixedconsole class provides debugging support console form prefix string attached message displayed console 
prefix string indicates internal state gas pump 
runningconsole pre condition prefixedconsole implied pre condition console accordingly code written accept instances console may violate pre condition prefixedconsole violating pre condition console clearly code expects instances console blamed code fulfilled obligations meeting console pre condition 
blame lie programmer prefixedconsole failing create behavioral subtype console addition classes interfaces describe type hierarchy 
class type hierarchy interface type hierarchy specify hierarchy behavioral subtypes 
pre post condition failures blame malformed hierarchy fall author code contains interfaces 
consider part java program 
imagine different programmers guy james wrote parts program 
james main method creates instance type invokes 
contracts perfectly valid argument 
ac written guy interface void int pre interface extends void int pre written james class implements void int 
pre public static void main string argv new behavioral subtyping interfaces cording contract illegal argument 
behavioral subtyping condition tells subtype substitutable context 
true accepts fewer arguments particular accept 

guy claim extends wrong respect behavioral subtyping condition 
method call james code fails blame contractual violation lie guy 
preceding examples suggest contract checking systems object oriented languages signal kinds errors pre condition violations post condition violations hierarchy errors 
distinguishes contract checking procedural world contract checking object oriented world 
hierarchy error signals subclass extending interface behavioral subtype hierarchy pre conditions hierarchy post conditions malformed 
problems prior examined tools implement eiffel style contracts java icontract handshake 
systems enforce contracts evaluating pre condition expressions methods called eval post condition expressions methods return 
pre condition fails blame calling code establishing proper context 
post condition fails blame method living promise 
tools handle programs inheritance 
exception jass tool constructs disjunction method super pre conditions conjunction method super post conditions 
program systems replace condition jj replace condition logical statements jj true re written programs satisfy behavioral subtyping condition original program 
holzle bruno section point contract monitoring tools check programmer original contracts checking synthesized contracts mask programmer errors 
recall prefixedconsole class previous section 
class display method pre condition contract length getmaxsize length superclass console display method pre condition contract length getmaxsize console pre condition imply prefixedconsole pre condition know programmer prefixedconsole mistake 
contract checking tool turn report mistake programmer 
existing tools monitoring pre post conditions handle situation properly 
combine pre conditions disjunction replacing pre condition length getmaxsize length getmaxsize length result pre condition overriding method underlined effectively ignored 
see bad problem translated iconsole console prefixedconsole icontract syntax maximum dummy display routine just prints stdout 
main method invokes prefixedconsole display method string abc follows new prefixedconsole display abc call erroneous pre condition prefixedconsole display method requires argument string character 
icontract responded error message java lang error precondition violated console display string declared iconsole display string length console display prefixedconsole display main main icontract blames call super display inside prefixedconsole display method hierarchy caller prefixedconsole display 
larger program erroneous explanation send programmer wrong direction searching defect 
icontract response edited clarity formatting meaning preserved 
written alice class void set int 
pre int get 
post class extends void set int 
pre int get 
post written bill new set get delayed incorrect explanation contract violation addition wrong method calls erroneous contract monitoring systems may trigger exception contract violation occurs 
contains program fragment illustrates idea 
consists classes implement integer state variable 
state variable allowed take positive values state variable strictly larger 
alice wrote hierarchy match behavioral subtyping condition behavioral subtype existing tools combine pre conditions disjunction pre condition effectively guarantee state variable larger 
call set signal error 
get invoked return incorrectly triggers post condition violation alice error message 
blame assigned guilty party case assigned actual violation occurs potentially days justified incorrect reason decreasing faith tools 
problem difficult reproduce understand 
existing contract monitoring systems handle java multiple inheritance interfaces similarly flawed manner 
single class implements interface collects pre conditions post conditions conjunctions ensuring object meets interfaces simultaneously 
icontract collects pre conditions disjunction post conditions conjunction 
manufactured contracts match programmer written contracts blame faulty programs may delayed mis assigned entirely absent 
jass jass contract checker java takes contract hierarchy consideration 
discover hierarchy errors jass programmer specify simulation method creates object supertype current object 
contract checker uses simulation method create supertype object time method called method returns 
checks relevant contracts supertype object original object related proper implications 
contract checker signals hierarchy error 
jass closely liskov wing 
directly translates framework java 
unfortunately framework java mismatched ways 
subtypes java function state space respective supertypes 
implies programmer define simulation method checks significantly cheaper jass new objects need created 
second technique scale multiple inheritance 
third technique checks single step subtype hierarchy type hierarchy java may steps 
properly monitoring contracts programmers mistakes 
mistakes range simple typographical errors complex subtle logical errors 
accordingly tools assumption programmers constructed formed programs particular tools re write programs assumptions 
tools report errors program text programmers provide 
giving programmers explanations terms original programs helps pinpoint mistakes precise timely gc gc gc ggg ggg ggg gc gc gc gc gc class hierarchy interface hierarchy hierarchy checking fashion 
especially true contract monitoring tools purpose provide checkable specifications programs improve software reliability 
consider code fragment running example display consoles iconsole assume returns prefixedconsole string falls gap display display method invoked pre condition prefixedconsole fails 
blame lie author code 
pre conditions prefixedconsole console wrong relationship blame lies author prefixedconsole implied prefixedconsole behavioral extension console assign blame correctly contract checking tools check report different types errors pre condition errors post condition errors hierarchy extension errors 
checking hierarchy extension errors separate checking pre postcondition errors blame contract failure assigned programmer 
method calls addition checking pre condition method invoked contract checking tool verify pre condition implies subtype pre conditions relevant portion contract hierarchy 
similarly method returns addition checking post condition returning method contract checking tool verify post condition implies supertype postconditions relevant portion contract hierarchy 
contains example hierarchy 
right hand side class hierarchy tree left hand side interface hierarchy dag 
curved lines indicate filled class implements filled interfaces 
method call return instantiations filled class pre post condition implications classes checked 
show chapter compile contracts hierarchy checking performed manner 
chapter contract compilation contract monitor acts compiler 
concretely eliminates contracts program source text insert statements validate contracts runtime 
process best described compiler consumes language containing contract annotations produces 
chapter develops contract compiler java properly handles hierarchy violations 
chapter organized sections 
describes contract compiler series examples 
second discusses integrate compiler java compilation model discusses efficiency issues 
check contracts assign blame contract compiler consumes java language contract specifications methods interfaces produces plain java augmented new statements 
new statements accepts string naming class blamed respective failure 
executed program halts appropriate error message blames author class named argument 
abstractly contract compiler transfers pre condition post condition contracts wrapper methods check contracts call corresponding original method 
rewrites calls methods contracts calls appropriate wrapper method 
furthermore method calls elaborated program rewritten call wrapper methods static type object method invoked 
translation depends type analysis takes account type hierarchy 
section overview contract compiler integrated type checker 
shows series hierarchy diagrams provide outline section 
diagram corresponds configuration classes interfaces 
boxes represent classes interfaces 
classes named interfaces named single lines arrow heads represent class interface inheritance double lines arrow heads represent interface implementation 
flat contract checking diagram illustrates simplest case 
contains program text corresponding diagram translation 
program consists classes main original class method pre condition post condition 
translation methods original wrapper method name wrapper method synthesized name original method name class 
wrapper method accepts additional argument naming class calling method blamed pre condition fails 
lines wrapper method checks pre condition blames class caller violation occurs 
line runs original method 
lines checks post condition class violations post condition 
contract compiler rewrites call main call wrapper method passing class void int 
pre 
pre condition 
post 
post condition 
class main public static void main string argv new gg class void int 
void string tbb int 
pre condition 
tbb 
post condition 
ggg class main public static void main string argv new main gg pre post condition checking main additional argument blamed pre condition violation 
interface implementation diagram contains class interface 
class implements interface 
previous example method called pre condition checked pre condition checked depends static type object method invoked 
may wrapper methods generated check respective pre post conditions 
example diagram adds twist simple translation 
instances substitutable contexts expecting check hierarchy formed 
case pre conditions imply pre conditions post conditions imply post conditions method call possibilities pre conditions 
clearly true violation occurred false pre condition hold caller blamed 
pre condition true pre condition false hierarchy malformed author blamed 
pre condition false pre condition true hierarchy formed hierarchy violation signaled 
case object viewed instance pre condition checking code blames caller failing establish pre condition 
object viewed instance error occurs violation signaled 
logic post condition checking similar 
perform hierarchy checks hierarchy checking methods generated interface class method 
classes new methods inserted translated version class 
interfaces new methods inserted new class generated interface 
hierarchy checking methods recursively combine result pre post condition rest pre post condition results hierarchy determine hierarchy formed 
contains translation illustrates compiler deals diagram 
wrapper methods augmented calls hierarchy checking methods pre hier post hier lines 
pre hier post hier methods ensure pre post condition hierarchies wellformed 
checkers appear checkers class analogous omitted 
pre condition checking pre hier accepts arguments original method returns value pre condition 
check hierarchy method calls checkers pre hier method line ensures pre condition hierarchy formed 
checkers refer object contracts checked current object passed checkers pre hier example hierarchy trivially formed supertypes 
result checkers pre hier value pre condition bound sup pre hier shown line 
pre hier binds res value pre condition line 
tests pre condition implies interface void int pre 
pre condition post 
post condition class implements void int 
pre 
pre condition post 
post condition interface 
class checkers 
class implements void 
void string tbb int 
void string tbb int 
pre condition 
tbb pre hier 
post condition 
post hier false boolean pre hier int boolean sup checkers pre hier boolean res 
pre condition sup jj res sup res return res gg void post hier string tbb boolean int boolean res 
post condition jj res res checkers post hier res tbb ggg hierarchy checking pre condition expression sup jj res line logically equivalent sup res implication holds pre hier returns result pre condition line 
evaluates statement line aborts program blames bad extension post condition checking recursively traverses interface class hierarchy order pre condition checking 
contrast pre condition checking postcondition checking accumulates intermediate results needed check hierarchy returning 
example arguments post hier accumulators tbb line class blamed failure value post condition subtype initially false relevant subtypes 
determine hierarchy violation res bound value post condition line implication checked line 
hierarchy flawed point tbb blamed line 
example happen res initially false code needed general 
checkers post hier called line value post condition name 
blame bad hierarchy discovered checkers post hier falls diagram adds interface checking picture 
principle contract checkers program diagram diagram 
additional interface generates additional class checking additional level hierarchy contract checking proceeds diagram 
class inheritance diagram introduces class inheritance implementation inheritance 
poses complex problem contract compiler 
additional interface new methods generated check hierarchy 
new hierarchy checking methods instance derived class created 
program creates instances hierarchy checked 
instances check entire hierarchy including pre post conditions 
general conditions interface superclass originally instantiated class checked method call method return ensure hierarchy sound 
multiple inheritance diagram shows interface super interfaces 
discussion chapter hierarchy checkers check pre condition implies precondition pre condition implies pre condition alternative mentioned footnote chapter ensure conditions equivalent 
easily checked point hierarchy checker 
interface void int pre 
pre condition 
post 
post condition 
interface void int pre 
pre condition 
post 
post condition 
interface extends void int pre 
pre condition 
post 
post condition 
class checkers 
class checkers 
class checkers static boolean pre hier int boolean sup checkers pre hier jj checkers pre hier boolean res 
pre condition 
sup jj res sup res return res gg static void post hier string tbb boolean int boolean res 
post condition 
jj res res return checkers post hier res checkers post hier res tbb ggg hierarchy checking multiple inheritance boolean identity tells just check disjunction pre conditions implies precondition 
accordingly shown checkers pre hier method hierarchy checker combines results checkers checkers pre hier methods disjunction binds sup lines 
contract checker traversal type hierarchy remains 
post conditions take advantage similar boolean identity 
combine recursive calls conjunction compute result postcondition hierarchy checking method shown post hier definition lines 
environmental considerations contract compiler need install class loader generate extra java class files require extra class libraries evaluation 
features design enable contract compiler integrate seamlessly java compilation model existing java contract checkers 
smooth interaction due fact compiler produces single java class file source class interface 
described previous section contract compiler generates additional class interface 
implementation augment class file generated interface information add wrapper hierarchy methods class implements interface 
done custom attribute class file contains byte codes contracts 
hierarchy checking methods interfaces copied classes implement interfaces 
require code duplication programs 
code examples section method names wrappers valid java identifiers 
implementation special names wrapper methods class files eliminate name clashes programmer defined method names 
additionally implementation add new blame assigning statements java inline code raises exception blame guilty party 
contract compiler uses wrapper methods check contracts redirects method call call wrapper methods programmer original methods available class 
class files contract compiler generates linked existing pre compiled byte codes 
allows pre existing byte code distributions java code interoperate code compiled contract compiler cost losing contract enforcement 
existing byte code libraries bypass wrapper methods call original methods directly pre condition post condition hierarchy checking contract checking occurs 
performance compiler design may far expensive traditional checkers due hierarchy checking 
traditional contract checkers combine contract corresponding contracts supertype 
approaches contract checking evaluate contracts method call 
post condition checking approaches check contracts contracts succeed 
precondition checking traditional checkers possibly short cut checks contract checker check leads mis assigned blame explained earlier additional cost pays additional guarantees approach 
additionally method chaining hierarchy checking methods unnecessary 
class interface hierarchies static method chaining replaced nested tests 
done naive manner lead code explosion 
optimizing java compiler inline hierarchy checking method calls profitable 
chapter contract soundness failure existing tools properly assign blame contract violations traced directly lack fundamental research contract checking 
address problem chapter develops formal model java contracts form calculus 
starting point classic java calculus :10.1.1.23.8118
specifies syntax type system semantics small java language 
extended mechanisms simple pre post condition contract specifications 
extended calculus contract checking modeled translation extended language contracts class java calculus extended simple error signalling primitives 
calculus state prove contract soundness theorem 
theorem guarantees contract compiler correctly catches contract violations correctly assigns blame contract violations 
chapter divided sections 
section introduces contract checking framework shows type soundness framework 
section presents syntax section presents type checker 
section presents contract elaborator 
section presents operational semantics 
section states proves contract soundness theorem contract elaborator 
type soundness contract soundness development meaningful type systems benefited developed theory 
particular type systems satisfy type soundness theorem ensures type checker respects language semantics specifies kinds runtime errors program may signal 
type soundness theorem parts 
specifies kind errors run time exceptions evaluation typed program allowed trigger 
second implies certain properties hold evaluation typed subexpressions 
example addition operation ml program receive numbers ml programs terminate errors due misuse addition operation 
array indexing operation receive integer index integer may array range 
ml program terminate non integer array index may terminate due bounds array index 
show contract checking system satisfy contract soundness theorem 
type soundness theorem contract soundness theorem parts 
states kind errors evaluation monitored program may signal 
second guarantees specified hierarchy interfaces classes satisfies implications stated pre post conditions overridden methods 
syntax contains syntax contract java adapted flatt :10.1.1.23.8118
syntax divided parts 
programmers syntax write programs 
type checker elaborates syntax syntax contains type annotations evaluator contract compiler 
contract compiler elaborates syntax syntax 
elaborates pre post conditions monitoring code result accepted evaluator 
program sequence class interface definitions followed expression represents body main method 
class definition consists sequence field declarations followed sequence method declarations contracts 
interface consists method specifications contracts 
contracts arbitrary java expressions type boolean 
method body class carried study complex contract specification language plain java expressions suffice express important contracts 
additionally single language preconditions post conditions expressions simplifies presentation proofs 
defn defn class extends implements field meth interface extends imeth field fd meth md arg body pre post imeth md arg pre post arg var body new var null fd fd md super md view binding true false binding var var variable name class name object interface name empty fd field name md method name boolean surface syntax defn defn class extends implements field meth interface extends imeth field fd meth md arg body pre post imeth md arg pre post arg var body new var null fd fd md super md view binding true false binding var var variable name class name object interface name empty fd field name md method name boolean typed contract syntax defn defn class extends implements field meth interface extends imeth field fd meth md arg body imeth md arg arg var body new var null fd fd md super md view binding true false return binding var var variable name class name object interface name empty fd field name md method name boolean core syntax contract java syntax contracts compiled away sets names variables classes interfaces fields methods assumed mutually distinct 
meta variable method signatures variable lists var environments mapping variables types 
ellipses baseline indicate repeated pattern continued sequence centered ellipses 
indicate arbitrary missing program text spanning class interface definition 
class name declared class 
class 
field names class declaration unique class 

fd 
fd 
fd fd method names class declaration unique class 

md 


md 


md md interface name declared interface 
interface 
method name unique md var varn 
var varn distinct class declared immediate subclass class extends 

field declared class hc fd ti class 

fd 
method declared class hmd var varn ei class 

md var varn feg 
interface declared immediate interface extends 


method declared interface hmd interface 

md arg argn pre post ea 
class declares implementation interface class 
implements 


class subclass transitive reflexive closure classes extended defined rng dom class hierarchy order antisymmetric method overriding preserves type hmd ei hmd field contained class hc fd ti hc fd ti minfc hc fd method contained class hmd ei hmd ei minfc hmd predicates relations model contract java interface transitive reflexive closure extended implemented interfaces defined rng rng dom interface hierarchy order antisymmetric class implements interface interface inheritance methods consistent hmd hmd method contained interface hmd hmd classes supply methods implement interfaces md hmd hmd ei class methods instantiated hmd ei type subtype type immediate subtype field method type method interface hmd hmd field method type method class hmd hmd ei field method type field type hc fd ti hc fd ti prep pre condition contract method interface prep hi mdi interface 
md arg pre post 
prep pre condition contract method class prep hc mdi class 
md arg body pre post 
post condition contract method interface hi mdi interface 
md arg pre post 
post condition contract method class hc mdi class 
md arg body pre post 
predicates relations model contract java ii indicating method overridden subclass class instantiated 
java body method just expression result result method 
java classes instantiated new operator class constructors contract java instance variables initialized null 
view forms represent java casting expressions capability binding variables locally 
code examples omit extends implements clauses appear 
type checker translates syntax syntax 
inserts additional information underlined contract elaborator evaluator 
support contract elaboration method calls annotated type object method called 
support evaluation field update field annotated class containing field calls super annotated class 
contract elaborator produces syntax evaluator accepts 
pre post conditions removed interfaces classes contract expressions inserted elaborated program 
syntax adds constructs language 
constructs signal contract violations 
expressions shape return mark method returns 
type indicates type object method invoked parallel type annotations method calls class name class defined invoked method 
standard java contract java programmer write return expressions program 
evaluator introduces return expressions executes program 
annotations statement proof contract soundness theorem 
pre post condition contracts constructors treated contracts methods overridden 
valid contract java program satisfies number predicates described figures 
example predicate states class name defined program additionally number relations syntax valid contract java program 
relation associates class name class extends overloaded relations capture field method declarations syntax summarizing relations induce second set relations predicates summarize class structure program 
subclass relation partial order predicates hold 
case classes declared form tree object root 
program describes tree classes decorate class tree collection fields methods accumulates local declarations inheritance 
source declaration field method class computed finding minimum superclass farthest root declares field method 
algorithm described precisely relations 
relation retains information source class field retain source class method 
reflects property java classes fields overridden instances subclass contain field methods overridden may inaccessible 
interfaces similar set relations 
declaration relation induces relation classes single interface multiple proper superinterfaces order forms dag tree 
set methods interface described union interface declared methods methods superinterfaces 
classes interfaces related implements declarations captured relation 
relation set edges joining class tree interface graph completing subtype picture program 
type full graph subtype ancestors 
subtype structure program captured relation type subtype type program written conditions holds type classes derived interfaces extension written class interface implements implements interface derived class relations pre post relate expressions pairs methods types 
expression pre condition program written pre ht mi expression appears program declared precondition similarly expression postcondition program post ht mi 
type elaboration type elaboration rules contract java defined judgements elaborates type defn defn defn elaborates defn meth meth meth class elaborates meth imeth imeth imeth interface elaborates imeth elaborates type type subsumption valid type defn defn defn defn defn defn meth meth class 
fd fd meth class 
fd fd meth meth imeth imeth interface 
imeth interface 
imeth imeth var varn var varn boolean ret ea boolean md var varn pre post ea md var varn pre post var varn boolean ret ea boolean md var varn pre post ea md var varn pre post var varn boolean ret ea boolean md arg argn pre post ea md arg argn pre post new new var dom var var var null null hc fd ti fd fd hc fd ti ev fd ev fd context sensitive checks type elaboration rules contract java hmd md en md hmd var varn super md en super md view dom dom view view var 
var var 
varn en var 
varn true true boolean false false boolean boolean dom dom empty context sensitive checks type elaboration rules contract java ii complete typing rules shown figures 
program typed class definitions final expression typed 
definition turn typed field method declarations legal types method body expressions typed 
expressions typed elaborated context environment binds free variables types 
example get set rules fields determine type instance expression calculate class tagged field name yields type field class installed annotation 
set rule right hand side assignment match type field match may exploit subsumption coerce type value supertype 
type elaboration rules translate expressions access field call super method call normal method annotated expressions see underlined parts 
field uses annotated expression contains compile time type instance expression determines class containing declaration accessed field 
super method invocations annotated expression contains compile time type determines class contains declaration method invoked 
regular method calls annotation contains type object called 
contract expressions typed type boolean 
addition precondition expressions may contain arguments checked method post condition expressions may contain result method 
variable ret refers result method post condition 
contract elaboration contract checking modeled translation called elab syntax syntax 
contract checking triggered method calls need understand elab deal 
consider code fragment iconsole factory 
display crunch time 
programmer know kind console represents run time establish preconditions display iconsole specifies 
code elab produces method call test preconditions display iconsole 
test fails author method call mistake 
test succeeds contract monitoring code check ancestor portion class interface hierarchy determined class tag 
hierarchy checks ensure precondition overridden method implies precondition overriding method postcondition overriding method implies postcondition overridden method 
perform forms checking elab adds new classes check subtype hierarchy inserts methods existing classes check pre post conditions 
method class elaborator inserts wrapper methods type instances class 
wrapper methods perform pre postcondition checking call hierarchy checkers 
additionally elaborator redirects method call invokes appropriate wrapper method static type object method invoked 
translation chapter differs previous chapter 
previous chapter hierarchy checking methods added class 
hierarchy checking methods separated classes 
simplifies model proof contract soundness 
translations check contracts program 
invocation elaborator inserts display iconsole wrapper method console class console class cast iconsole 
additionally rewrites call display method call display iconsole method type iconsole 
display iconsole method checks iconsole pre condition pre condition hierarchy instantiated class upwards 
display console ml tradition word type refer static type determined type checker 
words class tag refer called dynamic run time type 
prog defn defn defn pre defn post main defn defn defn defn defn defn pre defn post defn defn pre defn post defn imeth imeth imeth pre meth pre imeth post meth post interface extends imeth imeth interface extends imeth imeth class check pre imeth pre 
imeth pre class check post imeth post 
imeth post defn meth meth meth pre meth pre meth post meth post meth method class extends implements meth meth class extends implements meth meth method method class check pre extends object meth pre 
meth pre class check post extends object meth post 
meth post meth md var var pre post md var var meth md arg arg pre post md arg arg wrap pre ht mdi post ht mdi md 

md 
string cname new check pre md 
ret md 
new check post md dummy true md 
md cname blame compilation method calls original display method 
returns display iconsole method checks iconsole post condition post condition hierarchy instantiated class upwards 
rest section presents elaborator concretely example console classes interfaces abstractly judgements define elaborator 
object md var varn pre post ea pre boolean md var 
varn new check pre md var 
varn jj 
res ea jj res res res object md var varn pre post ea pre boolean md var 
varn new check pre md var 
varn jj new check pre md var 
varn jj 
res ea jj res res res md var varn pre post ea pre boolean md var varn new check pre md var 
varn jj 
res jj res res res blame compilation ii object md var varn pre post ea post boolean md string tbb boolean md var 
varn res ea jj res res new check post md res md var 
varn 
tbb object md var varn pre post ea post boolean md string tbb boolean md var 
varn res ea jj res res new check post md res md var 
varn new check post md res md var 
varn 
tbb md var varn pre post ea post boolean md string tbb boolean md var 
varn res ea jj res res new check post md res md var 
varn 
tbb blame compilation iii exp new new null null var var ev fd ev fd fd fd call md 
en md 
md 
en md 
en super md en super md view view var 
varn en var 
varn true true false false blame compilation iv formally contract elaborator defined judgements program compiles program defn defn defn pre defn post defn compiles defn checkers defn pre defn post imeth imeth imeth compiles imeth meth meth meth compiles meth class meth meth meth checks pre post conditions meth blames contract violations 
compiles blames contract violations 
imeth pre imeth imeth checks hierarchy pre condition imeth imeth post imeth imeth checks hierarchy post condition imeth judgement program elaboration judgement 
defines elab elab occasionally elab applied syntactic categories expressions 
case context dictates implied program elab applied result elaborated expression program 
judgement builds definitions definition original program 
derived original definition 
second third pre post condition hierarchy checking classes respectively 
judgement removes interface method contracts 
judgements produce annotated class 
judgement constructs wrapper methods check contracts 
judgement re writes methods removes class method contracts 
judgement rewrites expressions method calls re directed wrapper methods type call 
final judgements pre post produce methods pre post condition hierarchy checkers 
judgments figures 
defn rule defn rule show definition original program generates definition additional classes 
definition corresponds original definition contracts removed case classes wrapper methods inserted 
wrapper methods check pre condition post condition violations invoke hierarchy checkers 
elaborator inserts wrapper methods types instances class 
consider console class chapter 
elaboration adds wrapper methods getmaxsize instances console types iconsole console 
elaborator adds wrapper methods display class console implements iconsole int getmaxsize 
int getmaxsize iconsole 
int getmaxsize console 
void display string 
void display iconsole 
void display console 
similarly runningconsole prefixedconsole elab adds methods instances classes may take types 
runningconsole class runningconsole extends console int getmaxsize 
int getmaxsize iconsole 
int getmaxsize console 
int getmaxsize runningconsole 
void display string 
void display iconsole 
void display console 
void display runningconsole 
wrap rule specifies shape wrapper methods 
uses program class wrapper method appears type method called method header md 

wrapper method accepts arguments original method plus extra argument naming class program text contains method call 
wrapper method checks pre condition check fails blames calling context establishing required precondition 
pre condition succeeds wrapper calls pre condition hierarchy checker pre condition hierarchy checker traverses class interface hierarchy making sure subtype behavioral subtype pre conditions 
hierarchy checking succeeds wrapper method calls original method 
method returns saves result variable md checks post condition calls post condition hierarchy checker 
pre condition hierarchy checkers post condition hierarchy checker ensures subtype behavioral subtype post conditions 
post condition checking succeeds wrapper method delivers result wrapped method 
additionally wrap rule rewrites contract expressions preand post condition methods invoked contracts checked 
console display console wrapper method void display console string string cname length getmaxsize new check console pre display display display new check console post display dummy true display cname omit annotations inserted type checker clarify presentation 
original console class display method post condition expression wrap rule eliminated 
variable display bound result method post condition 
arguments check console post initial values accumulators explained 
second third classes definitions introduced defn defn rules hierarchy checkers 
hierarchy checker responsible checking portion hierarchy combining result rest hierarchy checkers 
pre post condition checking hierarchy checking begins class tag object static type object 
example consider hierarchy diagram code fragment new invoked hierarchy checkers ensure hierarchy formed 
instances cast boxed portion hierarchy checked 
invoked hierarchy checking classes ensure pre condition implies pre condition pre condition implies pre condition 
similarly returns post conditions checked ensure post condition hierarchy formed 
running console example classes generated check iconsole pre check console pre check runningconsole pre check prefixedconsole pre check iconsole post check console post qk qk example hierarchy diagram check runningconsole post check prefixedconsole post 
hierarchy checking classes method method original class 
methods hierarchy checking classes names methods original class purpose different 
hierarchy checking methods check pre post condition method 
combine result results rest hierarchy checking determine hierarchy violations 
example hierarchy checking class contains getmaxsize method display method 
pre rule produces pre condition hierarchy checker md method interface resulting method accepts arguments md accepts plus binding 
argument passed contract checking code test state object 
hierarchy checking method returns result precondition md recursively calls hierarchy checkers immediate super interfaces combines results disjunction 
second evaluates pre condition md checker ensures hierarchy formed checking pre conditions super methods imply current pre condition 
implication holds checker returns res value pre condition 
implication hold hierarchy checker method signals hierarchy error blames extending interface 
rule classes analogous 
pre condition checkers runningconsole console display methods class check runningconsole pre extends object boolean display runningconsole string new check console pre display res true jj res res res runningconsole class check console pre extends object boolean display console string new check iconsole pre display res length getmaxsize jj res res res console post rule specifies post condition hierarchy checking method 
postcondition hierarchy checker similar pre condition checker 
returning truth value condition post condition checker accumulates results conditions argument 
accumulator fashion means post condition checker uses recursive traversal type hierarchy precondition checker checks implications reverse direction 
tbb argument accumulator 
represents subclass blamed implication hold 
mentioned initial values accumulators tbb dummy false respectively 
post condition checker particular class blames subclass hierarchy violation post condition checker assigns blame 
initial false passed guarantees blame assigned checker dummy ignored 
additionally highest class interface hierarchy blamed possibly violate hierarchy 
code post condition hierarchy checker getmaxsize runningconsole console class check runningconsole post extends object boolean getmaxsize string tbb boolean runningconsole int getmaxsize res getmaxsize jj res res new check console post getmaxsize runningconsole res getmaxsize tbb class check console post extends object boolean getmaxsize string tbb boolean console int getmaxsize res getmaxsize jj res res new check iconsole post getmaxsize console res getmaxsize tbb call rule shows elaboration re writes method calls 
method call call wrapper method type object method invoked 
example code fragment chapter getmaxsize methods inserted directly runningconsole console classes directly 
iconsole factory 
display crunch time rewritten iconsole factory 
display iconsole crunch time gathers code fragments running example 
left column contains proper interfaces classes enriched wrapper methods 
right column contains hierarchy checking classes plus translation method call 
evaluation operational semantics contract java defined contextual rewriting system pairs expressions stores 
evaluation rule shape si 
si reduction rule name store mapping variables class tagged field records 
field record mapping field names values 
consider configurations expressions stores equivalent renaming variables store bind free variables expression 
expression program defined 
complete evaluation rules 
example call rule models method call replacing call expression body invoked method syntactically replacing formal parameters actual parameters 
dynamic aspect method calls implemented selecting method run time type object store 
contrast super reduction performs super method selection class annotation statically determined type checker 
noteworthy rules call super 
reduce return expressions 
return expressions markers signal post condition contract violations occur 
inserted method call super call reductions statement contract soundness theorem 
interface iconsole int getmaxsize void display string class console implements iconsole int getmaxsize 
int getmaxsize iconsole 
int getmaxsize console 
void display string 
void display iconsole 
void display console string string cname length getmaxsize new check console pre display display display new check console post display dummy true display cname class runningconsole extends console int getmaxsize iconsole 
int getmaxsize console 
int getmaxsize runningconsole 
void display string 
super display string substring 
getmaxsize 
void display iconsole 
void display console 
void display runningconsole 
class prefixedconsole extends console int getmaxsize iconsole 
int getmaxsize console 
int 
string return void display string super display void display iconsole 
void display console 
void 
class check iconsole pre 
class check console pre extends object boolean display console string new check iconsole pre display res length getmaxsize jj res res res console gg class check runningconsole pre extends object boolean display runningconsole string new check console pre display res true jj res res res runningconsole class check prefixedconsole pre 
class check iconsole post 
class check console post extends object boolean getmaxsize string tbb boolean console int getmaxsize res getmaxsize jj res res new check iconsole post getmaxsize console res getmaxsize tbb class check runningconsole post extends object boolean getmaxsize string tbb boolean runningconsole int getmaxsize res getmaxsize jj res res new check console post getmaxsize runningconsole res getmaxsize tbb class check prefixedconsole post 
iconsole 
display iconsole crunch time elaborated console example 
object object null true false fd fd fd md 
md 

super md 

view var 
var var 
object md 
vn si 
return fe object var vn varn si call object hc fi hmd var varn ei super object md 
vn si 
return fe object var vn varn si super hmd var varn ei return si 
si return new si 
object object hc fi new object dom fc fd null hc fd ti object fd si 
si get object hc fi fd object fd si 
object hc fd set object hc fi view object si 
object si cast object hc fi var 
varn vn si 
var vn varn si true si 
si iftrue false si 
si iffalse si 
si seq 
gc hhe closed si 
herror violated pre condition si pre si 
herror violated post condition si post si 
herror bad extension si hier view object si 
herror bad cast si object hc fi view null si 
herror bad cast si null fd si 
herror dereferenced null si null fd si 
herror dereferenced null si nset null md 
vn si 
herror dereferenced null si operational semantics contract java contract soundness contract monitoring tool faithfully enforce programmer contracts 
contract soundness theorem guarantees property 
relates evaluation program original program contracts removed 
imagine evaluation proceeding program contracts contract elaborated program erase erase 
hs 
hs 
elab elab 
hs 
hs 
qs theorem relates top evaluation bottom 
intuitively program contracts reaches method call pre condition hold hierarchy sound elaborated program signal corresponding pre condition hierarchy violation 
similarly program contracts reaches method return post condition hold hierarchy sound elaborated program signal corresponding post condition hierarchy violation 
contracts model arbitrary java expressions may side effects raise errors may affect behavior underlying program 
considering role contracts logical assertions state space undesirable 
restrict attention contracts effect free 
definition effect free expression 
expression effect free store free variables included dom exists value si 
hv si 
key definition effect free expressions evaluate value changing store signalling error 
mean allocates 
garbage collection non deterministic reduction step contract expression practice approaches enforcing restriction different pros cons 
may allocate long newly allocated objects garbage evaluation contract produces value 
order state contract soundness theorem give meaning contract checking arbitrary programs 
definition lists conditions correspond contract violation 
definition contract violation 
pre condition failure program state md 
si pre condition contract violation pre ht mdi si 
hfalse fx formal parameters md declared store 
post condition failure program state return fvg si post condition contract violation post ht mdi ret si 
hfalse store pre condition hierarchy failure program state md 
si hc fi pre condition hierarchy violation exist types conditions hold post hs mdi post hs mdi si 
hfalse si si 
htrue si fx formal parameters md declared fx formal parameters md declared post condition hierarchy failure program state return fvg si hc fi pre condition hierarchy violation exist types conditions hold pre hs mdi pre hs mdi ret si 
htrue si ret si 
hfalse si definition specifies contract soundness 
intuitively soundness guarantees elaborated programs respect contracts original program 
concretely program contract elaborator produces signals error evaluation program contracts reach corresponding contract failure 
program contract elaborator produces signal contract error program contracts locally contract sound step evaluation 
definition contract soundness 
elaborator elab contract sound program defn pre post conditions effect free expressions conditions holds elab 
herror violated pre condition si store class erase 
md si md si pre condition contract violation md elab 
herror violated post condition si store class erase 
return fvg si return fvg si post condition violation md elab 
herror bad extension si store type erase 
si si hierarchy violation state hp erase 
locally contract sound respect recall erase just contract annotations removed 
roughly local contract soundness configuration si means store contracts hold necessary relations contracts hold 
precisely states method calls method returns locally contract sound 
state evaluate method call locally sound conditions true 
pre condition method satisfied 
second pre condition hierarchy behaviorally formed 
type pre condition imply subtypes pre conditions method invoked 
similarly state perform method return locally sound post condition method satisfied post condition hierarchy behaviorally formed 
definition local contract soundness 
program state si locally contract sound respect contract java program conditions holds 
hc fi exists pre ht mi hy si 
htrue ui store exists pre hs mi pre hs mi hx si 
hb hx si 
hb return exists post ht mi hy si 
htrue ui store exists post hs mi post hs mi hx si 
hb hx si 
hb method call method return 
theorem 
elaboration elab contract sound 
proof sketch 
program 
assume elab signal contract error 
elab contract sound show reduction step erase locally contract sound 
lemma program reduction step erase takes elab takes reduction potentially larger context point elab raises contract error erase terminates 
elab raises contract error erase corresponding method call method return 
elaboration change expressions method calls erase elab synchronized long method calls 
consider method call 
reductions erase look erase 

si 
return 
si body method ellipses contain method calls reductions method call identical elab 
elaborated version calls wrapper method version contracts just calls method directly 
elab signals contract error hierarchy error lemma holds erase took method call steps synchronized 
know wrapper method effects contract expressions effect free elab signal pre condition error hierarchy error 
reduction sequence looks elab 

si 

si 
return 
si extra context remainder wrapper method checks post conditions post condition hierarchy 
inductive argument reduction sequence see long erase reduction sequence contain method returns lemma holds 
similar argument applies method returns 
method return elab discharge extra context built method call 
extra context corresponds portion wrapper method wrapped method returns 
code signals contract violation know erase returns method 
doesn reduction sequences remain synchronized 
pictorially reduction sequences look erase elab pre condition checking post condition checking method call 
smaller arrows extra steps elab takes method call 
lemma prove theorem 
assume elab signals contract violation 
lemma know erase method call method return corresponds contract violation signaled elab 
inspection wrapper methods follows method call return erase enters contract violation 
remains show elab signals contract violation erase locally contract sound step reduction sequence 
si step reduction sequence starting erase 
decompose evaluation context method call evaluation context return instruction locally hierarchy sound 
assume decompose context method call 
show bullet definition true 
elab reached method call previous argument know wrapper method invoked 
wrap rule see pre condition check succeeded 
remains show exists pre hs mi pre hs mi hx si 
hb hx si 
hb states types pre conditions evaluate hierarchy checkers traverse entire hierarchy checking pre condition type implies pre condition subtypes holds 
step locally hierarchy sound 
similarly decomposes context method return elab returned wrapper method code invoked step locally contract sound 
chapter contracts higher order functions higher order typed programming language implementations static type discipline prevents certain abuses language primitive operations 
example programs apply non functions add non numbers invoke methods non objects statically rejected 
languages go 
run time systems dynamically prevent additional abuses language primitives 
example primitive array indexing operation aborts receives bounds index division operation aborts receives zero divisor 
techniques dramatically improve quality software built hot languages 
advent module languages support type abstraction hot languages empower programmers enforce abstractions type level 
abstractions expressive power language designer uses specifying language primitives 
dynamic aspect second class citizen 
programmer manually insert dynamic checks blame assigned automatically checks fail 
worse possible programmer manually insert checks call sites may unavailable modules 
chapter empowers hot programmers refine type specifications abstractions additional dynamically enforced invariants 
presents assertion contract checker languages higher order functions 
section discusses challenges contracts higher order functions 
section introduces subtleties assigning blame higher order contract violations series examples scheme 
section presents con typed higher order functional programming language contracts 
section specifies meaning con section provides implementation 
section contains type soundness result proves implementation matches calculus 
section shows extend calculus function contracts range depends input function section discusses interactions contracts tail recursion 
order function contracts higher order function contracts procedural languages contracts simple interpretation 
consider contract int int val rec 
states argument int greater produces int 
enforce contract contract compiler inserts code check proper range called check result proper range returns 
proper range caller blamed contractual violation 
symmetrically result proper range blame falls 
world detecting contractual violations assigning blame means merely checking appropriate predicates defined points program evaluation 
straightforward mechanism checking contracts generalize languages higher order functions 
consider contract int int int val rec proc 
contract domain states accepts int int functions promises apply ints larger 
turn functions obliged produce ints 
contract range produce ints 
may contract matches domain contract accept functions stricter contracts int int val rec 
functions explicit contracts functions process external data read num int int val rec read num 
read nth entry file 
read num functions behavior depends context val rec dual purpose 
predicate global state 

long context properly established applies argument 
clearly algorithm determine proc matches contract 
worse impossible tell applies proc ints greater may hand proc function 
additionally higher order functions complicate blame assignment 
order functions blame assignment directly linked pre post condition violations 
precondition violation fault caller post condition violation fault callee 
higher order world promises obligations tangled complex manner due function valued arguments 
key observation higher order contract checking contract checker ensure argument meets contract called 
wait proc applied 
point ensure proc argument greater 
similarly proc returns ensure proc result range 
enforcing contracts manner ensures contract violation signalled soon contract checker prove contract violated 
proof takes form order witness violation 
additionally witness enables contract checker properly assign blame violation 
example contracts section contains series scheme examples explain contracts written difficulties checking 
examples illustrate syntax basic principles contract checking 
sections discuss problems contract checking higher order world 
section explains important contracts class values 
section demonstrates contracts help callbacks common higher order functions stateful world 
sections include examples drscheme code base demonstrating issue important practice 
contracts look example sqrt function sqrt number number define contract sqrt 

tradition design programs sqrt function proceeded ml type specification 
scheme define define contract expression consists variable expression initial value function case 
addition second subexpression define contract specifies contract variable 
contract expressions simple predicates function contracts 
function contracts turn consist pair contracts domain function range function cd 
cr 
domain portion sqrt contract ensures receives positive number 
range portion contract guarantees result bigger zero 
example illustrates general contracts check certain aspects function behavior complete semantics function 
contract position definition arbitrary expression evaluates contract 
allows improve contract sqrt defining bigger zero 
predicate definition sqrt contract bigger zero 
number boolean define bigger zero 
sqrt number number define contract sqrt bigger zero 

bigger zero 

contract sqrt strengthened making sure result properly relates argument 
dependent function contract constructor allows programmer specify range contracts depend values arguments 
constructor similar range position contract simply contract 
function accepts arguments original function returns contract cd 
arg cr example dependent contract sqrt sqrt number number define contract sqrt bigger zero 

res bigger zero 
abs res res 
contract addition stating result sqrt positive ensures square result argument 
module preferences scheme contract provide add panel open dialog add panel panel panel void define contract add panel 
new child children send send new child get parent get children eq 
car children new child 
panel set 
panels cons panel panels panels listof panel panel define panels null open dialog void define open dialog object dialog sp object single panel children map call panel sp panels call panel panel 
panel panel panel define call panel sp panel panel sp contract specified add panel enforcement order types key checking assertion contract higher order function postpone contract enforcement higher order function receives flat value argument produces flat value result 
section demonstrates delays necessary discusses ramifications delaying contracts 
consider toy module module delayed scheme contract provide save saved integer integer define saved save integer integer void define contract save bigger zero 
bigger zero 
set 
saved integer integer define bigger zero 
bigger zero 
saved module declaration consists name module language module written provide declaration series definitions 
module provides save variable saved holds function supposed map positive numbers positive numbers 
exported module contract 
getter save visible accessors saved function save stores new function invokes saved function 
naturally impossible save detect value saved applied positive numbers determine argument worse save guarantee time saved value applied return positive result 
contract checker delays enforcement save contract save argument applied returns 
accordingly violations save contract detected called 
general higher order contract checker able track contracts evaluation point contract established call site save discovery contract violation return site potentially evaluation 
assign blame contract checker able report violation discovered contract established 
details module language see mzscheme manual 
module preferences scheme provide add panel open dialog add panel panel panel void define add panel panel set 
panels cons panel panels panels listof panel panel define panels null open dialog void define open dialog object dialog sp object single panel children map call panel sp panels call panel panel 
panel panel panel define call panel sp panel new child panel sp children send send new child get parent get children eq 
car children new child contract error panel new child contract manually distributed toy example clearly contrived 
underlying phenomenon common 
real world example consider drscheme preferences panel 
plug ins drscheme add additional panels preferences dialog 
extensions register callbacks add new panels containing gui controls buttons list boxes pop menus preferences dialog 
gui control needs values parent control callback invoked control manipulated 
gui controls need additional values label list choices 
order add new preference panels extensions define function accepts parent panel creates sub panel parent panel fills sub panel controls configure extension returns 
functions registered calling add panel time user chooses drscheme preferences menu item drscheme constructs preferences dialog registered functions 
contract add panel ensures add panel arguments functions 
addition guarantees result call argument child parent panel 
ensures ordering preferences dialog children panels corresponds order calls panel shows code implements add panel open dialog boxed contract attached definition add panel body add panel saves panel making function list 
user opens preferences dialog functions called contracts checked context call panel comparison contains checking code written higherorder contract checking 
boxed portion excluding inner box contract checking code 
code enforces contracts code implements preferences dialog 
decreases readability contract call panel client programmers need determine portion code contract checking portion code performing function 
addition author preferences module find call site higher order function 
finding sites general impossible practice call sites collaborators code source available 
blame contravariance assigning blame contractual violations world class functions complex 
boundaries cooperating components obscure world order functions 
addition invoking component exported functions component may invoke function passed component 
applying class functions corresponds flow values components 
accordingly blame corresponding contract violation lie supplier bad value matter bad value passed directly applying exported function applying class function 
consider example little detail 
imagine body call integer integer integer define contract greater 

zero 

zero 
point invokes greater 
portion contract fails 
violation domain contract order world fault caller 
case blame violation lie promises apply argument values greater 
reversal blame due contra variance function application occurs functions class values 
imagine variation example applies 
imagine returns 
return value blamed producing bad result 
blame contract result checked returns 
accordingly trigger contract violation error contract callers supply functions produce numbers greater 
case blamed supplying bad value order function contract checking parties involved con tract function caller 
order function contract checking general rule applies blame assignment 
function responsible positive positions covariant positions contract function caller responsible negative positions contravariant positions contract 
means contract enforcement mechanism able track negative positive positions contract determine party blame 
problem assigning blame naturally appears contracts drscheme implementation 
example drscheme creates separate thread evaluate user programs 
typically extensions drscheme need initialize thread specific hidden state user program run 
accessors mutators state implicitly accept current thread parameter code initializes state run user thread 
enable drscheme extensions run code user thread drscheme provides primitive run user thread accepts thunk queues thunk run user thread returns 
contract promises argument thunk applied current thread user thread define contract run user thread eq 
current thread user thread 

thunk contract higher order function contract 
interesting aspect precondition function passed run user thread covariant position function contract contravariant position contravariant position covariant rule blame assignment means run user thread responsible establishing contract 
run user thread state available user program accessors mutators lexically available user program 
bool bool define op op number number bool define define eq equal bool define eq eq 
define equal equal 
bool define abstraction predicate contracts promises clients function thunks supply applied user thread 
thunks initialize user thread state 
class contracts experience drscheme shown certain patterns contracts recur frequently 
support abstraction patterns contracts values passed returned functions 
example curried versions comparison operators commonly see 
interestingly certain patterns higher order function contracts common 
example common drscheme pass mixins values 
drscheme mixin function accepts class returns class derived argument 
extensions drscheme supply mixins drscheme important ensure result mixin fact derived input 
contract common defined part drscheme contract library mixin contract class class contract define mixin contract class 

arg res subclass 
res arg module preferences scheme contract provide add panel 
preferences add panel panel panel void define contract add panel 
sp pre children copy spine send sp get children new child post children send sp get children length post children add length pre children eq 
cdr post children pre children eq 
car post children new child 
panel set 
panels cons panel panels preferences panel contract protecting panel contract dependent contract 
states input function class result subclass input 
common contracts mixins guarantee base class passed mixin just class class implements particular interface 
support contracts drscheme contract library provides function constructs contract mixin contract interface interface 
class class contract define mixin contract interface interface implements 
interface 
arg res subclass 
res arg mixin contract interface function accepts interface argument produces contract similar mixin contract contract guarantees input function class implements interface 
mixin contract principle checkable type system type system currently implemented 
ocaml rich express mixins typechecking fails interesting mixins 
contract example expressiveness contracts leads opportunity improve existing type systems 
hopefully example encourage type system designers build richer type systems support practical mixins 
callbacks stateful contracts callbacks notorious causing problems preserving invariants 
szyperski shows callbacks important cause problems 
short code invokes callback ensure state modified dynamic extent callback 
typically invariant maintained examining state callback invoked comparing state callback returns 
consider simple library registering invoking callbacks 
module callbacks scheme contract provide register callback invoke callback register callback 
void void define contract register callback 
arg old state 
save relevant state 
res 
compare new state old state 
set 
callback practice lock variables technique adapts mutatis mutandis 
lock variable solution callback problem invoke callback void define invoke callback callback callback void define callback void function register callback accepts callback function registers current callback 
invoke callback function calls callback 
contract register callback dependent contract constructor new way 
contract checker applies dependent contract original function arguments function applied 
range portion dependent contract determine key aspects state save closure resulting predicate 
predicate called result function compare current version state original version state ensuring callback behaved 
technique useful contract drscheme preferences panel contract considered 
consider revision add panel contract 
revision just ensure new child child 
addition ensures original children preferences panel remain panel order preventing extension removing preference panels 
contract calculus contains syntax contract calculus 
typed context show contracts refine types 
program consists series definitions followed single expression 
definition consists variable contract expression expression initializing variable 
variables bound val rec single program distinct 
expressions include abstractions applications variables numbers numeric primitives lists list primitives expressions booleans predicates 
final expression forms specify contracts 
contract 
expressions construct flat function contracts respectively 
expression returns core syntax 
val rec aop rop hd tl mt true false str 
contract pred dom rng blame str 
aa ab 
rop aop variables 

types list int bool string contract con syntax types true argument flat contract false argument function contract 
pred dom rng expressions select fields contract 
blame primitive assign blame definition violates contract 
aborts program 
model omits dependent contracts return 
model definition treated written different programmer 
definition considered separate entity purpose assigning blame 
implementation fine grained 
blame assigned coarser construct modula modules ml structures functors java packages 
drscheme blame modules 
types con standard core ml polymorphism plus types contract expressions 
typing rules contracts 
contracts flat contracts analogous datatype definition variants flat contracts higher order contracts 
evaluation contexts val rec 
val rec val rec 
val rec 
val rec val rec 
val rec 
aop aop rop rop hd tl 

contract dom rng pred blame values str true false val rec 
con evaluation contexts values values tagged contract value constructor predicates operate appropriate type 
contracts functions consist contracts domain range function 
typing rule definitions mandates type contract corresponds type definition 
rest typing rules standard 
example consider definition sqrt function val rec sqrt contract 
contract 
body sqrt function elided 
contract sqrt 
con error true false true false contains define true false hd hd error hd tl tl error tl contract true 
false pred contract pred 
error pred dom 
dom contract error dom rng 
rng contract error rng blame error reduction semantics con tract type sqrt function type 
domain range portions contract predicates integers sqrt consumes produces integers 
succinctly predicates embedded contract augment type specification indicating domain range positive 

contract 



val rec 

bool contract contract contract contract contract blame contract dom contract contract rng contract contract pred bool contract bool fx tg fx tg int int int aop bool int int rop int list list list list mt bool list hd list tl list bool true bool false bool str string con type rules figures define conventional reduction semantics base language contracts 
contract monitoring explained earlier contract monitor properties 
track higher order functions discover contract violations 
second properly assign blame contract violations 
able track covariant contravariant portions contract 
monitor contracts extend calculus new form expression new values evaluation contexts reductions rules 
contains new expression form representing obligation superscript contract expression base expression obliged meet 
variables 
variables enable contract monitoring system assign blame covariant contravariant positions 
variable names party responsible positive positions contract second variable names party responsible negative positions 
implementation add fourth superscript representing source location contract established 
superscript carried evaluation contract violation discovered point reported part error message 
programmers write obligation expressions 
contracts extracted definitions turned obligations 
enforce judgement ok holds obligation expressions shows obligations placed val rec defined variable 
part obligation definition contract expression 
variable initially name referenced definition 
second variable initially name definition occurs main occurs expression 
function calls expression program 
function accepts program transformed variable specifies blame negative positions obligations expression set variables lexically shadow val val rec 
val rec 
main fxg fyg num num aop aop aop rop hd hd tl tl mt mt true true false false str str 

contract contract pred pred dom dom rng rng blame blame holds val rec obligation expression insertion rec defined variables expression transform 
produces transformed expression 
relates programs variables expressions 
particular program variable expression related variable defined val rec program expression contract definition 
obligation expressions induces extension set evaluation contexts 
shows new evaluation contexts 
specify value superscript obligation expression determined base value 
additionally obligation expression induces new type rule 
type rule guarantees obligation appropriate contract base expression 
add new class values calculus express delay higher order contract 
new values values labelled function obligations see 
grammar allows value labelled function contract type soundness theorem coupled type rule obligation expressions guarantees delayed values functions 
reductions superscripted evaluation proceeds just original evaluation superscript carried instruction result 
additional reductions 
predicate contract reaches flat value predicate flat value checked 
predicate holds contract discarded evaluation continues 
predicate fails execution halts definition named variable positive position superscript blamed 
final reduction key contract checking higher order functions 
application superscripted procedure domain range portion function position superscript moved argument expression entire application 
obligation maintain contract distributed argument result application 
sense positive negative positions reversed argument ensuring blame properly assigned contravariant portions contract 
example consider definition sqrt single main expression 
reduction sequence application sqrt shown 
brevity variables defined val rec treated values reduce variable current values 
reduction example obligations distributed application 
domain portion superscript contract moved argument procedure range portion moved application 
second reduction second reduction examples flat contracts checked 
case predicate holds value 
predicate failed second reduction step main blamed main supplied value sqrt predicate failed second reduction step sqrt blamed sqrt produced result 
second example recall toy higher order program val rec gt val rec bet false val rec gt 
bet 
bet definitions gt bet merely helper functions defining contracts need contracts 
calculus allow definitions simple extension add contract checker simply ignore 
accordingly variable body main expression definition contract 
variable compiled obligation 
contract obligation contract 
positive position contract met blamed negative position contract met main blamed 
reduction sequence gt 
bet 
bet main 
gt 
bet main bet main 
gt 
bet main bet main 
gt main bet main bet main 
gt blame bet main bet main blame reduction step obligation distributed argument result application 
additionally variables indicating blame swapped obligation 
second step substitutes body resulting obligation expressions 
obligation type rule contract obligation evaluation contexts 
obligation values 

obligation reductions contract flat blame 
hoc monitoring contracts con application 
third step distributes contract result application 
addition variables positive negative blame switch positions contract 
fourth step reduces flat contract test determines contract holds 
final reduction steps assign blame supplying argument promised supply number greater 
example shows higher order functions order functions treated uniformly calculus 
higher order functions merely require distribution reductions order functions 
fact nested arrow contract expression induces distribution reduction evaluation 
consistency focus sqrt example remainder chapter 
original program val rec sqrt contract 
contract 
body intentionally elided 
sqrt reductions con sqrt contract 
contract main sqrt 
sqrt contract main sqrt contract sqrt main 
sqrt blame main contract sqrt main sqrt contract sqrt main contract sqrt main blame sqrt reducing sqrt con contract implementation implement con compile away obligation expressions 
key compilation wrapper function 
wrapper function defined calculus 
accepts contract value test strings 
strings correspond variables superscripts 
wrap defined compiling obligations merely matter replacing obligation expression application wrap argument contract referenced variable 
second argument expression obligation final arguments string versions variables obligation 
accordingly define compiler shown maps programs programs 
replaces obligation expression corresponding application wrap original program val rec sqrt contract 
contract 
body intentionally elided 
sqrt reductions compiled expression wrap contract 
contract sqrt sqrt wrap contract sqrt wrap contract main sqrt sqrt main wrap contract sqrt wrap contract main sqrt sqrt main wrap contract sqrt blame main sqrt main wrap contract sqrt sqrt main wrap contract sqrt main blame sqrt reducing sqrt wrap function wrap defined case wise case kind contract 
case handles flat contracts merely tests value matches contract blames positive position doesn 
second case wrap deals function contracts 
wrap contract string string val rec wrap ct ct pred ct error dom ct rng ct wrap wrap contract compiler wrapping function expression shorthand inlined applications expressions 
body wrapper function tests original function argument result recursive calls wrap textual recursive call wrap corresponds postcondition checking 
applies range portion contract result original application 
second recursive call wrap corresponds pre condition checking 
applies domain portion contract argument wrapper function 
call wrap positive negative blame positions reversed domain checking function 
shows compiled version sqrt program reduces 
begins call wrap obligation expression original program 
reduction applies wrap contract case function contract wrap takes second case definition returns expression 
expression applied 
point function contract distributed sqrt argument result sqrt application just distribution reduction con shown 
reduction step call wrap argument sqrt contract flat case definition wrap applies result test 
test failed branch assigned blame main supplying 

val rec val rec aop aop rop rop hd hd tl tl mt mt true true false false str str 
pred pred dom dom rng rng blame blame contract compiler bad value sqrt test passes expression returns reduction step 
sqrt returns 
arrive final call wrap contract flat predicate wrap reduces expression 
time test failed sqrt blamed returning bad result 
final reduction test succeeds result entire program 
correctness type soundness theorem con standard 


val rec 


aop aop rop rop hd hd tl tl true true false false str str 
dom dom rng rng pred pred blame blame error error simulation fw fw theorem type soundness con program 
holds 
error val rec defined variable hd tl pred dom rng exists diverges 
proof combine preservation progress lemmas con lemma 
preservation con 

lemma 
progress con 
remainder section formulates proves theorem relates evaluation programs instrumented semantics section contract compiled programs section 
relate semantics introduce new semantics show relates semantics 
new semantics extension semantics figures 
addition expressions contains obligation expressions evaluation contexts flat reduction new values wrap reduction 
wrap 
free lemma 
evaluators defined partial functions undefined program diverges 
proof inspection evaluation contexts prove unique decomposition program evaluation context instruction value 
follows evaluators functions 
type soundness theorem know undefined programs diverge 
theorem compiler correctness fh definition evaluators 
define fh transitive closure flat hoc define fw transitive closure flat wrap 
functions defined programs ok error error fh fh fh 
fh 
error fh error fw fw fw error fw error evaluators proof combine lemma lemma 
lemma 
fw proof proof establishes reduction sequences fw proceed lockstep 
shows evaluation contexts term compiled counterpart match shows possible reduction mirrored fw obligations compiler change program 
obligation expressions program compiled version program decompose instruction context identically 
obligation expressions compiler produces application expression 
definition evaluation contexts applications obligation expressions know obligation expressions compiled versions obligation expressions decompose parallel 
accordingly purposes proof extend follows write 
compiler change expressions obligations merely need show obligation expression instruction reduces expression compiled counterpart 
cases 
consider obligation expressions exponent flat contract contract fh blame corresponding compiled expression reduces compiled version expression contract wrap contract contract pred contract blame dom contract rng contract wrap wrap pred contract blame blame blame second consider result reducing obligation expressions exponent higher order contract 
fh 
reduction sequence compiled expression short hand expression expanded 
wrap 


blame 
wrap wrap dom 
rng 

wrap wrap rng 
dom 

wrap wrap rng 
wrap wrap rng 
wrap wrap wrap wrap 
expression result fh reduction fw lemma 
fw fh proof intuitively difference fw fh hoc reductions fh split steps fw wrap application wrap reduction may come earlier reduction sequence application 
proof formalizes intuition simulation fh fw defined 
relates fw reduced programs taken half hoc reduction fh counterparts 
clause establishes connection sub terms wrap reduction occurred counterparts fh world 
addition write valid decompositions values errors 
proof establishes reductions steps match diagram fh fw consider reductions 
preserves simulation relation know term resulting single step fw lemma know exists satisfy diagram 
reduction consider hoc case 
definition 
definition 
case reduces second expression wrap 
second expression reduces simulates lemma know exists complete diagram 
prove lemma examine reduction sequences piecing diagram 
situations consider program runs forever fh 
clearly piecing diagram times program runs forever fw 
program reduces error fh 
definition relation see program reduce error fw 
program reduces value fh 
value procedure know program reduce value fw definition 
value procedure reduce different procedure definitions fw fh identify procedure values produce result 
lemma 
exists wrap proof value completes proof 
value progress lemma decompose evaluation context instruction 
spine number higherorder contract obligation values 
proceed inductive argument number expressions 
zero values decompose evaluation context instruction identically follows definition says terms structurally definition evaluation contexts values fw fh higher order contract obligation expressions spine term 
just take values reduces wrap replacing outermost higherorder contract obligation expression 
new term simulates dependent contract expressions 
dependent contract evaluation contexts 


dependent contract reductions 
dependent function contracts con fewer higher order contract value 
inductive hypothesis conclude exists wrap dependent contracts adding dependent contracts calculus straightforward 
reduction relation dependent function contracts naturally extends reduction relation normal function contracts 
reduction distributing contracts applications difference 
placing range portion contract obligation application range portion function original argument placed obligation 
evaluation contexts dictate obligation superscript reduced value base expression 
particular order evaluation means application resulting dependent contract reduction reduced base expression 
procedure dependent contract examine state machine function proper applied 
order evaluation critical callback examples section 
tail recursion contract compiler described section checks post conditions preserve tail recursion procedures post conditions 
typically determining procedure call tail recursive simple syntactic test 
presence higher order contracts understanding exactly calls tail calls complex task 
example consider program val rec gt contract val rec gt 
gt 
gt ng 
body tail position respect conventional interpreter 
optimizing compiler optimize call allocate additional stack space 
due contract result larger call optimized semantics contract checking 
worse functions contracts functions contracts evaluation call function tail call times call function call tail call 
extending program imagine argument locally defined recursive function 
recursive calls tails calls associated top level variable contract enforced 
contracts effective module boundaries experience shown module boundaries typically involved tight loops conjecture losing tail recursion contract checking problem practice 
particular adding contracts drscheme detectable effect performance 
removing tail call optimization entirely render drscheme useless 
minimum compiling tail call difficult 
chapter presents contract checker higher order functions 
key insights 
delay checks function contracts function applied returns 
allows contract checker enforce contracts higher order functions 
second insight blame contract violations switches sense contra positive positions function contracts track positive negative positions function contracts evaluation 
chapter serious impediment software component marketplace assigning blame runtime errors system composed components 
sound type systems mitigate difficulty statically rejecting certain incorrect component compositions 
static systems inherently limited decidable approximations component true interface requirements 
contrast behavioral contracts limitation 
express complete correctness specifications component experience building drscheme suggests full correctness specifications particularly interesting 
particular complex improve quality software merely key behavioral properties 
fact useful contracts simple contracts programmers client components understand contract able program 
improves state art behavioral contract checking ways 
explains fixes flaws contract checking object oriented languages 
second extends contract checking higher order languages natural intuitive manner 
lays groundwork theory contract checking spirit type checking 
consider starting point interesting research directions 
believe experience behavioral contracts reveal contracts biggest impact software quality 
information turn help focus type system research fruitful directions 
second runtime software contract checking static analyses plt static de synergistic 
static debugger improves contract checking validating contracts statically contract checking allows static debugger operate component program independently dramatically increasing size programs analyzed 
third trace debugging improved software contracts 
imagine developer buys components different companies find particular component fails live contracts 
typically merely reporting problem able fix defect 
component producer needs test cases reliably reproduce problem 
test cases help developers ensure problem really components 
furthermore test cases help ensure defect removed re appear releases 
feasible component developer buy component useful context finding test cases de facto responsibility component consumer 
doing simple matter 
typically programmer extract small test case large program guidance 
believe combination trace debugging software contract specifications automatically extract test cases 
bibliography america designing object oriented programming language behavioural subtyping 
proceedings foundations object oriented languages volume lecture notes computer science pages 
springer verlag 
bell 
standard ml new jersey 
und beim mit 
diplomarbeit universitat oldenburg april 
fischer moller 
jass java assertions 
workshop runtime verification 
held conjunction th conference computer aided verification cav 

plouzeau watkins 
making components contract aware 
ieee software pages june 
choi miller netzer 
techniques debugging parallel programs analysis 
acm transactions programming languages systems october 
clinger proper tail recursion space efficiency 
proceedings acm sigplan conference programming language design implementation pages june 
detlefs rustan leino nelson saxe 
extended static checking 
technical report compaq src research report 
duncan holzle 
adding contracts java handshake 
technical report university california santa barbara december 
felleisen findler flatt krishnamurthi 
design programs 
mit press 
felleisen hieb 
revised report syntactic theories sequential control state 
theoretical computer science pages 
findler clements flanagan flatt krishnamurthi felleisen 
drscheme programming environment scheme 
journal functional programming 
appear 
preliminary version appeared plilp lncs volume pages 
findler flatt 
modular object oriented programming units mixins 
proceedings acm sigplan international conference functional programming pages september 
flatt plt mzscheme language manual 
technical report tr rice university 
flatt felleisen 
units cool modules hot languages 
proceedings acm sigplan conference programming language design implementation pages june 
flatt krishnamurthi felleisen :10.1.1.23.8118
classes mixins 
proceedings acm conference principles programming languages pages 
flatt krishnamurthi felleisen 
programmer reduction semantics classes mixins 
formal syntax semantics java 
preliminary version appeared proceedings principles programming languages 
revised version rice university technical report tr june 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley massachusetts 
gomes stoutamire 
language manual sather august 
gosling joy guy steele 
java tm language specification 
addisonwesley 
gosling james 
emacs screen editor 
software 
holt cordy 
turing programming language 
communications acm volume pages december 
jones reid yale haskell group 
hugs user manual 
holzle bruno 
reflective java library support design contract 
proceedings meta level architectures reflection volume lncs july 
kelsey clinger 
editors 
revised report algorithmic language scheme 
acm sigplan notices 

java pre processor 
technical report cs tr department computer science california institute technology 
language specification 
www com 
rosenberg 
blue language specification version 
kramer icontract java design contract tool 
technology objectoriented languages systems 
larus execution technique efficiently tracing programs 
software practice experience december 
leroy manifest types modules separate compilation 
proceedings acm conference principles programming languages pages 
leroy applicative functors fully transparent higher order modules 
proceedings acm conference principles programming languages pages 
acm press 
leroy objective caml system documentation user guide 
liskov wing 
behavioral subtyping invariants constraints 
technical report cmu cs school computer science carnegie mellon university july 
liskov wing 
behavioral notion subtyping 
acm transactions programming languages systems november 
luckham programming specifications 
texts monographs computer science 
luckham von henke 
overview anna specification language ada 
ieee software volume pages march 
man machine systems 
design contract java 
www com html 
mcilroy mass produced software components 
naur randell editors report conference nato science committee pages 
meyer object oriented software construction 
prentice hall 
meyer eiffel language 
prentice hall 
milner theory type polymorphism programming 
journal computer systems science 
milner tofte harper 
definition standard ml 
mit press 
parnas technique software module specification examples 
communications acm may 
pichler 
contracts analysis implementation 
technology object oriented languages systems pages 
remy vouillon 
objective ml simple object oriented extension ml 
proceedings acm conference principles programming languages pages january 
rosenblum practical approach programming assertions 
ieee transactions software engineering 
stallman gnu emacs manual 
free software foundation mass ave cambridge ma 
steele expensive procedure call myth procedure call implementations considered harmful lambda ultimate goto 
technical report mit artificial intelligence laboratory 
appeared proceedings acm national conference seattle october 
szyperski component software 
addison wesley 
ghc team 
glasgow haskell compiler user guide 
wright felleisen 
syntactic approach type soundness 
information computation pages 
appeared technical report tr rice university 
