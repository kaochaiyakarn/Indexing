journal artificial intelligence research submitted published cp nets tool representing reasoning conditional ceteris paribus preference statements craig boutilier cs toronto edu department computer science university toronto toronto canada ronen brafman brafman cs bgu ac il department computer science ben gurion university beer israel carmel domshlak cs cornell edu department computer science cornell university ithaca ny usa holger hoos hoos cs ubc ca department computer science university british columbia vancouver bc canada david poole poole cs ubc ca department computer science university british columbia vancouver bc canada information user preferences plays key role automated decision making 
domains desirable assess preferences qualitative quantitative way 
propose qualitative graphical representation preferences reflects conditional dependence independence preference statements ceteris paribus equal interpretation 
representation compact arguably quite natural circumstances 
provide formal semantics model describe structure network exploited inference tasks determining outcome dominates preferred ordering set outcomes preference relation constructing best outcome subject available evidence 

extracting preference information users generally arduous process human decision analysts developed sophisticated techniques help elicit information howard matheson 
key goal study computer decision support construction tools allow preference elicitation process automated partially fully 
methods extracting representing reasoning preferences naive users particularly important ai applications ranging collaborative ai access foundation morgan kaufmann publishers 
rights reserved 
boutilier brafman domshlak hoos poole filtering lashkari metral maes recommender systems nguyen haddawy product configuration ambrosio birmingham medical decision making getoor norman shahar 
applications users expected patience ability provide detailed preference relations utility functions 
typical users may able provide qualitative rankings fairly circumscribed outcomes 
describe novel graphical representation cp nets specifying preference relations relatively compact intuitive structured manner conditional ceteris paribus equal preference statements 
cp nets specify different types preference relations preference ordering potential decision outcomes likelihood ordering possible states world example shoham preference semantics 
mainly type preferences outcomes decisions motivates development 
inference techniques cp nets described focus important related questions perform preferential comparison outcomes find optimal outcome partial assignment problem attributes 
ideally preference representation capture statements natural users assess reasonably compact support effective inference 
conditional ceteris paribus semantics requires user specify specific attribute interest attributes impact preferences values instantiation relevant attributes parents user specify preference ordering values conditional parents assuming instantiated values instance may preferred hold 
preference ceteris paribus interpretation preferred equal 
words fixed instantiation remaining attributes outcome holds preferred holds assuming 
statements arguably quite natural appear places commerce applications 
instance product selection service offered active buyer guide asks unconditional ceteris paribus statements assessing user preference various products 
tools ask certain semi quantitative information preferences 
conditional expressions offer greater flexibility 
preference elicitation complex task key focus decision analysis keeney raiffa howard matheson french especially elicitation involving non expert users 
automating process preference extraction difficult 
considerable exploiting structure preferences utility functions way allows appropriately decomposed keeney raiffa bacchus grove la shoham 
instance certain attributes preferentially independent keeney raiffa assign degrees preference attribute values worrying attribute values 
furthermore assumes stringent conditions construct additive value function attribute contributes preference specific degree weight attribute keeney raiffa 
instance common engineering design problems assumptions simply 
see www com 
cp nets require users assess weights ambrosio birmingham 
allows direct tradeoffs values different attributes assessed concisely 
case approaches considered ha haddawy 
models preference elicitation process easier imposing specific requirements form utility preference function 
consider cp net representation offer appropriate tradeoff allowing flexible preference expression imposing particular preference structure 
specifically cited cp nets capture conditional preference statements 
remainder organized follows 
section provides background preference orderings important notions preferential independence conditional ceteris paribus preference statements 
define cp nets discussing semantics expressive power depth model properties 
section algorithm outcome optimization cp nets provide example application cp nets illustrates optimization process 
section introduces kinds queries preferential comparison ordering dominance queries investigates computational properties 
section discusses general techniques answering dominance queries exploit structure cp net 
section discuss applicability complexity results algorithms slight generalization cp nets allow incompletely specified local preferences statements preferential indifference 
section examine related applications cp nets discuss number interesting directions theoretical research applications 

model definition philosophical treatment intuitive qualitative preferential statements began pioneering continued casta eda von wright hansson 
reason intensive analysis statements expressed concisely opening hansson discussing wife table buy living room said round table better square mean irrespectively properties round table better square shaped table 
meant round table better living room square table differ significantly characteristics height sort wood finishing price preference ceteris paribus equal 
preferences express act type 
emphasis added 
important property ceteris paribus preferential statements intuitive nature users types 
independently philosophers area reasoning ceteris paribus statements drawn attention ai researchers 
example doyle 
introduced logic relative desire treat preference statements ceteris paribus assumption 
logic bears similarity von wright logic boutilier brafman domshlak hoos poole preferences supports complicated inferences 
best knowledge serious attempt exploit preferential independence compact efficient representation ceteris paribus statements 
take steps structured modeling qualitative ceteris paribus preferential statements 
start defining notion qualitative preference relation number basic preference independence concepts followed cp nets semantics 
preference relations focus attention single stage decision problems complete information ignoring issues arise multi stage sequential decision analysis considerations risk arise context uncertainty 
relevant notions decision theory 
assume world number states state number actions performed 
action performed state specific outcome concern uncertainty action effects knowledge state 
set outcomes denoted ranking total preorder set outcomes means outcome equally preferred decision maker 
denote fact outcome strictly preferred decision maker denotes decision maker indifferent 
terms preference ordering relation interchangeably ranking 
aim decision making certainty knowledge specific state choose action preferred outcome 
note ordering vary decision makers 
instance customers radically different preferences computer system configurations sales program helping construct 
state certain outcomes result action outcomes obtained called feasible outcomes 
instances mapping states actions outcomes quite complex 
decision scenarios actions outcomes may equated user allowed directly select feasible outcome select product desirable combination attributes 
states play role single state 
thing decision problems difficult fact outcomes actions preferences usually represented directly 
example actions may represented set constraints set decision variables 
focus preferences 
assume set variables features attributes xn decision maker preferences 
variable xi associated domain dom xi xi ni values take 
assignment values set variables called instantiation function maps variable element domain complete assignment called partial assignment 

detailed discussion issue refer reader doyle wellman 

issues include assigning preferences sequences outcome states assessing uncertainty beliefs system dynamics assessing user attitude risk 
cp nets denote set assignments 
assignments disjoint sets respectively denote combination xy 
ifx completion assignment completions complete assignments correspond directly outcomes user possesses preferences 
outcome dom assigned variable outcome 
problem defined variables domains dom dom xn dom dom xn assignments 
direct assessment preference function usually infeasible due exponential number outcomes 
fortunately preference function specified partially specified concisely exhibits sufficient structure 
describe certain standard types structure referring keeney raiffa detailed description structural forms discussion implications 
set variables preferentially independent complement iff andy iff 
words structure preference relation assignments variables held fixed matter values variables take 
relation holds say preferred ceteris paribus 
assess relative preferences assignments knowing preferences change attributes vary 
define conditional preferential independence analogously 
nonempty sets partition conditionally preferentially independent assignment iff andy iff 
words preferentially independent assigned ifx conditionally preferentially independent conditionally preferentially independent set variables note ceteris paribus component definitions ensures statements relatively weak 
particular imply stance specific value tradeoffs 
consider variables preferentially independent preferences values assessed separately instance suppose 
clearly preferred outcome feasibility constraints impossible satisfied 
tell preferred separate assessments 
stronger conditions additive preferential independence construct additive value function weights assigned different attributes attribute groups 
decomposition preference function allows identify preferred outcomes readily special forms preference structure especially appropriate attributes take numerical values 
extensive discussion various special forms preference functions refer keeney raiffa bacchus grove shoham 
cp networks boutilier brafman domshlak hoos poole representation preferences graphical nature exploits conditional preferential independence structuring preferences user 
model similar bayesian network pearl surface nature relation nodes network generally quite weak compared probabilistic relations bayes nets 
defined graphical representations preference relations instance bacchus grove shown strong results pertaining undirected graphical representations additive independence 
representation semantics distinct main aim graph capture statements qualitative conditional preferential independence 
note reasoning ceteris paribus statements explored ai doyle wellman doyle doyle wellman context network representations exploiting preferential independence computational fashion 
variable xi ask user identify set parent variables pa xi affect preference various values xi 
particular value assignment pa xi user able determine preference order values xi things equal 
formally pa xi conditionally preferentially independent pa xi xi 
information ask user explicitly specify preferences values xi instantiations variable set pa xi 
information create annotated directed graph nodes stand problem variables node xi pa xi immediate ancestors 
node xi annotated conditional preference table cpt describing user preferences values variable xi combination parent values 
words letting pa xi assignment assume total preorder provided domain xi values simplicity presentation ignore indifference algorithms 
treatment indifference straightforward semantically consistency arbitrary networks indifference assumed discuss section 
likewise assume cpts variables fully specified discuss partially specified cpts section 
call structures conditional preference networks cp networks cp nets short 
definition cp net variables xn directed graph xn nodes annotated conditional preference tables cpt xi foreach xi conditional preference table cpt xi associates total order instantiation xi parents pa xi illustrate cp net semantics consequences small examples 
ease presentation variables examples boolean semantics defined features arbitrary finite domains 
example dinner consider simple cp net expresses preference dinner configurations 
network consist variables standing soup wine respectively 
strictly prefer fish soup sf soup sv preference red wr ww wine conditioned sf sf sv ww wr sv wr ww cp nets sv ww sv wr sf wr sf ww cp net dinner soup wine induced preference graph 
soup served prefer red wine served vegetable soup white wine served fish soup 
shows preference graph outcomes induced cp net 
arc graph directed outcome oi oj indicates preference oj oi determined directly cpts cp net 
example fact sv wr preferred sv ww indicated direct arc direct consequence semantics cpt 
top element sv ww bottom element sf ww example dinner ii extends chain cp net example adding main course variable 
example preference options main course clear strictly prefer meat course mmc fish course mfc 
addition prefer fish courses dinner preference vegetable fish soup conditioned main course prefer open fish soup main course meat vegetable soup main course fish 
example shows corresponding induced preference graph outcomes 
example evening dress illustrates cp net expresses preferences evening dress 
consists variables ands standing jacket pants shirt respectively 
unconditionally prefer black white color jacket pants preference red white shirts conditioned combination jacket pants color white shirt prefer red shirt 
jacket pants different colors red shirt probably prefer white shirt 
shows corresponding preference graph 
boutilier brafman domshlak hoos poole mmc mfc mmc sf sv mfc sv sf sf ww wr sv wr ww mfc sf wr mfc sf ww mfc sv ww mfc sv wr mmc sv ww mmc sv wr mmc sf wr mmc sf ww cp net dinner ii induced preference graph 
jb jw jb pb jw pb jb pw sr sw sw sr sw sr jw pw sr sw pb pw cp nets jw pw sw jw pw sr jw pb sr jb pw sr jb pw sw jw pb sw jb pb sw jb pb sr cp net evening dress jacket pants shirt induced preference graph 
semantics semantics cp net straightforward 
defined terms set preference rankings consistent set preference constraints imposed cpts 
definition cp net variables xi variable ordering dom xi parents xi xi 
dictated cpt xi instantiation parents 
preference ranking 
preference ranking satisfies iff dom xi yx preference ranking satisfies cpt cpt xi 
preference ranking satisfies cp net iff satisfies cpt xi variable xi 
acp satisfiable iff preference ranking satisfies 
network satisfied iff satisfies conditional preferences expressed cpts ceteris paribus interpretation 
theorem acyclic cp net satisfiable 
boutilier brafman domshlak hoos poole proof prove constructively building satisfying preference ordering 
proof induction number variables 
theorem trivially holds variable total ordering specified directly cp net 
suppose theorem holds cp nets fewer variables 
network variables 
acyclic variable parents variable 
xk ordering dom dictated cpt 
xi construct cp net ni removing initial cp net variable child revising cpt restricting row xi 
inductive hypothesis construct preference ordering reduced cp nets ni 
construct preference ordering original network follows 
rank outcome xi preferred outcome xj xi xj cpt 
outcomes identical values xi rank ordering associated ni ignoring value 
easy see preference ordering satisfies example consider cp net example 
somewhat surprisingly information captured network sufficient totally order outcomes sf ww sf wr sv wr sv ww ranking satisfies cp net 
need case general satisfiable cp net satisfied ranking 
instance consider cp net 
rankings satisfy network abc ab bc bc bc abc ab bc bc bc preferential entailment cp net defined standard way 
definition cp net variables ando 
entails outcome preferred written iff holds preference ordering satisfies lemma preferential entailment transitive 
proof preference rankings satisfying rankings transitive satisfying rankings 
example consider cp net outcomes ab ando bc 
outcomes assign values variables addition value pa preferred value ino equal 
argument respect 
network example dinner ii variables renamed 
cp nets bc bc bc ab abc simple chain structured cp network 
variable show 
observe derived directly cpts lemma follows relation inferred transitive closure direct relations notice cp net assess outcome terms conditional preferences violates 
example cp net example outcome sf ww violates preference constraints sf wr violates conditional preference sv wr violates preference ww violates 
somewhat surprisingly ceteris paribus semantics implicitly ensures violating preference worse violating wr sv wr 
parent preferences higher priority child preferences 
property important implications 
cyclic networks mentioned semantics cp net model forces acyclic 
theorem acyclicity network automatically confers important property model network satisfiable exists preference ordering satisfies ceteris paribus preference assertions imposed cpts 
cyclic cp nets situation complicated 
example consider binary valued cyclic cp net structure 
cpts network specified induced preference graph see extended complete preference ordering consistently 
cpts specified network unsatisfiable induced preference graph shown boutilier brafman domshlak hoos poole completed consistently 
example shows consistency cyclic cp nets guaranteed depends actual nature cpts 
examples satisfiable unsatisfiable cyclic cp net binary variables 
initial results consistency testing cyclic cp nets domshlak brafman 
particular wide class cyclic binary valued identified efficiently testable consistency 
results cover part spectrum research cyclic cp nets needed 
open computational questions cyclic cp nets raise usefulness requires analysis 
argue possible cluster variables preserve acyclicity 
approach technically feasible probably useful domains provide general solution 
clustering affect space requirements problem description generally degrade efficiency reasoning preferences 
second certain domains may natural express cyclic preferences acyclic representation 
example case preference presentation web page content domshlak brafman shimony argued preferred presentation certain component web page may depend presentation neighbors page preferred presentation depend presentation 
argue preferences naturally exhibit cyclic structure acyclic nets theoretical interest 
experience indicates opposite 
acyclic cp nets shown effective natural mentioned web page presentation domshlak related project deals presentation multi media content medical domain domshlak extensive example domain section 
domains difficult generate intuitively reasonable cyclic networks 
due fact cycle implies variables equally important 
cp nets typically case 
apparent utility acyclic networks fact composite variables clustering primitive variables additional complexity involved cyclic networks consider acyclic cp nets remainder 
investigation cyclic cp nets characterization different classes utility functions represented cyclic acyclic networks remains interest 
indifference far assumed preference constraints cpt cp net totally order outcomes variable question 
specifically variable xi parents assume total order dom xi 
general definition cp net allow arbitrary total preorder dom xi allowing user express indifference values variable 
denote cpt 
turns ceteris paribus semantics quite strong say variable values equally preferred 
example consider cpts network variables parent assert user indifferent hold prefers hold prefers derive preferences outcomes ab ab ab ab ab statements consistent preference ranking network satisfiable 
way interpret really preferences indifferent ceteris paribus 
points potential difficulty indifference cp nets 
careful express indifference values variable case express strict conditional preference child variable depends values user indifferent 
intuitively case user expressing fact value match respect sign intends preference ab ab vice versa 
case making expresses preference subsidiary intent 
case cyclic network satisfiable network discussed section clustering variables appropriate 
despite indifference safely follows 
xi variable network parents child xi 
denote remaining boutilier brafman domshlak hoos poole parents xj excluding xi 
suppose dom xi long local orderings cpt xj fixed instantiation identical holds network satisfiable 
precisely xy network satisfiable 
indifferent preferences values xi children exhibit indifference context includes simplicity presentation remainder continue assume preference constraints cpt cp net totally order outcomes variable question 
section discuss applicability results satisfiable cp nets capture statements preferential indifference 

outcome optimization principal properties cp nets cp net easily determine best outcome preference rankings satisfy call query outcome optimization query 
turns simple task cp nets 
algorithm outcome optimization intuitively generate optimal outcome simply need sweep network top bottom ancestors descendents setting variable preferred value instantiation parents 
network generally determine unique ranking determine unique best outcome assuming indifference 
generally suppose evidence constraining possible outcomes form instantiation subset network variables 
determining best completion best outcome consistent achieved similar fashion outline 
outcome optimization queries answered forward sweep procedure time linear number variables 
assume partial instantiation goal determining unique comp comp 
effected straightforward sweep network 
xn topological ordering network variables 
set instantiate xi turn maximal value instantiation parents 
procedure exploits considerable power ceteris paribus semantics graphical modeling preferential statements easily find optimal outcome certain observed evidence imposed conjunctive constraints 
lemma forward sweep procedure constructs preferred outcome comp 
proof vz outcome set completions define sequence outcomes vi follows vz vi constructed setting value xi preferred value instantiation parents vi variables retaining values vi xi vi 
construction vi vi 
outcome vn precisely constructed forward 
restriction relaxed somewhat take account fact xj parents lie set case rankings need agree indifference pair cp nets sweep algorithm 
notice arrive outcome irrespective starting point vz assumption ties 
vn vz outcome vz consistent evidence forward sweep procedure yields optimal outcome 
example application turn illustration cp nets context cp net system adaptive multimedia document presentation 
applications system presentation web content multi media medical data domshlak 


example demonstrate simplicity preference specification cp nets utility acyclic networks optimization algorithm described 
system consists tools authoring tool viewing tool 
central part authoring tool module specification cp net corresponding created edited multimedia document 
cp net content provider express preferences regarding presentation document content 
example content provider may prefer material material 
result preference multimedia document design meta document specifying 
description content provider preferences captured acyclic cp net static part document sets parameters initial presentation 
document viewing tool responsible reasoning preferences specifically determine optimal reconfiguration document context interaction viewer document 
process user content choices viewed constraints form items appear specified 
subject constraints optimal document presentation respect content provider cp net generated 
particular session actual presentation changes dynamically user choices 
precisely new user input obtained optimization algorithm constructs best presentation document components respect content provider preferences presentations conform user viewing choices 
process uses forward sweep procedure described 
example multimedia document consider medical record consists components components correspond set medical tests conducted ray image textual notes physician components correspond set medical tests ct computerized tomography image ray image graph illustrating results textual notes physician 
purposes illustration assume preferences content provider physician presentation options components captured cp net shown 
specific details preferences nature preferential dependencies precise details cpts summarized follows ct image ct image consist ct images different parts body shown 
presentation options ct image completely completely hidden boutilier brafman domshlak hoos poole document components multimedia document example 
ct image ray graph ray old notes notes old multimedia document cp net 
zoom parts standing left top left bottom right bottom parts respectively 
physician preference presentation options ct image unconditional ray ray hidden xray hide xray plain segmentation xray segm image segmentation depicted figures respectively 
preference presentation options ray depends presentation ct image xray hide xray plain xray segm cp nets graph shown graph plain hidden graph hide 
preference presentation options graph depends presentation ct image ray notes textual notes fully summarized omitted 
preference presentation options notes depends presentation ct image graph graph plain graph plain ray old ray hidden xray old hide xray old plain image depicted 
preference presentation options ray old depends presentation ray xray hide xray old hide xray old plain xray hide xray old plain xray old hide notes old textual notes notes omitted notes 
preference presentation options notes old depends presentation ray old xray xray notes notes notes notes viewing session initial presentation document depicted determined forward sweep procedure component set preferred presentation presentation immediate parents cp net 
example ct image hidden preferred option component 
subsequently ray image segmented ct image turn graph decision presentation options ct image ray 
suppose viewer chooses xray boutilier brafman domshlak hoos poole notes xray notes xray notes xray notes document presentations various user choices 
cp nets look right top part ct image 
terms forward sweep procedure choice sets ct image andz 
result forward sweep procedure appears follows shaded nodes stand evidence constrained variables ray image segmentation zoom right top part ct image summarized graph ct image hidden 
suppose viewer consequently chooses hide ray image 
number viewer choices taken constrain presentation greater choice set ct image ray andz xray hide 
result forward sweep procedure appears 
consequently viewer chooses see ct image xray hide updated presentation shown 

comparing outcomes outcome optimization task supported preference representation model 
basic query respect model preferential comparison outcomes 
outcomes stand possible relations respect cp net orn orn third case specifically means network contain information prove outcome preferred exist preference orderings satisfying 
distinct ways compare outcomes cp net 
dominance queries pair outcomes ask relation holds preferred say dominates respect 
ordering queries pair outcomes relation holds exists preference ordering consistent words consistent knowledge expressed order assert preferred 
case say consistently orderable respect ordering queries clearly weaker dominance queries 
may case dominance queries typically useful ordering queries sufficient applications may satisfied knowing outcome consistently ordered example consider set products human automated seller customer non increasing order customer preference 
reason strong dominance relation sort products 
applications dominance queries replaced ordering queries 
instance dominance queries shown integral part constraint preferential optimization cp nets boutilier brafman geib poole 

document explorer part viewing tool illustrated order snapshots smaller 

recall time consider cp nets indifference cpts outcomes proven equally preferred 
boutilier brafman domshlak hoos poole showing ordering queries respect acyclic cp nets answered time linear number variables 
addition show set outcomes sorted consistent non increasing order respect acyclic cp net ordering queries 
provide complexity analysis dominance queries 
introduce study particular form reasoning search flipping sequences answer dominance queries 
technique focusing binary valued cp nets show connections structure cp net graph worst case complexity dominance queries 
discuss dominance queries detail section general search techniques flipping sequences 
ordering queries easy show ordering queries respect acyclic necessarily binary valued cp nets answered time linear number variables 
corresponding algorithm exploits graphical structure model 
likewise show acyclic cp nets construct non increasing ordering outcomes consistent ordering queries 
corollary acyclic cp net pair outcomes 
exists variable 
assign values ancestors 
assignment provided assigns preferred value assigned proof construction theorem provides preference ordering satisfying true models consequence corollary presents condition sufficient necessary truth ordering query instance consider example mmc sv ww mfc sv wr 
outcomes incomparable cp network proven preferred deduced conditions corollary root variable chain cp net assigns preferred value assigned despite fact condition provided corollary necessary consistent show sufficient provide consistent ordering pair outcomes 
theorem acyclic cp net variables complexity determining truth ordering queries iso 
proof variable xi xi denote assignment outcomes respectively 
variables xi assign different values xi values ancestors xi identified cp nets time top traversal 
note xi 
xi xi xi corollary deduce exist variables type xi xj xi xi xj xj case corollary implies corollary provides effective algorithm answering ordering queries computational efficiency comes price sound algorithm says consistently orderable incomplete provides negative response query may case theorem provides effective algorithm sound partially complete sense return positive answer words allow determine outcome consistently ordered 
incompleteness algorithm single ordering queries problematic partial completeness algorithm paired queries sufficient allow find consistent ordering outcomes polynomial time case acyclic cp net 
introduce notation 
write oq represent algorithm paired ordering queries tells holds consistently orderable orderable 
oq assured orderable due incompleteness algorithm sure orderable write oq denote algorithm returns positive response ordering queries tells outcomes consistently orderable 
soundness algorithm ensures outcomes consistently preferred case 
note partial completeness ensures oq oq oq sufficient allow produce consistent ordering set outcomes 
theorem acyclic cp net variable set set outcomes om ordering outcomes consistently done ordering queries 
proof define binary relations outcomes iff oq iff oq show transitive closure relation asymmetric 
assume contrary exists set outcomes ok ok letv oi value assigned oi improved assignment provided oi pa 
ni subgraph consisting variables oi descendants observe corollary implies ni ni 
see notice ni ni exists variable ancestors assigned preferred values oi oi ii oi pa oi pa assigned preferred value oi preferred values oi 
boutilier brafman domshlak hoos poole case ordering query determine oi oi contradicts assumption oi oi 
graph containment relations ni ni strict initial assumption trivially contradicted 
left case nk recalling acyclic consider variable xj ancestors pa xj parents xj original network note 
construction ni ok case ancestors xj assigned unique optimal assignment part variables improvable 
entails xj xj ok xj xj inconsistent definition cp net 
exploit asymmetric nature relation follows 
relation representing induced preference graph subset 
total ordering om consistent consistent immediate consequence theorems set outcomes acp complexity ordering outcomes consistently preference graph induced nm cost comparing pair outcomes ordering accordingly 
dominance queries flipping sequences ceteris paribus semantics cp nets allows directly information cpt variable alter flip value outcome directly obtain improved preferred worsened outcome 
sequence improving flips outcome provides proof outcome preferred rankings satisfying network 
defining notion precisely illustrate intuitions example 
example consider cp net 
rankings satisfy network abc ab bc bc bc abc ab bc bc bc outcomes totally ordered abc abc 
abc abc chains outcomes move outcome chain flipping value exactly variable preference cp nets information cpt instantiation parents 
example move outcome sequences abc second abc fact prove second outcome flip preferred value instantiation parent conversely move backwards sequence flipping second outcome obtaining preferred outcome 
recall corollary demonstrates violating preference constraints parent variable preferred violating preference constraints children 
greater importance parent variables implicit ceteris paribus semantics 
consider outcomes abc abc unordered 
outcome violates preference values outcome bc violates preferences values anda ancestor semantics cp nets specify outcomes preferred intuitively preference higher priority violations lower priority preferences may preferred violation single higher priority preference 
outcomes improving flipping sequence uniquely corresponds directed path node node preference graph induced cp net 
instance consider cp net exactly network evening dress example example simpler variable names 
alternative flipping sequences outcome bc outcome abc corresponding paths outcomes induced preference graph depicted bc bc abc bc bc ab abc bc bc abc bc bc ab abc abc bc consequence cp net 
contrast flipping sequence directed path bc outcomes incomparable 
examples suggest construction flipping sequence prove dominance 
definition cp net variables parents xi xi 
outcome dom xi 
improving flip outcome respect variable xi outcome ux 
note improving flip xi exist preferred value xi 
improving flipping sequence respect sequence outcomes ok oi improving flip oi respect variable 
improving flipping sequence outcome outcome improving sequence ok ok boutilier brafman domshlak hoos poole ab bc bc bc ab abc evening dress cp net example simpler names 
define worsening flips worsening flipping sequences entirely analogous way 
obviously worsening flipping sequence reverse improving flipping sequence vice versa 
important things notice examples 
improving worsening flipping sequence show outcome better 
second preference violations worse larger negative impact preference outcome higher network compare lower level violations violation single ancestor constraint 
observations underlie inference algorithms 
theorem soundness improving flipping sequence cp net outcome proof improving flip outcome outcome definition 
theorem follows transitivity preferential entailment lemma 
theorem completeness acyclic cp net improving flipping sequence outcome proof graph nodes outcomes complete assignments variable set directed edge iff improving flip sanctioned network clearly directed paths equivalent improving flipping sequences respect show total preference ordering respects paths path satisfy exist variable parents instantiation cp nets values dom instantiation remaining variables ux cpt dictates direct consequence definition satisfaction 
requires direct flip uy contradicting fact extends graph observation prove theorem improving flipping sequence directed path exists preference ordering respecting paths preference ordering satisfies implies flipping sequences plans searching flipping sequences seen type planning problem variable parents pa inn conditional preference statement form xd pa dom 
statement converted set planning operators improving value particular conditional preference statement converted set planning operators form preconditions xi postconditions delete list xi add list xi corresponds action improving xi xi context 
inverse set operators created worsening sequences 
query start state goal state planning problem 
readily apparent query consequence cp net plan associated planning problem plan corresponds flipping sequence 
planning problem multi valued variables discrete finite domains known pspace complete nebel remains pspace complete assumption variables binary bylander planning problems strips formalism negative effects 
upper bound informative respect dominance queries planning problems generated generally look quite different form standard ai planning problems actions action directed achieving particular proposition requires specific preconditions 
dominance queries respect cp nets correspond specific class strips planning problems complexity boutilier brafman domshlak hoos poole analyzed domshlak brafman 
explain relationship 
divide preconditions operator planning problem types prevailing conditions variable values required prior execution operator affected operator preconditions affected operator 
second introduce notion causal graph knoblock directed graph nodes stand problem variables 
edge causal graph operator changes value prevailing condition involving complexity analysis brafman domshlak addresses planning problems binary variables unary operators operators affect single variable acyclic causal graphs 
planning problem generated dominance query respect binary valued cp net 
operators unary flip improves value single variable 
causal graph problem exactly graph cp net values pa required value flip exactly prevailing conditions corresponding planning operator 
computational analysis dominance queries binary valued acyclic cp nets results techniques brafman domshlak 
complexity dominance queries binary valued acyclic cp nets section analyze complexity dominance testing respect cp nets showing connection structure cp net graph worst case complexity dominance queries 
particular show binary valued cp net forms directed tree complexity dominance testing quadratic number variables 
binary valued cp net forms polytree induced undirected graph acyclic dominance testing polynomial size cp net description 
binary valued cp net directed path singly connected directed path pair nodes dominance testing np complete 
problem remains hard node degree network bounded low constant 
dominance testing binary valued cp nets remains np complete number alternative paths pair nodes cp net polynomially bounded 
exact complexity dominance testing multiply connected binary valued acyclic cp nets remains open problem stage clear problem np harder 
follows assumption number parents variable node degree cp net bounded constant 
assumption cp nets justified cpts part problem description size cpt exponential pa 
general properties start notation useful lemmas 
cp net pair outcomes respect improving flipping sequence called irreducible subsequence obtained deletion entries endpoints improving flipping sequence 
cp net set irreducible improving flipping sequences outcomes 
denote maxflip xi maximal number times variable xi changes value flipping sequence formally flip xi value flips xi flipping sequence maxflip xi max flip xi lemma formalizes observation irreducible flipping sequences respect binary valued cp nets 
lemma variable xi binary valued cp net maxflip xi maxflip xj xj xi pa xj proof irreducible flipping sequence respect outcome outcome maxflip xi flip xi 
consider subsequence fk consists value flips children xi observe fl requires xi take possible values ii value flip depends value xi 
fl require value xi value flips xi fl fl flips simply redundant contradicts assumption irreducible 
recall fl fl adjacent may separated flips original sequence alternatively fl fl require different values xi due irreducibility exactly value flip xi fl fl 
similarly show value flip xi value flip xi fk 
flip necessary fk requires xi take value xi supporting immediate successors xi flip value order obtain value required implies maxflip xi flip xi xj xi pa xj flip xj 
note removing proper initial final subsequence results valid flipping sequence 
refer deletion arbitrary elements sequence excluding endpoints 
boutilier brafman domshlak hoos poole definition maxflip wehave maxflip xi xj xi pa xj maxflip xj adopting terminology domshlak shimony shimony domshlak directed acyclic graph directed path singly connected pair nodes directed path lemma prove binary valued cp net forms directed path singly connected dag variable xi maxflip xi bounded number variables 
lemma binary valued cp net forms directed path singly connected dag variable xi number variables maxflip xi proof follows denote maxflip xi inn maxflip xi 
proof induction forn obvious maxflip 
assume binary valued directed path singly connected cp net consists variables xi maxflip xi binary valued directed path singly connected cp net variables 
loss generality variables xn topologically ordered acyclic graph clearly xn leaf node denote cp net obtained removing xn lemma maxflip xn observe directed paths predecessors xn assumed directed path singly connected 
lemma parent xi xn wehave maxflip xi maxflip xi maxflip xn xi xi generally directed path singly connected variable xi xi path xi xn xi xi xi wehave maxflip xi cp nets initialize variables outcome loop iteratively remove leaf variables assigned values return 
find variable value improved value descendants improved current assignment variable return 
change value flipping sequence search algorithm binary valued tree structured cp nets tree structured cp nets start presenting flipping sequence search algorithm class binary valued tree structured cp nets prove correctness 
show time complexity algorithm show lower bound flipping sequence search binary valued tree structured cp nets 
presents algorithm binary valued tree structured cp nets 
informally starts initializing variables values purported preferred outcome continues incremental bottom conversion initial assignment assignment induced purported preferred outcome step starts iteratively removing leaf variables maximal fringe canopy consistent iteration step removes variables variables assigned values required improving flipping sequence generated 
stand updated nodes removed 
node candidate variable value flipped ii descendant value flipped current assignment variables value arbitrary candidate variable exists repeat node removal report improving flipping sequence candidate variables 
algorithm deterministic backtrack free 
show complete binary valued tree structured cp nets generates irreducible flipping sequences time complexity 
fact generates irreducible flipping sequences ensures soundness generating valid flipping sequences provide correct positive answers dominance queries 
theorem algorithm sound complete binary valued tree structured cp nets 
proof consider execution dominance query respect binary valued tree structured cp net boutilier brafman domshlak hoos poole suppose iteratively remove tree leaf variables values required target outcome easy see affect completeness algorithm acyclic variables fringe ancestors variables 
value variables fringe influence ability flip values variables remove improving flipping sequence consideration 
second consider variable iteratively removing variables value improved descendents improved current assignment ifx leaf node changing value influence ability flip values variables 
addition current value ofx different part removed fringe 
improving change value point necessary improving flipping sequence 
alternatively suppose leaf node 
leaf nodes subtree rooted part removed fringe values remain changed 
tree completely separates descendents variables improving flip subtree possible change value value changed flipping sequence point value descendent remains shown candidate variables flipped matter flip 
candidate variable flipped point flip necessary flipping children corresponding variable 
changes candidates affect candidates descendants 
evaluation order candidate flips irrelevant prevent finding flipping sequence exists 
algorithm complete 
soundness algorithm clear proof 
flip generated step algorithm valid improving flip current outcome theorem time complexity flipping sequence search binary valued treestructured cp nets wheren number variables cp net 
proof algorithm backtrack free thing remains shown addition lemma theorem binary valued tree structured cp nets generates irreducible flipping sequences 
proof straightforward shown 
flips value variable achieve value purported preferred outcome query allow required value flips descendants 
role flips fulfilled value flips variables 
improving flipping sequence generated subset value flips illegal ends respectively 
improving flipping sequence generated algorithm irreducible 
cp nets theorem shows limiting chain binary valued dominance queries minimal flipping sequences quadratic length 
asymptotically optimal 
theorem lower bound flipping sequence search binary valued tree structured cp nets 
proof proof see appendix proof example providing dominance query binary valued tree cp net size minimal flipping sequence 
polytree cp nets dags cycles underlying undirected graphs known polytrees minimal extension directed trees 
unfortunately procedure complete polytree cp nets extended form backtracking restricted binary variables 
due fact parents node may allowed values flipped choices may lead target outcome lead dead 
instance consider cp net query bc 
starting outcome bc iteration choice flipping chosen assignment changed bc 
lead target way flip back dead reached 
hand chosen successfully generate improving flipping sequence bc bc incorrect choice improving variable may require backtracking 
dominance testing binary valued polytree cp nets remains polynomial time algorithm solution complicated 
algorithm adapted corresponding algorithm planning problems binary variables unary operators polytree causal graphs described domshlak brafman 
theorem dominance testing binary valued polytree cp nets proof reduction cp net dominance queries classical planning problems see section dominance query respect binary valued polytree cp net compiled propositional planning problem unary operators polytree causal graph 
algorithm problem brafman domshlak time complexity algorithm maximal degree causal graph 
recall assumption degree cp net bounded constant case 
assumption justified cpts part problem description size cpt exponential pa 
complexity algorithm brafman domshlak cp nets polynomial size 
boutilier brafman domshlak hoos poole intractable dominance queries dominance testing binary valued polytree cp nets polynomial show binary valued directed path singly connected cp nets problem np complete 
proved cp net oriented extension proof corresponding claim respect planning problems brafman domshlak 
results entail dominance testing binary valued cp nets remains np number distinct paths pair nodes cp net polynomially bounded 
theorem dominance testing binary valued directed path singly connected cp nets np complete 
proof proof see appendix immediate extension directed path singly connected dags max connected dags directed graph max connected number different directed paths nodes graph bounded 
theorem dominance testing binary valued max connected cp nets polynomially bounded size cp net np complete 
proof theorem immediately entailed corresponding result planning brafman domshlak proof terms cp nets see appendix theorem implies dominance testing binary valued acyclic cp nets hard 
exact complexity problem open question clear problem np harder 
preliminary analysis problem domshlak brafman shows connection complexity flipping sequence search binary valued acyclic cp nets diameters specific graphs 
complementary result respect graphs domshlak recursively directed hypercubes shows dominance queries respect binary valued acyclic cp nets unbounded node degree may require flipping sequences size exponential wheren number variables cp net 
shown general class planning problems binary variables unary operators acyclic causal graphs harder np brafman domshlak 
result imply answering dominance queries harder np know reduction class planning problems cp nets 

search techniques dominance queries previous section showed dominance testing generally hard cp nets tractable algorithms exist specific problem classes 
cp nets impose rich structure preferences exploited various search strategies heuristics significantly reduce search effort allow effective solution problem instances 
section discuss search flipping 
polytree directed path singly connected converse true 
cp nets sequences rules allow significant pruning search tree impacting soundness completeness search procedure 
rules described context improving flipping sequences applied worsening search mutatis mutandis 
cp net outcome define improving search tree follows rooted children node outcomes reached single improving flip easy see rooted path corresponds improving flipping sequence outcome respect vice versa 
example consider preference graph shown induced cp net 
depicts improving search tree respect preference graph 
clearly treat dominance query searching node associated outcome starting root node instance example dominance query dotted paths shown bring outcome different direction tree traversal lead dead requiring backtracking order find suitable flipping sequence 
generic search algorithm traverse improving search tree find improving sequence supports dominance query 
suffix fixing suffix fixing rule allows certain moves pruned search tree impacting completeness search 
cp net variables xn numbered arbitrary topological ordering consistent network define rth suffix outcome subset outcome values xr xr xn 
notice rth suffix outcome depends topological ordering variables 
say rth suffixes outcomes match iff xj xj target search words attempting find flipping sequence proves suffix fixing rule requires rth suffix matches value neighbors explored rth suffix match equivalent ruling exploration flipping sequences destroy suffix outcome matches target outcome lemma ensures pruning branches search tree searching path affect completeness 
lemma cp net outcomes rth suffix matches topologically consistent ordering xn variables 
path root path root outcome path assigns values xr xn suffix match 
proof proof straightforward acyclic suffix variable ancestor non suffix variables 
value suffix variables influence better worse ability flip values remaining variables 

corresponding worsening search tree defined similarly worsening flips 
boutilier brafman domshlak hoos poole bc bc bc ab abc ab bc abc ab ab bc abc abc bc ab bc abc abc abc bc abc abc bc ab ab abc abc ab ab ab abc abc preference graph induced cp net improving search tree paths outcome pruning 
cp nets suppose query outcome type mentioned lemma 
subtree rooted just assured path passes path passes suffix preserved subpath conclude proposition complete search algorithm improving search tree remains complete pruning suffix rule 
suffix fixing rule effectively prunes search tree node described contain paths retain suffix values target backtracking choices lead may required may choices preserve suffixes consideration full search tree required nontrivial suffix match 
example improving search tree discussed pruned suffix fixing rule variable ordering appears 
see pruning dramatically reduce size effective search tree 
variable flipping extension suffix fixing rule variable flipping rule defined follows 
suppose cp net query outcome variable xj denote instantiation pa xj ino say xj improvable variable value dom xj xj descendent xj property 
intuitively improvable variable lowest flipped produce outcome preferred naturally may variables 
say xj improvable respect target iff xj improvable variable part suffix match words suffix matches apply definition improvable variable restricting attention variables part matching suffix 
variable flipping rule requires neighbors node expanded search improving sequence target improvable variable respect improved 
lemma ensures binary valued directed path singly connected cp nets pruning improving search tree variable rule affect completeness search procedure 
lemma binary valued directed path singly connected cp net outcomes rth suffix matches topologically consistent ordering xn variables 
om set outcomes reachable variable flip affect matched suffix 
path root path os 
proof loss generality earlier observations assume suffix match restricting attention set non suffix variables affect argument 
boutilier brafman domshlak hoos poole assume contradicting statement theorem variable flips os path exist path implies variable flips involve leaf variables network flip value leaf variable effect ability flip variables able construct path passes os flip leaves 
consider leaf variable xi dealing binary variables irreducible flipping sequence value xi flipped exactly 
current assignment pa xi allow perform flip see observation 
achieve assignment pa xi flip value xi making part suffix match 
subnetwork induced xi ancestors xi directed path singly connected forms tree directed root xi 
reduce removing subtrees variable flipped note step cause loss generality due acyclicity assignment variables flipped improving flipping sequence likewise xi xi corresponding variable flips single directed path xik xi 
xij tree separates variables xij paths set flips variables enable flip values variables particular flip pa xi enabled 
enable flip xi eventually flip value variable xi xi 
ii value flip xi xi affect positively negatively ability flip values variables 
improving flipping sequence sequence starts value flip variable xi xi observation contradicts assumption flipping sequence pass os 
variable flipping rule distinguish flips different candidate improvable variables simply restricts flips variables 
general flips suitable may lead dead ends requiring backtracking point illustrated section 
backtrack need consider variable flips flips significantly reducing size search tree expected amount backtracking 
observe algorithm binary valued tree structured cp nets essentially implements variable flipping rule complete backtrack free search procedure binary valued tree structured networks 
examples show lemma presents probably widest class variable flipping rule complete example shows flipping rule preserve completeness binary valued max connected cp nets cp nets example shows multi valued directed path singly connected cp nets 
note cp net example forms chain 
binary valued treestructured cp nets probably widest class cp nets variable flipping rule complete backtrack free 
example consider binary valued cp net depicts graph cp net shows corresponding cpts 
query abcde improving tree rooted 
improvable variable flipped root outcome flipped improvable 
unfortunately flipping value leads outcome target abcde unreachable order reach target value variable achieve assignment variables ii achieving assignment flip question possible restoring value iii flipping value lead situation longer flip preventing achieving target value variable flipping rule allow discovery improving flipping sequence 
hand flipping sequence abcde proves query bc bcd abcd abcde sequence requires flipped root despite fact improvable variable 
example consider chain cp net variables andc parent andb parent suppose domain domain andc domain conditional preferences consider query ab ab 
improved context improved context fact improvable variable flip outcome ab 
unfortunately flip leads outcome ab path target ab exists 
contrast flipping non improving variable allows discovery successful improving path flipping change 
boutilier brafman domshlak hoos poole variable cpt multiply connected cp net variable flipping rule causes incompleteness 
multiply connected networks networks multi valued variables variable flipping rule complete believe provide useful heuristic guidance cases 
variable heuristic heuristic ordering children improving search tree requires expanding node respect target children corresponding improving variables explored 
typically reduce number nodes expanded tree heuristic viewed embodying form commitment 
flipping values improving variable seen leaving maximum flexibility flipping values variables 
upstream variable limits possible flipping sequences drastically downstream variable altering variable limit ability flip values non descendants 
multivalued networks commitment strategy extend variable heuristic improving rule alternative improving flips improvable variable considered improving flip improving flip flip leads preferred improving value adopted 
allows greater flexibility movement downstream variables 
improve value variable question preferred value preferred value provided parent values maintained skipping values may prevent setting descendants desired values 
fact illustrated example crucial flip variable improving rule heuristic leads directly target outcome 
cp nets forward pruning search procedure improving flipping sequence matter procedure adopts heuristics general forward pruning technique 
technique number desirable properties quickly shows flipping sequence possible prunes domains variables reduce flipping search space doesn compromise soundness completeness relatively cheap time complexity number variables maximum number conditional preference rules variable size largest variable domain 
general idea sweep forward network pruning values variable appear improving flipping sequence query 
intuitively consider set flips possible ignoring interdependence parents number times parents change values 
consider variables order consistent network topology parents node considered node 
variable xj parents build domain transition graph nodes corresponding possible values xi dom xj 
conditional preference relation dom xj xu contains unpruned values parents xj include directed arcs successive values ordering arc xi xi foreach 
answering query prune value xj directed path xj xj domain transition graph xj 
implemented running known dijkstra algorithm cormen rivest twice find nodes reachable xj find nodes reach xj 
sets nodes intersected find possible values xj path xj xj int improving sequence xj xj respect 
intersection empty dominance query fails legal flipping sequence xj xj 
results quick failure straightforward queries carry search non obvious cases 
example consider cp net binary root variables preferences values query 
domain transition graph consists arc pruned 
example changed slightly third value wherea third value pruned simplifying tables children consider domain transition graph consists single arc value purported preferred outcome query reachable domain transition graph value purported preferred outcome query query fails quickly looking variables 
boutilier brafman domshlak hoos poole 
incompletely specified preferences indifference practical applications expects see reluctance behalf user provide complete cpts totally order values variable possible context 
natural ask results techniques applied cases 
turns results linear time procedure ordering queries easily extended cp nets partially specified cpts satisfiable cp nets capture statements preferential indifference 
instance results section respect dominance queries remain applicable results shown brafman domshlak valid general setting classical planning 
case analyzed domshlak brafman case tree cp nets 
correctness procedure extended cp nets easily verified complexity remains quadratic 
stems fact lemma valid general planning setting brafman domshlak 
point requires clarification difference partial specification indifference respect flipping sequences variable parents values dom equally preferred flip value vice versa 
alternatively incomparable flip value 
complexity dominance testing context indifference incompletely specified cpts remains open problem 
theorem shows flipping sequence search multi valued cp nets partially specified preferences np cp net forms chain variables valued 
theorem flipping sequence search multi valued cp nets partially specified preferences np 
proof proof see appendix consider outcome optimization queries 
cpts allowed partially specified statements indifference allowed cp net may induce nondominated outcome 
instance consider example dinner 
preference type wine fish soup specified decision maker considers red white wine go equally fish soup cp net induces nondominated outcomes fish soup white wine fish soup red wine 
forward sweep procedure outcome optimization queries section easily extended cases partial specification indifference adding branching variable generated assignment pa induces nondominated value dom 
complexity resulting algorithm number variables cp net number nondominated outcomes induced cp net 
course exponential size cp net 
adapted forward sweep procedure anytime property solutions generated iteratively time add new nondominated 
tight upper bound shown cp net simply leaving cpts unspecified 
cp nets outcome current set generated solutions 
complexity generating nondominated solutions linear important query answered efficiently standard cp nets outcome ordering query see section 
basic corollary remains valid case cp nets partial specifications statements indifference case theorem 
computational complexity ordering queries extended cp nets remains open question conjecture problem hard 

concluding remarks introduced cp nets new graphical model representing qualitative preference orderings reflects conditional dependence independence preference statements ceteris paribus semantics 
formal framework offers compact arguably natural representation preference information allows efficiently answer principal forms preference queries 
described types queries algorithms answering respect specific cp net 
particular outcome optimization outcome ordering queries shown solvable time linear number variables network 
dominance queries situation complicated 
demonstrated equivalence answering dominance queries task determining existence improving worsening sequence variable value flips respect cp net 
reduced task special subclass classical planning problems 
insights allowed show general answering dominance queries np hard polynomial algorithms exist tree polytree structured binary valued cp nets 
addition techniques generic search procedure improving flipping sequence 
techniques shown impact soundness completeness search cp net techniques property binary valued cp nets 
argued techniques modified general purpose heuristics reduce significantly size expanded search tree 
analyzed applicability results cp nets allow partially specified preferences capture statements indifference 
applications goal developing cp nets formalism facilitate development applications 
application preference driven adaptive multimedia document presentation developed ben gurion university domshlak 
described central components system section 
application conceptual computational properties cp nets useful distributed meeting scheduler 
basic prototype system implemented ben gurion university brafman domshlak 
currently extending system working related theoretical issue multi agent preference optimization 
potential application qualitative preferences general particular sorting product database user specified preferences 
problem highly relevant context electronic commerce 
boutilier brafman domshlak hoos poole conceptually simplistic quite interesting commercial applications rely unconditional preference statements available world wide web examples include active sales assistant tm see www com tm see www com 
general idea assist user selecting specific product product database preferences 
important compact natural representations preference information 
cp nets extend current models typically don allow conditional preference statements offer efficiency ordering set alternatives 
important aspect problem database precisely defines products represented vectors attribute values available preference information required extent narrows choice product sufficiently small selection products database 
graphical properties cp nets underlying efficiency ordering queries various dominance testing strategies exploited context find subset products dominated product database conditional preference information extracted user 
interactive dynamic approach appears promising user prompted additional preference statements ordering products database sufficiently constrained preference information offer reasonably small selection products 
growing application area cp nets automated constraint product configuration sabin 
task assemble number components compose product compatibility constraints satisfied 
simple example assembly components computer system instance type system bus constrains choice video sound cards 
wide growing body research modeling configuration problems efficient problem solving methods need modeling learning user preferences achieve configurations feasible satisfactory user point view 
issues emphasized papers configuration freuder sullivan junker soininen niemel especially high level specific real life domains discussed 
importance incorporating user preferences configuration problem stems fact problems weakly constrained numerous feasible solutions ambrosio birmingham 
value solutions subjective point view particular user may vary significantly 
cp nets represent user preferences compatibility constraints search preferred feasible configurations 
contrast database sorting application set possible vectors feature values configurations explicitly implicitly specified compatibility constraints 
cp net search algorithm boutilier 
specifically designed address problem 
description algorithm analysis computational properties refer reader boutilier 
brafman domshlak 
related cp nets number lines research related cp nets 
addition conceptual philosophy philosophical logic described section ai doyle wellman explored ceteris paribus assertions logical properties 
exploit notions preferential independence particular considered graphical representations preference statements 
best knowledge computational results known formalism 
clear useful queries answered efficiently framework 
surface cp nets reminiscent bayesian networks pearl graphical structures capturing conditional independence assertions 
bayesian networks utilization probabilistic independence provide important motivation structures differ considerably properties type information 
motivated considerations driving bacchus grove la shoham study different notions independence associated graphical representations 
representations allow quantitative assessments cp nets current form differ cp nets precise nature independence concept studied 
particular bacchus grove concentrate notion conditional additive independence 
additive independence strong property requiring utility outcome sum utilities different variable values outcome 
conditional additive independence weaker requirement promising practice 
bacchus grove show conditional additive independence properties domain captured undirected graph set nodes independent separates nodes la shoham define concept independence ceteris paribus comparison operator utilities 
operator measures intensity preference specific values certain variables fixed value variables respect fixed point 
define undirected graphical structure expected utility networks independence represented notion node separation 
benferhat dubois prade provides preliminary investigation potential possibilistic logic qualitative decision analysis specifically qualitative preference representation 
possibilistic approach takes utilities account probabilities provides qualitative approach decision problems replacing numeric preferences probabilities linear orderings 
discussion approach utilities preference representation see benferhat 
dubois godo prade dubois prade dubois prade related qualitative models see boutilier tan pearl 
see number potential extensions described 
particular leaves number interesting open theoretical questions 
worst case complexity dominance testing respect acyclic binary valued cp nets needs boutilier brafman domshlak hoos poole established open question problem np 
second complexity dominance queries respect multi valued cp nets remains open problem 
third clear hard ordering queries cp nets capture partial preference specification statements preferential indifference 
need understand expressive power cp nets better specifically sort partial orderings representable cp nets orderings representable cp nets ones represented cyclic network 
cyclic networks important challenge 
networks arise applications natural notion neighborhood defined set variables preferences variable value depend value neighboring variables 
cases user may find natural provide cyclic preference structure able determine specified network satisfiable 
addition inference methods networks need developed alternatively methods reducing cyclic networks acyclic networks significant blow size 
number papers started deal question interesting insights results domshlak domshlak brafman brafman dimopoulos domshlak rossi walsh 
working various extensions framework 
extensions include conditional preference statements contain small amount quantitative information 
existing applications online interactive consumer guides suggest limited amount quantitative preference information relatively easy extract user natural way useful inducing stronger preference orderings 
preliminary topic undertaken boutilier bacchus brafman 
interesting extension cp nets tcp nets brafman domshlak 
tcp nets add importance relations conditional relative importance statements conditional ceteris paribus statements supported cp nets 
conditional importance statements form optimizing important optimizing 
example flying night having better seat important getting preferred carrier preference optimization presents interesting tradeoff amount user interaction required extracting preference information amount computation needed determine preferred feature vectors 
asking specific questions particular potentially complex preferences finding preferred feature vectors easier 
hand asking questions especially really necessary establishing relevant preferences annoy user system usable 
finding tradeoffs amount user interaction computation time answering queries finding preferred items database optimal configurations promising direction research 
related motivation underlying goal programming dyer 
structure cp nets exploited determining preference elicitation strategies 
explored context cp nets quantitative information boutilier remains seen techniques purely qualitative setting 
acknowledgments cp nets parts appeared boutilier brafman hoos poole reasoning conditional ceteris paribus preference statements proceedings fifteenth conference uncertainty artificial intelligence pp stockholm domshlak brafman cp nets reasoning consistency testing proceedings eighth international conference principles knowledge representation reasoning pp toulouse 
chris geib contributions earlier related models cp nets anonymous referees useful suggestions 
boutilier hoos poole supported natural sciences engineering research council institute robotics intelligent systems 
brafman acknowledges support paul center robotics research production management 
appendix theorem lower bound flipping sequence search binary valued tree structured cp nets 
proof proof example dominance testing query binary valued tree cp net size minimal flipping sequence 
consider cp net defined binary variables xn domain variable xi xi xi xi 
pa xi xi forms directed chain 
cpts capturing preferences values xn shown 
consider dominance testing query xi xi xi xi xi length minimal flipping sequence proving required lower bound 
jth flip sequence changes value variable xk mod informally flips change values xk xn order flips change values xk xn xn flips change values xk 
sets flips length flipping sequence 
illustrates corresponding flipping sequence 
variable xi annotated value flips flipping sequence arrows values stand value flips sequential numbers flips flipping sequence appear arrow labels 
boutilier brafman domshlak hoos poole variable cpt xi xi xi xi xi xi xi xi xi xi xi xi xi illustration proof theorem cpts variables flipping sequence 
prove size minimal flipping sequence example 
divide proof steps show minimal flipping sequence 
variable xk variables change value times 
variable xj variables change value times 
proof claim induction fori xn change value 
assume induction hypothesis variable xk change value times prove claim xk 
recall xk parent xk pair successive flips xk require different values xk 
assume 
flip xk xk xk requiring xk take value xk xk xk 
flip xk may performed flip xk flip number xk change value times 
flips variable xk assigned value xk xk 
xk xk change value time 
proof case odd similar flip xk xk xk requiring xk take value xk xk xk 
cp nets flip number xk change value times 
odd flips variable xk assigned value xk 
xk xk xk xk change value time 
proved xk change value times 
proof second claim induction show xk change value times 
claim xk changes value times 
pair successive flips xk requires different values xk change value times 
assume induction hypothesis variable xj change value times prove claim xl 
pair successive flips xl requires different values xl change times 
theorem dominance testing binary valued directed path singly connected cp nets np complete 
proof 
dominance query denote size minimal shortest improving flipping sequence property variables upper bound straightforward lemma maxflip xi xi guess minimal improving flipping sequence solvable problem verify low order polynomial time 
proof hardness reduction sat problem finding satisfying assignment propositional formula conjunctive normal form conjunct clause literals 
cn sat propositional formula xm variables equivalent problem constructed follows vm vm cn domain xi stand false true respectively 
pa vi pa vi pa ci vi vi vi vi vi vi xi xi xi variables participate ith clause outcome assigns variables outcome assigns variables variable vi vi unconditionally preferred value turn preferred value variable ci exist 
vij vij boutilier brafman domshlak hoos poole 
literal xij xij belongs clause ci vij vij ci value preferred value variable ci 
constructed inference problem directed path singly connected binary valued cp net pa xi 
show improving flipping sequence exists satisfying assignment 
satisfying assignment improving flipping sequence follows flip value variable vj xj flip value variable vj actual ordering flips irrelevant variables mutually independent 
flip value ci ordering flips significant 
flip values variables vj vj value improving flipping sequence flipped variables vj vj pa ci values respectively variable xj set true 
ci flipped variables vj vj pa ci values respectively variable xj set false 
existence ensured construction cpt ci 
turn vj vj achieve value achieving value outcome vj vj outcome vj vj vice versa 
shows value variable ci flipped context consistent 
close ci literal lij ci lij 
theorem dominance testing binary valued max connected cp nets polynomially bounded size cp net np complete 
proof prove theorem showing acyclic binary valued cp net variable xi wehave maxflip xi xi xj xi xj denotes total number different necessary disjoint paths xi xj 
simplicity presentation assume variables xn numbered topological order induced graph rewrite eq 
maxflip xi xi xj proof induction fori obvious maxflip xn xn leaf node assume lemma holds prove loss generality assume exist variable xj xk pa xj 
simply maxflip xk 
cp nets denote succ xk immediate successors xk xik succ xk pa xik 
proof straightforward maxflip xk lemma xi succ xk succ xk xk xj maxflip xik xi succ xk ik xik xj binary valued cp net max connected variables problem considered topological ordering induced eq 
follows variable xi wehave maxflip xi denote size minimal shortest improving flipping sequence 
eq 
follows polynomially bounded size guess verify minimal improving flipping sequence polynomial time class dominance testing queries np 
theorem flipping sequence search multi valued cp nets partially specified preferences harder np 
proof proof example dominance query multi valued chain cp net partially specified preferences minimal flipping sequence exponentially long 
consider cp net defined valued variables xn domain variable xi xi xi xi xi 
pa xi xi directed chain 
cpts capturing preferences values xn shown 
consider dominance testing query xi xi xi xi 
sequence ai defined ai ai length minimal flipping sequence greater ai illustrates corresponding flipping sequence variable xi annotated value flips flipping sequence arrows boutilier brafman domshlak hoos poole variable cpt xi xi xi xi xi xi xi xi xi xi xi xi xi xi xi xi xi xi xi xi xi xi xi xi xi values stand value flips sequential numbers flips flipping sequence appear arrow labels 
prove size minimal flipping sequence dominance query greater ai 
divide proof steps step shows necessity ai flips flipping sequence subsequent steps prove existence flipping sequence recall forms chain xi parent xi value flips xi depend value xi 
steps proof follows cp nets flipping sequence variable xk variables change value ak times fk ak corresponding sequence flips xi ak wehave xi xi xi xi xi xi xi xi variable xi variables change value ai times fi ai corresponding sequence flips xi ai flip consistent eq 

sequence flips xk variable xk change value ak times ak wehave ak xk xk xk xk corresponding sequence flips xk sequence flips xk feasible sequence flips xk 
step proof induction fori xn change value twice value induces 
way change value flip 
note flips consistent eq 
ak established induction base 
assume induction hypothesis variable xi change value ak times eq 
prove claim xk 
consider sequence flips xk assumed necessary fk cpt xk wehavethat pair successive flips xk require different values xk ii required values xk xk xk iii flip xk xk xk xk xk xk 
xk perform ak value changes xk xk back order support required value changes xk addition supporting value changes xk perform value change xk xk see eq 
xk xk xk xk 
ak boutilier brafman domshlak hoos poole cpt xk value change xk xk xk xk xk consists flips initial value xk xk target value 
proved xk perform ak ak value changes value changes consistent eq 

step proof induction forx proof straightforward allows flip value 
assume induction hypothesis variable xi change value ai times eq 
prove claim xi 
proof apparent cpt xi outcomes query induction hypothesis 
value achieved xi sequence ai flips including initial value xi xi xi flip value twice xi xi xi xi flip value xi xi xi xi xi 
alternatively xi xi flip value xi xi xi xi xi 
xi flip value ai ai times easy see value flips xi consistent eq 

step sequence ak flips fk ak xk eq 
val dom xk value xk achieved flip ak 
cpt xk entails triple values xk achieved triple successive flips fk fk ak addition know val xk xk val xk xk val xk xk val xk xk val xk xk val xk xk xk xk xk xk val xk xk xk entails xk change value ak times eq 

step proof straightforward cpt xk 
se quence xk value flips fk ak eq 
observe ak thenf wise thenf ak val cp nets supported value xk xk supported value xk xk 
xk xk apparent sequence ak value flips xk eq 
feasible sequence ak value flips xk eq 

entails size minimal flipping sequence ai greater fact show value flips xk constructed steps part minimal flipping sequence length sequence greater ai ak result achieved step proves claim exist dominance queries multi valued cp nets partially specified preferences exponentially sized minimal flipping sequences 
bacchus grove 

graphical models preference utility 
proceedings eleventh conference uncertainty artificial intelligence pp 
montreal 
bacchus grove 

utility independence qualitative decision theory 
proceedings sixth international conference principles knowledge representation reasoning pp 
cambridge 
nebel 

complexity results sas planning 
computational intelligence 
benferhat dubois prade 

possibilistic logic handling preferences 
applied intelligence 
boutilier 

logic qualitative decision theory 
proceedings fifth international conference principles knowledge representation reasoning pp 
bonn 
boutilier bacchus brafman 

ucp networks directed graphical representation conditional utilities 
proceedings seventeenth conference uncertainty artificial intelligence pp 
seattle 
boutilier brafman geib poole 

constraint approach preference elicitation decision making 
aaai spring symposium qualitative decision theory stanford 

fact ak value flips xk order perform ak value flips xk required 
flip xk order achieve value xk supporting xk 
boutilier brafman domshlak hoos poole brafman domshlak 

cp networks preference csp 
proceedings workshop modelling solving problems soft constraints cp pp 
cyprus 
brafman domshlak 

introducing variable importance tradeoffs 
proceedings eighteenth annual conference uncertainty artificial intelligence pp 
edmonton canada 
brafman domshlak 

structure complexity planning unary operators 
journal artificial intelligence research 

brafman dimopoulos 

new look semantics optimization networks 
inproceedings eighteenth international joint conference artificial intelligence acapulco mexico 
appear 
bylander 

computational complexity propositional strips planning 
artificial intelligence 
casta eda 

review logic better 
philosophy phenomenological research 
getoor norman shahar 

utility elicitation classification problem 
proceedings fourteenth conference uncertainty artificial intelligence pp 
madison wi 
cormen rivest 

algorithms 
mit press cambridge ma 
ambrosio birmingham 

preference directed design 
journal artificial intelligence engineering design analysis manufacturing 
domshlak 

modeling reasoning preferences cp nets 
ph thesis ben gurion university 
forthcoming 
domshlak 

recursively directed hypercubes 
electronic journal combinatorics 
domshlak brafman 

cp nets reasoning consistency testing 
proceedings eighth international conference principles knowledge representation reasoning pp 
toulouse france 
domshlak brafman 

structure complexity planning unary operators 
proceedings sixth international conference artificial intelligence planning scheduling pp 
toulouse france 
domshlak brafman shimony 

preference configuration web page content 
proceedings seventeenth international joint conference artificial intelligence pp 
seattle 
domshlak rossi walsh 

reasoning soft constraints conditional preferences complexity results approximation techniques 
proceedings eighteenth international joint conference artificial intelligence acapulco mexico 
appear 
cp nets domshlak shimony 

efficient probabilistic reasoning bayes nets mutual exclusion context specific independence 
appear proceedings sixteenth international flairs conference special track uncertain reasoning 
doyle shoham wellman 

logic relative desire preliminary report 
proceedings sixth international symposium methodologies intelligent systems ismis lecture notes computer science pp 

springer verlag 
doyle wellman 

representing preferences ceteris paribus comparatives 
proceedings aaai spring symposium decision theoretic planning pp 
stanford 
dubois prade 

logical representation computation optimal decisions qualitative setting 
proceedings fifteenth national conference artificial intelligence pp 
madison wi 
dubois godo prade 

making decision qualitative setting decision uncertainty case decision 
proceedings international conference principles knowledge representation reasoning pp 

morgan kauffman 
dubois prade 

possibilistic logic machinery qualitative decision 
aaai spring symposium qualitative preferences deliberation practical reasoning pp 
stanford 
dyer 

interactive goal programming 
management science 
french 

decision theory 
press new york 
freuder sullivan 

modeling generating tradeoffs constraintbased configuration 
proceedings th workshop configuration ijcai pp 
seattle 
domshlak 

remote conferencing multimedia objects 
proceedings second international workshop multimedia data document engineering 
ha haddawy 

case preference elicitation similarity measures preference structures 
proceedings fourteenth conference uncertainty artificial intelligence pp 
madison wi 


sales configuration business processes 
ieee intelligent systems applications 


logic better 
lund 
hansson 

ceteris paribus preference 
journal philosophical logic 
howard matheson 
eds 

readings principles applications decision analysis 
strategic decision group menlo park ca 


linear programming single multiple objective systems 
prentice hall englewood cliffs 
boutilier brafman domshlak hoos poole junker 

cumulative model semantics dynamic preferences assumptions 
proceedings fifteen international joint conference artificial intelligence pp 
nagoya japan 
junker 

preference programming configuration 
proceedings th workshop configuration ijcai pp 
seattle 
keeney raiffa 

decisions multiple objectives preferences value trade offs 
wiley new york 
knoblock 

automatically generating abstractions planning 
artificial intelligence 


preference choice 
theory decision 
la shoham 

expected utility networks 
proceedings fifteenth conference uncertainty artificial intelligence pp 
stockholm 
lashkari metral maes 

collaborative interface agents 
proceedings twelfth national conference artificial intelligence pp 
seattle 
nguyen haddawy 

decision theoretic video advisor 
aaai workshop recommender systems pp 
madison wi 
pearl 

probabilistic reasoning intelligent systems networks plausible inference 
morgan kaufmann san mateo 
sabin 

product conguration frameworks survey 
ieee intelligent systems applications 
shimony domshlak 

complexity probabilistic reasoning singly connected polytree 
bayes networks 
submitted publication 
shoham 

semantical approach nonmonotonic logics 
proceedings tenth international joint conference artificial intelligence pp 

shoham 

conditional utility utility independence utility networks 
proceedings thirteenth annual conference uncertainty artificial intelligence pp 
san francisco ca 
morgan kaufmann publishers 
soininen niemel 

formalizing configuration knowledge rules choices 
seventh international workshop nonmonotonic reasoning trento 
tan pearl 

specification evaluation preferences planning uncertainty 
proceedings fifth international conference principles knowledge representation reasoning pp 
bonn 


utility theory preference logic 

von wright 

logic preference essay 
edinburgh university press 
von wright 

logic preference reconsidered 
theory decisions 
reprinted von wright 
von wright 

philosophical logic philosophical papers volume ii 
cornell university press ithaca ny 
cp nets wellman doyle 

preferential semantics goals 
proceedings ninth national conference artificial intelligence aaai pp 
anaheim 

