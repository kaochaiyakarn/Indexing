state modules adaptive query processing raman ibm almaden research center almaden ibm com deshpande joseph hellerstein university california berkeley cs berkeley edu report 
ucb csd february computer science division eecs university california berkeley california state modules adaptive query processing raman ibm almaden research center almaden ibm com deshpande joseph hellerstein university california berkeley cs berkeley edu query architecture join operators decomposed constituent data structures state modules stems data ow stems managed adaptively eddy routing operator 
breaking encapsulation joins serves purposes 
allows eddy observe multiple physical operations embedded join algorithm allowing better calibration control operations 
second stem relation serves shared materialization point enabling multiple competing access methods share results leveraged multiple competing join algorithms 
architecture extends prior signi cantly allowing continuously adaptive decisions major aspects traditional query optimization choice access methods join algorithms ordering operators choice query spanning tree 
stems introduce signi cant routing exibility eddy enabling opportunities adaptation introducing possibility incorrect query results 
constraints eddy routing stems ensure correctness preserving great deal exibility 
demonstrate bene ts architecture experiments telegraph data ow system 
show simple routing policy allows signi cant exibility adaptation including novel effects automatic hybridization multiple algorithms single join 
dif cult predict values parameters govern database query execution 
cardinality estimates highly imprecise bc competing demands memory system load network bandwidth typically known runtime zl 
federated web database systems data distributions rates known advance zr uf vn 
single data source statistical properties vary time particular concern continuous query systems bbd 
interactive query systems introduce parameter vary query execution user preferences 
uncertainties led focus adaptive execution query systems includ ing tukwila telegraph aurora query scrambling stream tel ufa bbd 
adaptive approaches eddy operator ah telegraph executes queries routing tuples query modules selections joins dynamically reconsidering ordering modules tuple basis :10.1.1.34.8546
supported nsf uc micro microsoft fellowship gifts microsoft ibm intel 
infrastructure research provided nsf eia 
presents adaptation mechanism substantially enhances power eddy allow ing continuously adaptive decisions major aspects traditional query optimization ordering operators choice access methods join algorithms selection span ning tree query graph ik kbz 
core idea re ne granularity query modules breaking join modules elevating data structures typically encapsulated separate state modules stems 
join logical construct relational algebra join algorithms typically involve multiple phys ical operations 
motivation splitting joins stems decouple physical operations typically encapsulated join modules 
exposes physical operations directly eddy performance calibration ne grain routing adaptation sharing 
informally stem half join 
encapsulates dictionary data structure tuples table handles build insert probe lookup requests dictionary 
show select project join queries executed routing tuples carefully access methods data sources stems selections 
join algorithms explicitly programmed captured routing tuples stems access methods data sources 
breaking algebraic join encapsulation bene ts 
eddy monitor control physical operations normally hidden joins 
adapting tuple routing stems eddy adapts order physical operations join algorithm 
see example section allows eddy distinguish cached uncached lookups networked index join resulting simple routing policy better performance corresponding join algorithm literature 
fact appropriate routing eddy simulate hybrid join algorithms combine elements different traditional algorithms 
example shall see experi ment section eddy index hash join algorithms gradually converting query execution 
second stems provide shared data structure materializing probing data accessed table regardless number access methods join algorithms involving table 
sharing especially useful access method adaptation 
choice access methods dif cult federated systems tel table may provided multiple data sources single source may support multiple access methods corresponding different sets bind elds 
eddy run multiple access methods concurrently dynamically choose observed performance 
stems helps avoid redundant competition access methods table build stem 
eddy routing policy effectively try multiple competing join algorithms lookups table probe stem advantage shared materialization 
exibility enabled stems comes challenge arbitrary routing multiple access methods stems may correspond valid query execution plan 
incorrect routing lead duplicate results missing results nite routing loops 
develop set constraints routing guarantee correct query execution section preserving opportunities exible kinds adaptation described 
hash jn static query plan indx jn allow dynamic join selection ordering hash jn eddy indx jn eddy join modules allow competitive access methods join algorithms spanning trees eddy eddy stems table join performed ways 
eddy continually routes tuples modules run concurrent threads 
indexes represented triangles shown encapsulated index join suggested ah 
stems shown sideways triangles half signify half joins 
example consider join tables equi join predicates suppose scan access method relation index access method corresponding join attributes shows ways running query 
traditional statically chosen query plan involving hash join index join 
shows approach ah eddy dynamically adapt join order controlling tuple ow joins 
note approaches index access method pre chosen implementation rs st joins 
shows query executed stems 
access methods data sources treated query modules simultaneously 
tuples coming eddy access methods routed joins stems access methods 
plan allows access methods variety routing decisions correspond different join algorithms join orders 
develop details approach body 
background setting telegraph adaptive data ow system querying streams networked data tel 
early application telegraph federated facts figures fff query system combine data diverse distributed data sources 
include relational databases websites providing services data backed databases called deep web lex 
example query web sources listing contributors election campaigns federal election commission fec database demographic information neighborhoods yahoo demographics database crime ratings area com crime 
select avg contribution avg state fec demographics crime zip zip zip zip group state various factors discussed earlier interest adaptive query execution motivated unpredictable properties fff volatility distributed data sources web sources autonomously maintained speeds availability hard estimate optimization time vary query execution 
volatility user interests online query processing users specify queries itera tive exploratory fashion fff uses online performance metric rh gives partial results query execution 
user sees partial results interests different parts result may change 
outline rest develop stem mechanism show helps environment fff 
description modules architecture section describe arbitrary select project join queries executed correctly modules section 
experimental study illustrates various kinds adaptations allowed stems performance bene ts get online query processing metric section 
discuss related section conclude discussion implications stems directions section 
mechanics query execution stems section rst describe modules architecture including state modules stems discuss instantiated arbitrary query 
illustrate simple important example modules ary version symmetric hash join operator 
eddy state access selection modules architecture uses kinds modules selection modules correspond query predicates access modules correspond access methods data sources state modules stems encapsulate data structures traditional join algorithms nally eddy module routes tuples modules module runs asynchronously separate thread asynchrony achieved single threaded implementation 
describe module functionality detail 
simpli ed pseudo code table 
start de nitions 
de nition base table component span consider tuple belongs join base tables 
tk 
projections columns base tables form relations single row 
rows called base table components tt tt 
denote tt tt 
say spans tables 
tk 
de nition singleton tuple singleton tuple contains single base table component 
discussions query plans devote explicit modules projection assume done module aggressively semantically possible 
group aggregation complex select list expressions implemented eddy results output user 
module input tuple output tuple action sm bounce back iff matches predicate am asynchronously bounce back matches asynchronously return matches eot return eot matches returned 
stem build stem 
eot build eot stem 
asynchronously bounce back needed correctness section 
find matches tuples stem 
concatenated results concatenate matches return concatenated results 
asynchronously bounce back needed correctness section 
eddy module table functionality main query processing modules architecture 
eddy role continuously route tuples rest modules routing policy 
module eddy processes tuple generate tuples send back eddy routing 
optionally return bounce back eddy requires additional processing 
tuple removed eddy data ow sent output spans base tables veri ed pass predicates 
eddy terminates query tuples data ow module nished processing tuples sent 
tuple carries state called track done furthering query progress 
exact structure depends routing policy 
bare mini mum contain tables spanned tuple predicates tuple passed implementation uses bitmap done bits ah :10.1.1.34.8546
denotes type tuple eddy decide tuple ready output 
fact state suf ces special class cyclic queries discuss exception section 
selection modules sms selection modules sms simple 
selection module receives input tuple returns eddy passes selection predicate removes data ow 
passes predicate marks fact eddy track progress access modules ams access module am encapsulates single access method data source scan index set columns 
access method relation encapsulated separate am 
tuple routed am called probe tuple corresponds request am output tuples match probe tuple matches am table concatenation satis es query predicates de ned union columns spanned note output schema am data source 
particular predicates enforced index lookup am applies lookup 
am concatenate probe tuple output tuples 
concatenation performed stems 
scans treated ams accept special empty probe tuple call seed tuple return output tuples data source 
query initialization scan am initialized passing seed tuple informs returning contents full scan eddy 
addition returning matches ams asynchronously bounce back probe tuple eddy 
intuitively bounce back required probe tuple needed eventual concatenation matches 
discussed detail section 
asynchronous indexes demonstrated gw throughput accesses web sources improved signi cantly sending multiple asynchronous probes similar arguments asynchronous random disk os 
spirit assume am probes responses asynchronous 
asynchrony complicates issues somewhat system needs track matches returned probe 
data ow pass information 
am table returned matches probe sends transmission eot tuple encoding probing predicate case scan am predicate simply true 
common case index lookups equality predicates eot tuple regular tuple special eot value non bound elds john eot eot 
probe tuple binds rst elds john 
non equality predicates eot tuple contains pointers predicates stored data structure created query parsing 
scans eot predicate contains predicate true 
advantage encoding tuples control messages stored stems alongside standard tuples see 
state modules stems stem essentially corresponds half traditional join operator 
stores homogeneous tuples tuples spanning set tables formed query processing supports insert build search probe optionally delete eviction operations 
consider stems base tables tuples stem singleton tuples table 
joins base table stem builds probes involving base table 
purpose allow stem perform searches arbitrary predicates 
kinds tuples routed stem 
build tuple routed added set tuples indexes updated accordingly 
eot tuple am routed build tuple probe tuple routed returns concatenated matches eddy 
concatenated matches tuples satisfy query predicates evaluated columns note stem continually built may tuples 
tracked presence eot tuples 
eot tuple matches probe knows de nitely contains matches probe stem bounce back routed modules nd missing matches 
logic bounce backs logic simpli ed assumes tuples am arrive stem order 
fact implementation eddy reorders tuples data ow match user interests rh 
eot tuple probe built stem needed determined routing constraints developed section 
implementation speed join predicate lookups indexes 
stem table called main memory index hash table binary tree column involved join predicate 
secondary indexes having pointers tuples memory 
focus disk resident indexes datasets encountered web sources typically small main memory 
defer discussion multi table stems disk data management stems section 
query planning eddy stems obviates need query optimization priori decisions 
ah need pre optimizer chooses join implemen tations access methods query spanning tree :10.1.1.34.8546
query instantiated follows 
check query valid executed bind eld constraints data sources algorithm nail mor 

create am access method possibly query 

create sm predicate query 

create stem base table query 

create seed tuples needed scans section 
described earlier section stem created data source 
stem shared join predicates involving data source multiple instances source clause exist self join 
focuses execution single query stem share storage concurrent queries 
related telegraph uses stems way context continuous query processing cf 
example way symmetric hash join give example modules implement way version symmetric hash join shj rs wa 
traditional binary shj pipelining join works simultaneously building hash tables inputs 
input tuple rst built hash table input immediately probed hash table input 
due pipelining nature operator suited interactive processing 
originally designed memory resident algorithm subsequently extended uf spill disk memory constrained environments 
ways extend shj multi table queries 
consider equi join pipelining binary joins shows multiple binary pipelined perform way shj 
best knowledge approach choice current literature uf 
ary shj operator ii shows uni ed single operator uses hash indexes join column secondary index 
new tuple comes rst built corresponding hash index ra htb matches probe built 
solve tag eot tuple number probe matches allows stem verify matches built 
hash jn hash jn ra sa sb tb ary hash jn ii iii ra sa sb eddy ways doing table symmetric hash join shj pipelined binary ii ary shj operator iii eddy stems probed hsa 
resulting matches probe htb result output 
new tuple comes similarly built hsa point choice corresponding different join orders 
probe tuple probe htb resulting matches probe htb 
initial eddy ah rst approach connecting set pipelining binary join modules external eddy module ordering join modules decided dynamically 
contrast stems mechanism second approach essentially places eddy ary shj operator ordering hashtable lookups decided dynamically 
core effect stems give eddy access data structures typically stored inside join algorithms 
stem approach implemented part shj generally applicable 
iii illustrates translation uni ed ary shj operator routing stems 
stem source encapsulate hash indexes source eddy route tuples stems 
tuple rst built stem source immediately routed stems 
eddy dynamically adapt join ordering changing way routes tuples built stems 
addition different routing opportunities ary hash join materializes different state traditional binary shj scheme 
note way shj description stores singleton tuples hash tables traditional pipeline binary materializes intermediate result tuples joins root tuples 
stems principle support scheme stem materialize base table intermediate relation desired 
represents tradeoff performance memory space memory intermediate result tuples stored probes may need intermediate results may need recomputed multiple times 
cf choose store intermediate tuples stems 
addition space time tradeoffs secondary advantage materializing intermediate results tuple eviction simpli ed 
base table component stored single stem easily evicted stem needed 
focus sliding window queries queries unbounded data streams require tuple eviction cf stems eviction 
currently investigating hybrid approach partially materializes intermediate results extent available tb memory section 
ary shj select project join query sources scan access methods 
section generalize simple operator join algorithms index access methods show eddy dynamically adapt join algorithms access method choices spanning tree choices 
executing arbitrary select project join queries stems super cially query execution stems simple 
need instantiate ams stems sms section eddy route tuples operators 
problem arbitrary routing policies need lead correct results terminating queries 
want eddy adapt routing dynamically develop constraints routing policy ensure correctness 
ary shj operator corresponds correct routing policy 
start identifying routing constraints implicit operator gradually generalize constraints larger space queries 
presentation intended intuitive informal proofs correctness appendix acyclic spj queries single scan am table ary captured rules 
rst stems implemented hash indexes 
second eddy obey routing constraints singleton tuple table rst routed build stem stem bounce back build tuples probe stems matches bounce back probe tuples 
atomicity building singleton tuple stem atomically coupled probing tuple stems 
tuple routed module 
rst constraints capture essence ary shj ensures query termination 
relaxations constraints allow eddy adapt wider space join algorithms 
constraint relaxation allow join algorithms rst relaxation removes constraint stems implemented hash indexes 
example stem may linked list holds small number tuples switch hash implementation list size increases 
switch independent modules 
relaxation remove atomicity constraint decouple build probe operations tuple 
allows eddy interleave probes builds tuples arbitrary ways change join algorithms section relax allowing build completely avoided 
unfortunately build probe decoupling cause duplicate query results 
example fig ure shows steps shj 
satis es join predicate output step 

probe 
probe eddy 
duplicates arise decoupling build probe ui ld probe rs matches eddy rs matches probe matches query index ams step builds probes tuples interleaved 
avoid duplicates add timestamp constraint ram form set constraints singleton tuple table rst routed build stem stem stems bounce back build tuples bounce back probe tuples 
tuple routed module 
timestamp singleton tuple assigned global timestamp wall clock time builds stem 
building de ned 
tuples 
tn de ned max 
tn timestamp base table component 
tuple probes stem nds match result returned eddy iff 
timestamp constraint says arriving base table component result tuple generate tuple probing stems join previously arrived components 
simulating non pipelined join algorithms relaxed constraints allow eddy simulate join algorithms shj 
consider table join policy simulate non pipelining join algorithms 
route tuples build 
route tuples build stems 
route tuples probe 
route tuples probe stems stem implementation decides exactly join algorithm simulated 
asynchronous hash index implementation simulates grace hash join 
build tuples routed stems stems create hash partitions disk 
bouncing back build tuples immediately asynchronously clustered hash partition 
step bounced back tuples probe gets locality 
timestamp constraint step produce results 
completely avoided maintaining stem minimum timestamp tuples stem contains eddy need route stem che probe tuples timestamp greater minimum timestamp 
unusual describe grace hash join terms routing policy 
advantage eddy dynamically shj grace hash join changing routing follows 
steps steps eddy dynamically decide interleave 
speci cally tuple bounced back building stem eddy may choose immediately probe stems 
choice level interactivity desired user 
instance eddy start frequent probes give interactive responses early degenerate occasional probes order reduce completion time probes infrequent probes partition clustered cost lesser 
frequent probe phase simulates shj occasional probe phase similar grace 
exactly analogous implementation stems tournament trees spill sorted runs disk simulate sort merge join knu 
hybrid hash join simulated stems maintain full memory hash table partitions bounce back build tuples partitions ahead 
eddy route tuples memory partitions probe tuples built 
note part join logic choosing indexes hash indexes tournament trees captured stems implementation 
stem implementation internally adapt needed 
remaining part interleaving builds probes captured routing policy dynamically adapted eddy 
competitive ams expand class queries include tables am 
alternate ams common web sources telegraph fff 
different websites provide data single website may support multiple ams corresponding different sets elds chosen lookup key 
address tables multiple scan ams section discuss index ams section 
traditional database systems typically pick am data source optimization time 
want able run multiple ams single source competition eddy dynamically choose am switch ams 
example particular am stalls underlying source delayed eddy able alternate ams 
architecture quite straightforward access methods exposed eddy 
main problem turns duplicates tuple generated different ams 
constraint duplicates easily removed build stem source 
need simple enhancement stem constraint stem stems bounce back build tuple duplicate stems 
aside duplicate semantics rules applied deal duplicates including set bag semantics see alb 
identical tuples identi ed value key column may projected result projection postponed till result output stem preserve exact number duplicates source 
issue complicated ams involve different possibly inconsistent web sources 
currently adopt set semantics stem removes build tuple identical tuple stem 
index ams data source index am encounter problem 
shows execution sim ple table join query class 
recall indexes allowed return matches asynchronously 
tuple rst built probed stems see matches cached 
matches cached bounced back stems probe ams difference previous section scan am probe index am seed generation matches 
subsequently index ams return matches say 
matches rst built stems probed 
probe join possibly tuples 
role rendezvous buffer gw hold pending probe tuples matches arrive 
built stems subsequent tuples bind column values nd index matches stems 
stems bounce back tuples stems veri es relevant matches checking eot tuples 
stems role cache index lookups fact multiple ams source cooperate building cache probing alternate ams wasted 
see experimentally section reduces cost competition 
data source scan index ams tuple routing determines index join performed hash join performed 
see experiment section eddy dynamically adapts routing switch query execution 
summarize enhanced stem constraint follows stem stems bounce back build tuple duplicate previously stems 
stems bounce back probe tuple scan am stems contains matches mentioned section stems uses presence eot tuples probes ams verify stems contains matches probe tuple 
cyclic queries query join graph complicates matters 
traditionally plan chosen query optimizer contains join modules spanning tree query join graph 
spanning tree determined query execution prior adaptive query processing schemes initial eddy ah 
static spanning tree choices hurt ways spanning tree choice typically selectivities hard estimate queries web sources 
resulting execution strategy arbitrarily sub optimal 
static spanning tree choice constrain generation partial query results 
consider way join join predicates pair tables 
choose spanning tree source stalls query execution entire query blocks 
spanning tree changed dynamically rt tuples generated 
partial results missing values columns valuable interactive querying environments rh 
problem xing spanning tree priori duplicates arise timestamping 
consider sequence events way join query tuple probes stems nd match probes nd match stems bounces back stem constraint probes produce probes stems produce 
avoid duplicates ensure previously bounced back tuples probe stems 
constraint tuple bounced back probing stems probe stem 
routing policy maintain data ow routing modules probed am de nition prior probe completion tables tuples bounced back probing stems called prior 
corresponding table called probe completion table ams called probe completion ams identity probe completion table marked relaxing constraint constraints developed far guarantee select project join queries executed correctly 
constraints constraint particularly restrictive result highly cient execution situations input tables larger 
suppose table larger tables example iii 
case better build stems tuples probe tuples directly stems building 
equivalent building temporary index side join 
enable optimizations allowing eddy build stem table long access method access method scan 
multiple access methods index am stem required avoid duplicate results 
tuple bounced back stems means matches tuple time 
tuple needs routed back stems nd remaining matches 
relax constraint allow eddy route tuple repeatedly module 
ensure repeated probes produce duplicates assign tu ple 
initially set 
time tuple routed stems note happens scan am stems bounce back tuples sent section 
constraints enforced routing policy implementor tuple routed module nite number times 
singleton tuple table rst built iff multiple ams index am prior prober routed stem probe completion table 
eddy remove prior prober data ow probed probe completion ams 
constraints enforced stem am implementation stem stems bounce back build tuple duplicate tuple stems 
stems bounce back probe tuple stems contains matches scan am base tuple components cached stems timestamp tuple probes stem nds match result returned eddy iff 
table routing constraints ensure correct query execution updated maximum timestamps tuples stems 
constraints developed far summarized table 
notice stem timestamp rules implemented internally ams stems routing policy implementor need aware 
correctness theorems proved appendix theorem duplicate avoidance eddy follows routing policy satis es constraints table arise duplicate versions tuple data ow singleton tuples built stems 
theorem correctness eddy follows routing policy satis es constraints table output tuple query result output query result tuples nite number routing steps 
experimental results illustrate kinds adaptation stems enable experimental study 
focus online metric maximizing rate result tuples generated experiments demonstrate effectiveness system traditional metric completion time 
experiments implementation stems telegraph tel run lightly loaded machine dual mhz pentium iii processors mb ram running redhat linux 
salient points experimental study follows simple join algorithm index join encapsulates multiple physical operations causes head line blocking problem 
problem avoided breaking join module stems 
stems allow eddy ef ciently learn competitive access methods doing redundant 
stems allow eddy dynamically choose join spanning tree cyclic queries 
stems allow eddy dynamically switch index join algorithm symmetric hash join algorithm query execution 
stems eddy adaptively choose way reorders tuples interactive environments 
synthetic data sources experiments source properties easily controlled 
data sources shown table 
eddy routing policy implementation uses routing policy designed maximize value partial results output user rh 
details policy needed understand advantages stems experiments 
brie summarize completeness 
tuple routed module bene value partial result output bene depends expected number matches return user preferences matches 
takes expected time process maximize value user time eddy continually routes maximize 
clearly feasible optimization tuples 
discussed rh ratio depends largely optimize granularity 
policy add constraints section specialized follows singleton tuples rst built corresponding stems regardless come sources multiple ams 
simpli es implementation inexpensive cause web sources typically data sizes smaller memory sizes 
stem addition bounce back circumstances table set stems tables index ams bounce back probe tuple satis es predicate prioritized user 
notice case stems index am scan am bounce back redundant 
prioritized probes bounced back subsequently probe ams 
speeds entry matches tuples data ow output prioritized results user 
index join improvement stems start experiment shows effect decoupling physical operations join 
consider index join 
consider rst query joins tables join equi join key column table total tuples distinct values traditional query processor query executed index join module shown 
contrast tuple returned module contains key columns result output partial result 
tuples value subsequently generate partial results joining tuples 
details please see rh 
source schema description key integer integer table tuples scan access method 
key primary key eld distinct values randomly assigned 
integer integer keys asynchronous index access methods 
tuples identical values integer integer primary key asynchronous index access method tuples identical values integer integer primary key asynchronous index access method set tuples set tuples key integer asynchronous index access method primary key key scan access method 
table data sources experiments 
index lookups implemented sleeps identical duration 
select select select select key key select avg key key group key queries experiments modulus sign cache index jn eddy executing query join modules bu probe rs matches eddy rs matches es probe executing query stems system stem scan am index am 
holds pending probe tuples ams processes probes stems caches probe results 
plots number rs results output time schemes 
curve plan index join parabolic expected 
cost probing index join decreases continually time cache size probability cache hits increases 
contrast plan stems takes time linear shape 
rises comparatively faster initial stages processing better online processing metric 
understand behavior plot number probes remote source ap proaches ii 
notice curve identical stems 
lookup caches build rate cases 
difference stems probes caches happen quickly 
rst approach stems tuple coming scan immediately probe index join queues eddy modules nite size probes happen speed index join turn speed index handle probes 
unfortunate tuples may need probe index may nd matches cache 
stems head line blocking happen probes cache index separate queues 
number index probes index join stem time seconds number result tuples index join stem time seconds ii number results output stem index join index join shared cache time seconds number tuples output time ii probes index stems index join approaches query iii performance query stems index joins modi ed index joins share caches joins source indx jn sx eddy indx jn sy executing query traditional join modules probe rs matches eddy iii rs matches es probe matches executing query stems experiment illustrates point simple join operators encapsulate multiple physical oper ations 
example index join comprises operations cache lookup index lookup different performance characteristics 
performance characteristics vary time cache lookups may expensive cache runs memory starts paging disk 
important avoid encapsulating operations join modules 
learning competitive access methods avoiding cache fragmentation second experiment looks sources alternate access methods 
aim experiment demonstrate stems effectively reuse done learning competing access methods 
query experiment obtained adding equality predicate 
alter query result way values identical tuples 
result adding predicate index access methods consider ways executing query index join modules fig ure stems 
index join approach akin approach taken oracle rdb az 
approaches eddy rst tuples learn index methods better 
done routing tuples randomly index joins equal probability 
learning phase eddy chooses index joins executes rest query 
mainly concerned experiment state management overhead learning eddy learns index joins better set probe costs indexes equal constant execution query 
iii shows number rs tuples generated time 
consider curves corresponding stems approach index join approach 
curves phases 
curve plan index joins rises rapidly seconds rises slowly 
point eddy stops routing index join effect seen stems curve stem output tuples time phase shift 
stems curve better index join curve reasons 
previous experiment stems approach bene ts having separate queues cache remote indexes 
note experiment stems curve completes faster index join curve 
happens stems approach uni es caches alternative index joins fragmented alternative approach 
essentially eddy stops sending probes index join tuples cached index join unusable 
contrast stems probes indexes stored single uni ed cache resulting higher proportion cache hits 
isolate effect cache fragmentation arti cially set index joins share caches rerun query 
third curve iii index joins shared cache shows approach completion time stems approach effect head line blocking seen 
spanning tree selection consider cyclic query 
involves tables equality predicates pairs 
traditional way execute query select spanning tree join graph create join modules edges enforce predicate remaining edge selection module 
stems need choose spanning tree front 
see advantage exibility consider situation source experiences second delay query run seconds 
compare approaches eddy creates join modules rt tu join predicates eddy creates stems shows number partial full result tuples generated time approaches 
generation full result tuples affected delay cases 
stems partial result generation severely affected ru join de selected query optimization 
stems eddy able generate ru join results delay 
experiment advantage provided stems directly re ected generation partial result tuples ru tuples 
experiments section mainly demonstrate advantages full result tuple generation 
advantages apply equally partial result tuple generation 
instance index join improvement saw query section arises current experiment number results output number results output ru rt time seconds time seconds ii number full partial result tuples output time query stems ii traditional join operators number results output number results output hybrid index join hash join time seconds time seconds ii hybrid index join hash join number tuples output index join hash join hybrid approach rst seconds ii rst seconds num 
results prioritized group num 
results groups scan index time seconds scan index time seconds ii number prioritized ii results generated eddy ways partial rt result tuples notice curve ii compared 
index hash join hybridization costs experiments studies ability system choose alternative join algo rithms costs 
query joins table index scan access method 
ensure results affected cache effects equijoin key columns means natural ways joining scans symmetric hash join scan index index join 
third way eddy access methods stems choose hybrid join algorithm 
plots number result tuples generated time approaches rst seconds query execution 
see index join initially outperforms hash join 
happens index outputs exact matching tuple probe tuple scan outputs tuples arbitrary order probes nd matches tuples scanned symmetric hash join catches index join quickly hash tables lled 
ii plots graph entire query execution period 
analysis hash join beats index join scan faster access method index see approach stems performs plots 
early stages performs index join 
tuples routed index fanout probes low 
tuples scan tuples nd matches 
completion time hybrid approach slightly hash join eddy keeps sending small fraction tuples probe index processing artifact eddy routing policy continues explore alternative approaches executing query 
index hash join hybridization user preferences nal experiment investigate join algorithm hybridization user preferences different kinds tuples 
demonstrate advantages stems interactive processing environ ments user gives preferences various rows result query running control project 
modify query form adding group clause key sign modulus telegraph 
model scenario user prioritized tuples group key 
plots number results generated time prioritized group hybrid approach previous section 
notice prioritized results generated tuples coming scans prioritized tuples occur infrequently tuples base tables prioritized 
results generated prioritized tuples probing index hand scan contributes output tuples seen ii 
number results generated way low prioritized results generated eddy prioritizes routing prioritized tuples 
differential behavior arises reason 
eddy occasionally send tuples probe index throughput probes low 
send probe index eddy prefers send prioritized tuples resulting matches higher bene user contrast probes stem high throughput eddy send probe tuples stem frequently 
prioritized tuples rarer ones tuples probing stems tuples 
eddy combined hash join index join algorithms user interests 
index get tuples key divisible index stride reordering algorithm prioritize 
scan get tuples juggle reordering algorithm 
effect eddy decides reordering algorithm appropriate user preferences 
juggle index stride algorithm effective hash join curve hybrid curve quadratic seconds tuples scanned 
point scan stops curves linear reduced slope 
note tuples tuples key key divisible prioritized group key eddy automatically uses transitivity query equality predicates infer tuple priorities 
query 
index stride performance poor juggle tuples key divisible prioritized 
hybridization juggle index stride best approach arises naturally stems 
related long interest adapting query optimization decisions due space constraints discuss relevant detailed surveys see ram 
adapting join selection ordering 
early ingres query processor swk query optimizer heuristic approach tuple routed collection index nested loops joins different order 
graefe cole gc study ways optimizing queries parametrized fashion actual execution plan chosen just execution 
allows operator ordering changed query commenced execution 
kabra dewitt running query block query plan 
tukwila uses similar approach rule language specifying reoptimization occur 
query scrambling ufa queries running wan delay accessing source 
attempts develop join algorithms internally adapt changing properties 
ripple join hh adapts changing statistical properties data optimize user feedback online aggregation 
xjoin uf variant symmetric hash join dynamically changes execution strategy previously scanned tuples delay inputs 
making hash join sort operators adaptive memory uctuations zl 
dec oracle rdb system introduced strategy running multiple alternative access methods simultaneously short stopping best access method az 
depart prior important aspects 
adapt query execution ne tuple granularity 
second prior focuses primarily adapting join orders architecture allows greater exibility adaptation including choice access paths data sources join algorithms join spanning trees join orders 
stems developed part telegraph project berkeley build eddy tuple routing operator ah 
rst complete presentation stems occurs ram meant concise description 
stems telegraph continuous query processing focus sharing stems queries cf 
join operators constitute important part traditional query processors 
operators typically complex algorithms maintain state tables involved join 
routing tuple join results chain steps join operator constitute multiple physical operations 
developed way executing queries routing tuples join operators state modules encapsulate data structures holding intermediate query processing state 
mechanism decisions involved query optimization including ordering joins selections choice access methods tables choice reordering mech anism choice join algorithms choice join spanning tree determined routing tuples dynamically eddy 
designed set restrictions eddy routing policy ensure correct query execution 
experiments demonstrate stems mechanism allows powerful adaptation eddy various situations 
plan extend directions 
important restriction consider stems span multiple tables 
reduces memory overheads cient traditional query execution scenarios leads repeated probes avoided storing intermediate results 
currently investigating extensions architecture allow intermediate results retaining adaptivity stems provide 
stems encapsulate data structure communicate directly eddy enable eddy observe control memory resource utilization modules query 
eddy memory allocation decisions globally optimal manner possibly memory avail ability relative frequency probes stem 
extended eddy control spilling tuples disk 
interesting see adaptive control spilling help eddy simulate join algorithms xjoin uf algorithm dynamically adapt disk spilling 
presence multi table stems opens new set optimization opportunities eddy dynamically decide materialize intermediate results memory availability 
important research direction formally study space join processing strategies opened decoupling state management routing logic 
believe lead better adaptive routing policies learning kinds hybrid join strategies may appropriate particular circumstances common justify programming new join operators 
ah avnur hellerstein 
eddies continuously adaptive query processing 
sigmod 
alb albert 
algebraic properties bag data types 
vldb 
az 
query processing optimization oracle rdb 
vldb journal 
bbd babu datar motwani widom 
models issues data stream systems 
pods 
bc bruno chaudhuri 
exploiting statistics query expressions optimization 
sigmod 
carney monitoring streams new class data management applications 
vldb 
cf chandrasekaran franklin 
streaming queries streaming data 
vldb 
appear 
dewitt implementation techniques main memory database systems 
sigmod 
kitsuregawa tanaka 
overview system software parallel relational database machine grace 
vldb 
gc graefe cole 
optimization dynamic query evaluation plans 
sigmod 
gw goldman widom 
practical approach combined querying databases web 
sigmod 
haas optimizing queries diverse data sources 
vldb 
hellerstein interactive data analysis control project 
ieee computer 
hellerstein adaptive query processing technology evolution 
ieee data engg 
bull 
hh haas hellerstein 
ripple joins online aggregation 
sigmod 
hellerstein haas helen wang 
online aggregation 
sigmod 
ioannidis parametric query optimization 
vldb 
ives adaptive query execution system data integration 
sigmod 
ik ibaraki kameda 
optimal nesting computing relational joins 
tods 
kabra ef cient mid query reoptimization sub optimal query execution plans 
sigmod 
kbz krishnamurthy boral zaniolo 
optimization nonrecursive queries 
vldb 
knu knuth 
sorting searching volume art computer programming 
addison wesley 
lex 
www com 
madden adaptive continuous queries streams 
sigmod 
mor morris 
algorithm ordering subgoals nail 
pods 
pirahesh extensible rule query rewrite optimization starburst 
sigmod 
pang memory adaptive external sorting 
vldb 
pang partially preemptive hash joins 
sigmod 
ram raman 
interactive query processing 
phd thesis berkeley 
raghavan garcia molina 
crawling hidden web 
vldb 
rh raman hellerstein 
partial results online query processing 
sigmod 
raman raman hellerstein 
online dynamic reordering 
vldb journal 
rs rashid su 
parallel processing strategy evaluating recursive queries 
vldb 
shah java support data intensive systems 
sigmod record 
lohman 
leo db learning optimizer 
vldb 
swk stonebraker wong kreps 
design implementation ingres 
tods september 
tel telegraph project 
db cs berkeley edu telegraph 
uf urhan franklin 
xjoin reactively scheduled pipelined join operator 
ieee data engineering bulletin 
uf urhan franklin 
dynamic pipeline scheduling improving interactive query performance 
vldb 
ufa urhan franklin 
cost query scrambling initial delays 
sigmod 
vn naughton 
rate query optimization streaming information sources 
sigmod 
wa wilschut apers 
data ow query execution parallel main memory environment 
pdis 
zl zhang larson 
dynamic memory adjustment external mergesort 
vldb 
zr raschid 
query optimization meet performance targets wide area applications 
icdcs 
proof correctness routing constraints rst show eddy output duplicate query results duplicate partial query results 
need de nitions de nition de ne tuple tuple base table components form subset base table components 
sk 
tm exist distinct base tables 
ck ck si tci conversely call de nition arity tuple arity tuple number base table components 
de nition generator tuple query data ow called generator query result tuple 
theorem eddy follows routing policy satis es constraints table arise duplicate versions tuple data ow singleton tuples built stems 
proof proceed contradiction 
consider query sources 
sn query result qr 
tuple minimum arity duplicate versions occur data ow query exe cution 
call versions ta tb 
suppose loss generality ts ts 
singleton tuple 
ta tb built stems bounced back building 
consider situation 
discussed tuple created query execution singleton tuple probing various stems accumulating components base tables 
arrange base table components ta tb order accumulated ta tsa tsa 
tsa tb tsb tsb 
tsb 
ak 
bk permutations 
timestamp constraint tsa tsb highest timestamp base table components ta tb generated tsa probing stems 
tsa 
tsa longest common pre tsa tsa 
tsa tsb tsb 
tsb cases arise case know 
ta tb generated tsa 
tsa probing duplicate versions tsa tsa 
tsa probes multiple times timestamp constraint ensures match tsa 
duplicate versions tsa 
tsa 
contradicts hypothesis duplicate minimum arity 
case generation ta involves tsa 
tsa probing genera tion tb involves tsa 
tsa probing constraint ensures tsa 
tsa probe single stem 
know bl chosen longest common pre duplicate versions sa 
tsa contradicts hypothesis duplicate minimum arity 
theorem eddy follows routing policy satis es constraints table nite number tuples arise query data ow course query execution 
proof observe dealing nite relations theorem nite number tuples arise query data ow singleton tuples built stems 
set nite set tuples coming am nite 
clearly index am say amr tables nite scans generate nite number tuples 
nite number tuples come amr nite number tuples probe amr 
theorem probe tuples singleton tuples 
exist query relation nite number tuples probing scan ams generate nite number tuples 
tuples coming index ams probe amr built stems 
stems bounce back distinct tuples probe nite number probe tuples generated way 
theorem eddy follows routing policy satis es constraints table output tuple query result output query result tuples nite number routing steps 
proof consider query sources 
sn query result qr 
notice rst eddy output tuple qr query result tuple rst route tuple selection modules 
section 
consider set tuples arise data ow query execution order increas ing order latest time routed eddy tuple routed eddy multiple times gets bounced back modules 
theorem sequence duplicates singleton tuples 
singleton tuple occurs sequence remove occurrences rst rest absorbed corresponding stem 
resulting sequence tuples 
gm 
consider query result tuple ps ps 
psn qr 
clearly sources say query executable 
exist generator scan am emits ps generators choose ones highest timestamp ones maximum arity 
generators 
show proceed contradiction 
suppose equal clearly qr 
notice eventually routed eddy nite number tuples data ow theorem query execution terminate tuples removed 
consider ways routed eddy 
case routed sm 
satisfy selection predicate bounced back eddy selected occurrence constructing contradiction 
case routed build stem 
bounced back argument case holds 
absorbed duplicate built stem earlier selected constructing sequence contradiction 
case routed probe stem say 
sub cases arise case psw psw 
concatenation psw arise data ow sw output concatenation probe stem output concatenation previous probe concatenation generator higher arity timestamp contradicting scheme choosing generators 
case psw psw 
psw entered data ow building 
generator higher timestamp contradicting scheme choosing generators 
case psw exists scan am 
psw enter data ow get built time 
psw generator higher timestamp contradicting scheme choosing generators 
case psw exist scan am 
bounced back selected occurrence constructing contradiction 
case routed am say 
subcases arise case prior prober prior prober different probe completion am 
bounced back selected occurrence contradiction 
case prior prober probe completion am 
probed time transformed prior prober 
know psw time returned match higher arity case 
psw enters data ow enter time latest asynchronous match stem sw builds bounced back higher timestamp contradicts scheme choosing generators 
generated output eddy 
chosen arbitrary result tuple result tuples generated eddy 

