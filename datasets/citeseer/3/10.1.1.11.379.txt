ller dept computer science university victoria canada csr uvic ca margaret anne storey dept computer science university victoria canada csr uvic ca early need reengineering legacy systems acute demand increased significantly shift web user interfaces 
demand business sectors adapt information systems web created tremendous need methods tools infrastructures evolve exploit existing applications efficiently cost effectively 
reverse engineering promising technologies combat legacy systems problem 
presents roadmap reverse engineering research decade new millennium building program comprehension theories reverse engineering technology 
keywords software engineering reverse engineering data reverse engineering program understanding program comprehension software analysis software evolution software maintenance software reengineering software migration software tools tool adoption tool evaluation 
notion computers automatically finding useful information exciting promising aspect just application intended practical 
decade ago successes early case tools chikofsky cross introduced taxonomy reverse engineering design recovery 
defined reverse engineering analyzing subject system identify current components dependencies extract create system abstractions design information past years researchers produced number capabilities explore manipulate analyze summarize draft submitted icse 
reverse engineering roadmap jens jahnke dept computer science university victoria canada jens csr uvic ca scott tilley dept computer science university california riverside usa cs ucr edu dennis smith software engineering institute carnegie mellon university usa dbs sei cmu edu kenny wong dept computing science university alberta canada cs ualberta ca hyperlink synthesize visualize software artifacts 
capabilities include documentation forms intermediate representations code data architecture 
reverse engineering tools focus extracting structure legacy system goal transferring information minds software engineers trying reengineer reuse 
corporate settings reverse engineering tools long way go effective integral part standard toolset typical software engineer uses day day 
vitality field demonstrated annual conferences helped spark interest field shape ideas focus working conference reverse engineering wcre international workshop program comprehension iwpc workshop program analysis software tools engineering paste 
presents roadmap reverse engineering research decade new millennium building program comprehension theories reverse engineering technology 
describe selected research agendas code data reverse engineering research strategies tool development evaluation 
investing program understanding technology critical software information technology industry control inherent high costs risks legacy system evolution 
reverse engineering truly exciting field research ready taught computer science computer engineering software engineering curricula 
summarizing major research trends accomplishments unanswered needs divided major parts 
section concentrates code reverse engineering main focus attention field past decade 
contrast data reverse engineering topic section established expected gain prominence new millennium 
section explores spectrum reverse engineering tools 
section deals question software reverse engineering tools widely section concludes 
code reverse engineering current research practice focus forward reverse engineering code level 
forward engineering processes geared producing quality code 
importance code level legacy systems important business rules buried code 
evolution software change applied source code add function fix defects enhance quality 
systems poor documentation code reliable source information system 
result process reverse engineering focused understanding code 
past years reverse engineering research produced number capabilities analyzing code including subsystem decomposition concept synthesis design program change pattern matching program slicing dicing analysis static dynamic dependencies object oriented metrics software exploration visualization 
general analyses successful treating software syntactic level address specific information needs span relatively narrow information gaps 
code contain information needed 
typically knowledge architecture design tradeoffs engineering constraints application domain exists minds software engineers 
time memories fade people leave documents decay complexity increases 
consequently understanding gap arises known useful information required information needed enable software change 
point gap may wide easily spanned syntactic semantic dynamic analyses provided traditional programming tools 
focus low levels abstraction big picture evolution software system 
need focus research significant levels business processes software architecture 
example knowledge software architecture multiple user perspectives needed largescale structural changes capability perform architecture reconstruction increasingly important 
developers need information impacts potential changes 
managers need information assign coordinate personnel 
information create knowledge maintained continuously generate required perspectives continuous basis costly reverse engineering efforts 
analyses rarely performed today current system evolution efforts experience time crisis gap desired information available information critical 
point reverse engineering techniques inserted big bang attempt regain useful understanding insight 
structural functional behavioral code analyses require intensive human input construct scratch 
analyses difficult interpret costly efforts high risk 
continuous program understanding avoid crisis important address information needs effectively software lifecycle 
need better support forward backward traceability software artifacts 
example forward direction design module important able obtain code elements implement 
backward direction source object file need able obtain business rule contributes 
addition important determine appropriate focus analysis different levels abstraction 
understanding purposes traceability especially important 
need able take pattern change updating tax law map law explicitly software structures 
part program comprehension reconstruct mappings application implementation domains 
ease long term understanding mappings explicit recorded reused updated continuously 
vision reverse engineering applied incrementally small loops forward engineering desperate attempt resurrecting poorly understood system 
research issues formulated questions need addressed enable capability continuous program understanding 
long term information needs software system 
patterns change software systems undergo 
mappings need explicitly recorded 
kind software repository represent required information 
requirements tool support produce manipulate mappings 
support coexist traditional tools users processes 
reverse engineering process addition emphasis continuous program understanding important focus efforts better definition reverse engineering process 
reverse engineering typically performed ad hoc manner 
address technical issues effectively process mature repeatable elements need supported automated tools 
example developer require software components contribute specific system responsibility 
subsystem view information require tedious manual manipulation 
mapping responsibility components consulted script generate required view option minor personal customization user 
script instance reverse engineering pattern commonly task solution produce understanding particular situation 
cataloging patterns automating tool support improve maturity reverse engineering process 
insights sei capability maturity model cmm framework ought apply reverse engineering forward engineering 
research ought focus ways process reverse engineering repeatable defined managed optimized 
increased process maturity enable better assessment risks costs economics reengineering activities 
poorly understood processes success reengineering project rests solely ingenuity people involved ingenuity disappears project ends 
evolving large software systems long periods time appreciation product process improvement needed 
research direction summary research reverse engineering important understand software various levels abstraction maintain mappings levels 
catalogs information tool process requirements needed prelude enabling continuous program understanding 
useful reverse engineering processes need identified better supported important step discipline reengineering rational 
data reverse engineering software systems business industry information systems maintain process vast amounts persistent business data 
main focus code reverse engineering improving human understanding information processed data reverse engineering tackles question information stored information different context 
research data reverse engineering underrepresented software reverse engineering arena main reasons 
traditional partition database systems software engineering communities 
second code reverse engineering appears sight challenging interesting data reverse engineering academic researchers 
data reverse engineering concepts techniques gained increasing attention reverse engineering arena 
driven requirements mass software changes resulting needs problem european currency conversion migration information systems web electronic commerce 
researchers recognize quality legacy system recovered data documentation break strategic information technology goals 
example data analysis crucial identifying central business objects needed migrating software systems object oriented platforms 
negative example seen fact difficulties data structure legacy systems cited barriers replacing legacy software modern business solutions sap baan peo 
increased data warehouses data mining techniques strategic decision support systems motivated interest data reverse engineering technology 
incorporating data various legacy systems data warehouses requires consistent mapping legacy data structures common business object model 
similar challenges occur web integration autonomous legacy information systems cooperative net centric infrastructures 
data reverse engineering techniques assess quality software systems 
implemented persistent data structure significant design flaws indicates poorly implemented software system 
analysis data structures help companies decisions purchase maintain commercial theshelf software packages 
data reverse engineering assess quality dbms schema catalog vendor software represent evaluation criteria potential software product 
general reverse engineering persistent data structure software systems dbms specifically referred database reverse engineering 
dbmss provide functionality extract initial information implemented physical data structure database reverse engineering higher potential automation data reverse engineering 
consequently existing reverse engineering tools area consider information systems employ database platform 
approaches specifically targeted relational systems 
data reverse engineering process role tools shows data base reverse engineering process consists major activities referred analysis abstraction respectively 
data analysis analysis activity aims recover date logical data model structurally complete semantically annotated 
cases important information data model missing physical schema catalog extracted dbms 
indicators structural semantic schema constraints various parts legacy information system including data procedural code documentation 
developers users domain experts contribute valuable knowledge 
general data analysis exploratory human intensive activity data reverse engineering process requires significant amount experience skills 
current tools provide minimal support activity visualizing structure extracted schema catalog 
cognitive task data analysis fully automated computer aided reverse engineering tools potential dramatically reduce effort spent phase 
major aid searching collecting combining indicators structural semantic schema constraints guiding reengineer initially incomplete data model complete consistent result 
achieve kind support current data reverse engineering tools need overcome significant problems imperfect knowledge 
data analysis inherently deals uncertain assumptions heuristics legacy data models 
combining detected semantic indicators stereotypical code patterns instances hypothetical naming conventions schema catalog leads uncertain contradicting analysis results 
data reverse engineering tools tolerate imperfect knowledge support interactive process incrementally guide reengineer consistent data model 

legacy information systems different hardware software platforms programming languages 
data models developed various design conventions idiosyncratic optimization patterns 
existing tools provide necessary applicable variety application contexts 
approaches address problem providing mechanisms user programming script ing languages 
principle tools provide high amount flexibility 
coding analysis operations heuristics scripting languages require significant skills experience 
address problem number dedicated formalisms proposed specify customize reverse engineering processes 
due high level abstraction approaches facilitate customization process 
provide amount flexibility scripting languages 
consequently hybrid solution combines high level rule formalisms low level programming scripts fruitful area exploration 
conceptual abstraction conceptual abstraction aims map logical data model derived data analysis equivalent conceptual design 
design usually represented entityrelationship object oriented model provides necessary level abstraction required subsequent reengineering activities cf 

currently tools support data abstraction 
practice limited fail fulfill requirements iteration 
data reverse engineering process involves sequence analysis abstraction activities cycles iteration 
initial analysis phase reengineer produces initial design serves basis discussion domain experts investigations 
design needs altered new knowledge legacy system available 
iteration supported current tools incremental change propagation mechanism jahnke 
bidirectional mapping process 
current data reverse engineering tools follow strictly bottom data abstraction process abstraction produced transformation analyzed logical data model 
approach adequate pre existing partial design data structure available documentation knowledge domain experts developers 
information efficiently reverse engineering legacy information systems require hybrid bottom top abstraction process 
furthermore process required legacy data structure mapped common data model information systems federated integrated data warehouse 
research direction discussion reverse engineering community needs develop tools provide adequate support human reasoning incremental evolutionary reverse engineering process customized different application contexts 
reverse engineering tools techniques aid program understanding grouped categories unaided browsing leveraging corporate knowledge experience computer aided techniques reverse engineering 
unaided browsing essentially software engineer manually flips source code printed form browses online file system navigation aid 
approach inherent limitations amount information software engineer may able keep track head 
leveraging corporate knowledge experience accomplished mentoring conducting informal interviews personnel knowledgeable subject system 
approach valuable people available associated system evolved time 
carry important information heads design decisions major changes time troublesome subsystems 
example corporate memory may able provide guidance look carrying new maintenance activity similar change took place past 
approach useful gaining big picture understanding system learning selected subsystems detail 
leveraging corporate knowledge experience possible 
original designers may left 
software system may acquired 
system may maintenance sourced 
situations computer aided reverse engineering necessary 
reverse engineering environment manage complexities program understanding helping software engineer extract high level information low level artifacts source code 
frees software engineers tedious manual error prone tasks code reading searching pattern matching inspection 
current tool effectiveness reverse engineering tools key aiding program understanding effective today offerings meeting goal 
academic corporate settings reverse engineering tools long way go effective integral part standard toolset typical software engineer calls day day usage 
biggest challenge increased effectiveness reverse engineering tools wider adoption tools effective aren software engineers little knowledge current tools capabilities 
relatively healthy market unit testing tools code debugging utilities integrated development environments market reverse engineering tools remains quite limited 
addition awareness adoption represents critical barrier 
people lack necessary skills needed proper reverse engineering tools 
root adoption problem really fold lack software analysis skills part today software engineers lack integration advanced reverse engineering tools commonplace software utilities mentioned 
art program understanding requires knowledge program analysis techniques essentially tool independent 
programmers lack type foundational knowledge best tools won help 
integration perspective reverse engineering tools attempt create completely integrated environment reverse engineering tool assumes control 
approach precludes easy integration reverse engineering tools toolsets commonly academic research industry 
unix environment linux established edit compile debug tools common 
representative tools group include emacs vi editing gcc compiling gdb debugging 
windows nt environment tools may different names serve similar purposes 
real difference cost choice 
case study illustrates challenges facing students short term project difficulties face solving problem 
learning effectively reverse engineering tool low list priorities tool available 
corporate setting situation different 
relatively short project means little time learn new tools 
tools commercial software development firm may slightly richer academic setting 
displacing existing tool new tool tool arguably better extremely difficult task 
done address challenges reverse engineering tool effectiveness possible avenues explore 
candidate solutions address primary issues identified awareness adoption 
computer science software engineering encourage greater reverse engineering tools 
carefully balance code synthesis commonly taught program analysis rarely taught 
learning analysis techniques art program understanding students better position leverage capabilities reverse engineering tools automate analysis tasks 
increase adoption rate reverse engineering tools vendors need address issues 
tools need better integrated common development environments popular platforms 
need easier 
lengthy training period strong tool adoption 
issue related integration ease just time understanding 
watches software engineer uses tools rarely exercise tool functionality 
rule apply time tool capabilities 
critical capabilities constitute commonly functions identified vendors better able integrate level support vendors environments 
example simple tools grep look patterns source code inefficient 
inefficiencies result regular expressions versus programming language syntax semantics large number false positive matches 
grep widely cost availability ease 
simply augmenting grep context dependent domain aware capabilities better approach full fledged search engine new pattern language proprietary repository tangential capabilities 
evaluating reverse engineering tools includes tools techniques support reverse engineering 
important consideration choosing path technologies measure success tools theories may selected 
reverse engineering tools concentrate extracting structure architecture legacy system goal transferring information minds software engineers trying maintain reuse 
tool purpose increase understanding software engineers managers system reverse engineered 
agreed definition test understanding difficult claim program comprehension improved program comprehension measured 
despite difficulty generally agreed effective tools reduce amount time maintainers need spend understanding software tools improve quality programs maintained 
coarse grained analyses types results attempted 
investigative techniques may appropriate studying benefits reverse engineering tools 
include expert reviews user studies field observations case studies surveys 
general lack evaluation reverse engineering tools examples investigative techniques listed evaluating tools 
section describe techniques give examples techniques applied evaluation reverse engineering tools 
expert reviews expert reviews set informal investigative techniques effective evaluating tools area human computer interaction 
techniques heuristic evaluation involves set expert reviewers critiquing interface short list design criteria 
cognitive walkthroughs expert review technique involve experts simulating users walking interface carry typical tasks 
expert reviews applied stage tool design life cycle normally expensive timeconsuming formal methods 
example reverse engineering tool developer technology delta framework developed brown introspective evaluation tool early stages development 
framework supports technology evaluation ways understanding technology differs technologies considering differences support users needs 
type evaluation useful overlooked sophisticated research tools reverse engineering tools 
user studies user studies formal experiments key factors independent variables identified manipulated measure effects factors dependent variables 
experiments conducted laboratory field 
laboratory setting control independent variables experiment 
factors introduced may applicable realistic situations 
example students act subjects students probably comprehend programs way industrial programmers 
fenton pfleeger refer formal experiments research small 
user studies appropriate fine grained analyses software engineering activities processes 
general relatively formal experiments evaluate reverse engineering tools 
exceptions notably 
field observations formal user studies field difficult execute laboratory setting tend expensive time consuming 
informal user studies programmers observed natural setting insightful 
researcher opportunity observe programmers 
observation may intrusive programmers technique gives researcher opportunity observe maintainers tools realistic set 
results field observations may difficult generalize small number subjects normally involved 
von mayrhauser vans observed programmers industrial setting performing variety maintenance activities 
goal study validate integrated code comprehension model 
derived reverse engineering tool capabilities analysis audio taped think aloud reports programmers information needs maintenance activities 
singer lethbridge describe field experiment study practices software engineers working large telecommunications 
combined various investigative techniques gather information software engineers practices questionnaires issued web longitudinal observations software engineers wide tool usage statistics 
results studies motivate design software exploration tool called software exploration environment 
case studies case studies occur particular tool applied specific system experimenter documents activities involved 
case studies particularly useful experimenter little control factors studied 
expert reviews combined specific case studies powerful evaluation technique 
gall report evaluation reverse engineering tools analyze source code refine sniff rigi 
investigated capabilities tools applying real world embedded software system implements part train control system 
number assessment criteria derived brown technology delta framework 
main focus case study tool capabilities generate graphical reports call trees control flow graphs data flow graphs 
concluded single tool best tools differ considerably respective functionalities 
armstrong evaluated reverse engineering tools 
evaluation abilities tools extract architectural design source code clips language interface processing system browsing linux operating system 
tools examined rigi dali workbench software bookshelf cia sniff 
investigations focused abstraction visualization system components interactions 
surveys surveys normally retrospective investigative technique 
example surveys ask questions nature tool reduce amount time spend doing maintenance changes 
infrequently field psychology programming surveys useful form exploratory research 
cross designed preference survey informally evaluate grasp software visualization tool 
grasp uses control structure diagram csd algorithmic level graphical representation software 
csd compared graphical diagrams 
sim conducted survey web questionnaire find archetypes typical standard examples source code searching maintainers 
results commonly tools searching increasing usage editors grep find integrated development environments 
administering questionnaire web effective information gathering 
summary section reviewed various experimental techniques evaluating comparing software exploration tools important category reverse engineering tools 
investigative techniques just described certain advantages disadvantages 
combining techniques singer lethbridge done produce stronger results 
sharing results research groups important 
example sim storey chaired workshop reverse engineering tools compared live demonstration 
tools applied significant case study team complete series software maintenance documentation tasks collaboration teams emphasized 
adoption reverse engineering technology industry slow 
observed user studies usability major concern 
tool difficult affect adoption rate matter useful may 
produced solid foundation field laws software evolution theories fundamental strategies program comprehension taxonomy reverse engineering 
realized percent evolution effort involves program understanding 
began series papers outlined challenges research directions decade 
decade reverse engineering community developed infrastructures tools major components reverse engineering system parsers repository visualization engine 
researchers developed strategies specific reengineering scenarios result investigated program understanding technology scenarios industrial strength reverse engineering transformation tools :10.1.1.30.1921
theory parsing technology robust parsers legacy languages dialects readily available 
notable exception ibm visualage environment features api access complete syntax tree 
fortunately urgency year problem availability stand parsers top priority 
research needed produce parsing components easily integrated reverse engineering tools 
proliferation object technology expectations high early common objectoriented repository store artifacts accumulated evolution software system 
research community great strides modelling collections software artifacts various levels abstraction graphs developing object oriented schemas models cases artifacts multi line software systems stored relational databases file systems 
past decade produced software exploration tools 
desktop computing power manipulate huge graphs software artifacts effectively 
software exploration tools built web browsers exploit fact users intimately know tools exploring dependencies 
perspectives field reverse engineering provide roadmap decade new millennium 
researchers continue develop technology tools generic reverse engineering tasks particularly data reverse engineering recovery logical conceptual schemas research ought focus ways process reverse engineering repeatable defined managed optimized 
need integrate forward reverse engineering processes large evolving software systems achieve appreciation product process improvement long term evolution initial development phases 
promising direction area continuous program understanding approach 
premise software reverse engineering needs applied continuously lifetime software important understand potentially reconstruct earliest design architectural decisions major tool design implications 
tool integration adoption central issues decade 
critical effectively answer questions knowledge level abstraction need extract subject system informed decisions reengineering need tailor adapt program understanding tasks specific reengineering objectives 
able predict needs reverse engineers develop tools user programmable 
pervasive scripting successful strategy allow user codify customize automate continuous understanding activities time integrate reverse engineering tools personal software development process environment 
infrastructures tool integration evolved dramatically years 
expect control data presentation integration technology continue advance amazing rates 
need evaluate reverse engineering tools technology industrial settings concrete reengineering tasks hand 
perfect reverse engineering technology inherent high costs risks evolving legacy software systems 
developing strategies control costs risks key research direction 
practitioners need reengineering economics book serve guide determine reengineering costs economic analyses making improved reengineering decisions 
probably critical issue decade teach students software evolution 
computer science computer engineering software engineering curricula large teach software construction scratch neglect teach software maintenance evolution 
contrast situation electrical civil engineering study existing systems architectures constitutes major part curriculum 
concepts architecture abstraction consistency completeness efficiency robustness taught software design software analysis perspective 
software architecture courses established computer science programs topics software evolution reverse engineering program understanding software reengineering software migration rare 
aim balance software analysis software construction software engineering curricula 
research supported part nserc national sciences engineering research council canada cas ibm toronto centre advanced studies canadian consortium software engineering research institute robotics intelligent systems network centres excellence british columbia advanced systems institute carnegie mellon university software engineering institute universities alberta paderborn riverside victoria 
aiken 
data reverse engineering legacy dragon 
mcgraw hill 
armstrong 
evaluating architectural extractors 
proceedings th working con ference reverse engineering wcre honolulu hawaii usa pages october 
bass clements kazman 
software architecture practice 
addison wesley 
dittrich 
migration relational schemas data objectoriented database systems 
proceedings th international conference re technologies information systems klagenfurt austria pages 
computer gesellschaft december 
gall 
evaluation reverse engineering tool capabilities 
journal software maintenance research practice 
smith woods 
options analysis reengineering oar issues conceptual approach 
technical report cmu sei tn carnegie mellon software engineering institute 
biggerstaff webster 
program understanding concept assignment problem 
communications acm may 
blackwell 
questionable practices questionnaire psychology programming research 
psychology programming interest group newsletter july 
blaha 
reverse engineering vendor databases 
working conference reverse engineering wcre honolulu hawaii usa pages 
ieee computer society press october 
blaha premerlani 
observed relational database designs 
second working conference reverse engineering wcre toronto ontario canada 
ieee computer society press 
soloway 
whorf visualization tool software maintenance 
proceedings ieee workshop visual languages seattle washington pages september 
brodie stonebraker 
migrating legacy systems gateways interfaces incremental approach 
morgan kauffman 
brooks 
theory comprehension computer programs 
international journal man machine studies 
brown 
framework evaluating software technology 
ieee software pages september 
brown iii 
refactoring software architectures projects crisis 
john wiley sons 
buss gentleman henshaw johnson kontogiannis merlo ller mylopoulos paul prakash stanley tilley wong :10.1.1.30.1921
investigating reverse engineering technologies cas program understanding project 
ibm systems journal august 

chen ramamoorthy 
information abstraction system 
ieee transactions software engineering march 
chidamber kemerer 
metrics suite object oriented design 
ieee transactions software engineering 
chikofsky cross 
reverse engineering design recovery taxonomy 
ieee software january 
clayton rugaber wills 
knowledge required understand program 
proceedings th working conference reverse engineering wcre honolulu hawaii usa pages october 
franklin 
network resource planning sap baan iv people soft guide planning enterprise applications 
mcgraw hill 
consens mendelzon 
visualizing querying software structures 
proceedings th international conference software engineering icse melbourne australia pages 
ieee computer society press 
cross ii hendrix mathias 
scalable visualizations support reverse engineering framework evaluation 
proceedings th working conference reverse engineering wcre honolulu hawaii usa pages october 
cross ii hendrix 
control structure diagram initial evaluation 
empirical software engineering 
vossen 
transforming relational database schemas object oriented schemas odmg 
proceedings th international conference deductive object oriented databases 
fenton pfleeger 
software metrics rigorous practical approach 
pws publishing 
holt kerr kontogiannis ller mylopoulos stanley wong 
software bookshelf 
ibm systems journal 
holt kerr kontogiannis ller mylopoulos stanley wong 
software bookshelf 
ibm systems journal november 
fowler 
refactoring improving design existing code 
addison wesley 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley 
graham 
migrating object technology 
addison wesley 


hick roland 
database design recovery 
lecture notes computer science ff 
linger 
function abstraction understand program behavior 
ieee software january 
humphrey 
managing software process 
addison wesley 
humphrey 
discipline software engineering 
addison wesley 

www com 
jahnke 
management uncertainty inconsistency database reengineering processes 
phd thesis department mathematics computer science universit paderborn germany september 
jahnke sch fer 
generic fuzzy reasoning nets basis reverse engineering relational database applications 
proceedings european software engineering conference esec fse number lncs 
springer september 
jahnke 
integration analysis redesign activities information system reengineering 
proceedings rd european conference software maintenance reengineering amsterdam netherlands pages 
ieee cs march 
kazman carrie re 
playing detective reconstructing software architecture available evidence 
journal automated software engineering april 
kazman woods re 
requirements integrating software architecture reengineering models ii 
proceedings fifth working conference reverse engineering wcre honolulu hawaii usa pages 
ieee computer society press october 

integration und migration von 
phd thesis forschungszentrum informatik universit karlsruhe germany december 
kontogiannis martin wong gregory ller mylopoulos 
code migration transformations experience report 
proceedings cascon toronto ontario canada november 
lehman 
programs life cycles laws software evolution 
proceedings ieee special issue software engineering september 
lethbridge singer 
understanding software maintenance tools empirical research 
ieee workshop empirical studies software maintenance wess bari italy pages october 
letovsky 
cognitive processes program comprehension pages 
ablex publishing 
dumas 
visualizing program dependencies experimental study 
software practice experience april 
martin 
leveraging ibm visualage reverse engineering tasks 
proceedings cascon toronto ontario canada november 
martin cordy abu 
information capacity preserving relational schemas structural transformation 
technical report issn department computing information science queen university kingston ontario canada november 
mendelzon 
reverse engineering visualizing querying 
software concepts tools 
ller 
rigi system programming large 
proceedings th international conference software engineering icse city singapore pages 
ieee computer society press april 
ller tilley 
reverse engineering environment spatial visual software interconnection models 
proceedings fifth acm sigsoft symposium software development environments sigsoft tyson corner virginia usa acm software engineering notes volume pages december 

knowledge discovery 
communications acm november 
murphy notkin lan 
empirical study static call graph extractors 
proceedings th international conference software engineering berlin germany pages 
ieee computer society press march 
nielsen 
usability engineering 
academic press new york 
ning 
knowledge approach automatic program analysis 
phd thesis department computer science university illinois urbana champaign 
paul prakash 
formal query languages source code search 
ieee transactions software engineering se june 
pennington 
stimulus structures mental representations expert comprehension computer programs 
cognitive psychology 
penny 
software landscape visual formalism programming large 
phd thesis department computer science university toronto 
peter selfridge chikofsky 
challenges field reverse engineering 
working conference reverse engineering wcre baltimore maryland usa pages 
premerlani blaha 
approach reverse engineering relational databases 
communications acm may 
price baecker small 
principled taxonomy software visualization 
journal visual languages computing 
rich wills 
recognizing program design graph parsing approach 
ieee software january 
rugaber 
recognizing design decisions programs 
ieee software january 
shneiderman 
designing user interface strategies effective human computer interaction 
addison wesley 
third edition 

reconstruction er schema database applications cognitive approach 
proceedings th international conference era manchester uk pages 
springer 
sim clarke holt 
archetypal source code searches survey software developers maintainers 
proceedings th working conference reverse engineering wcre honolulu hawaii usa pages october 
sim 
storey 
collective demonstration program comprehension tools cascon workshop november 
www csr uvic ca cascon 
singer lethbridge 
studying practices assist tool design software engineering 
proceedings th international workshop program comprehension wpc italy pages june 
sniff 
user guide take software version december 
www com 
standish 
essay software reuse 
ieee transactions software engineering se september 
stevens 
systems reengineering patterns 
acm sigsoft foundations software engineering fse lake vista florida usa pages 
acm press 

storey ller 
manipulating documenting software structure shrimp views 
proceedings international conference software maintenance icsm france pages 
ieee computer society press october 

storey wong fong hooper hopkins ller 
designing experiment evaluate reverse engineering tool 
proceedings rd working conference reverse engineering wcre monterey california usa pages november 

storey wong ller 
program understanding tools affect programmers understand programs 
proceedings th working conference reverse engineering wcre amsterdam netherlands pages october 
syst 
relationships static dynamic models reverse engineering java software 
proceedings sixth working conference reverse engineering wcre atlanta georgia usa pages 
ieee computer society press october 
tilley wong 
storey ller 
programmable reverse engineering 
international journal software engineering knowledge engineering december 
tilley 
coming attractions program understanding ii highlights opportunities 
technical report cmu sei tr carnegie mellon software engineering institute february 
tilley 
canonical activities reverse engineering 
baltzer science publishers netherlands february 
tilley huang 
just understanding time 
technical report department computer university california riverside december 
henshaw buss 
filtering quality 
proceedings cascon toronto ontario canada pages october 

application re engineering building web applications dealing 
prentice hall 
von mayrhauser vans 
code understanding needs reverse engineering tool capabilities 
proceedings case singapore pages july 
waters chikofsky 
reverse engineering special section 
communications acm may 
weiser 
program slicing 
ieee transactions software engineering se july 
wong 
reverse engineering notebook 
phd thesis department computer science university victoria october 
wong tilley ller 
storey 
structural 
ieee software january 
