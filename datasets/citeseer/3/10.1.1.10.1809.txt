information theoretic approach normal forms relational xml data marcelo arenas university toronto cs toronto edu leonid libkin university toronto libkin cs toronto edu normalization way producing database designs understood topic 
problem distinguishing designed databases poorly designed ones arises data models particular xml 
relational world criteria designed usually intuitive clear state obscure moves complex data models 
goal provide set tools testing condition database design speci ed normal form corresponds design 
techniques information theory de ne measure information content elements database respect set constraints 
rst test measure relational context providing informationtheoretic justi cation familiar normal forms bcnf nf pj nf nfr dk nf 
show measure applies xml context gives characterization introduced xml normal form called xnf 
look information theoretic criteria justifying normalization algorithms 
constitutes database design 
question studied extensively wellknown solutions practically database texts 
database design 
question usually addressed formal level 
instance know bcnf example design usually say bcnf eliminates update anomalies 
time sucient simplicity relational model intuition 
papers attempted formal evaluation normal forms relating elimination update anomalies 
criterion existence algorithms produce designs example know database scheme decomposed bcnf constraints may lost way 
previous speci relational model 
new data formats xml critically important classical database theory problems revisited new context 
consensus address problem designed data xml setting 
problematic evaluate xml normal forms update anomalies proposals update languages exist xml update language standardized 
likewise existence decomposition algorithms criterion problematic example formulate needs small set operations language play role xml relational algebra relations 
stating dependency preservation testing normal forms problematic relational world wellunderstood procedures doing xml know implication functional dependencies decidable 
suggests needs di erent approach justi cation normal forms designs 
approach applicable new data models issues query update constraint languages completely understood resolved 
approach intrinsic characteristics data opposed query update languages particular data model 
suggest approach information theoretic concepts speci cally measuring information content data 
goal twofold 
information theoretic measures goodness design test relational world 
applicable contexts expect measures characterize familiar normal forms 
second apply xml context show justify normal form xnf proposed 
measures reason normalization algorithms showing standard decomposition algorithms decrease information content piece data database document 
rest organized follows 
section give notations review basics information theory entropy conditional entropy 
section appetizer main part particularly simple information theoretic way measuring information content database show characterizes bcnf nf 
measure coarse furthermore reason normalization algorithms 
section main information theoretic measure information content database 
measure studied measure takes account database instance schema constraints de nes content respect set constraints 
designed database content datum maximum possible 
measure characterize bcnf nf best way design schemas fds justify normal forms involving jds pj nf nfr types integrity constraints dk nf 
section show main measure section straightforwardly extends xml setting giving de nition designed xml speci cations 
prove constraints fds designed xml speci cations precisely xnf 
section measures sections reason normalization algorithms showing normalization algorithms decrease information content datum step 
section presents ideas 
notations schemas instances database schema nite set relation names set attributes denoted sort associated shall identify sort cardinality mg 
assume domain attribute set positive integers 
instance schema assigns symbol relation nite set tuples adom mean active domain set elements occur size de ned ki 
ji size kik ki instance set positions denoted pos set sort note kik 
shall deal integrity constraints rst order sentences set integrity constraints denotes set constraints implied constraints instance implies 
de ne inst set database instances satisfying inst fi inst adom kg 
constraints normal forms 
brie review common normal forms bcnf nf pj nf nfr dk nf 
information reader referred 
widely bcnf nf de ned terms functional dependencies fd multivalued dependencies respectively 
shall standard notations 
fds 
set fds bcnf nontrivial fd key de ned sort 
set fds nf de ned analogously nontrivial 
key 
recall case fds nontrivial means case nontrivial means sort 
normal forms pj nf projection join normal form nfr deal fds join dependencies jds 
recall jd expression form 
sort 
database instance satis es 
xn 
set fds jds pj nf 

set key dependencies dependencies form sort sort 
words instance satis es keys satisfy 
pj nf extension nf bcnf 

jd xy sort fds de nition pj nf coincides nf 
reduces de nition bcnf 
alternative normal form fds jds introduced original de nitions bcnf nf 
set fds jds jd strong reduced 

sort 
nfr reduced th normal form nontrivial strong reduced join dependency key 
pj nf strictly stronger nfr 
ultimate normal form relational databases introduced 
normal form de ned terms key dependencies domain dependencies 
setting domain dependencies considered says 
set integrity constraints dk nf domain key normal form implied set key dependencies basics information theory main concept information theory entropy measures amount information provided certain event 
assume event di erent outcomes probability information gained knowing occurred 
clearly function suppose measures information continuous decreasing function domain higher probability information gained information gained outcome known advance 
furthermore additive outcomes independent amount information gained knowing successive outcomes sum individuals amounts 

database instances 
function satisfying conditions ln arbitrary positive constant 
customary base logarithms log entropy probability distribution represents average amount information gained knowing particular event occurred 
fs pa probability space 
pa entropy denoted de ned log log observe probabilities space zero 
case adopt convention log lim log 
known log log uniform distribution pa 
shall conditional entropy 
assume probability spaces fs pa fs furthermore know probabilities events pa need independent 
conditional entropy denoted gives average amount information provided known 
de ned conditional probabilities pa log information theory normal forms appetizer see particularly simple way provide information theoretic characterization normal forms 
easy number shortcomings elaborate measure section 
violating normal form bcnf implies having redundancies 
example fr fa bg bcnf key instances contain redundant information value gray cell equal value 
need store value inferred remaining values constraints 
concept entropy measure information content position instance basic idea follows measure information gain lose value position restores original value necessarily active domain 
instance lose value gray cell gain zero information gets restored know rest instance constraints equals 
formally inst adom pos position value database instance constructed replacing value position de ne probability space entropy measure information de ne guarantee value outside active domain 
function gj 
words number note 

example instance position gray cell probability distribution follows 
entropy position zero expect 
generally show 
theorem set fds fds schema bcnf nf resp 
inst pos proof give proof case fds fds proof identical 
assume bcnf 
fix inst pos 
assume th element show conclude uniformly distributed 
contradiction assume 
exist 
assume generated tuples respectively 
note adom position mentions value contradiction 
similarly 
bcnf key contradiction 
assume bcnf 
show exists inst pos 
bcnf exist fag sort key exists database instance sort 
assume contains tuples say greatest value position easy see inst equal 
schema bcnf nf instance position carries non zero amount information 
clean characterization bcnf nf measure accurate number reasons 
example fa bg fa 
bg 
instance satis es position gray cell 
intuitively information content higher says value equal value says happen values attribute distinct 
consider shown figures respectively 
fa bg denote positions gray cells 
di erent values amount redundancy higher enumeration de ning inf 

ag inst 
position entropy zero 
consider positions attribute corresponding value 
disappear know matter restored values 
measure section possibly talk inter dependencies kind 
section measure overcomes problems 
general de nition designed data schema set constraints inst instance kik recall pos set positions sort goal de ne function inf information content position pos respect set constraints 
general de nition designed data want say measure maximum possible value 
bit problematic case nite domain know maximum value entropy discrete distribution elements log overcome de ne function inf apply instances active domain contained consider ratio inf log ratio tells close position having maximum possible information content databases active domain 
nal measure inf take limit sequence goes nity 
informally inf de ned follows 
pos fpg 
suppose values positions lost restores set measure information value gives 
measure de ned entropy suitably chosen distribution 
inf average entropy sets pos fpg 
note involved de nition previous section takes account possible interactions di erent positions instance constraints 
measure formally 
enumeration kik bijection pos 
assume instance associated enumeration say position pos enumeration assigns clear context say position normally associate positions rank enumeration fix position pos 
rst step need describe possible ways removing values set positions di erent shall placing variables set fv positions values removed occur position furthermore assume set positions equally removed 
model set vectors fpg choice particular enumeration ect measures de ne 
value th position probability space de ned uniform distribution 
example database instance shown 
enumeration positions shown 
assume position gray cell shown 
vectors 
vectors de ne measure inf inst de ned conditional entropy distribution distribution 
de ne conditional probabilities characterize occur position values removed tuple need couple technical de nitions rst 
vector table obtained putting position position substitution assigns value variable leaves intact 
extend talk 
example example continued arbitrary substitution 
note identity substitution contains variables 
shows equal 
substitution de ned follows 
shows shows database instance generated applying set constraints sat de ned set substitutions kik ensures tuples collapse result applying 
de ne jsat jsat corresponds conditional probabilities respect distribution de ned 
probability distribution inst pos 
example example continued assume fa bg 
substitution identity sat 

value re ects intuition value gray cell instance shown removed inferred remaining values fd substitutions domain range 
substitution sat jsat 
proved 
hand substitution sat contains tuple 
jsat 
letter lead confusion 
furthermore probability distributions depend omit parameters clear context 
de ne probability space omit parameters overload letter lead confusion 
measure amount information position inf conditional entropy average information provided possible ways removing values instance inf def log note log aj measures amount information position set constraints missing values represented variables inf average amount 
furthermore de nition conditional entropy inf log measure inf depends domain size consider ratio inf maximum entropy log turns sequence converges lemma set rst order constraints schema inst pos lim inf log exists 
proof lemma appendix 
fact lemma shows limit exists set generic constraints constraints depend domain 
nally gives de nition inf 
de nition inst pos measure inf de ned lim inf log inf measures information contained position inf 
designed schema instance position maximum information de nition database speci cation designed inst pos inf 
example database schema fr fa bcg 
shows instance satisfying shows value inf position gray cell 
expected value inf maximal bcnf 
preserve number tuples values distinct possibilities selecting open 
examples show measure inf distinguish cases indistinguishable measure section 
fa bg fa 
bg 
shows instance satisfying shows value inf inf 
expected values smaller bc log 
value conditional entropy 
fa bg 
figures show instances satisfying expect information content gray cell smaller measure section distinguish 
shows values inf inf 
expected values smaller fact inf inf 
basic properties clear de nitions inf depend particular enumeration positions 
basic properties expect measure information content follows rst depend particular representation constraints second schema constraints designed tell 
true 
proposition sets constraints schema equivalent instance satisfying pos inf inf 
designed 
proof follows fact instance sat sat 
follows part proposition proved 
inst pos adom implies designed 
proposition show useful structural criterion inf schema designed position arbitrary inst assigned fresh value 
proposition criterion show inf exhibit sub logarithmic growth lim inf log lim log inf 
proposition schema set constraints equivalent 
designed 
inst pos adom 
inst pos lim log inf 
lemma proof proposition proofs 
lemma fix element set probability space uniform distribution pa assume probability space called joint distribution conditional probability elements 
log particular lim log exists lim log 
proof assume 
fi 
observe jm log log log log afa log log log afa log log log afa log log log log log log log log log assume 
case log equation equal previous sequence formulas show log proof proposition prove chain implications 
implication straightforward 
show 
contradiction assume exists inst pos adom 
adom fag 
claim see appendix adom 
adom tuple containing variables 
applying lemma kik conclude inf log log 
kik inf lim inf log exists lemma conclude inf designed contradiction 
show 
inst pos 
kik inst 
prove adom jsat jvar var set variables induction jvar induction jvar assume jvar 
conclude jsat 
assume true tuple containing variables jvar 
suppose 
assumption adom 
adom adom jsat jsat tuple constructed replacing conclude tuple constructed replacing arbitrary adom jsat 
jsat induction hypothesis jsat jvar jvar jsat jvar proving 
show lim log inf 
adom log inf lim log inf 
prove theorem show lim log inf adom 
assume adom 
jsat jvar get jvar jvar jvar claim see appendix adom 
adom order prove need establish lower bound inf 
follows term log aj replace induction relies simple idea adom ip replace values positions provided position gets fresh value 
log aj smaller terms respectively 
precisely inf log adom jvar log log adom log adom log log log log log inf log log lim log log conclude holds 
completes proof proposition natural question point problem checking relational schema decidable 
surprising arbitrary rst order constraints problem undecidable proposition problem verifying relational schema containing rst order constraints designed undecidable 
proof known problem verifying rst order sentence form arbitrary rst order formula nitely satis able undecidable 
denote decision problem reduce complement problem 
formula form shown 
assume de ned relational schema fr xj relational schema fu ary predicates 
furthermore de ne set constraints follows suces show designed 
assume instance fr satisfying 
de ne inst follows ag tuple 
adom arbitrary position 
designed proposition 
assume nonempty instance inst 
position value adom empty 
conclude designed proposition 
integrity constraints database schema design commonly universal form quanti er free formula 
fds jds universal constraints elaborated dependencies equality generating dependencies full tuple generating dependencies 
universal constraints problem testing relational schema designed decidable 
fact proposition problem deciding schema containing universal constraints designed nexptime complete 
furthermore xed relation attributes problem complete 
prove proposition rst prove lemma 
lemma terminology 
rst order constraint sentence form 
quanti er free formula string quanti ers 
qm consists consecutive blocks quanti ers block adjacent blocks quanti ers rst block contains existential quanti ers 
sentences de ned analogously requiring rst block contains universal quanti ers 
lemma relational schema set sentences 
exists relational schema sentence designed 
proof assume fr mn arity 
de ne relational schema fr fu de ne rst de ne sentence conjunction formulas 

xm xm 
relation empty 

contains exactly element 

ym element contained contained active domain relation 

xm xm 

ym empty empty 

um um 

ym 

empty exists tuple tuple contain exactly values element th column contains value relation furthermore tuple denote set rst order constraints generated replacing occurrence de ne sentence follows notice sentence sentence 
nish proof show designed 
assume designed 
proposition exists inst pos adom 
assume position element th column 
de ne instance follows 
fag 
furthermore empty empty constructed replacing arbitrary element th column 
empty empty fag adom empty empty empty di ers exactly value 
conclude 
assume exists database instance 
note empty empty empty contradiction 
de ne instance follows 

element position element changed obtain 
empty 
adom proposition conclude designed 
sentences correspond sch bernays fragment rst order logic 
known problem verifying sch bernays formula nite model nexptime complete complete relation attributes xed constant 
lemma obtain corollary proof proposition 
corollary problem deciding schema containing sentences belongs nexptime 
proof proposition consider case unbounded arity relations case xed arity relations similar 
membership part proposition particular case corollary 
hardness part proposition follows observation 
reduction proposition formula form quanti er free set constraints de ned universal 
reduction proposition shows problem deciding sentence nitely satis able reducible problem deciding schema containing universal constraints designed 
speci kinds constraints fds lower complexity bounds follow results section 
justi cation relational normal forms apply criterion designed various relational normal forms 
show lead designed speci cations precisely characterize designed speci cations obtained class constraints 
start nding constraints give rise designed schemas 
recall typed equality generating dependency constraint form 
represents universal closure formula 
xm assignment variables columns variable occurs column equality atom involves pair variables assigned column 
extended key typed equality generating dependency form 

note key extended key 
proposition schema set extended keys designed 
proving proposition introduce de nition proofs 
inst pos 
substitution say tuple generated tuple means tuple obtained replacing value element position 
say generated tuple generated means proof proposition prove proposition part proposition 
inst pos adom 
show 
assume contrary 
exists extended key 
xm 
xm 
exists substitution 
xm de ne substitution 
xm follows 
value th position 
straightforward verify generated respectively 
contradiction proves proposition 
corollary relational speci cation dk nf designed 
rest section denote join dependencies rst order sentences 
precisely join dependency relation rst order sentence form 
represents universal closure formula 
xm variable occurs precisely assignment variables columns variable occurs column 
example join dependency ab bc relation denoted characterize designed schemas fds jds 
theorem set fds jds relational schema 
designed nontrivial join dependency 
exists mg 


proof theorem shall chase fds jds brie review sake completeness 
tableau set rows column attribute universe rows composed distinguished non distinguished variables 
variable may appear column distinguished variable may appear column 
non distinguished variables xm chase respect set fds jds successive application rules fd rule functional dependency form single attribute 
result applying fd new tableau de ned follows 
variables distinguished occurrences renamed variable 
non distinguished occurrences variable larger subscript renamed variable smaller subscript 
jd rule join dependency form tuple result applying jd fug 
chasing sequence sequence tableaux result applying dependency known sequence terminate resulting tableau depend particular sequence denote tableau chase 
application fd rule jd rule naturally de nes substitution variables variables substitution identity 
substitution de ned chase obtained composition substitutions step chase 
substitution enables map original variable tuple variable tuple chase 
set fds jds shown chase checking 
idea construct tableau compute chase verify condition satis ed 
fd rows contains distinguished variables contains distinguished variables columns non distinguished variables 
chase distinguished variable column 
jd rows 
th row contains distinguished variables columns non distinguished variables remaining columns 
furthermore non distinguished variable appears exactly 
chase contains row distinguished variables 
chase results shown generalized natural manner case expressive constraints typed equality generating dependencies see 
move proof theorem 
need lemmas rst 
lemma set fds jds relational schema assume contains jd 


exists inst pos inf proof tableau containing tuples xm distinguished variables 
function domain 
xm range contained de ne chase 
assume composition substitutions chase 


conclude 
sort position adom 
contains jd 
implies contain changing value generates instance satisfy 
ft tuple containing variables 
applying lemma conclude log constant suciently large lemma inf lim inf log set fds jds relational schema jd form 
de ne equivalence relation tuples variables follows 

equivalence class var set variables contained tuples lemma set fds jds relational schema assume contains jd form 
var 
exists inst pos inf proof 
lemma exists inst pos inf may assume exists 
hypothesis exists xj variable th column var 
variable th column set variables column tuples tableau xm distinguished variables 
chase tuples equivalence class identi ed tuple 
denote th component tuple similarly tuples 
function domain 
xm range contained chase 
assume composition substitutions chase 
tuple 
note tuple distinguished variables 
additionally satis es 
case 
position value position 
show tuple containing variables 
denote tuple corresponds note di ers value th column 
assume satis es 
satis es particular 

recall jd variable occurs unique give substitution variable tuples xm tuples respectively 

xm substitution de ned follows 

xm 
claim clearly need consider th column 
column contains value variable occurs case assumed satisfy jd 
contain 
contradiction 
conclude 
lemma inf log constant suciently large lemma inf lim inf log 
proves lemma 
theorem corollary proposition lemma 
note theorem justi es various normal forms proposed jds fds 
corollary set fds jds relational schema pj nf nfr designed 
normal forms characterizes precisely notion de ned proposition exists schema set jds fds violates dk nf pj nf nfr 
proof fr fab ac ab ac bc speci cation dk nf pj nf set keys implied fab abc ac abc abc set imply ab ac bc 
furthermore speci cation nfr ab ac bc strong reduced join dependency bc key 
join dependency ab ac bc corresponds rst order sentence theorem conclude designed implies sentence 
restricting theorem case speci cations containing fds fds obtain equivalence designed databases nf respectively bcnf 
theorem set integrity constraints relational schema 
contains fds designed nf 

contains fds designed bcnf 
normalizing xml data section give overview xml normal form called xnf show notion designed straightforwardly extends relations xml 
furthermore constraints speci ed functional dependencies notion precisely characterizes xnf 
overview xml constraints normalization dtds xml trees shall somewhat simpli ed model xml trees order keep notation simple 
assume countably nite set labels countably nite set attributes shall notation attributes distinguish labels countably nite set values attributes 
furthermore consider pcdata elements xml trees represented attributes 
dtd document type de nition tuple nite subset set rules regular expression frg assigns nite subset possibly empty set attributes root 
example dtd part dblp stores conference data 
title cdata required author cdata required title cdata required pages cdata required year cdata required dtd represented db fdb conf issue fdb conf conf issue issue inproceedings inproceedings conf inproceedings author title pages db issue 
xml tree nite rooted directed tree set nodes set edges labeling function partial attribute value functions furthermore assume node children ordered de ned nite set attributes say conforms dtd written root labeled word 
consists labels children belongs language denoted function de ned provides value attribute 
functional dependencies xml functional dependency language xml need introduce terminology 
recall countably nite sets labels attributes respectively 
element path word attribute path word form element path consistent dtd tree contains node reachable particular paths rst letter addition nodes reachable attribute attribute path consistent set paths element attribute consistent denoted paths 
set nite non recursive nite recursive 
functional dependency dtd expression form fq paths 
de ne notion satisfaction fds relational representation xml trees 
tree tuple mapping paths element path letter label pre node lies path root de ned value intuitively tree tuple assigns nodes attribute values nulls 
paths consistent manner 
tree tuple maximal extended changing nulls values set maximal tree tuples denoted tuples 
say fd fq true tuples holds 
example dtd example 
set fds dtd db conf title db conf db conf issue db conf issue inproceedings year rst functional dependency speci es distinct conferences distinct titles 
second speci es inproceedings children issue value year 
xnf xml normal form 
suppose dtd set fds set fds implied denoted set fd xml tree conforming satisfying fd called trivial belongs implied dtd 
example root trivial fds 
say xml normal form xnf nontrivial fd fd 
intuitively violation xnf means redundancy document may nodes reachable path value attribute provided agree 
example dblp example seen earlier may contain redundant information year stored multiple times issue conference 
xml speci cation xnf db conf issue db conf issue inproceedings suggests making year attribute issue revised speci cation easily shown xnf 
designed xml data need introduce new notion designed speci cally xml de nition formulated section relational data apply 
de ne notion positions tree reuse relational de nition 
relational databases positions correspond shape relations position contains value 
likewise xml positions correspond shape complex documents modeled trees values associated 
consequently formally de ne set positions pos tree assume enumeration positions bijection pos ng shall associate positions numbers enumeration 
de ne adom set values attributes xml tree constructed replacing value position relational case take domain values attributes set fds dtd 
de ne inst set xml trees conform satisfy inst restriction trees adom 
inst pos 
de nitions de ne probability spaces exactly de ned relational instance set tuples form variable value corresponding position sat set possible ways assign values variables result tree satisfying rest de nition repeats relational case verbatim substituting de nitions de ne inf entropy inf def relational case show limit lim inf log exists denote inf 
relational case introduce de nition xml speci cation designed inst pos inf 
note information theoretic de nition designed schema section relational data proved extremely robust extended straightforwardly di erent data model needed new de nition pos place pos pos simply enumeration places document attribute values occur 
relational case possible show designed xml xnf coincide 
furthermore possible establish useful structural criterion inf xml speci cation designed position arbitrary inst assigned fresh value 
theorem dtd set fds equivalent 
designed 
xnf 
inst pos adom 
proof theorem follows closely proof proposition replacing relational concepts xml counterparts 
proof theorem prove chain implications 
assume xnf 
show exists inst pos inf 
xnf exists nontrivial fd inst containing tree tuples 
may assume 
contradict 
position 
vector containing variables 
values fag 
fag 
straightforward application lemma implies inf lim inf log concludes proof 
xml speci cation xnf inst pos adom 
prove 
assume contrary 
exists fd exists tuples 
assume tuples generated tuples tuples 
adom 
element path constructed modifying values attributes 
contradiction 
assume attribute path form case nontrivial fd xnf 
conclude 
element path previous case conclude 
contradiction 
inst pos 
prove inf 
show suces prove lim inf log inst 
var set variables mentioned adom jsat jvar hypothesis replace values positions provided position gets fresh value 
jsat jvar adom jvar jvar jvar functional dependencies generic constraints 
adom 
adom order prove need establish lower bound inf 
follows term log aj replace log aj smaller terms respectively 
precisely inf log adom jvar log log adom log adom log log log inf pj log log log lim log log follows 
concludes proof 
theory xml constraints normal forms nearly advanced relational counterparts demonstrated de nition designed schemas works existing normal form fds test design criteria xml proposed 
normalization algorithms show information theoretic measure section reasoning normalization algorithms instance level 
section assume set fds relational xml cases 
results shown state step decomposition algorithm amount information position decrease 
relational databases result applying step normalization algorithm order compare amount information instances need show associate positions consider functional dependencies deal bcnf standard bcnf decomposition algorithms steps kind pick relation set attributes disjoint union instance gets decomposed xy xy xz xz sets fds xy xz stands fc cd wg 
decomposition gives rise partial maps xy pos pos xy xz pos pos xz 
position xy xy de ned equals position xy xy mapping xz de ned analogously 
note xy xz map di erent positions position xy xz show amount information position decrease normalization process 
theorem partition attributes inst pos 
xy xz de ned inf inf prove theorem rst need prove lemmas 
lemma set fds relational schema inst pos 
lim log log aj 
proof appendix 
relation schema sort nonempty pairwise disjoint sets attributes 
set fds inst 
assume de ne relation schema sort xy xy 
note inst 
lemma show 
lemma xy th element th element inf inf 
proof assume kik fa am ft ig contains tuples choose tuple loss generality assume am th element rst element th element lm th element note lm 
de ne generated replacing variable 
furthermore de ne 
easy see lim log log aj lim log log aj 
lemma lim log log lim log log inf lim log log lim log log lim log log lim log log observe ki lm 
loss generality assume lm de ne 
case easy see lim log log aj lim log log aj particularly property holds 
conclude inf lim log log lim log log lim log log inf proof theorem notice adding new relations constraints schema ect information content old positions 
fr rm relational schema 
set fds set fds fr inst inst 
furthermore position corresponding position inf inf 
theorem direct consequence fact lemma 
decomposition algorithm ective basic steps inequality theorem strict amount information increases 
notion leads characterization bcnf 
proposition bcnf decomposition algorithm ective 
proof bcnf inst pos inf 
decomposition algorithm ective inst 
assume bcnf 
show exists decomposition algorithm ective 
bcnf nd nonempty pairwise disjoint sets attributes sort key xy xy bcnf 
database instance containing tuples de ned follows 
sort 

easy see inst 
furthermore pos th element inf inf xy xy xy xy xy bcnf 
inf inf xy xy xy 
decomposition algorithm decomposes xy xz ective 
xml data treat xml case 
shall prove result similar theorem 
state result rst need review normalization algorithm xml data proposed explain step algorithm induces mapping positions xml trees 
section assume dtds non recursive fds contain element path left hand side 
furthermore presenting algorithm proving result assumption fd causes violation xnf time null path null shown eliminate assumption 
algorithm proposed need introduce terminology 
dtd set fds nontrivial fd called anomalous violates xnf algorithm eliminates anomalous functional dependencies basic steps moving attribute creating new element type 
moving attributes 
dtd set fds assume contains anomalous fd element path 
instance dblp database shown example contains anomalous fd form db conf issue db conf issue inproceedings year eliminate anomalous fd move attribute set attributes element set attributes element shown 
instance eliminate anomalous functional dependency move attribute year moving attribute 
ln ln qn creating new element type transformations xml normalization algorithm 
set attributes inproceedings set attributes issue 
formally new dtd attribute mg lg fa transforming new dtd new set functional dependencies generated 
formally set fds consists fds paths 
observe new set fds include functional dependency creating new element types 
dtd set fds assume contains anomalous fd fq element path 
example consider dtd describes database containing courses di erent universities cdata required title cdata required sno cdata required name cdata required grade cdata required course store number title list students course 
student course store number sno name grade course 
database functional dependencies fdb univ db univ course db univ course fdb univ db univ course student db univ course student name rst fd says distinct courses university distinct numbers second says students university sno value name 
observe anomalous fd form described fdb univ db univ course student db univ course student eliminate anomalous fd construct new dtd creating new element type child element making children attribute attributes respectively 
furthermore remove set attributes element shown 
formally fa element types new dtd denoted fa de ned follows 
assume fa fa 

lg lg fag 
instance eliminate anomalous functional dependency create new element type info child courses remove name attribute student attribute info create element type number child info sno attribute 
note remove sno attribute student 
transforming new new set functional dependencies generated 
formally set fds de ned union sets constraints de ned paths fd fq lg include fd obtained changing fq fq 
algorithm 
shown normalization algorithm proposed 
algorithm applies moving attributes creating new element types transformations schema xnf 
note creating new element types transformation applied arbitrary anomalous fd minimal 
understand notion minimality xml fds rst introduce notion relational databases 
relation schema containing set attributes set fds bcnf exist pairwise disjoint sets attributes case say anomalous fd 
eliminate anomaly decomposition algorithm splits relation relations 
desirable property new schema bcnf 
say minimal anomalous fd bcnf contain anomalous xnf return go step 
anomalous fd element path choose fresh attribute go step choose minimal anomalous fd fq create fresh element types go step xml normalization algorithm 
fd 
condition de ned follows minimal pairwise disjoint sets xml context de nition minimality similar sense expect new element types form structure containing anomalous elements 
de nition minimality complex account paths fds 
say fq minimal anomalous fd subset fq contains element path 
prove step normalization algorithm proposed amount information position decrease 
xml speci cation inst 
assume xnf 
xml speci cation obtained executing step normalization algorithm 
step algorithm induces natural transformation xml documents 
properties algorithm normalization step transforms inst inst nd map pos pos associates position new tree positions old tree shown 
assume anomalous fd 
case xml tree constructed follows 
tuples de ne tree tuple rule paths fq lg 
xml tree tree tuples ft tuples furthermore positions associated positions follows fp assume generated considering minimal anomalous fd fq 
case xml tree constructed follows 
tuples de ne tree tuple rule fresh node identi er fresh node identi er paths fq lg 
xml tree tree tuples ft tuples furthermore positions associated positions follows 
note case may contain position 
position fp similarly relational case show 
theorem tree conforms dtd satis es set fds inst result applying step normalization algorithm 
pos 
inf max inf proof xml speci cation inst 
assume xnf 
xml speci cation obtained executing step normalization algorithm 
prove pos inf max inf done exactly way proof theorem 
proof lemma show results holds xml trees 
show assume anomalous fd 
element pos 
form inf theorem trivially holds 
fp shown inf inf proof lemma 
assume fq minimal anomalous fd 
pos 
position value reachable root path inf fq minimal 
case theorem trivially holds 
fp shown inf inf proof lemma 
completes proof theorem 
just relational case de ne ective steps algorithm inequality strict position show xnf decomposition algorithm ective 
goal nd criteria data design intrinsic properties data model tools built top query update languages 
motivated justi cation normal forms xml usual criteria update anomalies existence lossless decompositions applicable standard universally acceptable query update languages 
proposed techniques information theory measure information content elements database respect set constraints 
tested approach relational case showed works characterizes familiar normal forms bcnf nf precisely corresponding designs justi es complicated ones involving join dependencies 
showed approach straightforwardly extends xml setting case constraints functional dependencies equates normal form xnf designs 
general approach robust show due space limitations easily adapted nested relational model justi es normal form nnf 
interesting characterize nf measure developed 
far little bit known nf 
example case bcnf possible prove synthesis approach generating nf databases decrease amount information position 
furthermore nf necessarily eliminate redundancies nd nf databases amount information positions maximal 
consider complex xml constraints characterize designs give rise 
connect approach information capacities schemas compared existence queries standard language translate 
classes designed schemas constraints keys information capacity equivalent means isomorphic see connection extends classes schemas studied 
acknowledgment pablo michael benedikt helpful comments 
anonymous referees helpful comments 
abiteboul hull vianu 
foundations databases 
addison wesley 
albert ioannidis ramakrishnan 
equivalence keyed relational schemas conjunctive queries 
jcss 
arenas libkin 
normal form xml documents 
pods pages 
arenas libkin 
normal form xml documents 
appear tods 
beeri 
membership problem functional multivalued dependencies relational databases 
tods 
beeri bernstein goodman 
database normalization theory 
vldb pages 
biskup 
achievements relational database schema design theory revisited 
semantics databases lncs pages 
springer verlag 

theory probabilistic databases 
vldb pages 
cover thomas 
elements information theory 
wiley interscience 
robertson 
information dependencies 
pods pages 
dblp 
www informatik uni trier de ley db 
embley mok 
developing xml documents guaranteed properties 
er pages 
fagin 
multivalued dependencies new normal form relational databases 
acm tods 
fagin 
normal forms relational database operators 
sigmod pages 
fagin 
normal form relational databases domains keys 
acm tods 
hull 
relative information capacity simple relational database schemata 
siam comput 
kanellakis 
elements relational database theory handbook tcs vol 
pages 

lee 
information theoretic analysis relational databases part data dependencies information metric 
ieee trans 
software engineering 
levene 
snow ake schema data warehouse design 
information systems appear 
levene vincent 
justi cation inclusion dependency normal form 
ieee tkde 
maier mendelzon sagiv 
testing implications data dependencies 
acm tods 
mok ng embley 
normal form precisely characterizing redundancy nested relations 
acm tods 
ozsoyoglu 
yuan 
new normal form nested relations 
acm tods 
papadimitriou 
computational complexity addison wesley 
shannon 
mathematical theory communication 
bell system technical journal part part ii 
suciu 
database theory xml 
sigmod record 
tatarinov ives halevy weld 
updating xml 
sigmod pages 
vianu 
web odyssey codd xml 
pods pages 
vincent 
corrected nf de nition relational database design 
tcs 
vincent 
semantic foundations nf relational database design 
acta informatica 
proofs proof lemma start simple useful observation 
proof follows immediately genericity 
claim set generic integrity constraints relational schema inst pos 
assume adom 
jsat jsat need 
claim set integrity constraints relational schema inst pos 
exists polynomial jsat proof variables fix maximum value adom fag 
de ne 
genericity jsat implies jsat assume substitution sat 
consider set triples fv partition fv sat write block 
observe sat exists exactly triple substitutions 
genericity immediately see 
furthermore collapses rows 
conclude sat sat 
number triples depends belong sat belongs sat 
suce show exists polynomial jf sat 
case belongs sat trivial mp number partition blocks 
number number ways chose mp distinct ordered elements mp mp depend concludes proof claim 
proof lemma inst pos 
prove lemma suces show limit exists lim log log claims exists polynomials adom 
jsat adom 
jsat adom 
adom 
equal lim log adom log log rst show lim log adom log note degree degree adom 
degree degree clearly lim qa log qa 
degree degree lim qa log qa exists equals positive constant lim log qa log qa 
holds equals lim log 
log de nition degree degree 
simple calculation shows degree degree equals positive constant depends coecients degree degree equals 
limit exists completes proof 
proof lemma assume lim log log show limit 
note exists adom jsat 
true claim adom jsat log aj log conclude lim log log lim log log contradicts 
prove lemma need introduce equivalence relation elements prove basic properties 
assume kik 
adom 
say linked written substitution case 
observe constants easy see equivalence relation say determined pair substitutions case 
notice constant determined 
furthermore observe determined determined 
extend de nition equivalence classes determined determined 
de ne set undetermined equivalence classes claim adom adom exists substitution adom 
proof adom adom 
assume exists substitution 
easy see determined determined linked linked 
trivial claim 
claim adom 
jsat proof prove claim consider cases 
assume contain variable 
prove jsat 
suces show 
contradiction assume 
claim jsat adom contradicts existence second assume contains variable 
substitution substitution exists assumption 
substitution coincide determined equivalence classes undetermined class assigns value adom fag element class pair distinct undetermined classes 
notice function exists 

jsat greater equal number substitutions domain range contained satisfying conditions 
jsat 
proves claim 
claim prove lim log log aj 
adom 
claim adom jsat furthermore claim adom jsat adom claim adom conclude log adom log log arbitrary element adom 
log log log log straightforward prove lim log log 
lim log log lim log log log aj log completes proof lemma 

