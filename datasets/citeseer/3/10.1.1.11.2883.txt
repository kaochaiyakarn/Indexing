optimising embedded dsls template haskell sean manuel chakravarty gabriele keller university new south wales school computer science engineering sydney australia keller cse unsw edu au 
embedded domain specific languages provide specialised language particular application area harnessing infrastructure existing general purpose programming language 
reduction implementation costs results approach comes price compiles ine cient code host language compiler optimises level host language constructs 
presents approach solving problem compile time meta programming retains simplicity embedded approach 
pantheon implementation existing image synthesis demonstrate benefits drawbacks approach 
furthermore suggest potential improvements template haskell meta programming framework greatly improve applicability kind task 
domain specific languages dsls reduce cost producing software providing programming constructs tailored particular domain 
reduces amount repetitive code written general purpose language means people little programming experience conversant domain languages 
terms implementation ort constructing new languages expensive 
embedded domain specific languages decrease implementation burden implemented existing feature rich general purpose language 
allows reuse substantial portion host language programming environment lexical analyser parser type checker optimisation phases code generator compiler tools surrounding debuggers profilers 
host languages better choices 
argue language support compile time meta programming ideal tool implementation due ability express compiler optimisations increasing number domain specific optimisations written 
standard approach construction involves implementing libraries combinators language support higher order functions unfortunately constructed manner produce ine cient code 
reason domain data types usually represented algebraic data types interpreted recursive traversal functions 
interpretive overhead generated code host language compiler knowledge code improvement techniques may applied domain data types expressions 
absent ability declare compiler optimisations operate syntactic structure expressions capability ered language compile time meta programming features 
alternative embed compiler dsl dsl host language 
precisely approach taken implementors pan language synthesis dimensional images animations 
approach primitives dsl defined functions syntax tree ast representation 
asts generated programs written host language optimised fed code generator produces cient code necessarily di erent target language 
ort involved equivalent writing compiler back considerable cost writing components compiler front lexical analyser parser type checker saved 
main disadvantage embedding compiler access extensive general optimisations host language compiler lost 
furthermore disparity host language target language generated programs may able features host language 
ostensibly writes programs host language may possible language constructs require base type language 
instance expressions valid typically require expression boolean type 
unfortunately representation expressions asts requires synthetic types precludes language constructs 
disadvantages automatically avoided traditional approach implementation 
bearing mind assert problem inefficient code adequately solved extending approach techniques provided compile time meta programming 
approach transforming user written code syntactic structure di ers quite markedly popular meta programming approach staged interpreters 
meta programming annotations traverse representation interpreted program essence program executed run time amounts form domain specific partial evaluation 
approach inherits optimisations host language applied generated code introduces expense having implement front additional benefit easing distribution easier distribute build module written established language sources entire compiler compiler lexer parser 
meta programming language require ability inspect structure code 
demonstrate feasibility approach template haskell compile time meta programming extension glasgow haskell compiler provide alternative implementation pan dubbed pantheon 
pan implemented embedded compiler haskell target language alluded earlier disparity languages means generated programs features host language case laziness higher order functions 
summarise main contributions 
introduce approach implementing ering benefits embedded compiler reduced implementation ort sharing host language programming environment extension suite optimisations 
retention host language features 
inheritance host language constructs 

investigations feasibility approach pantheon example 

evaluation template haskell example significant size suggested extensions template haskell wider range implementation tasks easier 
rest organised follows 
provide meta programming template haskell 
give brief overview pantheon 
comprises brief pan language description transformations apply 
subdivide descriptions parts independent template haskell possible 
principle reason implement pantheon language similar functionality 
aspects implementation dependent specifics template haskell implementation suspect shall interest users language 
benchmarks provide evidence cacy optimisations followed analysis recurrent problems template haskell solutions devised 
compile time meta programming template haskell meta programming range interesting tasks primarily concerned transformation expressions 
optimisations pantheon get treated adequately rest show useful algebraic transformation di erent domain implemented template haskell 
basic result linear algebra matrix multiplied inverse equal identity matrix just sort property expect compilers optimise away 
consider expression inverse matrices 
precise details matrices implemented immaterial 
order expression may simplified converted code data structure process known reification 
verified data structure matches pattern inverse replace data structure represents identity need convert data structure back code process known reflection 
known particularly template haskell splicing 
meta programming languages reification inverse typically take form syntax tree 
transformation expression simple 
create new data structure represents identity splice 
show achieved template haskell contrived lambda expression body equal inverse exp mat inverse exp arith introduces quasi quote notation template haskell denoted brackets 
brackets reify code 
presents function removes redundancy reified expression 
unfortunately familiarity data structure representing expressions code di cult understand 
case real matches infix expressions form returns identity second third match expressions form fa respectively recursively call sub expressions 
note cases necessary transform exp mat 
just ghc num just inverse vare lame pats exp lame pats exp exp exp exp exp exp exp fig 

example arithmetic transformation 
template haskell splicing operator 
runs meta programs converts resulting data structure back code 
case expression exp mat evaluates code compiletime 
key aspect approach language restricted compile time meta computation guarantee run time overhead code generated 
pantheon pantheon direct implementation image primitives elliott 
main classes optimisation unboxing arithmetic expressions aggressive inlining algebraic transformations 
subsections describe particularly applicable domain realisation general meta programming terms recourse template haskell specifics 
language similar functionality place know language 
template haskell relatively new extension haskell 
common wisdom languages change rapidly substantially early lives 
partly motivated novel situations discovered additional features simplify things 
follow general description optimisation solution devised template haskell highlighting problems encountered 
put context describe pan detail 
pan example pan domain specific language founded concept modelling image function continuous cartesian coordinates colour values 
animation extends image concept simply function continuous time image 
presents simple pan ect running example rest self contained respect appendix colours represented tuples containing red green blue alpha transparency components range 
transparent 
checker board checker defined function takes coordinate returns 
stripes function easier define 
simply check colour red blue 
checker stripes see image overlay combinator 
function combines images pointwise 
depending transparency top image portion underlying image show 
interesting pan primitive warps image rotating points distance proportional distance origin 
empty image completely transparent 
unboxing arithmetic motivation approach pantheon numerically intensive application exclusively floating point arithmetic 
unboxing yield significant improvements speed 
arithmetic function unbox arguments perform primitive arithmetic operation values re box result 
unboxed code yields better memory locality checker floor floor stripes floor blue red checker stripes checker empty stripes fig 

checker board imposed vertical blue red stripes arguments results require indirection heap allocated object 
fact may possible arguments placed directly registers 
compilers optimise away unnecessary boxing feasible implementors generally knowledge compiler consequently better 
certain validity unboxing assuming function pantheon monomorphic 
quite possible define functions way done nicer solution specialise invocation polymorphic function type information gleaned context invoked 
discuss subsection 
begs question simply define functions terms unboxed arithmetic place 
apart fact syntax unboxed arithmetic ugly cumbersome important issue abstraction 
colour displayed component values converted integral value combined single bit integer placed video memory 
ciency gained converting functions operate colours integer arithmetic equivalents scenes user retains view current abstraction general terms optimisation requires traverse representation top level function replacing boxed arithmetic operators constants early experiments indicated arithmetic conversion measurably improved performance technical reasons prevented 
discuss reasons section unboxed equivalents 
unboxing arithmetic interesting transformation changes semantics program 
type resulting program corresponds exactly type original clear validity correspondence relies knowledge domain 
implementation template haskell process replacing boxed operators constants unboxed equivalents generally straightforward process template haskell run di culty context polymorphic data structures 
cases written family unboxing functions merely call unbox recursively sub objects declarations types bodies expressions 
interesting cases 
transforming type signatures 
clear type signatures type annotations existed original declarations longer valid 
type synonym data type declared boxed declarations declare unboxed version 
ease recognition name types ub su appended 

replacing arithmetic operators unboxed equivalents 
code assumes operators changed unboxed floating point equivalents 
recognise flawed assumption discuss 

replacing tuples stricter versions 
declared new data types express points colours increase strictness 
situation tuples add strictness annotations arguments constructor 
example cases action 
checker checker floor floor checker ub checker point ub float int float int main problem implementation unboxing pass lack easily accessible typing information 
problematic ways 
aspect problem impossible know type literal identified 
fortunately nearly literals definition pan functions instances fractional 
instances true special cases written 
previous section stated considered converting components colours range 
necessitated relatively complex transformation functions manipulated colours 
instance consider definition cover key component definition image overlay 
cover proposed transformation cover colour ub colour ub colour ub transformation feasible knowledge type variable 
instance example necessary know type ub range 
define functions pantheon 
type information specialise polymorphic functions containing arithmetic operations call site 
ability reify type fragment expression transformations simply written general case satisfactory solution regard principle shortcomings implementation 
discuss issue section 
inlining motivation approach style embedding original implementation pan ect inlining definitions reducing resulting function applications simplification occurred 
greatly increases opportunities algebraic transformation drawback introducing possibility code replication 
fortunately ect code replication mitigated applying common subexpression elimination cse pass 
success elliott investigated approach code improvement 
ghc passes performing beta reduction cse decided leave passes unimplemented see compiler performed 
results experiment encouraging provide concrete example section 
general terms ability inline code relies meta programming facilities ability reify transform splice code ability look definition top level function declaration 
unfortunately template haskell support second facility 
section explain solution problem involves manual creation look table 
inlining process relatively straightforward 
take input final animation image function pantheon display traverse definition 
time encounter function defined pantheon look definition create equivalent lambda expression substitute location 
recursively 
clearly leads non termination context recursion 
refuse inline recursive function definitions determining function recursive involved process requiring construction call graph determination strongly connected components case ghc 
unfortunately access information 
template haskell provide 
chosen limit inlining process fixed depth roughly corresponds loop unrolling 
implementation template haskell definitions inlining transformation concerned traversing components declaration 
function real 
implementation quite cluttered template haskell specifics chosen stepwise example ect running example 
inlining pass traverses declaration checker stripes comes variable sub expression checker 
point look performed name declaration checker retrieved 
convert definition equivalent lambda expression 
note declarations converted declarations 
floor floor expression substituted place variable 
function definitions contain guards handled 
occurs inlining stripes 
replaced floor red blue previous section promised concrete example ect ghc common subexpression elimination inlined code 
fitting example consider comes original implementation pan rotate pi result inlining clearly contains redundancy cos sqrt pi sin sqrt pi cos sqrt pi sin sqrt pi dump core code produced shows capable removing redundancy inline functions part haskell libraries 
intermediate representation ghc 
adding flag core command line dump code standard output 
interestingly cse done 
failed see expression ghc prim corresponding expression twice 
se ww se ww se ghc prim ghc prim ww se ghc prim ghc prim ww se ghc prim ghc prim ghc prim ww se ghc prim ghc prim ww se ghc prim ghc performs reduction constant folding replaced constant 
saves implementation ort 
algebraic transformation motivation approach principle algebraic transformation optimisation technique simple expressions substituted semantically equivalent expressions compile faster code universally average 
consider running example see overlaying entirely transparent empty image top stripes ect 
proved examining definition 
checker stripes checker empty stripes expression may simply replaced stripes 
algebraic identity holds empty image image 
examples algebraic properties pan see appendix 
exciting technique pantheon general context fairly novel context outside compiler 
key advantage embedded compiler need implement transformations specific extending overriding optimisations compiler 
general terms algebraic transformations easy implement 
expression attempt match left hand side algebraic identities 
successful replace equivalent right hand side expression 
ensure sub expressions optimised recursively apply sub expressions left unchanged original transformation 
algebraic transformation applicable 
implementation template haskell template haskell reification code algebraic data types combination pattern matching features algebraic transformations easy write noted 
earlier showed expression empty image replaced image 
particular case implemented code 
vare vare empty image image side ects rich syntaxes ered modern programming languages including haskell way write essentially expression 
order reduce number syntactic patterns matched number cases written put expressions canonical form 
instance example matches canonical prefix form empty image algebraic identity earlier 
tedious aspect transformations recursive cases 
wish transformations applicable just expressions subexpressions cases recursively call sub expressions 
cases numerous easily outnumber cases interesting module written unnecessary rewrite cases afresh new transformation 
benchmarks performance testing pantheon conducted ways optimised ects compared counterparts original pan implementation 
pantheon vs compares frame rate ect di erent combinations optimisations applied 
ects run ghz apple mb ram 
left ect algebraic transformations sample size small 
naturally ect computational redundancy show ectiveness tell 
collecting large number ects say ectiveness 
ect base inlined unboxed unboxed inlined checker circle checker stripes squares tunnel view fig 

ect optimisations frame rate ects displayed resolution 
pantheon vs pan possibly interest performance pantheon compares pan 
unfortunately di cult compare platform disparity 
pantheon implemented nix platforms pan runs microsoft windows 
performed measurements pantheon pan machine mhz pentium iii mb ram resolution results inconclusive 
checker ect performance compares favourably resolution runs frames pantheon frames pan 
ects squares perform far better pan frames slowly pantheon frames frames respectively 
ects substantial primitive layering images top 
appears pan performs better optimisation context primitive 
shown issue lie inherent deficiencies quality code ghc produces 
hand code optimised simple ect ran speed comparable ect pan pixels 
aspect template haskell implementation hindered tuning creation optimisations lack support profiling programs contain splicing 
relative code sizes compare amount code needed implement pan pantheon crude means comparing implementation ort 
pantheon implemented slightly lines code pan exceeds implementations entirely comparable pantheon support user interface bitmap loading capabilities pan 
implementable handful lines code require changes estimate require lines code 
template haskell specifics section review di culties current template haskell implementation solutions devised 
envisage section users template haskell may skipped safely 
reification top level functions unboxing arithmetic inlining require ability reify top level function declarations 
currently reification unsupported template successfully built debian linux mac os haskell 
relatively simple problem 
create look table steps 
place entire module declaration reification brackets call resulting data structure appropriate 
create look table module applying function creates list pairs matching names function declarations 
interesting dilemma arises wishes write module say th refers functions defined module th functions th scope 
solution write module splices reified functions th 
import th inside module th 
quite solve problem 
wish transform functions th th bringing scope solution outlined causes functions th refer functions scope 
representation functions contain original names form module function names respectively 
necessary write pass called ensure functions transformed functions th correctly refer transformed functions th splice time 
addition template haskell native means deal reification top level function declarations greatly simplify implementation pantheon similar programs error prone 
add user pantheon knows metaprogramming place automatically preprocess user written source files add reification brackets apply transformations splice result back 
lack type information section mentioned lack type information prevented satisfactorily implementing unboxing transformation 
main reasons 
require type literals order choose correct primitive unboxed arithmetic functions 

knowing type invocation polymorphic function instantiated necessary choose correct primitive unboxed arithmetic functions 

polymorphic data structures contain unboxed values 
specialised data structures required 
types needed 
subsection discusses 
template haskell underwent substantial revision 
features added ability reify variable names glean things types 
unfortunately possible variable name convention append th modules constructed manner question brought scope reasons came module generated splice appears current module generated top level splice occurring earlier current module 
fact type information available splicing declaration variable appears general undecidable arbitrary meta program run produce correctly typed code 
motivation design template haskell typing system defers type checking meta programs run 
special case reified code closed sense contained splices variable names scope possible principle type code 
precisely sort declaration pantheon wish glean type information 
unboxing context polymorphic data structures section hinted problem unboxed values context polymorphic data structures 
restrictions unboxed values may stored polymorphic data structures 
necessitates specialisation polymorphic data structures monomorphic counterparts 
disregarding di culty doing absence typing information additional di culty 
possible reify data type declarations modules template haskell primitive possible reify definitions functions modules 
example illustrates di culty arising 
weird point weird head zipwith ability reify definitions zip head specialise monomorphic version list data type solution marshal data unboxed monomorphic representations key points function definition feasible requires access type information 
clear ability reify entire modules functions modules added template haskell 
solution necessary case 
question re write rules implementation chosen re write rules perform algebraic transformation programs principle possible 
template haskell provides full control timing application transformations ghc rewrite rules 
experience suggests notoriously di cult ensure rewrite rules applied intends 
complex interaction optimisations ghc case nearly applicable 
identified number ways pantheon improved 
suggestions limited particular benefit extensional meta programming approach taken 
conversion domain data types 
interested converting components colour data type integers range converting functions manipulate colour operate range 
noted feasible able ascertain type individual components functional declaration 
believe type information allow radical conversion 
key function pantheon takes colour converts component range fits bits packs components bit integer bitwise operations 
interesting see colours represented bit representation times 
require colour manipulating functions bitwise operations colours native pattern matching facilities haskell language 
moving optimisation phases host language compiler libraries 
subtle problem interaction ghc optimisations optimisations performed ghc 
unfortunately order optimisations important increase ectiveness performed correct time 
encountered problem pantheon feel problem benefit closer scrutiny 
solution problem 
proposal optimisations written template haskell 
ect shifting large portion compiler support libraries arguably simplify implementation considerably 
raises new problems 
optimisations ghc depend information gleaned structure input program examples include strictness analysis various forms data flow analysis call graphs 
optimisations applied core language simplified intermediate representation haskell programs haskell 
syntactically simpler complicated semantics writing optimisations core easier 
idea adding meta programming facilities core put forward far clear implemented 
potential benefits probably outweigh di culty proposal 
access type information execution meta programs 
interested implementing small extension type checker template haskell allows closed reified code typed 
interesting see declarations closed partially typed 
related languages developed embedded approach domain specific language construction 
examples include xml translation language fran haskore 
languages written interpretive style domain types modelled algebraic data types language primitives functions recursively traverse 
leads ine cient code original motivation embedded compiler approach pan 
feel approach sacrifices 
apart having write entire back compiler introduces disparity semantics host language target language lead problems loss host language features burden having duplicate ect constructs expressions due synthetic nature types embedded compiler 
ine ciency results host compiler able see level new language 
compilers intimate knowledge semantics primitive constructs knowledge allows perform sophisticated optimisations improve performance code 
understand manner 
meta programming solves problem allowing programmer knowledge write domain specific optimisations 
handful optimisations significantly improve performance pan 
performance match pan believe substantial scope improvement performance eventually par 
design pantheon aware areas template haskell task di cult 
inability reify top level function declarations entire modules lack native means obtaining type information expressions 
problem solved elegantly requires satisfactory solution 
source code pantheon instructions building www cse unsw edu au pantheon html comments suggestions number people helped improve presentation 
chronological order contribution authors ian simon peyton jones john donnell anthony sloane 
listing module image listing just parts module image needed understand examples 
module image type point float float type colour float float float float type image point type image colour type warp point point colour colour lift lift lift empty empty lift point float sqrt float warp pi cover colour colour colour cover lift cover algebraic properties pan empty image image image image image translate translate im translate im rotate im rotate pi im div pi rotate rotate im rotate im scale scale im scale im 
glasgow haskell compiler 
haskell org ghc 

krzysztof czarnecki john donnell jorg walid taha 
dsl implementation metaocaml template haskell 
url www cs rice edu taha publications html 

conal elliott 
functional implementations continuous modeled animation 
lecture notes computer science 

conal elliott 
functional image synthesis 
proceedings bridges mathematical connections art music science 

conal elliott finne oege de moor 
embedded languages 
journal functional programming may 

paul hudak 
building domain specific embedded languages 
acm computing surveys es 

paul hudak 
modular domain specific languages tools 
devanbu editors proceedings fifth international conference software reuse pages 
ieee computer society press 

paul hudak tom gadde bo 
haskore music notation algebra music 
journal functional programming 

simon peyton jones andrew tolmach tony hoare 
playing rules rewriting practical optimisation technique ghc 
international conference functional programming icfp 
haskell workshop september 

ian 
unrolling simplifying expressions template haskell 
url web comlab ox ac uk ian papers unrolling simplifying expressions template haskell ps may 

sage 
declarative gui language haskell 
acm sigplan notices 

tim sheard simon peyton jones 
template meta programming haskell 
acm sigplan notices pli workshops 

malcolm wallace colin runciman 
haskell xml generic combinators type translation 
proceedings fourth acm sigplan international conference functional programming icfp volume pages 
acm press 
