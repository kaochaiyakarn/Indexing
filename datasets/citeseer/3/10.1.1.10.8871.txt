region memory management cyclone dan grossman greg morrisett trevor jim michael hicks wang james cheney computer science department cornell university ithaca ny cs cornell edu cyclone type safe programming language derived primary design goal cyclone programmers control data representation memory management sacrificing type safety 
focus region memory management cyclone static typing discipline 
design incorporates advancements including support region subtyping coherent integration stack allocation garbage collector 
support separate compilation cyclone requires programmers write explicit region annotations combination default annotations local type inference novel treatment region effects reduces burden 
result integrate idioms region framework 
experience porting legacy cyclone required altering code changes region annotations 
categories subject descriptors programming languages language constructs features dynamic storage management general terms languages 
software systems including operating systems device drivers file servers databases require fine grained research supported part sloan br nsf afosr onr nsf graduate fellowships 
opinions findings recommendations expressed publication authors reflect views agencies 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
pldi june berlin germany 
copyright acm 
labs research park avenue florham park nj trevor research att com control data representation field layout resource management memory management 
de facto language coding systems providing low level control admits wide class dangerous extremely common safety violations incorrect type casts buffer overruns dangling pointer dereferences space leaks 
result building large systems especially ones including third party extensions 
higher level type safe languages avoid drawbacks doing fail give programmers control needed low level systems 
porting extending legacy code prohibitively expensive 
safe language level abstraction easy porting path attractive option 
developed cyclone language designed close safe 
written ported lines cyclone code including cyclone compiler extensive library lexer parser generators compression utilities device drivers multimedia distribution overlay network web server smaller benchmarks 
process identified common idioms usually safe type system weak verify 
augmented language modern features types programmers idioms safety guarantees 
example reduce need type casts cyclone features parametric polymorphism subtyping tagged unions 
prevent bounds violations making hidden data representation changes cyclone variety pointer types different compile time invariants associated run time checks 
projects aimed making legacy code safe addressed issues somewhat different approaches discussed section 
focus novel aspect cyclone system preventing dangling pointer dereferences space leaks 
design addresses seemingly conflicting goals 
specifically system sound programs dereference dangling pointers 
static dereferencing dangling pointer compiletime error 
run time checks needed determine memory deallocated 
convenient minimize need explicit programmer annotations supporting idioms 
particular uses addresses local variables require modification 
exposed programmers control objects allocated long live 
usual local variables allocated stack 
comprehensive treat memory uniformly including stack heap optionally garbage collected regions 
scalable system supports separate compilation analyses intraprocedural 
seminal tofte talpin system region object lives region exception distinguished heap region may garbage collected region objects deallocated simultaneously :10.1.1.23.5498
static system explicitly typed low level language cyclone region framework technical contributions previous notably region subtyping discipline region lifetimes induces outlives relationship regions turn allows provide useful subtyping discipline pointer types 
simple effects eliminate need effect variables complicate interfaces regions type operator 
default annotations combine local inference algorithm system defaults reduce need explicit region annotations 
integration existential types combination region subtyping simple effects integration class data types relatively simple 
cyclone region system sufficiently expressive porting legacy code writing new applications 
experience porting code required altering code vast majority changes region annotations 
furthermore cyclone performed network applications considered factor computationally intense programs 
demonstrate contributions general description system suitable programmers section 
technical discussion novel effect system interaction existential types section 
continue core formal language proven sound section overview implementation section study burden porting code cyclone resulting performance section 
discuss related section section 
cyclone regions section presents programmer view cyclone memory management system 
starts constructs creating regions allocating objects part simple departure small 
corresponding type system involved pointer type carries region annotation 
show regions lifetimes induce subtyping pointer types 
point type syntax quite verbose explain features practice eliminate region annotations 
take liberty syntax greek letters actual cyclone 
ascii syntax region oriented cyclone see user manual 
basic operations cyclone memory region kinds single heap region conceptually lives forever stack regions correspond local declaration blocks dynamic regions lexically scoped lifetimes permit unlimited allocation static data objects reside heap 
primitives malloc new create new heap objects 
new operation malloc takes expression initializes memory 
explicit mechanism reclaiming heap allocated objects free 
cyclone programs may optionally link boehm demers weiser conservative garbage collector reclaim unreachable heap allocated objects implicitly 
interaction collector regions discussed section 
stack regions correspond directly local declaration blocks entering block local declarations creates storage lifetime corresponding lexical scope block 
function parameters stack region corresponding function lifetime 
short cyclone local declarations function parameters exactly layout lifetime dynamic regions created construct region identifier statement 
region lifetime execution bound primitives rnew allocate objects associated region 
example rnew returns pointer int allocated region handle initialized 
handles class values caller may pass handle function allow allocate associated region 
predefined constant heap region handle heap 
declaration block dynamic region deallocated precisely execution leaves body enclosed statement 
execution leave due unstructured jumps continue goto areturn exception 
section explains compile dynamic region deallocation 
region system imposes changes representation pointers meaning operators 
hidden fields counts maintaining region information run time 
pointers arrays unknown size denoted implemented extra fields support bounds checks design orthogonal regions 
infrastructure preventing dangling pointer dereferences static type system making dereferences compile time error 
basic type system region annotations 
pointers point exactly region 
principle pointer types annotated region name region point practice eliminate annotations 
ignoring subtyping int describes pointer int region char strcpy char const char char const char char region const char size strlen const char cyclone string library prototypes name 
invariant pointers particular region basic restriction impose undecidable problem detecting dangling pointer dereferences tractable 
pointer types different region names different types 
handle region corresponding type region 
region names fall categories 
region name heap block labeled int name refers stack region block creates 
similarly arguments function stored stack region statement region defines region name created region 
type region 
cases scope region name corresponds lifetime corresponding region 
give types small examples 
type region type type 
int declared block type int similarly type type 
preventing dangling pointer dereferences 
dereference pointer safety demands region live 
goal determine compile time code follows dangling pointer 
suffices ensure pointer types region names scope 
example code ill typed 
int 
int 


code creates storage line deallocates line assignment creates dangling pointer dereferenced line 
cyclone rejects code scope declared 
change declaration region assignment fails type check type int cyclone advanced features notably existential universal polymorphism conspire allow pointers escape scope regions just closures allow pointers escape original tofte talpin 
general rely simple scoping mechanisms ensure soundness 
track set live region names control flow point 
keep analysis intraprocedural novel type effects system track interprocedural liveness requirements 
delay full discussion effects section 
region polymorphism 
functions cyclone actual regions arguments results 
way functions manipulate pointers regardless point stack heap dynamic region 
presents prototypes cyclone string library including strcpy region allocating function 
cyclone notation pointer dynamically sized array 
functions exhibit region polymorphism 
strcpy parameters region names abstracted syntax meaning instantiated actual region name function called 
write code char buf strcpy buf heap pointer syntax call instantiates heap region stack region allowing copy string heap stack 
region polymorphism guarantee region equalities unknown regions region names 
example strcpy region names argument return value returned pointer point region argument 
region name equalities important dynamic regions 
example function version copies source string dynamic region 
prototype matches region name dynamic region handle region 
fact implement just calling char const char return heap region polymorphic recursion 
valuable instantiate region parameters recursive function call different names function region arguments 
example contrived program function fact abstracts region takes arguments pointer integer 
void fact int result int int fact result int int main fact return executed program returns value 
main heap pointer type fact instantiated 
contrast recursive call instantiates name stack region 
run time call fact modifies call modifies value caller stack frame 
type definitions 
struct definitions contain pointers cyclone allows definitions parameterized region names 
example declaration lists pointers ints struct lst int hd struct lst tl ignoring subtyping value type struct lst list hd fields point tl fields point 
invariants possible type tl struct lst declaration char strcpy char const char 
char 
const char 
char region const char 
size strlen const char 
cyclone prototypes minimally annotated describe lists regions hd tl alternated element 
type abbreviations typedef region parameters 
example define region allocated lists heap allocated pointers typedef struct lst list subtyping type system described far quite powerful expressive cases 
example common define local variable alternatively hold value arguments void int int int int 
appears program fail type check type int change type int int assignments illegal 
solve problem observe region corresponding outlives region corresponding sound value type type 
cyclone supports coercions implicitly 
region discipline outlives relationships common create region know region currently alive outlive 
simple subtyping outlives relationship allows program type check 
region polymorphic functions specify outlives relationships arguments explicit preconditions express partial orders region lifetimes 
practice rarely feature local outlives information sufficed 
ensure soundness allow casting subtype cast allow putting location code expects 
usual covariant subtyping 
cyclone allow casts const subtype 
ensure soundness enforce read access const values 
support deep subtyping combined polymorphic recursion powerful allow stack allocation recursive structures arbitrary size 
eliminating annotations cyclone explicitly typed principle combination inference chosen defaults reduce dramatically number annotations needed practice 
emphasize approach inference purely intraprocedural prototypes functions inferred 
default completion partial prototypes minimize region annotations 
approach permits separate compilation 
writing pointer type int region annotation optional compiler deduces appropriate annotation context 
local declarations unification inference engine infers annotation declaration intraprocedural uses 
local inference works practice especially declarations initializers 

omitted region names argument types filled fresh region names generalized implicitly 
default functions region polymorphic region equalities 

contexts return types globals type definitions omitted region names filled heap 
default works global variables functions return heap allocated results 
fails functions strcpy return parameters 
looking function body determine parameter component parameter function return 
addition calling region polymorphic function programmer omit explicit region name instantiation inference engine discovers 
result devices fact example annotation free void fact int result int int fact result put way function treated code ports cyclone modification 
shows string library functions minimally annotated 
cases lack region annotation argument means type checker insert fresh region name pointer type generalize 
lack annotation return type defaults heap 
total region annotations removed generalization implicit 
default annotations inference engine reduce burden programmer porting easier necessary put explicit annotations express equalities necessary safety 
example write void int pp int pp code elaborates void int pp int pp fails type check int int 
programmer insert explicit region annotation assert appropriate equality relation parameters void int pp int pp employ technique greatly reduces annotations practice regard type definitions 
partially apply parameterized type definitions elided arguments filled rules pointer types 
aggressive feature typedef struct lst heap copy ans null null tl ans new lst new hd ans return ans defaults parameter type return type 
inference compiler gives ans type return statement requires ans function return type type initializer type 

effects argued section scope restrictions region names prevent pointers escaping scope region 
particular function block return assign value type outside scope definition simply write formed type result 
cyclone mechanisms type abstraction property hold 
way hide pointer type result pointer escape scope region 
instance cyclone upwards escaping closures hide pointer local variable closure environment return closure outside scope variable introducing dangling pointer 
problem closure invoked dereference dangling pointer 
critical problem tofte talpin address functional languages 
cyclone closures typing constructs hide regions 
particular cyclone provides existential types suffice encode closures simple forms objects 
possible cyclone pointers escape scope regions 
address problem cyclone type system keeps track subset region names considered live control flow point 
walker crary morrisett call set live regions capability :10.1.1.1.3704
allow dereferencing pointer type system ensures associated region name capability 
similarly allow function call cyclone ensures regions function access live 
function types carry effect records set regions function access 
idea effects ensure soundness due tofte talpin tt 
treatment effects differs substantially previous 
major departure tt calculate default effects function prototype inferring function body order preserve separate compilation 
default effect includes set region names appear argument result types 
instance prototype int int int elaborates int int int default effect 
absence polymorphism default effect conservative bound regions function access 
region names prototypes programmer override default explicit effect 
example dereferences argument strengthen prototype adding explicit effect follows int int int practice default effects extremely useful 
lines cyclone code far written non default effect 
second major departure tt effect variables 
effect variables tt purposes simulate subtyping inference framework set regions closure need access set regions hidden type 
original cyclone design tried tt style effect variables 
approach explicitly typed language reasons 
effect variables introduced tt support effect subtyping occur free location effect variables prenex quantified 
unification algorithm depended crucially structural invariants 
explicitly typed language enforcing constraints difficult 
furthermore prenex quantification restriction prevented class polymorphic functions cyclone supports 
second needed effect variables library interfaces making libraries harder understand 
consider instance type polymorphic sets struct set list elts int cmp set consists list elements spine list region 
know elements allocated instantiate 
comparison function cmp determine set membership 
type elements known type cmp function effect variable set regions access comparing values 
effect variable type region variable abstracted set structure 
suppose library exports set structure clients abstractly revealing definition struct set client discern connection hidden comparison function access 
avoiding effect variables simplify system retaining benefit effect variables type operator regions 
novel operator just part type system 
intuitively regions represents set regions occur free 
inparticular regions int regions regions regions regions regions regions type variables regions treated set region variables effect variables 
example regions regions 
default effect function type simply includes regions 
addition regions example follows struct set list elts int cmp regions connection type parameter comparison function effect apparent data structure longer needs parameterized effect variable 
regions default effect int cmp need write 
suppose wish build set int value particular comparison function int cmp ptr int int return set int build set list int return set elts cmp cmp ptr default effect cmp ptr 
instantiating int effect cmp regions int equals 
result function build set typechecks 
fact function default effect succeed 
consequently programmers need explicitly mention effects designing libraries 
addition unifying function types somewhat easier default effects argument result types functions default effect 
interaction existential types mentioned cyclone supports existential types allow programmers encode closures 
example give type call backs return int struct intfn int func env env call back consists function pointer abstracted state passed function 
existentially bound various objects type struct intfn instantiate differently 
struct intfn object created type checker ensures type fields initialized correctly 
access fields existential object need open giving name bound type variable 
example write admittedly alien syntax int apply intfn struct intfn pkg intfn func env pkg return form binds pkg func type int pkg env type 
function call appears typed 
effect regions evidence regions live scope 
regions may live code demonstrates int read int return struct intfn int struct intfn ans int func read env return ans abstracted type instantiated int call back environment pointer int region function call back just dereferences pointer passed 
packaged existential int hidden result typed despite fact call back dangling pointer 
short struct intfn objects leak information prove call safe 
resorting effect variables give regions bound struct intfn 
bound means regions outlive type checker rejects instantiation bound may hold 
pkg type struct intfn call long live 
practice bounds reduce effect call back single region 

formal soundness separate technical report defined operational model core cyclone formalized type system proven type soundness 
space constraints prevent including material summarize salient details 
core cyclone includes features relevant memory management including stack allocation dynamic regions polymorphism existential types 
operational semantics small step deterministic rewriting relation machine states machine states 
machine state triple consisting garbage stack statement stacks lists mapping region names locations 
garbage stack technical device record deallocated storage program stays closed despite dangling pointers 
note machine stuck program attempts read write location garbage stack 
primary goal formalism prove typed programs get stuck garbage stack deallocated regions need exist execution 
syntax gives bnf definitions syntax statements expressions types core cyclone 
constructors define syntax types regions 
kind discipline determine type variable represents type region 
types include pairs model structs 
structs pairs passed value copied 
duplicate polymorphic code pair types instantiate type variables values larger types words 
types include type variables universal types existential types 
quantifiers range types regions include region constraints specify partial orders region lifetimes 
region constraint kinds region sets region constraints constructors int handle expressions rnew pack values region pack paths functions statements return region open pop constraints form region set region 
intuitively constraint means live regions live 
region sets include region variables 
omit regions conciseness 
function types include region set specifies function effect set regions live calling function 
statements consist expressions return statements composition statements statements 
addition include blocks declaring new stack region variable region declarations region form opening values existential type 
statements include special form pop executed evaluates terminal state deallocates moves garbage stack region 
form available source programs internally machine marker indicate deallocate region 
expressions include variables double locations 
variable lives region formally fact explicit 
expressions integers functions pointer dereference function calls address operator assignment addition expressions include type instantiation pairs projection rnew packages 
lastly region handles region special form available source programs creating dynamic region region binds region 
model individual memory locations paths object 
instance location contains value path refers refers 
path value 
static semantics important typing judgment statements 
form stmt records type region variables scope records value variables scope types records partial order constraints relating region lifetimes records capability regions considered live records type statement form return just interesting rules 
syntax core cyclone type checking statements requires checking expressions correct types 
example rule return statements stmt return expressions access memory proven live 
example rules prove live 
informally need partial order shows outlives course suffices 
idea subsumption rule type check function calls mean 
rule standard rule type instantiation novelty ensuring establishes constraints type checking judgment just means 
abuse notation write capture avoiding substitution substitution regions 
necessary judgment statements ret ensures execution terminates terminal state form return value judgment defined simple syntax directed analysis enforces functions fall return values 
set proof soundness define judgment assert garbage stack stack described context heap set region names bound records types locations bound records regions relative lifetimes 
particular describes total order regions judgment connect assumptions statement reality current heap 
judgments state soundness theorem core cyclone theorem soundness 

heap 
ret 
int stmt 
contains pop statements runs forever exists return 
plain english start empty garbage heap stack contains single heap region formed statement doesn fall formed respect type initial heap returns integers contain pop statements program get stuck type errors dangling pointer dereferences 
furthermore program terminates regions allocated freed program return integer 
soundness proof available companion technical report uses long tedious progress preservation subject reduction lemmas 
just sketch complications proof preservation 
operational semantics uses type substitution example 
usual need substitution lemma order conclude typedness typedness explicit effects partial orders proving necessary substitution lemma requires auxiliary lemmas example implies 
second weaken theorem assumptions heap region pop statements proving program properly deallocates regions allocates 
assume partition deallocates regions order regions 
see assumption proper weakening ands 
assumption formalized judgment statements implies position pop statements prove program resulting rewriting step properly deallocates exactly live regions 
words ability partition necessary properties hold preserved evaluation 

implementing cyclone regions code generation run time support cyclone regions simple 
heap stack manipulation exactly dynamic regions represented linked lists pages page twice size previous 
region handle points list current allocation point page rnew place object 
insufficient space object new page allocated 
region deallocation simply frees page list 
garbage collector included dynamic region list pages acquired collector 
collector supports explicit deallocation free regions 
important note collector simply treats region pages large objects 
reachable stack scanned pointers objects ensuring objects preserved 
advantage interface simplicity cost collection time object dynamic region appears reachable live dynamic regions scanned objects reachable dynamic regions reclaimed 
code generator ensures regions deallocated lifetimes due unstructured control flow 
intraprocedural jump return determine statically regions deallocated transferring control 
throwing exception number regions deallocate known statically 
store region handles exception handlers integrated list operates manner 
exception thrown traverse list deallocating regions reach exception handler 
transfer control longjmp 
fashion ensure region deallocated control returns 

experimental results simplify porting programming cyclone sought minimize number required region annotations 
just important sought achieve performance 
sections analyze burden porting terms added annotations find annotations impose negligible burden application writer somewhat larger burden library writer 
section comparison cyclone performance ported applications find networking programs essentially perform compute bound applications factor slower due run time checks pointer representations 
porting application code ported number applications compared differences source code original cyclone version 
picked networking applications part systems domain controlling data representation important 
include web server mini httpd web utilities get post ping load simple client finger 
computationally intense older applications heavy arrays pointers include cfrac grobner 
ported compression utilities cacm 
took approaches porting 
changed programs little possible correct cyclone programs 
cfrac mini httpd code functions region polymorphic possible eliminated heap allocation program loc annotations cyc diffs total lines cacm cfrac finger grobner get load ping post mini httpd tile total benchmarks cfrac mini httpd total table benchmark code differences favor dynamic region allocation rnew 
added compiler checked null annotations pointer types possible avoid null checks 
results summarized table 
program table shows number lines cyclone code number differences region annotations required cyclone 
diffs column indicates number lines added changed porting cyclone 
annotations total column number individual region related alterations including variable annotations occurrences region rnew 
column total number lines file changed due annotations 
interesting results regarding difficulty minimal porting 
changes programs relatively small program code needed changed 
vast majority differences arise pointer syntax alterations 
changes typically easy type strings changed char char 
currently experimenting interpreting char safe null terminated string type default doing allows fewer changes 
encouraging result number region annotations small changes account roughly total changes lines code 
majority changes completely trivial programs required adding annotations argv arguments stored global variables 
program required changes grobner 
interestingly majority changes arose fact place stack pointer stored struct type 
parameterized struct definition region variable parameterization propagated rest code 
default annotation worked cases total variable declarations parameterized struct type required annotations 
cost porting program dynamic regions reasonable case roughly total differences region related 
web server able eliminate heap allocation entirely 
event loc proto rnew region string string max string cyc list list max list cyc table region annotations libraries driven handling request comes changed main handler function create dynamic region pass region handle subroutines request structure 
request serviced region freed 
majority changes arose moving global variables request structure adding structure parameter various functions 
request structure parameterized region functions need annotations connect region request structure argument return value 
successful cfrac 
web server changed functions allocate region handle parameters 
easy dynamic region allocation deallocation part algorithm main iteration large inputs difficult keep regions growing large deallocation 
conclude garbage collection better match code success regions 
porting library code ported significant subset caml libraries cyclone 
illustrative cases cyclone list string libraries ported caml respectively 
table summarizes region annotations interfaces implementations libraries 
rough measure effectiveness default region annotations provide results maximally annotated versions interfaces list max string max respectively 
proto column lists number region type annotations necessary function prototypes rnew column lists number uses rnew column lists number uses dynamic regions 
library code requires region annotations application code annotations sake convenience generality necessity 
library functions perform allocation come flavors heap allocating function signature corresponding caml function version takes additional region handle generality annotations occur 
changes function prototypes explicit region annotations necessary bodies functions 
maximally annotated interfaces require times region annotations default region annotations suffice time 
non default region annotations needed express region relationship arguments return types allow function allocate arbitrary region remainder needed type definitions 
effect annotations whatsoever necessary 
importantly applications compiler libraries extensively region instantiation im test ctime cyclone time checked factor unchecked factor cacm cfrac finger grobner get load ping post mini httpd tile compiled garbage collector benchmarks cfrac mini httpd plicit 
vast majority library calls ported code require changes malloc memcpy essentially exceptions 
performance table shows performance original versions benchmark programs cyclone versions bounds checks null checks 
ran benchmark times mhz pentium iii mb ram running linux kernel gcc back 
gcc optimization flags compiling original code output cyclone compiler march 
observed skewed distributions benchmarks report medians semi interquartile ranges 
non web benchmarks web benchmarks median mean essentially identical standard deviation mean 
factor columns cyclone programs show slowdown factor relative versions 
achieve near zero overhead network bound applications clients servers pay substantial penalty compute intensive benchmarks worst grobner factor slower version 
seen slowdowns factor pathological scenarios involving pointer arithmetic microbenchmarks 
common sources overhead safe languages garbage collection bounds checking 
garbage collection overhead easy measure cyclone program require significant 
shown table benchmarks needed garbage collection 
profiling garbage collected version cfrac suggests garbage collection accounts approximately half overhead 
partially cfrac resulted improvement 
hand load tile relatively little dynamic allocation garbage collection overhead 
semi interquartile range difference high quartile low quartile divided 
measure variability similar standard deviation recommended jain skewed distributions 
table benchmark performance expect overhead vary widely different programs depending memory usage patterns 
table demonstrates bounds checks important component overhead expected 
major cost due representation fat pointers 
fat pointer represented words base address bounds address current pointer location essentially representation bounded pointers 
result larger space overhead larger cache footprint parameter passing return value copying increased register pressure especially register impoverished 
fat pointers currently pointer types cyclone support pointer arithmetic dynamically sized arrays fat pointer performance crucial cyclone programs 
slight changes fat pointer operations gcc flags relating instruction selection huge impact performance 
particular replacing inlined pointer operations macros setting architecture specific instruction selection flag properly doubled speed applications 

related concentrated region type system cyclone naturally supports style stack allocation conventional heap allocation dynamic region allocation 
feel cyclone unique promising point programming language design space systems share features cyclone 
making safe 
systems including certainly limited lclint slam safe ccured aim code safe 
systems lclint meant static bug finding tools 
cyclone usually require restricted coding idioms additional annotations cyclone offer soundness guarantees 
way static tools reduce false positives 
contrast cyclone uses combination static type system memory management run time checks bounds violations minimize false positives 
systems safe ccured ensure soundness rewriting code adding run time checks implementation dependent static analysis eliminate checks 
primary advantage systems require changes code cyclone 
preserve data representations lifetimes objects 
cyclone 
pointers wide representation pointers programmer control 
furthermore memory errors caught run time compile time 
instance object freed ccured entire storage immediately reclaimed marked inaccessible 
subsequent accesses check mark signal error object dereferenced 
ultimately mark reclaimed garbage collector avoid leaks 
ccured may move stack allocated objects heap avoid dangling pointer dereferences 
static regions 
tofte talpin seminal implementing ml regions provides foundation regions ml kit :10.1.1.23.5498
programming kit convenient compiler automatically infers region annotations 
small changes program drastic unintuitive effects object lifetimes 
program effectively understand analysis try control indirectly certain idioms 
ml kit includes optional support garbage collection regions 
number extensions basic tofte talpin framework avoid constraints lifo region lifetimes 
examples ml kit includes reset region primitive aiken provide analysis free regions early walker propose general systems freeing regions linear types 
systems expressive framework 
instance ideas capability calculus implement type safe garbage collectors language 
systems designed source level programming 
designed compiler intermediate languages analyses ignore issues minimizing annotations providing control user 
projects vault henglein aim provide safe source level control memory management regions 
vault powerful type system allows region freed leaves scope types enforce code free region 
vault restricts region aliasing tracks finegrained effects 
result programming vault requires annotations 
find vault extremely promising direction hope adapt ideas cyclone 
henglein designed flexible region system require lifo behavior 
system monomorphic order unclear extend support polymorphism existential types 
tal microsoft cil provide support type safe stack allocation 
system allows programmers mix stack heap pointers systems place overly strong restrictions stack pointers 
instance microsoft cil prevents pointers placed data structures returned results features language implementors need effective compilation 
regions closely related gay aiken rc compiler earlier system 
note region programming old idea contribute language support efficient counting detect region deallocated remain pointers 
dynamic system regions lifetimes pointer point rc approach encode memory management idioms 
cyclone provide pointer annotations 
annotations required crucial performance reduce need counting 
annotation similar notion region subtyping 
rc uses counting dynamic regions 
fact annotation enforces pointer points dynamic region counting needed 
result rc allows dangling pointers stack heap 
kinds type errors remain 
number array bounds bugs benchmarks evaluate rc grobner tile 
rc support kind polymorphism cyclone rc compiler know statically objects pointers 
summary systems convenient cyclone ccured take away control memory management 
static systems capability calculus provide powerful region constructs designed intermediate languages programming convenience cyclone 
systems rc safe flexible offer static guarantees 

great deal remains achieve goals easily providing type safe language building systems control data representations memory management issue 
near hope incorporate support deallocating dynamic regions early 
experimented briefly linear type systems style capability calculus vault approach generally restrictive especially context exceptions 
currently developing traditional intraprocedural flow analysis track region aliasing region lifetimes 
interprocedural case expect add support explicit annotations experimental evidence drive choice defaults 
expect incorporate better support class regions style rc 
goal give programmers sufficient range options statically checked regions time fall back dynamically checked regions needed 
addition enhancements region system needed areas 
instance seen run time overheads ranging benchmarks overheads high microbenchmarks 
currently working identify bottlenecks clear problem representation pointers dynamically sized arrays 
pointers 
support dynamically sized arrays tag arrays implicit size information 
similarly support type safe discriminated unions add implicit tags 
adapting ideas dml xanadu tags explicit programmers control tags placed 
hope doing easier interface legacy code devices expect tags data support time saving space saving optimizations 
dml framework easily extend imperative languages cyclone 
particular subtle issues involving existential types address operator 
acknowledgments david walker fruitful discussions steve zdancewic jeff proofreading manuscript 

aiken hndrich levien 
better static memory management improving region analysis higher order languages 
acm conference programming language design implementation pages la jolla ca 
austin breach sohi 
efficient detection pointer array access errors 
acm conference programming language design implementation pages orlando fl june 
ball rajamani 
automatically validating temporal safety properties interfaces 
spin workshop model checking software volume lecture notes computer science pages toronto canada may 
springer verlag 

boehm weiser 
garbage collection uncooperative environment 
software practice experience 
bruce cardelli pierce 
comparing object encodings 
information computation 
cyclone user manual 
technical report department computer science cornell university nov 
current version www cs cornell edu projects cyclone 
deline hndrich 
enforcing high level protocols low level software 
acm conference programming language design implementation pages snowbird ut june 
henderson ross 
compiling mercury net common language runtime 
benton kennedy editors babel international workshop multi language infrastructure interoperability volume notes theoretical computer science florence italy sept 
evans 
lclint user guide 
lclint cs virginia edu guide 
evans 
static detection dynamic memory errors 
acm conference programming language design implementation pages philadelphia pa may 
gay aiken 
memory management explicit regions 
acm conference programming language design implementation pages montreal canada june 
gay aiken 
language support regions 
acm conference programming language design implementation pages snowbird ut june 
gordon syme 
typing multi language intermediate code 
eighth acm symposium principles programming languages pages london united kingdom jan 
grossman 
existential types imperative languages 
eleventh european symposium programming pages grenoble france apr 
grossman morrisett wang jim hicks cheney 
formal type soundness cyclone region system 
technical report department computer science cornell university nov 
elsman tofte 
combining region inference garbage collection 
acm conference programming language design implementation berlin germany june 
volume 
henglein niss 
direct approach control flow sensitive region memory management 
third international conference principles practice declarative programming florence italy sept 
jain 
art computer systems performance analysis 
wiley 
jim morrisett grossman hicks cheney wang 
cyclone safe dialect usenix annual technical conference monterey ca june 

bounds checking projects 
www gnu org software gcc projects bp main html 
minamide morrisett harper 
typed closure conversion 
third acm symposium principles programming languages pages st petersburg fl jan 
mitchell plotkin 
types existential type 
acm transactions progamming languages systems 
preliminary version twelfth acm symposium principles programming languages 
saha shao 
principled scavenging 
acm conference programming language design implementation pages snowbird ut june 
morrisett crary glew walker 
stack typed assembly language 
workshop types compilation volume lecture notes computer science pages kyoto japan mar 
springer verlag 
necula weimer 
ccured type safe retrofitting legacy code 
ninth acm symposium principles programming languages pages portland jan 
tofte birkedal 
region inference algorithm 
acm transactions progamming languages systems july 
tofte birkedal elsman olesen sestoft 
programming regions ml kit version 
technical report university copenhagen sept 
tofte 
talpin 
region memory management 
information computation 
walker crary morrisett :10.1.1.1.3704
typed memory management calculus capabilities 
acm transactions progamming languages systems july 
walker watkins 
regions linear types 
sixth acm international conference functional programming pages florence italy sept 
wang appel 
type preserving garbage collectors 
eighth acm symposium principles programming languages pages london united kingdom jan 
xi 
imperative programming dependent types 
fifteenth ieee symposium logic computer science pages santa barbara ca june 
xi pfenning 
dependent types practical programming 
sixth acm symposium principles programming languages pages san antonio tx jan 
