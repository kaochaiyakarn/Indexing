formal verification superscalar microprocessors multicycle functional units exceptions branch prediction 
extend burch dill flushing technique formal verification high level microprocessors logic equality uninterpreted functions memories applicable automatic fashion designs functional units memories multicycle possibly arbitrary latency 
show ways incorporate exceptions branch prediction effectively exploiting properties positive equality 
study modeling features different versions dual issue superscalar microprocessors 
keywords 
formal verification microprocessor verification uninterpreted functions logic equality 
order formal methods scale verification modern microprocessors need applicable easily high degree automation designs multicycle functional units multicycle memories exceptions branch prediction 
burch dill verification methodology potential highly automatic applied previously automatic manner designs single cycle functional units memories produce results instantaneously 
approach elegant flushing processor feeding bubbles instructions flight complete execution order compute abstraction function mapping implementation state specification state 
difference bubble nop bubble modify user visible state nop increments pc 
correctness criterion commutative diagram stating application transition function implementation followed flushing produce user visible state flushing implementation resultant user visible state apply transition function specification times 
practice range issue width implementation 
observed exploited burch controlled flushing change logic flushing purpose logic compute abstraction function 
having improper abstraction function compromise verification result false negative 
correctness criterion applied order designs sawada hunt jones :10.1.1.10.7924
approaches theorem proving require extensive manual intervention 
example sawada hunt method user manually build intermediate abstraction processor define large number lemmas nearly benchmark miroslav ece cmu edu www ece cmu edu randal bryant randy bryant cs cmu edu www cs cmu edu bryant department electrical computer engineering school computer science carnegie mellon university pittsburgh pa 
research supported part src contract dc 
preliminary version published 
considered necessary correctness proof 
require user manually define set completion functions unfinished instruction flight describing instruction completed instructions data dependency completed 
effectively results manual recreation functionality hardware 
furthermore user manually define way compose completion functions order form abstraction function processor 
researchers sawada hunt demonstrated techniques processors exceptions branch prediction projects required months manual 
combination model checking theorem proving order argue correctness basic order processor register register instructions 
method involves manual construction specialized circuit distant relation original design 
burch dill flushing technique applied processors multicycle functional units srivas gopalakrishnan claimed drawback hard pipelines indeterminate latency arise control involves data dependent loops part processor memory cache interface abstracted away managing complexity system 
extend burch dill flushing methodology applicable microprocessors functional units memories multiple cycle possibly arbitrary latency 
model exceptions branch prediction 
complex designs instruction types register register register immediate multicycle register register multicycle register immediate load store branch jump return exception nop 
completely functional pipelines consisting stages total instructions flight 
exhaustive binary simulation consider instruction sequences instructions 
furthermore accounting possible data dependencies raised exceptions correctness incorrectness branch predictions multicycle computations number significantly higher 
directed simulation probably find hard possible generate interesting instruction sequences design 
able formally verify minutes cpu time 
method multicycle functional units memories branch predictors abstracted place holders preserve modular structure units replaced automatically actual implementations refining high level implementation processor gate level synthesizable description 
background key success efficient decision procedure logic exploits properties positive equality ij encoding order translate correctness formula propositional formula evaluated bdds sat checkers :10.1.1.119.326
earlier exploiting positive equality bdds results dramatic speedup compared svc decision procedure logic exploit positive equality correctness formulas 
syntax includes terms formulas 
terms data values register identifiers memory addresses entire states memories 
formulas represent boolean signals model control path processor 
term uninterpreted function uf applied list argument terms domain variable ite operator selecting argument terms controlling formula ite formula term term evaluate term formula true term formula false 
formula uninterpreted predicate applied list argument terms propositional variable ite operator selecting argument formulas controlling formula equation equality comparison terms 
formulas negated connected boolean connectives 
refer terms formulas expressions 
ufs ups away implementation details functional units replacing black boxes satisfy particular properties functional consistency 
combinations values inputs uf produce output value 
longer matters original functional unit adder multiplier long uf replace implementation specification 
note way prove general problem processor correct implementation functional units 
general problem easier prove see scaling correctness proof processor actual bit level implementation alu 
syntax terms extended model memories means functions read write read takes argument terms serving memory address write takes argument terms serving memory address data 
functions return term 
satisfy forwarding property memory semantics read write mem equivalent ite read mem addition property functional consistency 
versions read write extend syntax formulas defined similarly returns formula takes formula third argument 
possible ways impose property functional consistency ufs ups ackermann constraints nested pushing leaves 
ackermann scheme replaces uf application formula new domain variable propositional variable adds external consistency constraints 
example uf application replaced new domain variable application uf replaced new domain variable resultant formula extended nested scheme application uf replaced new domain variable second replaced ite new domain variable 
third replaced ite ite new domain variable 
similarly ups 
note nested approach keeps consistency information located internal structure formula 
pushing leaves scheme uf application pushed leaves argument nested ite expressions arguments domain variables 
uf application unique list argument domain variables replaced unique new domain variable 
example ite transformed ite ite new domain variables replacing respectively 
scheme potential result term blow advan tage create equations argument terms previous schemes 
note pushing leaves scheme results conservative approximation functional consistency satisfies ackermann functional consistency constraints syntactically identical terms 
positive equality allows identification types terms structure formula appear positive equations called terms appear positive negative equations called terms general terms 
negative equation appears odd number negations part controlling formula ite operator 
computational efficiency exploiting positive equality due theorem states truth formula maximally diverse interpretation terms implies truth formula interpretation 
classification terms vs terms done ufs ups eliminated nested uf classified term term new domain variables generated elimination considered terms terms 
ufs ups eliminated maximally diverse interpretation equality comparison syntactically identical exactly domain variables evaluates true term domain variable syntactically distinct domain variable evaluates false term domain variable syntactically distinct term domain variable evaluate true false encoded dedicated boolean variable ij variable 
order fully exploit benefits positive equality designer processor model set suitable abstractions conservative approximations 
example equality comparison data operands determine condition take branch instruction abstracted implementation specification data operand terms appear negated equations arguments ups ufs classified terms 
similarly finite state machine fsm model memory conservative approximation actual memory employed model data memory addresses produced alu serve data operands classified terms 
fsm abstraction data memory automated 
result data values produced register file alu data memory pc values classified terms 
register identifiers equations control forwarding stalling conditions negated classified terms 
case processor branch prediction predicted actual branch address targets terms negated equality comparison logic corrects branch mispredictions see sect 

done automatically conservative approximation pushing leaves eliminating reads initial state memories addressed terms register file order reduce number distinct equations terms reduce number ij boolean variables 
prior exploiting positive equality speed proving validity formula generated burch dill method depended significantly manually identified case splitting expressions 
extreme example verifying single issue pipelined dlx 
formula correctness generated automatically included case splitting expressions evaluated svc hours 
contrast automatic tool exploits positive equality bdds completed evaluation seconds 
furthermore order burch verify dual issue superscalar version dlx decompose commutative diagram correctness criterion commutative diagrams easier verify correctness decomposition proved manually identify case splitting expressions minutes cpu time 
verified comparable design automatic tool seconds cpu time decomposing commutative diagram manually identifying case splitting expressions 
svc complete evaluation hours 
side note application completion functions theorem proving approach comparable dual issue dlx required month manual minutes cpu time 
distinguished positive negative equations logic equality uninterpreted functions pnueli 
careful analysis set equations propose encoding terms requires fewer bdd variables ij encoding 
guarantee smaller bdd sizes faster evaluation 
furthermore ackermann constraints enforce functional consistency ufs ups creates negative equations outputs ufs turning output terms terms 
hand exploit strategy nested enforce functional consistency ufs avoiding negated equations outputs treated terms 
ackermann constraints functional consistency ups create negated equations terms treat terms result worse bdd variable orderings slower bdd evaluations requiring order magnitude increase number bdd nodes cpu time see sect 
nested enforce functional consistency ups 
thorough comparison encoding ij encoding pending 
modeling multicycle functional units replace multicycle functional units place holders implemented constructs exhibit timing characteristics original functional units correctness processor place holders imply correctness actual implementation original functional units 
example model functional unit fixed latency cycles chain latches situated pipeline latches limit stage functional unit shown fig 
signal implement burch controlled flushing helps eliminate ambiguity instruction flow flushing translates significant simplification expressions correctness criterion formula 
signal set false regular symbolic simulation processor 
set true flushing order override original stall signal enforce stalling instructions previous pipeline stages guaranteed original stall signal evaluate false 
set false clock cycle order instructions previous stages advance set true original stall signal guaranteed evaluate false 
similar model stage pipelined multiplier sawada hunt exploiting burch controlled flushing 

model functional unit executes single cycle instructions true cycle instructions true 
feedback loop output latch chain avoids need impose check invariant latch output true 
flushing scheme alu latency dag node counts bdd variables max 
bdd nodes memory mb cpu time initial dag eliminating reads ufs final propositional logic dag regular regular memory 
burch controlled accelerated arbitrary table 
statistics experiments modeling multicycle alu stage arithmetic pipeline 
burch controlled flushing applicable pipeline cycle alu design stalling 
forwarding logic alu opcode data result 

stall latches implemented fixed latency alu model fig 
values ranging incorporated stage pipeline consisting fetch decode execute writeback stages capable executing register register instructions 
verification results shown table 
evaluation formula correctness criterion done automatic tool described 
verification model cycle alu latency chain latches require bdds 
due fact model stalling expressions produced sides commutative diagram correctness criterion identified identical hashed way ensures maximal sharing subexpressions 
careful uses regular flushing set false scaling exponential 
due term blow verification cycle latency runs memory minutes executed mhz sun gb physical memory gb swap space 
hand experiments burch controlled flushing scale cycle latency model requiring seconds bdd nodes mb memory 
cumbersome model processors multicycle instructions different fixed latency 
importantly model applicable functional units latency depends values input operands arbitrary environment factors memory system cache coherence mechanisms data value locked order modified processor 
functional units memory systems researchers hard application burch dill method real processors 
resolve problem technique call accelerated flushing 
cycle regular symbolic simulation implementation model indeterminate outcome possibly completing computation multicycle functional unit new boolean variable 
flushing force functional unit complete computations clock cycle 
original computation finished single cycle regular symbolic simulation implementation definitely completed cycle flushing new computation completed subsequent cycle flushing 
signal controlling completion multicycle computations generated automatically circuit fig 


generator new boolean variables extended gate order produce signal complete control computation completion multicycle functional unit accelerated flushing technique 
observe state finite state machine fsm output uf nextstate equality comparisons circuit classified terms formula translated propositional formula 
uf nextstate nextstate choice flush complete generator arbitrary values nd choice map input term domain variable new term domain variable corresponding output value 
state fsm updated new term domain variable cycle 
term domain variables mapped new boolean variable choice fsm generate sequence new boolean variables 
passed signal complete cycle regular simulation input flush set false 
flushing input flush true signal complete 
similarly uf depends state fsm fig 
order generate sequence new domain variables 
call fsms generators arbitrary values 
note generator arbitrary values properly exploiting properties positive equality 
implementation processor correct interpretations domain variables serving state fsm processor correct maximally diverse interpretation domain variables maps unique boolean variable output choice case new boolean variable automatically introduced clock cycle order symbolically model uncertainty 
new boolean variables express uncertainty completing multicycle computation hunt calls oracle variables uses model multicycle memory accesses 
designing place holders multicycle functional units arbitrary latency assume computation semantics expressed combinational functional unit abstracted uf alu see fig 
additionally assumptions abstracted functional unit functional unit deadlock eventually complete multicycle computation functional unit mechanism store input values guaranteed available cycle multicycle computation functional unit mechanism store result computation stages ahead ready accept result property hold functional units stalled functional unit discard going computation ready new clock cycle controlling squash signal raised clock cycle property hold functional units affected squash signal 
original functional unit formally verified satisfying properties model checking 
fsm fig 
timing functional unit 
conceptually multicycle computation states cycle flight executed cycle completed stalled pipeline stages state 
latch output uf alu computation cycle assuming data inputs correct values cycle 
alternative implementation latch inputs uf alu 
states fig 
encoded state bits arbitrary initial boolean values control fsm state initially 
signal stall stall previous pipeline stages computation completed complete false result accepted true 
signal complete produced generator arbitrary values fig 

control logic place holder generates signals indicate control fsm corresponding state state transition diagram fig 

implementation place holder functional unit arbitrary latency state transition diagram control logic place holder stalled determined signal 
order model computations guaranteed complete clock cycle start gate driving signal complete extended extra inputs account conditions 
pipeline stages mechanism stall multicycle functional unit control logic place holder simplified setting false removing state state transition diagram fig 
furthermore raised squash signal affects multicycle functional unit set signal complete false cause fsm fig 
transition state 
correct result alu result passed output result place holder stages ahead ready accept result false multicycle computation completed cycle complete true previously true 
output place holder get new domain variable produced generator arbitrary values output nd result 
effect analogous xs symbolic ternary simulation order express ambiguity 
place holder fig 
conservative approximation multicycle functional unit arbitrary latency 
functional unit modeled specification processor uf alu extra logic required implement place holder specification defines semantics instructions regardless timing 
note making op code term op inputs uf alu model potentially different computation instruction 
uf alu replaced memory model fsm implementing place holder memory system arbitrary latency 
modeling exceptions functional unit abstracted uf generate exception depends inputs functional unit order circuitry producing exception signal functional unit 
example condition alu exception function alu inputs data operands op code inputs 
hand instruction memory exception depends instruction address having illegal value model exceptions alu op data control logic stall stalled complete complete complete complete complete complete alu result stall complete control logic result generator arbitrary values flush complete nd choice nd result data takes input instruction address 
similarly data memory exception depends data memory address having illegal value possibly type access identified op code 
model exceptions takes inputs data memory address instruction op code 
predicates implementation specification order define correct semantics excepting instructions 
specifically excepting instruction allowed update pc register file data memory 
stores exception conditions dedicated exception status latch stores pc value exception pc latch subsequent instructions flight implementation performs jump fixed instruction addresses designate exception handler corresponding exception type 
exception handlers assumed implemented software correct 
fixed instruction address modeled distinct domain variable generated designated uf arguments 
models exception allowed occur exception taken place earlier execution instruction condition alu exception set instruction memory exception raised condition data memory exception set instruction memory alu exception occurred 
processor set exception flag bits see exception status bits modeled representative set 
general processors different types exceptions generated instruction memory alu data memory 
exception types modeled extra uf exception source 
uf take arguments inputs functional unit generate term viewed identifying exception type 
addition generate boolean condition designating exception possibly occurred 
boolean condition control branching behavior program execution term designating exception type transferred processor control logic reaches latch part user visible state 
exception type term positive equations part final equality comparisons correctness criterion identified term 
modeling exception type terms processor designs sect 
resulted insignificant variations resources max 
bdd nodes memory cpu time needed verification run 
modeled return exception instruction semantics defined clear exception status registers jump exception pc 
instruction executed exception handler returning control excepting instruction fixing cause exception 
observe incorporating exceptions processor model extends set user visible state elements latches exception status bits exception pc 
accounted generating formula correctness criterion 
modeling branch prediction order incorporate branch prediction microprocessor need mechanism prediction taken taken outcome target branch jump instruction early pipeline stages mechanism correct misprediction stages actual outcome target known 
implementation mechanisms pipelined dlx shown fig 

order branch predictor implementation processor generator arbitrary values produces new boolean variable direction branches new domain variable target branches jumps clock cycle 
specification processor include branch predictor part user visible state irrelevant defining correct instruction semantics 
note implementation processor verified completely arbitrary predictions direction branch target branch jump processor correct actual implementation branch predictor 
sawada hunt similar approach verifying designs branch prediction 
assume processors execute self modifying code 
allows treat instruction memory read memory unrelated data memory 
equivalently modeled uf 
input flush set true flushing processor 
logic drives enable signal pc latch ensures flushing pc updated instructions partially executed flushing began 

possible way incorporate branch prediction single issue stage pipelined dlx 
logic directly related updating pc omitted 
clock cycle generator arbitrary values fig 
produces new boolean variable output serving prediction taken taken direction newly fetched branch jumps taken architecture new domain variable output uf serving prediction target branch jump 
newly fetched instruction branch predicted taken jump taken processor models immediately predicted taken pc updated predicted target term 
output uf labeled abstracts alu increments pc 
verified implementation updates speculatively pc prediction fetch stage pipeline prediction incorrect determined actual direction ex mem id id ex 
mem mem jump mem branch mem misprediction misprediction pc mem flush squash branch jump 
generator arbitrary values 
translation box mem mem target available execution stage processor mechanism correct misprediction 
actual target branch outcome computed execution stage ex uf respectively implement mechanism correcting mispredictions done memory stage mem fig 

signal misprediction true actual target mem loaded pc 
happen jump instruction predicted target equal actual target signal branch instruction predicted taken mem false taken determined signal mem true signal branch instruction correctly predicted taken mem mem true predicted target equal actual target signal 
signal misprediction true branch incorrectly predicted taken sequential pc relative branch mem loaded pc 
note done mem equal predicted target mem 
check assumed infrequent case order simplify logic signal misprediction 
alternatively assumption actual branch prediction mechanism predict branch taken predicted target equals sequential pc 
misprediction misprediction true subsequent instructions flight squashed control bits determine updating user visible state set false 
shown branch jump control bits fig 

note negated equality comparison actual predicted targets memory stage 
terms appear arguments positive equations final equality comparisons state pc part correctness criterion formula 
terms classified terms 
hand state pc consist domain variable initial state values generated uf terms appear positive equations correctness criterion formula classified terms 
instruction memory addressed terms consist term domain variables 
result dependencies newly fetched instructions ij variables encoding equality comparisons term domain variables 
needless say dependencies affect entire final formula increase complexity evaluation 
alternatively pushing leaves strategy order enforce consistent state 
avoid ij variables distinct term domain variables compared equality 
result term blow especially wider processors 
solution introduce translation box address terms uf translate input terms consisting term term domain variables output terms consisting term domain variables see fig 

output terms uf positive equations part final equality comparisons formula correctness criterion classified terms 
note translation box address inputs implementation specification 
idea translation boxes new 
model data memory order translate terms terms 
case uf serving translation box conservative approximation 
general direct connection processor verified translation boxes correct implementation ufs including identity function simply connecting input output 
translation boxes help better exploit computational efficiency positive equality modeling branch prediction 
optimization modify logic updating pc order prevent terms cancelled appearing expression pc see fig 

observe flushing pc fig 
updated condition misprediction misprediction true 
terms written pc flushing cancelled final formula evaluated 
cancelling happen late evaluation final propositional formula bdds 
unnecessary ij variables introduced simplified away slow bdd computations confuse dynamic variable reordering heuristics 
alternatively try simplifications structure final formula translation propositional formula 

extra gate added logic controls updating pc terms cancelled formula controlling enable signal pc evaluated included expression pc 
note branch prediction scheme fig 
require changes specification optimization trick translation box address terms instruction memory 
analyzing model fig 
tempting try avoid equality comparison actual predicted targets memory stage 
terms classified terms avoid ij variables necessary encode equations final equality comparisons correctness criterion 
equality comparison memory stage 
invalidate formula correctness criterion outputs uncorrelated outcomes actual equations appear correctness formula comparing predicted targets written pc implementation actual targets written pc specification 
solution specification aware branch prediction mechanism prediction executed instruction implementation uf depends pc 
equality comparison actual predicted branch targets specification prediction correct pc updated predicted target actual target 
course elegant solution requires extension pc flush mem misprediction misprediction mem new specification logic invisible synchronization specification implementation terms predictions newly fetched instruction 
interestingly requiring fewer boolean variables scheme worse verification complexity original shown section 
experimental results started base processor models dlx single issue stage pipelined dlx completely functional pipeline execute instruction types register register register immediate load store branch jump nop dlx ca dual issue stage superscalar dlx completely functional pipeline capable executing arithmetic instructions register register register immediate instructions fetched cycle design comparable burch inspired intel pentium processor dlx cc dual issue stage superscalar dlx completely functional pipelines structural hazards load interlocks triggered data dependency source registers decode destination register load instructions execute instructions fetched cycle 
models extended versions implement branch prediction designated bp multicycle functional units marked mc instruction memory alu execution stage data memory modeled having arbitrary latency new instruction types introduced multicycle register register multicycle register immediate instructions alu modeled complete clock cycle start new instructions executed completely functional pipeline dlx ca mc exceptions ex instruction memory alu execution stage data memory generate exceptions additional instruction return exception introduced executed completely functional pipeline dlx ca ex 
created hybrid versions mc ex mc ex bp combine features 
second pipeline dlx ca execute arithmetic instructions vacuous memory stage ex versions processor data memory exceptions generated pipeline 
similarly mc versions processor stalling pipeline stages memory stage due data memory accesses arbitrary latency pipeline 
bp versions dual issue processors branch predictions newly fetched instructions ex versions models new instruction fetches generate instruction memory exception mc versions instruction fetches invalid due unfinished instruction memory access arbitrary latency 
processors modeled style described 
implementation specification processors described hdl supports constructs logic 
hdl similar verilog description implementation processor viewed level hierarchical verilog description processor 
level functional units memories left modules black boxes control logic modules described completely logic gates equality comparators multiplexors constructs 
information provided description identifying module single cycle multicycle functional unit memory modules automatically replaced uf memory place holder multicycle functional unit memory 
implementation processor generated automatically 
instruction memory implementation specification base models defined produce instructions consisting op code term immediate value term source register destination register terms boolean variables 
represented values control bits determine execution flow instructions controlling updating register file data memory respectively branch jump identifying branches jumps condition take computed execution stage taken identifying data read register file location specified second source register second operand alu immediate value term produced instruction memory condition stalling due load interlock stalling resolve data dependency second source register load value done data second source register identifying value read data memory written register file alu result instruction load 
models exceptions instruction memory producing extra boolean variable identifying corresponding instruction 
case models multicycle instructions instruction memory produced boolean variable identifying register register register immediate instructions arbitrary latency 
note valuation boolean variables branch jump applicable false corresponds nop pc incremented rest user visible state unmodified 
base models verified constraints 
instructions produced instruction memory types simultaneously instructions flight 
extensions base models exceptions require constraints 
models branch prediction required constraint branch jump jump branch instructions produced instruction memory flight 
due assumption branch jump instructions distinct designing logic correcting branch jump mispredictions memory stage 
similarly models multicycle instructions required constraint branch jump models multicycle instructions exceptions required constraint branch jump 
imposed newly fetched instructions instructions flight execution stage signal 
incorporating new feature model successful attempt 
analysis counterexamples generated automatic tool described helped identify correct design bug impose constraint initial state 
unsuccessful verification runs needed order impose minimal set constraints sufficient verification 
results table 
experiments performed mhz sun having gb physical memory gb swap space running solaris 
final propositional formulas evaluated colorado university bdd package bdd evaluation heuristic described sifting dynamic bdd variable reordering heuristic 
burch controlled flushing employed designs 
table shows verification times range second single issue case little minutes complex dual issue superscalar designs 
memory requirement ranges mb 
number propositional variables ranges comprising ij variables encoding equality relations term domain variables 
number term domain variables times greater term domain variables 
analyzing results benchmarks base model extended single feature see adding exceptions leads greatest increase complexity 
explained characteristics designs 
user visible state contains extra latches exception pc exception status bits indicating instruction memory alu data memory exception occurred extra equality comparisons added formula correctness criterion 
second require boolean variables part initial state pipeline latches outputs ups indicating certain type exception raised particular instruc processor final vp final vg bdd variables max 
bdd nodes memory mb cpu time src regs dest regs total ij total dlx dlx bp dlx mc dlx ex dlx mc ex dlx mc ex bp dlx ca dlx ca bp dlx ca mc dlx ca ex dlx ca mc ex dlx ca mc ex bp dlx cc dlx cc bp dlx cc mc dlx cc ex dlx cc mc ex dlx cc mc ex bp table 
statistics number domain variables resources needed bdd evaluation final propositional formulas 
memory cpu time reported sequence symbolic simulation translation formula propositional evaluation bdds 
designates set term domain variables set term domain variables 
src regs stands source registers dest regs destination registers 
category final consists predicted actual targets branch jump instructions 
tion flight 
compare category bdd variables table ex models vs corresponding base model mc ex models vs corresponding mc model see number boolean variables increases significantly approaching double original number 
third models exceptions exhibit greatest increase branching behavior program execution 
raised exception results squashing subsequent instructions flight jumping address corresponding exception handler conditional modification user visible state elements 
term blow correctness criterion formula 
modeling multicycle functional units instruction memory alu data memory arbitrary latency explained sect 
results slight increase number term domain variables 
state fsms model non deterministic outcomes completing memory accesses multicycle instructions single cycle regular simulation implementation 
similarly increase number bdd variables attributed boolean variables outputs ups produce non deterministic choice completions 
increase ij bdd variables due fact instructions advance pipeline stage single cycle regular simulation signal indeterminate completion multicycle computation allows 
instructions stay initial positions non deterministic signal opposite value 
forwarding logic compare destination register advanced instruction source register terms instruction lagged detailed analysis selecting formulas show comparisons infeasible 
selecting formulas evaluated formula translated propositional ij bdd variables introduced 
number bdd variables increases number bdd nodes memory consumption go cpu time 
incorporating branch prediction results increase evaluation complexity compared mc ex extensions 
extra term domain variables created relative model extended serving predicted actual targets branch jump instructions 
decreases number term domain variables actual targets longer classified terms 
potentially extra term domain variables compared equality extra term domain variables simplifications take effect equality comparisons final state pc formed part correctness criterion 
explains significant increase number ij boolean variables 
ij variables affect instruction flow final equality comparisons effect relatively limited bdd evaluation heuristic combined sifting worked 
net result relatively small increase number bdd nodes memory compared extensions model multicycle instructions exceptions 
fact see adding branch prediction dlx cc mc ex order construct dlx cc mc ex bp resulted propositional formula depended bdd variables required fewer bdd nodes memory cpu time evaluate 
experiments models branch prediction done optimizations translation box address terms instruction memory modified pc updating logic flushing see sect 

dlx cc mc ex requires fewer bdd variables dlx cc mc verification takes cpu time variations performance sifting heuristic different boolean formulas 
benchmark formally verified sifting heuristic experiments run memory hours cpu time 
table studies value optimizations verify processor models branch prediction 
pushing leaves strategy eliminating reads initial state memories addressed terms order prevent ij variables equality comparisons actual predicted branch address targets affecting fetched instructions reads instruction memory 
anticipated sect 
resulted term blow see pushing leaves row table 
nested approach eliminating reads initial state memories addressed terms reduced memory consumption cpu time nested row table 
employing translation box address terms instruction memory pushing leaves strategy eliminate reads initial state memories addressed terms memory register file reduced cpu time third left number bdd nodes memory consumption somewhat increased transl 
box 
extending optimizations experiment modified pc updating logic flushing see sect 
resulted considerable improvement bdd nodes mb memory minutes cpu time transl 
box mod 
pc 
equality comparisons actual predicted branch jump targets implementation specification resulted fewer bdd variables abstracted comparison 
structure final propositional formula changed way harder evaluate bdds sifting dynamic variable reordering heuristic memory doubled cpu time relative best result translation box modified pc 
ackermann constraints eliminating applications consistently produced worse results nested scheme eliminating ups 
example verification complex design dlx cc mc ex bp required bdd nodes mb memory seconds times bdd nodes times memory times cpu time 
previously burch dill flushing technique formal verification microprocessors applied automatically designs functional units memories produce experiment final vp final vg bdd variables max bdd nodes memory mb cpu time src regs dest regs total ij total pushing leaves nested transl 
box transl 
box mod 
pc abstracted comparison table 
statistics experiments improved verification complex design dlx cc mc ex bp branch prediction incorporated 
results instantaneously 
extended technique applicable automatic manner processors functional units memories multicycle possibly indeterminate latency 
shown ways model exceptions addition branch prediction feature incorporated verified efficiently aggressive designs properties positive equality considered carefully 
instrumental success efficient procedure translating formula logic equality uninterpreted functions memories propositional formula exploiting positive equality applying conservative approximations 
able verify dual issue superscalar dlx processor completely functional pipelines instruction memory functional units execution stage data memory arbitrary latency possibly generate exception branch prediction newly fetched instructions minutes cpu time 
believe success approach extremely efficient verification pipelined dlx multicycle functional units memories exceptions branch prediction requiring seconds cpu time mb memory bdd nodes enable verification real pipelined microprocessors features arm core motorola core 
fact best knowledge designs publicly announced branch prediction 
microprocessors widely embedded applications cellular phones automotive control 
applied techniques abstraction multicycle functional units branch predictors formal verification vliw processor imitates intel itanium features predicated execution speculative register remapping advanced loads 
studied different schemes enforcing constraints transitivity equality 
explore ways improve variable ordering heuristics speed verification effective procedures boolean satisfiability 
automate translation high level hdl processor models gate level synthesizable verilog 
ackermann solvable cases decision problem north holland amsterdam 
arm technical manuals data sheets url www arm com 
clarke biere zhu verification order processor designs model checking light weight completion function appear journal formal methods system design 
bryant symbolic boolean manipulation ordered binary decision diagrams acm computing surveys vol :10.1.1.119.326
september pp 

bryant german exploiting positive equality logic equality uninterpreted functions computer aided verification cav halbwachs peled eds lncs springer verlag july pp 

bryant german processor verification efficient reductions logic uninterpreted functions propositional logic technical report cmu cs carnegie mellon university 
bryant boolean satisfiability transitivity constraints com 
available www ece cmu edu puter aided verification cav emerson sistla eds lncs springer verlag july pp 

bryant boolean satisfiability transitivity constraints technical report cmu cs carnegie mellon university 
burch dill automated verification pipelined microprocessor control computer aided verification cav dill ed lncs springer verlag june pp 

burch techniques verifying superscalar microprocessors rd design automation conference dac june pp 

clarke jr grumberg peled model checking mit press cambridge ma 
url vlsi colorado edu fabio 
goel zhou aziz singhal bdd procedures theory equality uninterpreted functions computer aided verification cav hu vardi eds lncs springer verlag june pp 

hennessy patterson computer architecture quantitative approach nd edition morgan kaufmann publishers san francisco ca 
srivas gopalakrishnan decomposing proof correctness pipelined microprocessors computer aided verification cav hu vardi eds lncs springer verlag june pp 

srivas gopalakrishnan proof correctness processor reorder buffer completion functions approach computer aided verification cav halbwachs peled eds lncs springer verlag july pp 

personal communication september 
gopalakrishnan srivas verifying advanced microarchitectures support speculation exceptions computer aided verification cav emerson sistla eds lncs springer verlag july pp 

systematic verification pipelined microprocessors ph thesis department computer science university utah august 
hunt jr fm verified microprocessor lnai springer verlag 
jones dill 
reducing manual abstraction formal verification order execution formal methods computer aided design fmcad gopalakrishnan eds lncs springer verlag november pp 

jones dill :10.1.1.10.7924
formal verification order execution incremental flushing appear journal formal methods system design 
core engine programmer manual 
pnueli rodeh siegel deciding equality formulas instantiations computer aided verification cav halbwachs peled eds lncs springer verlag july pp 

dynamic variable ordering ordered binary decision diagrams interna 
available sprout stanford edu 
available www cs utah edu 
available www motorola com sps tional conference computer aided design iccad november pp 

sawada hunt jr processor verification precise exceptions speculative execution computer aided verification cav hu vardi eds lncs springer verlag june pp 

sawada hunt jr verification fm order processor speculative execution exceptions may execute self modifying code appear journal formal methods system design 
sawada formal verification advanced pipelined machine ph thesis department computer science university texas austin december 
sawada hunt jr hardware modeling function encapsulation formal methods computer aided design fmcad hunt jr johnson eds lncs springer verlag november pp 

stanford validity checker svc thomas verilog hardware description language th edition kluwer academic publishers boston dordrecht london 
bryant incorporating timing constraints efficient memory model symbolic ternary simulation international conference computer design iccd october pp 

bryant bit level abstraction verification pipelined microprocessors correspondence checking formal methods computer aided design fmcad gopalakrishnan eds lncs springer verlag november pp 

bryant superscalar processor verification efficient reductions logic equality uninterpreted functions propositional logic correct hardware design verification methods pierre eds lncs springer verlag september pp 

bryant formal verification superscalar microprocessors multicycle functional units exceptions branch prediction th design automation conference dac june pp 

formal verification vliw microprocessors speculative execution computer aided verification cav emerson sistla eds lncs springer verlag july pp 

williams biere clarke gupta combining decision diagrams sat procedures efficient symbolic model checking computer aided verification cav emerson sistla eds lncs springer verlag july pp 

williams formal verification boolean expression diagrams ph thesis department information technology technical university denmark lyngby denmark august 
burch mechanically checking lemma automatic verification tool formal methods computer aided design fmcad srivas eds lncs springer verlag november pp 


available www cs utexas edu users sawada 
available www dk research bed 
