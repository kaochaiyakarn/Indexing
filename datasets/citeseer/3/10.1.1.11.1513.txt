shi ding lin microsoft research asia microsoft com practical distributed mutual exclusion protocol dynamic peer peer systems qiao tsinghua university lq mails tsinghua edu cn mutual exclusion studied fundamental primitives distributed systems 
emerging systems bring forward challenges completely solved previous approaches 
propose sigma protocol implemented inside dynamic dht circumvents issues 
basic idea adopt queuing cooperation clients replicas enforce quorum consensus scheme 
demonstrate protocol scalable system size robust contention resilient network latency variance fault tolerant 
fundamental primitives implement generic systems applications top dhts mutual exclusion 
primitive rudimentary service guard arbitrary resources necessary 
example concurrency control mechanism obviously needed mutable distributed file system 
applications systems envision built deployed dhts rule possibility enforcing concurrency stable transaction servers external internal system 
primitives implemented inside dht 
protocol definition distributed simple efficient robust practical 
basic idea simple utilizing fact nodes dht collectively form logical space holes institute set logical replicas quorum consensus protocol access critical section cs 
client perspective replicas online 
may suffer complete memory loss time time 
random reset occurs node acts logical replica crashes gets replaced logical neighbor dht 
open dynamic nature environment brings serious challenge 
previous approaches assume close system fixed relatively moderate number nodes nodes communicate reach consensus 
solutions inapplicable context number clients unpredictable swing large 
protocols need designed harsh open environment wide area 
presents novel contributions start investigating straightforward aloha strawman protocol show high variation network latency ming chen tsinghua university cm mails tsinghua edu cn zheng zhang microsoft research asia microsoft com clients replicas responsible large performance degradation 
believe insight valuable wide area consensus protocols 
demonstrate cooperative strategy clients replicas necessary circumvent latency variance contention achieving scalability robustness 
propose informed backoff mechanism intelligently rebuilds replica state handle random reset problem replicas 
resulting protocol sigma fully implemented analyzed evaluated 
analytical experimental results demonstrate performance efficacy 
discuss system model section ii 
strawman protocol performance evaluation section iii 
building describe sigma protocol section iv experiment results section related section vi conclude section vii 
ii 
system model essence dht offers virtual space populated participating peers 
space holes transient period time membership change 

majority consensus dht bucket unit dht synonym zone denotes logical replica 
diagram illustrates node crash modeled logical replica reset 
resource associated server cs logical 
instance replicas names foo bar see 
hash names derive keys hosting node key serve replica 
decoupling naming actual server means working peculiar server available may suffer memory loss random point time 
shall see multiple replicas implies latencies client replicas highly variable exerting significant impact performance 
formally speaking system model follows replicas available internal states may randomly reset 
termed failure recovery model 
number clients unpredictable large 
clients malicious fail 
clients replicas communicate messages unreliable channels 
messages replicated lost forged 
context clients replicas peers dht practice replicas dht members 
replica permission vote client called owner 
client collected majority permissions said winner round 
assume typical lifetime dht node long client talk directly current node acts logical replica invoking logn dht lookup logical replica takes reset 
primary goal derive set efficient highly reliable protocols 
want protocol perform robust possible low high contention situation 
correct rapidly faults occur 
iii 
strawman protocol section introduce strawman protocol straightforward implement illustrates essential attributes problems highly available majority consensus protocol 
main idea similar aloha protocol way resolving conflicting packets clients want enter critical section cs send requests replicas wait responses 
replica lease owned rejects request informs client current owner 
obtains replicas winner round 
losers release acquired votes back retry random period 
guarantees deadlock occur 
replicas suffer random reset forgets previous decision open new request 
change heart cause mutual exclusion broken 
assume average life node probability node may crash period probability voted replicas resets safety broken equal resets occur probability turns round tolerate replica reset needed 
design choice raise value shows probability violating exclusivity seconds reported average life node chosen seconds gives conservative upper bound clients staying cs 
show results different parameters observed accomplishing robust mutual exclusion protocol realistic 
practical setting chance breaking exclusivity configuration guard document availability requirement nines entirely reasonable 
broader point want little practical sense guarantee conflict probability substantially lower availability resource protected 
broken probability ratio 
probability break exclusivity 
performance protocol entirely different story 
depicts throughput various network conditions respectively 
average network latency client replicas fixed ms latency client replica pair random variable 
reasonable assumption wide area dht 
success rate ms ms ms incoming request rate 
performance strawman protocol latency uniformly distributed 
thing notice curve looks just aloha see throughput increases linearly contention low reaches peak degrades essentially zero 
clear latency variance significant impact higher variance worse throughput 
iv 
sigma protocol main culprit strawman protocol poor performance variance network latency client replica 
client requests reach different replicas different time hard replicas build consistent view competing clients 
second subtle issue greedy behavior clients keep retrying collision occurs win 
comprehensive set techniques address problems 
deal problem installing queue replicas consistent view case high contention 
combat second issue adopt strategy enforce clients state active waiting 
pseudo code described terms message handler clients replicas respectively 
sides exchange messages relevant entities interactions depicted 
client request release messages replica queue operations 
architecture sigma protocol 
insert front remove contains empty client states include id array resp 
resp records response th replica stating owner associated timestamp 
replica maintains owns replica value nil indicates replica voted towner stores timestamp request queue stores waiting clients order timestamp 
lamport logical clock generate timestamp 
client starts firing request messages replicas request 
requests handled replica vote outright queue request depending replica voted 
regardless id timestamp current owner replica equals client queue empty returned client response message 
responses arrive client gradually forms idea place race 
suppose replicas needed achieve quorum consensus outcomes easily distinguished examining owner attached response messages 
client winner quorum consensus 
succeeds gets permission enter cs 

win client 
client knows registered replicas 
detail notified 

won case number returned responses maximal number item 
client sends yield message acquired replicas 
state variables id identity client resp responses replica request cs timestamp lamport clock cs id timestamp owner timestamp resp owner owner resp timestamp timestamp responses received winner winner self case return success winner nil case resp owner self id clear resp reset state case wins just wait release cs cs id 
client side pseudo code 
state variables client accepts towner time stamp queue queue requests timestamp nil towner timestamp queue insert timestamp towner nil queue empty queue contains queue remove queue insert towner towner helper routine towner queue front towner queue remove 
replica side pseudo code 
yield operation reflects collaborative nature sigma protocol critical performance optimization 
semantic yield release request 
replica receives yield message removes client winning seat inserts queue chooses earliest notifies winner 
function yield handling queue 
fact wins indicates contention occurred 
turn implies queues built winners place 
issuing yield request clients collectively offering replicas chance build consistent view consequently choose right winner 
important understand go winner settled take multiple rounds yield 
typically process quickly settle verified experiments 
release operation straightforward client owner simply relinquishes removed queue 
case client notified response message 
far described sigma failure free environment 
reality things may go wrong crash replica vote new client despite fact done previous 
deal raising ratio reduce probability breaking safety 
appropriate parameter risk negligible practice section iii 
seriously queue gone waiting clients get stuck forever 
called way rebuild replica memory 
addressed informed backoff mechanism discussed 
client currently cs crashes exit replicas stuck 
replica permission clients renewable lease 
lease expires replica permission client queue 
unreliable communication channel client replica cause similar problems 
essence message loss mapped arbitrary crash clients replicas simplifies handling 
combination informed backoff lease builds reliable communication unreliable channel variation failure detector plus timeout 
best effort approach leverages replica knowledge achieve better tradeoff communication cost system throughput 
informed backoff way rebuild restarted replica state overloading healthy replicas 
extremely simple core 
request replica predict expected waiting time tw advise wait long retry 
empirical calculation tw tw tcs client position queue tcs average cs duration observed replica interval consecutive release operations 
formula take current owner replica consideration 
notice tw updated reception retry 
consider case replica crashed 
client notified scheduled retry harm done 
means advised tw accurate earlier clients take extra time 
case client renew tw retry 
course overhead far point permission granted hopefully retry client endure 
hand replica go reset queue reconstructed order similar original fulfilling goal 
offer brief analysis sigma protocol service policy 
logical clock come serve policy replica guarantee fcfs client requests take arbitrarily long arrive 
sigma best described quasi fcfs 
safety 
guarantee safety high probability 
known protocols ensure correctness failure 
treat replica failure imprecise failure detector uniform manner 
shown section iii probability violating safety practically negligible setting appropriate liveness 
progress ensured lease 
experimental results sigma protocol fully implemented deployed distributed testbed configured different network topology models 
assume pool infinity clients client fire request contending cs poisson distribution incoming request rate 
focus performance aspects protocol client exit cs immediately enters 
minutes warm period test minutes throughput terms number serviced requests second measured 
repeated different incoming request rate 
throughput ms ms ms ms strawman ms strawman ms strawman saturated service rate incoming request rate 
throughput versus latency variance contention latency uniformly distributed average latency ms 
dashed lines correspond theoretical predictions saturated throughput differ latency distribution 
data strawman sigma shown 

depicts throughput different incoming request varying latency distribution 
see network latency distribution little impact throughput increases linearly request rate ramps point reaches saturated rate stays flat predicted theoretical model see 
ideal behavior 
comparison purposes throughput strawman protocol plotted 
see performance improvement significant 
replicas suffer crash undergo memory reset performance drop 
causes contributing performance degradation difficult obtain succinct reasoning 
way reset net effect enlarging latency variance request result successful response reaches restarted replica queued 
throughput replica life replica life replica life replica life saturated service rate incoming request rate 
throughput versus replica availability latency uniformly distributed ms 
dashed line corresponds theoretical prediction saturated throughput 
replica life seconds theoretical throughput achieved 
set average lifetime replica excessively short 
lifetime exponentially distributed different average values tested 
presents results 
penalty throughput perceptible replica life seconds significant longer replica life 
environment nodes typically online seconds believe ideal throughput sigma achieved practice 
analyzed measured message cost show asymptotically bound 
due space limitation refer readers full technical report 
vi 
related taxonomy sigma protocol fall permission category 
protocols assume closed system clients replicas 
context mandates open system number clients unpredictable 
relevant includes byzantine protocols operates setting 
obviously sigma idea virtual replicas immediately applicable protocols tailor fit environment 
objectives differ 
sigma light weight synchronization protocol message costs attempt deal malicious client 
byzantine protocols takes replicated state machine approach cost handles malicious client 
interesting note total replica faults exceed protocols yield unpredictable results 
sigma emphasis practicality side pays attention performance 
space similar strawman protocol augmented exponential backoff 
clear property hold face latency variance believe prevailing pattern environment 
vii 
emerging scenario brings forward challenges mutually exclusive access resource stored huge variance network latency unpredictable large number clients high dynamism 
issues partially addressed previous works completely solved 
propose sigma practical efficient fault tolerant protocol distributed mutual exclusion inside dht 
key points sigma protocol logical replicas quorum consensus deal system 
quasi consistency cooperation clients replicas circumvent large variance network latency high contention 
sigma gracefully deals failure techniques informed backoff lease making protocol faulttolerant 
verified protocol offers high performance heterogeneous network condition various contention rates 
practical environment failure handling mechanism works negligible performance penalty moderate communication overhead 
detailed technical report include extensive empirical analytical report 
correctness sigma protocol formally proved extend applicability dynamic distributed system general just 
concept logical replica extended 
quorum members form dht client request broadcasted member vote share space zone 
consensus reached client gathered total fraction total space 
protocol interesting investing mechanisms handle membership change designed cope non constant number members start 
furthermore brings level robustness protocol correct long space owned nodes larger owned compromised malicious nodes threshold 
simple defense mechanism possible continuously institute new members combat spread compromised nodes 
protocol described terms strawman protocol sigma easily adopted highly optimized implementation 
anonymous reviewers valuable feedbacks 
benefited enlightening discussions colleagues msr labs including zhou butler lampson leslie lamport 
pawlowski nfs version protocol proceedings nd international system administration networking conference sane liben nowell balakrishnan karger analysis evolution peer peer systems st acm symposium principles distributed computing podc monterey ca july 
malkhi reiter backoff protocols distributed mutual exclusion ordering proceedings st international conference distributed computing systems icdcs 
stoica chord scalable peer peer lookup service internet applications proceedings acm sigcomm san ca august 
yin separating agreement execution byzantine fault tolerant services proceedings th acm symposium operating systems principles 
lamport shostak pease byzantine generals problem acm transactions programming languages systems july lamport time clocks ordering events distributed system communications acm july 
aguilera chen toueg failure detection consensus crash recovery model 
distributed computing springer verlag april pp 

castro liskov practical byzantine fault tolerance 
proceedings third symposium operating systems design implementation new orleans february 
survey distributed mutual exclusion algorithms colorado state university technical report cs 
abramson aloha system alternative computer communications 
afips conference proceedings vol 
pp 

saroiu krishna gummadi gribble measurement study peer peer file sharing systems proceedings multimedia computing networking mmcn 
ratnasamy francis handley karp shenker scalable content addressable network proceedings acm sigcomm 
lin chen zhang practical distributed mutual exclusion protocol dynamic peer peer systems microsoft research technical report msr tr 
chandra toueg unreliable failure detectors reliable distributed systems 
journal acm 
zhang power dht logical space 
appear computing chen lin zhang 
sigma fast fault tolerant mutual exclusion algorithm dynamic distributed system 
submission preparation 
