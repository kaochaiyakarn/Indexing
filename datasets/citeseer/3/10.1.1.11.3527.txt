explaining polymorphic types yang jun greg michaelson phil trinder department computing electrical engineering heriot watt university eh uk greg hw ac uk polymorphic types programming languages facilitate code reuse increase reliability reduce semantic errors programs 
hindley milner type inference forms strong basis checking polymorphic types suited explaining introduces intermediate constructs relate poorly programmer understanding program 
report experiment expert human type explanation uncover simple set rules human explanations 
type explanation system rules hindley milner inference 
system uses new inference algorithm annotate types explanations designed produce succinct non repetitive explanations minimal artefacts mechanised type inference 
type systems fundamental programming languages constraining combinations constructs ensure formedness programs reduce runtime errors 
despite considerable research type systems widely languages provide relatively impoverished sets types direct abstraction explicit low level von neumann computers 
modern imperative languages typically offer integers floating point numbers characters booleans corresponding fixed size bit patterns arrays records corresponding fixed size bit pattern sequences pointers corresponding machine addresses bit patterns 
elaborate types discriminated unions objects single inheritance usually syntactic sugar top basic type repertoire 
typical imperative language monomorphic type system construct retains concrete type lifetime 
particular variable assigned type may associated values type 
strong monomorphic type systems enable simple static checks programs type consistency unduly restrict programming flexibility 
contrast polymorphic type systems construct may take different types different contexts 
strachey distinguished ad hoc parameterised polymorphism 
weakly typed languages lisp prolog adhoc polymorphism allow variables associated arbitrary typed values statically enforced constraints 
enables considerable flexibility programming static checks programs type consistency may longer possible 
run time type checking avoid invalid construct combinations time consuming brings attendant space overheads explicit type tagging values 
parameterised polymorphism contrast constructs strongly typed types may include abstraction points 
enables definition generalised constructs generic types resolved concrete instance construct created 
abstraction points indicated type variables may uniformly replaced types parameterised polymorphism 
example generic list type empty list nil constructor cons may defined sml datatype list nil cons list introduces new type list 
type variable may instantiated type specific type deduced context cons applied 
cons cons cons nil int list ints 
similarly cons cons cons nil string list strings 
important contribution programming language design milner hindley development order parameterised polymorphic type inference 
enables static type checking compile time minimising need run time type representations checking 
hindley milner type systems commonly incorporated functional languages example standard ml sml miranda hope haskell 
considerable anecdotal evidence polymorphic type checking greatly reduces semantic errors programs 
certainly polymorphic types central succinctness contemporary functional languages enabling considerable degree type safe abstraction component re 
parameterised polymorphism provided languages paradigms 
exceptions rule including addition generics object oriented languages java napier imperative persistent database language prolog strongly typed prolog variant theorem proving 
suspect apparent resistance including polymorphic type systems contemporary languages lies combination aura complexity mathematical sophistication surrounding systems 
particular claim fundamental mismatch polymorphic type inference algorithms deduce types people reason types particularly apparent reporting polymorphic type errors 
expression variable exp identifier lambda abstraction application binding exp syntax 
investigated human inference polymorphic types aid construction type explanation system mimics human behaviour 
section discuss hindley milner type inference parameterised polymorphism limitations providing type explanations people 
section report experiment human experts explain types distill simple set rules human type explanation 
key rules focus concrete types dimensional analysis function definition patterns 
section human type explanation system rules 
system uses new type inference algorithm termed algorithm annotate types information inferred 
type inference history recorded graph expression syntax tree graph traversed generate succinct non repetitive explanations 
section discuss related draw research section 
hindley milner type inference hindley milner type scheme introduce simple functional language exp form basis presentation type inference 
illustrate inference simple exp function doubles argument note introduce constant identifiers integer multiply integers return integer type represented type expression shows exp type base type type variable function type 
base types integer boolean 
type variable ff represents type 
type function mapping argument type result type 
type scheme represents abstracted polymorphic type type variable may replaced type expression 
simple language constant identifiers types int int int int type int bool integer bool ff type variable function type oe ff delta delta delta ff type scheme te fin type environment types type schemes type environments 
read integer multiplies integers return integer 
note treat binary operators curried functions simplify presentation 
hindley milner polymorphic type inference may expressed set rewrite rules take general form premise infer establish premise 
inference driven assumption type environments te set identifier type associations shown 
premises take general form te prior assumptions te may infer expression type rules inferring polymorphic types expressions exp cardelli 
ar assumptions te include association identifier type scheme oe may infer type oe may look identifier set assumptions find associated type 
abs assumptions te augmented association identifier type show expression type function type takes argument type returns result type app type type applying returns value type polymorphic type scheme oe te augmented association identifier oe show expression type type gen spec rules required generalise specialise polymorphic types 
consider applying scheme 
assume initial assumption environment te contains types constant identifiers appropriate type function parameter te int int 
int 
int int var variables te phi fx oeg oe abs abstraction te phi fx te app application te te te binding te oe te phi fx oeg te gen generalisation te oe ff free te te ff oe spec specialisation te ff oe te ff oe hindley milner inference rules exp assume parsed function built syntax tree ast 
leaves ast back root applying rules type scheme 
te int var 
te int 
int 
int var 
te int 
int app 
te int var 
te int app 
te fn 
int 
int abs int int 
int 
int int 
int 
int int 
fn 
int 
int 
key hidden step initial assumption int 
type inference algorithms steps performed automatically assigning new type variables bound variables unifying type expressions types find substitutions type variables 
shall see process renders automatic type inference unsuitable type explanation 
algorithm milner algorithm remains classic basis implementations polymorphic type inference 
expression initial assumption set te algorithm theta exp substitution theta type te ff delta delta delta ff te ffi ff fi new te te phi fx fig fi te te te fi fi new fi te te te phi fx ff delta delta delta ff ff free ff te type inference algorithm exp te attempts find type incidentally producing set substitutions substitution form fnew applied type expressions replace occurrences old new 
new bindings added phi removed psi 
substitutions may composed rst indicating applied order right left apply apply apply field harrison defines algorithm syntax exp omitting cases inference may fail writing fi new type variables 
write identity substitution effect type expressions 
identifier type inferred assumption environment 
universally quantified type variables replaced new unquantified variables indicating generic types instantiated specific unknown types 
substitutions performed 
note stage introduces new type delta delta delta fi function type inferred steps 
substitutions type function body environment augmented binding function parameter new type variable fi 
function type fi applying substitutions finding body type parameter type 
note stage introduces new type variable fi may find instantiations type variables 
type function application inferred steps 
function expression analysed return type associated substitutions 
argument expression analysed substitutions applied assumption environment return type substitutions 
function result type fi function type type function fi unified find consistent substitutions 
result composition substitutions application third substitution fi 
type definition inferred steps 
defining expression analysed return type associated substitutions 
modified assumption environment updated association defined variable universally quantified form type 
analysis result expression produces substitution type composition substitutions result expression type returned 
illustrate algorithm inferring type assumption environment bindings constants te int int 
int 
intg showing major steps inference 
te 
te phi fx ffg 
te phi fx ffg 
te phi fx ffg fg int 
int 
int 
te phi fx ffg fg ff 
unify int 
int 
int ff 
fi fint ff int 
int fig 
fint ff int int fig int 
int 
te phi fx intg fg int 
unify int 
int int 
fl fint flg 
fint ff int int fi int flg int 
fint ff int 
int fi int flg int 
int step assumed bound variable unknown definite type ff 
step type int 
int 
int unified type ff 
fi represents type function take type argument determine ff int step type prior unification type substitution int ff applied assumption environment type int 
strict left right bottom resolution type variables place holders unknowns deduced applied chains substitution causes difficulty algorithms explain types 
human expert type explanations course teaching functional programming undergraduate postgraduate level observed students number conceptual difficulties polymorphic typing 
rooted prior familiarity fi int 
int monomorphic type schemes imperative languages 
particular students appear understand rules governing type variables surprised inferred type general specific intended 
difficulty arises scope type variables type expressions 
curried function definition nested instance bound expression variable denotes new variable new scope extent 
contrast type expression occurrences identifier denote type variable 
example consider fun val fn 

int 
int function looks formal parameters called fact shorthand val fn 
fn 
fn 
curried function unknown body function unknown body function integer added 
applied arguments discarded incremented value third returned 
consider fun join val join fn 


list curried parameters joined form list 
unknown type 
accounts implementations polymorphic type inference conflate quantified unquantified type variables symbols omitting quantifiers 
students find hard distinguish generic specific unknown type variables 
difficulties conspire complicate interpretation type information type inference especially error messages 
decided investigate experts explain types try identify guidelines automatic explanations readily understandable especially novices 
conducted experiment identify human strategies explaining types 
characterising human type explanations comparison algorithm experience people appear far rigid rigorous checking types 
partial assuming construct type minimum necessary evidence 
opportunistic scanning program text sources evidence 
seek concrete evidence constant types introducing type variables 
consider sml function count number integer list fun count count count count count algorithm extended deal patterns explore case left right working cases introducing type variables count contrast caricature typical human check example ffl int int list argument int list ffl int result int 
may note caricature human check concludes case int list 
int case 
int second case int list 
scans columns patterns case 
focuses constant types values 
hypothesised human type checkers strategies 
ffl focus ground known types 
ffl vertical relationships patterns cases resolving assigning types term text inspection 
ffl introduce type variables resort 
ffl partially check functions 
examples partial checking include locating just error expression multiple type errors deducing type information single value result count int pattern 
shall see caricature appears wholly accurate 
carried experiments experts video taped type checking sets sml functions speak aloud protocol 
unable locate standard sets type checking problems evaluating automated type checkers people 
questions experiments drawn type checking problems set st year functional programming students augmented additional questions 
question consists untyped function definition subject required identify type explain type error 
questions formed pure functional subset sml comprising base types lists tuples 
sets questions chosen reflect range function types may contain multiple errors 
subjects took part type correct experiment type error experiment 
people took part experiments 
subjects post graduate computer science experience programmed extensively polymorphic typed languages 
furthermore implemented hindley milner type checkers worked extensively technique class techniques type skeleton construct type skeleton function construct refine type skeleton local construct refine function type skeleton concrete types locate specific types locate overloaded operators locate known system operators inspection locate commonalities patterns analyse top nodes leaves syntax tree analyse bottom leaves nodes syntax tree identify argument type function body identify body construct type known argument type search forwards backwards known type type variable introduce type variable major human type inference techniques 
implementing functional languages 
undergraduate postgraduate students functional programming 
small cohort may considered experts 
subjects minutes complete set questions 
initial inspection video taped sessions led identification major inference techniques type checking shown 
simplify analysis grouped techniques major classes 
elaborating type skeleton subjects typically drew gross structure type signature identifying tuple function types omitting fine detail 
systematically sought fill fine detail techniques 
identifying concrete types subjects looked constants known type overloaded operators known system operators important sites evidence 
inspection subjects scanned program text various orders reflecting type relationships required program constructs 
subjects introduced type variables place holders refinement tokens transmission 
subject attempt question analysed sequences techniques recorded 
small number subjects form basis statistical analysis 
able identify number clear trends combining technique counts subjects 
results subjects attempted error free questions technique instances error questions technique instances 
technique class error free error type skeleton concrete types inspection type variable technique questions errors 
shows technique percentage questions errors major technique 
questions errors considerable type signature skeletons anticipate 
hypothesised concrete type information 
similarly inspection function text confirming hypothesis 
low type variables hypothesised 
questions errors type signature skeletons error free problems 
concrete type information 
inspection text similar error free questions 
type variable technique far error free questions 
contrary expectations questions errors full checking carried questions partial checking 
questions errors full checking error free questions full checking carried questions partial checking questions detailed discussion experiment analysis results may 
discussion observed number differences human type checking characterised expert subject group algorithm 
people find elaboration skeletal type checking extremely helpful structuring process 
furthermore hypothesised people rely identification constructs known type guide checking textual form locate 
hypothesised people explicit type variables resort 
prediction people performing partial checking confounded 
comparable research specifically human type checking 
interesting correspondences program comprehension 
particular observed type skeletons guide type checking may instance brooks top hypothesis driven comprehension 
similarly observed concrete type features similar wiedenbeck scholz identification surface beacons guide successful program comprehension 
wiedenbeck scholz note beacon particularly helpful comprehension programs unknown purpose questions provide minimal semantic information meaningful identifiers 
human type explanation system developing prototype human type explanation system strongly informed experiments discussed 
objectives ffl provide succinct explanations ffl base explanations concrete type information far possible ffl examination functions patterns results cases pattern result individual case ffl minimise repetition explanations 
differ human inference techniques discussed previous section giving exhaustive explanations function explicitly skeleton explanation 
resulting explanations discussed different derived directly algorithm equivalents feel similar observed human type inference 
algorithm clearly computationally expensive algorithm argue improved quality explanations justifies additional computation 
type explanation system stages 
firstly introduce new type inference algorithm annotates types information inferred 
secondly illustrate algorithm construct annotated type graph syntax tree recording history inference node 
thirdly discuss annotated syntax tree traversed generate explanation rules ensure succinct non repetitive explanations 
algorithm human subjects techniques explain types illustrated language simple exp section 
example experts analysed dimensional structure patterns properties overloaded operators 
gives syntax sophisticated language exp explanation system 
new language subset sml including patterns tuples lists conditionals local definitions recursive functions base types int real bool string corresponding operators 
operators may overloaded may applied int real 
syntax unusual making pattern matching function definitions explicit 
exp val identifier constant int real string bool int real string boolean constants exp constant primitive operation identifier application condition local definition val definition tuple list empty list fn fmg lambda abstraction fun pattern function patt identifier constant tuple empty list list match match fx fpg pattern function definition exp syntax richer set types exp 
support overloaded numeric types distinguish numeric ordinary type variables likewise support quantified types distinguish quantified ordinary type variables 
type schemes type environments substitutions unchanged exp annotated types central explanation system form graph type component may contain annotated types 
total annotation rules corresponding distinctive sites type inference 
complete list rules 
reproduce include annotations examples 
exp expression types explained parsed syntax tree ast constructed 
ast typed human algorithm unification assumption environment algorithm uae 
uae closely related algorithm motivated informal suggestion johan 
essentially uae types program variable produce assumption type environment 
type environments unified ensure consistency 
algorithm types inferred left right expressions 
conflicts parts expressions related back earlier parts 
uae program variable fl quantified type variables ffi type variables number ff fi tyvar ordinary type variables int real ffi numeric types type string bool string boolean ff num ord type var 
function type list list type tuple type annotate annotated type string bool ff fl list rulename app function application cons list concatenation function left hand side fnr function right hand side op op primitive operator op op prim 
op 
left hand side op prim 
op 
right hand side val val definition val val left hand side val val right hand side exp types 
typed unified left right bias algorithm avoided 
full details appear 
interactive type exploration environment algorithm similar uae developed independently huch simon 
algorithm generates types containing annotations justifying type inferred 
figures define algorithm exp omitting cases inference may fail writing fi fresh ordinary type variables ffi fresh numeric type variables 
unification occurs sets type constraints denoted 
constraint set set type equalities denoted oe oe ancillary functions algorithm appendix brevity definitions val tuples conditionals omitted comprehensive description algorithm 
definition val similar tuples similar list construction conditionals similar pattern definition 
explanation definitions algorithm follows 
explanation definition pattern matching function definitions deferred discussed example section 
type empty list fi list annotated 
type constant determined function annotated 
type numeric operator ffi theta ffi ffi annotated explain relationship arguments result 
type identifier type environment te retrieve annotated type instantiate assume type fi type environment annotate type typeof record assumption 
type application inferred typing function argument annotating argument indicate argument function 
new type variable fi introduced result function annotated 
types inferred function argument unified constraint function type unify argument assumed result type reason fi reason 
type local definition inferred typing subexpressions unifying type environments 
body annotated indicate body local definition 
type list constructor inferred typing expressions annotating hd second tl selecting simplest explanation result type unifying constraints expressions 
type abstraction inferred typing pattern body annotating pattern body unifying environments 
annotating syntax tree algorithm generate annotated type node syntax tree 
annotation indicates rule form piece ast corresponds type environments te contributed original type inference 
type environments turn contain annotated types type environments 
cyclic graph type environments records type inference history subsequently generate explanations 
program variable reached ast traversal augmented type environment associating new type variable annotated program variable 
value known type reached type noted annotated value 
branches syntax construct visited corresponding node type application hindley milner rules unify child nodes types 
node final type environment formed combining unifying child nodes type environments 
theta exp type theta te annotate fi list te te annotate te te annotate ffi theta ffi ffi te te dom te ff delta delta delta ff te ffi ff te annotate fi typeof fx fig phi te te te te te te reason annotate fi reason annotate fi reason fi reason phi te te fi reason te phi te te te te te new te phi fx close te te te new reason annotate te te psi reason te phi te psi te te te reason annotate hd te te reason annotate tl reason list reason list phi te te te phi te algorithm see appendix te fn te te te reason annotate te te reason annotate te te reason reason fn te te fund see section tes uae column column tes env env tes fun fte ij ji zg env column fun te exp psi algorithm see appendix val fn twice ast val twice fn 
operator known type reached operator specific rule applied unify operand types type environments 
consider example val twice fn 
ast shown 
ast descended build equivalent type tree lists ast node rule applies initial type variable known type corresponding sub tree 
shows form annotated nodes 
rule indicates uae rule invoked 
type indicates node type 
ast node textual representation node ast type tree node derived 
type environment node type environment 
shows type tree example ast descent 
note combined nodes val fn fn op simplify presentation conflate function right hand side value definition operation right hand rule type ast node type environment annotated type tree node fn val app fn op fn op op int val twice fn val val twice initial annotated type tree val twice fn 
side function respectively 
type tree constructing full type node 
node type variable instantiated appropriate rule combine types sub nodes 
type environments contributing nodes recorded 
shows type tree example type construction 
note brevity initial type environment shown node 
fn val fn fn op fn int op op int val twice fn val val twice twice twice int int int int int int int int int int int int int int complete annotated type tree val twice fn 
pattern matching function definitions algorithm multiple case function definitions treated sequence separate single case functions type 
case checked produce substitution set type 
case type unified predecessor type produce substitution set case type having modified substitution set preceding unification 
type function type case treated 
case checked left right definition checked top bottom 
details see field harrison 
account pattern matching function definitions defined sml fun form treated special case facilitate dimensional analysis 
typing function fun pm uae algorithm generates matrix pairs type type environment row definition case column pattern result 
denote type matrix tes uae fi fi fi fi fi fi fi fi te te te te te te tem mn tem fi fi fi fi fi fi fi fi example function counts integer list contains initial matrix shown 
fun count count count count count inference uses observations 
types column unifiable combined single substitution column detailed 
write column shorthand equations unified type column types second similarly row identifier unifiable type occurrences combined single substitution detailed 
write env shorthand equations 
function bodies unifiable types te exp te te te write function type constructed unified column types unification count matrix form shown 
type annotation links matrix element omitted originate subtree element 
cons cons cons list int list list list int op int count count int app count count left hand side pattern right hand side expression case case case initial annotated type matrix count 
tn mn column tn column unification pattern columns te te te te te mn tem env env unification identifier types 
cons cons list int list int op int count int list int list count int count int list int cons list app count int int list list count int list count int list int left hand side pattern right hand side expression case case case complete annotated type matrix count 
generating explanations human type checking generate explanation annotated type tree tree traversed node annotated type environment recording history inference node type inspected 
contributing type environments recorded node may considerable repetition information circular chains annotations 
system attempts remove redundant information build reduced tree node non circular explanation 
full description graph traversal tedious give textual description supported example 
formal treatment 
program variable appears multiple type environments occurrences checked consistency shortest chain annotations leading fully instantiated type selected 
furthermore chain annotations program variable includes cycle back variable cycle eliminated removing highest level link annotated type tree 
example cycle linking int node back node 
remove link reduced annotation tree shown 
final explanations structured top level function type generated systematically left right argument types result types 
alternatives start simplest type allow user select top level types interest 
gross structure explanation determined rule annotation node fine detail provided history chains type environments 
explanation generation sub explanation generated back sub explanation line example 
sml subset rules explanation corresponding distinctive sites type inference 
list discuss final explanation val twice fn 
twice fn 
type lhs rhs val twice fn 
fn 
function type int 
int argument int bound variable type arguments result number types int result int function body int result arguments number types see initially observed sides val definition type right hand side chosen give explanation 
step final type right hand side function fn 

argument fn val fn fn op fn int op op int val twice fn val val twice twice twice int int int int int int int int int int int int int int reduced annotated type tree val twice fn 
explained exploring bound variable body 
step observed operands numeric type 
step notes int 
argument int 
step refers back step justify observation function body type int 
example full explanation function counts list fun count count count count count function type int list 
int argument int list type lhs pattern position list type operands result int list int list result int count count type rhs result int note identifier third definition case numbered distinguish case 
step notes left hand side patterns type 
step second case shortest history observed list containing tail list type 
step shortest history int 
step decides list int list function argument int list 
step notes right hand side result expressions type 
step shortest history int 
concluded function result int 
examples appendix related type explanation systems tracing behaviour algorithm 
system explains type inference menu traversal 
system uses global list record subexpressions inferred types global history list contains result types inference sub expression finishes 
information menu enable traversal global list 
system strengths user ask indicate site needs explanation explanation instantiate unnecessary local type variables explanation purely terms types corresponding sub expressions 
hard explain types method 
explanation top user needs remember steps inference understand full explanation required type 
duggan bent system explains type inference analysing instantiation type variables unification 
modified unification algorithm record instantiations type variables 
approach similar wand identify sources type errors 
systems similar unification algorithms give type inference explanation example programming environment 
system uses essentially unchanged algorithm walk syntax tree program collecting equality constraints types program variables 
modified unification algorithm solves equality constraints collect explanations 
explanation systems system records program fragment gave rise constraint corresponding instantiation 
resulting explanation simpler direct trace algorithm technique discussed :10.1.1.46.4848
explanation closer people understand type inference easy understand 
aliasing generates local type variables relate program 
furthermore type represented annotated graph quickly lengthy similar problems approach 
system intended error explanation illustrates inference reaches conflicting types :10.1.1.46.4848
system maintains deductive steps type inference explain reasoning type reconstruction process relation program 
uses functions explain type expression determined type subexpressions types subexpressions inferred 
explanation generated traversing syntax tree root leaves back root 
explanations essentially algorithm traces 
system strengths unnecessary local type variables explanations duggan bent system explanations english system explain type errors 
explanations bottom tend fine granularity information user needs remember steps inference 
furthermore explanations tend lengthy repetitive 
suggested interactive type debugger tied inference algorithm 
allow programmers explore type subexpression ask origin specific constructors 
type debugger determine type subexpression derivation information programmer intentions mistaken beliefs 
decide tell tells knows programmer overwhelmed 
intention programmer identify parts complex type surprising need explained 
system hard identify methodology exploring type decisions 
style type explanation similar duggan bent system includes instantiation type variables 
understand explanations needs understand unification type inference system 
bernstein stark give method debugging type errors called open system 
new type definition assumption environment defined 
type definition admits principal typings addition closely related ml type system 
assumption environment system finite mapping variables sets simple types including type schemes defined 
type definition polymorphic construct type schemes simple types 
owing assumption environments 
type definition essentially shao appel 
bernstein stark proved relation type definition type environment type definition assumption environment 
type inference give possible types unbound program variable 
user replaces suspect expression program free variable 
system infers type free variable user compare expected 
user repeatedly probe program way error uncovered 
contrast techniques requires user interaction locate error 
particular user guess probable location type error 
furthermore clear issue large assumption environments really practice 
explanation systems correct accurate fail key points 
explanations tend counterintuitive 
substantial internal type variables bridges instances sites refinement substitution 
contrast programmer concerned type variables 
understand explanations necessary remember program variable type variable inferred refined 
type variables hard remember entity type variable represents 
furthermore explanations succinct 
textual explanations information diffuse 
experts usually find explanation detailed real help find valuable information different positions programs contribute type systems 
explanations source tending text generated syntax tree original program text 
language implementations program converted simpler core representation prior type checking bears little relationship original source running example 
think difficulties arise directly realisation hindley milner type inference scheme algorithms efficient computer 
attempts generate human readable type explanations necessarily constrained sticking rigidly traces algorithms 
constructed type explanation system simple purely functional list subset sml influenced strongly experimental investigation expert human type explanation 
system explain type errors providing explanations conflicting sites unification uae algorithm 
wish extend approach substantial functional language fragment including user defined types types ultimately classes modules 
expect generating concise understandable explanations types mutually recursive top level constructs provide significant challenges 
furthermore experience polymorphism suggests considerable increase volume annotated type information complexity constructs increases 
consequently anticipate need investigate elaborate rules techniques explanation simplification generation 
human type complete language interesting provide front common implementation evaluate usability especially naive users 
interesting explore interactive type explanation user interactively browses program gui environment highlight program constructs explanation required 
human approach explanation formalised proved consistent including soundness completeness respect type inference 
acknowledgments wish joe wells collaboration uae algorithm colleagues took part expert type checking experiments 
wish anonymous referees helpful comments 
yang jun wishes ors heriot watt university support 
appendix examples count true list elements fun function type 
bool 
list 
int argument 
bool type lhs pattern position function type 
bool argument operand type operation result bool type condition type bool argument list type lhs pattern position list type operands result operations list list result int type rhs result int count negative zero positive list elements fun function type int int int 
int list 
int int int argument int int int type lhs pattern position tuple type int int int tuple element int type arguments result number types int tuple element int type arguments result number types int tuple element int type arguments result number types int argument int list type lhs pattern position list type operands result int list int list result int int int row argument type int int int see appendix ancillary functions function simply returns type constants 
int int real real bool bool string string functions defined fully 
ftv function returns free type variables type type scheme type environment 
close te denotes type scheme generated closing type type environment te ff ff fff ff ng ftv te 
returns annotated type simpler explanation returns constraint sets denoted finite sets pairs type schemes written foe oe delta delta delta oe oe constraint writing type variables left defined structure types 
similarly set constraints 
constructs constraint set common identifiers type environments te te fte te dom te dom te applying constraint set eliminates quantified type variables constrained equal returns constraint set unchanged 
unification functions te te te te case ffl fl ffl fl fl flg ffl fl fff ff ftv ffg fffi ffig fail strachey 
fundamental concepts programming languages 
higher order symbolic computation kluwer 
milner 
theory type polymorphism programming 
journal computer systems sciences academic press 
milner tofte harper 
definition standard ml revised 
mit press cambridge ma 
turner 
miranda non strict functional language polymorphic types 
proceedings functional programming languages computer architecture jouannaud ed springerverlag lncs vol 

burstall macqueen 
hope experimental applicative language 
csr department computer science university edinburgh 
hughes peyton jones 
eds 
haskell non strict purely functional language 
technical report yaleu dcs rr department computer science yale university 
bracha odersky stoutamire wadler 
making safe past adding genericity java pro gramming language oopsla vancouver october acm press new york 
cartwright steele jr 
compatible genericity run time types java tm programm ing language oopsla vancouver october acm press new york 
myers bank liskov 
parameterized types java proc 
acm principles programming languages paris france january 
morrison brown connor dearle 

napier manual 
persistent programming research report university st andrews un glasgow 
miller 
logic programming language function es simple unification 
journal logic computation cardelli 
basic polymorphic type checking 
science computer programming 
field harrison 
functional programming 
addison wesley wokingham 
yang michaelson trinder 
human type explanations ed proceedings th annual workshop psychology programming interest group april university 
yang michaelson trinder 
human human polymorphic type explanations 
proceedings nd annual conference centre information computer sciences london september university 
michaelson 
elementary standard ml 
ucl press london 
brooks 
theory comprehension computer programs 
international journal man machine studies 
wiedenbeck scholz 
beacons knowledge structure program comprehension 
salvendy smith editors designing human computer interfaces knowledge systems elsevier amsterdam 
yang 
improving polymorphic type explanations phd thesis dept computer science heriot watt university edinburgh scotland 
gustavsson 
personal communication 
chalmers university technology goteborg june 
yang 
explaining type errors finding source type conflict 
michaelson trinder 
loidl editors trends functional programming intellect bristol 
huch simon 
tool understanding type errors 
proceedings th international workshop implementation functional languages aachen july koopman eds informatik berichte 

explanation polymorphic type checker standard ml 
master thesis dept computer science heriot watt university edinburgh scotland 
duggan bent 
explaining type inference 
science computer programming 
wand 
finding source type errors 
conference record thirteenth annual acm symposium principles programming languages acm press january 

interactive programming environment ml 
technical report inria 
:10.1.1.46.4848
explaining type errors polymorphic languages 
acm letters programming languages systems 

finding source type errors interactively 
technical report department computer science chalmers university technology sweden 
bernstein stark 
debugging type errors full version 
technical report state university new york stony brook 
shao appel 
recompilation twentieth annual acm symposium principles programming languages january 

