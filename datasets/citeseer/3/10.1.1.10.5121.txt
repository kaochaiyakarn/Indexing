associated types class manuel chakravarty gabriele keller university new south wales national ict australia keller cse unsw edu au simon peyton jones simon marlow microsoft research cambridge uk simonpj microsoft com explore extension haskell type classes allows type class declaration define data types values methods 
similarly instance declaration gives witness data types witness method 
turns extension directly supports idea type indexed type useful applications especially self optimising libraries adapt data representations algorithms type directed manner 
crucially just haskell existing type class mechanism explained translation system explain extension translation system full detail 
valuable property ensures addition associated data types existing haskell compiler leads changes front 
efficient implementation parametrised data type requires concrete representation depends type parameter 
example may want represent arrays fixed width integers differently arrays trees 
inventing syntax want parameterized data type array instantiations data array data array int data array bool bitvector data array array array represent array integers unboxed array array booleans bit vector array pairs flattened pair arrays 
consequently array pairs integers booleans array int bool represented pair unboxed arrays bitvector 
specialised representation efficient terms space runtime typical operations parametric representation boxed array draft draft pairs 
data types concrete representation depends type parameters called type indexed 
shall demonstrate type indexed types understood class local data type declarations fact natural extension haskell type class overloading system 
example array type expressed local data type type class array elements class data array index array int keyword data class introduces associated data type definition type array associated class 
loosely terminology garcia 
representation array vary instance instance basis apart behaves top level data type declaration 
define instances class give instantiations array type instance int data array int index ar ar instance data array array array index ar br index ar index br local data type array included method index indexing arrays 
type index index array int signature dependence class associated type array explicit 
words varying instantiations element type concrete array representation index operates varies dependence equations defining array 
variation substantial standard haskell type classes representation type array may changes non parametric way different instantiations element type words type indexed types permit ad hoc overloading types way standard type classes provide ad hoc overloading values 
summarise contributions introduce associated data type type synonym declarations mechanism implement type indexed types demonstrate usefulness number motivating examples notably self optimising libraries sections 
show associated data types natural extension haskell overloading system 
give typing rules new type system evidence translation source terms system sections 
novel aspects system confined system translation enables straightforward integration existing haskell compilers glasgow haskell compiler 
great deal related subject type indexed types review detail section 
associated data type declarations narrow gap type classes haskell modules standard ml class declaration ml signature gives describes types values instance declaration structure functor specifies concrete realisation abstraction 
associated types obviously related intensional type analysis functional dependencies 
deserve additional comments available haskell systems 
section discuss detail functional dependencies form proposed jones inadequate motivating examples 
close links associated data type declarations ways bidirectional functional dependencies get effect unidirectional functional dependencies need associated type synonyms sketch 
motivation previous array example representative class applications associated types self optimising libraries 
libraries depending optimise implementation data representation choice algorithms lines determined library author 
optimisation process guided type instantiation class element type determines suitable array representation 
shall discuss instance representation optimisation considering generic finite maps subsection 
subsection turn sophisticated example generic graph library data representation algorithms vary dependence type parameters 
key feature self optimising libraries merely rely general compiler optimisations library code contains precise instructions library code specialised particular applications 
templates style libraries highly successful example standard template library boost graph library matrix template library 
generic programming haskell illustrates need data representations 
addition implementing self optimising libraries associated types useful interfaces applications functional dependencies 
shall discuss subsection 
generalised tries finite maps nice example data structure representation changes dependence type parameter discussed hinze subsequently example type indexed types hinze jeuring loh context generic haskell generalised tries generic finite maps 
maps change representation dependence structure key type index map 
addition key type finite maps parametrised value type forms codomain map 
representation generic finite maps depends type keys parametric polymorphic codomain call value type definition class mapkey data map empty map express different status key type value type making class parameter associated representation type map depends types 
assuming suitable library implementing finite maps integer trees patricia trees may provide instance mapkey integer keys follows instance mapkey int data map int mapint patricia dict empty mapint patricia instance different treatment key value types obvious fix key type instance leaving value type open 
words regard map type indexed type constructor kind 
described detail hinze define generic finite maps arbitrary algebraic data types simply giving instances mapkey unit product sum types 
follows leaving definitions class methods hinze instance mapkey data map instance mapkey mapkey mapkey data map map map instance mapkey mapkey mapkey data map map map class mapkey specific algebraic data type need map product sum representation means embedding projection pair 
generic graphs concept traits introduced aim reducing number parameters templates 
generic programming templates traits useful self optimising libraries choice data representation algorithms guided way type instantiation 
led investigation support style generic programming range different languages garcia 
evaluation garcia comparative implementation graph library concluded haskell excellent support generic programming exception satisfactory support associated types 
extension proposed tackles shortcoming head 
inspired garcia class graphs example 
class graph data edge data vertex src edge vertex tgt edge vertex outedges vertex edge contrast array mapkey examples container type associated element type vertex edge type associated container type 
allows define distinct instances graphs edge vertex types differ representation algorithms working data structure 
possible instances model vertices integers edges pairs source target vertex adjacency matrix newtype vertex instance graph newtype vertex gv int data edge ge vertex vertex maps vertices neighbours newtype vertex vertex instance graph newtype vertex gv int data edge ge vertex vertex addition flexibility gain defining class way method offers distinct advantages traits reduce number parameters class second contrast class parameters refer associated types names just position argument list improves readability program reduces potential confusing order arguments 
interface abstraction previous examples associated types self optimising libraries specialising data representations algorithms manner 
entirely different application defining interfaces base classes interfaces java signatures standard ml 
known example interface discussed context haskell hierachical libraries monad state transformer supports mutable 
collect parametrised family types follows class monad data ref ref ref ref instance io data ref io data ioref ioref data ioref 
instance st data ref st data data 
note type parameter associated type ref representation types ref higher kind kind 
complete signature ref subtlety code type ref io compatible data ioref ioref haskell data type constructors subject nominal type equality 
may desired interfaces prefer type synonyms preserve structural type equality 
introduce local type synonyms subsection 
associated type synonyms associated type synonyms define overloaded arithmetic operations manner flexible standard classes haskell 
particular example duck multiplication operation performs automatic coercions arguments different numeric types 
omit obvious method definitions class mul type prod prod instance mul int int type prod int int int instance mul int float type prod int float float contrast associated data types result existing type int float associated data type defined class 
contrast standard numeric classes haskell class mul generalises nicely richer types vectors 
type vec instance mul mul vec type prod vec vec prod similar examples discussed context multi parameter type classes functional dependencies reformulated associated types 
associated type synonyms add useful new power new complexity 
discuss appendix restrict associated data types rest 
associated data types detail section describe proposed language extension detail user language 
technical details type system deferred section 
propose type class may define addition set methods set associated data types 
class declaration data types declared definitions definitions instance declarations 
associated data type parameterised type variables class type variables come order class type variables 
rationale restriction section 
new type constructor introduced associated data type way normal top level data type 
kind type constructor inferred obvious way allow explicit kind signatures type parameters class data instance declarations give single definition associated data type class definition repeat class parameters instance additional parameters data type left type variables 
example legal instance class instance data instance declaration associated data types introduces new data constructors top level scope 
example data constructor introduced type instance associated data type may newtype declaration data declaration single constructor single field 
enables compiler represent datatype intervening constructor runtime 
default definitions haskell class method default definition declaration class instance omits specific definition method inherit default 
unfortunately provide similar facility associated data types 
see consider example add hypothetical default definition array associated type class data array index array int type constructor 
presumably type array type constructor valid certain instances give specific definitions array type 
correct type give constructor default definition 
system extended include associated type synonyms section shall see default definitions sense associated type synonym 
types involving associated data types type constructor introduced associated data type declaration thought type indexed type 
representation dependent instantiation parameters haskell existing overloading machinery resolve types 
duality methods class associated data types methods introduce overloaded type indexed variables associated data type declarations introduce type indexed types 
means just expression refers overloaded identifiers requires instances available context supplied true types 
going back array example consider signature array bool bool system declares valid type signature instance bool 
similarly array invalid representation array unknown 
type valid supply context array restriction associated type constructor type constructor appears applied type arguments class parameters 
surprising stated different way type applied index parameters 
types data declarations consistency system support associated types including definition data type 
doing interesting consequences 
consider array example suppose wish define new data type data array type valid type add context data array context works similar way contexts data types haskell currently adds context type constructor 
array type constructor ordinary type constructor behaves similar way associated type appears type appropriate context instances order deduce furthermore applied type indexed arguments 
translation example illustrate translation haskell associated types system walking translation mapkey example section 
translated terms haskell syntax convenience 
recap class declaration mapkey class class mapkey data map empty map lookup map translation new data type type dictionaries mapkey class data mk empty forall mk lookup forall mk type type parameter class type variable usual case single type variable extra type parameter mk representing associated type map instance class give different instantiation type map dictionary type 
note mk kind type variable polymorphic virtue class type variables 
class methods empty lookup explicitly polymorphic type variable 
instance unit instance instance mapkey data map empty lookup translation new datatype associated type dictionary value data empty lookup consider instance pairs instance mapkey mapkey mapkey data map map map empty empty lookup lookup lookup translation new datatype dictionary function data ma mb ma mb forall ma mb ma mb lda ldb empty empty da lookup lookup db lookup da new datatype takes additional type arguments ma mb representing types map map respectively 
instance context translation dictionary function dictionaries mapkey mapkey arguments delivering value 
translation instance doesn illustrate new omitted 
give translation example function making overloaded lookup function mapkey int map int lookup translation forall mk 
int mk mk lda lm lix 
lookup da ix example programmer specified type inferred type signature 
translation slightly trickier type signature specifies different context albeit entailed inferred context mapkey int mapkey map int lookup translation forall mk 
mk mk mapint lda lm lix 
lookup da ix note translating type map int instances mapkey mapkey int consulted just consulted check mapkey int entails mapkey construct dictionary mapkey int value translation 
type system evidence translation section formalise type system lambda calculus including type classes associated data types 
extend typing rules include translation source programs symbol classes type variable type constructor type class associated type data constructor term variable source declarations pgm data cls inst val program data data data type declaration cls class class declaration inst instance instance declaration val val value binding data associated type signature class method signature data associated data type source terms lx term identifier source types monotypes qualified type type scheme associated type application constraints constraint qualified constraint constraint scheme environments type environment instance environment syntax expressions types predicative fragment system type system jones overloaded ml oml 
fact associated data types change typing rules fundamental way require substantial extension dictionary translation type classes 
syntax syntax source language 
denote type variables term variables type constructors data constructors type classes associated types program sequence data type declarations class declarations instance declarations value bindings expressions simple lambda terms including non recursive local bindings 
notation extensively 
notation means sequence may omitted unimportant 
comma mean sequence extension follows give syntax qualified types curried way equiv notation accommodate function types regarding curried application function type constructor arguments unconventional feature source language 
class declarations may contain data type signatures addition method signatures correspondingly instance declarations may contain data type declarations addition method implementations 
data types associated types class 
second syntax types includes saturated application associated type application number arguments matches arity parent class 
type arguments way production 
arity associated type arity class defined notation data extra arguments count arity saturated applications associated types may higher kind 
stand constraint schemes closed predicate implications collect instance environments typing rules 
addition typing rules maintain type environment simplifying assumptions reduce notational burden class exactly type parameter 
classes associated types arity 
class exactly method associated type 
data type single constructor 
furthermore treat case expressions assume constructor comes projection function prj selects th argument constructor treat superclasses default declarations classes 
assume types kinded stating assumptions formally 
loosening simplifications largely matter adding great typing rules introducing superclasses slightly trivial section discusses 
type checking key feature system typing rules expressions close haskell 

judgement means type environment instance expression type rules absolutely standard damas milner type system 
allows constraint allows discharge constraint provided entailed environment 
judgement entirely standard 
unusual feature judgement rules check type formed respect available instances 
side condition rejects example typing lx map int target declarations td data target terms la target types environments dictionary environment associated type environment syntax target terms types typing invalid associated type map meaningless corresponding mapkey constraint 
rules class instance declarations quite standard possibility type declarations class 
omit details form part elaborate rules give 
reason type wellformedness judgement specified type schemes just monotypes needed check validity types class methods 
evidence translation second crucial feature system haskell translated system augmented data types adding associated type extensions target language 
gave example translation section 
section formalise translation 
evidence translation terms main judgement means environment source term type translates target term 
rules judgement part wellknown elaboration rules 
target term explicitly typed style system syntax 
main typing judgement derives source type target term decorated target types 
programmer sees source types include qualified types applications associated types 
contrast target type mentions data types qualified types associated types appear 
instance environment plain type checking rules split components see 
dictionary environment associates dictionary function constraint scheme contains information old wellformedness judgement rules type translation judgement translates source types target types 
type translation driven associated type environment discuss type translation section 
mono spec mp associated type fv var lx fv fv sig standard type checking rules expressions trw trw fv trp associated type pe associated type fresh pi mono spec mp definition entailment relation var lx lx la fv fv la sig typing rules translation returning rules terms interesting cases rules deal associated types 
rule type variables stand associated types 
augmenting dictionary environment reflect constraint environment witness augment type translation environment explain associated types may rewritten 
dually rule applies target term witness type witness term witness types derived judgement witness terms derived 
translating types translation source types target types formalised judgement eliminates applications associated types consulting associated type environment judgement relates formedness judgement just way typing judgement relates motivate rules type translations copied section map int mapint ag mapkey map ab mapkey mapint example straightforward arises directly instance declaration mapkey 
going second example 
class constraint translated ordinary function argument type mapkey target data type mapkey type dictionaries class mapkey generated translating class declaration 
crucial point data type takes extra type parameter associated type class just 
correspondingly quantify new type 
type map translated map map applying instance declaration pairs 
map translated mapint map precisely associated type class mapkey translated associated type environment contains kinds assumptions 
instance declaration get assumption form associated data type corresponding target data type 
example consider instances class mapkey section 
instances int pairs augment assumptions map int map map map see details extended way discuss rule instance declarations section 
second midst translating type extend local assumptions form denoted rule trp 
example moving inside mapkey qualifier example add assumption map need extend local assumptions form judgment form 
judgment abstracts associated type introducing new type variable represents associated type 
provides application associated type class instance corresponding dictionary type data type value declarations rules type directed translation declarations 
somewhat largely notational overheads complexity vanilla haskell 
real done point 
programmer sees haskell type system unchanged implementation deal water implement associated types 
translation data type declarations easy need translate constructor argument types auxiliary type translation judgement value declarations straightforward done figures 
class instance declarations interesting cases class instance declarations 
may help refer back example section reading rules 
noted class declaration class translated data type declaration named data constructor called cd data type represent dictionary class constructor class methods signature argument types suitably translated course 
translation uses associated type environment maps associated type fresh type variable data type data td data data prj data cls td fresh class data data cd ab prj cls inst td fresh fresh fresh instance data data la ld 
inst val td val pgm td data cls inst val data cls inst val declaration typing rules translation parameterised fresh presumably free translated method types generate binding method selector function class method rule implemented corresponding projection functions prj addition target declarations defining data type dictionary method selector functions rule cls produces environment giving source types class methods 
instance declarations awkward 
associated type class generate fresh data type declaration implements associated type instance type 
data type parameterised quantified type variables instance declaration type variable associated type constraint instance declaration type variables type parametric instances example artificial example demonstrate class mapkey data map instance mapkey mapkey mapkey data map map data type arises instance declaration data map ma mb mb arguments ma mb 
may needed see example 
optimisation unused translated right hand side declaration omitted type parameter list 
produce righthand sides instance associated type declarations need replace applications associated types newly introduced type parameters 
achieved associated type environment hypothesis 
addition promoting associated data type fresh top level data type declaration rule inst returns tiny associated type environment dictionary environment embody information instance declaration rest program tiny type embodies types new data constructor concludes hard part instance declarations 
generation dictionary function extension dictionary environment exactly vanilla haskell 
tying knot final judgement judgements types classes instances value declarations 
rule highly recursive associated type environment produced type checking instance declarations consumed judgement judgements 
similarly judgements produce fragment environment consumed judgements instance value declarations 
reason recursion 
example consider data type section 
constructor mentions type vertex translation type comes instance declaration 
practice implementation unravel recursion somewhat new extension somewhat harder 
example haskell type check instance declaration heads part generate top level check value declarations generate take second run instance declarations time checking method bodies 
instance declarations class may needed type check class declaration class associated types appear method type signatures 
rocket science complication 
associated type parameters section specified type parameters associated type identical parent class plus optional extra parameters see 
class parameters occur insist associated type applications saturated wrt class parameters 
turn ensures type translation described proceed concern partial applications clutter arising extra principle permit type permute parent class parameters cost extra notational bureaucracy inst rule benefit doing 
principle allow associated type mention subset parent class parameters need extra tests ensure instance declarations overlap account selected class parameters ensure type translation described confluent 
similar test functional dependencies employed 
benefit justify cost 
superclasses formalisation type system evidence translation take superclasses account context head class declaration 
simplification interest clarity formal rules 
needs mentioned subtlety respect translation associated types classes superclasses 
rule cls see generated dictionary data type set type arguments corresponds associated type class 
class superclasses contain associated types associated types needs appear argument dictionary 
words similar dictionaries superclasses embedded class dictionary associated types superclasses need embedded 
comparison functional dependencies functional dependencies experimental addition multiparameter type classes introduce functional relationship different parameters type class similar class parameters associated types 
functional dependencies rely jones notion improvement type checking impact evidence translation multiparameter type classes 
fact hinze section briefly mention possibility functional dependencies implement type indexed types reject giving vague rationale 
give hard technical reasons prevent defining type indexed types array type section functional dependencies 
illustrate problems encoding array relational form parameter type class class arr arr index arr int functional dependency arr restricts binary relation function element types representation types arr 
instance declarations populate relation represented 
words associated type provided extra argument class local 
consequently corresponding instance declarations local type definition replaced instantiation second parameter class methods omitted instance int instance arr arr class definition polytypic arrays suffers serious shortcomings shall discuss 
unsound type constraints 
duck point instance pairs arr unsound type variables arr occur argument type constraint 
instances accepted type inference presence functional dependencies undecidable 
precisely diverges certain terms rejected type incorrect 
jones original proposal functional dependencies allow instances 
clutter 
comparative study garcia mentioned section haskell receives full marks categories treatment associated types type classes functional dependencies 
essence requirement associated types extra parameters type classes results complicated readable code 
illustrated parameter arr type class 
extra parameters appear signatures involving associates types quite large terms involved examples graph library discussed garcia lack abstraction 
expect define arrays module hide concrete array representation user module 
encoding functional dependencies allow level abstraction 
see case consider full type index function index arr arr int avoiding knowledge arrays integers represented expect able define int arr arr int index definition admissible type signature considered instance type inferred function body presence functional dependency arr cf 
class declaration 
fact forced definition int index clearly breaks intended abstraction barrier 
root problem lies deep 
consequence evidence translation type classes expect system term coerces coercion exists 
require non parametric operation system 
variations functional dependencies 
duck propose liberal form functional dependencies recursive instances lead nontermination 
require radically different form type checker hm framework constraint handling rules 
stuckey sulzmann introduce implementation multi parameter type class functional dependencies depend dictionary translation 
result avoid problems original form functional dependencies 
related type classes 
significant amount previous studies relationship type classes type indexed functions purpose expressing generic functions standard type classes 
chen proposed parametric type classes type classes type parameters represent container classes overloaded constructors selectors 
provide type system type inference algorithm evidence translation 
parametric type classes type class single associated type synonym 
functional dependencies 
discussed original form functional dependencies section including extensions duck stuckey sulzmann 
neubauer introduce functional notation type classes single functional dependency parametric type classes 
proposal just syntactic sugar functional dependencies translate new form classes multi parameter classes functional dependency passing type checker 
authors ambitious second proposal add full blown functional logic language type system hm framework 
treatment local type synonyms type inference seen special case generic approach carefully preserve termination type inference 
neubauer address issue suitable evidence translation means infer types compile programs 
generic haskell 
hinze propose translation type indexed data types type specialisation procedure 
efforts culminated generic haskell pre processor translates code including type indexed types functions haskell including type system extensions rank types 
pay special attention type indexed data types structurally defined map type section automatically perform mapping standard haskell data type definitions representation binary sums products 
loh elaborated original design introduced dependency style generic haskell 
functors standard ml 
relationship standard ml higher order modules form signatures structures functors haskell type classes subject discussions 
far type classes lacked local type declarations signatures 
essentially ml signature encapsulates set parametrised type value declarations type class associated types 
structure functor concrete instance signature type class instance 
despite conceptual similarity concepts differ significantly 
structures term level entity notion phase distinction required separate static dynamic semantics 
contrast type classes purely static concept 
part due involvement term level ml higher order modules give rise rich design space far clear different concepts relate type classes 
local types type classes shows previous lack encapsulation types fundamental property type classes 
intensional type analysis 
intensional type analysis realises type indexed types type level construct originally proposed facilitate type preserving optimisation polymorphism 
subsequent elaborated seminal harper morrisett outlined relationship type classes 
conceptual difference intensional type analysis type classes explicit runtime representation type arguments evidence translation targets system type erasure semantics 
crary proposed alternative view intensional type analysis type erasure 
case need pass method dictionaries runtime regarded implicit type representation 
constrained data types 
xi introduce type indexed data types annotating constructor data type declarations type pattern call guard type system establish soundness 
internal language explicit contrast approach type indexing removed evidence translation phase call elaboration 
cheney hinze slightly generalised version guarded data types permitting equational type constraints various alternatives data type declaration 
approaches differ class approach type indexed data types open new class instance added theirs closed data type declarations extended 
object oriented languages 
discussed section associated types long standing tradition collected traits classes 
garcia compared support generic programming standard ml haskell eiffel generic java generic 
exists plethora generic programming object oriented programming languages scope review 
proposed include type declarations side value declarations haskell type classes 
associated types type class especially useful implementing self optimising libraries serve implement interfaces concepts functional dependencies past 
case associated data types demonstrated evidence translation standard implementing type classes elegantly extended handle associated types particular target language affected extension source language 
elaborate type checking presence associated type synonyms plan investigate feasibility generic default methods classes involving associated types 

amr sabry discussions previous version approach pointing garcia roman detailed feedback sharing insights generic programming 
martin sulzmann number interesting discussions type classes functional dependencies 
dave brian mcnamara jeremy siek interesting email exchange comparing haskell type classes classes 
authors partly funded australian research council number dp 
national ict australia funded australian government backing australia ability initiative part australian research council 
rinus plasmeijer 
generic programming extension clean 
international workshop implementation functional languages number lecture notes computer science pages 
springer verlag 
manuel chakravarty gabriele keller 
approach fast arrays haskell 
johan jeuring simon peyton jones editors lecture notes summer school workshop advanced functional programming number lecture notes computer science 
kung chen paul hudak martin odersky 
parametric type classes 
acm conference lisp functional programming 
acm press 
james cheney ralf hinze 
class phantom types 
tr cornell university 
karl crary stephanie weirich 
flexible type analysis 
international conference functional programming 
karl crary stephanie weirich greg morrisett 
intensional polymorphism type erasure semantics 
acm sigplan international conference functional programming pages 
acm press 
nachum dershowitz jean pierre jouannaud 
handbook theoretical computer science volume formal models chapter rewrite systems pages 
elsevier mit press 
derek dreyer karl crary robert harper 
type system higher order modules 
proceedings th acm sigplan sigact symposium principles programming languages pages 
gregory duck simon peyton jones peter stuckey martin sulzmann 
sound decidable type inference functional dependencies 
esop lncs 
springerverlag 
ronald garcia jaakko andrew lumsdaine jeremy siek 
comparative study language support generic programming 
proceedings th acm sigplan conference object oriented programing systems languages applications pages 
acm press 
cordelia hall kevin hammond simon peyton jones philip wadler 
type classes haskell 
european symposium programming number lncs pages 
springer verlag 
robert harper john mitchell 
parametricity variants girard operator 
information processing letters 
robert harper john mitchell eugenio moggi 
higherorder modules phase distinction 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 
robert harper greg morrisett 
compiling polymorphism intensional type analysis 
nd acm symposium principles programming languages pages 
acm press 
ralf hinze 
generalizing generalized tries 
journal functional programming 
ralf hinze johan jeuring 
generic haskell applications 
roland backhouse jeremy gibbons editors lecture notes summer school workshop generic programming number lecture notes computer science 
ralf hinze johan jeuring andres loh 
type indexed data types 
bernhard mller editors proceedings sixth international conference mathematics program construction mpc number lecture notes computer science pages 
springer verlag 
ralf hinze simon peyton jones 
derivable type classes 
graham hutton editor proceedings acm sigplan haskell workshop volume electronic notes theoretical computer science 
elsevier science 
mark jones 
simplifying improving qualified types 
fpca conference functional programming languages computer architecture 
acm press 
mark jones 
system constructor classes overloading implicit higher order polymorphism 
journal functional programming 
mark jones 
type classes functional dependencies 
proceedings th european symposium programming esop number lecture notes computer science 
springer verlag 
ralf 
sketch polymorphic symphony 
nd international workshop reduction strategies rewriting programming wrs volume entcs 
elsevier science 
ralf simon peyton jones 
scrap boilerplate practical approach generic programming 
proceedings acm sigplan workshop types language design implementation pages 
andres loh dave clarke johan jeuring 
generic haskell 
proceedings eighth acm sigplan international conference functional programming pages 
acm press 
alberto martelli ugo montanari 
efficient unification algorithm 
acm transactions programming languages systems toplas 
nathan myers 
traits new useful template technique 
report june 
matthias neubauer peter thiemann martin michael sperber 
functional notation functional dependencies 
acm sigplan haskell workshop 
matthias neubauer peter thiemann martin michael sperber 
functional logic overloading 
proceedings th acm sigplan sigact symposium principles programming languages 
acm press 
martin odersky martin sulzmann martin 
type inference constrained types 
theory practice object systems 
chris okasaki andy gill 
fast mergeable integer maps 
workshop ml pages 
zhong shao 
flexible representation analysis 
proceedings acm sigplan international conference functional programming pages 
jeremy siek lie quan lee andrew lumsdaine 
boost graph library user guide manual 
addison wesley 
jeremy siek andrew lumsdaine 
matrix template library generic components high performance scientific computing 
computing science engineering 
stepanov lee 
standard template library 
technical report wg iso programming language project 
peter stuckey martin sulzmann 
theory overloading 
acm transaction programming languages systems 
appear 
stephanie weirich 
type safe cast functional pearl 
proceedings fifth acm sigplan international conference functional programming icfp 
acm press 
stephanie weirich 
higher order intensional type analysis 
european symposium programming esop 
hongwei xi chen gang chen 
guarded recursive datatype constructors 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 
associated type synonyms seen previous section add local data type declarations haskell type classes significant changes typing rules serious changes type inference 
translating source types expressions declarations explicitly typed intermediate language need pay special attention associated data types 
translation way class methods introduce dictionary parameters class local data types introduce representation type parameters 
situation changes soon allow local type synonyms type classes 
shall discuss section local type synonyms lead significant change type system particular seriously impact structure type inference especially type term unification 
machinery handling local data types dictionary translation place local type synonyms major impact structure translation 
words local data types type synonyms require similar changes evidence translation additionally local type synonyms require changes basic type system 
space constraints prevent thorough formal treatment local type synonyms handling type inference 
outline essential points section discuss details companion 
subsection motivates need local type synonyms discussing special properties compared local data types 
subsection sketches type inference presence local type synonyms necessary changes evidence translation procedure 
local type synonyms versus data types utility local type synonyms apparent example mul class section part definition repeat class mul type prod prod instance mul int int type prod int int int instance mul int float type prod int float float example want application associated type prod equal corresponding instance type want int equal int values 
prod int int lifted nominally distinct int conventional arithmetic operations result multiplication operation class mul 
similar reasons want associated synonyms data types example class section 
data types original operations data ioref interchangeable methods interface class values type ref wrapped additional data constructor 
idea traits discussed section relies encapsulating types class form permits passed arguments type constructors classes addition enforcing equality traits different classes classes conjunction 
contrast data types associated synonyms higher kind explicitly naming additional arguments need add kind signature mul example 
associated type synonyms default declarations default declarations class methods 
instance omit definition associated synonym having definition declarations default type instance 
default declarations example useful type indexed container types arrays want fall back vanilla boxed representation instances provide optimised data representation 
possible associated data types discussed section 
associated type synonyms underlies additional restrictions discuss detail example may recursive occurrences reasons recursion allowed toplevel type synonyms 
equational type equality just toplevel type synonyms associated type synonyms introduce richer purely syntactic equality type terms 
contrast toplevel synonyms expand associated synonyms type checking 
result typing rules implementation form type inference procedure need explicitly deal associated synonyms resulting richer notion equality type terms 
words purely syntactic type equality extended modulo theory defined type equations class instances 
fact type equations class instances form term rewriting system trs type terms 
preserve decidability type checking inference principal types property restrict trs confluent terminating imposing studied restrictions 
instance heads left linear repeated occurences type variable 

instance heads constructor synonym applications 

right hand sides local synonyms decreasing application local synonyms strictly constructors arguments constructors left hand side 
confluent terminating trs guarantees unique normal forms type terms turn sufficient tractable notion equality 
equality typing rules easily extended allow replace type terms equals 
type inference unification unfortunately matters get involved move typing rules type inference algorithm 
basic known problem unification may come applications associated type synonyms reduce current set substitutions 
example referring class mul may encounter situation need unify prod int int 
decide unification succeeds fix type unification succeeds depending instantiated int float prod int reduces int float respectively 
call prod int int unification constraint extend standard type inference algorithm damas milner type classes maintain set pending unification constraints addition type substitution arises solved unification steps 
addition need take care avoid generalising variables mentioned unification constraints rule bindings 
solve unification constraints set rewrite rules nondeterministic algorithm martelli montanari add additional rules rewrite type terms rules trs induced program instance declarations 
add treatment associated synonyms evidence translation section need add mapping source types normalised version type translation environment 
