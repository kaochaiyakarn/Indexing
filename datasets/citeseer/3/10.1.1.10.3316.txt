memory safety runtime checks garbage collection vikram adve chris lattner university illinois urbana champaign cs uiuc edu traditional approaches enforcing memory safety programs rely heavily runtime checks memory accesses garbage collection unattractive embedded applications 
long term goal enable static enforcement memory safety embedded programs advanced compiler techniques minimal semantic restrictions programs 
key result compiler technique ensures memory safety dynamically allocated memory programmer annotations runtime checks garbage collection works large subclass type safe programs 
technique fully automatic pool allocation region inference algorithm programs developed previously ensures safety dynamically allocated memory retaining explicit deallocation individual objects regions avoid garbage collection 
diverse set embedded programs previous technique avoid null pointer checks show able statically ensure safety pointer dynamic memory usage programs 
describe improvements previous static checking array accesses 
achieve static enforcement memory safety new language syntax significant subclass embedded programs subclass broader array bounds checks ignored 
categories subject descriptors computer systems organization special purpose application systems software programming languages software operating systems security protection keywords embedded systems compilers programming languages static analysis security region management automatic pool allocation 
sponsored nsf embedded systems program award ccr part nsf career award eia onr 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
june san diego california usa 
copyright acm 

current embedded systems demand increasing software exibility including ability upgrade introduce software modules existing applications ine active operation 
software upgrades increasingly common small consumer devices expected important constrained systems embedded control systems sensor networks 
key requirements enabling dynamic software upgrades ensure new software modules applications compromise safe correct functioning embedded device 
part problem ensuring memory safety embedded software guarantee upgraded software module corrupt code data host application 
term memory safety de ned section 
unfortunately appears current language system approaches ensuring memory safety require signi cant overheads terms runtime checks garbage collection 
safe languages java modula ml cyclone ccured variety runtime checks individual memory operations bounds checks array null pointer type conversions rely garbage collection ensure safety dynamically allocated memory :10.1.1.127.7825:10.1.1.127.7825
overheads runtime checking quite signi cant languages ccured cyclone vault reported slowdowns ranging di erent applications :10.1.1.10.8871:10.1.1.14.7406
types embedded software operate stringent energy memory processing power limitations hard soft real time constraints 
runtime overheads safety checks overheads potential unpredictability garbage collection unattractive software 
long term goal ensure memory safety embedded software eliminating greatly minimizing need runtime checks garbage collection 
goal impossible ordinary language features arbitrary dynamic memory allocation aliases array strategy impose minimal semantic restrictions programs necessary achieve goal existing compiler technology reduce restrictions developing new compiler techniques 
previous addressed limited class realtime control applications typically simple data structures memory management designing restricted subset language appropriate pro grams 
language called control imposed onerous restrictions dynamic memory allocation pointer usage array usage 
showed restrictions existing compiler technology permit static checking memory safety language 
real time control codes kinds embedded applications dynamically allocated memory arrays complex ways restrictions preclude writing applications 
major technical challenge broader classes embedded applications allowing exible dynamic memory allocation deallocation runtime checks garbage collection 
proving statically general program example dereferences freed pointer dangling pointer problem undecidable 
languages including real time java cyclone vault introduced language mechanisms region memory management :10.1.1.127.7825:10.1.1.127.7825:10.1.1.32.6278:10.1.1.14.7406
approach heap partitioned separate regions deallocation permitted entire region 
mechanisms guarantee safety pointer accesses region data garbage collection key disadvantages converting programs region mechanisms demands signi cant manual ort typically requiring region annotations pointer variables function interfaces allocation sites 
region management schemes disallow explicit deallocation individual objects data structures shrink grow frequently objects non nested life times fall back separate garbage collected heap avoid potentially unbounded growth unused memory :10.1.1.10.8871
automatic region inference algorithms developed solve rst issue completely partially languages explicit deallocation ml cyclone languages require garbage collection :10.1.1.10.8871
developed fully automatic region inference algorithm called automatic pool allocation works correctly programs explicit malloc free including non type safe programs 
transformation solves problems fully automatic retains explicit deallocation individual objects regions 
pool holds objects single size eliminating fragmentation pools enabling fast allocation deallocation 
unfortunately allowing individual object deallocation means transformation ensure memory safety attempt eliminate restrict dangling pointers 
main result current extend automatic pool allocation ensure memory safety requiring runtime checks retaining performance memory bene ts original algorithm including fully automatic region management language annotations explicit deallocation objects regions 
key approach prevent uses dangling pointers freed memory read write free freed storage location ensure statically operations cause violations type safety memory safety 
speci contributions follows show automatic pool allocation transformation ensure safety dynamically allocated memory 
interprocedural ow analysis compiler generated pool operations pinpoint data structures approach lead increased memory consumption program 
analysis identi es pools individual object deallocation completely eliminated increasing memory consumption 
extend previous program restrictions compiler analysis ensuring array access safety order support common features disallowed including string manipulation standard operations argument vectors 
evaluate ective new techniques compiler safety checks retained previous permitting static checking memory safety diverse collection embedded programs widely benchmark suites mediabench 
experimental results show able statically ensure safety pointer dynamic memory usage programs 
compiler analysis identi es speci data structures programs memory management strategy lead probably small potential increase memory consumption 
approach promises safe dynamic memory management overheads runtime checks negligible manual programmer ort 
believe major step achieving long term goal static enforcement memory safety embedded programs 
results show essential techniques developed previous adequate programs studied novel memory initialization strategy eliminate runtime checks null pointer speci system assumption compiler analysis lifetimes stack allocated data 
sucient programs necessary works successfully programs 
proving safety array remains major challenge achieving long term goal 
extensions able prove safety array programs 
draw ideas language compiler mechanisms succeed programs 
rest organized follows 
section de nes mean memory safety static checking brie describes previous static safety checking real time control systems summarizes assumptions programs systems current 
section describes language restrictions compiler techniques ensuring safety pointer heap management 
section array 
section describes experiments evaluating ectiveness techniques supporting di erent classes embedded applications 
section compares previous providing program safety static techniques 
section concludes summary results suggests directions research 

definitions prior assumptions purposes de ne software entity module thread complete program memory location outside address space allocated entity executes instructions outside code area created compiler linker address space 
practice enable static enforcement requirements enforce stronger restrictions strict type rules operations limited type conversions bounds array accesses 
stronger restrictions help detect kinds errors compile time runtime 
static enforcement static checking memory safety mean compiler ensure memory safety relying garbage collection introducing runtime checks program operations null pointer array bounds type conversion checks 
runtime support necessary especially initialization global dynamically allocated storage system assumptions error recovery described 
ordinary constructs modern languages particularly array accesses complex pointer data structures impossible ensure memory safety static checking 
choose impose restrictions programs static checking possible 
simple possible modify existing embedded code conform restrictions avoid adding new language mechanisms syntax 
impose usage semantic restrictions de ned framework existing language checked compiler 
experiments focus programs semantic restrictions de ned low level language independent terms safety checking compiler implemented entirely language independent compiler infrastructure called llvm low level virtual machine features lack new source level constructs imply safety checking strategy programs source level language compiled llvm object code 
control memory safety real time control codes control language de ned previous imposed semantic restrictions programs added new language mechanism manual region allocation described 
goal enable static checking memory safety real time control codes existing compiler techniques 
brie describe language provide basis understanding new compiler techniques current eliminate need restrictions 
classes restrictions control type safety input programs strongly typed 
restrictions retained current 
ane expressions accessing arrays control imposed restrictions array index expressions llvm de nes simple fully typed instruction set static single assignment ssa form input code representation order enable compile time link time runtime optimization programs 
see llvm cs uiuc edu 
loop bounds net ect produce ane relationship ective address expression size expression array dimension 
disallowed common library functions string operations 
ane requirement retained number trusted library functions string operations permitted 
single region dynamic memory allocation imposed onerous restrictions dynamic memory allocation pointer usage eliminated current heap allocation restricted single region time entire region heap objects deallocated simultaneously 
time region freed scalar pointers variables local global reinitialized 
structures arrays containing pointers allocated dynamically heap stack alloca intrinsic 
showed restrictions adequate real time control algorithms tend simple data structures memory management 
clearly inadequate broader classes embedded programs 
eliminating restrictions retaining static checking memory safety requires new compiler techniques particularly array bounds checking heap pointer safety 
current primarily focuses making simple improvements 
assumptions system assumptions current plus basic language restrictions type safety pointer safety summarized 
language restrictions array safety described sections 
assumptions runtime environment 
assume certain runtime errors safe runtime system recover errors killing applet thread process executing untrusted code 
assume safe runtime error generated stack heap grows available address space 
assume system reserved address range access addresses causes safe runtime error typically triggered page fault handler reserved address range hardware systems virtual memory management 
available null pointer checks inserted code described 
assume certain standard library functions system calls trusted safely invoked untrusted code calls arguments checked discussed section 
assume check source code functions available compiler 
require program single threaded 
retain basic type rules control summarized informally 
assume low level type system including set primitive integer oating point types arrays pointers user de ned records structures restricted union types functions 
example standard linux implementations high process address space reserved kernel typically gb gb 
variables assignments expressions strongly typed 
casts pointer type type disallowed 
certain pointer pointer casts compatible targets considered safe 
union contain types cast union include pointer non pointer type 
enforcing rules trivial llvm operations typed explicit cast instruction perform type conversion 
retain rules required ensuring pointer safety discussed section local pointer variable initialized referenced having address taken 
individual data type array larger size reserved address range 
address stack location stored heap allocated object global variable returned function 

safety pointer language garbage collection type restrictions key ways pointer usage lead unsafe memory behavior uninitialized pointer variables scalars elements aggregate objects access invalid memory addresses 
pointer stack frame function live function returns access object di erent type violate type safety 
pointer freed memory object dangling pointer access object di erent type allocated 
problems detected disallowed compile time safely tolerated runtime introducing checks individual memory 
examine conditions turn subsections 
uninitialized pointers compiler prevents rst error due uninitialized pointer values way previous combination static analysis minimal runtime support 
describe brie completeness 
standard global data ow analysis check rule requires automatic scalar pointers initialized parent function explicitly dereferenced address taken 
detecting uninitialized values global variables pointers dynamically allocated data structure elds arrays dicult compile time 
order avoid runtime null pointer checks initialize uninitialized global scalar pointers pointer elds dynamically allocated data structures allocation time point base reserved address range analogous initialization elds java 
pointer elds stack allocated variables aggregate types initialized value 
constant pointer type expression replaced value 
rule speci es size individual structure type exceed size reserved address range 
rule initialization ensures ective address load scalar variable structure eld uninitialized pointer fall reserved address range triggering safe runtime error 
reserved address range unavailable structure size restriction unacceptable runtime checks null pointer required 
stack safety problem potentially arises address local variable pointer current stack frame accessible function returns 
avoid problem type safe languages java disallow address local variables 
choose restrictive disallow placing address stack location heap location global variable returning directly function rule 
enforcing rule requires sophisticated compiler technology required perform automatic pool allocation enforcing heap safety 
particular data structure analysis ow insensitive context sensitive fast interprocedural analysis computes data structure graph procedure 
directed graph memory objects accessible procedure types storage class stack heap global formal parameter return value local scalar temporaries points links 
graph function includes reachable objects passed callers returned callees 
rule enforced simple traversal data structure graph function checking stack allocated object reachable function pointer arguments return node globals 
heap safety third error detecting unsafe accesses freed memory particularly challenging problem language explicit memory deallocation 
example illustrates challenges 
function calls rst creates linked list nodes initializes calls computation 
frees nodes head returns 
uses dangling pointer reachable head 
code extremely hard compiler statically identify may unsafe 
consider allocates node frees node list times 
eliminating explicit frees region allocation control cyclone languages nested regions increase instantaneous memory consumption program sizeof struct bytes region holding list items freed exiting function key principle underlying approach type homogeneity principle freed memory block array need size restriction 
uninitialized pointer array caught array bounds checker array known size expression 
dangling val 
struct create node list initialize free head struct tmp struct malloc sizeof struct insert tmp list tmp remove useful member free pointer safety pool allocation example holding single object reallocated object type alignment dereferencing dangling pointers previous freed object cause type violation 
principle implies guarantee memory safety need prevent dangling pointers usages source just need ensure dereferenced type unsafe manner 
principle allows correct programs programs uses dangling pointers correctly runtime overhead 
programs dangling pointer errors execute safely need prevent errors programs 
principle directly simple impractical solution separate heap disjoint pools distinct data types allow memory pool reused di erent pool 
impractical lead large increases instantaneous memory consumption 
worst case increase program pools roughly factor program rst allocates data type frees allocates data type frees 
solution essentially sophisticated application basic principle automatic pool allocation achieve type homogeneous pools shorter lifetimes order avoid signi cant memory increases far possible 
background automatic pool allocation transformation automatic pool allocation transformation developed general compiler technique enabling macroscopic optimizations logical data structures 
transformation introduces pool memory management subset disjoint data structures ordinary imperative program uses explicit allocation malloc deallocation free 
rewrites allocation deallocation operations separate pools memory logical data structure instance particular linked list graph exposed unknown external functions 
pool created rst allocation data structure instance destroyed point accessible data pool 
pool allocation library simple operations pool pp td creates new pool objects speci ed type 
pool pp destroys pool releases remaining memory back system heap 
pool pp pool pp int allocate single object array objects pool 
pool pp ptr deallocates object pool marking memory available reallocation 
pool library internally uses ordinary malloc free obtain memory system heap return part pool unused pool destroyed 
pool allocation transformation operates follows 
identify data structure ds instances traverse data structure graph function described section identify maximal connected subgraphs containing heap nodes 
subgraph represents distinct heap allocated data structure 

identify create destroy pools procedure dsg identify data structures accessible procedure returns escape procedure callers 
data structure insert calls create destroy pools memory pool data type data structure entry exit procedure 
running example linked list escape procedure callers create destroy pool list procedure shown 
transform de allocation operations function interfaces transform malloc free calls original program pool allocation versions illustrated function 
function containing operations pool created outside function add extra arguments pass appropriate pool pointers function possible callers functions callers 
illustrated functions invocations 
result transformation type safe programs heap allocated objects assigned pools disjoint data structure instances de ned assigned distinct sets pools individual items allocated freed individual pools points 
pool destroyed live reachable data pool 
note transformation described far ensure program safety 
explicit deallocation return freed memory pool back system allocate di erent pool 
dangling pointers freed memory violate type safety 
exploiting pool allocation heap safety basic principle type homogeneity mentioned earlier applied ensure program safety pool pools require nested lifetimes 
move function move earlier callee additional ow analysis currently 
data structure analysis identi es targets function pointers constructs call graph allowing handle programs indirect calls recursion 
pool pp pp struct pp dangling val 
pp struct pool pp create node list pp initialize pp free head pp struct pool pp tmp pp insert tmp list tmp remove useful member pp example pool allocation transformation allocation transformation 
pools simply need ensure memory pool dynamically allocated data pool heap allocations trusted libraries destroyed 
done easily modifying runtime library memory pool released system heap 
change disadvantage na ive type pools memory requirement program increase signi cantly 
note pools short lived na ive approach tied dynamic data structure instances program static types 
expect lifetime pool important reuse memory pool pool pools 
causes potential increase memory consumption 
increases signi cant concern programmers embedded systems 
goal analysis distinguish situations outlined inform programmer data allocation points potential memory increases occur 
classify pool categories case reuse pool calls pool including 
case reuse memory destroyed 
illustrates situation 
note calls eliminated performance optimization 
essentially static garbage collection pool memory reclaimed introduced compiler 
case self reuse operation pool call operations pool case reuse memory pool explicit deallocation ensures increase program memory consumption occur 
illustrated rst new allocations pool function pool 
case cross reuse rst operation pool operations pools 
pool falls category allocations pool call 
transformation case may lead increased memory consumption require approved programmer compiler option 
situations programmer able estimate potential memory increase manual analysis pro ling 
practice expect amount memory released pool rst pool destroyed relatively small 
note pool running example self reuse guarantee memory safety increase memory consumption 
experiments section produced instances case embedded codes examined 
compiler implementation compiler rst applies type checking stack safety array safety analyses original program 
applies automatic pool allocation transform program described earlier 
modi ed runtime pool allocation library release free memory pool back system heap pool destroyed 
key goal new compiler analysis identify situations lead potential increase memory consumption categorizing pools described 
categorizing pools requires analyzing potential order execution pool operations entire program interprocedural control ow analysis 
automatic pool allocation records information pools function locations calls inserted pool 
pool pointers passed procedures copied address taken pool pointer variable function identi es unique pool 
current pool allocation transformation places calls function containing call pool 
algorithm identifying categorizing reuse pools shown 
say function call site indirectly calls pool operation calls function may directly indirectly call operation 
sets respectively identify call sites function directly indirectly invoke pool sets respectively sets incoming pools formal pool pointer arguments function may directly indirectly call 
consider rst single procedure program containing calls 
analysis traverses paths pool unique pool looking calls appear path 
shown routine 
easy handle pools single linear time traversal control flow graph version gure easier understand 
pool categorized instances paths 
consider input program recursion 
algorithm bottom traversal call algorithms described section easily modi ed calls placed di erently pool allocation 


self reuse 
self reuse cross reuse reuse case self reuse case self cross reuse case example illustrating types reuse behavior pool 
graph computing kinds sets function 
bottom traversal ensures sets computed possible callees function visiting compute sets visit call site add call causes invocation similarly 
add pool encountered 
invoke directly classify pools note distinction local indirect calls pool kinds call sites included 
handle recursive non recursive programs uniformly perform bottom traversal strongly connected components scc call graph 
scc simple iterative algorithm sets propagated function call sites scc sets stabilize functions scc pool stabilized sets propagated function scc call site function outside scc 
applied function current scc explained earlier 

array restrictions general array bounds checking general programs undecidable 
previous designed language restrictions array usage rules fig 
enable complete symbolic checking array accesses 
restriction says index expression array provably ane relationship allocated array size dimension 
described interprocedural constraint propagation algorithm propagates ane constraints integer variables callers callees incoming integer arguments global scalars callees callers integer return values global scalars described 
perform symbolic bounds check index expression integer programming compiler uses omega library maryland 
array safety primary goal evaluate adequacy rules broad range embedded programs relax rules limited ways checked existing compiler integer programming technology 
surprisingly embedded codes typically arrays complex ways control codes studied previous experimental results section show 
practical issue embedded programs signi cant operations string library command line arguments 
added rule fig 
allow certain trusted string library routines 
rule speci es arguments trusted library routines satisfy safety preconditions prevent bu er overruns library routines 
library routines provide constraints relating output routine inputs compiler check bu er string safety 
example expression read fd buf count buf character array safety precondition buf size count constraint return value read read count bytes 
trusted library calls corresponding constraints listed 
library call return value safety conditions read fd buf count count puts memcpy size size size size fp fopen getc strlen strcpy size size size size size size size size size trusted library routines implied constraints preconditions advantage providing trusted routines prede ned constraints including source code analysis fold 
allows body library routine non ane array accesses non typesafe code 
need compute propagate detailed constraints body library routine speeding analysis 
ensure string routines read size array initialize character array characters null 
added rule require program modify character enforce rule excluding element array size expression safety checking 
set call sites may call pool directly indirectly set call sites may call pool directly indirectly set pool arguments may callees set pool arguments may callees function pool pointer ssa variable formal argument local variable call site fi call ai exists path fi ai control flow graph classify case call ai exists path fi ai control flow graph classify case case case classify case program scc callgraph post order change true change false function scc pool pointer variable formal argument local variable call site cs argument function called cs contains contain cs change true add cs argument add contains contain cs change true add cs argument add function scc algorithm identify classify potential memory reuse pools pre conditions return value constraints directly incorporated existing analysis array bounds described 
explain basics approach help example 
char character set null read fd requires size len strlen implies len break 
stuff array usage example prove safety array access rst collect constraints index expression array size expression ssa def edges collect branch conditions de nitions depend control dependence graph 
example array access constraints generate size def edges array declaration note character excluded size len def edges return value constraints library functions strlen read control dependence graph 
induction variable recognition allows generate useful constraints loop index variables renaming variables ssa form allows disregard inconsistent equations induction variables ordinary variables 
complete set constraints generate access size len 
note interprocedural constraint propagation necessary simple example essential realistic applications practice 
add illegal array bounds conditions size example omega library check resulting constraint system satis able 
control ow paths index expression array access evaluate value bounds array 
dynamically allocated arrays size array positive expression 
array accessed inside loop bounds loop provably ane transformations size outer loop index variables vice versa index expression array provably ane transformation vector loop index variables ane transformation size index expression array depends symbolic variable independent loop index variable appears constant term ane representation memory locations accessed provably independent value 
set trusted library routines speci ed preconditions may arguments passed routines satisfy preconditions 
element character array modi ed program 
semantic restrictions array usage constraints proven inconsistent array access safe 
verify precondition trusted library call read simply need check negation precondition size known constraints buf size count results inconsistent system 
size trivially results inconsistent system 
manner generate check preconditions trusted library call program 

results section address key questions ectiveness semantic restrictions compiler techniques check memory safety 
ort required convert existing embedded programs conform semantic restrictions 
pool allocation transformation heap safety analysis powerful enforce pointer heap safety statically di erent embedded programs 

encounter pools categories programs 

array restrictions exible permit existing embedded codes extensive changes 

semantic restrictions static analyses stack safety sucient existing embedded codes 
methodology porting effort test codes derived embedded application benchmark suites mediabench 
consists embedded codes variety domains including telecommunications security networking mediabench predominantly multimedia codes 
program rasta library called source available 
experiments rasta assumed library safe checked safety available source 
benchmarks sizes results shown table 
codes benchmarks accepted current llvm front evaluated new version front near 
lines code changed benchmarks conform rules particularly type safety array safety 
shown third fourth columns table 
largest changes rule rasta union oat array chars swap bytes oat value 
rewrote code shift operations eliminated union 
changes type safety small initializing local pointer variables parent function 
array safety rules rewrite lines code programs 
changes generally minimal obvious 
instance blowfish command line argument accessed iterating checking character null rewritten strlen loop bound 
requiring modi cations changes simple local cases obvious reading code compiler error messages 
believe porting ort compiler standard programs small negligible 
effectiveness pointer heap safety analysis heap pointer safety column table shows compiler able enforce safety heap pointer usage benchmarks studied 
half benchmarks dynamic memory allocation pointers 
benchmarks column shows di erent categories pools 
results show able prove heap safety increase memory consumption case case pools reuse self reuse benchmarks mediabench codes 
codes rasta epic pools pools case incur increase memory consumption 
believe encouraging result 
rasta epic extensive dynamic memory contain pools fall case just pool total pools epic rasta 
fact pools rasta self reuse pool ect freeing memory pools mitigated 
observed case pools epic converted case sophisticated benchmark lines lines code lines code array bounds heap stack safety code modi ed modi ed checker pointer safety type safety array safety case automotive qsort susan case oce security sha blow sh rijndael network dijkstra case crc adpcm codes fft case gsm case multimedia mpeg decode case epic cases rasta cases totals table benchmarks code sizes experimental results compiler analyses pool moved close pool possible compromising safety 
interesting dynamic memory seen dijkstra linked list alive program repeatedly allocates deallocates memory 
language explicit regions cyclone list go garbage collected heap :10.1.1.10.8871
number case pools amenable optimization turning individual object frees entirely ectively performing static garbage collection increase memory usage 
results indicate case occurs infrequently complex embedded codes typically occurs simpler codes 
strong empirical evidence technique powerful enforce heap safety statically broad range embedded codes 
effectiveness stack safety checks stack safety check ensures pointers stack frame function accessible function returns 
column table shows program rijndael failed check 
occurred data structure analysis ow insensitive false positives 
rijndael pointer local variable stored global global reinitialized callee function function returns 
cases handled restructuring program 
results indicate stack safety signi cant obstacle static safety checking approach 
effectiveness array access checks array bounds checker passed benchmarks mediabench changes described earlier 
interestingly tests detected potential array bound violations suite mediabench dijkstra large small versions blowfish violations 
errors ones due incorrect assumptions number command line arguments 
error xed size bu er copy le name obtained command line argument 
cause stack corruption 
array bounds checking algorithm failed prove safety codes 
codes non ane bit operations index variables 
codes indirect indexing arrays 
possible solution aim explore ada style subrange types index expressions attempt prove safety index values computed 
codes memory locations heap store size array load size value function requiring compiler prove heap location modi ed 
believe handled fairly simply interprocedural load value numbering 
safety checking complex array remains signi cant obstacle goal static safety checking broad class embedded applications 
comparison control control codes studied previous control accepted new compiler fully automati cally require explicit single region operations dynamic memory management 
importantly applications case case pools table case pools dicult implement single region restriction control 
programs command line arguments strings library calls accepted array bounds checks control 
new heap analysis improved array access checks help support larger class embedded codes previous program annotations 

related broad approach identify minimal semantic restrictions imperative programs develop new compiler techniques permit complete static checking memory safety runtime checks garbage collection 
knowledge programing language compiler system achieves goal non trivial class programs 
believe results show achieved goal signi cant subclass embedded programs subclass quite broad array bounds checks ignored 
alternative approaches taken eliminate speci types runtime overheads compare approach 
real time speci cation java rt java enables programmers avoid garbage collection entirely subsets heap providing additional types garbage collected 
runtime checks required ensuring safety di erent areas 
type de nes nested scoped regions dynamic allocation 
restrictive runtime overheads pools memory allocated current region requires programmer specify region entry exit points importantly requires runtime checks ensure objects outer scoped region di erent type memory area inner 
rt java inherits runtime checking needs standard java arrays null pointer checks type coercions 
real time garbage collection techniques see incremental collection methods reduce unpredictability garbage collection 
techniques incur fairly high memory overhead achieve acceptable real time behavior times actual space consumption program 
alternative garbage collection languages rt java cyclone adopted mechanisms region memory management :10.1.1.10.8871
languages disallow direct deallocation items region order ensure program safety 
discussed languages key disadvantages relative generally require extensive programmer annotations identify regions provide mechanisms free reuse memory region data structures shrink grow non nested object life times put separate garbage collected heap may incur potentially large increase memory consumption 
cyclone rt java include separate garbage collected heap 
automatic region inference eliminate mitigate rst second successful type safe languages explicit deallocation 
contrast approaches infer regions automatically garbage collection permit explicit deallocation individual data items regions ensure program safety combination homogeneous regions additional static analysis 
potential disadvantages 
prevent certain kinds errors dangling pointer irrelevant correct programs 
second rely heavily interprocedural analysis annotations cyclone languages designed avoid need retain bene ts separate compilation performing analysis link time key advantage llvm compilation framework 
boyapati static type system combining ownership types region types eliminate runtime checks needed ensuring safe region deallocation rt java 
region language di erences discussed 
provide additional mechanism sub regions region sharing region data safely threads counts reclaim data 
support multi threaded applications far 
linear types alias types statically prove memory safety presence explicit deallocation objects 
achieve primarily severe restrictions aliases program far proved practical realistic programs 
languages vault uses type system successfully encode important correctness requirements dynamic resources application le handles sockets :10.1.1.14.7406
attractive vault mechanisms programming environment statically check key correctness requirements system calls trusted libraries 
valuable strategy compiler secure reliable systems proof carrying code pcc 
bene pcc safety checking compiler usually complex unreliable system untrusted simple proof checker reliable required trusted code base 
fundamentally pcc change aspects program require static analysis require runtime checking depends language design compiler capabilities 
pcc orthogonal valuable safety checking compiler outside trusted code base 
extensive static elimination array bounds checks see goal generally eliminate subset bounds checks complete elimination impossible standard languages 
contrast impose carefully chosen language restrictions enable compiler analysis eliminate checks entirely conforming programs 
previous discusses interprocedural bounds checking algorithm compares related 
wagner developed tool detection bu er overrun vulnerabilities general codes 
analysis necessarily imprecise terms generating constraints solving resulting false positives 
contrast precise context sensitive analysis rigorous constraint solver 

described set semantic restrictions compiler techniques enable static checking memory safety signi cant class type safe embedded programs 
semantic restrictions de ned low level language independent type system instruction set implemented languageindependent link time compiler framework 
key new result show automatic pool allocation transformation allows ensure safety dynamic memory management pointer usage static checking garbage collection runtime checks memory operations new syntax 
compiler analysis helps pinpoint infrequent case certain data structures experience increase memory consumption 
results show techniques allow check heap pointer safety embedded programs studied 
previous techniques eliminating null pointer checks stack safety ective nearly programs current analysis checking array complete checking half benchmarks studied 
believe codes certi ed safe compiler execute fast compiled native compiler guaranteeing memory safety 
furthermore usually require minimal simple completely portable rewriting existing programs conform restrictions improving original 
key steps remaining achieve long term goal secure low overhead programming environment techniques 
explore better language compiler support complex array operations 
second provide robust exible runtime environment mechanisms enforce correct usage system calls runtime libraries 
develop architecture tolerates bugs necessarily complex compiler runtime system 

austin breach sohi 
ecient detection pointer array access errors 
proc 
sigplan conf 
programming language design implementation orlando fl june 
bacon cheng rajan 
real time garbage collector low overhead utilization 
proc 
th acm symp 
principles programming languages popl jan 
bodik gupta sarkar 
abcd eliminating array bounds checks demand 
sigplan conf 
prog 
lang 
design implementation june 
gosling 
real time speci cation java 
computer 
boyapati rinard 
ownership types safe region memory management real time java 
sigplan conference programming language design implementation 
crary walker morrisett 
typed memory management calculus capabilities 
conference record popl th acm sigplan sigact symposium principles programming languages san antonio texas pages new york ny 
deline fahndrich 
enforcing high level protocols low level software 
proc 
sigplan conf 
programming language design implementation snowbird ut june 
fahndrich deline 
adoption focus practical linear types imperative programming 
proc 
sigplan conference programming language design implementation june 
gay aiken 
memory management explicit regions 
sigplan conference programming language design implementation pages montreal canada june 
gosling joy steele bracha 
java language speci cation 
sun microsystems 
grossman morrisett jim hicks wang cheney :10.1.1.10.8871
region memory management cyclone 
proc 
sigplan conf 
programming language design implementation june 
ernst austin mudge brown 
free commercially representative embedded benchmark suite 
ieee th annual workshop workload characterization austin tx dec 
jim morrisett grossman hicks cheney wang :10.1.1.127.7825
cyclone safe dialect proc 
usenix annual technical conference june 
kelly maslov pugh rosser wonnacott 
omega library interface guide 
technical report computer science dept maryland college park apr 
adve 
ensuring code safety runtime checks real time control systems 
proc 
conference compilers architecture synthesis embedded systems grenoble oct 
lattner 
llvm infrastructure multi stage optimization 
master thesis computer science dept university illinois urbana champaign urbana il dec 
see llvm cs uiuc edu 
lattner adve 
automatic pool allocation disjoint data structures 
proc 
acm sigplan workshop memory system performance berlin germany jun 
lattner adve 
data structure analysis ecient context sensitive heap analysis 
tech 
report uiucdcs computer science dept univ illinois urbana champaign apr 
lee potkonjak mangione smith 
mediabench tool evaluating synthesizing multimedia systems 
international symposium microarchitecture pages 
levis culler 
mate tiny virtual machine sensor networks 
international conference architectural support programming languages operating systems san jose ca usa oct 
necula 
proof carrying code 
proc 
th acm sigplan sigact symposium principles programming popl paris jan 
necula weimer 
ccured type safe retro tting legacy code 
proc 
th acm symp 
principles programming languages popl london jan 
sha 
dependable system upgrades 
proceedings ieee real time system symposium 
sha 
simplicity control complexity 
ieee software july august 
tofte birkedal 
region inference algorithm 
acm trans 
prog 
lang 
sys 
tofte 
talpin 
region memory management 
information computation pages feb 
wagner foster brewer aiken 
rst step automated detection bu er overrun vulnerabilities 
network distributed system security symposium pages san diego ca february 
walker morrisett 
alias types recursive data structures 
lecture notes comp 
sci vol 

