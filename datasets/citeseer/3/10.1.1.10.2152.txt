meta programming built type equality extended tim sheard ogi sheard cse ogi edu emir ogi cse ogi edu report experience exploring new point design space formal reasoning systems development programming language ngu intended practical programming language logic 
main goal allow programmers describe reason semantic properties programs programming language mainly powerful type system 
illustrate main features developing interesting meta programming example 
show encode set typed simply typed calculus terms data type 
show implement substitution operation terms guaranteed type system preserve typedness 

large semantic gap programmer knows program way express knowledge formal system reasoning program 
reasoning tools built isomorphism hard programmers conceptualize put abstraction 
propose design language important isomorphism concrete proofs real object programmers build manipulate leaving programming language 
explored new point design space formal reasoning systems developed programming language age practical programming language logic 
irreconcilable goals possible embedding logic type system equality qualified types 
design supports construction maintenance propagation semantic properties programs powerful old ideas supported nsf ccr 
supported nsf ccr 
cork ireland july types novel ways 
kind programming language useful 
rest describes possibility 
meta programming mega 
meta programs manipulate object programs represented data 
traditionally programs represented algebraic data types syntactic objects 
representation preserves syntactic properties object language programs impossible represent syntactically incorrect object language programs explore benefits representing object language programs data manner preserve important semantic properties particular scoping typing 
representing typed object languages way preserves semantic properties lead real benefits 
preserving typing scoping properties gain assurance correctness particular language processor compiler interpreter program analysis 
semantics preserving representations statically catch errors introduced incorrect meta language programs 
contributions 
contribution approach manipulating strongly typed object languages manner semantics preserving 
approach encodes typed statically scoped object language programs data types embed type object language program type representation 
done standard extensions haskell type system equality types extension haskell inspired cheney hinze phantom types 
second contribution implementation cheney hinze ideas programming typed object language programs considerably tedious equality types haskell 
implementation supports features extensible kinds staging shall discuss 
integration creates powerful meta programming tool 
third contribution demonstration semantic properties meta programs preserving object language types encoded type meta program programmer need resort meta logic formally assure substitution algorithm preserves typing 
demonstrate implementing type preserving substitution operation object language simply typed calculus 
contribution demonstration techniques support embedding logical frameworks style judgments programming language haskell 
important moves logical style reasoning programs meta logical level programming language 
mega type equality type equality haskell 
key technique inspired described encoding equality types haskell type constructor equal 
non bottom value equal regarded proof proposition equals technique encoding equality types polymorphic function type 
proposed swierstra cheney hinze time described somewhat earlier di erent setting weirich 
illustrate data type equal data equal equal 
cast equal cast equal logical intuition definition known leibniz equality types equal interchangeable context 
context represented arbitrary haskell type constructor 
proofs useful proof equal extract functions cast values type type type contexts 
example construct functions equal equal allow cast types identity context 
furthermore possible construct combinators manipulate equality proofs standard properties equality transitivity reflexivity congruence 
equality types described shall explanation 
essential characteristic programming type equality haskell requirement programmers manipulate proofs equalities types equality combinators 
practical drawbacks 
manipulation proofs combinators tedious 
second program equality proof manipulations real computational content solely leverage power haskell type system accept certain programs typable written proofs 
clutter induced proof manipulation di cult discern di erence truly important algorithmic part program mere equality proof manipulation 
turn programs brittle di cult change 
type equality mega extend type system haskell relatively minor way allow type checker manipulate propagate equality proofs 
type system proposed cheney hinze ideas nd 
remainder shall pure haskell write examples 
conjecture principle possible possible haskell plus usual set extensions expressed cleanly succinctly 
syntax type system designed closely resemble haskell ghc extensions 
practical purposes consider conservative extension haskell 
section briefly outline useful di erences haskell 
equality types encoded explicitly type constructor equal 
built type system implicitly typechecker 
consider fragmentary data type definitions 
adopt ghc syntax writing existential types universal quantifier appears left data constructor 
replace keyword forall symbol 
shall write explicitly universally existentially quantified variables greek letters 
arrow types written 
data exp lit int int var data var 

var data constructor may contain clause contains list equations types scope constructor definition 
equations play role haskell type equal section important di erence 
user required provide actual evidence type equality type checker keeps track equalities types proves propagates automatically 
mechanism nis uses keep track equalities types similar constraints haskell type checker uses resolve class overloading 
special qualified type assert equality types constraint solving system simplify discharge assertions 
assigning type type constructor equations specified clause just predicates qualified type 
constructor lit type int int exp equation int just form predicate similar class membership predicate haskell type example eq bool 
tracking equality constraints 
type checking expression type checker keeps sets equality constraints obligations assumptions 
obligations 
set constraints set obligations 
obligations generated type checker program constructs data values constructors contain equality constraints explicit type signature definition encountered 
example consider type checking expression lit 
constructor lit assigned type int int exp lit polymorphic type variable instantiated int 
instantiating int equality constraint obligation int int trivially discharged type checker 
lit exp int obligation int int practical thing note context data constructors exp var types lit int exp var 
var var important note qualified types instantiated types lit exp int var var var seen lit 
consider case type variable instantiated 
instantiation obligation introduced constructor immediately discharged built equality solver 
leaves instantiated type var 
assumptions 
second set constraints set assumptions facts 
constructor clause pattern matched type equalities added current set assumptions scope pattern 
assumptions discharge obligations 
example consider partial definition exp exp env case exp lit expression exp type exp matched pattern lit equality int definition lit introduced assumption 
type signature induces obligation body definition type 
right hand side case expression type int 
type checker discharge prove obligation int fact introduced pattern lit int 
type checker uses algorithm congruence closure discharge equality obligations 
automatically applies laws equality solve equations 
case equation discharged easily congruence 
mega example substitution shall develop main example meta programming facilities shall define sample object language simply typed calculus judgments implement type preserving substitution function terms 
object language quite simple useful didactic purposes applied techniques wider range meta programs object languages tagless staged interpreters typed imperative languages object languages modal type systems :10.1.1.19.8942
example demonstrates type preserving syntax transformations object language programs 
substitution shall develop remainder transformation 
furthermore correct implementation substitution build syntax syntax transformations shall provide implementation big step semantics uses substitution 
substitution operation preserves typing 
meta program analyzes object language typing judgments builds new judgments result analysis 
expressions types var base weak var var abs app simply typed calculus fragment 
substitutions la slash shift lift explicit substitutions fragment 
simply typed calculus typed substitutions figures define sets typed expressions 
expressions just simply typed calculus 
second defines set typed substitutions 
substitution expressions taken calculus 
ways represent substitutions explicitly terms see er rose excellent comprehensive survey chosen notation simplicity 
substitution expression intended represent mapping de bruijn indices expressions substitution way expressions intended represent functions 
define kinds substitutions see graphical illustration 
slash 
intuitively slash substitution maps variable index variable index var 
shift 
shift substitution adjusts variable indices term incrementing 
maps variable term var 

lift 
lift substitution mark fact substitution applied term context index bound changed 
maps variable index var 
variable index maps term maps provision resulting term adjusted shift 
typing substitutions 
substitution expressions typed 
typing judgments substitutions written indicate type substitution type assignment type assignment 
intuition var var var var 
var var var var 
var 
slash shift lift substitutions substitution typing judgment term variables assigned types applying substitution yields expression variables assigned types example 
describe couple example substitutions 

consider substitution true 
substitution maps variable index boolean constant true 
type substitution true bool 
words type assignment substitution true applied context variable assigned type bool 

consider substitution true 
substitution replaces variable index constant true 
recall type substitution type assignment type assignment written expression substitution applied hold type assign 
applied expression lift substitution true change variable index 
typing know shape 
know know 
type assignments determined sub substitution true yielding typing derivation true bool const bool bool slash bool bool lift typing rules substitutions 
slash 
slash substitution replaces index variable expression context type typing rule requires substitution expressions type assignment index variable assigned type slash substitution decrements indexes variables shifted right place free variables assigned old types substitution applied 
slash 
shift 
shift substitution maps variables var 
term variables assigned type performing shift substitution types type assignment variable move left position 
done appending arbitrary type variable index occur free term substitution performed 
shift 
lift 
variable index term substitution applies shifts resulting term 
index term type assignment remains untouched rest type assignment specified lift applying substitutions 
remainder section show implement function call subst takes substitution expression expression returns expression indices replaced substitution 
simply typed calculus substitution preserves typing expect property true substitution function subst subst subst 
presents judgments describe action substitutions expressions variables respectively 
judgments derived reduction relations calculus 
di cult show reduction strategy implement capture avoiding substitution su cient perform reductions see benaissa lescanne proofs 

implementing substitution mega show implement substitution operation expression substitution judgments expressions substitution expressions 
judgments expression substitution judgments easily encoded data types var exp encode expression variable judgments 
substitution expressions var substitution variables var var var applying substitutions terms data var 
var data exp var 
abs exp 
app exp exp judgment var implements lookup weakening rules variables 
just judgment cases 
constructor constructor translates definition directly clause requires type system prove exists environment environment equal extended 
second constructor takes judgment type var requirement environment equal pair existentially quantified 
names chosen show judgments variable structurally natural number indices 
sub judgments variable case plugged definition exp constructor type expression judgments exp constructed similar fashion 
shall explain abstraction case detail 
constructor abs takes argument judgment type exp expression judgment type type assignment extended assigns variable type 
argument supplied result type abs judgment function type indicated clause 
define data constructor subst gamma delta represents typing judgments substitutions type constructor subst gamma delta represents typing judgment 
data subst gamma delta 
shift subst subst gamma delta exp delta exp gamma subst app app subst subst subst abs abs subst lift subst slash subst slash subst lift subst lift subst shift subst subst shift substitution simply typed calculus 
gamma delta 
slash exp gamma delta gamma del gam 
lift subst gam del delta del gamma gam substitution define substitution function subst 
type subst subst gamma delta exp delta exp gamma takes substitution type delta type assignment gamma expression type typed type assignment delta produces expression type typable type assignment gamma 
discuss implementation function subst detail 
relevant cases shall describe process type checker sure definitions correct types 
recall pattern match exp subst judgments may introduce zero equations types available type checker body case function definition 
type checker may equations prove types equal 
text type variables gamma delta notational convenience skolem constants 
artifact type checker appear pattern matching values may contain existentially quantified variables regarded type constants 

application case line simply applies substitution sub expression judgments rebuilds application judgment results 

abstraction case line pushes substitution abstraction 
may interesting examine types various subexpressions definition 
abs exp delta exp delta subst gamma delta lift subst gamma delta subst lift exp gamma body abstraction type delta type domain abstraction 
order apply substitution body abstraction need substitution type subst gamma delta 
substitution obtained applying lift recursively applying subst lifted substitution body obtain expression type exp gamma construct abstraction exp gamma 

variable slash case line 
cases applying slash substitution variable expression variable 
substitution slash type subst gamma gamma contains expression exp gamma expression type exp delta 
pattern matching introduces equation gamma delta replace 
slash subst gamma gamma exp gamma variable 
pattern matching substitution argument introduces equation delta gamma 
pattern matching expression introduces equation delta gamma gamma 
expression result expression type exp gamma 
type checker uses equalities prove type exp gamma 
congruence prove gamma gamma applying equality obtain exp gamma exp gamma slash subst gamma gamma exp delta 
variable lift case lines 
cases applying lift substitution variable expression 
variable 
case easy lift substitution places changes variable index 
able simply return result 
variable 
pattern lift subst gamma delta substitution introduces equations delta gamma pattern variable var delta introduces equation delta step apply substitution type subst decremented variable index type var type checker show easily follows equations introduced pattern yielding result type exp 
applying shift substitution result yields expression type exp type 
equations prove expression type exp gamma equation gamma 

variable shift case line 
pattern matching shift substitution introduces equation gamma delta 
expression type exp delta 
applying successor variable results expression type exp delta 
immediately type checker equation introduced pattern prove type equal exp gamma 
defined type preserving substitution simply typed calculus judgments 
recall equality proofs encoded haskell possible certain caveats implement function subst haskell couple ghc extensions 
worth noting proven helpful writing complicated functions explicitly manipulating equality proofs function haskell result code verbose di cult understand 

big step evaluator implement simple evaluator big step semantics calculus 
evaluation relation judgment note application case substitution substitute argument variable index body abstraction 
big step evaluator implemented function eval takes typed expression judgment type exp delta returns judgments type 
evaluator reduces redices call name strategy relying substitution implemented 
eval exp delta exp delta eval app case eval abs body eval subst slash body eval note type function eval statically ensures preserves typing object language expressions evaluates usual caveats exps faithfully encode typed expressions 
apply big step evaluator simple example 
consider expression example 
example exp gamma example abs app abs abs app abs example 
expression example evaluates identity function 
applying eval yields precisely result eval example abs exp gamma 
related implementations simple interpreters equality proof objects implemented haskell datatypes weirich swierstra 
swierstra untyped syntax equality proofs encode dynamically typed values 
hinze cheney notion phantom type introduced leijen meijer 
hinze cheney phantom types designed address problems arise equality proofs represent type indexed data 
main motivation provide language polytypic programs generic traversal operations easily written 
cheney hinze system bears strong similarity xi guarded recursive datatypes little general 
adapt cheney hinze ideas meta programming language implementation 
incorporate ideas haskell programming language 
value added additional type system features extensible kinds rank polymorphism applying techniques wide variety applications including typed syntax specification semantics patterns combination staging obtain tagless interpreters encoding logical framework style judgments class values programming language 
simonet pottier proposed system guarded algebraic data types equivalent expressiveness phantom types guarded recursive datatype constructors equality qualified data types 
type system guarded algebraic data types extension hm type system describe type inference algorithm 
prove number important properties type system inference algorithm type soundness correctness 
technique manipulating typedness judgments extensively various logical frameworks 
see advantage translating methodology main stream functional programming idiom 
examples techniques adapted haskell fairly common extensions 
previous techniques programming language extensions described address problem tagless interpreters meta programming :10.1.1.19.8942
tagless interpreters easily constructed dependently typed languages coq cayenne 
languages support staging gained wide audience functional programming community 
programming typed object language syntax applied problem constructing tagless staged interpreters shown possible meta language provisionally called staging dependent types :10.1.1.19.8942
drawback approach industrial strength implementation language 
fact judgment encoding technique basically dependently typed language encode necessary machinery language arguably recognizable haskell programmers 
explicit equality types encoded standard ghc extensions haskell adds ease techniques relieving programmer responsibility explicitly manipulating equality proofs 
technique indexed type systems restricted disciplined form dependent typing write interpreters source source transformations typed terms 
meta language guarded recursive datatype constructors xi roughly equivalent expressive power equipped additional features staging may give wider range useful applications 

discussion meta language implementation 
meta language seen conservative extension haskell built support equality types 
largely inspired cheney hinze 
meta language examples papers functional language ngu language designed similar haskell 
implemented interpreter similar spirit capabilities hugs interpreter haskell 
theoretical demonstrating consistency type equality support functional language carried cheney hinze 
implemented type system features type inference engine combining equality decision procedure manipulate type equalities 
resulting implementation seen deal practice rigorous formal type inference engine required 
polymorphism binding constructs types 
object language example simply typed binding constructs structures index arguments exp want represent object languages universal existential types find way dealing type constructors type functions index arguments judgments di cult haskell currently working extending type system just 
allow apply techniques object languages complex type systems polymorphism dependent types 
logical framework mega 
examples succeed manage encode usual logical framework style inductive predicates type system acquired considerable experience doing typing judgments lists length logical propositions 
needed come formal general scheme translating predicates type constructors explore range expressiveness limitations approach 
intend 

lennart augustsson magnus carlsson 
exercise dependent types typed interpreter 
workshop dependent types programming gothenburg 
available online www cs chalmers se cayenne interp ps 
arthur doaitse swierstra 
typing dynamic typing 
proceedings seventh acm sigplan international conference functional programming icfp pittsburgh pennsylvania usa october sigplan notices 
acm press october 
barras cornes courant herbelin huet munoz murthy parent paulin werner 
coq proof assistant manual version 
technical report inria august 
el benaissa daniel pierre lescanne degli 
calculus explicit substitutions preserves strong normalisation 
journal functional programming september 
cheney hinze 
lightweight implementation generics dynamics 
proc 
workshop haskell pages 
acm press 
james cheney ralf hinze 
phantom types 
available www informatik uni bonn de ralf publications phantom pdf 
robert harper furio honsell gordon plotkin 
framework defining logics 
proceedings symposium logic computer science pages washington june 
ieee computer society press 
conference held cornell university ithaca new york 
jones 
hugs user manual 
mark jones 
qualified types theory practice 
phd thesis college oxford university 
leijen erik meijer 
domain specific embedded compilers 
proceedings nd conference domain specific languages pages berkeley ca october 
usenix association 
greg nelson derek oppen 
fast decision procedures congruence closure 
journal acm april 
bengt nordstrom kent peterson jan smith 
programming martin lof type theory volume international series monographs computer science 
oxford university press new york ny 
currently available online authors homepage 
emir 
heterogeneous meta programming 
phd thesis oregon health sciences university ogi school science engineering 
forthcoming 
emir walid taha tim sheard :10.1.1.19.8942
tagless staged interpreters typed languages 
international conference functional programming icfp pittsburgh usa october 
acm 
frank pfenning carsten 
system description twelf meta logical framework deductive systems 
harald ganzinger editor proceedings th international conference automated deduction cade volume lnai pages berlin july 
springer verlag 
er rose 
explicit substitution tutorial survey 
technical report ls brics october 
brics lecture series 
tim sheard emir nathan linger 
mega implementation 
available request author 
vincent simonet francois pottier 
constraint type inference guarded algebraic data types 
submitted publication july 
martin sulzmann martin odersky martin 
type inference constrained types 
fool th 
int 
workshop foundations object oriented programming languages january 
stephanie weirich 
type safe cast functional pearl 
proceedings acm sigplan international conference functional programming icfp volume acm sigplan notices pages september 
acm press 
hongwei xi chen gang chen 
guarded recursive datatype constructors 
cindy norris jr james editors proceedings th acm sigplan sigact symposium principles programming languages popl volume acm sigplan notices pages new york january 
acm press 
xi frank pfenning 
dependent types practical programming 
conference record popl th acm sigplan sigact symposium principles programming languages san antonio texas pages new york ny january 
acm 

acknowledgment described supported national science foundation ccr 
