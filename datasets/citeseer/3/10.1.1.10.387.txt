clotho transparent data versioning block level department computer science university toronto king college road toronto ontario canada tel fax mail cs toronto edu storage management emerged main problems building cost effective storage infrastructures 
issues contribute management complexity storage systems maintaining previous versions data 
till functionality implemented high level applications filesystem level 
modern systems aim higher scalability employ management entities filesystems 
propose pushing versioning functionality closer disk advantage modern block level storage devices 
clotho storage block abstraction layer allows transparent automatic data versioning block level 
clotho provides set mechanisms build flexible higher level version management policies range keeping data modifications version capturing triggered timers system events 
find approach promising offloading significant management overhead complexity higher system layers disk concrete step building self managed storage devices 
specific contributions implement clotho new layer block hierarchy linux demonstrate versioning performed block level transparent manner 
ii investigate impact path performance overhead microbenchmarks spec sfs real filesystems ext fs 
iii examine techniques reduce memory disk space required metadata information 

storage currently emerging major problems building tomorrow computing infrastructure 
systems provide tremendous storage cpu pro department computer science university crete box heraklion gr greece angelos institute computer science foundation research technology box gr heraklion greece tel fax mail ics forth gr cessing network transfer capacity cost efficient manner able process store increasing amounts data 
cost managing large amounts stored data dominant complexity cost factor building operating modern storage systems 
studies show storage expenditures represent typical server purchase price applications oltp line transaction processing erp enterprise resource planning percentages keep growing 
furthermore cost storage administration estimated times purchase price storage hardware :10.1.1.130.3029:10.1.1.101.3227
building self managed storage devices reduce management related overheads complexity paramount importance 
cumbersome management tasks requires human intervention creating maintaining recovering previous versions data archival durability reasons 
problem exacerbated capacity scale storage systems increases 
today backup main mechanism serve needs 
traditional backup systems limited functionality provide 
usually incur high access restore overheads magnetic tapes impose coarse granularity allowable archival periods usually day result significant management overheads :10.1.1.101.3227
automatic versioning conjunction increasing disk capacities proposed method address issues :10.1.1.101.3227
particular magnetic disks cheaper larger projected disk storage soon competitive tape storage 
advent inexpensive high capacity disks perform continuous real time versioning maintain online repositories archived data 
online storage versioning offers new range possibilities compared simply recovering users files available today sive high storage systems recovery user mistakes 
users recover accidentally deleted modified data rolling back saved version 
recovery system corruption 
event malicious incident system administrators quickly identify corrupted data recover previous consistent system state 
historical analysis data modifications 
necessary understand piece data reached certain state versioning proves valuable tool 
goal provide online storage versioning capabilities commodity storage systems transparent cost effective manner 
storage versioning previously proposed examined purely filesystem level block level filesystem aware 
approaches versioning intended large centralized storage servers appliances 
argue build self managed storage systems versioning functionality pushed lower system layers closer disk offload higher system layers 
possible underlying technologies drive storage systems 
disk storage network bandwidth processor speed main memory reaching speeds capacities possible build cost effective storage systems significant processing capabilities able store vast amounts information provide advanced functionality 
approach providing online storage versioning provide related functionality block level 
approach number advantages compared approaches try provide features application filesystem level 
provides higher level transparency particular completely filesystem agnostic 
instance versioned volumes multiple third party filesystems need modifications 
data snapshots taken demand previous versions accessed online simultaneously current version 
second reduces complexity higher layers storage systems filesystem storage management applications 
third takes advantage increased processing capabilities memory sizes active storage nodes expensive host processing overheads disk subsystem increasing scalability storage archival system 
block level versioning poses certain challenges memory disk space overhead access blocks information depending application data access patterns increased danger higher space overhead storing previous versions data related metadata 
ii path performance overhead clear cost versioning functionality provided block level 
iii consistency versioned data versioned volume conjunction filesystem 
iv versioning granularity versioning occurs lower system layer information content data available instance case versioning implemented filesystem application level 
access full volumes opposed individual files 
design clotho system provides versioning block level addresses issues demonstrating done minimal space performance overheads 
clotho low memory space overhead uses novel method avoid copy write costs versioning extent size larger block size 
furthermore clotho employs line differential compression reduce disk space overhead archived versions 
second advanced disk management algorithms clotho operation reduced cases simply manipulating pointers memory data structures 
clotho common path overhead follows rapidly increasing processor memory curve depend lower disk speeds 
third clotho deals version consistency providing mechanisms higher system layers guarantee data consistent mark data files 
believe volumes appropriate granularity versioning policies 
amounts information need managed specifying volume wide policies placing files volumes appropriate properties result efficient data management 
implement clotho additional layer driver hierarchy linux 
implementation approach allows clotho flexibility inserted different points block layer hierarchy single machine clustered system san 
clotho works simple block devices standard disk driver advanced device drivers volume managers hardware software raids 
furthermore implementation provides higher layers abstraction standard block device disk drivers volume storage managers object stores filesystems 
evaluate implementation microbenchmarks real filesystems spec sfs suite nfs 
main memory overhead clotho metadata kbytes gbyte disk space reduced larger extents 
performance overhead clotho operations clotho fates ancient greek mythology spins thread life mortal 
minimal may change behavior higher layers including filesystem especially implicit assumptions underlying block device location disk blocks 
cases design layers system tuning necessary degrade system performance 
find approach promising offloading significant management overhead complexity higher system layers disk concrete step building self managed storage systems 
rest organized follows 
section 
presents design discusses related challenges building block level versioning systems 
section 
presents implementation 
section 
presents experimental evaluation results 
section 
discusses related section 
presents limitations 
section 
draws 

system design design clotho driven high level goals challenges flexibility transparency 
low metadata footprint low disk space overhead 
low overhead common path operation 
consistent online snapshots 
discuss address challenges separately 

flexibility transparency clotho provides versioned volumes higher system layers 
volumes look similar ordinary physical disks customized user defined policies keep previous versions data store 
essentially clotho provides set mechanisms allow user add time dimension managing data creating manipulating volume versions 
piece data passing clotho indexed location block device time block written 
new version created subsequent write block create new block preserving previous version 
multiple writes data block versions result overwriting block 
clotho device versions captured demand automatically prespecified periods 
user view access previous versions data online independent block devices current version 
user compact delete previous volume versions 
focus mech clotho provides simple policies implemented tested 
expect systems administrators define policies context higher level storage management tools 
clotho provides set primitives mechanisms higher level policies automatic version management provides mechanism capturing lower level block device state version 
explicitly removes previously archived version reclaims corresponding volume space 
shows saved version specific block device 
enables creating virtual device corresponds specific version volume accessible read mode 
provide ability compact existing versions reducing disk space overhead 
versions volume properties version identified unique version number integer counter starting value increasing new version 
version numbers associated timestamps presentation purposes 
blocks device accessible higher layers period time part version volume taken moment identified version number 
archived versions exists solely read state higher levels block hierarchy distinct virtual read block device 
latest version device readable writable exists entire lifetime clotho operation deleted 
clotho inserted arbitrarily system layered block hierarchy 
stackable driver concept employed design block level abstractions software raid systems volume managers clean flexible manner 
input higher layer filesystem block level abstraction application raid volume manager storage system 
clotho accepts block requests read write ioctl layer 
similarly output lower layer block device block level abstraction 
design provides great flexibility configuring system block device hierarchy 
shows possible configurations clotho 
left part clotho operates top physical disk device 
middle clotho acts wrapper fs database nfs clotho versioning layer disk virtual block volume disk disk single virtual volume constructed volume manager abstracts multiple physical disks 
configuration clotho captures versions virtual volume 
right side clotho layered top raid controller adds reliability system 
result storage volume versioned tolerate disk failures 
higher level abstractions built top existing block devices assume device fixed size rare exceptions filesystems 
space taken previous versions data clotho depends number amount modified data 
clotho provide fixed size block device abstraction higher layers dynamically devices higher layers support 
device initialization time clotho reserves configurable percentage available device space keeping previous versions data 
essentially partitions logically physically capacity wrapped device logical segments illustrated 
primary data segment pds contains data current latest version backup data segment bds contains data archived versions 
bds full clotho simply returns appropriate error code user reclaim parts bds deleting compacting previous versions moving device 
operations performed automatically module implements high level data management policies 
latest version block device continues available usable times 
clotho enforces capacity segmentation reporting total size input layer size pds 
space reserved storing versions hidden input layer accessed managed api provided clotho 
clotho metadata needs saved output device actual data 
losing metadata indexing extents render data stored block hierarchy unusable 
similar fs database nfs clotho versioning layer disk clotho versioning layer disk clotho block device hierarchy 
fs database nfs raid controller disk 
disk block level abstractions volume managers software raid devices 
clotho stores metadata output device periodically 
size metadata depends size encapsulated device extent size 
general clotho metadata metadata typical filesystem saving stable storage issue 

reducing metadata footprint main types metadata clotho logical extent table lxt device version list device superblock dsb 
logical extent table lxt structure logical physical block translation 
clotho presents input layer logical block numbers opposed physical block numbers provided wrapped device 
note block numbers need directly correspond actual physical locations block abstraction volume manager lvm output layer 
clotho uses lxt translate logical block numbers physical block numbers 
device version list list versions output device available higher layers separate block devices 
existing version stores version number virtual device may linked version creation timestamp number flags 
device superblock dsb small table containing important attributes output versioned device 
stores information capacity input output device space partitioning size extents sector block size current version counter number existing versions usage counters 
lxt demanding type metadata conceptually array indexed block numbers 
basic block size block devices varies bytes size disk sector kbytes 
results metadata input layer capacity primary data segment backup data segment output layer capacity logical space segments clotho 
large memory requirements 
instance disk storage kbyte blocks lxt entries 
current version clotho lxt entry bits bytes 
include bits block addressing bits versions allow practically unlimited number versions 
lxt requires gbytes disk storage 
note bit address space kbyte blocks address storage 
reduce footprint lxt time increase addressing range lxt extents opposed device blocks basic data unit 
extent set consecutive logical physical blocks 
extents thought clotho internal block size configure arbitrary sizes kbytes mbytes 
similarly physical logical blocks denote extents logical input extents physical output extents 
implemented tested extent sizes ranging kbyte kbytes 
kbyte extents addressing need mbytes memory storage 
kbyte extent size address storage 
large extent sizes may result significant performance overhead 
extent size operating system block size clotho block devices kbytes clotho receives operating system full extent create full version 
extents larger maximum size clotho sees subset extent needs create new version 
needs copy rest extent new version small portion written higher system layers 
copy significantly decrease performance common path especially large extent sizes 
large extents desirable reducing metadata footprint 
operating systems support blocks maximum size linux may result severe performance overheads 
kbyte extent device block size input output kbytes kbyte extent kbyte valid bitmap addressing large extents 
address problem addressing 
small bit bitmap lxt entry need copy extent partial update 
just translate block write size mark bitmap valid just bit 
subsequent read operation search valid lxt translating read operation 
kbyte extent size need bits bitmap kbyte 
possible approach reduce memory footprint store part metadata main memory perform swapping active metadata stable storage 
solution adequate storage systems large amounts data need addressed 
orthogonal addressing combined 

version management overhead version management operations performed negligible cost manipulating memory data structures 
creating new version clotho involves simply incrementing current version counter involve copying data 
called clotho stalls incoming requests time required flush outstanding writes output layer 
synchronized stable storage clotho increases current version counter appends new entry device version list creates new virtual block device access captured version output device explained 
version linked exactly virtual device os specific device number sends request retrieve request version 
fact device versioning low overhead operation possible create flexible versioning policies 
versions created external processes periodically system events 
instance user processes specify requires new version hour files device closed single write device 
mechanisms detect events open files device may currently implemented clotho provided system components 
order free backup disk space clotho provides mechanism delete volume versions 
operation clotho traverses primary lxt segment entry version number equal delete candidate changes version number existing version number 
traverses backup lxt segment frees related physical extents 
version creation operations version deletion performed memory overlap regular provided higher layer order implement version cleaning policies 
storage space finite policies necessary order continue versioning running backup storage 
backup data segment bds full primary data segment latest version data continue interruption 

common path overhead consider common path clotho path read write latest current version output block device versioning occurs frequently 
accesses older versions importance expected occur frequently current version usage 
accordingly divide read write access volume versions categories accesses current version accesses previous version 
main technique reduce common path overhead divide lxt logical segments corresponding primary backup data segments output device illustrated 
primary segment lxt mentioned figures equal number logical extents input layer allow direct mapping logical extents physical extents current version output device 
direct mapping clotho locate physical extent current version data block single lookup primary lxt segment translating requests current version versioned device 
input device needs access previous versions versioned output device multiple accesses lxt required locate appropriate version requested extent 
find physical extent holds specific version requested block clotho primary lxt segment entry locate current version requested extent single table access 
uses linked list represents version history extent locate appropriate version requested block 
depending type request state requested block requests categorized follows write requests performed current version device older versions read 
clotho locate lxt entry current version extent single lxt access 
write requests kinds shown writes new unallocated blocks 
case clotho calls extent allocator module returns available physical extent output device updates corresponding entry lxt forwards write operation output device 
extent allocation policy current implementation scan type policy starting pds 
free extents ignored reach device rewind allocation pointer start allocating free extents 
writes existing blocks modified snapshot captured version number equal current version number 
case clotho locates corresponding entry primary lxt segment single lookup translates request block address existing physical block number output device 
note case blocks updated place 
writes existing blocks modified snapshot captured version number lower current version number 
data existing physical extent overwritten new data written different location new version extent created 
clotho allocates new lxt entry backup segment swaps old new lxt entries old moved backup lxt segment 
block address translated new physical extent address request forwarded output layer 
swapping lxt entries maintains mapping current version logical extents lxt optimizes common path single lxt lookup 
write translation algorithm allows independent fine grain versioning extent level 
extent lxt versioned updates input level 
extents updated versions extents written frequently 
read request translation illustrated 
clotho determines desired version device virtual device name number request dev clt corresponds version dev clt version 
clotho traverses version list lxt specific extent locates appropriate physical block 
input logical extents lxt output physical extents write write write type type type direct mapping arbitrary mapping move old lx link overwrite allocate keep allocate old px new px old px new px write write translation path write requests 
previous versions clotho device appear different virtual block devices 
higher layers filesystems devices access old versions data 
device id read request different normal input layer device id read request refers extent belonging previous version 
clotho determines device id version extent requested 
traverses version list associated extent locate backup lxt entry holds appropriate version logical extent 
translation process illustrated 

reducing disk space requirements clotho operates block level induced overhead amount space needs store data updates 
application instance file modifies consecutive bytes file clotho create new version full block contains modified data 
reduce space overhead clotho provide differential content compaction mechanism describe 
clotho provides user ability compact device versions able transparently access online 
policy decision compact version left higher layers system similarly policy decisions clotho 
form binary differential compression store data modified version capture 
called clotho constructs differential encoding delta blocks belong version corresponding blocks previous version 
lot differential policies applied case compare content specific version version previous version stage explore diff read request latest version input logical extents lxt output physical extents direct mapping read request older version lookup backup input logical extents lxt output physical extents read physical extents arbitrary mapping translation path read requests 
reading compact lx direct mapping lookup backup diff lx arbitrary mapping ancestor px compact px stores multiple read translation compact versions 
ing previous version 
furthermore versions compressed independently differential compression algorithms lempel ziv encoding wheeler burrows encoding scope :10.1.1.118.8921
envision functionality provided layers device stack 
differential encoding algorithm works follows 
compaction operation triggered algorithm runs backup data segment lxt locates extents belong version consideration 
extent previous version compacted 
extents compacted algorithm locates previous version diffs extents writes diffs physical extent output device 
diff size greater threshold effective clotho discards pair proceeds extent version compacted 
words clotho differential compression algorithm works selectively physical extents compacting extents reduced size 
rest left normal format avoid performance penalties necessary reconstruction 
compacted form extent requires size physical extent algorithm stores multiple deltas physical extent effectively imposing different structure output block device 
furthermore compacted versions multiple entries lxt may point physical extent 
related entries lxt ancestor extent kept clotho metadata 
physical extents freed compaction reused storage 
shows sample lxt mappings compacted version output layer 
data compacted version accessed transparently online data volumes 
clotho follows path locate appropriate version logical extent lxt 
recreate original full extent data need differential data previous version logical extent 
information clotho reconstruct requested block return input driver 
evaluate related overheads section 
clotho supports recursive compaction devices 
version compacted version compacted 
compacted versions original state reverse process 
side effect differential encoding concept creates dependences consecutive versions logical extent affects way versions accessed explained 
deleting versions clotho checks dependencies compacted versions previous version delete extents required un versions deleted 
logical extents marked shadow attached compacted version 
left higher level policies decide keeping blocks increases space overhead better related version delete shadow logical extents 

consistency main issues block device versioning arbitrary times consistency stored data 
levels consistency online versioning system state consistency refers consistency system buffers data structures path 
deal clotho flushes device buffers kernel filesystem metadata version creation 
guarantees data metadata block device correspond valid snapshot filesystem point time 
consistency issues internal system data structures 
open file consistency filesystem top versioned device certain files may open time snapshot 
clotho deal issue provides mechanism assist users 
new version created clotho user level module queries system open files particular device 
files open clotho creates special directory links open files includes directory archived version 
accessing older versions user find files open versioning time 
application consistency applications versioned volume may specialized notion consistency 
instance application may files updated atomically 
version created file updated closed second open updated files open version creation application data may inconsistent 
type consistency possible deal transparently application knowledge support addressed clotho 

system implementation implemented clotho block device driver module linux kernel user level control utility lines code 
kernel module loaded runtime configured output layer device means command triggered user level agent 
configuring output layer device user manipulate clotho block device depending higher layer want 
instance user build filesystem top clotho device regular filesystem 
module adheres framework block devices linux kernel provides interfaces user programs command interface proc interface device information statistics 
operations described design section create delete manage version implemented ioctl interface initiated user level agent 
proc interface provides information device version readable ascii files 
clotho uses interface report number statistics including times creation version time span size modified data previous version specific information compacted versions compaction level number shadow extents 
clotho module uses zero copy mechanism request fn fashion lvm 
mechanism clotho able translate device driver id sector address block re throughput kbytes sec bonnie performance write rewrite read disk write clotho write clotho read disk read disk rewrite clotho rewrite block size kbytes bonnie throughput write rewrite read operations 
quest struct buffer head redirect devices minimal overhead 
achieve persistence metadata clotho uses kernel thread created module load time flushes metadata output layer configurable currently intervals 
virtual device creation uses partitionable block device concepts linux kernel 
limit linux kernel minor numbering minor numbers specific device versions seen simultaneously partitions clotho 
number partitions supported clotho larger 
overcome limitation created mechanism call allows user link unlink demand available versions minor number partitions clotho device 
mentioned partitions read normal block device mounted mount point 

experimental results experimental environment consists identical pcs running linux 
system pentium iii mhz cpus mbytes ram ibm ata hard disk drive capacity mbytes mbyte cache mbps ethernet nic 
operating system red hat linux smp kernel 
experiments performed gbyte partition ibm disk 
kbyte extent need mbytes memory gbyte partition 
number system parameters worth investigation evaluate clotho respect parameters memory performance overhead 
extent sizes kbytes 
smaller extent sizes seeks sec bonnie performance seek disk clotho block size kbytes bonnie seek read performance 
higher memory requirements 
gbyte partition clotho kbyte extent size uses mbytes inmemory metadata dirty parts flushed disk seconds 
evaluate clotho microbenchmarks bonnie version house developed microbenchmark real life setups production level filesystems 
bonnie benchmark publicly available filesystem benchmark 
real life setup run spec sfs suite top known linux filesystems ext fs high performance 
results label disk denote experiments regular disk clotho driver top 

bonnie bonnie microbenchmark quantify basic overhead clotho 
filesystem bonnie experiments ext fs kbyte extent size 
size file tested gbytes block sizes ranging kbyte kbytes 
measure accesses latest version volume operations block write large file created system call 
block rewrite block file read read rewritten requiring 
block read file read block 
random seek processes running parallel performing random locations file read ing corresponding file blocks 
average response time msec operation spec sfs response time vs load kb extents clotho reiser ver 
disk ext fs disk reiser fs clotho reiser min ver 
clotho reiser min ver 
clotho ext ver 
clotho ext min ver 
clotho ext min ver 
requested load nfs operations second spec sfs response time kbyte extents 
average response time msec operation spec sfs response time vs load kb sub extents clotho rfs ver 
disk ext fs disk reiser fs clotho rfs min ver 
clotho rfs min ver 
clotho ext ver 
clotho ext min ver 
clotho ext min ver 
requested load nfs operations second spec sfs response time kbyte extents rfs denotes 
shows overhead write throughput minimal curves practically 
read throughput case clotho performs slightly better regular disk 
believe due logging sequential disk allocation policy clotho uses 
rewrite case overhead clotho significant 
due random seek read operation overhead shown 
seeks experiment random clotho logging allocation effect overhead translating requests flushing filesystem metadata disk dominates 
case overhead observed regular disk 

spec sfs spec sfs benchmark suite measure nfs file server throughput response time clotho 
nfs client nfs server 
systems serve client server measured throughput operations sec measured throughput operations sec spec sfs req 
load vs measured load kb extents clotho ext min ver 
clotho ext min ver 
clotho ext ver 
clotho reiser min ver 
clotho rfs min ver 
disk reiser fs disk ext fs clotho reiser ver 
requested load nfs operations second spec sfs throughput kbyte extents 
spec sfs req 
load vs meas 
load kb sub extents clotho ext min ver 
clotho ext min ver 
clotho ext ver 
clotho rfs min ver 
clotho rfs min ver 
disk reiser fs disk ext fs clotho rfs ver 
requested load nfs operations second spec sfs throughput kbyte extents rfs denotes 
connected switched mbit ethernet network 
settings nfs version protocol udp ip nfs exported directory max read max write requested loads ranging nfs operations increment step 
warm run time seconds run time spec sfs runs sequence approximately hours 
mentioned report results ext fs option filesystems 
new filesystem created experiment 
conduct experiments spec sfs filesystems plain disk clotho disk versioning clotho versioning minutes clotho minute versioning 
versioning performed entire hour run spec sfs 
figures show throughput latency results kbyte extents figures show results kbyte extents addressing 
read throughput kbytes sec packed vs unpacked snapshots random read throughput packed snapshot packed snapshot packed snapshot packed snapshot packed snapshot read buffer size kbytes random compact read throughput 
results show clotho outperforms regular disk cases versioning 
higher performance due logging sequential block allocation policy clotho uses 
explanation reinforced performance cases versions created periodically 
case frequent versioning prevents disk seeks caused overwriting old data written new locations disk sequential fashion 
furthermore observe frequent versioning higher performance 
kbyte extent size experiments figures show lower memory requirements mapping offers performance kbyte case 
attribute small difference disk rotational latency skipping unused space write kbyte extent size extents written back back sequential manner 
comparing filesystems ext find performs worse top clotho 
attribute behavior metadata management 
ext updates metadata place appends metadata updates journal 
technique combination clotho logging disk allocation appears negative effect performance spec sfs workload compared ext 

compact version performance measure read throughput compacted versions evaluate space time tradeoff diff compaction 
old versions accessible read mode developed phase microbenchmark performs operations 
stage microbenchmark writes number large files captures multiple versions data clotho 
writing data benchmark able control amount average response time msec operation packed vs unpacked snapshots random read latency packed snapshot packed snapshot packed snapshot packed snapshot packed snapshot read buffer size kbytes random compact read latency 
similarity versions percentage space required compacted versions 
second stage benchmark mounts compacted version performs random read operations files compacted version 
run benchmark flushes system buffer cache 
figures latency throughput results different percentages compaction 
compaction compacted version takes minimal space disk case compaction 
difference performance mainly due higher number disk accesses read operation required compacted versions 
read operation requires disk reads reconstruct requested block 
read fetch block previous version fetch diffs 
particular compaction read results disk accesses performance half compaction case 

related number projects highlighted importance issues storage management :10.1.1.115.4299
goal define innovative functionality storage protocols apis reduce management overheads 
block level versioning discussed file system designed network appliance nfs appliance 
works block level filesystem create snapshots volume keep available online nfs 
filesystem works nfs appliance approach depends filesystem 
demonstrate clotho filesystem agnostic presenting experimental data production level filesystems 
manage limited number versions clotho manage practically unlimited number 
authors mention performance compared general purpose file systems runs specialized nfs appliance performance comes nfs specific tuning 
authors compare performance filesystem block snapshots 
advocate block level backup due cost performance reasons 
provide evidence performance overhead block level versioned disks compared regular non versioned block devices 
thoroughly evaluate microbenchmarks standard workloads 
extension introduces management remote replicas snapshots optimize data transfer ensure consistency 
venti block level network storage service intended repository backup data 
venti follows write storage model uses content addressing means hash functions identify blocks identical content 
clotho uses differential compression concepts 
furthermore venti versioning features 
clotho venti designed perform complementary tasks version data repository store safely archived data blocks network 
distributed block level versioning support included petal 
concepts similar clotho petal targets networks workstations opposed active storage devices 
backup archival data important problem products available try address related issues 
specific information systems performance commodity hardware filesystems known benchmarks scarce 
live backup captures changes file level client machines sends modifications back server archives previous file versions 
emc runs storage servers block level uses copy write algorithm 
capture snapshots copy algorithm logging block allocation speed writes 
copies old block data hidden storage space write overwriting block 
veritas software works inside veritas file system clotho filesystem agnostic 
furthermore supports snapshots volumes 
sun instant image works sun storage servers 
operation appears similar clotho 
drivers programs sun architecture runs solaris architecture filesystem aware 
systems especially commercial ones uses proprietary customized hardware system software comparisons commodity hardware general purpose operating systems difficult 
systems intended standalone services centralized storage appliances clotho designed transparent autonomous layer active storage devices appropriate pushing functionality closer physical disk 
direction clotho categorizes challenges implementing block level versioning addresses related problems 
authors examine possibility introducing additional layer device stack provide certain functionality lower system layers affect functionality provided filesystem 
efforts direction include logical volume management storage virtualization try create higher level abstraction top simple block devices 
authors survey systems linux 
systems usually provide abstraction block level volume partitioned aggregated expanded shrunk demand 
efforts add raid capabilities arbitrary block devices 
complementary efforts proposes adding versioning capabilities block device level 
previous versioning data performed filesystem layer higher layers 
authors propose versioning data file level discussing filesystem transparently maintain file versions cleaned 
authors try achieve similar functionality providing mount points previous versions directories files 
propose solution require kernel level modification relies set user processes capture user requests files communicate back storage server archives previous file versions 
similar efforts approach problem filesystem level provide ability checkpointing data explicitly manage time additional file attribute 
self securing storage filesystem target secure storage systems operate filesystem level 
versioning concepts self securing storage similar clotho numerous differences 
significant self securing storage policies intended data archiving retain versions data short period time called detection window 
versions guaranteed exist outside window time version management control provided specifying higher level policies 
introduces certain interesting concepts reducing metadata space geared security intended archival purposes 
certain concepts similar clotho believe block level self secure storage system clotho separating orthogonal versioning security functionalities different subsystems 

limitations main limitation clotho layered abstractions aggregate multiple block devices single volume shared block devices transparently 
clotho layered volume abstraction performs aggregation top block devices aggregated single volume policies creating versions need perform synchronized versioning devices ensure data consistency 
may possible transparent manner higher system layers 
main issue clear semantics versioning parts coherent larger volume 
furthermore multiple clients access shared block device usually case distributed block devices clotho layered top shared volume client internal metadata inconsistent clotho instances :10.1.1.130.3029
solutions problems interesting topics 
limitation clotho imposes change block layout input output layer 
clotho acts filter block devices transferring blocks data layer 
introduce new issues wasting space due fragmentation files filesystem clotho alters significantly data layout 
may affect performance free blocks scattered disk higher layers rely specific block mapping block block disk block second issue clotho layer hierarchy performs block remapping raids volume managers 
subsystems complex provide functionality general solutions problem may necessary 
scope discuss 

storage management important problem building storage systems 
online storage versioning assist reduce costs directly addressing data archival retrieval costs indirectly providing novel stor age functionality 
propose pushing versioning functionality closer disk implementing block device level 
approach takes advantage technology trends building active self managed storage systems address issues related backup version management 
detailed design system clotho provides versioning block level 
clotho imposes small memory disk space overhead version data metadata management large extents addressing diff compaction 
imposes minimal performance overhead path eliminating need copy write extent size larger disk block size employing logging sequential disk allocation 
provides mechanisms dealing data consistency allows flexible policies manual automatic version management 
implement system linux operating system evaluate impact path performance microbenchmarks spec sfs standard benchmark top production level file systems 
find common path overhead minimal read write operations versions compacted 
compact versions user pay penalty double disk accesses operation accesses compact block 
believe approach promising offloading significant management overhead complexity higher system layers disk concrete step building self managed storage devices 

acknowledgments acknowledge support natural sciences engineering research council canada canada foundation innovation ontario innovation trust nortel institute technology communications information technology ontario nortel networks general secretariat research technology greece 
ajtai burns fagin long stockmeyer 
compactly encoding unstructured inputs differential compression 
journal acm 
anderson hobbs keeton spence veitch 
running circles storage administration 
proceedings fast conference file storage technologies fast pages berkeley ca jan 
usenix association 
burrows wheeler 
block sorting lossless data compression algorithm 
technical report 

bonnie 
www com au bonnie 
cox murray noble 
pastiche making backup cheap easy 
proceedings th symposium operating systems design implementation osdi berkeley ca dec 
usenix association 
de jonge kaashoek hsieh 
logical disk new approach improving file systems 
proc 
th sosp pages 
edward lee thekkath 
petal distributed virtual disks 
proceedings asplos vii oct 
emc 
data sheet 
www emc com pdf products ds pdf 
doyle thompson 
panel report data storage technologies 
international technology research institute 
world technology division june 

total cost storage ownership approach sept 
gibson nagle amiri butler chang gobioff hardin riedel zelenka 
cost effective high bandwidth storage architecture 
proc 
th asplos oct 
gibson wilkes 
self managing storage 
acm computing surveys es dec 
gray 

remaining problems information technology turing lecture 
acm federated computer research conferences may 
hitz lau malcolm 
file system design nfs file server appliance 
proceedings winter usenix conference pages 
hutchinson manley harris hitz kleiman malley 
logical vs physical file system backup 
proc 
rd usenix symposium operating systems design impl 
osdi feb 
kubiatowicz bindel chen eaton geels gummadi rhea weatherspoon weimer wells zhao 
oceanstore architecture global scale persistent storage 
proceedings acm asplos november 
lesk 
information world 
www lesk com html 
molnar 
linux raid code 
apr 
moran lyon incorporated 
file revisited 
proc 
usenix summer technical conference june 


www com 
olson 
design implementation inversion file system 
proc 
usenix winter technical conference jan 
patterson 
uc berkeley istore project bringing availability maintainability evolutionary growth storage clusters 
roc cs berkeley edu january 
patterson manley hitz kleiman 
file system asynchronous mirroring disaster recovery 
proceedings fast 
usenix jan 
pike presotto thompson trickey 
plan bell labs 
proc 
summer conference 

dfs time oriented file server 
proceedings usenix winter technical conference jan 
feeley hutchinson veitch 
deciding forget elephant file system 
proceedings th sosp dec 
sean quinlan sean dorward 
venti new approach archival data storage 
proceedings fast pages 
usenix jan 
soules goodson strunk ganger 
metadata efficiency versioning file systems 
proceedings fast conference file storage technologies fast berkeley ca apr 
usenix association 

delivering real time data protection easy disaster recovery windows workstations 
www com files whitepaper doc jan 
strunk goodson soules ganger 
self securing storage protecting data compromised systems 
proceedings th symposium operating systems design implementation osdi pages berkeley ca oct 
sun microsystems 
instant image white 
www sun com storage white papers ii soft arch pdf 

volume managers linux 
proceedings usenix technical conference june 
thekkath mann lee 
frangipani scalable distributed file system 
proceedings th sosp volume operating systems review pages new york oct 
acm press 
veitch riedel towers wilkes 
global storage management data placement 
eighth ieee workshop hot topics operating systems hotos viii pages 
ieee computer society press may 
veritas 

eval veritas com downloads pro guide wp pdf 
wilkes 
traveling rome qos specifications automated storage system management 
proc 
int 
workshop qos iwqos 
karlsruhe germany june 
ziv lempel :10.1.1.118.8921
universal algorithm sequential data compression 
ieee transactions information theory may 
