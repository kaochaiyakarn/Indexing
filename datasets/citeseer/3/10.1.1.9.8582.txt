energy efficient soft real time cpu scheduling mobile multimedia systems presents grace os energy efficient soft real time cpu scheduler mobile devices primarily run multimedia applications 
major goal grace os support application quality service save energy 
achieve goal grace os integrates dynamic voltage scaling soft real time scheduling decides fast execute applications addition long execute 
grace os scheduling decisions probability distribution application cycle demands obtains demand distribution online profiling estimation 
implemented grace os linux kernel evaluated hp laptop variable speed cpu multimedia codecs 
experimental results show demand distribution studied codecs stable changes smoothly 
stability implies feasible perform stochastic scheduling voltage scaling low overhead grace os delivers soft performance guarantees bounding deadline ratio application specific requirements grace os reduces cpu idle time spends busy time lower power speeds 
measurement indicates compared deterministic scheduling voltage scaling grace os saves energy delivering statistical performance guarantees 
categories subject descriptors process management scheduling organization design real time systems embedded systems general terms algorithms design experimentation 
keywords power management mobile computing multimedia 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sosp october bolton landing new york usa 
copyright acm 
yuan klara nahrstedt department computer science university illinois urbana champaign springfield ave urbana il usa klara cs uiuc edu 
battery powered mobile devices ranging laptops cellular phones important platforms processing multimedia data audio video images 
compared traditional desktop server systems mobile systems need support application quality service qos requirements save battery energy 
operating systems manage system resources cpu qos aware manner 
hand mobile systems offer new opportunities 
system resources able operate multiple modes trading performance energy 
example mobile processors market today intel amd athlon transmeta crusoe change speed frequency voltage corresponding power runtime 
second multimedia applications soft real time resource demands 
hard real time applications multimedia applications require statistical performance guarantees meeting deadlines 
best effort applications long multimedia applications complete job video frame decoding deadline actual completion time matter qos perspective 
soft real time nature results possibility saving energy substantially affecting application performance 
exploits opportunities address challenges qos provisioning energy saving 
done part illinois grace cross layer adaptation framework system layers including hardware operating system network applications cooperate optimize application qos save energy 
discuss os resource management grace framework 
particular focus cpu scheduling energy saving stand mobile devices 
dynamic voltage scaling dvs common mechanism save cpu energy :10.1.1.143.7417
exploits important characteristic cmos processors maximum frequency scales linearly voltage energy consumed cycle proportional square voltage 
frequency enables lower voltage yields quadratic energy reduction 
major goal dvs reduce energy possible degrading application performance 
effectiveness dvs techniques dependent ability predict application cpu demands waste cpu energy resources underestimating degrade application performance 
general prediction approaches monitoring average cpu utilization periodic intervals application worst case cpu demands application runtime cpu usage :10.1.1.143.7417
approaches suitable multimedia applications due highly dynamic demands interval approach may violate timing constraints multimedia applications worst casebased approach conservative 
take third approach runtime dvs integrate soft real time srt scheduling 
srt scheduling commonly support qos combining predictable cpu allocation proportional sharing reservation real time scheduling algorithms earliest deadline :10.1.1.112.5162:10.1.1.25.6928
integrated approach dvs algorithms implemented cpu scheduler 
enhanced scheduler called grace os decides fast execute applications addition long execute 
integration enables scheduler dvs decisions properly scheduler full knowledge system states performance requirements resource usage applications 
goal obtain benefits srt dvs maximize energy saving dvs preserving performance guarantees srt scheduling 
introduce stochastic property grace os 
specifically scheduler allocates cycles statistical performance requirements probability distribution cycle demands individual application tasks processes threads 
example mpeg decoder requires meeting deadlines particular input video frame decoding demands cycles scheduler allocate cycles frame decoder 
compared worst case allocation stochastic allocation increases cpu utilization 
saves energy task set level cpu run minimum speed meets aggregate statistical demand concurrent tasks 
example mpeg video decoder mp audio decoder running concurrently statistical allocation cycles second respectively cpu slow mhz save energy 
potential exists save energy task level 
reason task may complete job allocated cycles 
early completion results cpu idle time resulting energy waste 
realize potential grace os finds speed schedule task probability distribution task cycle demands 
speed schedule enables job task start slowly accelerate job progresses 
consequently job completes early avoid high speed high energy consumption part 
stochastic intra job dvs sharp contrast previous dvs approaches execute entire job uniform speed start job higher speed decelerate early completion 
stochastic scheduling dvs dependent demand distribution tasks estimate online profiling estimation 
kernel profiling technique monitor cycle usage task counting number cycles task execution 
simple effective histogram technique estimate probability distribution task cycle usage 
estimation approach distinguished online low overhead :10.1.1.112.5162
important necessary live multimedia applications video conferencing 
implemented grace os linux kernel evaluated hp laptop variable speed processor multimedia applications including codecs speech audio video 
experimental results show interesting findings 
studied code applications vary instantaneous cpu demands greatly probability distribution cycle demands stable changes slowly smoothly 
grace os estimate demand distribution small part task execution jobs update infrequently 
stability indicates feasible perform stochastic scheduling dvs demand distribution 

grace os delivers soft performance guarantees stochastic opposed worst case allocation meets deadlines lightly loaded environment bounds deadline ratio application specific requirements meeting deadlines heavily loaded environment 

compared systems perform allocation dvs deterministically grace os reduces cpu idle time spends busy time lower power speeds saving energy 

grace os incurs acceptable overhead 
cost cycles kernel online profiling ms histogram estimation cycles srt scheduling cycles dvs 
intra job dvs change cpu speed frequently 
studied codes average number speed changes job 
rest organized follows 
section introduces design algorithms grace os 
sections implementation experimental evaluation respectively 
section compares grace os related 
section summarizes 

design algorithms introduce application model stochastic scheduling dvs 
consider periodic multimedia tasks processes threads release job period decoding video frame ms basic computation unit timing constraints characterized release time finishing time soft deadline 
deadline job typically defined sum release time period release time job 
soft deadline mean job finish time 
words job may deadline 
multimedia tasks need meet percentage job deadlines soft real time performance requirements 
statistical performance requirement probability task meet job deadlines monitoring performance requirements scheduling system calls grace os grace os multimedia tasks processes threads profiler demand distribution srt scheduler time allocation speed adaptor speed scaling cpu grace os architecture enhanced scheduler performs soft real time scheduling dvs probability distribution cycle demands multimedia task 
task needs meet deadlines 
general application developers users specify parameter application characteristics audio streams higher videos user preferences user may tolerate deadline misses cpu overloaded 
describe architecture grace os major algorithms qos provisioning energy saving 
overview goal reduce cpu energy consumption possible meeting statistical performance requirements multimedia tasks 
operating system needs provide predictable cpu scheduling speed scaling 
enhance cpu scheduler integrate scheduling speed scaling 
enhanced scheduler called grace os consists major components profiler srt scheduler speed adaptor shown 
profiler monitors cycle usage individual tasks automatically derives probability distribution cycle demands cycle usage 
srt scheduler responsible allocating cycles tasks scheduling deliver performance guarantees 
performs soft real time scheduling statistical performance requirements demand distribution task 
speed adaptor adjusts cpu speed dynamically save energy 
adapts task execution speed task time allocation provided srt scheduler demand distribution provided profiler 
operationally grace os achieves energy efficient stochastic scheduling integration demand estimation srt scheduling dvs performed profiler srt scheduler speed adaptor respectively 
describe operations subsections 
online estimation demand distribution predictable scheduling dvs dependent finish th job th job finish finish th job th job finish cycles cycles jth job cycles th cycles job th job cycles th job legend profiled task switched execution profiled task switched suspension finish profiled task finishes job kernel online profiling monitoring number cycles elapsed task switch switch context switches 
prediction task cycle demands 
step grace os estimate probability distribution task cycle demands 
estimate demand distribution instantaneous demands reasons 
stable predictable demonstrated section 
second allocating cycles demand distribution tasks provides statistical performance guarantees sufficient targeted multimedia applications 
estimating demand distribution task involves steps profiling cycle usage deriving probability distribution usage 
number profiling mechanisms proposed :10.1.1.112.5162:10.1.1.124.5957
profiling performed online line 
line profiling provides accurate estimation trace cpu usage applicable live applications 
take online profiling approach 
add cycle counter process control block task 
task executes cycle counter monitors number cycles task consumes 
particular counter measures number cycles elapsed task switch switch context switches 
sum elapsed cycles job execution gives number cycles job uses 
illustrates kernel online profiling technique 
note multimedia tasks tell kernel jobs system calls mpeg decoder finishes frame decoding may call sleep wait frame 
resource containers proposed profiling technique accurate subtracting cycles consumed kernel interrupt handling 
currently count cycles typically negligible relative cycles consumed multimedia job 
proposed profiling technique distinguished reasons :10.1.1.112.5162:10.1.1.124.5957
profiles runtime requiring isolated profiling environment 
second customized counting job cycles simpler general profiling systems assign counts program functions 
incurs small overhead happens updating cycle counters context switch 
additional cumulative cumulative probability probability min cumulative distribution function cycle demand max histogram estimation histogram approximates cumulative distribution function task cycle demand 
overhead due sampling interrupts 
employ simple effective histogram technique estimate probability distribution task cycle demands 
profiling window keep track number cycles consumed jobs task 
parameter specified application set default value jobs 
cmin cmax minimum maximum number cycles respectively window 
obtain histogram cycle usage follows 
cmin br cmax split range cmin cmax equal sized groups 
refer br group boundaries 

ni number cycle usage falls th group bi bi 
ratio ni represents prob ability task cycle demands bi bi nj represents probability task needs bi cycles 

group plot rectangle interval bi bi height nj rectangles form histogram shown 
probabilistic point view histogram task approximates cumulative distribution function task cycle demands random variable task demands 
particular rectangle height nj group bi bi approximates cumulative distribution bi probability task demands bi cycles 
way estimate cumulative distribution group boundaries histogram br 
distribution parameters mean standard deviation histogram describes property full demand distribution 
property necessary stochastic dvs see section 
hand compared distribution functions normal gamma pace histogram estimation need configure function parameters line 
easy update low overhead demand distribution changes due video scene change 
cumulative cumulative probability probability min statistical performance requirement cycle demand cycle allocation max stochastic cycle allocation allocating smallest bm bm 
stochastic srt scheduling multimedia tasks demanding computational requirements met soft real time decoding frame period 
support timing requirements operating system needs provide soft real time scheduling typically steps predictable cycle allocation enforcement 
key problem step deciding amount cycles allocated task 
grace os takes stochastic approach addressing problem decides cycle allocation statistical performance requirements demand distribution task 
purpose stochastic allocation improve cpu energy utilization delivering statistical performance guarantees 
specifically statistical performance requirement task task needs meet percentage deadlines 
words job task meet deadline probability 
support requirement scheduler allocates task probability job requires allocated cycles find parameter task search histogram group boundaries br find smallest bm cumulative distribution bm bm 
bm parameter illustrates stochastic allocation process 
determining parameter earliest deadline edf scheduling algorithm enforce allocation 
scheduling algorithm allocates task budget cycles period 
dispatches tasks deadline budget selecting task earliest deadline positive budget 
selected task executed budget decreased number cycles consumes 
task overruns finish current job budget scheduler notify abort overrun part preempt run best effort mode 
case overrun task executed utilizing unused cycles tasks blocked budget period 
stochastic dvs srt scheduling determines task execute long number cycles execute 
discuss scheduling dimension fast execute task cpu speed scaling 
purpose speed scaling save energy preserving statistical performance guarantees srt scheduling 
intuitive idea assign uniform speed execute tasks task set changes 
assume tasks allocated ci cycles period pi 
aggregate cpu demand concurrent tasks ci pi cycles second mhz 
meet aggregate demand cpu needs run speed task exactly allocated cycles uniform speed technique consume minimum energy due convex nature cpu speed power function :10.1.1.12.4451
cycle demands multimedia tasks vary greatly 
particular task may complete job allocated cycles 
early completion results cpu idle time wasting energy 
save energy need dynamically adjust cpu speed 
general dynamic speed scaling approaches starting job uniform speed completes early starting job lower speed accelerating progresses 
conservative assuming job allocated cycles aggressive assuming job fewer cycles allocated 
comparison second approach saves energy jobs complete early jobs avoid high speed high energy consumption execution 
grace os takes second approach multimedia jobs fewer cycles allocated shown section 
specifically define speed schedule task 
speed schedule list scaling points 
point specifies job accelerates speed uses cycles 
points list larger cycle number higher speed 
point list sorted ascending order cycle number speed 
speed schedule task starts job speed scaling point 
job executed scheduler monitors cycle usage 
cycle usage job greater equal cycle number scaling point execution accelerated speed scaling point 
shows example task speed schedule scaling points 
shows corresponding speed scaling jobs task 
job starts speed mhz accelerates progresses 
job needs fewer cycles avoids high speed execution 
example job requires cycles needs execute speed mhz 
discuss calculate speed schedule task demand distribution similar stochastic dvs techniques proposed lorch smith 
goal minimize task energy consumption meeting statistical performance requirements 
allocate cpu time task follows 
concurrent tasks cycle speed mhz speed speed mhz mhz speed speed mhz mhz speed speed mhz mhz mhz mhz mhz mhz mhz mhz speed schedule scaling points job cycles job cycles job cycles job cycles job cycles job cycles time ms time ms time ms speed scaling jobs speed schedule example speed schedule corresponding speed scaling job execution job starts slowly accelerates progresses 
task allocated ci cycles period pi scheduler allocates th task cpu time ti ci ci pi period pi 
reason time allocation addition cycle allocation guarantee task executes allocated cycles allocated time regardless speed changes 
want preserve statistical performance guarantee srt scheduling dvs save energy 
speed schedule construction problem task find speed allocated cycles total energy consumption allocated cycles minimized total execution time allocated time 
formally cycle executes speed fx execution time fx energy consumption proportional 
task requires cycles statistically uses allocated cycles certain probability 
allocated cycle executed certain probability consequently average energy consumption proportional cumulative distribution function defined equation 
way constructing speed schedule task equivalent minimize subject fx task allocated cycles allocated time period respectively 
solve constrained optimization need know cumulative distribution allocated cycle 
histogram estimation provides cumulative distribution group boundaries histogram know bm bm cycle group boundary equal number allocated cycles th percentile task cycle demands fall groups histogram discussed section 
piece wise approximation technique find speed group boundaries uniform speed group 
rewrite constrained optimization minimize si bi subject si bi si size th group si bi bi jensen inequality equation lower bound bi bi bi fb bj si bi equation gives speed group boundaries fx bm 
construct speed schedule task adding scaling point group boundary 
speed schedule consists scaling points 
point cycle number bi speed fb speed fb increases cycle number bi increases speed schedule accelerates cpu job progresses 

implementation implemented prototype grace os 
hardware platform implementation hp laptop single amd athlon processor 
processor features technology supports different frequencies mhz 
frequency voltage adjusted dynamically operating system control 
prototype software implemented set modules patches hook linux kernel 
entire implementation contains lines user level kernel level system calls srt tasks processes threads instrumented srt apis process control block standard linux scheduler srt dvs modules soft real time scheduling speed scaling hook software architecture implementation 
table new system calls srt tasks 
api description start srt start real time mode specifying period statistical performance requirement 
exit srt exit real time mode 
finish job tell scheduler task finishes job 
set budget set task cycle budget 
set set scaling point task speed schedule 
tell kernel results demand estimation moved user level 
code including lines modification standard linux scheduler files sched sched implementation includes major issues 
adding new system calls 
calls table support soft real time requirements multimedia tasks 
uses start srt declare srt task require statistical performance guarantees os 
uses finish job notify scheduler finished current job 
finish job call scheduler gets number cycles task current job may re calculate task demand distribution cycle budget speed schedule necessary 
calculation requires double data type computation equation currently supported linux kernel modules 
solve problem move calculation user level intercepting finish job call 
returning calling task call estimates demand distribution user level uses set budget set tell scheduler task budget speed schedule respectively 
interception enabled demand estimation disabled reduce overhead 
note scaling point speed calculated equation may overlap speeds supported athlon processor 
need convert calculated speed supported 
round speed scaling point upper bound supported speeds combine scaling points upper bound 
result task speed schedule consists points supported speeds 
conversion specific processor specification may different number points different processors 
considered alternative approach simulations approximates calculated speed bounding supported speeds 
approach divides cycles need executed calculated speed parts lower bound process control block srt flag cycle counter cycle budget speed schedule current point attributes scaling point cycle speed cycle speed cycle speed enhanced process control block 
upper bound 
approach provides accurate approximation 
requires fine granularity speed scaling tens microseconds due cycle division may potentially result large overhead real implementations 

modifying process control block 
add new attributes process control block task struct shown 
new attribute srt flag indicates task srt task 
attributes apply srt tasks 
cycle counter profiling section 
cycle budget stores number allocated cycles section 
speed schedule list speed scaling points define accelerate cpu job execution 
current point specifies current execution speed task section 

adding srt dvs modules 
add new modules kernel soft real time scheduling speed scaling 
module responsible setting speed writing frequency voltage special register 
module provides simple clean interface speed setting separated dvs decision maker scheduler case 
doing improve flexibility reusability implementation apply stochastic scheduling dvs processors replacing speed setting module transmeta 
srt scheduling module hooked standard linux scheduler replacing 
similar hierarchical real time scheduling 
reasons support coexistence real time best effort applications minimize modification os improving usability implementation 
patch kernel utime package add periodic resolution utime timer kernel 
srt scheduler attached call back function timer invoked 
soft timers utime timers achieve high resolution low overhead running hardware timer aperiodic device 
high resolution timer standard linux kernel timer ms resolution resolution coarse srt scheduling intra job dvs 
utime timer expires srt scheduler invoked perform real time scheduling follows checks cycle budget current task 
budget exhausted sets current task scheduling policy best effort mode overrun protection 
checks srt tasks 
task begins new period speed increase table experimental multimedia applications 
application type jobs period ms mpeg video decoder mp audio decoder tmn video encoder video decoder toast gsm speech encoder task cycle budget puts task back real time mode 
sets priority real time tasks deadline earlier deadline higher priority 
invokes standard linux scheduler turn dispatches real time task earliest deadline 

modifying standard linux scheduler 
modify standard linux scheduler add profiling cycle charging dvs 
schedule function invoked context switch current task dispatched linux scheduler may accelerate speed current task speed schedule 
context switch happens linux scheduler housekeeping switched task increasing cycle counter number cycles elapsed switch decreasing cycle budget amount advancing current scaling point cycle counter reaches cycle number scaling point 
linux scheduler adjusts speed switched task current scaling point 
task execute new speed context switch 

experimental evaluation experiments performed hp laptop mb ram 
operating system red hat linux modified version linux kernel discussed section 
experimental applications codecs video audio speech 
table summarizes applications inputs 
experimented inputs codec show results due space limitations 
specified repeat experiments times measure relevant metrics scheduling cost cpu energy consumption run 
metric discard largest smallest value measured multiple runs report average remaining ones 
overhead experiments evaluate grace os overhead measuring cost demand estimation srt scheduling dvs 
measure cost cycles time elapsed time operation invocation srt scheduling depends speed number consumed cycles change substantially speed 
get number cycles reading timestamp register cpu cycle counter kernel provide api get cycle count user level 
evaluate cost new system calls table 
run task measure elapsed cycles new system call program 
table shows system calls take cycles speed mhz 
cycles table cost new system calls cycles 
start srt exit srt finish job set budget set window size window size group size cycles cost demand estimation 
head low negligible relative multimedia execution studied codecs consume cycles frame processing new system calls cost job cycles 
note cost finish job include cycles calculating demand distribution calling task recall calculation moved user level intercepting finish job demand distribution changes 
second measure cost demand profiling estimation 
profiling cost primarily results access timestamp register reading current number cycles 
cycles hp laptop 
evaluate estimation cost run codec measure number cycles building histogram calculating cycle budget speed schedule 
results show estimation cost dependent size profiling window histogram groups 
cost hundreds thousands cycles quite large 
number cycles consumed jobs studied codecs cycles job 
means online demand estimation happen frequently incur unacceptably large overhead 
section show demand distribution studied multimedia tasks relatively stable consequently grace os needs estimate demand distribution infrequently 
third measure cost srt scheduling 
run copies toast codec measure number cycles elapsed srt scheduling 
choose toast presents low cpu demand cycles job multiple copies run concurrently violating edf schedulability total cpu utilization 
run sample scheduling cost times kernel 
plots results confidence intervals 
scheduling cost depends number multimedia tasks srt scheduler needs check status task begins new period 
tasks new period cost primarily results budget charging currently running task status checking tasks 
cycles tasks 
scheduling granularity relative scheduling cost depending cpu cycles tasks period tasks new period tasks period ms cost soft real time scheduling confidence intervals 
table cost speed scaling cycles 
frequency mhz frequency mhz table average speed changes job 
single run concurrent tmn toast run 
speed task begins new period srt scheduler needs replenish cycle budget change scheduling parameters 
result scheduling cost larger small relative multimedia execution job cycles 
measure cost speed scaling 
adjust processor speed measure number cycles change 
results table show cpu change speed cycles 
means speed scaling incur large overhead invoked infrequently 
reasons implementation uses timer trigger srt scheduling dvs 
note advances microprocessor design speed change overhead smaller processor change speed cycles continue operation change 
notice stochastic intra job dvs may potentially result frequent speed changes due context switches different tasks acceleration task job execution 
practice grace os processor provides mhz cycles speed mhz mhz cycles mhz 
change speed frequently reasons jobs complete early accelerating speeds available means cpu speed may remain context switch 
validate run codecs time run tmn concurrently 
run measure average number speed changes job 
results table confirm stochastic intra job dvs change speed frequently 
particular speed change single run toast codecs lowest speed mhz sufficient meet cpu demands 
stability demand distribution stochastic scheduling speed scaling depend probability distribution task demands 
task demand distribution stable scheduler estimate small profiling window scheduler estimate demand distribution large profiling window update changes 
experiment examines stability demand distribution 
profile cycle usage codec various time intervals execution jobs estimate demand distribution cycle usage compare demand distributions different time intervals 
note cycle usage demand distribution codec dependent inputs 
report results inputs table experimented inputs codec similar results 
depicts cycle usage application video clip mpg frame size pixels frames 
plots demand distribution decoding different parts video frames 
shows important characteristics cpu usage 
instantaneous cycle demands bursty jobs need worst case cycles jobs worst case demand cycles jobs require cycles 
indicates compared worst case allocation speed scaling stochastic allocation scaling improve cpu energy utilization 
example scheduler improve cpu utilization delivering codec opposed deadline guarantees 
second instantaneous cycle demands change greatly factor demand distribution stable 
example cumulative probability curves jobs jobs jobs 
stability implies grace os perform stochastic scheduling dvs small part cycle usage history cycle usage jobs 
repeat experiment codecs 
plot demand distribution toast tmn codecs respectively 
results show toast low cpu demands th percentile jobs need cycles respectively 
probability distribution cycle demands stable cumulative probability curve jobs jobs 
hand tmn high cpu de cycles cumulative probability job cycles job frame demand distribution jobs jobs jobs job cycles millions cycle usage estimated demand distribution instantaneous cycle demands change greatly demand distribution stable 
mands th percentile tmn jobs need cycles 
demand distribution changes time different parts input video 
reason input videos scene changes require different amount cpu cycles 
changes indicate grace os needs dynamically update demand distribution tmn 
demand distribution tmn changes slow smooth manner little variation jobs 
implies grace os needs update demand distribution infrequently jobs 
efficiency grace os evaluate grace os efficiency qos support energy saving comparing schemes perform allocation dvs deterministically worst uniform 
allocates cycles task worst case demand sets uniform speed meets aggregate allocation cur rent task set ws tasks worst case demand ws worst reclaim 
reclaims unused cycles task completes job early 
sets cpu speed act pi cumulative probability cumulative probability demand distribution toast jobs jobs jobs job cycles thousands demand distribution tmn jobs jobs jobs job cycles millions cumulative probability cumulative probability demand distribution jobs jobs jobs job cycles thousands demand distribution jobs job cycles millions stability demand distribution codecs toast stable tmn change slowly smoothly 
act equals worst case demand job release number consumed cycles job completion 
represents dvs techniques start jobs high speed decelerate early completion 
worst stochastic 
allocates cycles task worst case demand performs stochastic dvs adjust speed task task demand distribution 
stochastic uniform 
allocates cycles task statistical demand sets uniform speed meets aggregate allocation cur rent task set st concur rent tasks period pi statistical cycle demand st stochastic reclaim 
allocates cycles task statistical demand sets cpu speed correspondingly 
parameter act set statistical demand opposed worst case demand th task releases job 
grace os schemes soft real time scheduling overrun protection 
run codecs table schemes measure metrics deadline ratio cpu energy consumption 
currently power meters measure actual energy consumption 
evaluate cpu energy measuring fraction cpu idle time distribution busy time speed 
similar measurement 
correlation speed levels energy consumption studied literature 
intuitively cpu saves energy spends time lower speeds idle time 
simplify comparison different schemes calculate normalized energy follows 
assume cpu power proportional cube speed normalize power highest speed unit cpu power speed fmax fmax maximum speed 
assumption holds speed proportional voltage andthe dynamic power dominates cpu energy consumption proportional speed square voltage fv 
power normalization cpu consumes normalized energy dt dt fmax total execution time time normalized evaluation commonly previous 
specified set codec statistical performance requirement codec task needs meet deadlines estimate demand distribution cycle usage jobs 
table cpu speed distribution 
percent cpu busy time speed mhz percent idle time grace os table energy deadline ratio 
grace os normalized energy deadline ratio jobs codec task executed best effort mode highest cpu speed mhz 
grace os allocates cycles changes speed task task finished jobs 
count missed deadlines jobs performance guarantees 
run single application 
codec cpu competition applications measure speed distribution normalized energy deadline ratio tables 
results show important observations 
grace os delivers statistical performance guarantees bounding deadline ratio 
deadline ratio schemes approximately measured values primarily due uncertainty resulted low level mechanisms caching interrupts 
reason overruns utilizes unallocated cycles exist cpu discrete speed options runs faster required 
second grace os spends cpu busy time lowest speed mhz idle time 
implies grace os slows cpu reduces idle slack 
consequently results reduction normalized energy 
benefit energy saving primarily results stochastic dvs 
stochastic allocation contribute energy saving grace os normalized energy 
expect reason result existence discrete speed options 
verify take speed schedule find 
result grace os speed scaling consume energy run 
run codecs time measure metrics 
find similar run deadline ratio negligible codecs 
focus energy evaluation 
table shows speed distribution tmn toast 
dvs method uniform reclaim stochastic plot worst case statistical allocation grace os speed table speed distribution codecs 
tmn percent cpu busy time percent speed mhz idle time grace os percent cpu busy time speed mhz grace os percent idle time toast percent cpu busy time percent cpu speed mhz idle time toast grace os schedule speed scaling executing single task 
notice immediately tmn grace os reduces cpu idle time spends busy time lower speeds 
implies grace os consumes energy single run tmn 
normalized energy summarized 
hand toast spend time lowest speed mhz fraction idle time 
indicates compared schemes grace os save energy toast 
reason applications low cpu demand 
specifically stochastic allocation toast period ms respectively demand cycles second mhz respectively 
low cpu demands mean speed schedule single scaling point associated lowest speed mhz 
consequently processor runs lowest speed resulting speed distribution energy consumption schemes 
conclude single low demand application effectiveness grace os energy saving limited available discrete speeds 
expect grace os save energy single low demand application cpu speeds available 
expectation validated trace simulation leave 
run multiple applications concurrently 
codecs concurrently tmn demands cycles concurrent execution 
tables show energy grace os tmn toast concurrent summary normalized energy single concurrent runs 
table speed distribution concurrent run 
percent cpu busy time speed mhz percent idle time grace os table energy deadline ratio concurrent run 
grace os normalized energy deadline ratio results 
notice deadline ratio stochastic allocation schemes higher single run case compared table 
reason multiple tasks may compete cpu overruns recall overrun task runs best effort mode utilizing unused cycles discussed section 
grace os bounds deadline ratio application statistical performance requirements deadline ratio 
obvious result grace os spends cpu busy time lower power speeds idle time fraction cpu busy time speed mhz grace os respectively 
implies stochastic allocation stochastic dvs contribute energy saving table 
different single run cases grace os consume energy see tables 
reason difference integration stochastic scheduling dvs yields statistical multiplexing gains concurrent run edf scheduling conserving enables task take advantage residual budgets tasks 
normalized energy concurrent statistical requirement impact normalized energy 
impact mixed workload experiments set task statistical performance requirement run application background 
examine impact parameter mixed workload grace os energy saving 
repeat concurrent runs change parameter average case requirement worst case requirement 
results show normalized energy increases increases 
reason higher performance requirement means cpu allocation turn results higher execution speed 
changes energy consumption concurrent run consumes energy explained 
reason interval cycle budget codecs change significantly budget changes millions increases speed schedule codecs little difference rounding available speeds 
implies discrete speed options limit grace os energy saving 
analyze impact best effort applications grace os energy saving 
repeat concurrent runs execute math program background 
math runs multimedia applications cpu execution speed previously executed normalized energy concurrent best effort allocation mhz impact mixed workload 
multimedia application scheduler adjust speed math 
protect math starvation allocate millions cycles second mhz 
plots normalized energy concurrent runs changing best effort allocation mhz 
results indicate extra best effort allocation increases energy consumption 
reason extra allocation increases total cpu demand 
consequently multimedia application allocated time needs run faster see equation 
note run extra mhz allocation affect normalized energy speed schedule change due discrete cpu speed options 
summary experimental results show grace os provides significant benefits qos provisioning energy saving incurs acceptable overhead 
grace os meets deadlines lightly loaded environment cpu competition bounds deadline ratio application statistical requirements heavily loaded environment 
compared systems deterministic scheduling dvs grace os spends cpu time lower power speeds saving energy 
executing single high demand application stochastic dvs primarily contributes energy saving reducing normalized energy 
executing multiple applications concurrently stochastic scheduling dvs contribute energy saving reducing normalized energy 
find grace os efficiency limited discrete speed options especially executing single low demand application changing statistical performance requirement 
similar shin finding shows simulations speed availability profoundly affects energy saving real time dvs algorithms 

related soft real time scheduling qos support 
number soft real time srt scheduling mechanisms proposed support qos requirements multimedia applications 
approaches typically integrate predictable cpu allocation proportional sharing reservation real time scheduling algorithms edf rate monotonic 
grace os distinguishes srt approaches reasons grace os derives task cpu demands online profiling estimation typically assume cpu demands known advance line profiling grace os uses srt scheduling integrated dvs variable speed context implicitly assume constant cpu speed 
variable speed context brings challenges srt scheduling enforce budget share reservation underlying speed changes 
groups studied stochastic srt scheduling statistical performance guarantees 
gardner proposed stochastic time demand analysis technique compute bound deadline ratio fixed priority systems 
computation runtime execution analyzing time demands task tasks higher priority 
contrast grace os aims edf systems delivers statistical guarantees allocating cycle budget demand distribution individual task 
hamann wang proposed scheduling technique provide statistical guarantees imprecise computations differentiated services respectively 
approaches assume predefined stochastic distribution resource demands 
contrast grace os obtains demand distribution online profiling estimation 
proposed automatic profiling overbooking techniques provide statistical guarantees 
approach similar stochastic allocation 
differences approach profiles resource busy intervals isolated environment traces grace os profiles number cycles consumed task runtime 
overbooking technique aims support services shared hosting platforms grace os aims save energy mobile devices 
dynamic voltage scaling energy saving 
dvs commonly save cpu energy adjusting speed application workload 
dvs investigated main areas general purpose systems gp dvs real time systems rt dvs 
gp dvs algorithms heuristically predict workload average cpu utilization 
save energy degrading performance best effort applications unsuitable multimedia applications due timing constraint demand variations multimedia applications 
example grunwald concluded heuristic algorithm examined saves energy affecting multimedia application performance 
rt dvs algorithms integrated cpu scheduling derive workload worst case cpu demands realtime applications 
set cpu speed assumption applications require worstcase cpu resources 
application demand worst case reclamation techniques proposed reclaim unused cycles save energy 
reclamation techniques run cpu fast assuming worst case demand decelerate job finishes early 
stochastic dvs alternative approach handling runtime demand variations 
starts job slowly accelerates job progresses 
stochastic dvs hard real time systems lorch smith proposed technique called pace improve gp dvs algorithms 
basic idea similar grace os finding speed cycle demand distribution applications 
grace os differs stochastic dvs techniques reasons 
grace os obtains demand distribution online profiling estimation assume distribution function estimate line 
second grace os supports multiple tasks integrating srt scheduling dvs 
contrast pace supports single task treats concurrent tasks joint workload isolation 
approach claims support concurrent tasks fixed priority systems clear decides time allocation multiple tasks 
importantly simulations grace os implements stochastic dvs 
lorch smith implemented pace algorithm windows 
implementation support soft real time scheduling 
groups proposed job stochastic dvs technique changes speed job task stochastic model markov process task cpu demands 
job dvs changes speed starting job grace os changes speed job execution 
grace os built previous shows benefits integration soft real time scheduling dvs simulation 

presents design implementation evaluation grace os energy efficient soft real time cpu scheduler 
grace os explores observation multimedia applications dynamic cycle demands probability distribution cycle demands relatively stable 
observation provides opportunity saving energy delivering soft guarantees multimedia applications 
realize opportunity grace os statistically allocates cycles individual applications executes allocated cycles different speeds 
stochastic decisions demand distribution multimedia applications 
experimental results real implementation show grace os provides significant deadline guarantees energy saving acceptable overhead 
bounds deadline ratio application specific requirements saves energy 
energy saving primarily results stochastic dvs especially executing single application 
current study grace os yields strong results lessons learned motivate 
limitation energy saving due speed options hp laptop 
expect grace os result benefits speeds available frequent speed changes incur low overhead 
general expectation examined ways trace simulator experiment ideal processor supports continuous dvs converting optimal speed available speeds applying grace os processors support contin uous dvs 
plan examine approaches 

limitation experiments due lack diversity application classes 
grace os targeted periodic multimedia applications demand distribution stable 
expect grace os benefit best effort applications soft realtime applications hosting servers highly bursty demands 
investigating grace os impact applications part 
plan analyze impact perceptual quality multimedia interactive applications 

limitation energy evaluation due lack actual energy measurement 
gra ce os uses normalized approach energy evaluation assumptions cpu power proportional cube speed stochastic scheduling impact energy consumption resource components memory 
practice assumptions may strong 
plan purchase power meters measure actual energy consumption analyze grace os practical impact comparing expected measured energy saving 

acknowledgments grace members especially professor sarita adve informative discussions energy saving anonymous reviewers shepherd professor kevin jeffay constructive feedback william conner proofreading final padmanabhan providing code set athlon cpu speed 
supported nsf ccr cise eia 
views contained authors interpreted representing official policies expressed implied nsf government 

adve illinois grace project global resource adaptation cooperation 
proc 
workshop self healing adaptive self managed systems june 
amd 
mobile amd athlon processor model sheet 
www amd com nov 
anderson continuous profiling cycles gone 
proc 
th symposium operating systems principles oct 
aron druschel 
soft timers efficient microsecond software timer support network processing 
proc 
th symposium operating systems principles dec 
melhem alvarez 
dynamic aggressive scheduling techniques power aware real time systems 
proc 
nd ieee real time systems symposium dec 
banga druschel mogul 
resource containers anew facility resource management server systems 
proc system design implementation feb 
chandra adler goyal shenoy 
surplus fair scheduling share cpu scheduling algorithm symmetric multiprocessors 
proc 
th symposium operating system design implementation oct 
chandrakasan sheng brodersen 
low power cmos digital design 
ieee journal solid state circuits apr 
duda cheriton 
borrowed virtual time bvt scheduling supporting latency sensitive threads general purpose scheduler 
proc 
th symposium operating systems principles dec 
mudge 
automatic performance setting linux 
proc th symposium operating systems design implementation dec 
flinn satyanarayanan 
energy usage mobile applications 
proc 
nd ieee workshop mobile computing systems applications feb 
gardner 
probabilistic analysis scheduling critical soft real time systems 
phd thesis computer science university illinois urbana champaign 
goyal guo vin 
cpu scheduler multimedia operating systems 
proc 
symposium operating system design implementation oct 

hard real time scheduling low energy stochastic data dvs processors 
proc 
intl 
symp 
low power electronics design aug 
grunwald levis farkas iii neufeld 
policies dynamic clock scheduling 
proc 
th symposium operating system design implementation oct 
hamann quality assuring scheduling stochastic behavior improve resource utilization 
proc 
nd ieee real time systems symposium dec 

voltage scheduling problem dynamically variable voltage processors 
proc 
intl 
symp 
low power electronics design 
jeffay smith anderson 
proportional share scheduling operating system services real time applications 
proc 
th ieee real time systems symposium dec 
jones rosu rosu 
cpu reservations time constraints efficient predictable scheduling independent activities 
proc 
th symposium operating systems principles oct 
kress kress 
jensen inequality 
birkhauser 
kurt 
utime micro second resolution timers linux 
www ku edu kurt mar 
liu layland 
scheduling algorithms multiprogramming hard real time environment 
jacm jan 
lorch smith 
improving dynamic voltage scaling algorithms pace 
proc sigmetrics conference june 
lorch smith 
operating system modifications task speed voltage scheduling 
proc 
st intl 
conf 
mobile systems applications services may 
lam 
design implementation evaluation smart scheduler multimedia applications 
proc 
th symposium operating systems principles oct 
pering brodersen 
simulation evaluation dynamic voltage scaling algorithms 
proc 
intl 
symposium low power electronics design june 
pering brodersen 
voltage scheduling microprocessor system 
proc 
intl 
symposium low power electronics design july 
shin 
real time dynamic voltage scaling low power embedded operating systems 
proc 
th symposium operating systems principles oct 
rajkumar 
resource kernels centric approach real time systems 
proc 
spie multimedia computing networking conference jan 
dynamic voltage scaling power management portable systems 
proc 
design automation conference june 
sinha chandrakasan 
dynamic voltage scheduling adaptive filtering workload traces 
proc 
th international conference vlsi design jan 
shenoy roscoe 
resource overbooking application profiling shared hosting platforms 
proc systems design implementation dec 
wang xuan zhao 
differentiated services statistical real time guarantees static priority scheduling networks 
proc 
nd ieee real time systems symposium dec 
weiser welch demers shenker 
scheduling reduced cpu energy 
proc 
symposium operating systems design implementation nov 
yuan nahrstedt 
integration dynamic voltage scaling soft real time scheduling open mobile systems 
proc 
th international workshop network operating systems support digital audio video may 
yuan nahrstedt adve jones kravets 
design evaluation cross layer adaptation framework mobile multimedia systems 
proc 
spie multimedia computing networking conference jan 
zhang wang chen smith 
system support automated profiling optimization 
proc 
symposium operating systems principles oct 
