higher order distributed objects henry suresh jagannathan richard kelsey nec research institute describe distributed implementation scheme permits efficient transmission higherorder objects closures continuations 
integration distributed communication facilities higher order programming language engenders number new abstractions paradigms distributed computing 
user specified load balancing migration policies threads incrementally linked distributed computations parameterized client server applications 
knowledge distributed dialect scheme related language addresses lightweight communication abstractions higher order objects 
categories subject descriptors programming techniques concurrent programming distributed programming programming languages language classifications applicative languages extensible languages programming languages language constructs features concurrent programming structures general terms experimentation languages additional key words phrases concurrency continuations higher order languages messagepassing 
process communication distributed environment requires solutions number important potentially troublesome issues 
issues concern interaction parallel distributed tasks local sequential computation efficient migration processes nodes effective storage management long lived distributed applications create data different nodes implementation protocols loosely coupled environment 
problems old solutions proposed andrews mullender 
solutions entail defining new programming language adding special primitives existing language handle concurrency distribution communication 
general proposals base languages typically provide little support defining composing new abstractions 
result semantics new primitives handle distributed programming easily expressed terms operations provided language easily combined provide new functionality 
primary goal article define small set language abstractions distributed computing enable variety applications different address independence way princeton nj email suresh research nj nec com 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission acm 
copy republish requires fee specific permission 
nication computation requirements execute efficiently stock hardware interconnect technologies 
keeping distributed programming interface orthogonal sequential programming interface equally important design goal 
realize goal choose sequential base language abstractions easily expressed 
high level languages scheme clinger rees ml milner provide support data abstraction class procedures support sophisticated control abstraction class continuations haynes friedman 
generality procedures continuations express operations parallel distributed programming 
building blocks high level concurrent distributed abstractions avoids need define entirely new language introduce ad hoc primitives existing 
article develop small set abstractions scheme base language 
distributed system described called scheme supports concurrency communication class procedures continuations 
efficient load balancing especially important problem systems multiple users different workload requirements share resources long lived distributed applications implementation transmits procedures continuations efficiently 
integrate procedures continuations message distributed framework allows scheme object sent received message 
integration engenders number new abstractions paradigms implementation techniques distributed computing enumerated discussed remainder article user level load balancing migration 
ability transmit continuation objects representation threads terms continuations thread schedulers residing different address spaces presumably residing different machines network migrate tasks address space schedulers may implemented entirely user level procedures scheme 
migration policies implemented modification application programs 
example consider parallel program running network workstations shared set users 
applications created owner workstation assumed priority tasks created consequently user initiates application node set tasks currently running may need migrate machines 
environment important specific migration policy determine tasks migrate determined hardwired part internal thread implementation 
example user level thread migration may useful parallel query searches distributed database 
query may spawn collection tasks responsible scanning portion database 
entries database related understood ordering may pantheon arms equipped distinct weapon chose name relevance distributed programming 
possible task determine input query satisfied piece database currently examining 
case task ideally migrate interesting section database 
choice go determined scheduler highly dependent structure database 
incremental distributed linking 
system performs dynamic linking code objects sent messages 
distributed programs incrementally compiled linked address space basis linking new program entail broadcast 
important example distributed linking useful distributed debugging monitoring 
consider long lived distributed application running collection address spaces 
monitor facets computation dynamically scheme users input monitoring procedure directly read eval print loop load file containing procedure apply different nodes halting current application 
words users define probes survey state ongoing computation probes need defined time computation instantiated 
parameterized client server applications 
ability communicate higherorder objects messages permits servers client applications establish new protocols functionality dynamically capability especially important wide area distributed applications benefit clients able load functionality servers dynamically 
section sketch simple example functionality useful 
example assumes server controlling display client manages large database 
queries database result modifications display 
optimize communication client server minimize latency refreshing display require ability ship portions database dynamically relevant accessor procedures server 
cooperative programs multiuser mud environments require kind functionality curtis 
mud network accessible program database extended users real time 
essential characteristics mud extensible words users add new data elements mud database new functionality mud core program extensions available users working environment 
long lived parallel computation 
process state freely transparently migrated processors asynchronously perform local garbage collection 
features system suited express long lived parallel applications 
ability migrate process state freely gives applications freedom build customizable schedulers benefits capability described 
automatic garbage collection essential distributed client server applications section new data constantly created discarded remote nodes 
garbage collection vital applications parallel search program described earlier 
tasks created application may create temporary data structures hold intermediate results search results may refer data elements recorded nodes 
memory allocated intermediate structures need explicitly recycled application 
benefits automatic garbage collection application clear data structures freely created concern space leaks memory limitations 
distributed data mining 
data mining program examines elements database attempts infer interesting relationships elements 
distributed data mining application operates distributed database 
complex data mining applications monitor examine distributed databases need ship procedures different nodes new inferences generated 
task application encounters interesting feature portion database may need notify tasks create new tasks nodes response 
lightweight communication protocols transmit receive programs useful realizing kind functionality 
consider problem large complicated mass input data requires system performs separate related tasks act heuristic database ready accept user queries status particular element likelihood complex phenomenon current state 
act monitor alarm system posting notices significant state changes occur 
determining likelihood complex states system quantitative tests heuristic decision procedures rule systems example mix 
input data recorded different address spaces monitor alarm tasks need distributed 
database assumed constantly evolving resolving user queries require creating tasks address spaces required data recorded having data sent node containing task making query 
executable content messages 
continues growing interest safe electronic delivery component software allowing executable content sent messages wide area networks 
world wide web example large distributed system built top wide area network 
expressive power significantly enhanced web browsers capability easily receiving executing programs installed sites 
consider implementing remote registration program web 
register new user product envision program downloaded user machine collects relevant data completion sends data back host site 
client server example cited earlier computation performed locally reducing message traffic improving latency 
example consider large application program available remote host 
conventional distributed system running program locally requires downloading entire image 
potentially wasteful small piece functionality required example libraries linked ap plication downloaded 
alternative solution application dynamically fault procedures demand application runs 
system describe consists collection address spaces potentially concurrent lightweight preemptible threads may execute 
envision address spaces uniformly distributed different nodes network ensemble potentially heterogeneous machines 
execution environment prototype described article network workstations running unix 
implementation assumption underlying network tightly loosely coupled expect scheme best utilized loosely coupled wide area network 
address spaces class may generated dynamically 
threads address space may communicate shared memory communication address spaces takes place explicit message passing 
section overview system 
section gives brief outline scheme concurrency distribution primitives primitives built top scheme implementation extended dialect scheme 
section describes transport mechanism focusing procedures continuations data sent messages 
section presents examples drawn list enumerated examples implemented tested heterogeneous platforms including single processor workstations networks pcs tightly coupled shared memory multiprocessors 
sharedmemory implementation maps address space logically different processor 
section outlines garbage collector 
section gives base performance figures section describes related 

overview distributed systems allow complex data structures sent nodes address spaces provide flexibility procedures dynamically created code objects complex pointer structures 
context language scheme efficient implementation functionality essential 
system describe article provides precisely expressivity 
describe section threads represented terms continuations 
consequently sent message transmitting thread message address space effectively migrates thread ordinarily continuations threads may closed large amount state 
avoid overhead occur continuations transmitted naively support generalization computation migration hsieh fault continuation frames lazily address spaces feature significantly reduces communication bandwidth requirements needed support migration 
interested supporting dynamic distributed applications implementation allows templates sent messages 
template corresponds roughly code segment procedure 
contains vector scheme byte codes vector locations top level definitions 
template environment defines closure 
ability send tem plates enables distributed applications linked incrementally 
incremental copy mechanism employed templates reducing cost migrating code objects 
allow complex data structures sent messages impose restrictions objects sent copied implementation includes novel distributed asynchronous garbage collector gc collect objects referenced remotely collector works distributed cyclic structures 
local collections run asynchronously independently gc occurring processor 
synchronization required collect cyclic structures span address spaces 
distributed garbage collection schemes birrell lang exporting local forwarded address spaces involves minimal gc related bookkeeping sending remote requires simply setting bit locally sender 
collection algorithm introduces overhead forwarded 
fault tolerance security important design issues address article 
communication primitives define guarantees communication latency synchronous message sends implement time outs timestamps message sent failed node appear sender simply high latency operation 
implementation replicate log data multiple nodes stable storage 
implementation assumes reliable network preserve timestamps logging information validate message receipts 
scheme type safe language operations applied objects inappropriate type casts objects unrelated type performed system provides measure security available distributed extensions type unsafe languages addition scheme lexically scoped closure objects sent nodes corrupt objects receiver explicitly shared 
system assume trusted channels 
receivers attempt validate integrity incoming messages senders encrypt outgoing messages 
course possible incorporate encryption validation facilities message sends receives provide extra level security extensions orthogonal main design goals system 

language abstractions scheme scheme implemented extension scheme kelsey rees implementation scheme clinger rees 
scheme lexically scoped dialect lisp 
scheme byte coded interpreter written highly optimized restricted dialect scheme called pre scheme compiles way implemented system portable reasonably efficient interpreted system 
scheme implementations scheme roughly times slower slower highly optimized scheme compiler generating native code kranz 
define record type thread continuation define current thread define spawn thunk thread thread set thread continuation 
thread lambda ignore thunk terminate current thread context switch thread define context switch thread add queue 
runnable threads current thread switch thread thread define switch thread thread call cc lambda set thread continuation 
current thread schedule thread thread define terminate current thread schedule thread thread define schedule thread thread set 
current thread thread cont thread continuation current thread set thread continuation 
current thread cont fig 

simplified implementation threads terms operations continuations 
scheme developed module system forms integral part language system environment 
scheme supports concurrency lightweight preemptible threads threads synchronize locks condition variables 
scheduling blocking resumption threads defined terms operations continuations haynes friedman 
scheme continuation reified procedure applied performs remaining computation 
resume blocked thread involves invoking continuation representing thread 
context switching similarly implemented terms capture invocation continuations 
sketches definition various thread operations omitting certain important details regarding interrupts synchronization debugging 
implementation shown thread simple record holds continuation 
new thread spawned continuation currently running thread enqueued thunk associated thread evaluated thunk procedure arguments 
currently running thread finishes time slice relinquishes control blocks continuation saved new thread scheduled scheduling operation restores old continuation continuation slot thread run applies continuation 
reinitialization operation ensures garbage collector trace old continuations 
extending formulation handle timer interrupts complicates design slightly 
system uses nonblocking system calls ensure thread blocked cause thread scheduler block 
cost context switching threads mitigated system uses stack cache kelsey restoring capturing continuations cheap 
stack cache stores active portion stack older frames restored demand heap 
extensions support distribution scheme thread system provides expressive concurrency model threads execute logically single address space 
consequently thread implementation easily extended support parallel applications shared memory environment thread system contain messagepassing communication abstractions necessary distributed memory system 
address spaces proxies extensions scheme support distribution 
describe abstractions detail 
distributed scheme program executes collection address spaces run different machine network ensemble multiprocessor 
address space reside node time 
usually address spaces physical nodes programmers create wish 
threads executing address space communicate shared memory locks abstractions provided thread system 
communication address spaces takes place message passing abstractions described 
manifest separation space space communication intentional 
important goal design provide programmers great flexibility control specify communication costs 
systems implement logical shared memory cox li hudak physically distributed platforms hide costs visible source level distinction local data access remote 
absence explicit hardware support modifications underlying operating system approaches tend costly inefficient kinds programs 
important examples ability tasks communicate data explicitly executing shared memory environment useful kranz 
stock hardware interconnects systems communication explicit exhibit better performance provide shared memory abstraction 
historically message passing systems difficult write debug complicated issues data placement locality communication patterns programmer specified 
addition integration distribution primitives language entails modifications semantics sequential core imposes limitations kind objects communicated 
extensions described alleviate complexity distributed programming languages systems 
extensions completely orthogonal scheme primitives combined abstracted different ways 
restrictions objects sent message contexts message passing operations may occur 
result kinds useful communication abstractions paradigms defined easily 
remainder article provide simplified code fragments various procedures system help describe details implementation 
address spaces 
address spaces implemented ordinary scheme data structures 
initialize address spaces system current implementation associates address space unique identifier list pairs channels element pair represents input output connection address space 
address space bidirectional connection 
implementation assumes existence operating system services network connectivity sockets ports similar abstractions 
primitive operations return address spaces result current aspace returns address space operation executed 
aspace addr creates new scheme process address space machine internet address addr notifies address spaces existence new address space 
address space created returned result 
address spaces dynamically created linked address spaces system 
address spaces direct connection number address spaces generated bounded number input output channels provided underlying operating system 
prototype particular topology pose serious constraints validating utility design 
limit scalability implementation 
straightforward relax constraints allow arbitrary connected graphs built 
example possible permit address space connected subset address spaces create destroy connections address spaces dynamically 
functionality complicates garbage collection algorithm slightly requires routing decisions transport layer described section underlying network case compromise semantics language primitives introduce 
proxies 
addition usual repertoire scheme objects vectors procedures continuations send proxy part message 
proxy distinguished record type slots contains systemwide uid second holds value 
part proxy uid address space proxy created 
way represented creating new proxy involve global synchronization 
uid field proxy transmitted proxy included part message 
value slot proxy need consistent different spaces 
words proxy defines address space relative abstraction 
proxy expression proxy creator returns address space proxy created proxy value returns value address space expression evaluated set proxy value 
sets value address space expression evaluated 
think proxy vector indexed address space uids 
element conceptual vector corresponds proxy value address space 
implementation proxies refines picture distributing vector space communication cost incurred access proxy local value 
distinction important provides programmers ability distinguish local remote data 
data structure safely replicated encapsulated proxy accesses mutations elements structure require synchronization communication 
sending objects system uses explicit message passing 
programmers significant control communication costs 
scheme objects sent message copy uid copy ordinary scheme structures lists vectors closures copied address spaces 
message sharing fully preserved 
sharing preserved messages 
example consider complex structure sent message address space new structurally identical copy constructed scheme eq ness copy honored 
re sent copy generated eq ness preserved copies 
uid certain scheme objects associated unique identifier 
procedure templates proxies symbols salient examples 
objects transmitted address spaces uid 
receiving address space may copy object referenced example sending symbol created read cause uid sent unknown receiver 
cases receiver explicitly requests unknown object sent 
subsequent transmission uid require object re sent 
describe implementation messages mechanisms transmit objects section 
communication primitives 
communication address spaces done remote run 
procedure 
expression remote run 
procedure args spawns new thread address space applies procedure args operation asynchronous returns immediately 
definition remote run 

target address space remote run 
operation current address space new thread simply spawned execute application 
message constructed sent channel connecting source target address spaces 
send message procedure responsible writing message target address space 
actual message send message requires define remote run 
aspace proc args eq 
aspace current aspace spawn lambda apply proc args send message run cons proc args aspace channel aspace aspace lock aspace define send message type message channel lock message encode type message lock lock channel write message channel fig 

procedures instantiated address spaces 
define remote apply aspace proc args eq 
current aspace aspace apply proc args condvar condvar proxy proxy condvar remote run 
aspace lambda remote run 
proxy creator proxy lambda set condvar 
proxy value proxy apply proc args condvar ref condvar fig 

synchronous send reply communication remote run 
knowing type message sent case type run needs know appropriate output channel requires access lock prevent messages sent target threads concurrently executing address space transfer underway 
send message linearizes message associated data releases lock complete 
describe decode operation executed receiving side section 
express rpc style version remote run 
shown 
remote apply procedure applies proc argument args target address space 
thunk sent target closed proxy evaluating thunk target requires sending proxy 
value proxy source address space condition variable 
sending thread blocks condvar receiver executes remote run 
operation back sender address space 
operation executed completion application proc args target determines source address space evaluating proxy creator proxy procedure executed target uses con implementation uses condition variables 
condition variables scheme synchronizing cells similar structures arvind 
attempt read condition variable value causes accessing thread block 
threads blocked condition variable awakened variable set 
define handle proxy define handle creator proxy creator define handle value remote apply handle creator proxy value define set handle 
remote apply handle creator set proxy value 
fig 

proxies implement network handles 
define handle test set 
pred 
remote apply handle creator lambda pred 
proxy value set proxy value 
fig 

class procedures allow extensions easily added basic set communication abstractions 
dition variable encapsulated proxy guarantee proper synchronization implementation concise efficient 
note remote apply simply applies proc args aspace argument current address space 
remote apply incurs message communication overhead case target address space source 
proxies unique owner easily implement shared global data structures network handles birrell shown 
network handle effectively proxy 
extract value network handle simply execute remote apply operation apply proxy value procedure address space handle created 
way remote apply defined dereferencing handle address space handle created incurs communication overhead 
setting value handle defined similarly 
class procedures simplifies specification handles significantly 
absence remote require predetermined handlers accept different requests 
generalizing functionality network handle example problematic 
example consider definition handle test set 
procedure sets value remote handle current value satisfies supplied predicate 
definition defined easily terms remote apply shown 
pred 
argument procedure applied handle value handle creator address space 
illustrates semantics abstractions 
encapsulating communication 
handles provide convenient shared data abstraction 
value handle encapsulates retrieved evaluating handle value operation handles may cause address space address space transmit transmit proxy proxy proxy proxy fig 

communication address spaces 
address space contains scheme structure scheme structures proxies 
structure transmitted address space copies fields structure sharing fully preserved 
proxies copied local value refers object local address space structure re sent back address space structure copied 
proxies retain identity transmission new copies scheme objects 
count lock lock counter lambda lock lock count lambda counter remote run fig 

procedures sent messages may closed free variables shared 
data procedural abstractions compromised 
example consider code fragment shown 
program application counter takes place address space scheme default copy semantics free variables counter count lock copied written counter serve intended purpose global increment procedure 
remedy problem handles shown 
rewritten version applies value handle associated counter address count lock lock counter handle lambda lock lock count lambda remote apply proxy creator counter lambda handle value counter remote run 
fig 

handles safely encapsulate free variables procedures may require exposing details procedure expressions ordinarily need know 
define proc proxy proxy proc lambda args remote apply proxy creator proxy lambda apply proxy value proxy args fig 

defines encapsulation abstraction procedures 
space counter defined 
calls counter execute address space allowing desired behavior realized 
unfortunately solution requires altering counter definition 
program alteration easily accomplished counter definition readily apparent 
generally case 
note encapsulating counter handle necessary explicitly provided argument remote run 
occurs free variable procedure requiring alteration counter constitutes violation procedural abstraction correctness definition longer dependent contexts applied contexts procedures call 
higher order procedures provide encapsulation mechanisms handles eliminate problems noted 
example defines procedure named procedure returns procedure result 
assume call occurs address space 
closed proxy created value applied arguments args address space remote apply operation executed applies args returns result 
users need know local procedure remote 
original program fragment rewritten shown 
definition counter remains unaltered 
regardless address space applied calls counter body execute address space counter defined 
integrating higher order count lock lock counter lambda lock lock count counter counter lambda counter remote run 
fig 

procedures effectively treated handles requiring definition altered 
programming techniques expressive abstractions distributed programming allows specification wide range sharing abstractions 

transport layer typically scheme address spaces start scheme image image contains definitions predefined base level procedures data structures 
processes may associated read eval print loop repl 
users interactively input new expressions load programs values yielded expressions input repl automatically broadcast address spaces transmitted included messages 
message encoding decoding performed scheme virtual machine 
encoding decoding done linearizing data structures fairly standard techniques 
sending messages data structures message encoded building vector corresponds flat linear representation structure 
cycles detected explicitly marking objects visited current message fully scanned 
templates symbols associated unique identifiers 
general uids globally known scheme images 
consequently usually case sending uid objects sufficient defined meaning receiver 
exceptions rule occur procedures symbols generated dynamically 
happen users input new definitions repl load files 
discuss cases handled 
receiving messages set coroutine pairs address space 
element set responsible receiving dispatching messages sent particular address space 
decoder routine receives flattened representation message interprets reconstruct valid scheme object sends resulting scheme object dispatcher executes appropriate operation 
decoder implemented part scheme virtual machine 
object decoded dispatched type 
basic types messages user space messages 
messages correspond remote run 
operations 
request messages 
message received containing uids objects proxies mapped scheme value receiving address space request message sent asking value 
reply messages 
user space message contains unresolved uids placed pending queue 
reply messages communicate values unknown uids 
pending message fully resolved values associated uids message known message executable new thread spawned evaluate 
gc messages 
periodically messages sent address spaces garbage collect objects global identity proxies noteworthy example 
defer discussion gc algorithm section 
basic structure dispatcher shown 
heart dispatcher process message procedure 
takes message output channel interprets message run messages implement remote run 
operations 
receiver applies procedure provided arguments separate thread control 
uid request messages requests value object referenced uid 
message containing uid sent attempt sender verify receiver object referenced uid 
decoder receiver encounters message uids value address space notifies dispatcher initiate uid request message 
request message sent proxies 
uid reply messages received response uid request message 
receipt uid reply receiver reconstructs object address space updating relevant uid tables 
addition count outstanding uid requests decremented 
count zero outstanding requests serviced messages previously placed pending queue referenced uids known address space executed 
pending messages initiated decoder sent address spaces 
pending message generated decoder encounters message uids values known 
dispatcher message sent places message queue sends uid request message appropriate address space 
message executed missing components received 
case administrative messages uid reply contain incomplete data 
messages flagged decoder pending handled dispatcher initiate uid request 
example uid reply message may contain unknown location template uids message enqueued pending queue dispatcher removed processed values unknown uids received 
illustrates relationship decoder dispatcher 
define dispatcher channel channel channel lock loop size get message size channel buffer byte vector size read message buffer channel disable interrupts 
message decode message buffer enable interrupts 
process message message channel channel lock loop define process message message channel channel lock case message type message run spawn lambda apply message proc message message args message uid request send message message type uid reply map uid reply uid list message channel channel lock uid reply process uid reply uid reply list message lock pending message lock set 
outstanding request count outstanding request count outstanding request count release pending messages pending handle pending message message channel channel lock process message message channel channel lock gc request proxies get local proxies message aspace message send message message type gc reply proxies channel channel lock reset proxies 
proxies gc reply collect local proxies message proxy list message message aspace message fig 

incoming messages handled dispatching basic types run uid request uid reply pending gc request gc reply 
message arrival run uid uid 

message decoding queueing uid request pending run 

dispatcher pending run 

decoder dispatcher pending decoder address space 
uid reply pending message dispatch uid reply pending replies decoder dispatcher pending run 


address space address space execution fig 

run message containing unknown uids received address space causes uid recorded message stored pending queue 
request object associated uid sender 
reply received message removed pending queue scheduled execution 
define fault frames rest cont handle args handle value rest cont handle args define run cont owner rest cont handle args remote run 
creator rest cont handle lambda handle value rest cont handle args fig 

options handler encounters remote continuation choose continuation frames faulted address space choose rest continuation executed address space continuation originally created 
fault frames implements alternative run cont owner implements second 
continuations scheme threads class objects represented continuations 
order support long lived distributed computations important allow threads migrate efficiently different address spaces load balancing locality criteria 
continuations may refer large amount state 
migrating thread simply copying entire continuation address space expensive practical 
alleviate overheads transmitting continuations implement form computation migration hsieh 
sending thread continuation involves sending top frames handle stored base sent continuation 
value slot handle contains rest continuation stack 
receiving thread spawned resumes continuation 
course computation thread return continuation base frame particularly case threads long lived subject frequent migration 
case avoiding copy entire continuation stack significantly reduce network traffic 
course top frames continuation refer large amount data significant amount copying may take place continuation migrated 
data top stack highly referenced continuation resumed receiver case data stored deeper frames continuation stack 
control pass base remote continuation object exception raised 
executing handler options 
example may choose execute remote run 
operation address space proxy base created 
operation fault frames continuation back receiver 
frames received handler fixes existing continuation resumes thread 
alternatively handler may choose apply value proxy proxy owner case thread migrates back original home 
illustrates alternatives 
define move 
aspace call cc lambda remote run 
aspace terminate current thread define move thread 
thread aspace cond eq 
thread current thread move 
aspace remove queue 
runnable threads thread remote run 
aspace thread continuation thread fig 

move 
move thread 
manipulate continuations 
move 
runs continuation current thread target address space move thread 
runs continuation input thread target address space 
procedures terminate thread source address space scheduling thread run case move 
removing thread runnable thread queue case move thread 

applications implementation techniques user level scheduling representing threads terms class procedures continuations enables number interesting novel paradigms 
important advantages abstractions ability migrate threads address spaces techniques migrate procedures 
thread scheduler capable migrating threads address spaces expressed entirely user code moving thread address space involves operations continuations 
defines procedures move threads current address space new 
called target aspace move 
captures continuation currently executing thread 
remote run 
continuation target address space 
remote run 
operation create new thread run continuation 
terminates thread source address space 
move thread 
similar move 
runs continuation input thread target address space 
envision number variations basic strategy provide greater control flexibility threads migrate 
variations build basic flexibility afforded class continuations procedures 
example shows basic structure thread scheduler uses centralized master offload tasks 
master records loads different address spaces 
offload procedure queries master address space find lightly loaded address space load address space exceeds threshold 
record move procedure records migration load information adjusted appropriately 
distributed systems monitoring behavior procedures offload find aspace problematic little support provided define offload current aspace 
get load max threshold thread find thread migrate runnable threads target remote apply master find aspace remote apply master record move target thread move thread 
thread target fig 

offload procedure coordinates central master address space determine target address space 
interaction 
programmers usually monitoring facilities procedures 
scheme gives users greater flexibility monitor debug ongoing computations 
example user send messages address space read eval print loop executing node configuration 
particular case user type expression repl print message load particular address space exceeds threshold 
remote apply master lambda source 
get load max threshold remote apply source display threshold exceeded current aspace represents repl prompt 
template associated expression lambda source constructed address space sender dynamically shipped master 
constraint requiring evaluation expression occur node address space containing master resides 
scheduling policies distributed system greatly simplified proxies 
especially case policies allow task migration address spaces 
consider definition distributed task queue 
tasks freely created tasks migrate address spaces 
task completes address space new task scheduled run set ready tasks define simple implementation abstraction 
create task dispatcher 
procedure creates new task queue spawns task dispatcher specified address space 
consider call add task 
task executing address space effect call new task enqueued task queue associated task queues proxies enqueue operation visible dequeue operations performed run task 
thread running task completes run tasks procedure dequeues new task runs 
proxies simplify implementation add task 
run task 
need aware address space called executed address space proxy value task queue returns value task queue avoiding need pass address spaces explicitly arguments procedures high degree abstraction preserved 
note task continuation ends call loop run tasks call causes new task define task queue proxy define add task 
task enqueue 
proxy value task queue task define run tasks loop new task dequeue 
proxy value task queue new task loop define create task dispatcher 
aspace initial task remote apply aspace lambda set proxy value 
task queue queue add task 
initial task spawn run tasks fig 

implementation simple distributed task queue 
implementation assumes tasks 
dequeue 
procedure assumed block argument queue empty 
dequeued queue accessed task queue proxy 
result migrating tasks address spaces requires special care 
client server applications ability download code dynamically reduce communication overhead tailoring communication protocol task hand 
clientserver applications example dynamic modification initial communication protocol especially important 
systems client server protocols fixed 
design decision expensive clients servers tightly coupled response times client server machines negligible message latency high 
example consider graphics application displays map world 
input program atlas represented list countries 
country name string list closed curves define country boundaries 
purpose application open window 
display boundaries countries 
track mouse 
mouse country country colored name displayed 
monitor keystrokes 
return key struck return name country mouse placed exit 
purposes application interesting run client machine different server machine controlling display 
tightly coupled networks latency cost waiting mouse event sent client translation may severe warrant special attention 
client server wide area network network bandwidth define pick country atlas point transformer transform window bounding box atlas bounding box atlas atlas transform atlas point transformer atlas mouse countries mouse countries atlas 
draw atlas 
atlas loop selected countries event get event case event type event motion new countries mouse countries motion position event cond equal 
selected countries new countries 
selected countries highlight 
new countries loop new countries key press cond eq 
return key press key name event destroy window 
map country name selected countries loop selected countries loop selected countries fig 

outline graphical atlas program 
latency sufficient communication demands placed application severe justify sophisticated partition server client 
ignoring remote communication provide simple outline application 
transform procedure returns procedure implements transformation bounding box atlas bounding box window atlas displayed 
atlas input atlas input coordinates transformed screen coordinates 
procedure mouse countries returns procedure mouse countries closed large table associates screen point list countries atlas overlap point mouse position mouse countries returns list countries mouse lies 
code shown mouse event involves communication server controlling display application containing atlas mouse countries procedure 
server runs aspace evaluating remote apply aspace pick country atlas cause application run machine server returning countries mouse resides user hits return key back client machine 
alternatively rewriting procedure slightly transmit data see 
version client computes coordinates countries atlas conform screen coordinates association cursor positions countries atlas computed server 
downloading code way simplifies protocol allows dynamic partitioning define pick country atlas server aspace point transformer transform window bounding box atlas bounding box atlas atlas transform atlas point transformer atlas remote apply server aspace lambda mouse countries mouse countries atlas 
fig 

offload functionality client server address spaces remote application 
define mouse countries atlas table handle handle mouse countries table atlas mirror mirror table lambda mouse position countries mirror table lookup mirror mouse position unknown 
countries countries remote apply proxy creator table handle lambda lookup mouse countries handle value table handle mouse position add mirror table 
mirror mouse position countries countries countries fig 

incrementally building server mirror table associates screen coordinates countries reduce communication costs 
table entries retrieved client mouse moves portion atlas coordinates locally available display server 
assume table representation provides efficient access sparse data 
machines 
sun news sun microsystems permits code transmitted similar way applications downloading postscript programs server 
news protocol lower level programs passed source text token sequences 
automatic encoding data structures significant support distributed programming uses lower level programming language 
making implementation mouse countries aware address spaces reduce communication costs 
procedure returned mouse countries wrapped handle table builds server incrementally construct mirror copy table demand 
code effect incremental faulting mouse country table client server outlined 
define dna workers worker db proxies map lambda aspace remote apply aspace proxy worker values add 
db proxies find nearest db proxies fig 

db proxies list proxies 
value ith element contains portion database seen ith worker 
parallelism final example consider implementation dna sequence comparison algorithm carriero gelernter 
algorithm takes input target string database initiates parallel search string database returning result closeness element database bears greatest similarity target 
natural implementation strategy master worker arrangement master creates number worker threads worker responsible comparing target specific portion database 
thread finds local best match notifies master terminates 
master completes threads complete returning global best string 
kind application suited implementation scheme benefits liberal higher order procedures 
associated worker proxy owned address space worker live 
proxy contain portion database examined worker 
addition require procedure add new elements worker portion database 
procedure search routine worker procedure shown 
add 
procedure simply keeps track total length entries worker portion data base 
new item add finds worker smallest local data base adds entry workers proxy 
proxy value add database addition accomplished evaluating expression remote apply proxy creator proxy lambda set proxy value 
proxy cons dna proxy value proxy remote apply versus remote run 
simply synchronization provides 
note dna implicitly copied worker address space occurs free procedure evaluated remote apply find nearest returns procedure called string returns distance closest item database string 
spawns thread worker 
thread find closest entry worker database calling local find nearest update location closest item far 
worker finish writes result condition variable read top level thread 
define find nearest db proxies length db proxies lambda dna goal lock lock left far infinitely far entry final result condvar lambda db proxy spawn lambda local best local find nearest dna goal db proxy lock lock set 
far closest entry far local best set 
left left zero 
left condvar set 
final result far db proxies condvar ref final result fig 

master task dna database search program 
define local find nearest dna goal db proxy remote apply proxy creator db proxy lambda loop best entry infinitely far entry entries proxy value db proxy null 
entries best entry loop closest entry best entry closeness dna goal car entries cdr entries fig 

worker threads execute local find nearest find closest match portion database 
heart master task shown 
local find nearest dna string searching proxy holding workers local database simply executes remote apply operation targeted worker address space procedure spawned folds local database find closest item definition 

garbage collection local garbage collection gc proceed asynchronously address space long proxies local values preserved 
proxies collected locally proxy sent received address space potentially accessible address spaces remote run 
operations 
section describe nonlocal gc algorithms proxies asynchronous collect cycles synchronous 
asynchronous garbage collection asynchronous gc algorithm system designed assumptions mind remote ephemeral creating destroying cheap entail minimal bookkeeping overhead 
message communication costly relative computation garbage collection minimize synchronization messages leads aggressive collection strategy 
messages delivered fifo order processors bound communication latency 
assumed arrival order messages sent different address space sender 
assumption consequence functional programming style encouraged scheme 
mutation rare objects tend short lived objects tend allocated deallocated frequently tend mutated reinhold 
procedures tend small lightweight 
consequently distributed system scheme remote tend short lifetimes 
assumptions derive constraints imposed commercially available low network technology protocols testing prototype 
gc algorithm uses bit flags proxy 
enroute flag indicates proxy included outgoing message creator asynchronous proxy collection 
referenced flag set proxy created received message 
flag cleared local collection reveals local proxy 
proxies local value enroute flag clear may collected address space time 
procedure address space garbage collect proxies created follows notifies address spaces garbage collecting proxies 
address space receives gc notification sends set proxies currently extant flag set clears enroute flags proxies 
reclaim proxies local lists proxies returned address spaces 
notifies proxies reclaim proxy originally collect local values collected included list returned gives graphical depiction algorithm 
algorithm simple asynchronous 
fundamental flaws 
collect cycles proxies remedy defining synchronous variant collector 
serious problem algorithm potentially reclaim proxies referenced 
repairing lack safety requires making algorithm weakly synchronous 
sequence events illustrates problem algorithm see 
replies reachable clears enroute flag 



local collections enroute 

gc 

initiates asynchronous proxy collection enroute 



includes message marks enroute enroute 
collect 

reclaims tells reclaim gc reply 




local collections fig 

asynchronous collection proxies 
proxies shown created referenced locally 
proxies garbage collected 
proxies local values depicted 
creates proxy sends 
sends setting enroute flag 
starts gc procedure sending messages 
reports clears enroute flag reclaims local copy 
reports proxies transit 
finishes collection reclaim reported having 
performs second garbage collection 
time report having reclaims 
message containing arrives proxy value longer exists 
critical observation message transmission atomic global time ordering message events 
may consistent images shared data consistency extend include shared objects held transit remedy problems define global tick thread creates coarse grain time ordering message transmission 
behavior thread guarantees messages transit time tick thread visited address space received tick arrives 
assume linear ordering address spaces 
running address space tick thread sends message remote apply enroute enroute proxies enroute proxies gc gc proxies gc gc sends arrives sends gc reports gc reclaimed enroute enroute enroute enroute enroute proxies fig 

impose constraints communication latency simple asynchronous gc strategy may erroneously collect live data associated accessible proxy 
numbers parentheses refer corresponding steps text 
address space greater ordering message simply executes null procedure 
messages acknowledged address spaces tick thread moves address space ordering 
address spaces visited guaranteed message transit iteration tick reached destination 
waiting full tick consecutive arrivals tick thread garbage collections ensure proxy enroute garbage collection arrived destination time collection 
algorithm simple highly local relies assumption messages delivered fifo order channel 
imagine aggressive collection strategy reclaims dead remote eagerly suspect schemes simple unobtrusive 
collecting cycles asynchronous collector unable collect cycles proxies 
proxy owned address space value proxy owned turn value prevent reclaiming vice versa 
prevent scenario proxies cycle need reclaimed simultaneously 
algorithm handling cycles follows address spaces computing 
address space uses local garbage collector determine proxies local determines proxy set proxies reachable value sets interpreted graph edge indicating proxy value reachable 
address spaces cooperatively walk graph reachable proxies starting locally referenced ones marking reachable proxy 
unmarked proxies reclaimed 
worst case algorithm requires time linear number proxies 
practice expect applications create cycles proxy graph vast majority proxies reclaimed asynchronous algorithm 
comparision distributed collectors counting collection strategies lang asynchronous collector requires bits reclaim proxies 
approach bears greater similarity distributed marking schemes messages kamada venkatasubramanian confirm message arrival 
schemes tick process provide effect asynchronous respect user processes requires extra acknowledgment signals centralized 
cyclic extension synchronous complexity bounded number proxies number messages proxies sent 
garbage collection algorithm network objects birrell shares similarity 
systems permit proxies forwarded address spaces owner systems weakly synchronous insofar local garbage collections address space occur requiring global synchronization 
important differences 
part differences reflect differences systems capabilities 
example scheme network objects designed tolerate node failure 
network objects collector uses counting scheme owner shared object maintains list processes proxy surrogate clients longer refer proxy notify owner 
approach effectively prohibits collector reclaiming cycles 
scheme simple flags reclaim proxies lists maintained 
owner proxy entity initiate proxy collection 
significantly network objects collector assumes tight coupling message sends proxy surrogate collection 
avoid race conditions kind outlined network objects implementation uses acknowledgments record network handles enroute address space transmission proxies collected sender 
system rpc semantics acknowledgments piggy back method return calls special acknowledgment signals necessary proxy returned result rpc call 
scheme collector requires acknowledgments proxy receivers remote run 
operations 
table baseline times times execute milliseconds remote run 
remote apply time send seconds proxy integer arg vector procedure thread 
performance sequential core system compiles byte codes performance system obviously poorer native code implementation 
validate utility language abstractions byte code implementation appears reasonable compromise inefficient simple source level interpreter efficient portable native code compiler 
primary goal investigating applicability higher order language features express interesting abstractions distributed computing view lack native code performance critical assessing system utility 
presence native code compiler expect see factor fold reduction message interpretation overhead 
message decoder implemented virtual machine baseline times message transmission despite fact operations require byte code interpretation 
table gives baseline times system 
column gives measurements taken mips mhz processors connected mb ethernet 
second column provides times benchmarks mhz machines connected mb ethernet 
note cost sending tcp ip packet user space user space takes roughly milliseconds network 
number determined dividing time required send packet receive reply 
baseline comparison scheme takes seconds execute null procedure seconds execute 
takes seconds spawn thread calls null procedure schedule apply thunk return takes seconds operation 
rows measure cost remote run 
remote apply operation null procedure remote apply measures round trip time 
times remote run 
see subtracting overhead tcp ip milliseconds seconds spent scheme 
time seconds involved thread creation context switching synchronization indicating roughly seconds spent transport layer decoding dispatching 
expect overheads executing remote run 
dominated foremost tcp ip costs secondly thread management overheads 
transport layer contributes small overhead compared costs 
transport layer implemented scheme virtual machine compiled code 
note implementation moved thread functionality virtual machine tcp ip costs dominant 
rows measure cost sending proxy integer argument vector elements procedure empty environment minimal thread 
rows measures overheads simple remote run 
operation 
remote apply time expect roughly twice cost remote run 
cost sending proxy roughly sending simple integer argument extra overhead due administrative costs record receipt proxy appropriate tables 
extra cost sending thread procedure due large part need migrate thread dynamic environment top frames continuation 

related lightweight distributed communication facility described differs important respects rpc mechanisms distributed languages birrell nelson schroder burrows 
languages typically order issue sending dynamically instantiated closures usually considered 
secondly marshaling code system permits scheme object including continuations top level new definitions sent message constraint kinds objects sent 
notion proxies generalization network objects described birrell 
network objects objects encapsulated proxy consistent address spaces 
proxy unique owner express behavior shared data object 
importantly design implementation network objects geared class procedures continuations mind contrast applications considered implementation liberally higher order structures 
proxies associated set methods scheme typed type enforcement proxies explicit stub modules generate marshaling code different scheme types 
scheme latent typing discipline type errors detected runtime 
consider remote run 
operation evaluated address space spawns thread address space application closure associated may raise runtime exception defined type errors common example exceptions flagged compile time 
progress building type systems optimizers scheme catch potential type errors statically jagannathan wright wright cartwright 
believe incorporating facilities scheme significantly alleviate debugging overheads incurred 
obliq cardelli higher order distributed language built top network objects 
obliq allows immutable data freely transmitted generates network mutable structures 
obliq support addressing proxies 
contrast implementation implicit assumptions objects transmitted scheme object including thread continuation explicitly copied referenced proxy 
obliq support class continuations availability firstclass functions possible program continuation passing style 
obliq implemented source level interpreter 
contrast rely heavily able send partial continuation objects different address spaces implementation intended compiled programs 
java sun microsystems byte coded system intended heterogeneous distributed environments 
scheme java allows byte codes transmitted nodes sequential core support higher order abstractions procedures continuations class threads 
language define sharing abstractions similar proxies 
cml reppy concurrent dialect ml supports class events channels preemptible threads 
system shares common features cml insofar rely heavily class continuations procedures implementation 
cml provide explicit support distributed computation include abstractions building remote address spaces 
consider distributed garbage collection disjoint address spaces 
facile extension ml intended operate distributed environment 
concurrency model facile generalization ccs milner 
consequently distributed computing facile synchronous communication channels language analogues address spaces proxies system support asynchronous message passing primitives described 
piranha carriero implementation linda runs networks workstations 
system lack class continuation objects problematic piranha adapt gracefully changing network loads 
piranha process node discard far performed current task require programmer construct manually continuation object executed resumption 
reification task state continuation problematic context contrast threads implemented terms continuations migrating thread retreating processor easily specified operation system 
addition piranha tuple space implementation fundamental communication abstraction shared data expressed terms tuples conceptually distinct basic proxy abstraction defined 
presumably implemented terms argue particular context proxies provide lighter weight flexible communication abstraction 
parallel systems operate separate address spaces support message communication pvm sunderam similar differences 
parallel dialects higher order languages scheme ml jagannathan philbin morrisett tolmach execute single address space 
systems provide primitives allow threads explicitly communicate disjoint address spaces 
consequently semantics implementation targeted applications differ important respects ones described 
split culler parallel extension provides global address space 
design split shares commonality allowing programmers significant amount control communication costs 
extension programming model paradigms supports differ obvious ways distributed system class procedures class continuations incremental distributed linking code objects 
process migration powell miller computation migration hsieh approaches moving threads distributed environments 
implementation shares common computation migration insofar continuations migrated lazily 
hsieh continuation migration protocols integrated scheme exception handling facility handlers different nodes choose implement different functionality control passes sent continuation base 
example error raised thread treated migrating thread back original home faulting error handler thread current address space 
scheme support class procedures continuations ideal platform explore new paradigms idioms distributed computing 
ability express new abstractions terms available language greatly simplifies implementation 
importantly allows users build nontrivial refinements extensions reengineering system scratch 
conclude high level data control abstractions offer domains distributed computing number important benefits abstractions express distributed applications merit continued investigation 
copy system sources obtained url www neci nj nec com pls html 
acknowledgments anonymous referees luca cardelli john ellis useful comments suggestions 
andrews 
concurrent programming principles practice 
benjamin cummings menlo park calif arvind nikhil pingali 
structures data structures parallel computing 
acm trans 
program 
lang 
sys 

birrell nelson owicki wobber 
distributed garbage collection network objects 
tech 
rep digital src research rep equipment palo alto calif birrell nelson owicki wobber 
network objects 
tech 
rep digital src research rep equipment palo alto calif birrell nelson 
implementing remote procedure call 
acm trans 
comput 
syst 

cardelli 
language distributed scope 
proceedings nd acm symposium principles programming languages 
acm new york 
carriero gelernter 
write parallel programs guide 
mit press cambridge mass carriero gelernter kaminsky 
piranha scheduling strategies implementation 
int 
parallel program 

clinger rees 
revised report algorithmic language scheme 
acm lisp pointers july 
cox dwarkadas keleher lu zwaenepoel 
software versus hardware shared memory implementation case study 
proceedings st annual international symposium computer architecture 
ieee new york 
culler dusseau seth copen krishnamurthy thorsten von yelick 
parallel programming split 
proceedings acm symposium supercomputing 
acm new york 
curtis 
social text virtual realities 
tech 
rep csl xerox palo alto research center palo alto calif mishra prasad 
facile symmetric integration concurrent functional programming 
int 
parallel program 

haynes friedman 
embedding continuations procedural objects 
acm trans 
program 
lang 
syst 

hsieh wang weihl 
computation migration enhancing locality distributed memory parallel systems 
th acm sigplan symposium principles practice parallel programming 
acm new york 
jagannathan philbin 
foundation efficient multi threaded scheme system 
proceedings conference lisp functional programming 
acm new york 
jagannathan wright 
effective flow analysis avoiding runtime checks 
proceedings international static analysis symposium lecture notes computer science vol 

springer verlag berlin 
kamada matsuoka yonezawa 
efficient parallel garbage collection massively parallel computers 
proceedings ieee supercomputing conference 
ieee new york 
kelsey 
tail recursive stack disciplines interpreter 
tech 
rep nu ccs northeastern univ college computer science boston mass kelsey rees 
tractable scheme implementation 
lisp symbol 
comput 

kranz johnson agarwal kubiatowicz lim 

integrating message passing shared memory early experience 
proceedings th acm sigplan symposium principles practice parallel programming 
acm new york 
kranz kelsey rees hudak philbin adams 
orbit optimizing compiler scheme 
acm sigplan 
july 
lang queinnec 
garbage collecting world 
proceedings th acm symposium principles programming languages 
acm new york 
li hudak 
memory coherence shared virtual memory systems 
acm trans 
comput 
syst 

milner 
communication concurrency 
prentice hall englewood cliffs milner tofte harper 
definition standard ml 
mit press cambridge mass morrisett tolmach 
procs locks portable multiprocessing platform standard ml new jersey 
th acm symposium principles practice parallel programming 
acm new york 
mullender ed 

distributed systems 
addison reading mass powell miller 
process migration demos mp 
proceedings th acm symposium operating systems principles 
acm new york 
reinhold 
cache performance garbage collected programs 
proceedings acm symposium programming language design implementation 
acm new york 
reppy 
cml higher order concurrent language 
proceedings sigplan conference programming language design implementation 
acm new york 
schroder burrows 
performance firefly rpc 
acm trans 
comput 
syst 

sun microsystems 
news programmer guide 
sun microsystems mountain view calif sun microsystems 
java language specification 
sun microsystems mountain view calif sunderam 
pvm framework parallel distributed computing 
concurrency pract 
exper 

venkatasubramanian agha talcott 
scalable distributed garbage collection systems active objects 
memory management lecture notes computer science vol 

springer verlag berlin 
wright cartwright 
practical soft type system scheme 
proceedings acm symposium lisp functional programming 
acm new york 
received april revised july accepted september 
