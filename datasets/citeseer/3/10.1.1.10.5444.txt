making gnutella systems scalable chawathe labs research research att com nick lanham uc berkeley cs berkeley edu napster pioneered idea peer peer file sharing supported centralized file search facility 
subsequent systems gnutella adopted decentralized search algorithms 
gnutella notoriously poor scaling led propose distributed hash table solutions wide area file search problem 
contrary trend advocate retaining gnutella simplicity proposing new mechanisms greatly improve scalability 
building prior research propose modifications gnutella design dynamically adapt overlay topology search algorithms order accommodate natural heterogeneity peer peer systems :10.1.1.160.7346:10.1.1.132.970
test design simulations results show orders magnitude improvement total system capacity 
report prototype implementation deployment testbed 
categories subject descriptors computer communication networks distributed systems general terms algorithms design performance experimentation keywords peer peer distributed hash tables gnutella 
peer peer file sharing revolution started napster 
napster system recognize requests popular content need sent central server handled hosts peers possess content 
serverless peer peer systems achieve aggregate download capacities requiring additional expenditure bandwidth server farms 
supported part nsf itr ani itr itr itr ani 
instance peers connected kbps provide aggregate download capacity single server farm connected oc links 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sigcomm august karlsruhe germany 
copyright acm 
sylvia ratnasamy intel research sylvia intel research net scott shenker icsi shenker icsi berkeley edu lee breslau labs research breslau research att com file sharing systems self scaling peers join system look files add aggregate download capability 
self scaling behavior node looking files find peers desired content 
napster centralized search facility file lists provided peer 
centralizing search require bandwidth distributing download napster achieved highly functional hybrid design 
resulting system widely acknowledged fastest growing internet application 
lawsuit forced napster shut various centralized search successors faced similar legal challenges 
centralized systems replaced new decentralized systems gnutella distribute download search capabilities 
systems establish overlay network peers 
queries sent central site distributed peers 
gnutella systems uses unstructured overlay network topology overlay network placement files largely unconstrained 
floods query overlay limited scope 
receiving query peer sends list content matching query originating node 
load node grows linearly total number queries turn grows system size approach clearly scalable 
gnutella lead decentralized file sharing systems kazaa popular 
kazaa proprietary fasttrack technology uses specially designated supernodes higher bandwidth connectivity 
pointers peer data stored associated supernode queries routed supernodes 
approach appears offer better scaling gnutella design documented analyzed 
proposals incorporate approach gnutella network 
gnutella clients implement supernode proposal scalability measured analyzed 
said believe supernode approach popularized kazaa step right direction building scalable filesharing systems 
leverage idea exploiting node heterogeneity selection supernodes construction topology dynamic adaptive 
new file sharing system called gia 
gnutella kazaa gia decentralized unstructured 
unique design achieves aggregate system capacity self scaling property mitigated extent free rider problem observed systems 
gia short generic name spread 
orders magnitude better gnutella attempts improve gnutella :10.1.1.132.970
retains simplicity unstructured system offering vastly improved scalability 
design gia builds substantial body previous 
lv gia replaces gnutella flooding random walks :10.1.1.132.970
adamic gia recognizes implications overlay network topology random walks includes topology adaptation algorithm 
similarly lack flow control recognized weakness original gnutella design gia introduces token flow control algorithm 
kazaa gia recognizes significant heterogeneity peer bandwidth incorporates heterogeneity aspect design 
gia build previous contributions gia knowledge open design combines elements recognizes fact peers capacity constraints adapts protocols account constraints 
simulations suggest results tremendous boost gia system performance 
performance improvement comes just single design decision synergy various design features 
discuss gia design section performance section prototype implementation associated practical issues section 
embarking description gia ask just distributed hash tables dhts 

dhts 
distributed hash tables class developed systems provide hash table semantics internet scale 
original rationale dhts provide scalable replacement unscalable gnutella file sharing systems 
past years seen research activity field design proposals suggested applications 
proposals structured overlay networks data placement overlay topology tightly controlled 
hash table lookup operation provided dhts typically requires log steps comparison gnutella requires steps reliably locate specific file 
level performance gain afforded dhts natural ask bother gia dhts available 
answer question review relevant aspects file sharing 
clients extremely transient 
measured activity gnutella napster indicates median time node minutes 
large systems say nodes implies churn rate nodes coming going minute 
churn causes little problem gnutella systems employ unstructured overlay networks long peer doesn disconnected loss neighbors case peer merely repeat bootstrap procedure re join network 
contrast churn cause significant overhead dhts 
order preserve efficiency correctness routing dhts require log repair operations failure 
failures node fails informing neighbors transferring relevant state require time dhts discover failure lost data pointers 
churn rate high overhead caused repair operations substantial understand published questions exact numbers study basic point remains peer population quite transient 
download requests available replicas download requests replicated files 
easily overwhelm nodes low bandwidth dial connections 
keyword searches prevalent important exact match queries 
dhts excel supporting exact match lookups exact name file translate name key perform corresponding lookup key operation 
dhts les adept supporting keyword searches sequence keywords find files match 
current file sharing systems revolves sharing music video requires keyword matching 
example find song ray light user typically submits search form ray light expects file sharing system locate files match keywords search query 
especially important unambiguous naming convention file names systems piece content stored different nodes slightly different names 
supporting keyword searching top dhts nontrivial task 
example typical approach constructing inverted index keyword expensive maintain face frequent node file churn 
complicated additional caching algorithms needed avoid overloading nodes store index popular keywords 
possible problems addressable dhts indicated deployment overnet file sharing application kademlia dht 
dht solutions typically need go great lengths incorporate query models simple exact match search 
contrast gnutella similar systems effortlessly support keyword searches complex queries searches executed locally node node basis 
queries hay needles 
dhts exact recall knowing name file allows find single copy file system 
contrast gnutella reliably find single copies files flooded query reaches nodes call files needles 
expect queries popular file sharing systems relatively replicated files call hay 
nature file sharing file requested frequently requesters download file machines copies system 
call systems queries replicated content mass market filesharing systems 
gnutella easily find replicated files 
searches hay needles gnutella lack exact recall significant disadvantage 
verify conjecture queries hay gathered traces queries download requests instrumented gnutella client 
tracing tool crawled gnutella network searching files match top query requests seen 
gathering file names number available copies files tool turned offered files download gnutella clients 
measured number download requests seen tracing tool offered content 
shows distribution download requests versus number available replicas 
notice requests correspond files large number available replicas 
example half requests files replicas approximately requests files replicas 
summary gnutella designs robust face transients support general search facilities important properties file sharing 
adept dhts finding needles may matter queries hay 
conjecture mass market file sharing applications improving scalability unstructured systems turning dht systems may better approach 

gia design gnutella systems basic problem faced high aggregate query rate nodes quickly overloaded system ceases function satisfactorily 
problem gets worse size system increases 
goal designing gia create gnutella system handle higher aggregate query rates 
second goal gia continue function increasing system sizes 
achieve scalability gia strives avoid overloading nodes explicitly accounting capacity constraints 
earlier workshop preliminary proposal incorporating capacity awareness gnutella 
current refine ideas thorough design detailed algorithms prototype implementation new system 
overview reasoning system design provide detailed discussion various components protocols 
design rationale gnutella protocol uses flooding search method find files network 
locate file node queries neighbors turn propagate query neighbors query reaches clients certain radius original querier 
approach locate files replicated extremely small number nodes obvious scaling problems 
address issue lv proposed replacing flooding random walks :10.1.1.132.970
random walks known technique query message forwarded randomly chosen neighbor step sufficient responses query 
better utilization network flooding associated problems 
random walk essentially blind search step query forwarded random node account indication node responses query 
note tracing tool captures download requests came directly requests went nodes copies file 
numbers lower bound popular replicated content 
random walker query arrives node overloaded traffic may get queued long time handled 
adamic addressed problem recommending purely random walks search protocol bias walks high degree nodes 
intuition arrange neighbors aware shared files high degree nodes pointers large number files answer matches query 
approach ignores problem overloaded nodes 
fact biasing random walk high degree nodes exacerbate problem node capacity handle large number queries 
design gia hand explicitly takes account capacity constraints associated node network 
capacity node depends number factors including processing power disk latencies access bandwidth 
documented nodes networks gnutella exhibit significant heterogeneity terms capacity handle queries 
prior scaling gnutella systems leverages heterogeneity 
design gia explicitly accommodate exploit heterogeneity achieve better scaling 
key components design summarized dynamic topology adaptation protocol puts nodes short reach high capacity nodes 
adaptation protocol ensures connected high degree nodes receive large proportion queries capacity handle queries 
active flow control scheme avoid overloaded hot spots 
flow control protocol explicitly acknowledges existence heterogeneity adapts assigning flow control tokens nodes available capacity 
hop replication pointers content 
nodes maintain pointers content offered immediate neighbors 
topology adaptation algorithm ensures congruence high capacity nodes high degree nodes hop replication guarantees high capacity nodes capable providing answers greater number queries 
search protocol biased random walks directs queries high capacity nodes typically best able answer queries 
detailed design framework gia client protocols modeled current gnutella protocol 
clients connect way handshake protocol 
messages exchanged clients tagged origin globally unique identifier guid randomly generated sequence bytes 
guid track progress message gia network route responses back originating client 
extend gnutella protocol take account client capacity network heterogeneity 
discussion assume client capacity quantity represents number queries client handle second 
practice capacity determined function client access bandwidth processing power disk speed discuss protocol components detail 
ci represent capacity node num max nbrs room accept return need drop neighbor subset ci cy neighbors exist reject return candidate highest degree neighbor subset cy max ci higher capacity num num fewer nbrs drop accept reject algorithm pick neighbor drop node tries add new neighbor determine room pick existing neighbors drop replace 
algorithm represents hysteresis factor 
topology adaptation topology adaptation algorithm core component connects gia client rest network 
section provide overview adaptation process leaving details specific mechanisms discussion section 
node starts uses bootstrapping mechanisms similar gnutella locate gia nodes 
gia client maintains host cache consisting list gia nodes ip address port number capacity 
host cache populated lifetime client variety rendezvous mechanisms including contacting known web host caches exchanging host information neighbors ping pong messages 
entries host cache marked dead connections hosts fail 
dead entries periodically aged 
goal topology adaptation algorithm ensure high capacity nodes ones high degree low capacity nodes short reach higher capacity ones 
achieve goal node independently computes level satisfaction 
quantity represents satisfied node current set neighbors 
value means node quite dissatisfied suggests node fully satisfied 
long node fully satisfied topology adaptation continues search appropriate neighbors improve satisfaction level 
node starts fewer pre configured minimum number neighbors dissatisfied state 
gathers neighbors satisfaction level rises decides current set neighbors sufficient satisfy capacity point topology adaptation quiescent 
section describe details algorithm compute satisfaction level 
add new neighbor node say randomly selects small number candidate entries host cache marked dead neighbors 
randomly chosen entries selects node maximum capacity greater capacity 
candidate entry exists selects random 
node initiates way handshake selected neighbor say handshake node decision accept node new neighbor capacities degrees existing neighbors new node 
order accept new node may need drop existing neighbor 
algorithm shows steps involved making determination 
algorithm works follows 
accepting new connection total number neighbors bound max nbrs connection automatically accepted 
node see find appropriate existing neighbor drop replace new connection 
favors drops existing neighbor higher capacity current neighbors 
decides retain follows 
neighbors capacity equal choose neighbor highest degree 
neighbor lose drops favor neighbor dropped new node fewer neighbors ensures drop poorly connected neighbors get disconnected favor connected ones 
topology adaptation algorithm tries ensure adaptation process forward progress stable state 
results experiments measuring topology adaptation process discussed section 
flow control avoid creating hot spots overloading node gia uses active flow control scheme sender allowed direct queries neighbor neighbor notified sender willing accept queries sender 
contrast proposed gnutella flow control mechanisms reactive nature receivers drop packets start overloaded senders infer likelihood neighbor drop packets responses receive neighbor explicit feedback mechanism 
technique may acceptable queries flooded network node drops query copies query propagate network 
gia uses random walks address scaling problems flooding forward single copy query 
arbitrarily dropping queries appropriate solution 
provide better flow control gia client periodically assigns flow control tokens neighbors 
token represents single query node willing accept 
node send query neighbor received token neighbor avoiding overloaded neighbors 
aggregate node allocates tokens rate process queries 
receives queries faster forward overloaded received tokens neighbors starts queue excess queries 
queue gets long tries reduce inflow queries lowering token allocation rate 
provide incentive high capacity nodes advertise true capacity gia clients assign tokens proportion neighbors capacities distributing evenly neighbors 
node advertises high capacity handle incoming queries turn assigned tokens outgoing queries 
token assignment algorithm start time fair queuing 
neighbor assigned fair queuing weight equal capacity 
neighbors assigned tokens marked inactive left capacity automatically redistributed proportionally remaining neighbors 
neighbors join leave algorithm recon avoid having flip back forth add level hysteresis drop add fewer neighbors represents level hysteresis 
simulations implementation set value 
figures token allocation accordingly 
token assignment notifications sent neighbors separate control messages piggy backing messages 
hop replication improve efficiency search process gia node actively maintains index content neighbors 
indices exchanged neighbors establish connections periodically updated incremental changes 
node receives query respond matches content provide matches content offered neighbors 
neighbor lost leaves system due topology adaptation index information neighbor gets flushed 
ensures index information remains date consistent lifetime node 
search protocol combination topology adaptation high capacity nodes neighbors hop replication nodes keep index neighbors shared files ensures high capacity nodes typically provide useful responses large number queries 
gia search protocol uses biased random walk forwarding incoming queries randomly chosen neighbors gia node selects highest capacity neighbor flow control tokens sends query neighbor 
tokens neighbors queues query new tokens arrive 
ttls bound duration biased random walks book keeping techniques avoid redundant paths 
bookkeeping query assigned unique guid originator node 
node remembers neighbors forwarded queries guid 
query guid arrives back node forwarded different neighbor 
reduces likelihood query traverses path twice 
ensure forward progress node sent query neighbors flushes book keeping state starts re neighbors 
query max responses parameter maximum number matching answers query search 
addition ttl query duration bounded max responses 
time node finds matching response query decrements max responses query 
max responses hits zero query discarded 
query responses forwarded back originator reverse path associated query 
reverse path lost due topology adaptation queries responses dropped node failure rely recovery mechanisms described section handle loss 
node generate response files files neighbors append forwarded query addresses nodes files 
ensures query produce multiple redundant responses instance file response generated node owns matching file listed query message 

simulations section simulations evaluate gia compare performance unstructured systems 
simulations refer models details algorithm proportional allocation 
capacity level percentage nodes table gnutella node capacity distributions 
flood search ttl scoped flooding random topologies 
represents gnutella model 
rwrt search random walks random topologies 
represents recommended search technique suggested lv avoiding scalability problems flooding :10.1.1.132.970:10.1.1.132.970
super search supernode mechanisms 
approach classify nodes supernodes non supernodes 
queries flooded supernodes 
gia search gia protocol suite including topology adaptation active flow control hop replication biased random walks 
describe simulation model metrics evaluating performance algorithms 
report results range simulations 
experiments focus aggregate system behavior terms capacity handle queries variety conditions 
show individual components system topology adaptation flow control hop replication searches biased random walks synergies affect total system capacity 
due space limitations detailed results evaluating tradeoffs design component 
system model capture effect query load system gia simulator imposes capacity constraints nodes system 
model node possessing capacity ci represents number messages queries add drop requests topology adaptation process unit time 
node receives queries neighbors rate higher capacity ci happen absence flow control excess queries modeled queued connection buffers receiving node read queries buffers 
simulations assign capacities nodes distribution derived measured bandwidth distributions gnutella reported saroiu 
capacity distribution levels capacity separated order magnitude shown table 
described distribution reflects reality fair fraction gnutella clients dial connections internet majority connected cable modem dsl small number participants high speed connections 
super experiments nodes capacities designated supernodes 
addition capacity node assigned query generation rate qi number queries node generates unit time 
experiments assume nodes generate queries rate bounded course capacities 
queries need buffered held queues 
model incoming outgoing queues having infinite length 
realize practice queues infinite assumption effect dropping query adding arbitrarily long queue essentially 
success rate replication replication queries second hop count successful queries replication replication queries second delay replication replication queries second success rate hop count delay increasing query load node gia network 
queries modeled searching specific keywords 
keyword maps set files 
files randomly replicated nodes 
files associated specific keyword potential answers query keyword 
term replication factor refer fraction nodes answers queries reside 
performing query keyword replication factor implies answer query nodes system 
deployed system real search traffic include different queries covering range replication factors simultaneously 
search process proceeds largely independently aside delays queues actions flow control 
having pick specific distribution queries looking keywords replication factors focus stream queries particular replication factor study results vary change replication factor 
simulations randomly connected topology 
gia simulations topology adaptation reconfigure initial topology 
algorithms pre configured parameters min nbrs max nbrs 
experiments min nbrs 
set max nbrs 
additional constraint max nbrs 
avoid mid low capacity nodes gathering neighbors capacity finely divided require min alloc min alloc num nbrs represents finest level granularity willing split node capacity 
additional constraint note node max nbrs min max nbrs min alloc 
preliminary simulations tested performance gia topology adaptation different values min alloc settled min alloc 
control traffic generated topology adaptation components modeled consuming resources unit capacity message 
simulator indirectly captures impact control traffic performance system 
rwrt flood topology adaptation random graph 
know gnutella networks fact exhibit properties similar power law graphs 
assurance high degree nodes skewed gnutella distribution high capacity nodes 
fact absence explicit congruence high capacity high degree random walk cause high degree nodes get overloaded 
comparing random walk topology gia unfairly bias results random walk 
rwrt choose purely random topology uniform degree distributions mitigates problem 
rwrt performance uniformly random graph independent degree individual nodes super experiments topology supernodes set random connections 
addition connect supernode random 
nodes visited probability 
hand performance flood depend degree fact worsens higher degree 
experiments chose uniformly random graphs average degree 
choice ad hoc reflects decision avoid unnecessarily biasing rwrt flood 
average diameter random graphs 
flood super set ttl queries ensure queries get artificially limited 
rwrt gia ttl set larger value case setting right ttl value crucial random walks terminate find required number responses 
simulator models behavior various protocols discussed section capture individual behavior account vagaries network behavior caused background traffic 
point quantify absolute performance algorithm realworld terms evaluate relative performance various design choices 
section preliminary results report experiences implementing deploying gia wide area internet 
performance metrics measure effect load system looked aspects system performance function offered load success rate measured fraction queries issued successfully locate desired files hop count measured number hops required locate requested files delay measured time taken query start finish 
shows success rate hop count delay increasing query load node network running gia system 
graphs remainder simulations mention query load say mean node system issues queries unit time bounded node capacity course 
graphs shows query load increases notice sharp knee curves success rate drops sharply delays increase rapidly 
hop count holds steady knee point decreases 
reason decrease hop count measured successful queries increasing load successful queries tend requested file located hops originator query 
graphs depict existence knee gia model simulations rwrt flood super range replication factors revealed kind behavior different query loads 
query deemed unsuccessful simulation generated responses stuck queues overloaded nodes 
collapse point gia rwrt flood super gia rwrt flood super replication rate percentage comparison collapse point different algorithms varying replication rates different system sizes 
ideally want system achieves high success rate maintaining low hop count delay 
system operate knee shown graphs 
consequently define metrics evaluation collapse point cp node query rate knee define point success rate drops 
metric reflects total system capacity 
hop count collapse cp hc average hop count prior collapse 
retain delay metric effect increasing delay effectively captured collapse point 
performance comparison compare behavior gia rwrt super flood varying replication factors different system sizes nodes 
measured cp cp hc increasing replication factors 
figures plot results systems nodes 
experiments additional system sizes yielded results consistent omit graphs clarity 
node system simulate replication corresponds single matching answer entire system query 
likewise nodes simulate replication 
believe replication factor nodes holds answer query represents fairly pessimistic test scenario 
query experiments runs finds matching answer 
represents case query originator sets max responses parameter see section query 
reality users expect query return multiple answers look scenario 
gia rwrt measure average hop count queries 
super flood query gets replicated hop hard define consistent hop count entire query measure hop count number hops taken find answer 
recall goal designing gia enable handle higher aggregate query rate gnutella 
obvious important observation figures aggregate system capacity defined collapse point orders magnitude higher flood rwrt 
compared supernode approach gia better especially higher replication rates 
surprising flooding techniques supernodes limit scalability 
goal improving system capacity gia clearly achieved 
second goal gia retain ability handle high aggregate query rates systems arbitrary sizes 
observed graphs goal satisfied 
gia rwrt scaling behavior determined replication factor 
hop count collapse gia rwrt flood super gia rwrt flood super replication rate percentage hop count collapse 
fixed replication factor cp cp hc largely unaffected system size 
expected replication factor percentage nodes answers located 
performance figures show apply arbitrarily large system sizes 
performance results note 
higher replication factors rwrt performs better flood approximately orders magnitude comparable flood lower replication rates 
follows fact low replication rates find matching answer rwrt may visit nodes system just flood 
gia achieves extremely low hop counts higher replication cases high capacity nodes quite hold answers quickly discovered biased walks 
low replication queries may travel far high capacity nodes resulting higher hop counts 
flood super achieve consistently low hop counts number hops find matching answer hop count rwrt inversely proportional replication factor rwrt essentially amounts random probing 
performance flood degrades increasing system size 
flood query propagated node system 
increasing number nodes total number queries system greater query load arriving node 
causes collapse point fall system size increases 
observed similar effects super seen 
experiments clearly demonstrate gia scalability relative rwrt super flood 
experiments limited queries search terminates finding single matching answer 
reality users expect query return multiple answers 
look results generalize single case different design components contribute enormous performance boost gia 
multiple search responses section look collapse points associated hop counts change different system models desired number responses query 
recall section query includes max responses parameter indicates responses sent back originator query query 
max responses parameter useful context gia rwrt 
flood super queries get flooded network max responses effect behavior 
algorithm collapse point hop count gia gia gia bias gia gia algorithm collapse point hop count rwrt rwrt rwrt bias rwrt rwrt table factor analysis gia rwrt modes replication 
measure gia components removed rwrt components added hop replication biased random walks bias topology adaptation flow control repl 
max gia rwrt flood super factor resp 
cp cp hc cp cp hc cp cp table cp decreases increasing numbers requested answers max responses 
corresponding hop counts collapse case shown parentheses 
ambiguous flood super multiple responses ignore cp hc cases 
repl 
max gia rwrt flood super factor responses cp cp cp cp table search responses replication equivalent replication 
single answer table shows cp system models node system replication factor 
rwrt gia higher values max responses imply query needs search network longer ends 
results higher effective hop count query result causes query utilize available system capacity 
shown cp values table effectively reduces system capacity 
expected varying max responses effect super flood models 
seen earlier collapse point depends replication factor 
files replicated fewer nodes queries average visit nodes find 
result collapse point drops decreasing replication factors 
fact find performance query max responses replication factor equivalent query single response correspondingly lower replication factor depicted table 
system models searching answers replication factor yields cp identical obtained searching single answer replication factor 
likewise searching answers replication yields cp searching single answer replication 
result model rest gia rwrt simulations simplicity searches terminate finding answer queries 
change nature results simpler analyze system sufficient bring significant differences various designs 
factor analysis results section indicate gia outperforms rwrt super flood orders magnitude terms query load successfully sustain 
turn attention looking individual components gia topology adaptation flow control hop replication biased random walks influence performance gain 
researchers proposed schemes improving gnutella scalability gia components 
distinguishes gia schemes combination components comprehensive system design previous adapts component capacity sensitive 
section show single component fact combination provides gia large performance advantage 
show gia design components vital performance addition single gia component rwrt significantly close performance gap gia rwrt 
consider flood primary design leap flood gia transition floods random walks effect captured basic rwrt 
similarly super just step gia design includes amount hop replication ad hoc awareness node heterogeneity 
examine performance gia removing design components time compare behavior rwrt add design components time 
table shows result factor analysis nodes replication 
glance may conclude gia gets performance gain hop replication removing hop replication gia severely impacts performance 
adding hop replication rwrt improves cp single order magnitude gia offers cp orders magnitude greater rwrt 
combination topology adaptation biased random walks flow control addition hop replication gives gia enormous performance gain rwrt 
biasing random walk appears little consequence gia performance 
high query loads close cp flow control component serves divert load available capacity typically high capacity nodes functions akin biased walks 
lower query loads nodes lightly loaded biased walk helps direct queries rapidly high capacity nodes 
effect heterogeneity gia explicitly designed sensitive node capacities examine impact heterogeneity system performance 
table compares performance gia rwrt node capacities drawn gnutella capacity distribution case nodes identical capacities equal av algorithm collapse point hop count gia gnutella capacity distribution gia uniform capacity distribution rwrt gnutella capacity distribution rwrt uniform capacity distribution table impact heterogeneity nodes replication erage node capacity gnutella distribution 
cp gia improves nodes heterogeneous capacities 
contrast see rwrt tolerant heterogeneity cp drops orders magnitude relative uniform capacity case 
cp hc remains rwrt cases expect hop count gia drops biased random walks start directing queries high capacity nodes 
robustness results far shown gia performs significantly better previous unstructured file sharing systems 
section show gia sustain performance face node failures 
node failure model 
model node failures assigning node time picked uniformly random time simulation parameter 
node time expires node resets 
disconnects neighbors shuts immediately rejoins system connecting initially random number neighbors 
similar modeling existing nodes shutting leaving system new nodes simultaneously joining system 
node shuts queries queued locally dropped resumed nodes originally generated 
nodes join leave system topology adaptation overhead captured fact node adaptation operations consume capacity node 
figures plot cp cp hc respectively node gia system increasing 
see relative static case cp drops approximately order magnitude reduced time units hop count rises approximately factor 
note time units approximately nodes reset time unit 
extremely stressful test gia performance drops order magnitude 
improvement orders magnitude rwrt super flood static conditions 
file downloads results indicate gia support significantly higher query loads previously proposed approaches distributed file searching maintain performance advantage face high node churn 
gia dramatic performance improvement stems unique combination design components ability funnel high capacity nodes system 
results lead conclude search decentralized exact mechanisms implementing query restart real system discussed section 
compare typical gnutella node life times minutes 
collapse point replication rate replication rate replication rate failures seconds collapse point increasing node gia system hop count collapse point replication rate replication rate replication rate failures seconds hop count increasing node gia system systems need longer pose insurmountable scaling problems 
conjecture bottleneck limiting scalability file download process 
particularly true measurement studies indicate file sizes continue increase 
believe gia ability harness capacity manner sensitive constraints individual nodes beneficial impact downloads 
gia aids downloads extent users typically directed copy file exists 
advantage significant high capacity nodes store files 
gia able assist file downloads extend hop replication gia allow active replication files simply pointers files 
simple form active replication overloaded low capacity nodes replicate popular files higher capacity nodes hop neighborhood 
done demand fashion high capacity nodes replicate content receive query corresponding download request content 
gauge extent active replication useful simple calculation total capacity nodes file available active replication scheme 
resultant numbers listed table 
see active replication increases total capacity nodes serving file factor 
appears promising need significant analysis simulations validate usefulness approach 

implementation practical details implemented prototype gia client incorporates algorithms section 
client written replication gia gia active replication table total capacity nodes offering file active replication node gia network ci represent capacity node num min nbrs return total neighbors total total num nbrs total num max nbrs return algorithm satisfaction level computes satisfied node returns value 
node fully satisfied completely dissatisfied 
values represent extent satisfaction 
provides command line file sharing interface 
section discuss systems issues prototype implementation addresses 
capacity settings discussion far assumed node capacity quantity represents number queries node handle second 
low bandwidth clients query processing capacity limited client access bandwidth 
hand nodes high speed access connections issues speed cpu disk latencies may affect capacity 
prototype implementation ignores effects cpu speed disk latency query capacity 
assume capacity direct function access bandwidth 
node user configure access bandwidth user interface done gnutella clients automatically determine access bandwidth executing configuration script downloads large chunks data known sites internet measures bandwidth average time taken downloads 
addition advertised capacity nodes weighted long node system 
ensures connected high capacity core network composed stable nodes 
implementations plan experiment auto configuration scripts take account factors addition network bandwidth node life times order determine client capacity 
satisfaction level aggressiveness adaptation section introduced notion satisfaction level client 
satisfaction level determines perform topology adaptation frequently executed 
function pre configured min nbrs max nbrs parameters node current set neighbors capacities degrees 
neighbors exchange capacity information initially connect periodically update information current degree 
algorithm shows steps involved calculating satisfaction level 
essentially measure close sum capacities adaptation interval seconds satisfaction level adaptation interval plot function satisfaction level maximum interval adaptation iterations sensitivity satisfaction level 
set seconds plot curves adaptation interval versus satisfaction level different values node neighbors normalized degrees node capacity 
high capacity neighbor low degree contributes satisfaction level neighbor capacity higher degree 
intuition node capacity forward approximately queries unit time full load needs outgoing capacity neighbors handle load 
addition factors discussed number parameters may compute satisfaction level example load node neighbors network locality prototype rely node capacity degree compute satisfaction level 
satisfaction level key deciding node conduct local topology adaptation 
nodes low satisfaction levels perform topology adaptation frequently satisfied nodes 
exponential relationship satisfaction level adaptation interval maximum interval adaptation iterations represents aggressiveness adaptation 
interval node satisfaction level attempts add new neighbor 
node fully satisfied continues iterate adaptation process checking satisfaction level seconds 
shows aggressiveness factor affects adaptation interval 
expected node fully satisfied adaptation interval irrespective value level satisfaction decreases adaptation interval shorter 
satisfaction level higher values produce shorter intervals cause aggressive quicker response 
section look rate topology adaptation changes real system different values query resilience described earlier gia search protocol uses biased random walks forward queries network 
drawbacks random walk flooding susceptible failures network 
node receives query dies forward query neighbor query lost forever 
contrast flooding query gets replicated times node dies forwarding query chance copies query exist system 
overcome problem rely query keep alive messages 
query responses sent back originator query act implicit keep 
addition query forwarded times number neighbors time seconds progress topology adaptation node topology time 
graph shows changes number neighbors nodes different capacities 
sending response send back explicit keep alive message 
implemented dummy query response message actual matches 
query originator receive responses keep alive messages re issue query 
problem arises fact responses typically forwarded path query originally arrived 
nodes query path dies topology changes due adaptation responses query sent back responses dropped 
node dies causes responses dropped query originator notice absence keep alive responses 
reissue query necessary 
hand topology adaptation controlled process better wait timeout 
connection dropped result topology adaptation decision connection closed time 
stops accepting incoming queries continues forward query responses need sent path 
deployment deployed prototype implementation planetlab wide area service deployment testbed spread north america europe asia south pacific 
test behavior algorithms face diversity artificially introduced heterogeneity system explicitly setting capacities individual nodes 
experiments means meant stress various components gia system 
set early results demonstrate viability approach actual deployment 
instantiated gia clients planetlab nodes range capacities 
allowed system run minutes shutting clients 
course experiment tracked changes gia topology evaluate behavior topology adaptation process 
shows changes time neighborhood different nodes 
nodes picked randomly capacity classes 
notice initially nodes dissatisfied quickly gather new neighbors 
rate topology adaptation slows satisfaction level nodes rises topology eventually stabilizes steady state 
experiment capacity node takes approximately seconds reach steady state 
time interval closely tied level aggressiveness topology adaptation 
recall adaptation interval function node satisfaction level aggressiveness factor experiment set seconds number neighbors time seconds progress topology adaptation capacity node time 
graph shows changes number neighbors node different runs experiment different value adaptation interval function 

ran experiments see responsiveness topology adaptation changes different values shows behavior capacity node different values seen topology adaptation respond changes aggressive ramp value parameter gives knob trade speed nodes attain target topology rate churn network 

related look related research area 
rise fall napster decentralized systems proposed 
gnutella pioneered approach footsteps networks kazaa emerged 
notion supernodes nodes better bandwidth connectivity kazaa latest versions gnutella helps improve performance network limited flooding communication supernodes 
gia supernode approach just binary decision node capacity supernode knowledge mechanisms dynamically adapt supernode client topologies system evolves 
numerous researchers performed extensive measurement studies infrastructures 
example saroiu studied bandwidth latency availability file sharing patterns nodes gnutella napster 
study highlighted existence significant heterogeneity systems 
fact gia designed accommodate heterogeneity avoid overloading capable nodes network 
measurement studies include shows exists extreme heterogeneity traffic volumes generated hosts network small fraction hosts stable persist network long periods time 
addition described section proposals addressing scaling problems gnutella 
krishnamurthy proposed cluster architecture systems cap uses network aware clustering technique central clustering server group hosts clusters 
cluster delegate nodes act directory servers objects stored nodes cluster 
sense high capacity nodes gia provide functionality similar delegate nodes 
cap gia adapts topology cluster high capacity nodes fully decentralized manner explicitly takes node capacity account facets design 

proposed modifying gnutella algorithms include flow control dynamic topology adaptation hop replication careful attention node heterogeneity 
simulations suggest modifications provide orders magnitude improvement total capacity system retaining significant robustness failures 
increased capacity due single design innovation result synergy combination modifications 
making search scalable design potential improve system download capacity fully distributing load 
simple changes gnutella search operations result dramatic improvements scalability 
result interesting 
plausible alternative gia dht design 
argued section believe dhts efficient tasks suited mass market file sharing 
particular ability find needles exceedingly rare files needed file sharing environment ability efficiently implement keyword search crucial application unproven 
alternative readily dismissed research community centralized search original napster 
reflex response research community designs inherently unscalable examples google yahoo large sites tell scalability pose insurmountable hurdle 
reality real barriers napster designs technical legal financial 
demise napster due unauthorized exchanges copyrighted material 
adopting decentralized designs merely avoid acts hardly noble exercise 
financial standpoint scaling centralized search site technically feasible requires sizable capital investment infrastructure 
approach adopted underlying business model application 
contrast decentralized designs need large infrastructure expenditures 
view facilitating copyright avoidance enabling sharing files cases underlying business model 
web publishing allowing author access large audience regardless commercial viability hope support similar ability file sharing 

adamic lukose huberman search power law networks 
physical review 
adar huberman free riding gnutella 
monday internet journal oct 
available www firstmonday dk issues issue adar index html 
bhagwan savage voelker understanding availability 
proceedings nd international workshop peer peer systems iptps 
berkeley ca feb 
net news 
napster fastest growing net technologies oct 
news com com html 

gnutella web caching system 
www net 
gnutella development forum 
gnutella protocol 
groups yahoo com group files 
gnutella development forum 
gnutella ultrapeer proposal groups yahoo com group files proposals ultrapeer 
gnutella wego com 
gnutella distributed information sharing gnutella wego com 
goyal vin cheng start time fair queuing scheduling algorithm integrated services packet switching networks 
proceedings acm sigcomm stanford ca aug 
krishnamurthy wang xie early measurements cluster architecture systems 
proceedings acm sigcomm internet measurement workshop san francisco ca nov 
li loo hellerstein kaashoek karger morris feasibility peer peer web indexing search 
proceedings nd international workshop peer peer systems iptps 
berkeley ca feb 
lv cao cohen li shenker search replication unstructured peer peer networks proceedings th acm international conference supercomputing ics new york ny june :10.1.1.132.970
lv ratnasamy shenker heterogeneity gnutella scalable 
proceedings st international workshop peer peer systems iptps 
cambridge ma mar 
maymounkov mazieres kademlia peer peer information system xor metric 
proceedings st international workshop peer peer systems iptps 
cambridge ma mar 

overnet file sharing network 
www overnet com 
flow control algorithm distributed broadcast route networks reliable transport links jan 
www net gnutella htm 
peterson anderson culler roscoe blueprint introducing disruptive technology internet 
proceedings acm hotnets workshop princeton nj oct 
see www planet lab org 
ratnasamy francis handley karp shenker scalable content addressable network 
proceedings acm sigcomm san diego ca aug 
reynolds vahdat efficient peer peer keyword searching 
technical report duke university durham nc 
available athttp cs duke edu search 
ripeanu foster iamnitchi mapping gnutella network properties large scale peer peer systems implications system design 
ieee internet computing journal 
saroiu gummadi dunn gribble levy analysis internet content delivery systems 
proceedings fifth symposium operating systems design implementation osdi boston ma dec 
saroiu gummadi gribble measurement study peer peer file sharing systems 
proceedings multimedia computing networking mmcn san jose ca jan 
sen wang analyzing peer peer traffic large networks 
proceedings acm sigcomm internet measurement workshop marseille france nov 
sharman networks kazaa media desktop 
www kazaa com 
stoica morris karger kaashoek balakrishnan chord scalable peer peer lookup service internet applications 
proceedings acm sigcomm san diego ca aug 
tang xu mahalingam psearch information retrieval structured overlays 
proceedings acm hotnets workshop princeton nj oct 
zhao kubiatowicz joseph tapestry infrastructure fault tolerant wide area location routing 
tech 
rep university california berkeley 
