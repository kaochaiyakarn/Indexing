logic programming theory practice constraint handling rules thom fruhwirth constraint handling rules chr proposal allow flexibility application oriented customization constraint systems 
chr declarative language extension especially designed writing user defined constraints 
chr essentially committed choice language consisting multi headed guarded rules rewrite constraints simpler ones solved 
broad survey aim covering aspects chr currently 
going theory practice define syntax semantics chr introduce important decidable property confluence chr programs define tight integration chr constraint logic programming languages 
survey describes implementations language review constraint solvers traditional non standard ones written chr language 
introduce innovative applications benefited chr 

advent constraints logic programming lp rare cases theoretical practical commercial aspects programming language improved simultaneously 
constraint logic programming vh vh fr jama clp combines advantages logic programming constraint solving 
logic programming problems stated declarative way rules define relations predicates 
problems solved built logic programming engine chronological backtrack search explore choices 
constraint solving efficient special purpose algorithms employed solve subproblems involving distinguished relations referred constraints 
constraint solver seen inference system 
solver supports address correspondence ludwig maximilians universitat muenchen lmu institut fuer informatik munich germany informatik 
de www pst informatik uni muenchen de journal logic programming fl elsevier science avenue americas new york ny basic operations constraints solving satisfaction simplification propagation normalization entailment deciding implication optimization computing best solutions 
clp constraint solving hard wired built constraint solver written low level language 
efficient called blackbox approach hard modify solver build solver new domain debug reason analyze 
problem lesson learned practical applications constraints heterogeneous application specific 
demanded clp constraint solvers completely changeable users ai 
user mean application programmer 
proposals allow flexibility constraint systems glass box box approaches ffl demons forward rules conditionals chip di vh allow defining propagation constraints limited way section 
ffl constraint combinators cc fd vh allow building complex constraints simpler constraints see section 
ffl constraints connected boolean variable prolog nested constraints sid allow expressing logical formula primitive constraints 
ffl indexicals clp fd codi allow implementing constraints finite domains medium level abstraction 
ffl meta attributed variables hol allow attaching constraints variables section 
noted approaches extend solver specific constraint domain typically finite domains 
application specific domains implemented directly approach tedious kind constraint assembler programming currently low level basis delay mechanisms constraint solver extensions 
proposal high level language extension especially designed writing constraint solvers called constraint handling rules chr fru fru fam 
chr introduce user defined constraints host language prolog lisp 
language extension chr concerned constraints auxiliary computations performed directly host language 
chr typically library containing compiler run time system written host language solvers written chr 
chr essentially committed choice language consisting guarded rules rewrite constraints simpler ones solved 
chr define simplification propagation user defined constraints 
simplification replaces constraints simpler constraints preserving logical equivalence 
propagation adds new constraints logically redundant may cause simplification 
chr seen generalization various chip constructs user defined constraints 
contrast family general purpose concurrent logic programming languages sha concurrent constraint languages sar alps framework mah chr special purpose language concerned defining declarative constraints procedures generality 
sense chr general allow multiple heads conjunctions constraints head rule 
multiple heads feature essential solving conjunctions constraints 
single headed chr unsatisfiability constraints detected global constraint satisfaction achieved 
overview survey section introduce chr example 
talk related 
way theory practice give syntax semantics soundness completeness results chr 
introduce important property constraint solvers confluence decidable necessary sufficient test 
discuss specifics extending clp language chr automatic labeling 
describe principles characteristics existing implementations chr prolog lisp 
chr encode wide range constraint solvers including new domains terminological temporal reasoning 
give overview solvers show extended modified briefly describe related builds solvers 
mention applications non standard domains optimizes placement radio cells transmitters gives rent advice internet 

chr example define user defined constraint equal handle variable arguments 
implementation rely syntactical equality assumed predefined built constraint 
reflexivity 
true 
antisymmetry 
transitivity 
chr specify 
simplifies propagates constraint 
implement reflexivity antisymmetry transitivity straightforward way 
chr reflexivity states logically true provided case test forms optional guard rule precondition applicability rule 
see constraint simplify true 
chr antisymmetry means find current constraint replace logically equivalent note different rules reflexivity rule equality precondition test rule antisymmetry rule enforced rule fires 
rules reflexivity antisymmetry simplification chr 
rule transitivity propagates constraints 
states conjunction implies operationally add logical consequences redundant constraint 
kind chr called propagation chr 
redundancy propagation chr useful query shows constraints cause chr transitivity fire add query 
new constraint matches head chr antisymmetry constraints replaced general matching takes account syntactical equalities implied built constraints 
built constraint added chr antisymmetry applies constraints resulting query contains inequalities simplification stops 
constraint solver built solved produced answer propagates transitivity 
simplifies antisymmetry 
simplifies antisymmetry note multiple heads rules essential solving constraints 
note solver implements partial order constraint constraint domain generality possible chr 
solver require conjunctions constraints idempotent multiple occurrences constraint absorbed 
ensures termination solver finite number variables finite number different 
constraints 
solver confluent means query answer regardless order apply rules 
query started applying transitivity 
related 
languages defining constraints cs prolog kom presumably proposal implement constraint solvers lp language utilizing delay mechanism 
conditional rewrite rules describe behavior solver 
years early able refine idea implement efficiently 
chip clp language introduce feasible constructs demons forward rules conditionals di vh user defined constraints 
various constructs generalized uniform chr 
demons essentially single headed simplification chr guards 
version chip included forward rules gr correspond chr guards 
practice demons forward rules proven useful chip applications boolean domain circuit design verification 
potential define constraint solvers general realized limitations 
guarded rules smo correspond single headed simplification chr 
shortcuts lemmata predicates definitions user written constraints 
interestingly smolka defines built con straint system terminating determinate reduction system 
implemented simplification chr 
mentioned approaches user defined constraints lp 
languages outside lp paradigm aim defining constraint systems 
functional language lel uses augmented term rewriting standard term rewriting extended equality theory local variables objects types 
confluence preserved 
extension allow multiple solutions discussed allow retaining expressive power lp 
extensions bertrand mimic lp equality theory unification herbrand terms local variables 
object oriented language extension equate wil simplifies arithmetic constraints sequence procedural solution steps 
equate uses rewrite rules seen lp rules 
procedural solutions destructive assignment ordering imposed solutions steps avoid read write conflicts 
approach capabilities deal added removed constraints 

multiple head atoms coh development prolog early colmerauer kowalski experiments performed clauses having multiple head atoms 
committed choice languages multiple head atoms considered rarely 
thesis saraswat remarks multiple head atoms notion powerful extensive investigations warranted sar 
motivates joint reductions multiple atoms analogous production rules expert system languages ops 
examples suggest joint reductions model objects spirit similar worked 
clauses multiple head atoms proposed literature model parallelism distributed processing objects 
similarity chr merely syntactical 
rules distribution objects agents involve nonmonotonicity state changes caused actions method calls opposed declarative constraint solving 
chr ab model objects agents stack object equipped method push push stack 
stack multi headed simplification chr sufficient simulate parallel machine multiset transformation proposed bcl 
chemical machine chemical reaction metaphor means describe highly parallel computations 
bcl implement sieve eratosthenes compute primes simply primes 
true 
primes 
prime primes generate candidates prime prime 
mod prime 
multiple answer query primes conjunction prime prime 
compare standard concurrent program sha appreciate expressive power multiple heads 
times long 
programs computing primes contained solver primes chr chr library 

syntax semantics section give overview syntax semantics soundness completeness results constraint handling rules 
detailed presentations fam abd abd 
assume familiarity concurrent constraint logic programming vh fr sar jama 
special purpose language chr extend host language constraint solving capabilities 
auxiliary computations chr programs directly executed host language statements 
keep section essential selfcontained address host language issues 
constraint considered distinguished special order predicate atomic formula 
disjoint sorts predicate symbols different classes constraints sort built predefined constraints sort chr user defined constraints 
built constraints handled predefined constraint solver exists host language 
chr constraints defined chr program 
host language statements appear chr declarative consider built constraints section incomplete solver host language 

syntax definition 
chr program finite set chr 
kinds chr 
simplification chr form 
propagation chr form 
chr form 
multi head nonempty sequence chr constraints guard sequence built constraints body sequence built chr constraints 
empty sequences represented built constraint true 
simplicity empty guard true removed rule commit operator propagation rule likewise thought abbreviation simplification rule 
need discuss section describe implementations applications chr 

declarative semantics general committed choice programs chr programs declarative semantics concerned defining constraints procedures generality 
declarative interpretation chr program conjunction universally quantified logical formulas rule consistent built constraint theory ct determines meaning built constraints appearing program 
theory ct expected include equality constraint basic constraints true false 
denote sequence global variables occurring head atoms chr 
local variables occurring guard body rule occur heads 
simplicity assume local variables occur guard body rule definition 
declaratively simplification chr logical equivalence guard satisfied 
propagation chr implication guard satisfied 
example 
chr reflexivity 
true introductory example section logical reading 

true 

operational semantics operational semantics chr programs transition system 
definition 
state annotated tuple hf div conjunction chr built constraints called goal store conjunction chr constraints conjunction built constraints called constraint stores annotation sequence variables 
empty conjunctions represented built constraint true 
attribute state hf div formula 
fru 
logical meaning variables occurring state ones appearing remain free formula 
clear context confuse state logical reading 
drop annotation state interest 
transitions computation steps transitions reductions proceed state 
intuitively state hf div constraints remain solved constraints accumulated simplified far 
aim computation incrementally reduce arbitrary states states contain goals 
transition solving built constraints transition introduces chr constraints store transitions applying kind chr 
transitions leave annotation unchanged 
definition 
chr program chr constraints ct constraint theory built constraints 
transition relation gamma 
chr follows 
variables occurring states stand conjunctions constraints 
denotes program variables occurring multi head solve hc div gamma 
hf built constraint ct introduce hh div gamma 
hf div chr constraint simplify hf div gamma 
hb div 
ct propagate hf div gamma 
hb div 
ct equating constraints mean hn mean hn note conjuncts permuted conjunction assumed associative commutative 
solve transition built solver updates constraint store new constraint goal store 
update constraint store means deterministically produce new constraint store constraint theory ct logically equivalent conjunction new constraint old constraint store 
introduce transition transports chr constraint goal store chr constraint store 
handled chr constraints applying rules 
chr applicable chr constraints constraints match head atoms rule account syntactical equalities implied built constraint store guard implied entailed store simplification rule 
appearing chr program applicable chr constraint simplify transition removes chr constraints store adds goal store adds equation expressing match head atoms built constraint store 
propagation rule 
applicable transition adds goal store adds equation built constraint store 
require rules applied fairly rule applicable applied eventually 
fairness respected trivial non termination avoided applying propagation rule constraints 
complex operational semantics addresses issues abd abd 
initial final states definition 
initial state consists goal empty constraint stores hf true sequence variables occurring final state form hf state called failed form htrue div fair computation step possible anymore false state called successful 
called query 
final state called conditional qualified answer query annotation allows distinguishing query variables variables introduced computation 
example 
computation goal bc ab introductory example section proceeds follows effect existential quantification head equalities 
usual variables renamed apart 
ha true truei 
introduce htrue truei propagate transitivity hc truei 
introduce htrue truei simplify antisymmetry hb truei solve htrue ci simplify antisymmetry ha true ci solve htrue true ci 
soundness completeness relate operational declarative semantics chr 
results mah vh proofs fam abd 
definition 
computation goal sequence states 
initial state hg true final state diverging 
finite computation successful final state successful 
failed 
definition 

holds iff 


sn 
results fact transitions chr preserve logical meaning states 
states computation logically equivalent 
lemma 
chr program goal 
logical reading state appearing computation ct denotes universal closure formula proof 
structural induction computation steps 
soundness completeness results chr need distinguish successful failed computations 
theorem soundness 
chr program goal 
computation answer ct proof 
immediately lemma 
theorem completeness 
chr program goal finite computation conjunction constraints 
ct computation answer ct proof 
immediately theorem 
theorem stronger completeness result clp languages mah way reduce disjunction strong com theorem single disjunct due lemma 
example shows completeness theorem hold finite computations 
example 
chr program 
holds ct fp pg 
infinite computations 
soundness result theorem specialized failed computations 
corollary 
chr program goal 
finitely failed computation ct 
proof 
theorem 
analogous completeness result converse corollary hold general example 
chr program 

false 
ct finitely failed computation 
completeness theorem weak failed computations 
stronger completeness result correct programs data sufficient goals data sufficiency introduced completeness deterministic alps programs mah see section 
definition 
chr program correct iff ct consistent 
definition 
goal data sufficient computation final state form htrue true div theorem stronger completeness failed computations 
correct chr program data sufficient goal 
ct finitely failed computation 
proof 
theorem definition correctness fact final state contains built constraints data sufficient 
see confluence property introduced improve soundness completeness results 

confluence shown previous section lemma chr program result computation goal meaning 
data sufficiency missing theorem fam stated wrongly 
guaranteed result syntactically 
confluence property program guarantees computation starting arbitrary initial state possible order rule applications results final state 
guarantee solver satisfaction complete detect inconsistencies 
due space limitations just give overview confluence definitions just informal 
detailed confluence results simplification rules published fam 
results simplified extended kinds chr abd abd 
papers adopt extend terminology techniques conditional term rewriting systems dos confluence 
extensions enable handling global knowledge built constraint store local variables propagation rules 
abd possible adapt chr idea knuth bendix completion algorithm set rules confluent introducing additional rules 
require states normalized compared syntactically meaningful way 
formal definition normalization function quite involved describe normalized states just informally 
basically require built constraints unique normal form equalities explicit propagated components state 
normalization identical failed states 
furthermore require refined operational semantics 
augment states second annotation 
new annotation multiset tokens representing potential applications propagation rules constraints 
propagation rule applied corresponding token removed rule reapplied constraints 
simplification rule applied appropriate tokens removed constraints occur removed 
rest section assume states normalized annotated 
definition 
states variants obtained variable renaming 
states called joinable exist states 

variant definition 
chr program called confluent states 

joinable 
chr program called locally confluent states 

joinable 
example 
chr program example confluent simplified false 
corresponding states final differ 
program confluent 

false 

false 
give new motivation critical pairs notion nontrivial direct common ancestor states 
analyze local confluence chr program check joinability pairs states derive common ancestor state general infinitely states 
construct finite number minimal states rule applicable direct common ancestor state consists heads guards rules 
suffices construct states rules 
obvious finite number states program 
due monotonicity property chr states extended context possible ancestor states 
monotonicity states adding constraints components state inhibit application rule long built constraint store remains consistent 
restrict nontrivial direct common ancestor states joinability destroyed rule inhibits application rule 
application rule may remove chr constraints user defined store introduce new constraints 
removal constraints effect applicability rule case removed constraint needed rule 
possibly inhibit rule simplification chr rules overlap head atom common ancestor state 
achieved equating head atoms state removing resulting identical copies head atoms 
definition 
simplification rule arbitrary necessarily different rule chr program variables renamed apart 
denote guard denote body rule 
partition head rule conjunctions conjunction common head atoms nonempty 
nontrivial direct common ancestor state htrue provided consistent 
sequence variables appearing simplification rule empty set propagation rule ig 
choice motivated minimality criterion state covers case propagation rules possibly applied constraints user defined store ancestor state reached 
application respectively leads states form called critical pair 
states critical pair body rule goal store removed chr constraint store case simplification rule empty built constraint store annotation remain 
definition 
nontrivial direct common ancestor state 
tuple critical pair critical pair joinable joinable 
due condensed presentation definition differs abd 
difference syntactical way critical pair represented 
example 
consider example section 
nontrivial ancestor state comes equating head atom antisymmetry rule head atom transitivity rule htrue truei sequence variables contains just token transitivity critical pair hx truei hx truei 
critical pair joinable computations states empty multisets tokens result final state htrue yi able give main theorem connecting joinability critical pairs local confluence theorem 
chr program locally confluent iff critical pairs joinable 
proof 
direction assume state possibilities computation steps 
investigate pairs possible computation steps show joinable 
direction contradiction 
assume locally confluent chr program critical pair joinable 
corollary gives decidable sufficient necessary test confluence terminating program definition 
chr program called terminating infinite computations 
corollary 
terminating chr program confluent iff critical pairs joinable 
proof 
immediately theorem newman lemma new 
notion confluence subsumes notion determinacy maher mah saraswat sar concurrent constraint logic programs 
determinate program guards rules predicate mutually exclusive 
trivially confluent critical pairs exist 

soundness completeness revisited showed fam abd confluence implies correctness see definition 
theorem 
confluent ct consistent 
theorem shows improve soundness completeness chr program confluent terminating 
theorem strong soundness completeness 
terminating confluent chr program goal 
equivalent ct 
computation answer ct 
computation answer ct 
proof 
theorem 
confluence termination 
theorem 
corollary soundness completeness result finitely failed computations 
corollary 
soundness completeness finite failure terminating confluent chr program data sufficient goal 
equivalent ct finitely failed computation 
computation finitely failed 
proof 
theorems 
maher proved similar soundness completeness results deterministic alps programs data sufficient goals 
results hold substantially larger class programs confluent terminating chr programs 
note alps general different semantics clark completion different operational semantics rules commit chr 

clp chr assume constraint handling rules extend clp language extend definitions previous sections accordingly 
clp tight integration possible allow clauses chr constraints 
labeling introducing choices 
idea simplification propagation possible anymore constraint automatically chosen labeling 
conversely regard predicate labeling routine constraint add chr 
seen way chr lemmata allow expressing determinate information contained predicate 
predicates constraints just alternate views don know don care nondeterminism combined declarative way 
idea guarded rules smo mentioned section 
see power lemmata consider rule append 
recursion list usual definition append replaced simple unification example 
continue example section 
illustrate automatic labeling chr constraint successor notation numbers 
label ground 
label ground 
labeling declarations starting label state may label ground variable free terms 

propagates 
labeling succeeds 
labeling succeeds 
labeling succeeds 

backtracking succeeds 

backtracking fails 
definition 
clp chr program finite set clp clauses predicates chr constraints chr rules chr constraints 
usual clp clause form head atom built constraint body conjunction atoms 
labeling declaration chr constraint hl form label hl definition 
bn ns clauses predicate head variables different clauses renamed apart 
logical reading predicate clark completion defined bn ns form new pairwise different variables 
labeling declaration serves precondition logical meaning clauses chr constraint hl 

clark completion 
definition 
computation steps involving clauses unfold hh di gamma 
hb di chr constraint label hf di gamma 
hb di label denotes program variables occurring unfold atomic goal means look clp clause gamma replace unfolding nondeterministic goal solved different ways different clauses 
clauses chr constraints unfolded label transition provided label declaration satisfied 

implementations implementation chr summer interpreter written ecl ps prolog called fru fru fru 
chr language implemented common lisp german research institute artificial intelligence dfki library ecl ps 
currently implemented sicstus prolog lmu munich ecl ps ic parc imperial college concurrent logical object oriented constraint language oz 
fru fru fru small fully functional interpreter 
small mean clauses lines kb code 
fully functional mean included preprocessor chr delaying conjunction incremental constraints residuation tracing tool chr constraints variable bindings simple partial evaluator simplifications simple statistics number rules fired kind timings 
solvers term equality unification finite domains term manipulation maximum types temporal reasoning 
lisp implementation provide rules offers interesting extensions 
rules priorities encoded integers 
second nondeterminism introduced disjunction rule bodies 
extension allows expressing prolog clauses 
rules disjunction usually get lowest priority 
algorithm executing chr somewhat similar implementation chr prolog 
matching head constraint rule heads dynamically adds new rule matched head removed variables instantiated matching 
constraint solvers terminological reasoning negation concrete domains equality herbrand terms inequalities finite domains linear polynomial inequalities algorithm implementation terminological language described applications 
chr library version ecl ps includes compiler run time system debugger solvers see section examples full color demo geometric constraints real life application wireless telecommunication see section 
extension definitions earlier chr rules deep guards local variables shared guard body rule 
prolog chr statements freely combined 
library complete committed choice language available side effect 
compiler utilizes delay mechanism built predicates ecl ps create inspect manipulate constraints delayed goals ch constraint handling ee extension ecl ps rules 
guards allow user defined predicates addition built constraints 
attributed variables 
compiler clauses lines kb code run time system clauses lines kb code including comments 
compilers ecl ps sicstus prolog idea types chr transformed multi headed single headed simplification rules guarded rules typical concurrent language sha sar provided language access delayed goals deep guards 
chr constraint goals modeled goals delay 
guarded rules translated clauses clp language delay mechanism coroutining attributed variables 
detailed description compilation scheme actual implementation 
performance range solvers examples run time penalty declarative high level approach turned constant factor comparison dedicated built solvers available 
slow order magnitude 
examples involving finite domains element constraint linear polynomial equations rationals see section applications approach faster exactly define tune amount constraint simplification propagation needed 
performance simplicity solver kept incomplete application allows 
defined low level support manipulating delayed goals adding searching activating removing delayed goals provided attributed variables reason performance number significant optimizations result experiments performed interpreter 
example observation usually head atoms rule connected common variables constraint usually search constraints delay common variable 
constraint domains number constraints normal form linear number variables find constraints constant time 
order rules tried matters 
ecl ps chr compiler prefers simplification propagation rules single headed multi headed rules 
propagation constraint may cause propagations redundant constraints 
compiler adds constraints propagated constraint considering new ones turn 
rules preferred remove constraint choice 
new sicstus implementation chr user control order rules 
user declarations rule annotations enforce idempotence constraints 
optimization related idempotence remove constraint generated body rule wants remove 
may speed computation improve complexity resulting algorithm avoid non termination 

constraint solvers section introduce constraint solvers part chr library ecl ps see solvers finite domains arbitrary ground terms including reals pairs incremental path consistency temporal reasoning solving linear polynomials reals rationals terminological reasoning 
solvers described time 
solver may slightly edited mainly self contained consistent presentation readable 
know mention related solvers researchers related solvers written researchers chr 
space limitations introduce constraint domain give idea implements chr 
usual formalism describe constraint system inference rules rewrite rules sequents formulas expressing axioms theorems written chr straightforward way 
starting executable specification rules refined adapted specifics application 
note solver written chr determinate incremental concurrent nature 
determinate mean user defined solver commits constraint simplification 
incremental mean constraints added constraint store time affecting computational cost 
rules applied concurrently different constraints logically correct chr replace constraints equivalent ones add redundant constraints 
note solvers rely order variables terms built predicate 

booleans domain boolean constraints includes constants falsity truth usual logical connectives propositional logic neg imp exor modeled relations 
assume equality built constraint 
program bool chr simple solver mainly value propagation single headed simplification rules automatic labeling 
sophisticated algorithms see 
define gate constraint handling rules assuming variables take boolean values 








example rule says constraint known input argument reduced asserting output file names refer 
library file constraint domain 
arc chr arc consistency bool chr booleans cft chr feature trees control chr sound control primitives domain chr finite domains geons chr geometric objects kl chr terminological reasoning leq chr partially ordered variables list chr lists lengths math gauss chr linear polynomial equations math elim chr inequations slacks math chr algorithm math fourier chr algorithm math eager chr inequations slacks math ineq chr inequations slacks math lazy chr inequations slacks minmax chr minima maxima osf chr order sorted feature trees path chr path consistency primes chr prime numbers set chr finite sets term chr prolog term constructors time pc chr temporal reasoning time point chr time points tree chr rational trees negation 
constraint solvers chr library ecl ps 
stands number simplification 
propagation rules number chr constraints nonempty guards rules 

query result 
obvious rules terminate chr constraints reduced built constraint 
confluent 
critical pairs easy construct heads identical 
example rules 

lead critical pair htrue htrue 
states simplify 
example 
consider predicate add taken known full adder circuit 
adds single digit binary numbers produce single number consisting digits add xor xor 
query add reduce 
computation proceeds follows output gate input 
input gate 
output gate inputs 
output xor gate output second xor gate 
query add reduces 
example illustrates power simple incomplete solver 
flexibility extensions cardinality constraint combinator introduced clp language cc fd vh hsd finite domains 
adapt boolean variables 
boolean cardinality constraint bl holds boolean variables list bl length equal 
solver assume constraint bl condition initially holds length finite closed list bl 
assume arithmetic constraints tests integers involving 
subtraction built 
delete usual prolog predicate removing element list 
trivial positive negative satisfaction bl 
true 
bl 
bl 
bl 
bl 
positive negative reduction bl 
delete bl bl bl 
bl 
delete bl bl bl 
labeling choice positive negative reduction bl true 
bl bl 
bl bl 
delete guard succeed element removed occurs list 
delete bl bl delay tries bind variable bl 
succeed list 
fail elements list zeros 
predicate true resp 
false binds elements list bl resp 

note call bodies labeling clauses call cardinality constraint 
cardinality constraint simplified built constraint reduced cardinality shorter list implementation terminates 
list initial cardinality constraint open ended length fixed contexts cardinality constraint terminate 
show solver maintains condition invariant 
invariant implementation confluent 
related solvers dum experiments performed applying resolution backtracking solving boolean constraint satisfaction problems 
limited version resolution called ordered resolution introduced compared davis putnam method 
dp procedure extensively satisfiability problems sound procedure basically restricts resolution unit clauses 
labeling phase added tries truth values backtracking variables retaining completeness 
ordered resolution sound complete restriction resolution literals clauses globally ordered resolution performed leftmost literals clause 
method improvement dp length clauses generated limited small number labeling preserving completeness 
incremental version dp procedure versions resolution dum 
boolean csps modeled conjunctions clauses clause disjunction literals positive negative atomic propositions 
clause represented list signed boolean variables 
example represented cl 
variables lists ordered 
member usual prolog predicate lists 
cl 
fail 
tautology cl 
member member true 
cl 

cl 

cl 
delete cl 
cl 
delete cl 
cl 
member true 
cl 
member true 
labeling necessary list elements cl true 
applied unit rules cl cl 
cl cl 
note similarity cardinality constraint 
argument termination 
confluence proven 

terminological reasoning terminological formalisms represent terminological knowledge particular problem domain logical level 
describe kind knowledge starts atomic concepts roles defines new concepts relationship terms existing concepts roles 
established notation terminologies verbose syntax help readers familiar topic 
concepts considered unary relations intensionally define sets objects similar types 
roles correspond binary relations objects necessarily kind properties color roles 
pure literal deletion implemented global condition sound anymore constraints added incrementally case chr 
definition 
concept terms defined inductively concept name concept term 
concept terms role name expressions concept terms conjunction disjunction nota complement value restriction exists restriction 
objects constants variables 
objects role concept term 
membership assertion role filler assertion 
box collection membership role filler assertions 
definition 
terminology box consists finite set concept definitions isa newly introduced concept name concept term 
concept new defined terms concept definitions acyclic 
implies concepts definition called primitive 
represent box clp predicates box chr constraints want solve problems terminology 
example 
domain configuration application comprises devices interfaces configurations 
concept definitions express concepts disjoint interface isa nota device 
configuration isa nota interface device 
assume simple device interface 
introduce role connector relates devices interfaces employ exists restriction 
simple device isa device connector interface 
introduce instances devices interfaces constraints pc device rs interface pc rs connector solver terminological formalisms straightforward embedding order logic 
limited expressiveness terminological formalisms allows decision procedures number interesting reasoning problems 
problems include consistency assertions classification concepts 
key idea bds constructing inference algorithms reduce reasoning services consistency checking 
unfolding completion rules propagation rules bds consistency test translate directly chr library solver file kl chr 
provide incremental algorithm simplify constraints 
roughly consistency test boxes simplifies propagates assertions box knowledge explicit looks obvious contradictions clashes device nota device 
need single clash rule may need extensions formalism 
nota 
false simplification chr show complement operator nota pushed leaves concept term nota 
nota nota nota 
nota exists restriction generates variable serves witness restriction 
value restriction propagated role fillers 
unfolding rules replaces concept names definitions 
isa nota 
isa nota conjunction rule generates new smaller assertions 
disjunction treated lazily clp clause automatic labeling 
exponential complexity consistency test terminologies surfaces 
label true 

rules simplify terminological constraints normal form reached 
normal form constraints nota primitive concept name 
show termination show rule membership assertions body strictly smaller head 
prove mapping concept terms numbers called ranks follows rank nota rank rank rank isa exists rank tn rank rank tn note definition concept terms ground variable free finite concept definitions acyclic finite 
solver detects inconsistencies clash rule independently order constraints added chr applied confluent 
chr clash rule pairwise disjoint heads run time critical pairs exist clash rule 
example inconsistent constraints nota simplified pushing nota constraint nota gamma 
rule nota gamma 
rule nota clash rule applied nota flexibility extensions attributes called features functional roles interpretation partial function 
assuming declaration attribute unary predicate attribute just extend implementation 
attribute 
example 
ready define simple configuration consists distinguished simple devices attribute component 
attribute component 
simple config isa configuration component simple device component simple device 
constraints config simple config config dev component config dev component solver derive dev dev simple devices 
reason attribute rule constrains witness component simple device second argument role config dev component equal analogously dev 
illustrate extensions basic terminological formalism proposed literature carry implementation chr painless manner 
extension allows parameterizing terminologies concrete domains linear constraints rational numbers 
related solvers related solvers implemented various forms feature trees order sorted feature trees osf apg osf chr including arity constraint cft chr rational trees tree chr including disequality 
prototype implementation interactive graphical tool supporting configuration process technical systems process control systems developed wolf gmd berlin 
includes knowledge base represented executable specification language called 
generalization terminological reasoning language implementation described 
version september 
looked theorem proving constraints terminological reasoning domain constraints considered 
clp proof procedures horn clauses enhanced efficient constraint solvers 
question arises possible incorporate constraint processing general non horn theorem proving calculi 
positive answer 
new calculus introduced combines model elimination constraint solving 
prototype system implemented rapidly combining prolog technology implementation model elimination constraint solvers 
example studies terminological reasoning show advantages problems procedure 
extension terminological solver authors able solve lion unicorn puzzle sun authors consider quite fast 

path consistency section introduce constraint solver implements classical artificial intelligence algorithm path consistency backtracking solve constraint satisfaction problems 
definition 
binary constraint network consists set variables set binary constraints 
network represented directed constraint graph nodes denote variables arcs labeled binary constraints 
definition 
disjunctive binary constraint xy variables written finite disjunction relation applicable called primitive constraints 
converse primitive constraint primitive constraint holds consequence 
usually number primitive constraints finite pairwise disjoint 
simplicity unary domain constraints modeled binary constraints variable fixed 
example 
disjunctive binary constraints ab impose restrictions constraint redundant 
definition 
solution constraint network assignment values variables satisfies constraints 
assignment called valid 
constraint network consistent exists solution 
constraint network minimal primitive constraint satisfied solution network primitive constraints participate solution 
definition 
network path consistent pairs nodes paths gamma gamma gamma direct constraint ij tighter indirect constraint path composition constraints ii omega omega path 
disjunctive constraint tighter disjuncts 
path consistency approximate minimal network 
follows definition path consistency intersect direct indirect constraint arrive tighter direct constraint 
intersection denoted operator phi 
graph complete edge pair arcs direction pair nodes 
graph underlying network complete suffices repeatedly consider paths length triple nodes repeatedly compute ij ij phi ik omega kj fixpoint reached 
complexity algorithm number nodes network 
example kk ji triple ik omega kj results result intersecting ij get compute ji converse ij 
get round computation causes change fixpoint reached minimal 
compare result solver section 
solver constraint ij represented predicate disjunction primitive constraints forming disjunctive constraint 
basic operation path consistency ij ij phi ik omega kj implemented rule performing composition rule performing intersection 

composition 

intersection 
see splitting operations rules offers high degree flexibility 
rules suffice implement incremental concurrent path consistency algorithm complete networks 
rules confluent properly defined logically correct composition intersection operations 
problem finite number variables possible disjunctive binary constraints solver generic terminate operational semantics 
propagation rule generate constraint intermediate constraints absorbed early simplification rule trace shows new constraints added right propagate propagate simplify propagate simplify state chr implementations solver terminate rules applied fairly idempotence enforced new absorbed state 
fairness means simplification intersection applied constraints variable pair propagation caused 
solver derived generic path consistency solver terminate 
generic path consistency solvers path chr time pc chr 
solver takes optimizations algorithm pc mac account addition incremental works incomplete networks removes redundant constraints implements equality built constraint 
optimizations discussed detail fru 
solver maintains invariant holds constraint pc converses constraint longer explicit 
special cases 
ground ground choose check 

empty false 

redundant true 

equality 
choose equality 
intersection 
intersection 
composition 
composition 

composition 

composition 
labeling label singleton 
choose 
special cases simplification chr 
checks satisfiability constraint trying primitive constraints disjunction assignment variables valid 
detects inconsistent constraints having empty disjunctions replaces equality constraint built constraint replaces constraint nodes test equality disjunction definitions auxiliary predicates check empty singleton redundant equality choose intersection composition comes instance path consistency solver see section 
simplification chr performs intersection propagation chr composition 
absence explicit converses composition chr cover possible orientations constraints keeping nodes ordered 
primitive relations properly contain equality rule weakened propagation rule 
computation converse implicit composition predicate necessary computing backwards 
labeling implements backtrack search complete path consistency algorithm 
disjunctive constraint singleton nondeterministically chooses primitive constraint enforces flexibility extensions solver path consistency specialized arc consistency restricting exactly binary constraints involved propagation chr unary 
achieved fixing variable point smaller variable zero 
unary constraint common notation dom usually called domain special cases dom 
ground choose check dom 
dom 
empty false 
dom 
redundant true 
intersection dom dom 
intersection dom 
composition dom 
composition dom 
dom 
composition dom 
labeling 
related solver arc consistency arc chr 
specialization solver finite domains section 
instance path consistency temporal reasoning introduced section 
modifications discussed fru 
related solvers application path consistency backtracking algorithm chr qualitative spatial reasoning described 
framework freksa zimmermann implemented extended treatment dimensional objects non zero dimensions 
framework space qualitatively divided regions defined means system 
primitive relations basically denote relative directions left front 
important aspect clp extended chr provides level abstraction suited integrating different aspects space 
results research applied toy examples robot path planning 
current authors extends solver framework handle distances objects 

temporal reasoning framework meiri mei temporal reasoning viewed constraint satisfaction problem location temporal variables time line path consistency backtrack search 
framework integrates forms temporal relations qualitative quantitative metric time points intervals considering disjunctive binary constraints 
quickly introduce temporal constraints available 
qualitative point constraints 
variables represent time points primitive constraints 
composition constraint equality yields constraint composition yields redundant constraint 
quantitative point constraints dmp 
primitive constraints restrict distance time points interval gammax signed numbers 
note infinite number primitive quantitative constraints overlap 
composition intervals results intersection max min 
interval constraints 
primitive constraints possible intervals equality relations converses 
constraints defined terms points intervals 

notationally abbreviate chains equalities variables 
equals overlaps meets starts finishes converses contains overlapped started finished 
point interval constraints mei 
possible primitive constraints point interval 
point interval 
converses express interval point constraints 
relating constraints different types 
qualitative time point constraints mapped quantitative point constraints quantitative constraints approximated qualitative constraints 
points represented points intervals interval constraints approximated constraints endpoints 
mappings solve heterogeneous constraints variables 
solver instantiate generic path consistency solver previous section defining intersection composition operations 
implementation described detail variations fru solver time chr time pc chr 
disjunctive constraints represented list primitive constraints 
intersection simply defined list intersection composition defined terms simplicity presentation distinguish open closed intervals 
pairwise combining primitive relations 
check validity performed definition primitive temporal constraints clp clauses 
infinite number primitive quantitative constraints overlap constraints need special treatment intersection composition deal overlapping intervals 
labeling go single intervals performing binary search single interval split half long size certain threshold eps 
eps lower bound size smallest nonempty interval possible constraint problem hand 
lower bound exists termination affected fru 
example 
constraints intervals contains tightened path consistency starts constraints points intervals contains turn inconsistent 
flexibility extensions specialize temporal solver quantitative time point constraints single intervals considered dmp 
notation meaning distance solver time point chr derivation extending solver inequality section described fru 
special cases 
ground ground 
false 

true 


intersection 
max min 
composition 





labeling performed interval splitting binary search 
related solvers logics modeling dynamical systems san 
syntactically scenario description description dynamical system consists parts observations formulas hold specific time points action laws formulas defines possible change values symbols schedule statements statements describes occurrences temporal relations actions 
additionally axioms specify proposition possibly change implement inertia 
basic idea implementation bja see formulas constraints encode action laws rules 
ideas borrowed chr implementation meiri framework disjunctions handled labeling mechanism 
cases various classical turkey shooting problems investigated 
european community funded esprit project environment qualitative temporal reasoning equator concerned modeling process systems industrial applications aircraft scheduling urban traffic control 
extension event calculus sako called grf including time granularity different time scales continuous processes implemented versions chr don 
version constraint ways extension chr solver inequalities finite domains interval part modeling temporal order 
simplified version solver linear equations conversion different time scales 
modeled negation chr constraint avoid floundering achieve maximum propagation 
predicates event calculus called time parameter unknown 

finite domains finite domains appeared chip vh advanced clp languages clp fd codi cc fd hsd 
integers domain arithmetic possible 
theory underlying constraint domain arithmetic 
linear fragment integer arithmetic decidable 
constraint dom means value variable finite domain dom 
precisely dom ffl enumeration domain list ground term list list ffl interval domain min max ground term min max 
difference interval domain enumeration domain constraint simplification performed interval bounds constraint simplification performed element enumeration 
enumeration domains allow constraint simplification hand tractable sufficiently small enumerations 
derive solver domain chr instance arc consistency solver section time point solver section 
gives chr need restricting representation integers 
partial solver interval domains specialize write specialization treatment equality changes add composition binary constraints arc consistency solver special cases 
ground 
false 

true 

intersection 
max min 
composition 
composition 

composition 
possible instance constraint 


gamma argument known rules strengthened simplification rules projection argument 
ground 

ground gamma example get applying rules composition intersection yielding simplifying equality projecting inequality intersecting simplifying 
enumeration domains specialize arc consistency solver special cases 
ground member 

false 

intersection 
intersect list labeling label true 
member 
flexibility extensions chip finite domains included ary arithmetic constraints linear polynomials constraints alldifferent circuit atmost element 
solver domain chr implemented version element constraint lower complexity chip introducing path consistency constraint 
sense constraint binary 
seen enumeration domain pairs 
simply reused special cases intersection normal unary enumeration domains introduce new special cases 
sample rules arithmetic constraints see section equal minx maxx miny 
minx miny maxx maxy 
equal minx maxx 
miny maxx maxy minx miny maxy 
example equal 
equal 
intersection equal 

equal 
intersection equal related solvers due structural character descriptions east asian analyzed generated 
sketches characters produced symbolic coordinate free description description interpreted system constraints 
constraints highly underdetermined exact geometry information implicit condition final sketch fill square fixed size 
special constraint solving algorithm tailored problem developed 
initial solution rewritten finite domain constraint solver chr library 
author chr lead improvements performance allowing generating sketches characters equivalence classes direction 
feasible original solution heavily relied generate test approach lp 

linear non linear polynomials initial motivation introducing constraints lp non declarative nature built predicates arithmetic computations 
clp languages included constraint solving linear equations inequations reals clp ja rationals prolog iii col chip di adopting variants gaussian elimination simplex algorithm imb 
theory underlying constraint system real closed fields covers linear non linear polynomials shown decidable tarski 
chr solver math gauss chr minimalistic powerful variant variable elimination employed 
linear polynomial represented poly equals constant poly list monomials form variable coefficient coefficients different zero list sorted variables strictly descending order 
rules suffice implement complete efficient solver linear equations floating point numbers rational numbers 
empty equals 
zero 
eliminate equals equals 
equals 
empty rule says polynomial empty constant zero 
predicate zero tests zero user definable error margin case floating point number 
eliminate rule workhorse performs variable elimination 
takes equations start variable equation left unchanged eliminate occurrence common variable second equation 
note variable explicit pivoting performed equations variable react 
solver terminates polynomial ordered large variable replaced strictly smaller ones 
solver complete results normal form left variable equation left occurrence variable 
create explicit variable bindings necessarily implicit equalities variables explicit 
solver confluent equations rule eliminate chosen eliminating variable resulting different new equations easily introducing order equations 
rule efficient result terms satisfiability variables uniquely determined 
flexibility extensions bindings variables introduced special cases rules unify equals 
unified equals 
delete ground equals 
eager variant eliminate rule possible eliminates variable matter occurs equation 
eager equals equals 
delete rule body rule eliminate rule implicit equalities explicit 
remarks termination confluence solver apply 
equation solving benchmark proposed van rational numbers solvers slightly faster lower level implementation rational solver ecl ps 
solved system variables equations minute mhz sun sparc 
solver implement optimization variable projection 
simplex algorithm inequation handled replacing equation help additional variable called slack variable constrained positive 
introduce additional rules maintain solving ax dense matrix mod 
normal form equations consist slack variables 
normal form constrained standard 
slack variables reordered left slack variable equation sign constant 
possible equations inconsistent 
slack variables sign constant zero slack variables zero 
solver math elim chr 
solver math chr result combining solver equations solver performing classical fourier algorithm inequations 
idea perform variable elimination long equation involved process case inequations transitivity rule propagation suggested fourier 
combined solver efficient algorithm avoids slack variables 
related solvers clp system non linear polynomial constraints appear geometric reasoning 
techniques bases complex numbers cal ai partial cylindrical algebraic decomposition risc clp real hon utilized tackle non linear polynomials 
approach interval arithmetic clp ben newton numerica hmd 
approach basically seen sophisticated extension interval domains reals non linear polynomials 
general inefficient decision procedure handles constraints cooperation specialized solvers 
approach requires design client server architecture enable communication various components solvers 
chr introduce constraints plan distribution constraints solvers 
solver works special domain specific constraints order treat linear constraints uses chr equation solver math elim chr rational numbers 
gb software fast grobner bases computation yields canonical form non linear constraints solutions extracted 
symbolic computation software maple compute roots univariate polynomials 
maple simplifies polynomials treated solvers 

applications innovative non standard uses constraint techniques characterize large class potential applications 
necessary constraint handling expressed implemented ease chr 
simplicity flexibility efficiency rapid prototyping advantages chr 
applications done european computer industry research center ecrc collaboration visitors research institutions industry 

planning cordless business communication systems mobile communications comes sites 
employees reached time place 
required small local radio transmitters senders installed 
planning locations specifics radio wave propagation taken account 
radio waves absorbed reflected walls floors building received power single point may exhibit discontinuities tiny changes sender location example move corner 
advanced industrial prototype popular planning radio mol fmb systems kind computes minimal number senders location blue print building information materials walls ceilings 
simulating propagation radio waves ray tracing subsequent constraint optimization number senders needed cover building 
popular developed ecrc siemens research development siemens personal networks department pn institute communication networks aachen university technology 
characteristics building computed grid test points 
test point represents possible receiver position 
test point space sender put cover test point radio cell calculated 
radio cell usually odd shaped object coverage smooth differentiable function 
test grid sufficiently small square meter expect neighbouring test points covered space inbetween building covered 
radio cell constraint set location sender geometrically speaking point space 
try find locations radio cell planes time possible 
possible locations constrained intersections radio cell planes covered 
sender locations cover test points 
way solution computed 
minimize number senders branch bound method 
consists repeatedly searching solution smaller number senders minimal number 
solver attempt restricted dimensions approximated radio cell single rectangle 
coordinates form rectangles orthogonal coordinate system represented pair left upper right lower corner coordinates 
radio cell constraint inside sender rectangle imposed sender point inside rectangle 
inside sender nonempty inside 
intersect inside inside 
max max min min inside 
rule named nonempty says constraint inside valid condition fulfilled rectangle nonempty area 
intersect rule says senders location constrained inside constraints rectangles replace constraints single inside constraint rectangle computed intersection initial rectangles 
compute solution try equate senders possible labeling procedure 
member true equate sender 
sender member true nondeterministically equates remaining senders list member true 
equating senders causes intersect rule fire constraints associated senders 
result labeling procedure senders location constrained intersect rule applied rectangle small empty 
nonempty rule applies causes failure initiates backtracking 
labeling heuristic equate senders radio cells associated nearby test points 
took just minutes extend solver works union rectangles describe radio cell desired degree precision 
corresponds disjunctive constraint inside 
inside rn compactly implemented inside rn 
inside sender list intersect inside inside 
intersect rectangle left inside 
intersect setof intersect 
intersect rect member rect member rect max max min min nonempty solver adapted quickly geometric objects rectangles changing definition intersect 
lifting dimensions just amounted adding third coordinate code analogous dimensions 
simplicity solver mean triviality illustrates power chr 
quite hard implement functionality hard wired black box solver 
finite domains coordinates rounded integers 
application built finite domain solver ecl ps slightly slower chr implementation 
linear polynomial constraints overkill inefficient 
interval arithmetic express required constraints adequately 
disjunctive constraints needed require recasting auxiliary variables expensive error prone limits amount propagation 
cardinality constraint hsd express disjunction available finite domains 
evaluation typical office building optimal placement popular minutes 
quality placements produced comparable human expert 
comparable tool available wise fgk written lines 
optimization wise uses adaptation nelder mead direct search method optimizes percentage building covered 
clp code popular just lines half graphics user interface 
big advantage clp approach flexibility changing labeling heuristic extending solver 

munich rent advisor munich rent advisor mra developed ecrc lmu electronic version ms munich 
ms published regularly german cities 
basically written description expert system allows estimate maximum fair rent flat 
estimates legally binding 
calculations size age location flat series detailed questions flat house 
questions hard answer 
order able calculate rent estimate hand questions answered 
usually calculation performed hand half hour expert city munich associations 
mra brought advising time minutes user needs fill form 
constraints user mra need answer questions 
user may want give information away care question know answer 
ms derived statistical model compiled sample data statistical methods regression analysis 
due underlying statistical approach problem inherent imprecision ignored version ms constraints mra account statistical imprecision 
mra available internet 
world wide web www need user acquire specific software computer handling skills 
process answers questionnaire return result wrote simple stable special purpose web server directly ecl ps sockets internet communication 
approach avoids overhead cgi interfaces 
solver clp point view mra application atypical computation proceeds deterministically constrained input variables user data constrained output variables rent estimate original ms solved problem 
need np hard constraint solving labeling constraint propagation forward direction answer expect smallest interval covering possible enumeration possible backtracking 
approach implement tables rules formulas high level declarative programming ecl ps provided data precise completely known 
added constraints capture imprecision due statistical approach incompleteness due partial user answers 
considered formulas rent calculation constraints refine rent estimate propagation input variables constrained partial answers 
mra dealing imprecise numerical information involves non linear arithmetic computations intervals 
simply modified existing finite domain solver chr domain chr described section deal interval constraints non linear equations form xn number different variables 
solver xn represented mult xn 
mult min max 
min max 
mult min max 
number min min max max min max mult 
xmin xmax mult min max 
min min min xmin max xmax min max xmin min xmax max max min xmin max xmax max max xmin min xmax mult 
need backpropagation application rules suffice 
evaluation years people mra service world wide web www 
winners best application prize fab conference france systems computer show munich 
took man weeks write www user interface weeks write calculation part week debug 
think coding dominated implementation effort conventional programming language 
presumably interval arithmetic express required constraints 
quite difficult tailor amount direction constraint propagation needs application hand 
high level approach implies program easily maintained modified 
crucial city new version comes different tables rules 
munich rent advisor represents class applications atypical constraint logic programming concerned np hard constraint pruned search solution executing existing calculation presence partial information 
clp deal imprecise knowledge partial information elegant correct efficient way provided possible adopt constraints application 
think constraint technology applied engineering applications wants reason partial information compromising correctness 

gave syntax semantics soundness completeness results chr 
introduced important property constraint solvers confluence decidable necessary sufficient test 
chr encode wide range solvers including new domains terminological temporal reasoning 
gave overview solvers showed extended modified mentioned related builds solvers 
existing solvers usually datastructures operations finite domains booleans numbers chr open way generic path consistency conceptual constraint solvers temporal spatial terminological reasoning 
chr successfully challenging applications existing clp systems applied results terms simplicity flexibility efficiency 
real life applications soft dynamic constraints required 
just started wol indicates chr helpful implementing general schemes handle constraints independent constraint domain 
topics research mentioned draft chr ffl correctness specifications ffl termination confluence ffl negation entailment constraints ffl combination communication solvers ffl debugging constraint solvers ffl soft constraints priorities ffl automatic labeling ffl dynamic constraints removable constraints ffl variable projection ffl partial evaluation ffl interpretation topics issue today 
clearly termination property important confluence topic research start see long version article fru 
chr solve conjunctions constraints operations typically expected constraint solver variable projection entailment investigated fru 
think survey illustrated languages chr fulfill promise user defined constraints described acm theoretician meta theorems proved analysis techniques invented implementor different constructs backward forward chaining suspension compiler optimization debugging implemented user set ideas need understood rich albeit disciplined variations constraint systems 
collaborators visitors ecrc especially meuss colleagues lmu hanschke ch 

people discussed chr contributed comments 
name 
mention colleagues ecrc wallace le provost constraint team 
ecrc chr partially supported esprit project 
wife andrea daughter anna ongoing support patience 
chr papers solvers mentioned article available url www pst informatik uni muenchen de 
abd 
operational semantics confluence constraint propagation rules rd intl conf principles practice constraint programming cp linz austria springer lncs pp october november 
abd 
analyse von german ph thesis dept computer science lmu munich appear february 
acm 
constraint programming working group acm mit workshop report outline draft september 
ai 
constraint logic programming language cal intl conf fifth generation computer systems ohmsha publishers tokyo pp 

ait kaci nasr login logic programming language built inheritance journal logic programming 

zur des fur munchen german der munchen amt fur city munich germany 

allen maintaining knowledge temporal intervals communications acm vol 
pp 


andreoli pareschi linear objects logical processes builtin inheritance seventh intl conf logic programming mit press cambridge mass usa pp 
apg 
ait kaci podelski goldstein order sorted feature theory unification dec prl research report may dec paris research laboratory france 

baader hanschke 
scheme integrating concrete domains concept languages 
th intl joint conf artificial intelligence 
bcl 

banatre coutant le metayer parallel machine multiset transformation programming style generation computer systems 
bds 
buchheit donini schaerf decidable reasoning terminological knowledge representation systems journal artificial intelligence research 

benhamou older bell northern research applying interval arithmetic integer boolean constraints technical report june 
bja 
proving consistency ia chronicles implementation master thesis dept information computer science 
ben 
benhamou interval constraint logic programming chapter constraint programming basics trends podelski ed springer lncs march 

benhamou van hentenryck clp intervals revisited ilps mit press cambridge mass usa 
codi 
diaz compiling constraints clp fd journal logic programming 
coh 
cohen view origins development prolog communications acm january 
col 
colmerauer prolog iii communications acm july 

davis putnam computing procedure quantification theory journal acm 
deb 
debray qd janus sequential implementation janus prolog software practice experience vol 
number december pp 
di 
dincbas constraint logic programming language chip fifth generation computer systems tokyo japan december 
dmp 
dechter meiri pearl temporal constraint networks journal artificial intelligence 
don 
constraint implementation grf esprit project equator report june 
dos 
dershowitz okada sivakumar confluence conditional rewrite systems st ctrs pp springer lncs 
due 
prolog structured character description font design journal logic programming special issue applications leon sterling ed february 
dum 
application resolution backtracking solution constraint satisfaction problems project report dept computer science university york england 

toledo qualitative spatial orientation constraint handling rules ecai budapest hungary wahlster ed john wiley sons august 
fab 
fruhwirth rent estimates constraints internet system description de programmation en logique programmation par contraintes france june 
fam 
fruhwirth meuss confluence constraint handling rules nd intl conf principles practice constraint programming cp cambridge usa springer lncs august 
fam 
fruhwirth meuss confluence semantics constraint handling rules constraint journal kluwer academic publishers accepted publication appear 



esolution des syst emes equations alg 
phd thesis universit paris 
fgk 
fortune gay kernighan wise design indoor wireless systems ieee computational science engineering vol 
pp spring 
fmb 
fruhwirth 
planning cordless business communication systems ieee expert magazine special track intelligent telecommunications february 
fr 
fruhwirth le provost lim wallace 
constraint logic programming informal chapter logic programming action springer lncs september 

fruhwirth munich rent advisor st workshop logic programming tools internet applications jicslp bonn germany september 

fruhwirth constraint programmierung german textbook springer verlag heidelberg germany september 

fruhwirth high level implementations constraint handling rules technical report ecrc ecrc munich germany june 

fruhwirth chapter constraint handling rules eclipse extensions user manual ecrc munich germany december 

fruhwirth chr library version ecl ps released ecrc munich germany january 

fruhwirth optimal planning digital cordless telecommunication systems rd intl conf practical application constraint technology pact london april 

fruhwirth hanschke terminological reasoning constraint handling rules chapter principles practice constraint programming van hentenryck saraswat eds mit press cambridge mass usa april 
fru 
fruhwirth introducing simplification rules workshop berlin germany october workshop rewriting constraints dagstuhl germany october technical report ecrc lp ecrc munich germany october 
fru 
fruhwirth constraint simplification rules jicslp workshop constraint logic programming washington usa november technical report ecrc ecrc munich germany july 
fru 
fruhwirth entailment simplification constraint constructors chr constraints workshop constraint logic programming marseille france march 
fru 
fruhwirth chr constraint handling poster intl conf logic programming iclp budapest hungary mit press cambridge mass usa june 
fru 
fruhwirth temporal reasoning constraint handling rules technical report ecrc ecrc munich germany february 
fru 
fruhwirth constraint handling rules chapter constraint programming basics trends podelski ed springer lncs march 
fru 
fruhwirth declarative language constraint systems theory practice constraint handling rules habilitation dept computer science lmu munich december 

gonnet leong maple language manual springer new york berlin paris 
gr 
graf sur les contraintes en programmation en logique french ph thesis version june universite de nice france september 

eine fur einen german master thesis university kaiserslautern germany april 
hol 
vs attributed variables context extensible unification intl symposium programming language implementation logic programming plilp pp springer lncs august 
hon 
hong non linear real constraints constraint logic programming algebraic logic programming conf volterra italy kirchner levi eds springer lncs pp 
hmd 
van hentenryck michel deville numerica modeling language global optimization mit press cambridge mass usa 
hsd 
van hentenryck vijay saraswat deville constraint processing cc fd chapter constraint programming basics trends podelski ed springer lncs 
imb 

linear constraint solving clp languages chapter constraint programming basics trends podelski ed lncs march 
ja 
jaffar clp language system acm transactions programming languages systems vol july pp 

janson programming paradigms andorra kernel language ilps san diego usa 

jaffar 
lassez constraint logic programming acm th popl munich germany january pp 
jama 
jaffar maher constraint logic programming survey journal logic programming 

kautz ladkin integrating metric qualitative temporal reasoning aaai pp 

kirchner kirchner rewriting theory applications northholland 
kom 
kawamura mizoguchi cs prolog generalized unification constraint solver th conf logic programming tokyo japan june furukawa eds springer lncs pp 

kowalski sergot logic calculus events new generation computing 
lel 
constraint programming languages specification generation addison wesley reading massachusetts 
mac 
mackworth consistency networks relations journal artificial intelligence 

mackworth freuder complexity polynomial network consistency algorithms constraint satisfaction problems journal artificial intelligence 
mah 
maher logic semantics class committed choice programs th intl conf logic programming melbourne australia pp mit press cambridge mass usa 

study boolean constraint solvers constraint logic programming selected research benhamou colmerauer eds mit press cambridge mass usa 
mei 
meiri combining qualitative quantitative constraints temporal reasoning aaai pp 
mol 

entwicklung eines zur fur die kommunikation german master thesis university technology aachen germany june 

rusinowitch implementing non linear constraints cooperative solvers george eds acm symposium applied computing sac philadelphia pa usa pp acm press february 
nai 
naish prolog control rules th intl joint conf artificial intelligence los angeles california september pp 
new 
newman theories combinatorial definition equivalence annals math vol 
pp 
sako 
sadri kowalski variants event calculus th intl 
conf logic programming tokyo japan pp mit press cambridge mass usa june 
san 
sandewall features fluents representation knowledge dynamical systems vol 
oxford university press 
sar 
saraswat concurrent constraint programming languages ph thesis carnegie mellon univ draft january 
sar 
saraswat concurrent constraint programming mit press cambridge mass usa 

schmidt schau smolka attributive concept descriptions complements journal artificial intelligence 
sha 
shapiro family concurrent logic programming languages acm computing surveys september 
sid 
language optimizing constraint propagation thesis simon fraser university canada 
smo 
smolka residuation guarded rules constraint logic programming constraint logic programming selected research benhamou colmerauer eds mit press cambridge mass usa 

smolka eds dfki oz documentation series dfki saarbrucken germany 

smolka records logic programming journal logic programming 

baumgartner constraint model elimination implementation th workshop theorem proving analytic tableaux related methods pp baumgartner posegga eds springer lnai 
vh 
van hentenryck constraint satisfaction logic programming mit press cambridge mass usa 
vh 
van hentenryck constraint logic programming knowledge engineering review vol pp 

vilain kautz constraint propagation algorithms temporal reasoning aaai pp 
wil 
equate object oriented constraint solver acm oopsla pp 
wol 
wolf incremental adaption constraint handling rule derivations cp workshop theory practice dynamic constraint satisfaction linz austria november 
