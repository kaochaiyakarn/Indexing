data replication mobile computers huang prasad sistla ouri wolfson electrical engineering computer science department university illinois chicago illinois users mobile computers soon online access large number databases wireless networks 
limited bandwidth wireless communication expensive wire communication 
analyze various static dynamic data allocation methods 
objective optimize communication cost mobile computer stationary computer stores online database 
analysis performed cost models 
connection time cellular telephones user charged minute connection 
message packet radio networks user charged message 
analysis addresses average case worst case determining best allocation method 
users mobile computers notebook computers personal communication systems soon online access large number databases wireless networks 
potential market activity estimated billions dollars annually access communication charges 
example road passengers access airline carriers schedules weather information 
investors access prices financial instruments access inventory data callers access location dependent data nearest taxi cab see route planning computers cars access traffic information 
limited bandwidth wireless communication expensive wire communication 
research supported part nsf iri nsf ccr appear acm sigmod minneapolis minnesota may example cellular telephone call costs cents minute 
example ram mobile data charges average data message mobile computer actual charge depends length message 
clear users perform hundreds accesses day wireless communication expensive 
important mobile computers access online databases way minimizes communication 
achieved appropriate 
example user frequently reads data item updated infrequently beneficial user allocate copy mobile computer 
words mobile user subscribes receive updates way reads access local copy require communication 
infrequent updates transmitted online database mobile computer 
contrast user reads infrequently compared update rate copy allocated mobile computer 
access demand read request sent stationary computer stores online database 
copy copies possible allocation schemes data item mobile computer 
scheme stationary computer copy second scheme stationary mobile computer copy allocation method determines allocation scheme changes time 
static allocation method allocation scheme change time dynamic 
example dynamic allocation method 
allocation scheme changes copies copy result larger number writes reads window minutes 
mobile computing geographical area usually divided cells stationary controller 
stationary computer confused stationary controller 
stationary computer node stationary network fixed data item change mobile computer moves cell cell 
analyze static allocation methods uses copy scheme uses copies scheme family dynamic data allocation methods 
methods suggested need select allocation scheme read write ratio reads frequent methods copy allocation scheme copies scheme 
family consists methods allocate deallocate copy data item mobile computer sliding window requests 
read update refer updates writes latest requests examined 
number reads higher number writes mobile computer copy copy allocated mobile computer number writes higher number reads mobile computer copy copy deallocated 
allocation scheme dynamically adjusted relative frequencies reads writes 
algorithms family distributed implemented software residing mobile stationary computers 
different algorithms family differ size window analysis static dynamic algorithms addresses worst case expected case reads writes poisson distributed 
furthermore analysis done cost models 
connection time user charged minute cellular telephone connection 
model mobile computer reads item stationary database computer read request response executed connection minimum length say minute 
writes propagated mobile computer propagation executed minimum length connection 
second cost model message 
model user charged message exact charge depends length message 
model distinguish data messages longer control messages shorter 
carry data item control messages carry control information specifically read requests mobile computer stationary computer delete requests delete request message deallocates copy mobile computer 
remote read request necessitates control message response necessitates data message 
write propagated mobile computer necessitates 
rest organized follows 
section summary results 
section formally model section precisely sliding window family dynamic allocation algorithms 
section develop results connection cost model section develop results message model 
section discuss dynamic allocation methods extensions handle read write operations multiple objects 
section compare relevant literature 
section discuss analysis 
due space limitations proofs omitted 
summary results consider single data item single mobile computer analyze static allocation methods st mobile computer copy st mobile computer copy dynamic allocation methods sw sliding window window size 
assume reads mobile computer issued poisson distribution parameter time unit expected number reads writes stationary computer issued independently poisson distribution parameter requests ignored cost affected allocation scheme 
denote analysis algorithms uses measures 
called expected cost denoted exp gives expected cost read write request case known fixed 
second called average expected cost denoted av important case unknown varies time equal probability having value 
gives average expected cost request possible values 
third measure worst case notion competitiveness see line algorithm 
intuitively data allocation algorithm said competitive sequence read write requests cost times minimum cost cost incurred ideal offline algorithm knows sequence requests advance contrast algorithms online sense service current request knowing request 
remainder section summarize results cost models discussed traditional worst case complexity function size input inappropriate algorithms discussed complexity measure 
example connection model algorithm sequence requests size algorithm incurs cost 
results interpreted discussed intuitive level section 
summary results connection model connection model results follows 
st expected cost expected number connections request gamma st expected number connections request 
sw expected cost request delta ff gamma delta gammaff ff probability majority consecutive requests reads formula probability equation 
furthermore show fixed sw lower minf gamma static allocation method st best expected cost request static allocation method st best expected cost request 
consider average expected cost 
sw best average possible values expected cost request 
cost deltak decreases increases coming optimum 
contrast st st average expected cost worst case show st st competitive ratio performance performance optimal perfect knowledge algorithm unbounded 
contrast show sw competitive competitiveness factor tight 
summary worst case cost sw family allocation algorithms increases increases average expected cost decreases increases 
window size chosen strike balance conflicting requirements 
example may provide reasonable compromise 
summary results message passing model model results follows 
denote ratio cost control message cost data message 
st expected cost request delta gamma st expected cost 
sw expected cost delta gamma delta delta sw derived expected cost function shown equation section 
formulae expected costs conclude 

delta 
st best expected cost delta 
delta 
st best expected cost delta 
delta 

delta 
sw algorithm best expected cost 
dominance graph strategies st sw st superiority coverage message model shown 
indicates superior algorithm value 
consider average expected cost obtain results 
st average expected cost 
st average expected cost sw average expected cost delta 
average expected cost sw equation section lower bound 
conclude sw best average expected cost 
average expected cost decreases window size increases see corollary section 
worst case show connection cost model st st competitive 
similarly show sliding window algorithm sw delta competitive sw delta competitive 
summary trade average expected cost worst case similar connection model 
dynamic allocation algorithm superior static ones worst case improving decreasing window size average expected cost decreases window size increases 
model mobile computer system consists mobile computer mc stationary computer sc stores online database 
consider data item stored stationary computer times 
reads writes issued mobile stationary computers 
reads writes stationary computer may originated computers origin irrelevant model 
furthermore ignore reads issued stationary computer writes issued mobile computer cost request fixed zero respectively regardless mc copy data item 
relevant requests writes issued stationary computer reads issued mobile computer 
schedule finite sequence relevant requests data item example schedule 
request issued mc copy data item 
purpose analysis assume relevant requests sequential 
practice may occur concurrently concurrency control mechanism serialize analysis holds 
consider cost models 
called connection model 
model algorithm static dynamic cost requests follows 
exists copy object mc read request issued read costs connection data item sent sc 
read costs zero 
write sc mc copy data item write costs connection read costs zero 
total cost schedule denoted cost sum costs requests 
second model called message cost model 
model assume data message cost control message cost 
length control message higher length data message 
model cost requests follows 
read request exists copy mc read require communication necessitates control message forwards request sc data message transfers data mc total cost 
write request mc copy data item write costs 
write costs depending algorithm result comparison reads writes executed mc response write request 
write propagated mc mc deallocate copy response cost mc deallocates copy response cost 
accounts deallocate request 
explained section sw propagate writes mc simply deallocates copy mc write request 
cost write 
assume reads issued mc poisson distributed parameter writes issued sc poisson distributed parameter denote 
observe poisson distribution memoryless point time probability request write gamma probability request read 
suppose data allocation algorithm read write distribution parameters respectively 
denote expected cost relevant request 
suppose unknown varies time equal probability having value 
define average expected cost request denoted av ga mean value ranging av ga average expected cost interpreted follows 
suppose time subdivided periods period reads writes distributed parameters second period reads writes distributed parameters 
suppose equal probability having value 
words random number 
algorithm expected cost relevant request periods time integral denoted av ga worst case study take competitiveness measure performance line data allocation algorithm 
formally competitive data allocation algorithm defined follows 
suppose perfect data allocation algorithm complete knowledge past requests 
data allocation algorithm competitive exist numbers schedule costa delta call competitiveness factor algorithm competitive algorithm bounds worst case cost algorithm constant factor minimum cost 
say algorithm tightly competitive competitive number competitive 
sliding window algorithms sliding window algorithm allocates deallocates copy data item mobile computer 
examining window latest relevant read write requests 
window size recall reads issued mobile computer writes issued stationary computer 
observe point time mobile computer copy mobile computer stationary computer aware relevant requests 
mobile computer copy reads issued mobile computer satisfied locally writes issued stationary computer propagated mobile computer mobile computer receives relevant requests 
mobile computer copy reads issued mobile computer sent stationary computer stationary computer receives relevant requests 
mobile computer stationary computer charge maintaining window requests 
window tracked sequence bits represents read represents write 
receipt relevant request computer charge drops bit sequence adds bit representing current operation 
compares number reads number writes window 
number reads bigger number writes copy mobile computer sw algorithm simply waits operation 
number reads bigger number writes copy mobile computer stationary computer charge copy allocated follows 
observe request read 
stationary computer responds read request sending copy mobile computer 
sw algorithm piggybacks message indication save copy mc local database sc commits propagate writes mc current window requests 
point onwards mc charge 
number writes bigger number reads copy mc sw algorithm waits request 
number writes bigger number reads copy mc mc charge copy deallocated follows 
sw algorithm sends sc indication sc propagate writes mc current window requests 
point onwards sc charge 
concludes description algorithm point remarks 
window size mc copy write sc deallocate copy window consist write 
sending mc copy sc simply sends deallocates copy mc 
sw denotes algorithm optimized 
second ease analysis assume window size odd 
connection cost model section analyze algorithms connection cost model 
section divided subsections 
subsection probabilistically study static data allocation algorithms second study family sliding window algorithms 
subsections derive expected cost average expected cost compare algorithms measures 
section analyze worst case performance algorithms 
probabilistic analysis static algorithms st algorithm write request costs read request cost connection 
st algorithm write costs read costs 
exp st exp st simply equal probabilities request read write respectively 
gamma concerning average expected cost equation equation obtain av gst exp st av gst probabilistic analysis sw algorithms section derive expected cost sw algorithms show sw algorithm higher expected cost static algorithms 
derive average expected cost sw algorithms show sw algorithm lower average expected cost static algorithms 
show average expected cost sw algorithms decreases increases 
recall assuming size window delta odd number 
point time probability exists copy mc denote ff probability majority preceding requests reads probability number writes preceding requests equal ff delta delta gamma gammaj theorem expected cost sw algorithm delta ff gamma delta gamma ff theorem compares expected costs sw static algorithms 
theorem exp swk consider average expected costs 
theorem sliding window algorithm window size sw average expected cost request av delta corollary average expected cost sw algorithms decreases window size increases av gst av st 
worst case analysis connection model section show static algorithms st st competitive 
show sw algorithm competitive 
competitiveness study suggests optimizing worst case choose sliding window algorithm small window size consider static strategies 
st algorithm pick long schedule consists reads 
cost st algorithm un boundedly higher cost optimal algorithm schedule keep copy mc 
st algorithm pick long schedule consists writes 
cost st algorithm schedule unboundedly higher optimal cost keep copy mc 
static algorithms st st competitive omit formal proof due space limitation 
theorem sliding window algorithm sw tightly competitive 
message cost model section divided subsections 
subsection probabilistically analyze static algorithms second analyze sw third analyze family sliding window algorithms sw 
subsections study algorithm expected cost average expected cost 
study relation expected costs static dynamic algorithms relation average expected costs 
subsection study worst case algorithms 
recall model assume data message cost control message cost ranges 
probabilistic analysis static algorithms st algorithm write require communication read costs st algorithm write costs read costs 
delta gamma av gst av gst probabilistic analysis sw algorithm derive expected cost relevant request 
theorem expected cost sw algorithm exp sw delta gamma delta delta 
theorem study relation expected costs algorithms exp st exp st 
results theorem graphically illustrated 
theorem expected costs exp sw related follows depending 

delta 
exp st exp sw exp st delta 
delta 

delta 
exp sw mentioned section sw simply sw 
cost model difference algorithms results different analysis need separate subsection dedicated analysis sw st exp st delta 
delta 
exp st exp sw exp st ready consider average expected cost 
theorem average expected cost sw algorithm av sw delta av sw av st av st probabilistic analysis sw section consider sw algorithms delta 
derive formula expected cost sw show expected cost sw higher minimum expected costs sw st st conclude known fixed sw inferior algorithms 
derive formula average expected cost sw show sw best average expected cost determine optimal function cost control message 
theorem expected cost sw algorithm exp swk ff delta gamma ff delta gamma delta delta delta delta delta gamma theorem expected cost algorithm sw higher expected cost algorithms sw st st exp swk exp st exp st order prove theorem need lemmas 
lemma exp st 
sw sw lemma ff decreases increases gamma gamma ff 
lemma 
delta gamma gamma delta gamma gamma exp swk exp sw 
consider average expected cost sw algorithms 
theorem sw algorithm window size average expected cost av swk delta delta delta delta delta corollary av decreases increases av theorem shown average expected cost sw algorithm better lower static algorithm 
corollaries analyze average expected cost sw lower average expected cost sw formulae 
corollary show average expected cost sw higher sw corollary av swk av sw 
corollary study case 

show 
average expected cost sw lower sw illustrates results corollaries 
example sw algorithm lower expected cost sw sw algorithm lower expected cost sw corollary 
av swk av sw satisfies gamma gamma delta delta delta delta gamma worst case message model section study competitiveness algorithms st st sw message cost model 
result sw stated separately special case see section 
conclude static algorithms competitive case connection model 
show sw competitive sw show competitiveness factor sw algorithms deteriorates increases sw performs best worst case 
connection model easily derive static algorithms competitive message model 
theorem algorithm sw tightly delta competitive message cost model 
ratio control message cost data message cost 
theorem algorithm sw tightly delta competitive message cost model 
ratio control message cost data message cost 
extensions section discuss various extensions previous methods 
particular subsection show modify static algorithms competitive second subsection discuss extensions algorithm optimize case multiple objects read written single operation 
modifications static methods simple static methods copy copies schemes 
static methods chosen value known advance 
example connection model static method single copy stationary computer best expected cost 
similarly static method copy scheme best expected cost 
static methods worst case behavior competitive 
example static method single copy incur high cost sequence requests consisting reads mobile computer 
cost arbitrarily large depending length sequence 
sequence highly improbable occur nonzero probability 
overcome problem simple modifications static methods dynamic 
example modify copy static method follows 
normally copy scheme consecutive reads occur changes copies scheme uses scheme write 
reverts back copy scheme repeats process 
refer algorithm shown competitive expected cost gamma gamma gamma connection model 
note second term additional expected cost static method price competitiveness 
know choose algorithm st appropriate value shown algorithm slightly lower expected cost swm similarly modify copy static method obtain algorithm competitive 
multiple objects addressed problem choosing allocation method single object 
results extended case multiple objects read written single operation 
sketch algorithm gives optimal static allocation method connection model multiple objects frequencies operations objects known advance 
assume multiple data items remotely read connection similarly remote writes 
algorithm case objects generalized objects 
discuss approach extended dynamic window algorithms 
assume objects classify read operations classes 
reads reads reads access assume different reads occur independent poisson distributions frequencies respectively 
classify writes similarly assume writes occur frequencies respectively 
noted denote frequencies joint reads writes respectively 
possible allocation methods st copy st copies st copy copy st copies 
allocation methods obtain expected cost single operation frequencies chose lowest expected cost 
example expected cost st st sum read write frequencies 
method generalized finite set objects 
need frequencies various joint operations objects 
method need know frequencies various operations advance 
frequencies known advance window approach dynamically calculates frequencies 
case need keep track number operations different kind joint exclusive read write operations multiple objects window 
numbers calculate frequencies operations compute expected costs similar static methods previous paragraph frequencies chose appropriate allocation method 
avoid excessive overhead recomputation done periodically operation 
address performance analysis method 
comparison relevant literature far know study communication cost static dynamic allocation distributed systems average case worst case analysis 
bodies relevant discussed subsections 
subsection compare database literature data allocation distributed systems 
second subsection compare literature caching distributed virtual memory 
data allocation distributed systems data allocation distributed systems static dynamic 
considered dynamic data allocation algorithms analyzed notion convergence different measures expected case worst case 
additionally algorithms works different ones discussed 
furthermore consider static allocation algorithms consider connection cost model 
dynamic data allocation algorithms introduced 
works analyze dynamic data allocation worst case 
sw algorithm analyzed 
model requires minimum copies system availability purposes 
worst case results different 
contrast assume availability constraints handled exclusively stationary system independently mobile computers 
addressing dynamic data allocation algorithms 
addresses worst case 
additionally model allow concurrent requests requires centralized decision making processor aware requests network 
contrast algorithms distributed allow concurrent read write requests 
static allocation studied 
works address file allocation problem 
assume read write pattern processor known priori estimated find optimal static allocation scheme 
works file allocation problem compare static dynamic allocation quantify cost penalty read write pattern deviates estimate 
works data replication problem file systems coda address solely availability aspect ensure availability data item presence failures :10.1.1.12.448
contrast addressed communication cost issue 
works done alonso ganguly related sense address optimization issue mobile computers 
optimization objective energy communication 
caching virtual memory computer architecture operating systems literature studies subjects related dynamic data allocation caching distributed virtual memory see 
important differences caching distributed virtual memory hand replicated data distributed systems 
results obtained previously 
methods focus communication cost consider collection factors determine performance complexity resulting problem dictates analysis experimental uses simulation 
contrast assumed mobile computing wireless communication involves immediate pocket expense optimization wireless communication takes precedence performance 
example performance principal optimization criterion mobile computer keep copy data item subscribe receive updates data item way read local fastest 
obviously approach may incur excessive communication 
second size cache limited 
important issues literature cache utilization page replacement strategy lru mru page replace cache cache full new page brought 
words contrast replicated data distributed systems may reside secondary tertiary storage literature page uncached result writes results limited storage 
may argue limited storage major issue distributed databases assumed storage mobile computer abundant 
third architecture assumed methods bus 
architecture supports broadcast cost single cast hand incurs contention 
contrast assumed point point communication 
considered data allocation algorithms mobile computers 
particular considered copy copies allocation schemes 
investigated static dynamic allocation methods schemes 
static method allocation scheme remains unchanged execution 
dynamic method allocation scheme changes dynamically window consisting requests window reads mobile computer writes stationary computer copy scheme copy scheme 
get different dynamic methods different values considered cost models connection model message model 
connection model cost measured terms number wireless telephone connections message model cost measured terms number control data messages 
considered different measures expected cost average expected cost worst case cost uses notion competitiveness 
roughly speaking algorithm said competitive sequence read write requests cost sequence times cost ideal line algorithm knows advance 
algorithm said competitive competitive 
expected cost standard expected cost request assuming fixed probabilistic distributions reads writes 
believe allocation method chosen expected cost worst case cost 
specifically think allocation method chosen minimize expected cost provided bound worst case behavior 
explain difference expected cost average expected cost 
assumed reads mobile computer writes stationary computer occur independent poisson distributions frequencies respectively 
values known specifically value known allocation method chosen expected cost competitiveness 
unknown varies equally value allocation method chosen average expected cost addition competitiveness 
allocation method lower average expected cost lower average cost request sequence requests frequencies reads writes vary time 
connection model greater read frequency lower write frequency static allocation method copy stationary computer best expected cost 
similarly smaller static allocation method copy stationary computer mobile computer best expected cost 
static methods worst case behavior competitive 
example static method single copy incur high cost sequence requests consisting reads mobile computer 
cost arbitrarily large depending cost sequence 
sequence highly improbable occur nonzero probability 
address problem developed section set algorithms slightly modify static methods 
closely approximate expected cost static algorithms competitive 
sequence reads mentioned algorithm adapt changing copy scheme 
furthermore shown best expected cost algorithms approaches expected cost best static algorithm increases 
example expected cost algorithm come optimum 
swm algorithms competitive expected cost slightly higher 
change time changes time dynamic methods sw appropriate value chosen 
due fact average expected cost sw algorithms lower static methods 
value window size chosen strike balance average expected cost decreases increases see equation competitiveness sw algorithm competitive competitiveness worse increases 
example sliding window algorithm average expected cost optimum worst case times worse optimum offline algorithm 
message model static allocation methods competitive dynamic allocation methods sw competitive different competitiveness factor 
expected cost methods st st sw lowest particular depends values 
ratio control message cost data message cost 
lowest expected cost algorithm function 
unknown varies sliding window methods provides optimal average expected cost 
particular depends value 
sw algorithm chosen average expected cost values higher value lower average expected cost sw algorithm see 
appropriate value chosen strike balance average expected cost competitiveness 
archibald baer evaluation cache coherence solutions shared bus multiprocessors acm trans 
computer systems nov pages agarwal simoni hennessy horowitz evaluation directory schemes cache coherence proc 
th int symp 
computer architecture pages june ahamad ammar multidimensional voting acm trans 
computer systems pages alonso ganguly query optimization energy efficiency mobile proc 
int workshop foundations models languages data objects austria agrawal el abbadi tree quorum protocol efficient approach managing replicated data proc 
th vldb august 
bennett carter zwaenepoel adaptive software cache management distributed shared memory architectures proc 
th int symp 
comp 
arch pages may bennett carter zwaenepoel munin distributed shared memory type specific memory coherence proc 
conference principles practice parallel programming march bartal fiat rabani competitive algorithms distributed data management th annual acm stoc victoria canada 
badrinath imielinski replication mobility proc 
nd workshop management replicated data ii pp 
monterey ca 
cheung ammar ahamad grid protocol high performance scheme maintaining replicated data proceedings th international conference data engineering pp january 
carey franklin livny shekita data caching tradeoffs client server architectures acm sigmod pages michael carey miron livny distributed concurrency control performance study algorithms distribution replication proc 
th vldb conf los angeles ca foster comparative models file assignment problem acm computing surveys 
eggers katz characterization sharing parallel programs application coherency protocol evaluation proc 
th int symp 
comp 
architecture pages june susan eggers randy katz evaluating performance snooping cache coherency protocols proc 
th int symp 
computer architecture june eager achieving robustness distributed database systems sept fiat karp luby mcgeoch sleator yong competitive paging algorithms journal algorithms pages ganguly alonso query optimization mobile technical report december gifford 
weighted voting replicated data proc 
th acm symposium operation system principles pages huang ouri wolfson competitive dynamic data replication algorithm ieee proc 
th international conference data engineering pages vienna austria huang ouri wolfson dynamic allocation distributed system mobile computers ieee proc 
th int conf 
data engineering pages houston texas 
imielinski badrinath querying highly mobile distributed environments proc 
th int conf 
vldb pp 
kai li shared virtual memory loosely coupled multiprocessors ph 
thesis september department computer science yale university new heaven ct usa kai li paul hudak memory coherence shared virtual memory systems acm trans 
computer systems nov lee synchronization multiprocessor caches proc 
th int symp 
comp 
architecture pages may karlin manasse rudolph sleator competitive snoopy caching algorithmica kistler satyanarayanan disconnected operation coda file system acm trans 
computer systems february pages eager disk cache performance distributed systems proc 
th int conf 
dist computing systems pages may manasse mcgeoch sleator competitive algorithms online problems proc 
th acm stoc pp 
acm satyanarayanan kistler kumar okasaki siegel steere coda highly available file system distributed workstation environment ieee trans 
computers april pages thomas majority consensus approach concurrency control multiple copy database acm trans 
database systems june ouri wolfson sushil jajodia distributed algorithms dynamic replication data proc 
acm pods ouri wolfson sushil jajodia algorithm dynamic data distribution proc 
nd workshop management replicated data ii pp 
wolfson milo multicast policy relationship replicated data placement acm tods 
wang rowe cache consistency concurrency control client server dbms architecture acm sigmod pages 
