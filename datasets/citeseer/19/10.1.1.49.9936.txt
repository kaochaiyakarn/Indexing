industrial strength theorem prover logic common lisp matt kaufmann strother moore personal material permitted 
permission reprint republish material advertising promotional purposes creating new collective works resale redistribution servers lists reuse copyrighted component works obtained ieee 
acl re implemented extended version boyer moore nqthm kaufmann pc nqthm intended large scale verification projects 
deals primarily scaled nqthm logic industrial strength programming language large applicative subset common lisp preserving total functions logic 
possible run formal models efficiently keeping logic simple 
enumerate important features acl briefly summarize industrial applications model motorola cap digital signal processing chip proof correctness kernel floating point division algorithm amd microprocessor advanced micro devices index terms formal verification automatic theorem proving computational logic partial functions total functions type checking microcode verification floating point division digital signal processing 
formal verification mathematical techniques verify properties system description 
reported performed authors employed computational logic matt kaufmann motorola box md austin tx 
mail matt kaufmann email mot com 
moore department computer sciences university texas austin austin tx 
mail moore cs utexas edu 
manuscript received oct revised mar recommended acceptance heitmeyer information obtaining reprints article please send mail computer org ieeecs log number particular style formal verification shown considerable promise years general purpose automated reasoning systems model systems prove properties 
reasoning system requires considerable assistance user important system provide convenient ways user interact 
state art general purpose automated reasoning system acl computational logic applicative common lisp 
number automated reasoning systems exist discuss subsection 
describe acl offerings user convenient industrial strength 
section history acl project 
section describes logic supported acl designed convenient specification verification 
section discusses guards connect acl efficient execution common lisp provide powerful specification capability 
illustration role guards section 
section discuss important features acl 
section industrial applications 
conclude section 

brief comparison theorem provers mentioned automated reasoning systems acl ancestors 
scope survey field provide descriptions systems say words order provide context 
active research continues automated reasoning number areas 
incomplete list 
case give representative systems 
certainly areas contain considerable overlap 
ffl provers providing strong support specification computing systems see ffl ctl model checkers ffl geometry provers ffl order provers ffl classical mathematics ffl constructive mathematics ffl provers symbolic computation engines ffl meta theoretic systems provers category distinguished convenience offer specifying computing systems 
cases prover category capabilities categories conversely provers categories placed 
category may subdivided follows 
ffl higher order tactic provers hol ffl higher order heavily automated provers pvs ffl order heavily automated provers acl nqthm ffl provers integrated program verification systems space permit detailed comparisons 
bill young special issue compares pvs acl particular example 
acl ancestral system nqthm compared nuprl 
extremely difficult compare general purpose theorem provers part experienced users dramatically affect system behavior proper formulation problems 
said systems cited support logics powerful acl 
hand acl theorem prover encourages reliance user system automatic aspects 
users happy essentially quantifier free order logic believe acl offers convenience type reasoning required model prove properties digital computing systems 
addition sophisticated inference engine provides acl provides extremely efficient evaluation allowing formal models serve simulators systems described 
turn provides immediate proof independent payoff requirements testing code development 
additional reasons acl convenience broadly lumped proof engineering considerations discussed section 
see url www formal stanford edu clt ars ars db html data base automated reasoning systems including brief descriptions links home pages systems mentioned 

history acl direct descendant boyer moore system nqthm interactive enhancement 
see ancestral systems including reasonably large set accomplishments systems 
particular successes described 
tutorial systems may 
nqthm acl supports lisp order quantifier free mathematical logic recursively defined total functions 
experience earlier systems supports claim logic sufficiently expressive permit address deep mathematical problems realistic verification projects 
fact nqthm logic executable important asset model hardware software systems models executed means accuracy 
consider example nqthm model mc corroborated fabricated chip running test vectors nqthm model 
largest formal verification projects done far carried nqthm 
cite explicitly cli short stack design fabrication fm microprocessor verification berkeley string library top mc microprocessor 
formal models projects collectively pages long involve functions 
despite successes nqthm designed kinds large scale projects inadequacies 
important inadequacy nqthm lack theorem proving power quickly settle question put proceed efficiently 
looking better proof techniques know build significantly powerful automatic theorem prover nqthm logic 
scale nqthm focused engineering issues 
decided step adopt logic applicative subset commonly programming language gaining access efficient execution platforms models written logic program development modeling environments 
chose common lisp expressiveness efficiency familiarity 
properly formulated common lisp execute speeds comparable guiding tenets acl project conform compliant common lisp implementations add logic violates understanding user input submitted directly common lisp compiler executed environment suitable acl specific macros functions acl kernel defined acl implementation language acl system 
third tenet akin recoding nqthm nqthm logic task believe produce unacceptably slow performance 
programming acl system acl emphasize word significantly acl theorem prover fact powerful nqthm ways 
see section 
repeatedly forced extend subset write acceptably efficient code 
iterations system built 
current system consists megabytes applicative source code including documentation 
version system written summer fall boyer moore 
time went boyer involvement decreased kaufmann increased 
eventually boyer decided longer considered coauthor 
acl modeling verification projects computational logic 
cli years 
released public version acl september 
see url www cli com 

acl logic definition common lisp 
closely studied 
acl logic order quantifier free logic total recursive functions providing mathematical induction ordinals ffl extension principles recursive definition encapsulation 
sketch logic 

syntax syntax acl common lisp 
formally acl term variable symbol quoted constant application ary function symbol lambda expression terms written 
illustrate syntax primitive constants 
formal syntax extended facility defining constant symbols macros 

rules inference rules inference nqthm propositional calculus equality instantiation mathematical induction ffl extension principles recursive definition encapsulation provided discussed subsection 

axioms primitive data types primitive data types axiomatized 
ffl acl numbers 
numbers consist rationals complex numbers rational components 
examples numeric constants complex number 
ffl character objects 
acl supports distinct characters including common lisp standard characters character constants newline space 
ffl strings 
acl supports strings characters string constant arithmetic overflow 
ffl symbols 
common lisp provides sophisticated class objects called symbol constants 
logically speaking symbol constant object containing strings package name 
symbol constant package mc name exec written mc exec convention package selected current name need written 
mc current package symbol may simply written exec 
packages may import symbols packages acl importation done time package defined 
mc exec imported string lib package string lib exec fact symbol mc exec 
ffl lists 
acl supports arbitrary ordered pairs acl objects list constant mc hello 


axioms defining primitive function symbols essentially common lisp functions data types axiomatized defined functions macros acl 
common lisp functions mean programs specified applicative ii dependent state implicit parameters data types acl iii completely specified unambiguously host independent manner 
approximately functions axiomatized 
common lisp functions partial defined possible inputs 
acl functions total 
roughly speaking logical function name acl completion common lisp function name obtained adding arbitrary natural values arguments outside intended domain common lisp function 
acl requires acl function symbol guard may thought predicate formals function describing intended domain 
guards entirely extra logical involved axioms defining functions 
discuss role guards explain relation acl common lisp 

axioms additions common lisp applicative common lisp add important new features introducing new function symbols appropriate axioms 
ffl add new multiple valued function call return primitives syntactically restrictive similar common lisp primitives multiple value bind values 
return number values called contexts expecting appropriate number values 
restrictions allow multiple valued functions implemented efficiently common lisp case gnu common lisp 
logically speaking vector multiple values returned function just list values implementation efficient list constructed 
ffl add explicit notion state allow acl programmer accept input cause output 
input output functions common lisp acl applicative dependent implicit notion current state 
acl state tuple containing things file system open input output channels files 
primitive input output functions axiomatized take state explicit parameter return new state explicit result usually results 
syntactic checks language ensure state single threaded function takes state argument calls function returns new state new state precisely final descendant returned 
gives rise defined notion current state supplied top level calls state dependent acl functions 
state returned calls definition current state 
restrictions execution function need construct new state tuples literally modifies underlying common lisp state 
ffl add fast applicative arrays 
implemented scenes common lisp arrays manner returns values accordance axioms operates efficiently provided certain programming disciplines followed single threaded way updated version array 
syntactic enforcement discipline failure follow simply leads inefficient correct execution warning messages 
ffl add fast applicative property lists manner similar arrays 

extension principles acl extension principles definition encapsulation 
preserve consistency extended logic 
standard model numbers lists extended include newly introduced function symbols 
inconsistency caused user adds new axiom directly extension principle 
encapsulation principle allows user introduce new function symbols constrained axioms certain properties 
consistency ensured requiring user exhibit witness functions satisfying constraints 
set function symbols constrained witnesses establish consistency irrelevant 
axioms new functions stating constraints 
theorems proved constrained functions theorems instantiated higher order way derive analogous results functions satisfying constraints 
possible derived rule inference called functional instantiation 
name encapsulation stems way principle implemented 
encapsulation command essentially wrapper admissible sequence definitions theorems 
wrapper allows mark certain definitions theorems local 
local definitions theorems exported wrapper non local ones exported 
local context established encapsulation constrained functions locally defined witnesses constraints non local theorems functions 
outside encapsulation function symbols undefined theorems appear consistent axioms 
implementation encapsulation useful new function symbols introduced allows large proofs structured 
see section 
definitional principle ensures consistency requiring proof defined function terminates 
done nqthm identification ordinal measure formals decreases recursion 
show nqthm ensures set theoretic function satisfies recursive definition proof carries acl case appropriate treatment non uniqueness constrained functions definition 
form acl function definition common lisp defun declare body acl extends common lisp declare permit specification guard expression permit optional specification ordinal measure hints 
additional syntactic restrictions put body 
ensure common lisp version execute efficiently accordance claims 
roughly speaking enforce syntactic notion current state single threaded restricting variable named state ensure multiple values appropriately 
syntactic restrictions met required termination theorems proved axiom 
xn body added new axiom 
observe axiom added independent guard 

relation acl common lisp guards role logic 
crucial relation logic common lisp 
implicit guards common lisp allow great efficiency 
implementations common lisp example gnu common lisp performance compiled code generated arithmetic list processing functions comparable hand coded arithmetic pointer manipulation 
exceptional execution efficiency wide variety platforms combined clear applicative semantics properly great attractions basing acl logic common lisp 
consider example primitive function car 
page says argument car cons nil 
page learn places stated may case error stated requirement met 
page learn error means valid common lisp program cause situation occur situation occurs effects results completely undefined common lisp implementation required detect error 
implementation function car may assume actual cons nil 
suitable representation data implementation car simply fetch contents memory location actual stored 
type checks necessary 
course car applied results unpredictable possibly damaging runtime image usually implementation dependent 
aspects lisp difficult debug compiled lisp code 
raises problems direct embedding applicative common lisp logic 
situation far worse merely knowing value car 
know value object logic car example 
worse know car function form equal car car instance axiom equal evaluate nil common lisps car return second return 
acl solves problem axiomatizing car total function returns nil outside intended domain described guard equal nil 
claim axioms describe common lisp car argument car satisfies guard 
furthermore acl provides general means verifying situation obtains evaluation expression containing car 
reading rest section reader may wish consider possibility approach carried programming languages 
programs commercially available mainstream languages check certain kinds errors believe utilities match capability making arbitrary semantic checks statically describe acl 
analogous approach opportunity integration formal verification mainstream software development practice lessening need dynamic error checking 

gold function symbols terms precise relation acl common lisp define inter related notions function symbol gold term gold hypothesis 
hypothesis implicitly true hypothesis 
roughly speaking function symbol gold guard true guards subroutines encountered evaluation true arguments 
ffl acl logic primitive function symbols gold 
ffl defined function guard body gold function symbol mentioned gold term gold function symbol mentioned gold term gold ffl variables quoted constants gold terms 
ffl term gold gold gold gold 
ffl term guard vn formals gold provided gold referees posing question 
implies theorem 
formula proved called guard conjecture subterm question 
say function term common lisp compliant synonym saying gold 
call process checking function symbol term gold guard checking guard verification 

story relating logic common lisp claim function symbol acl gold gold theorem proved execution function compliant common lisp produces answers consistent theorem provided arguments function satisfy guard resource errors stack overflow occur 
precisely gold acl theorems describe behavior common lisp 
claim precise follows 
claim restrictive setting simplicity 
suppose function symbol argument defined certified book file admissible acl definitions theorems guard gold equal necessarily gold theorem acl proved book 
consider common lisp compliant acl kernel loaded 
load book lisp 
common lisp object object acl 
application lisp returns causes resource error stack overflow memory exhaustion 
essence proof claim observe evaluates logic soundness logic computation step exercise function symbol outside guarded domain gold 
logic common lisp agree inside guarded domain common lisp computation returns 
restrictive alternative formulation thm gold theorem certified book acl instance thm evaluates non nil compliant common lisp acl kernel book loaded 

guards efficiency obvious implication story formal model proved common lisp compliant wishes evaluate gold applications model ignore acl theorem prover altogether load model compliant common lisp containing acl kernel directly execute model obtain results consistent axioms 
example build gold simulator microprocessor high level language provide users stand common lisp engine 
acl theorem prover need 
obvious claim inside acl theorem prover 
course theorem proving uncommon ground subexpressions arise certain instantiations lemmas case splits enumerated domains base cases inductions nqthm acl interpreter evaluating ground expressions 
acl completions common lisp primitives built 
runtime type checks done interpreter determine value axioms car applied constant interpreter determines uses lisp car returns default value nil 
interpreter calls user defined functions require recursive evaluation type checking body repeatedly 
acl evaluates call gold function symbol direct common lisp computation guard evaluates nqthm acl interpreter implemented defining compiling auxiliary common lisp functions runtime type checking 
gold acl functions generally compiled acl typechecking 
interpreter approach gold short circuit enjoy benefits compilation efficiency difference acl avoidance runtime type checking certain subexpressions 
substantial difference industrial sized models 
summary important incremental effect proving acl function symbol gold subsequent applications function efficiently computed 

guards specification device guards may type specifications 
gold functions typed 
guards expressive conventional types arbitrary terms logic 
course acl type checking decidable reason 
related see 
attaches restrictive guards functions proves functions gold obtains assurance functions exercised intended domains 
precisely gains knowledge computed value provably equal function application weakened logical system equality function application body conditional guard true 
nqthm provides assurance mechanism 

example section illustrate points just guards 

admitting definition consider problem concatenating lists 
define function app follows 
defun app declare measure guard true equal nil cons car app cdr ignore declaration moment 
observe function terminates nil recursion 
intention true list cons tree right branch terminates nil 
function applied common lisp result unpredictable nil recur cdr cdr undefined common lisp 
replacing equal nil test atom sensible know cons cdr 
lisp programmers tend test efficient type check equivalent provided true list 
declaration guard true clear intended domain 
logically speaking admit function reason 
logically speaking guard irrelevant 
show measure arguments decreases recursion matter 
suitable measure supplied user declaration defined nil greater length right branch easy show measure decreases recursion cdr 
nil 
intuitively recursion terminates acl cdr completed return nil non recursion hits atom bottom right branch stops atom nil goes step atom produce terminating nil 
function admitted axiom axiom 
app equal nil cons car app cdr added 
note axiom mention guard 
equality test symbol done single address comparison require memory type checks 

theorems prove surprising theorem theorem 
surprising app call equal app cons nil return surprising example 
prove useful powerful unconditional equality stating app associative 
theorem 
associativity app equal app app app app proof takes advantage fact car cdr return nil non cons arguments numbers 
guard app infected definition app limiting applicability true lists app unconditionally associative 
identifying sufficient conditions difficult 
appears argument call app conjecture true list order definition app call 
similarly true list 
app argument call app definition app call system able establish third hypothesis proof hypotheses app true list 
short guard function infects definitional axiom theorems inherit complexity compositionally weakened hypotheses 
weakened theorems raise problems ways ffl harder user state accurately ffl harder prove induction induction hypothesis weakened ffl harder subsequently relieve hypotheses 
points 
decision guards affect definitional axioms far reaching effect 
fact guards play logical role earlier versions acl driven return nqthm paradigm total functions complexity guards introduced industrial strength proof efforts particularly cap project described 

compliance returning app example ask relationship common lisp 
prove app gold common lisp compliant function definition app gold primitive body evaluated guard encountered true guard app true initially 
condition expanded follows 
subroutines body app non trivial guards car cdr recursive call app 
definition gold theorem proved call subroutine body app 
particular call prove guard app tests leading call imply guard call 
prove app gold suffices observe non nil true list cons cdr true list 
extra logical nature guards brought home observation define function say analogous app contains guard guard 
functions provably equivalent 
app common lisp compliant guard conjectures proved 
know app common lisp compliant story tells call app satisfies guard executes accordance axioms acl 
put way wish determine value axioms app constants simply execute expression common lisp provided true list 
user wishing execute formal model concrete data satisfying guard run model common lisp provided model proved compliant 
furthermore guards gold terms suitability data determined common lisp evaluation 

gold theorems theorems gold function app 
surprising result equal app cons nil 
know compliant common lisp evaluate true 
theorem gold 
guard app violated 
inferred common lisp claim 
common lisps may cause severe trouble commanded evaluate app 
associativity result app 
expect app unconditionally associative common lisp 
answer theorem gold 
theorem gold theorem 
gold associativity app implies true true equal app app app app implies thought lazy implies read proper treatment definition gold 
course prove theorem proof trivial unconditional associativity result 
verify gold guard call satisfied arguments call context call 
true hypotheses true guards 
calls app argument variable symbol guards requiring variable question appropriately true 
guard conditions trivial hypotheses 
guard condition app app generates interesting guard condition app true list 

separation concerns note acl treatment guards separates concerns 
theorem proving simplicity nqthm tradition acl functions total completing primitives arbitrary natural default values 
functions introduced logic addressing question compliant common lisp 
properties proved concerning oneself questions guards satisfied 
allows properties simply stated 
allows data base rules restrictive powerful easily applied 
non gold functions evaluated axioms nqthm efficiency 
system acl functions defined logical properties proved move question common lisp compliance gain execution efficiency acl setting stand common lisp gain type assurance 
efficiency gained incrementally doing guard verification core subroutines outlying checkers preprocessors typically involved big system 
furthermore having proved certain functions gold settle corresponding efficiency type assurance prove key properties proved gold 
recall example carry sequence steps ffl admit app function ffl prove unconditionally associative ffl prove gold common lisp compliant welltyped ffl trivially prove restricted version associativity ffl prove restricted version associativity gold common lisp compliant 
versions acl version guards part definitional equations issues intertwined impossible address separately 
little difference setting simple app associativity great deal difference models involving thousands functions properties 

proof engineering argued acl industrial strength 
main argument improved efficiency nqthm virtue executable common lisp special consideration efficient execution operations involving arrays property lists state 
indicated expressive kind type correctness gained guard verification capability separated logic proper proofs needlessly hindered 
consider strengths acl efficiency programming language robustness general features maintainability proof support 

robustness notion industrial strength robustness tool 
put considerable effort making program bullet proof handling user errors graciously appropriate messages 
interface consistent providing ability submit definitions theorems ability execute applicative lisp code efficiently 

usability notion industrial strength tool support features crucial get job done 
partial list features offered acl 
ffl extensible line documentation may read terminal text way hypertext emacs info html ffl support undoing back command undoing undo ffl notion books allows independent development inclusion libraries definitions theorems books share underlying implementation encapsulation forms marked local author book reader book sees non local definitions theorems possibly complex environment necessary certify book need exported reader environment books hierarchical may include books locally reader may include independently developed books create environment authors books install theory invariants help readers manage environments created multiple books authors books document definitions theorems book book inclusion updates online documentation acl consistency checks done books included books carry certificates help community version control ffl program mode allows definition execution functions proof burden imposed risk unsoundness introduced prover know program mode functions ffl realistic collection data types includes strings complex rational numbers support reasoning data fully integrated linear arithmetic decision procedure rationals ffl extensive capabilities controlling prover see ffl common lisp macros ease programming specification cluttering collection functions needs reason ffl useful programming primitives including efficient multiple values arrays property lists file ffl common lisp packages support distinct name spaces ffl mutually recursive definitions supported 
maintainability applicative style programming amenable maintenance fixing bugs implementing enhancements 
subset common lisp acl supports sufficient code lowest levels system needed implement primitives 
believe common lisp program applicative performs fact acl program nearly 

proof support nqthm pc nqthm proofs significant theorems acl tend require serious effort part user prove appropriate supporting lemmas primarily stored conditional rewrite rules 
acl offers ways user control proof engine ffl nqthm proof commentary english assists users debugging failed proofs ffl pc nqthm interactive loop proof discovery extensible macros access full power theorem prover ffl capability apply hints individual subgoals ffl proof tree displays show evolving structure proof real time convenient inspect failed proofs ffl efficient handling propositional logic normally clause generator efficient nqthm facility integrates ordered binary decision diagrams rewriting ffl functional instantiation facility gives acl nqthm convenience higherorder logic sacrificing simplicity order logic ffl break rewrite facility sophisticated nqthm prover far know allows proof time debugging rewrite stack ffl theory mechanism easy manipulate sets rules especially turning checking desired invariants sets rules ffl forcing mechanism gives prover permission defer checking hypotheses specified rules main proof ffl support variety types rules including types supported nqthm 
include conditional rewrite rules may replace equals equals may respect user defined equivalence congruence relations linear arithmetic rules mechanism create rules certain simple orders standard order rationals compound recognizer forward chaining type prescription equivalence congruence built clause rules efficient automatic certain facts improved meta lemma facility allows lemmas conditional hypotheses rules outside simplifier rewriter elimination generalization claim acl industrial strength efficiency consistent robust interface array general features ease maintenance flexibility theorem prover 

industrial applications course ultimately test tool industrial strength jobs interest industry 
important applications acl support claims task 
applications summarized discussed detail detail time manpower resources spent component tasks 

motorola cap digital signal processor bishop brock cli working collaboration motorola produced executable formal acl specification motorola cap digital signal processor designed motorola execute point complex fft microseconds 
defined behavior cap modeled including pipeline interrupts breakpoints traps excluding hard soft reset sequences 
cap complex processors subjected formal modeling fm mc 
principle cap single instruction simultaneously modify registers 
brock acl model cap bit accurate cycle accurate runs faster motorola spw model 
furthermore acl reason cap model 
acl compute symbolic effects complicated instruction just seconds 
acl brock proved suitable conditions model cap equivalent simpler pipeline free model 
important aspect cap acl possible prove correctness cap microcode programs 
complexity instruction set mechanical analysis cap microcode programs way assure programs certain properties 
brock acl verify microcode produced motorola assembler cap application programs including fir filter peak finding algorithm uses adder array chain comparators 
discussed 
approach nqthm mc brock configured acl easy symbolically execute cap microcode program symbolic data 
specified mechanically proved total correctness microcode programs considered 
possible labor intensive cap model acl prove weaker properties microcode errors occur 
believe microcode engine cap specified acl application programs mechanically verified subsequent microcode applications done routinely 
routinely mean technical details symbolic execution particular microcode managed acl effort verification task dominated consideration specification behavior program 
important aspect acl cap model executes cap programs faster motorola spw model 
convenient debugging tool 
reasons speed 
coded somewhat higher level spw model arithmetic model arithmetic common lisp simulated combinational logic 
brock strict guards ensure model type correct registers contain data appropriate size addresses legal objects cap machine states appropriate form functions cap model proved gold 
acl cap model compiled faithfully executed directly common lisp 

amd floating point division test industrial applicability acl collaborated tom lynch advanced micro devices formalize mechanically prove correctness microcode kernel floating point amd microprocessor amd pentium class processor 
particular prove double extended precision floating point numbers mode rounding mode specifying rounding style target format precision result algorithm rounded mode 
explained detail algorithm uses table obtain bit approximation reciprocal iterations efficiently computed variation newton raphson iteration refine approximation relative error gamma approximation compute floating point numbers sum sufficiently close rounded mode result rounding 
algorithm implemented microcode arithmetic computations floating point operations directed rounding 
prove algorithm works specified developed acl floating point folklore 
formalized algorithm acl acl check fairly deep mathematical proof 
necessary step proof show intermediate result fits floating point resources allocated amd 
industrial strength aspects acl proof 
fact acl executable important 
proof applications newton raphson iteration produce sufficiently accurate answer generalizes away particular table amd 
define predicate recognizes table contains sufficiently accurate bit approximations prove newton raphson steps start table correct answer produced 
predicate executable concrete table common lisp determine evaluation satisfies predicate 
apply result actual amd table acl merely executes predicate amd table 
aspects acl crucial proof encapsulation macros books 
encapsulation macros able conveniently configure acl temporarily derive key steps proof having impose proof strategy key step 
books able partition responsibility various parts proof collaborators assemble final results 
subsequent proof floating point division microcode david acl prove correctness amd floating point square root microcode 

acl re implemented extended version boyer moore nqthm kaufmann pc nqthm intended large scale verification projects 
acl logic extension large applicative subset common lisp supporting practical collection data types single threaded states multiple valued functions arrays property lists 
careful design notion guards acl allows elegant expression proof theorems logic type hy time allowing functions logic related common lisp way allows extremely efficient computation 
furthermore design allows clear separation problems admission logical definitions proofs simply stated properties type correctness common lisp compliance efficient execution 
design allows incremental achievement goals proof allowing user focus effort important aspects project 
acl provides features industrial strength goals including rugged extensively documented implementation convenient features constructing models developing structuring proofs maintainability 
demonstrated acl tackle problems importance industry 
acknowledgments bob boyer contributions especially initial stages acl development quite possible acl created 
especially grateful bishop brock providing valuable feedback heavy acl months 
bill young improved contributed tutorial material documentation 
art noah friedman laura contributed technical aspects documentation provided useful feedback 
acknowledge contributions bill alessandro cimatti rich cohen john warren hunt jun sawada bill mike smith 
grateful utility provided gnu emacs particular richard stallman provided patch assist building documentation 
anonymous referees provided valuable suggestions 
extended version acl industrial strength version nqthm appeared proceedings eleventh annual conference computer assurance compass ieee computer society press pp 
june 
reported supported part computational logic advanced research projects agency arpa order contract 
arpa order office naval research contract 

views contained document authors interpreted representing official policies expressed implied computational logic united states government 
akers 
strong static type checking functional common lisp 
ph thesis university texas austin 
available technical report computational logic suite west sixth street austin tx 
url www cli com 

model validation testing cli note august 
basin kaufmann boyer moore prover nuprl experimental comparison 
proceedings workshop logical frameworks antibes france may 
hunt moore young 
special issue system verification 
journal automated reasoning 
young 
machine checked proofs design fault tolerant circuit formal aspects computing vol 
pp 

available technical report computational logic suite west sixth street austin tx august url www cli com nasa cr november 
boyer goldschlag kaufmann moore 
functional instantiation order logic 
artificial intelligence mathematical theory computation papers honor john mccarthy academic press pp 

robert boyer matt kaufmann strother moore 
boyer moore theorem prover interactive enhancement 
computers mathematics applications pp 

boyer moore 
academic press new york 
boyer moore 
computational logic handbook academic press new york 
boyer yu automated correctness proofs machine code programs commercial microprocessor 
kapur editor automated deduction cade lecture notes computer science springer verlag 
brayton somenzi aziz 
cheng edwards pardo qadeer ranjan villa 
vis system verification synthesis 
th intl 
conf 
computer aided verification july 
brock kaufmann moore 
acl theorems commercial microprocessors 
srivas editors computer aided design fmcad springerverlag november appear 

chou mechanical geometry theorem proving reidel publishing dordrecht holland 
clarke zhao 
analytica theorem prover mathematica 
journal mathematica pp 
winter 
constable implementing mathematics nuprl proof development system prentice hall 
cornes courant 
huet coq proof assistant manual version 
rt inria le chesnay cedex france 
craigen meisels 
overview 
odyssey research center ora conference cp march 
crow owre rushby shankar srivas 
tutorial pvs workshop industrial strength formal specification techniques boca raton fl april see www csl sri com pvs html 
harrison 
architecture complex arithmetic processor processing 
spie proceedings international symposium optics imaging instrumentation advanced signal processing algorithms architectures implementations july 
gordon melham editors 
hol theorem proving environment higher order logic 
cambridge university press 
farmer guttman thayer 
imps interactive mathematical proof system 
journal automated reasoning 
hunt jr brock 
formal hdl fm verification 
proceedings royal society 
kaufmann 
user manual interactive enhancement boyer moore theorem prover technical report computational logic may 
url www cli com 
kaufmann 
interaction boyer moore theorem prover tutorial study arithmetic geometric mean theorem 
journal automated reasoning 
kaufmann moore high level correctness acl story draft url ftp ftp cli com pub acl acl sources reports story txt september 
revision preparation 
kunen 
ramsey theorem boyer moore logic journal automated reasoning october 
lamport types harmless www research digital com src tla tla html july 
mccune 
otter manual guide 
report anl argonne national laboratory 
kenneth mcmillan 
symbolic model checking 
kluwer academic publishers 
miller srivas 
formal verification microprocessor case study industrial formal methods proceedings workshop industrial specification techniques ieeecs april pp 

moore lynch kaufmann 
mechanically checked proof correctness kernel amd floating point division algorithm march submitted 
url devil ece utexas edu lynch divide divide html 
moore 
formal model mechanically verifying mark protocol formal aspects computing 
moore 
obdd algorithm atp community journal automated reasoning 
paulson isabelle generic theorem prover springer verlag lncs 
pitman draft proposed american national standard information systems programming language common lisp 
global engineering documents 

mechanical proof quadratic reciprocity 
journal automated reasoning 
mechanically checked proof correctness amd floating point square root microcode www onr com user russ david html february 
shankar 
metamathematics machines odel proof cambridge university press 
steele jr common lisp language digital press bedford ma 
steele jr common lisp language second edition 
digital press north avenue burlington ma 
trybulec 
built concepts 
journal formalized mathematics axiomatics 
young comparing verification systems interactive consistency acl ieee trans 
software engineering issue 
matt kaufmann trained mathematical logician university wisconsin receiving phd mathematics receiving bachelor degree mit 
career led research papers set theoretic model theory primarily mathematics faculty purdue university 
migrated computer science focusing functional programming research position burroughs working years computational logic general purpose automated reasoning applications 
dr kaufmann joined motorola august currently works formal verification hardware 
strother moore received phd degree university edinburgh bs degree institute technology 
holds inman chair university texas austin 
author books papers automated theorem proving mechanical verification computing systems 
book mechanically verified language kluwer 
bob boyer author boyer moore theorem prover boyer moore fast string searching algorithm 
bob boyer awarded current prize automatic theorem proving american mathematical society 
moore fellow american association artificial intelligence 
