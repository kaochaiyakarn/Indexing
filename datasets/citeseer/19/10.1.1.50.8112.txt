automated test data generation iterative relaxation method gupta aditya mathur mary lou soffa dept computer science dept computer science dept computer science purdue university purdue university university pittsburgh west lafayette west lafayette pittsburgh pa cs purdue edu apm cs purdue edu soffa cs pitt edu important problem arises path oriented testing generation test data causes program follow path 
novel program execution approach iterative relaxation method address problem 
method test data generation initiated arbitrarily chosen input domain 
input iteratively refined obtain input branch predicates path evaluate desired outcome 
iteration program statements relevant evaluation branch predicate path executed set linear constraints derived 
constraints solved obtain increments input 
increments added current input obtain input iteration 
relaxation technique deriving constraints provides feedback amount input variable adjusted branches path evaluate desired outcome 
branch conditions path linear functions input variables technique finds solution paths iteration guarantees path infeasible 
contrast existing execution approaches may require unacceptably large number iterations relatively long paths consider input variable branch predicate time backtracking 
branch conditions path nonlinear functions input variables may take iteration derive desired input set constraints solved iteration linear solved gaussian elimination 
technique practical suitable automation 
keywords path testing dynamic test data generation predicate slices input dependency set predicate residuals relaxation methods 
software testing important stage software development 
provides method establish confidence reliability software 
time consuming process accounts cost software development 
program testing criteria generation test data satisfies selected testing criteria difficult problem 
test data testing criteria program generated automatically relieve software testing team tedious difficult task reducing cost software testing significantly 
approaches automated test data generation proposed literature including random syntax program specification symbolic evaluation program execution test data generation 
particular type testing criteria path coverage requires generating test data causes program execution follow path 
generating test data program path difficult task posing complex problems 
symbolic evaluation program execution approaches proposed generating test data path 
general symbolic evaluation statements path requires complex algebraic manipulations difficulty handling arrays pointer 
program execution approaches handle arrays pointer efficiently array indexes pointer addresses known step program execution 
major challenges methods impact infeasible paths 
concept inconsistent constraints methods large number iterations performed search input abandoned infeasible path 
existing program execution methods function minimization search algorithms locate values input variables selected path traversed 
consider branch predicate input variable time backtracking 
branch conditions path linear functions input may require large number iterations long paths 
new program execution approach generate test data path 
novel approach relaxation technique iteratively refining arbitrarily chosen input 
relaxation technique numerical analysis improve approximate solution equation representing roots function 
technique function evaluated approximate solution resulting value provide feedback amount values approximate solution adjusted exact solution equation 
function linear technique derives exact solution equation approximate solution iteration 
nonlinear functions may take iteration derive exact solution approximate solution 
method test data generation path program initiated arbitrarily chosen input domain 
path traversed program executed input input iteratively refined relaxation technique obtain new input results traversal path 
apply relaxation technique test data generation problem view branch condition path function input variables derive representations function 
representation form subset input assignment statements path executed order evaluate function 
representation computed slicing operation data dependency graph program statements path starting predicate consideration 
refer predicate slice 
note predicate slice provides exact representation function computed branch condition 
exact representation form program statements derive linear arithmetic representation function computed branch condition terms input variables 
arithmetic representation function terms input variables necessary enable application numerical analysis techniques program representation function suitable purpose 
function computed branch condition linear function input linear arithmetic representation exact 
function computed branch condition nonlinear function input linear arithmetic representation approximates function neighborhood current input 
representations refine arbitrarily chosen input obtain desired input follows 
assume executing predicate slice arbitrarily chosen input determine branch condition evaluate desired outcome 
case evaluation branch condition provides value called predicate residual amount function value change order achieve desired branch outcome 
linear arithmetic representation predicate residual derive linear constraint increments current input 
constraint derived branch condition path 
linear constraints solved simultaneously gaussian elimination compute increments current input 
new input obtained adding increments current input 
constraints corresponding branch conditions path solved simultaneously method attempts change current input branch predicates path evaluate desired outcomes predicate slices executed new input 
branch conditions path linear functions input linear arithmetic representations predicate functions exact method derives desired input iteration guarantees path infeasible 
result immense practical importance accordance studies reported 
case study test case constraints generated group fortran programs shown constraints linear 
large class paths method able detect infeasibility problem detecting infeasible paths unsolvable general 
path feasible method extremely efficient finds solution exactly iteration 
branch condition path nonlinear function input increments current input computed solving linear constraints increments may immediately yield desired input 
set linear constraints increments derived linear arithmetic representations case approximate corresponding branch conditions 
may take iteration obtain desired input 
branch predicates path nonlinear functions input set equations solved obtain new input current input linear solved gaussian elimination 
gauss elimination algorithm widely implemented established method solving system linear equations 
technique practical suitable automation 
important contributions novel method ffl innovative traditional relaxation technique test data generation 
ffl conditionals path linear functions input generates test data iteration guarantees path infeasible 
efficient finding solution powerful detecting infeasibility large class paths 
ffl general technique generate test data conditionals path nonlinear functions input 
case number iterations inconsistent constraints indication potential infeasible path 
ffl set constraints solved method linear path may involve conditionals non linear functions input 
set linear constraints automatically solved gaussian elimination direct method exits solve set arbitrary nonlinear constraints 
gaussian elimination widely implemented experimented algorithm 
method practical suitable automation 
ffl scalable large programs 
number program executions required iteration independent path length bounded number input variables 
size system linear equations solved gaussian elimination increases number branch predicates path increase cost significantly existing techniques 
organization follows 
overview method section 
algorithm test data generation described section 
illustrated examples involving linear nonlinear paths loops arrays 
related discussed section 
important features method summarized outlined section 
overview define program module directed graph set nodes set edges unique entry node unique exit node node represents single statement conditional expression possible transfer control node node mapped edge path fn nk sequence nodes variable input variable module appears input statement input parameter domain dk input variable set possible values hold 
input vector thetad theta number inputs called program input 
may refer program input input terms interchangeably 
conditional expression multi way decision statement called branch predicate 
loss generality assume branch predicates simple relational expressions inequalities equalities form op arithmetic expressions op branch predicate contains boolean variables represent true value boolean variable numeric value zero greater false value negative numeric value 
branch predicate path conjunction boolean variables predicate considered multiple branch predicates simultaneously satisfied traversal path 
branch predicate path disjunction boolean variables time branch predicates considered branch predicates path 
solution branch predicate tried 
branch predicate op transformed equivalent branch predicate form op arithmetic expression gamma path represents real valued function called predicate function 
may direct indirect function input variables 
illustrate consider branch predicate bp conditional statement example program 
predicate function corresponding branch predicate bp gamma path predicate function gamma indirectly represents function gamma gamma input variables state problem addressed problem statement program path traversed certain evaluations true false branch predicates bp bp delta delta delta bpn generate program input theta theta dm causes branch predicates evaluate traversed 
new method generating program input path program traversed program executed input 
method test data generation initiated arbitrarily chosen input domain 
path traversed input set linear constraints increments input derived relaxation method 
increments obtained solving constraints added input obtain new input 
path traversed new input method terminates 
steps refining input carried iteratively obtain desired input 
briefly review relaxation technique numerical analysis refining approximation solution linear equation 
relaxation technique approximation solution linear equation ax general substituting lhs equation result non zero value called residual ax increments deltax deltay computed satisfy linear constraint deltax deltay gammar deltax deltay deltax deltay solution equation 
order formulate test data generation problem relaxation technique problem view predicate function corresponding branch predicate path function program input 
apply relaxation technique linear arithmetic representation terms relevant input variables required predicate function 
derive exact program representation called predicate slice function computed predicate function derive linear arithmetic representation 
representations innovative way refine program input 
predicate slice exact program representation predicate function predicate slice defined follows definition predicate slice bp branch predicate bp path set statements compute values value bp may directly indirectly data dependent execution follows path words bp slice data dependencies branch predicate bp program consisting read endif write linear elseif write nonlinear quadratic endif write elseif sin write nonlinear sine endif read statements predicate slice bp read statements predicate slice bp read statements predicate slice bp example program predicate slices path input assignment statements preceding bp path illustrate definition example program 
consider path bp denote th branch predicate path predicate slices corresponding branch predicates bp bp bp path bp bp bp 
illustrated examples predicate slices include input assignment statements 
value predicate function input computed executing corresponding predicate slice input 
note predicate slice conventional static slice computed statements path 
dynamic slice computed statically input assignment statements path precise dynamic slice 
illustrate consider code segment input code segment path array 
evaluation bp data dependent assignment statement 
evaluation bp data dependent assignment statement 
predicate slice branch predicate bp consist input statement assignment statement 
words predicate slice path oriented static slice 
concept predicate slice enables evaluate outcome branch predicate path irrespective outcome branch predicates 
predicate slices branch predicates path executed arbitrary input path may traversed input 
possible conditionals predicate slice 
execution predicate slice input value corresponding predicate function computed branch outcome evaluated 
correspondence outcomes execution predicate slices input traversal path input 
branch predicates path evaluate desired outcomes executing respective predicate slices input computing respective predicate functions path traversed program executed input 
branch predicates path evaluate desired outcome predicate slice executed input path traversed program executed input 
conceptually predicate slice enables view predicate function path independent function input variables 
method simultaneously force branch predicates path evaluate desired outcomes 
contrast existing program execution methods test data generation attempt satisfy branch predicate time backtracking fix predicate satisfied earlier trying satisfy predicate appears path 
consider branch predicates path simultaneously path may traversed intermediate input 
predicate slice useful identifying relevant subset input variables value predicate function depends 
subset input variables required linear arithmetic representation predicate function terms input variables derived 
subset input variables value computed predicate function depends determined dynamically illustrated example 
input branch predicate path corresponding predicate slice executed input dynamic data dependence graph execution constructed 
relevant input variables corresponding predicate function determined dynamic slice dependence graph 
note scalars referenced predicate slice corresponding predicate function subset input variables predicate function depends determined statically predicate slice 
execution predicate slice input data followed dynamic slice determine relevant input variables necessary handle arrays 
define subset input variables input dependency set 
definition input dependency set id bp branch predicate bp input path subset input variables bp directly indirectly data dependent 
input variables identified executing statements predicate slice bp input dynamic slice dynamic data dependence graph 
example executing bp input note evaluation bp depends input variables id bp fx zg 
explain input dependency set derive linear arithmetic representation terms input variables predicate function input 
deriving linear arithmetic representation predicate function predicate function input dependency set id input write general linear function input variables id compute values coefficients general linear function represents tangent plane predicate function gives linear arithmetic representation predicate function example predicate function gamma id fx zg input 
general linear function inputs id ax cz slopes respect input variables respectively constant term 
slopes computed evaluating corresponding derivatives predicate function input constant term computed linear function evaluates value computed executing corresponding predicate slice evaluating predicate function represents tangent plane predicate function input gives linear arithmetic representation predicate function predicate function computes linear function input tangent plane exact representation predicate function 
predicate function computes nonlinear function input tangent plane approximate predicate function neighborhood input illustrate deriving linear arithmetic representation predicate function input 
approximate derivatives predicate function divided differences 
compute execute bp deltax chosen deltax unit increment input variable compute divided difference deltax gamma deltax gamma gives value compute value executing predicate slice bp deltay computing divided difference points respect gives equal gamma 
similarly get equal 
compute value solving equation substituting values equation solving get equal gamma 
obtain linear arithmetic representation gamma gamma example computes linear function input 
linear arithmetic representation computed exact representation function inputs computed 
input variables influence predicate function appear representation 
approximated derivatives predicate function divided differences 
tools developed compute derivative program respect input variable 
tools get exact derivative values divided differences 
technique deriving linear arithmetic representation predicate function accurately implemented automated testing 
method explained derive linear arithmetic representation current input predicate function path 
order derive set linear constraints increments current input linear arithmetic representations execute predicate slices branch predicates current input compute values corresponding predicate functions 
values predicate functions provide feedback computing desired increments current input 
predicate residuals values predicate functions input defined predicate residuals essentially place constraints changes values input variables satisfied provide new input desired path followed 
definition predicate residual branch predicate input value corresponding predicate function computed executing predicate slice input 
branch predicate relational operator non zero predicate residual gives exact amount value predicate function change modifying input branch evaluates desired outcome 
predicate residual gives maximum value predicate function value changed allowed change modifying program input branch predicate evaluates continues evaluate desired outcome 
explain examples 
branch predicate evaluates desired outcome input continue evaluate desired outcome 
case predicate residual gives maximum value predicate function value allowed change modifying program input branch predicate continues evaluate desired outcome 
illustrate consider path example program 
input branch predicate bp evaluates desired branch path traversed 
value predicate function predicate residual input 
value predicate function allowed decrease due change program input predicate function continues evaluate evaluate positive value 
hand predicate evaluate desired outcome predicate residual gives value predicate function value changed modifying program input branch predicate evaluates desired outcome 
example input branch predicate bp evaluate desired branch path traversed 
value predicate function predicate residual gamma 
input modified value predicate function increases branch predicate bp evaluate desired outcome 
predicate residuals essentially guide search program input cause branch predicate path evaluate desired outcome 
compute predicate residual current input branch predicate path 
predicate residual linear arithmetic representation current input predicate function apply relaxation technique refine input 
refining input linear arithmetic representation predicate residual predicate function input essentially allow map change value predicate function changes program input 
predicate function path derive linear constraint increments program input linear representation predicate function value corresponding predicate residual 
set linear constraints solved simultaneously gaussian elimination compute increments input 
increments added input obtain new input 
illustrate derivation linear constraint corresponding predicate function 
branch predicate bp evaluates false bp executed arbitrarily chosen input evaluate true path traversed 
residual value gamma linear function gamma gamma derive linear constraint deltax gamma deltay deltaz note constant term appear constraint 
intuitively means increments input value predicate function changes force evaluate positive value force corresponding branch predicate bp evaluate desired outcome true new input 
instance deltax deltay deltaz solutions constraint 
see bp evaluates true bp executed 
linear constraint derived predicate residual compute increments current input important step method 
constraint value predicate function current input provides feedback increments computed derive new input 
method computes new program input previous input residuals relaxation method iteratively refines program input obtain desired solution 
point relational operator branch predicate path method reduces newton method iterative refinement approximation root system nonlinear functions variables 
illustrate consider linear constraint equation 
assume relational operator corresponding branch predicate bp simplicity function single variable linear constraint equation reduces deltax form xn xn gamma xn xn general branch predicates path equalities inequalities 
case method different newton method computing root system nonlinear functions variables 
increments input computed stepping tangent plane function current input expect method convergence properties similar newton method 
discussion far assumed conditionals source predicate functions 
practice additional predicates considered test data generation 
constraints inputs may exist may require additional predicates input variable required positive value predicate introduced 
second introduce predicates constrain input variables values avoid execution errors array bound checks division zero 
considering predicates predicates conditionals path desired input 
simplicity examples considered consider predicates conditionals 
description algorithm section algorithm generate test data programs numeric input arrays assignments conditionals loops 
technique extended input characters strings providing mappings numeric values 
main steps algorithm outlined 
describe steps algorithm detail time illustrate step algorithm generating test data path predicate functions linear functions input 
examples nonlinear predicate functions section 
method begins path arbitrarily chosen input input domain program 
program executed traversed desired program input algorithm terminates steps iterative refinement relaxation technique executed 
illustrate algorithm example section path program initial program input considered 
path traversed program executed iterative relaxation method discussed employed refine input 
step 
computation predicate slices 
node represents branch predicate compute predicate slice backward pass static data dependency graph input assignment statements path predicate slices branch predicates path bp bp bp step 
identifying input dependency sets 
node represents branch predicate identify input dependency set id ik input variables data dependent executing predicate slice current input ik dynamic slice dynamic data dependence graph 
input dependency sets branch predicates path computed executing respective predicate slices input id bp fx id bp fx zg id bp fx note input assignment statements path need executed compute input dependency sets branch predicates path step 
derivation linear arithmetic representations predicate functions 
step construct linear arithmetic representation predicate function corresponding branch predicate branch predicate formulate general linear function input variables set id ik 
example linear formulations predicate functions corresponding branch predicates path coefficients input variables linear functions represent slopes th predicate function respect input variables respectively 
approximate slopes respective divided differences 
compute slope coefficient respect variable execute predicate slice evaluate predicate function current input ik ik deltai compute divided difference ik deltai gamma ik deltai gives value coefficient linear function predicate function corresponding node similarly compute slope coefficients linear function 
example considered evaluating executing bp computing divided difference respect get 
similarly get computing divided differences respect get gamma gamma gamma computing divided difference respect get 
compute constant term execute corresponding predicate slice ik evaluate value predicate function 
values input variables ik slope coefficients substituted linear function equated value predicate function ik computed 
gives linear equation unknown solved value constant term 
example considered substitute slope coefficients computed general linear formulations predicate functions 
equate general linear formulations respective values obtain equations gamma gamma gamma gamma gamma gamma solving constant terms get gamma 
linear arithmetic representations predicate functions gamma gamma gamma gamma predicate function linear function input variables slopes computed exact method results exact representation predicate function 
input path fn initial program input output program input traversed procedure traversed return step branch predicate compute predicate slice endfor done branch predicate step execute input ik compute input dependency set id ik 
step compute linear representation id ik predicate function step compute predicate residual ik step construct linear constraint ik id ik computation increment ik endfor step convert inequalities constraint set equalities step solve system equations compute increments current program input 
compute new program input ik adding computed increments ik execution program input ik follows path ik done true endif endwhile algorithm generate test data iterative relaxation method 
predicate function computes nonlinear function linear function computed represents tangent plane predicate function ik neighborhood ik inequality derived tangent plane closely approximates branch predicate 
predicate function evaluates positive value program input neighborhood ik linear function vice versa 
linear representations predicate residuals computed subsequent step derive set linear constraints refine ik obtain ik step computation predicate residuals 
execute predicate slice corresponding branch predicate current program input ik evaluate value predicate function 
value predicate function predicate residual value ik current program input ik branch predicate predicate residuals branch predicates bp gamma bp gamma bp gamma 
step construction system linear constraints solved obtain increments current input 
step construct linear constraints computing increments deltai current input ik linear representations computed step predicate residual values computed step 
convert linear arithmetic representations predicate functions set inequalities equalities 
branch predicate evaluate true path traversed corresponding predicate function converted inequality equality relational operator branch predicate 
hand branch predicate evaluate false path corresponding predicate function converted inequality reversal relational operator branch predicate 
branch predicate relational operator evaluate false path traversed convert inequalities relational operator relational operator 
corresponding predicate function evaluates positive value ik consider inequality operator consider operator 
discussion holds branch predicate relational operator evaluate true path traversed 
set inequalities equalities gives linear representations branch predicates evaluate path traversed 
converting linear arithmetic representations predicate functions path inequalities get gamma gamma gamma gamma linear arithmetic representations ik branch predicates evaluate traversal path predicate residuals computed ik apply relaxation technique described previous section derive set linear constraints increments input 
applying relaxation technique linear arithmetic representations computed predicate residuals computed previous step set linear constraints increments derived deltax gamma deltay deltax gamma deltay deltaz deltax gamma deltay note constant terms linear arithmetic representations appear constraints 
step conversion inequalities equalities 
general set linear constraints increments derived previous step may mix inequalities equalities 
automating method computing solution set inequalities convert system equalities solve gaussian elimination 
convert inequalities equalities addition new variables 
simultaneous solution system equations gives increments ik obtain program input ik converting inequalities equalities constraint set example considered introducing new variables get deltax gamma deltay gamma deltax gamma deltay deltaz gamma deltax gamma deltay gamma require 
step solution system linear equations 
simultaneously solve system linear equations obtained previous step gaussian elimination 
number branch predicates path equal number unknowns input variables new variables consistent nonsingular system equations straightforward application gaussian elimination gives solution system equations 
number branch predicates path number unknowns system equations overdetermined may may exist solution depending system equations consistent 
system equations consistent solution applying gaussian elimination subsystem number constraints equal number variables verifying solution satisfies remaining constraints 
system equations consistent possible path infeasible 
case consistent subsystem set linear constraints solved gaussian elimination program input iteration 
repeated occurrence inconsistent systems equations subsequent iterations strengthens possibility path infeasible 
testing tool may choose terminate algorithm certain number occurrences inconsistent systems path infeasible 
number branch predicates path number unknowns system equations underdetermined infinite number solutions system consistent 
case branch predicates select unknowns formulate system equations expressed unknowns 
unknowns free variables 
unknowns selected resulting system equations set linearly independent equations 
system equations unknowns solved terms free variables gaussian elimination 
values free variables chosen values dependent variables computed 
solution obtained step gives values current program input ik incremented obtain approximation ik program input 
execute predicate slices evaluate predicate functions new program input ik branch predicates evaluate desired branches ik solution test data generation problem 
algorithm goes back step ik current program input th iteration 
explained previous section input dependency sets linear representations depend current input data 
computed iteration ik example considered linear constraints unknowns 
underdetermined system equations considered system equations unknowns unknowns free variables 
considered system equations variables deltax deltay deltaz gaussian elimination coefficient matrix find third equation dependent equation third row reduces row zeros resulting singular matrix 
consider system equations deltax deltaz gamma deltax deltaz deltay deltay deltay values free variables chosen arbitrarily 
choosing free variables deltay equal solving deltax deltaz get deltax deltaz 
adding increments get executing predicate slices path input evaluating corresponding predicate functions see branch predicates evaluate desired branch leading traversal algorithm terminates successfully iteration 
method new approximation program input obtained previous approximation residuals 
falls class relaxation methods 
relaxation technique iteratively obtain new program input branch predicates evaluate desired outcomes executing corresponding predicate slices 
method terminate time possible time allotted test data generation insufficient accumulation round errors gauss elimination method due finite precision arithmetic 
gaussian elimination established method solving system linear equations 
implementations pivoting strategies available avoid accumulation round errors due finite precision arithmetic 
possibilities reason method terminating time path infeasible 
clear construction linear representations step function input computed predicate function linear corresponding linear arithmetic representation constructed method exact representation function computed predicate function 
prove case desired program input obtained iteration 
theorem functions input computed predicate functions path linear desired program input traversal path obtained iteration path guaranteed infeasible 
proof assume input variables program containing path branch predicates bp bp bpn path relational operator 
linear representations predicate functions corresponding branch predicates computed method described step algorithm 
note representations exact functions input computed predicate functions linear 
write branch predicates path terms representations follows mxm mxm mxm bn bn bn xm bn mxm cn cn cn mxm cn eq 
set note coefficients corresponding input variables input dependency set predicate function zero 
xm approximation solution set equations 
xm xm xm bn bn bn xm bn mxm cn cn cn mxm cn eq 
set 
residual value obtained executing corresponding predicate slice evaluating corresponding predicate function 
solution eq 
set 
executing program result traversal path goal compute solution 
substituting eq 
set get bn bn bn bn cn cn cn cn eq 
set subtracting eq 
set eq 
set get deltax deltax deltax gammar deltax deltax deltax gammar deltax deltax deltax gammar bn deltax bn deltax bn deltax gammar deltax deltax deltax gammar cn deltax cn deltax cn deltax gammar deltax gamma precisely set constraints increments input satisfied obtain desired input 
increment deltax computed set constraints deltax gives desired solution illustrated requires iteration 
set constraints step method test data generation 
arbitrarily chosen input program domain method derives desired input iteration 
solving constraints set inconsistent path infeasible 
method derives desired solution iteration guarantees path infeasible 
paths nonlinear predicate slices 
function input computed predicate function nonlinear predicate function locally approximated tangent plane neighborhood current input ik residual value computed ik provides feedback tangent plane ik computation increments ik tangent plane exact representation predicate function predicate function evaluate desired outcome iteration 
slope correspondence tangent plane predicate function local current iteration point ik may take iteration compute program input execution predicate slice results evaluation branch predicate desired branch outcome 
consider path predicate function computing second degree function input example program initial program input path traversed input iteratively refined 
predicate slices input dependency sets branch predicates bp bp bp example path linear predicate slices 
bp bp id bp fx zg linear representations predicate functions example previous section 
gamma slope respect computed evaluating divided difference 
linear function represents tangent plane nonlinear function computed predicate function corresponding branch predicate bp 
converting functions inequality relational operator branch predicate evaluate get gamma gamma gamma gamma gamma note relational operator representation bp different example previous section different branch taken 
predicate residuals predicate slices bp gamma bp gamma bp gamma bp gamma 
set linear constraints computing increment results steps deltax gamma deltay deltax gamma deltay deltaz deltax deltaz deltax gamma deltay inequalities constraint set converted equalities introducing new variables 
resulting system equations deltax deltay deltaz solved gaussian elimination 
gamma gamma gamma gamma deltax deltay deltaz gamma free variables arbitrarily chosen equal system solved deltax deltay deltaz solution system deltax gamma deltay gamma deltaz 
increments added obtain new input deltax deltay deltaz gamma gamma executing predicate slices program input find branch predicates evaluate desired branches resulting traversal algorithm terminates successfully iteration 
summarize results table 
iteration bp bp bp bp example illustrates tangent plane current input linear approximation predicate function neighborhood current input 
consider path predicate function computing sine function input 
consider path program initial program input 
path traversed bp evaluates undesired branch steps iterative refinement executed 
summarize results execution test data generation algorithm example table 
iter 
bp bp bp bp path traversed branch predicates bp bp evaluate false branch predicates bp bp evaluate true 
shown table iterations algorithm bp bp bp continue evaluate desired outcomes values inputs incremented moves closer zero iteration 
iteration positive program input bp true 
point linear arithmetic representation branch predicate exact branch predicate evaluates desired outcome iteration continues subsequent iterations 
linear arithmetic representation approximates branch predicate neighborhood current input case bp tangent plane iteration refined input evaluates desired outcome respect tangent plane may take iterative refinements input corresponding branch predicate evaluate desired outcome 
example bp evaluated true desired outcome evaluated false predicate residual provides feedback linear arithmetic representation tangent plane sine function bp input modified stepping linear arithmetic representation 
result linear representation evaluates positive value change program input falls short making predicate function evaluate positive value subsequent iterations input gets refined fourth iteration predicate function evaluates positive value 
illustrated example iteration branch predicates computing linear functions input continue evaluate desired outcomes input refined satisfy branch predicates computing nonlinear functions input 
regression testing branch predicate statement path may changed 
generate test data modified path traversed input branch predicates evaluate desired outcomes initial input refined method 
regression testing existing test data initial input refine generate new test data 
arrays loops arrays input procedure problems faced test data generation method size input arrays 
test data generation method considers array elements referenced predicate slices branch predicates path executed corresponding predicate functions evaluated 
input dependency set input identifies input variables relevant predicate function 
test data generation algorithm uses refines array elements relevant 
test data generation independent size input arrays 
illustrate method handles arrays loops generating test data program 
take path initial input compare performance program execution test data generation methods 
denotes th execution predicate initial program input low high step 
path traversed steps iterative refinement executed 
denote low high step respectively predicate slices input dependency sets branch predicates bp id bp fl hg bp id bp fx yg bp id bp fx yg bp id bp fl hg bp id bp fx zg bp id bp fx zg bp id bp fl hg linear representations predicate functions corresponding branch predicates gamma gamma gamma gamma gamma gamma gamma predicate residuals predicate functions branch predicates bp gamma bp gamma bp gamma bp gamma bp gamma bp gamma bp gamma set linear constraints computing increment results steps deltal deltas gamma deltah deltax gamma deltay deltax gamma deltay deltal deltas gamma deltah deltax gamma deltaz deltax gamma deltaz deltal deltas gamma deltah inequalities converted equalities introducing new variables 
considering system equations expressed unknowns deltal deltas deltax deltay get gamma gamma gamma gamma deltal deltas deltax deltay deltah gamma gamma deltah deltaz deltaz deltah unknowns free variables selected obtain nonsingular system equations 
values free variables chosen arbitrarily constraints 
values free variables deltaz deltah chosen 
value free variable integer arithmetic 
solving unknown variables gaussian elimination get deltay deltax deltas gamma deltal deltaz deltah new input generated iteration deltax deltay deltaz input values copied respectively increments computed iteration added giving low high step step important increments computed current iteration added input current iteration resulting values copied array elements iteration 
elements relevant iteration 
executing predicate slices program input evaluating corresponding predicate functions see branch predicates evaluate desired branch outcomes resulting traversal predicate functions corresponding branch predicates compute linear functions input 
expected algorithm terminates successfully iteration 
summarize results example table 
korel obtains test data path program executions method finds solution iteration program executions 
program execution test path traversed additional program executions required computation slope computations linear representations program execution required test path traversed choose path set linear constraints obtained step inconsistent 
predicate functions path compute linear functions input theorem conclude path infeasible 
easy check infeasible path 
var array integer low high step integer min max integer input low high step min low max low low step high max max min min step endwhile output min max iteration low high step iteration bp bp bp bp bp bp bp example array loop 
related popular approach automated test data generation path oriented methods symbolic evaluation actual program execution 
earliest systems automatically generate test data symbolic evaluation linear path constraints described 
detect infeasible paths linear path constraints limited ability handle array depend program input 
attempt symbolic evaluation test data generation fault criteria described 
test data generation system collection heuristics solving system constraints developed 
constraints derived imprecise resulting approximate solution path may traversed 
test data refined eventually obtain desired input method fails path traversed approximate solution 
program execution approach requires partial solution test data generation problem computed hand values integer input variables described 
indication automate step requiring computation hand 
program execution approaches automated test data generation described developed statement branch testing criteria 
approach automatically generate test data path actual execution program 
program execution approach uses program instrumentation test data generation path reported 
approaches consider branch predicate input variable time backtracking 
may require large number iterations branch conditionals path linear functions input 
conditionals selected path depend common input variables lot effort wasted backtracking 
consider branch predicates path simultaneously path may traversed intermediate input 
concept predicate slice allows evaluate branch predicate path independently intermediate input path may traversed input 
technique efficient execution methods 
method scalable large programs number program executions iteration independent path length equal number input variables plus 
input variables iteration executions input assignment statements path required compute slope coefficients 
values predicate functions input ik known previous iteration 
execution input assignment statements path required test path traversed ik method uses gaussian elimination solve system linear equations established widely implemented technique solve system linear equations 
method suitable automation 
size system linear equations solved increases increase number branch conditionals path increase cost solving larger system significantly existing execution methods 
new program execution method established mathematical techniques automatically generate test data path 
method innovative application traditional relaxation technique numerical analysis obtain exact solution equation iterative improvement approximate solution 
results obtained method test data generation promising 
provides practical solution automated test data generation problem 
easy implement tools required available 
efficient existing program execution approaches requires fewer program executions branch predicates path considered simultaneously backtracking 
detect infeasibility large class paths single iteration 
execution handle different programming language features 
working extending technique strings pointers 
bauer finger test plan generation formal grammars proc 
th int 
conf 
software engineering pp 

bird munoz automatic generation random self checking test cases ibm syst 
vol 
pp 

bischof adic extensible automatic differentiation tool ansi appear software practice experience 
clarke system generate test data symbolically execute programs ieee transactions software engineering vol 
se pages september 
brown chang cross rule software test data generator ieee trans 
knowledge data eng vol 
pp jan 
demillo offutt constraint automatic test data generation ieee transactions software engineering vol 
pages september 
gallagher test data generation suite ada software systems ieee transactions software engineering vol 
pages august 
botella automatic test data generation constraint solving techniques international symposium software testing analysis 
roy atlas automated software testing system nd international conference software engineering 
korel automated software test data generation ieee transactions software engineering vol 
pages august 
korel dynamic approach test data generation 
conference software maintenance pages san diego ca november 
lyons automatic data generation system data base simulation testing data base vol 
pp 

miller jr melton automatic generation testcase datasets sigplan notices vol 
pages june 
miller automatic generation floating point test data ieee transactions software engineering vol 
se pages september 
numerical analysis outline series mcgraw hill book 
