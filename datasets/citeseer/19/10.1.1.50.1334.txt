understanding extending graphplan kambhampati eric parker eric lambrecht department computer science engineering arizona state university tempe az eas asu edu html rao asu edu provide reconstruction blum furst graphplan algorithm reconstruction extend improve original algorithm ways 
reconstruction process growing planning graph inferring mutex relations corr doing forward state space refinement disjunctively represented plans 
backward search phase graphplan corresponds solving binary dynamic constraint satisfaction problem 
reconstruction sheds light sources strength graphplan 
reconstruction explain graphplan goaldirected extended handle actions conditional effects backward state space refinement generalized apply disjunctive plans 
discuss backward search phase graphplan improved applying techniques csp literature apart planning scheduling resource allocation phases graphplan 
blum furst graphplan algorithm emerged fastest planner solving classical planning problems 
despite impact currently exists little critical analysis algorithm sources strength relation trad planning algorithms 
show significant surface differences notwithstanding graphplan algorithm best understood terms forward state space refinement disjunctive partial plans correspond unioned representation forward state space search tree 
normally direct refinement disjunctive plans called planning graphs graphplan parlance tends result reduced pruning power 
counter graphplan infers propagates information disjuncts hold solution called mutex relations graphplan parlance 
mutex inference process seen generalization standard refinement strategies presence disjunctive plans helps graphplan producing planning graph close upper bound approximation forward state space search tree 
solution extraction involves searching sequence actions part disjunctive plan solves planning problem 
done backward search planning graph structure 
search problem corresponds closely binary dynamic constraint satisfaction problem mittal falkenhainer 
reinterpretation graphplan summarized explains role properties interference relations mutex relations action parallelism algorithm clarifies relative impact performance 
reconstruction helps place graphplan pantheon refinement planners 
connection graphplan forward state space refinement suggests improving graphplan making goal directed extending handle expressive actions 
connec research supported part nsf nyi award iri initiative arpa daah 
avrim blum dan weld helpful discussions graphplan mark peot david smith making lisp implementation graphplan available 
tion backward search planning graph dynamic constraint sa problem suggests improvements backward search exploiting techniques constraint satisfaction tsang 
rest presents reconstruction graphplan algorithm elaborates insights affords extensions suggests 
organized follows section reconstruct graphplan algorithm starting generalized forward state space search 
section discuss insights offered reconstruction 
section presents variety ways improving efficiency coverage graphplan algorithm including making graphplan goal directed means ends analysis supporting propagation mutex information backward direction empowering graphplan handle expressive action representations improving graphplan backward search phase help csp techniques apart planning scheduling graphplan 
section summarizes contributions 
reconstructing graphplan forward state space search generalized forward state space search start reconstruction graphplan simple example domain containing operators op action preconditions effects shown top 
consider process forward state space search starting initial state 
recall involves applying applicable action initial state compute new states applying operators resultant states iteratively 
portion search tree resulting process shown bottom left solid lines 
path tree corresponds partial plan 
planning ends states search tree contains goals 
path state output plan 
process normally leads sequential totally ordered plans easily extend idea allow special form parallelism solutions 
done projecting sets actions independent don delete preconditions added effects drummond search tree bottom left portion tree produced allowing projection independent action sets shown dashed lines 
example independent preconditions satisfied initial state apply action set state get state second level apply get third level 
goal terminate third level solution plan said time steps long time step containing actions 
semantics pa time step execute concurrently second step execute easy see long allow projection independent action sets complete search strategy breadth guaranteed find shortest plan terms number time steps 
project single actions time appears state fourth level 
words allowing projection independent action sets reduces solution depth increasing branching redundancy search tree 
total number actions solution remain 
different kind partial order plan space plans 
particular branch projection tree positioning operators respect time steps strictly fixed positioning gives state information level 
possible reduce redundancy search tree pre processing domain partition actions maximal sets non interfering actions doing search projecting action sets individual actions 
actions action set may simultaneously applicable state projection involve stripping action set unioned naive graphplan op op op op op op nop 
interpreting graphplan disjunctive forward state space refinement planner 
left portion search tree generated forward state space search 
portion dashed lines show branches produced allowing parallel ction independent actions 
right different disjunctive representations tree 
planning graph compact representation search tree big problem forward state space search shares planning algorithms search projection tree grow exponentially large small problems 
way getting handle forward branching consider states level separate nodes search tree 
particular seeing states sets propositions try union sets get collection propositions states level 
unions roughly see equivalent graphplan calls proposition lists 
shall call resulting structure unioned planning graph 
unioned planning graph example shown top right 
proposition lists various levels shown ovals 
proposition list actions 
actions action set may relevant final goal sequence action sets returned termination post processed eliminate irrelevant actions 
done polynomial time help causal structure solution plan 
level union just initial state 
second level third level 
relate proposition lists successive levels terms actions taken levels 
specifically unioned planning graph contains consecutive proposition lists actions taken levels corresponding state space projection tree shown 
actions planning graph connected elements preceding proposition list comprise preconditions elements proposition list comprise effects 
actions connected propositions change persistence propositions action execution explicit planning graph 
explicit set op actions persistence propositions introduced 
unioned planning graph correspond direct connections propositions consecutive levels 
loosely speaking unioned proposition list level planning graph seen compact disjunctive representation states assuming branching factor th level corresponding state space search tree 
unioned planning graph provide compact representation growth forward state space search 
representation basis efficient planning algorithm need decide planning graph structure grown solutions extracted 
growing searching planning graphs unioned planning graph grown generating converting state space search tree clearly inefficient overhead classical state space planning 
reduce cost significantly willing get planning graph structure upper bound approximation unioned planning graph 
specifically simple way growing planning graph add actions including ops preconditions subsets current proposition list construct proposition list level union effects actions 
shall call resultant structure naive planning graph 
naive planning graph example problem shown 
note second level naive planning graph state space search tree absent unioned planning graph making naive planning graph upper bound approximation unioned planning graph 
contrast exponential cost generating state space search tree naive planning graph polynomial sized structure generated polynomial time main savings generation cost comes planning graph contains instance action level possibly exponential number corresponding level state space search tree 
solution extraction need prove sequence legal states culminating state goals satisfied 
done essentially dependency links actions proposition list elements 
example see successful plan goals planning graph shown check actions supporting level 
supported supported op 
need support goal consider support turn 
suppose pick leaving op backtrack choice ensure preconditions actions satisfied previous proposition list 
leads recursive goal set previous level 
point single supports goals op actions occur simpler way introduce actions levels 
idea kautz selman linear encodings 
deleted think interfering op 
point backtrack consider remaining choice op support able succeed 
termination process discussed cast dynamic constraint satisfaction problem dcsp mittal falkenhainer 
dcsp generalization constraint satisfaction problem tsang specified set variables activity flags variables domains variables constraints legal variable value combinations 
dcsp initially subset variables active objective find assignments active variables consistent constraints variables 
addition dcsp specification contains set activity constraints 
activity constraint form variable takes value variables active 
correspondence planning graph dcsp clear 
specifically propositions var ious levels correspond dcsp variables actions supporting correspond dcsp domains 
action interference relations seen dcsp constraints interfering supported planning graph supported constraints activity constraints implicitly specified action preconditions supporting active proposition action propositions previous level corresponding preconditions active 
propos corresponding goals problem active 
improving growth search planning graphs naive planning graph exponentially larger terms actions level unioned planning graph see consider situation preconditions domain actions hold proposition list subsets proposition list correspond legal states 
growing searching may worse doing state space search 
improve approximation unioned planning graph tracking information subsets proposition list belong legal states 
example recognize part legal state second level search tree avoid projecting action preconditions proposition list 
type information control backward search solution planning graph 
example know part legal state second level backtrack soon get recursive goal set 
unfortunately keeping track illegal subsets proposition list general require computation don access state space search tree memory exponential number illegal subsets proposition list worst case 
knowing illegal subsets proposition lists help 
interesting middle ground keep track sized illegal subsets subsets 
idea graphplan mutex relations elements proposition list said mutex belong set sized illegal subsets 
nice thing pair wise mutex relations inferred efficiently incremental constraint propagation 
start generalizing mutex relations hold pairs interfering actions 
graphplan algorithm assumes specific definition interference viz actions interfere effects violate preconditions effects definition interference actions really designer domain needs capture requirements concurrent execution reisig 
starting actions level instructive note optimal solution length depends interference definition 
example domain doesn allow concurrency consider pair actions interfering 
case optimal solutions sequential 
similarly weaken consider pair actions interfere mutex 
mutex relation propagated effects actions proposition list long effects supported non interfering actions 
particular example op leading interfering fo deletes mutex second level proposition list 
similar reasoning shows mutex 
expected mutex information growth planning graph helps termination check 
mutex point projecting level proposition list shown graphplan planning graph mutex relations shown 
similarly mutex second level backward search goals terminated soon reach second level proposition list 
context observation previous section planning graph seen dcsp mutex propagation seen inferring additional variable value constraints 
mutex propagation process different standard notion constraint propagation csp 
see note mutex propagation routines constraints variables propositions level derive implicit constraints variables level 
contrast normal constraint propagation procedures constraints set variables derive new constraints set variables 
discussion reconstruction graphplan algorithm terms forward state space projection reduces mystery regarding antecedents algorithm 
recognize fact plans produced graphplan contain multiple actions step fact graphplan terminates smallest plan terms time steps consequences properties corresponding forward state space search tree 
similarly recognize planning graph approximation disjunctive unioned representation state space search tree approximation finer finer maintain bookkeeping information illegal subsets proposition lists 
shown mutex relations understood inferring sized illegal subsets 
reconstruction shows ability refine disjunctive partial plans action parallelism important innovation graphplan algorithm 
particular easy graphplan produce serial plans changing definition action interference considering pair non op actions interfering 
serial version graphplan tradeoffs respect graphplan normal forward state space search search projection independent action sets 
specifically situations domain allow parallelism parallel planning graph terminate fewer levels serial planning graph 
importantly serial version graphplan outperform normal state space planners 
verified observation comparing state space planner graphplan data structures serial version graphplan 
account gives insights tradeoffs offered propagation mutex relations 
point note mutex relations help generating planning graph finer approximation unioned planning graph 
approximation unioned planning graph provided mutex relations general differ exact unioned planning graph mutex identifies sized illegal subsets higher sized ones 
difference illegal projections left planning graph 
example graph interference hold actions deletes preconditions useful effects notice graphplan considers violation effect just useful effects 
weaker interference relation lead parallel shorter solutions graphplan 
plan planning graph includes preconditions third level proposition level propositions easy see search tree applied states level 
approximation improved higher sized mutex relations cost computing mutex relations offset improvements planning graph size time search depends percentage action interactions domain pair wise ary interactions amazing practical success sized mutex relations explained relative rarity order interactions actions classical planning domains 
rarity certain extent due lack global resource constraints classical planning domains 
sized mutexes may effective consider complex domains containing global constraints 
illustrate consider variation blocksworld domain blocks non uniform sizes super blocks example hold blocks top 
scenario suppose considering actions attempt stack distinct block top super block 
actions interacting interacting 
connection planning graph dynamic constraint satisfaction problem provides insights operation backward search phase graphplan algorithm 
essence graphplan algorithm uses systematic backtracking search strategy tsang solving dynamic csp computing satisfying assignment level recursing variables activated level 
failure compute satisfying assignment level algorithm backtracks previous level 
memoization phase graphplan seen special form learning kambhampati 
connection clear specific details backward search algorithm graphplan means unique 
exist possible ways solving dynamic csp algorithms worth considering 
include variable value ordering heuristics full nogood learning schemes 
shall elaborate section 
graphplan refinement planner existing ai planners fall rubric refinement planners 
kambhampati provide general model refinement planning 
reconstruction graphplan forward state space planning helps interpret instance generalized refinement planning 
specifically planning graph structure graphplan seen partial plan representation 
action sequence belongs candidate set planning graph prefix contains subset actions levels planning graph contiguous 
example action sequence prefix candidate shown belong level actions belongs second level actions belongs third level 
minimal candidates planning graph 
similarly action sequence prefix candidate planning graph 
relation naive unioned graphplan planning graphs formally stated saying candidate set naive planning graph superset candidate set graphplan turn superset candidate set unioned planning graph 
forward planning graph growing phase corresponds refinement operation 
inference propagation mutex constraints seen legitimate part binary interactions actions eventually lead higher level interactions propositions 
graphplan algorithm remember higher level mutex relations propositions caching failing goal sets 
graphplan algorithm works higher order relations small subset total number learned failure 
domain significant number non binary action interactions higher order interactions propositions prevalent postponed learning stage drastic hit performance 
refinement process addition mutex constraints reduces candidate set planning graph 
backward search phase graphplan corresponds solution extraction see minimal candidates planning graph correspond solution 
easy see solution extraction helped reduction candidate set planning graph achieved inference mutex constraints 
interesting thing analogy traditional refinement planners forward state space planner partial order planner search various partial plans refinement phase graphplan considers partial plan incur premature commitment 
saw single plan approximately equal unioned disjunctive representation partial plans forward state space search 
search partial plans graphplan solution extraction process forward state space refinement 
brings important insight graphplan refining disjunctive plans forward state space refinements possible duplicate success context backward state space plan space task reduction refinements 
kambhampati considers question outlines challenges involved developing planners 
extending graphplan making graphplan goal directed strong connection forward state space refinement graphplan suggests graphplan suffer 
specifically rea domains actions applicable proposition list unduly increasing width planning graph structure 
researchers despite efficiency graphplan easily fail domains actions available relevant top level goals problem 
ways making graphplan goal directed 
simple way reducing width planning graph involve construc ting operator graphs problem 
operator graphs smith peot symbolically back chain goals problem isolate actions domain potentially relevant solving problem 
action graph guaranteed relevant solution guarantee solutions consist operators operator graph 
restricting attention actions planning graph expansion phase reduce width planning graph 
cost operator graph construction quite low graph contains instance precondition action 
operator graphs may able reduce width graph sufficiently 
particular fact action relevant problem doesn imply considered action level planning graph 
order predict relevance action level developed novel way adapting means ends analysis mcdermott graphplan 
approach called parker kambhampati involves growing planning graph backward direction regressing goals actions resulting structure guidance standard graphplan algorithm 
growing backward planning graph involves regressing proposition lists relevant actions 
particular proposition th level proposition list counting goal state side introduce actions include dummy preserve action effects list th level action list 
actions introduced level 
proposition list th level consists preconditions actions introduced th level 
suppose grown planning graph way levels search solution graph 
level backward planning graph structure shows actions relevant level forward planning graph 
run standard graphplan making consider actions corresponding level backward planning graph 
alternately mark propositions th level initial state propagate flags actions propositions earlier levels action preconditions proposition supporting actions 
process results goal propositions marked commence mutex propagation phase part graph marked followed backward search phase 
number blk sized stacks cpu sec graphplan mea graphplan 
performance improvement achieved making graphplan goal directed notice planning graph considered approaches significantly smaller pure backward planning graph actions may preconditions satisfied preceding action level standard planning graph consider actions relevant goals 
leads dramatic reduction plan graph building cost problems containing irrelevant actions 
compares mea graphplan standard graphplan algorithm set blocks world problems 
problem consists block stacks initial state individually inverted goal state 
graph plots cpu time increased planners written lisp run sparc 
notice dramatic increase cost planning suffered graphplan compared mea graphplan 
main reason turns graph build time 
values greater mea graphplan solves problem graphplan runs memory 
propagating mutexes backward direction mea graphplan generates planning graphs backward direction ultimately uses forward state space refinement ideas infer propagate mutex relations 
variation theme involve doing inference propagation backward direction developing graphplan algorithm completely backward state space refinement 
look glance useful information propagated backward direction info rmation goals required propagated 

propagating mutexes backward direction mutexes shown black links specifically actions said backward mutex statically inte effects violate preconditions useful effects effects action support propositions planning graph exact set useful effects propositions supported action pair wise mutex propositions supported 
propositions backward mutex actions supported pair wise mutex actions supported 
illustrate consider example shown mutex solely supporting leads mutex relation supporting actions mutex 
mutex supporting propositions mutex 
preliminary studies show propagation rules derive reasonably large set mutex relations planning graph 
investigating utility controlling search concert forward mutexes 
considering effectiveness backward mutexes controlling search planning graph forward direction corresponds variant network flow problem 
handling expressive action representations graphplan algorithm originally described propositional actions algorithm inhibits extended expressive action representations ones ucpop penberthy weld 
ucpop representation allows negated preconditions goals conditional quant ified effects actions disjunctive preconditions 
briefly discuss handled 
negated preconditions goals quite straightforward handle allow proposition lists contain positive negative literals 
disjunctive preconditions handled allowing actions th level connected multiple sets preconditions th level 
universally quantified effects essentially expanded conjunction unquantified conditional effects 
notice expansion increase number actions 
treatment conditional effects interesting 
obvious approach convert action conditional effects set actions conditional effects 
approach leads exponential blow number actions 
better approach handle conditional effects directly 
doing requires minor modifications graphplan algorithm 
shall illustrate help example 
actions actions conditional effects shown left hand side 
suppose starting initial state shown left proposition list planning graph interested achieving goals planning graph grown shown avoid clutter show persistence actions useful solving problem avoid showing level 
iteration straightforward small exception explicitly introduce negated propositions support persistence negated propositions initial state closed world assumption true initial state closed world assumption persists second proposition list 
actions interfering propositions marked mutex 
extension second level involves actions conditional effects 
propositions corresponding conditional effects handled conditional establishment links 
example provided true previous state 
support link antecedent proposition previous level 
unconditional establishment seen special case antecedent link omitted signify special antecedents see effect need generalize mutex propagation presence conditional establishments 
follows conditional establishment paths part joint dan weld 
mutex action supporting mutex action supporting antecedents conditional establishment mutex antecedents second antecedents conditional establishment mutex consequent second conditional establishment vice versa 
clauses course generalizations needed handle conditional effects 
propositions mutex establishments proposition mutex establishments second propos 
applying rule find mutex third level antecedent mutex antecedent notice marked mutex 
fact action mutex rules remain unchanged actions marked mutex preconditions actions mutex preconditions action unconditional effects actions deletes precondition unconditional effect action 

example illustrating direct handling conditional effects mutexes shown black links coming back example goals third level propos list backward search commence 
goals may supported conditional establishments addition primary preconditions selected actions backward search subgoal secondary causation preconditions consider preservation preconditions subgoals respect selected actions 
example supported supported conditional establishment 
subgoal precondition causation precondition respect furthermore ensure selected actions violate subgoals 
conditional effect post preservation precondition respect selected actions violates subgoals supported level unconditional establishments resulting subgoals true initial state backward search succeeds 
improving graphplan backward search csp techniques connection planning graph dynamic constraint satisfaction problem suggests possible improvements backward search phase graphplan 
considering improvements motivated fact ling planning graph sat instance solving sat solving techniques shown perform standard graphplan kautz selman bayardo schrag 
current understanding csp literature frost dechter bayardo schrag best systematic search algorithms standard csp involve forward checking form constraint propagation dynamic var ordering dependency directed backtracking learning 
graphplan backward search uses memoization limited form learning 
worth considering utility ideas learning 
supporting forward checking involves filtering conflicting actions domains remaining goals soon particular goal assigned 
dynamic variable ordering involves selecting assignment goal number remaining 
preliminary results show techniques bring significant improvements graphplan performance 
example graphplan able solve blocks world benchmark problem times faster number remaining variable ordering heuristic compared number remaining 
results show contrary blum furst speculations goal ordering practical impact graphplan 
discussed kambhampati general failure explanation dynamic csp specifies set assigned variables assignments set unassigned variables 
semantics failure explanation part search node produced solving dcsp branches search node lead solution 
context graphplan memos seen subset possible failure explanations name unassigned variables 
fai lure explanations consisting assigned unassigned variables help situations ways achieving set subgoals level fail small fraction succeed 
cases memos learned generalized failure explanations graphplan forced repeat failing assignments times 
interesting investigate utility full fledged learning strategy involving explanation failures leaf nodes regression propagation leaf node failure explanations compute interior node failure explanations lines described kambhampati 
strategy promise increase learning opportunities existing memos general 
specifically graphplan stores goals failing goal set level failure due presence small subset 
full fledged learning help alleviate situation making stored goal sets useful branches search 
planning scheduling apart graphplan known despite efficiency graphplan perform poorly problems 
happen reasons due irrelevant actions domain planning graph grows fast existing memory 
handled large extent making graphplan goal directed see sections 
class problems exemplified benchmarks kautz selman satplan experiments hard require effort backward search phase 
analysis problems reveals main reason difficulty graphplan combines planning scheduling resource allocation phases making combined problem harder solve 
understand note blocks world problem bw large satplan suite graphplan finds plan correct save ordering actions early iterations spends enormous time iterations effectively linearizing plan handle resource restrictions imposed availability single hand 
inefficiency approach apparent realize iterations graphplan looking approximately correct plan rest search space 
approach results degradation graphplan performance additional resources number robot hands blocks world decidedly counter intuitive behavior 
better alternative involve separating planning scheduling phases graphplan terminating planning soon plan correct modulo resource allocation starting separate scheduling phase single plan part joint dan weld 
notice different subset memoization employed graphplan involves checking subset current goal set matching stored memo 
interested storing smaller memo normal subset better chance succeeding 
input 
preliminary investigations show strategy leads dramatic improvements efficiency plan generation 
currently process completing formalization evaluation idea srivastava kambhampati 
provided rational reconstruction blum furst graphplan algorithm starting forward state space search 
reconstruction shown graphplan planning graph data structure upper bound approximation unioned representation state space search tree mutex propagation making approximation finer 
backward search phase corresponds solving dynamic constraint satisfaction problem 
reconstruction clarify role relative tradeoffs offered action parallelism mutex propagation graphplan algorithm interpret graphplan refinement planner 
understanding sketch variety ways extending graphplan algorithm including making graphplan goal directed empowering handle expressive action representations supporting backward propagation mutex information improving backward search exploiting csp techniques apart planning scheduling graphplan 
details evaluation extensions described forthcoming extended version 
barrett weld 
partial order evaluating possible efficiency gains 
artificial intelligence 
blum furst 
fast planning planning graph analysis 
proc 
ijcai extended version appears artificial intelligence bayardo schrag 
csp look back techniques improve real word sat instances 
proc 
aaai 
frost dechter 
search best constraint satisfaction search 
proc 
aaai 
drummond 
situated control rules 
proceedings international conference knowledge representation reasoning morgan kau 
kambhampati knoblock yang 
planning refinement search unified framework evaluating design tradeoffs partial order planning 
artificial intelligence 
kambhampati yang role disjunctive representations constraint propagation refinement planning 
proceedings fifth international conference principles knowledge representation reasoning 

kambhampati 
challenges bridging plan synthesis paradigms 
proc 
ijcai 
kambhampati 
relations intelligent backtracking explanation learning planning constraint satisfaction 
eas asu edu pub rao jour ps 
kambhampati 

refinement planning unifying framework plan synthesis 
ai magazine 

kautz selman 
pushing envelope planning propositional logic stochastic search 
proceedings national conference artificial intelligence 
mcdermott 
heuristic estimator means ends analysis planning 
proceedings rd international conference ai planning systems 
aaai press 

mittal falkenhainer 
dynamic constraint satisfaction problems 
proc 
aaai 
parker kambhampati 
making graphplan goal directed 
forthcoming 
reisig 
petrie nets 
springer verlag 
smith peot 
suspending recursion partial order planning 
proc 
rd intl 
ai planning systems 
srivastava kambhampati 
apart planning scheduling graphplan 
forthcoming 
tsang constraint satisfaction 
academic press 

