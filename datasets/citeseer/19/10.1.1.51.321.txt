process algebraic view linda coordination primitives nadia busi roberto gorrieri zavattaro dipartimento di matematica universit di siena del siena italy dipartimento di scienze dell informazione universit di bologna zamboni bologna italy mail gorrieri cs unibo main linda coordination primitives asynchronous communication read operation nonblocking rd predicates studied process algebraic setting 
lattice languages proposed bottom element process algebra differing ccs asynchrony output operation languages lattice obtained extension basic language adding linda coordination primitives 
observational semantics languages obtained coarsest congruences contained barbed semantics tuples observable 
lattice languages collapses smaller points lattice different bisimulation semantics 
notably semantics standard notion strong bisimulation inputs outputs tuples treated symmetrically 
keywords coordination languages semantics linda process algebra 
aim provide process algebraic treatment linda gel coordination primitives studying adequate sos operational semantics plo observational semantics concept strong barbed bisimulation ms 
aim need analyze conceptual traditional process algebras ccs mil propose possible representation concepts process algebraic style 
main features distinguishing linda classic process algebras ffl asynchronous communication 
realized means communication medium called tuple space ready receive messages tuples senders ready deliver receivers 
communication asynchronous sender may proceed just performing emission message tuple space ts short 
similarly receiver input performing time ts hand shake synchronization tuple ts receiver completes communication sender receiver side effect removing message ts 
ffl read operation 
messages tuples treated resources possible read message removing ts input operation 
input operation reading message denoted rd blocking required message absent reading process suspended 
supported esprit bra project coordination 
rdp rd inp rd inp rdp inp rd rdp rd bisimulation inp bisimulation rdp bisimulation bisimulation lattice languages semantics 
ffl conditional input read predicates 
current status ts checked required message absent value false returned contrary message behavior rd operation value true returned 
communication mechanism said generative message generated process independent existence ts explicitly withdrawn input operation 
fact insertion ts message equally accessible processes bound 
implementing peculiar features linda process algebra take design decisions instance model asynchronous communication tuple space 
conceptually execution linda output primitive seen composed phases emission message sending ts rendering actual presence tuple ts denote hai 
decide model emission rendering message forming single autonomous atomic action internal step agent parallel composition operator 
representation tuple space just tuples hai parallel processes 
tuple hai interacts processes hand shake synchronization removed consumed process willing perform input operation tested read means read primitive rd 
concerning conditional input read predicates decide reformulate operators inp rdp respectively direct flow control depending presence absence required message coordination primitives mentioned new world process algebra 
quite instructive study primitive isolation combination 
shows lattice languages investigate bottom language essentially ccs asynchronous communication substituted synchronous hand shake communication mechanism giving semantics operation sketched 
languages extensions obtained adding linda coordination primitives 
top language rd inp rdp offers process algebraic view linda called linda process algebra 
order define adequate observational semantics languages lattice approach follow inspired ms firstly identify internal transitions define observable actions linda offers eval operation consider process algebraic approach going study simply correspond spawn operation eval calls activation precise omitted relabeling operator changed names prefixes 
find coarsest congruence contained barbed semantics coarse equivalence equates processes bisimilar internal actions offer pair related states observable actions 
usually internal transitions correspond labeled derivations 
case consider labeled steps languages contain predicates 
languages predicates consider new label introduced order give appropriate structured operational semantics predicates 
show derivations labeled considered internal usual steps 
second question asynchronous observer able detect 
intuition ht clear observer see just ts observer input read tuple ts previously emitted :10.1.1.53.4500
contrary observer means realizing system performing input read operations 
strong difference considering synchronous asynchronous communication inputs outputs relevant outputs better tuples 
barbed bisimulation obtained observations corresponds defined acs setting asynchronous calculus 
language despite asymmetric role inputs tuples resulting congruence classic notion bisimulation inputs tuples equally observable 
contrasts acs different operational modeling operation see concluding section comparison 
rd internal transitions left untouched resulting coarsest congruence called rd bisimulation different extends classic bisimulation allowing read operation matched invisible transition leading equivalent state 
processes equated rd bisimulation rd rd intuitively rd operation modify ts effect action justifies rd operation matched reverse doesn hold behavior rd restrictive performed hai ts 
inp includes conditional input operation form inp tests presence tuple hai tuple removed executed execution continue internal transitions barbed semantics enriched corresponding test absence required tuple consider inp hai absent started internal step 
coarsest congruence called inp bisimulation firstly bgz allows additional forms matching 
typical law holds bisimulation inp inp intuitively law holds tuple hai inp behaves inp behaves right hand side process executed tuple hai reason left hand side process needs summand 
rdp includes conditional read operation rdp differing inp tuple hai tested presence removed 
barbed semantics resulting coarsest congruence different case called rdp bisimulation 
offers new matchings exemplified typical law rdp rdp intuitively law holds rdp performs internal transition reading tuple hai effect checking absence hai behaves show right semantics rd inp languages extending rdp rdp bisimulation 
lattice languages collapses smaller points lattice bisimulation semantics reported 
organized follows 
sections introduce syntax operational semantics observational semantics languages rd inp rdp respectively 
section mainly devoted issue asynchronous communication section read operation section ii jq qjp iii jq jr qjr iv vi vii viii na ix pna nb pnb na jq na fn xi pna nb fresh xii rec rec table structural congruence 
conditional input operation section conditional read operation 
show language turing powerful encoding ram simpler definition ram inp alternative composition operator restriction operator 
section studies various combinations obtained gives precise mathematical relation syntactic semantic lattices 
conclusive remarks research comparison related literature reported section 
language section language essentially asynchronous version ccs mil relabeling standard input output prefixes changed respectively 
mess ranged set message names ar ranged set agent variables 
define processes terms obtained grammar cna rec possible prefixes term denotes inactive process usually omitted sake simplicity 
possible prefixes standing internal action standing input output primitives linda respectively 
consider usual parallel choice restriction recursion rec operators 
fa ang pna shorthand pna nan consider closed terms guarded recursion mil 
prefix introduces ts new tuple contents denoted hai 
input prefix requires presence hai ts 
hai removed 
tuples considered syntax processes 
order represent tuples ts introduce states defined terms obtained grammar hai jp pna gamma 
hai gamma 
gamma 
gamma 
ff gamma 
ff gamma 
ff gamma 
jq ff gamma 
jq gamma 
gamma 
jq gamma 
jq ff gamma 
pna ff gamma 
na ff ff gamma 
ff gamma 
table operational semantics state parallel composition processes tuples possibility define local message names restriction operator 
range states processes actual meaning clear context agent denotes set possible states 
fn defined follows denote free names fn fn fn jq fn fn fn fn hai fag fn pna fn fag fn fn fag fn fn rec fn fn order define operational semantics define structural congruence relation captures fact example order terms parallel composition effect behavior 
structural congruence defined smallest congruence satisfying axioms table 
axiom xi ff conversion denotes term obtained renaming free occurrences name name define labeled transition system agent label gamma 
specifying states called agents evolve 
label def ag ranged ff fi set possible labels 
labeled transition relation gamma 
smallest satisfying axioms rules table 
axiom shows output prefix generate new tuple performing internal action tuple hai able give contents process environment performing action labeled axiom 
axiom allows input prefix consume message environment performing action labeled complementary axiom rules usual ones prefix axiom choice operator rule parallel composition operator rules restriction operator rule giving possibility structurally congruent agents execute actions rule 
rules recursion semantics defined structural axiom xii applies unfolding step recursively defined process 
set agent closed respect transition relation agent ff gamma 
ff term agent 
example section implementation random access machine ram ss asynchronous version ccs 
way show loose turing equivalence passing synchronous asynchronous communication 
ram computational model composed finite set registers hold arbitrary large natural numbers program sequence simple numbered instructions arithmetical operations contents registers conditional jumps 
perform computation inputs provided registers registers program supposed contain value computation 
execution program begins instruction continues executing instructions sequence jump instruction encountered 
execution stops instruction number higher length program reached happens program executing instruction instruction require jump current instruction requires jump instruction number appearing program 
program terminates result computation contents registers specified outputs 
min shown instructions sufficient model recursive function ffl succ add contents register ffl contents register zero decrease go instruction jump instruction example program computes sum registers putting result register note third instruction corresponds unconditional jump register contains value computation contents modified program succ translation ram language essentially borrowed ccs tau 
model contents program counter means tuples instruction execute th ts contains tuple hp model instructions proceed way succ def rec ack def rec test zero dec succ instruction register position represented agent consumes program counter tuple produces tuple representing request increment register waits increment occurred consumes tuple hack updates program counter adding tuple hp instruction position modeled agent consuming program counter tuple hp produces tuple representing request testing register decrementing contents greater zero contents agent corresponding zero tuple produced agent consumes tuple updates program counter order perform jump th instruction adding hp decrement performed tuple produced agent consumes tuple updates program counter adding hp recursion operator representation instructions permits reuse 
register initially contains value modeled agent defined follows def rec test zero ack jin na def rec test dec ack jin nb def rec test dec ack na agent receives test message tuple inserted ts order state register contains value 
message received sends corresponding ack term jin na 
term blocked guard agent creates tuple hai observe local name 
point computation register contain value tuple inserted ts instruction term generates tuple activates term sending message tuple inserted ts sends corresponding ack jin nb 
case term guarded prefix waits activated term different name order avoid term incorrectly activate term term defined way unique difference name way agent represent odd values values 
consider program inputs nm uses registers order execute introduce input corresponding register done agent performs bootstrap system initializing registers emitting program counter tuple hp def times ack ack times nm times ack ack nm times program modeled jz jbj observational semantics approach follow order define adequate observational semantics language inspired ms firstly identify internal transitions define observable actions find coarsest congruence contained barbed semantics coarse equivalence equates processes bisimilar internal actions offer pair related states observable actions 
usual language internal actions denoted gamma 
labeled gamma 
iff gamma 
attention paid order identify observable 
intuition ht clear observer see just ts observer input read tuple ts previously emitted :10.1.1.53.4500
contrary observer means realizing system performing input read operations 
definition committed action iff gamma 
resulting definition barbed bisimulation definition binary symmetric relation agent barbed bisimulation implies ffl gamma 
exists gamma 
ffl agents barbed bisimilar written ffl exists barbed bisimulation definition barbed bisimulation essentially acs introduced setting asynchronous calculus channel names output labels considered visible 
asynchronous bisimulation ht proved coarsest congruence contained barbed bisimulation :10.1.1.53.4500
show language coarsest congruence standard strong bisimulation mil recalled 
definition binary symmetric relation agent bisimulation implies ffl ff gamma 
exists ff gamma 
agents bisimilar written exists bisimulation difference acs due fact asynchronous calculus process receive message immediately resends 
allows process simulate input action followed instantaneous emission consumed message internal action 
happen language instantaneous emission allowed 
formalized proposition 
proposition agent gamma gamma 
gamma proof 
recall tuples hai appear processes states 
provided tuples hai able generate transitions labeled processes perform transitions labeled proof proposition induction proof transition gamma 
base case equal program 
order prove bisimulation coarsest congruence contained barbed bisimulation language assert congruence prove agents barbed bisimilar context bisimilar 
proposition bisimulation congruence operators proof congruence result omitted sections standard mil 
reason structural congruence shorthand copies agent composed parallel stands jp fa ang 
proposition gamma 
gamma 
gamma 
pn pn hai 
proof 
proof uses double induction number successive derivations labeled proceed induction proof th derivation pn gamma gamma 
pn theorem agents jr ffl qjr agent proof 
agents satisfying premises proposition 
fn fn observe finite 
show pair contained bisimulation particular define agent def ag ag ag ag relation sjr ffl jr fn fn lg bisimulation 
pair jr barbed bisimilar qjr fn fn subsets agents ag defined follows ag def rec ag def rec ag def rec ag def rec fresh distinct names tuples hb called presence tokens agent ag able generate consume corresponding presence token hb agent ag ag ff gamma 
gamma 
performs transition step corresponding presence token produced single reduction step 
verify bisimulation 
ffl gamma 
consider sequence derivations agent sjr perform presence agent ag term ag ag ag ag sjr gamma 
ag jr def gamma 
ag jr def gamma 
jr def observe agent jr barbed bisimilar sjr jr gamma 
gamma 
gamma 
ffl jr generate consume presence token hb 
previous observations presence tokens ensures agent ag involved reductions jr reduction step consist consumption tuple hai performed prefix ag consumed tuple hai contain tuple 
gamma 
jr second third reduction steps consist generation withdrawal presence token hb respectively 
observe jr ffl jr fn fn ffl gamma 
restrictive suppose hai gamma gamma 
term hai infer derivation 
hai 
consider sequence reduction steps renames tuples hai appearing sjr tuples hc fresh 
renaming performed agent ag term ag ag ag ag sjr gamma 
gamma ag jr def gamma 
gamma ag jr def gamma 
gamma ag jr def gamma 
gamma ijr def gamma 
hc ijr def observe alternatively steps presence token hb generated consumed 
agent jr barbed bisimilar sjr jr gamma 
gamma 
gamma 
ffl sequence reductions performed jr presence token hb alternatively generated consumed steps times 
agent ag able involved steps guard performed times tuples hc created 
requires gamma 
gamma 
gamma 
agent contain tuple 
def proposition hai 
hc ijr agent able generate new tuple hai ag consumed performing derivation gamma 
term ag ag ag ag gamma 
hc ag jr def gamma 
hc ag jr def gamma 
hc ag jr def gamma 
hc ijr def observe follows proposition gamma gamma 
offers equivalent reduction steps gamma 
gamma 
gamma 
ffl fact presence token hb appears reduction steps implies steps performed ag implies tuple hai generated ag consumed reduction step 
consumption performed agent context 
second case agents ag performs operation 
implies contradiction ffl see observations presence tokens proof gamma 
requires steps order generate new presence token hb tuple hai removed gamma 
conclude hc ijr 
tuples hc renamed hai agent ag term ag ag ag ag gamma 
gamma hc ag jr def gamma 
gamma hc ag jr def gamma 
gamma hc ag jr def gamma 
gamma hc def gamma 
def observe alternatively steps presence token hb generated consumed 
agent barbed bisimilar gamma 
gamma 
gamma 
ffl sequence reductions performed presence token hb alternatively generated consumed steps times 
agent ag able activated times 

ensures hai hai observed hai 
gamma 
ensures gamma 
hai 
ffl gamma 
implies sjr gamma 
jr barbed equivalent agent jr able perform reduction step jr gamma 
jr ffl observations presence tokens assert agent involved reduction step jr generate presence token reduction step jr 
jr gamma 
hai hai gamma 
observe jr ffl jr fn fn corollary bisimulation coarsest congruence contained barbed bisimulation proof 
congruence contained ffl 
show 
fact jr qjr agent congruence 
ffl follows jr ffl qjr 
theorem holds 
rd gamma 
gamma 
gamma 
jq gamma 
jq table additional rules rd 
language rd section language rd 
syntax language obtained extending possible prefixes language new prefix rd set label possible labels extended new label standing execution prefix rd 
operational semantics language rd defined structural congruence table sos rules table extended axiom rule table 
side condition ff added rule table new label pass trough restriction name rule execution rd operation change ts tuple occurring agent removed left unchanged 
observational semantics rd investigate coarsest congruence contained barbed bisimulation 
obtained equivalence called rd bisimulation defined follows 
definition binary symmetric relation agent rd bisimulation implies ffl ff gamma 
ff exists ff gamma 
ffl gamma 
exists gamma 
gamma 
agents rd bisimilar written rd exists rd bisimulation new rd bisimulation allows simulate transition labeled internal labeled action 
intuition rd operation modify ts effect action matched rd operation behavior rd restrictive performed hai ts 
implies term rd absorbed occurring summation context rd rd order prove rd bisimulation coarsest congruence contained barbed bisimulation follow approach previous section proposition rd bisimulation congruence operators rd 
theorem agents rd 
jr ffl qjr agent rd proof 
structure proof proof theorem 
agent extended def ag ag ag ag ag ag def rec new set agents ag introduced new set fresh distinct presence tokens considered 
ag ensured ag ff gamma 
gamma 
relation defined proof theorem 
pair analysis possible derivations gamma 
gamma 
case gamma 
agent jr respond new kind synchronization due labels possible agent contains tuples gamma ag guarded rd prefix gamma 
new case gamma 

ffl gamma 
case restrictive suppose hai gamma gamma 
term hai infer derivation 
hai 
case gamma 
proof theorem consider sequence reduction steps renames tuples hai appearing sjr tuples hc term ag ag ag ag ag sjr gamma 
gamma ag jr def gamma 
hc ijr def proved generation consumption presence token hb implies agent jr reply reductions jr gamma 
gamma 
gamma 
ffl hc ijr hai ensures gamma agent able perform reductions 
term ag ag ag ag ag gamma 
hc ag jr def gamma 
hc ag jr def gamma 
hc ag jr def gamma 
hc ag jr def gamma 
hc ijr def observe agent offer equivalent reduction steps gamma 
gamma 
gamma 
inp gamma 
inp gamma 
gamma 
gamma jq gamma 
jq gamma 
pna gamma 
na table additional rules inp 
ffl presence token hb appears reduction steps hc ag jr analyze reduction step gamma 
observations presence tokens allows state agent involved reduction step new presence token generated single step 
agent ag involved remember gamma 
step inferred case consider gamma 
generic name observe agent synchronize action 
holds gamma 
gamma 
case gamma 
action synchronize tuple hai result synchronization consumption tuple hai follows contradiction remember proposition gamma 
possible cases gamma 
gamma 
reductions performed order remove presence token hc ijr 
occurrences tuple hc renamed hai agent ag term ag ag ag ag ag gamma 
gamma hc ag jr def gamma 
def alternate generation consumption presence token hb ensures gamma 
gamma 
gamma 
ffl 
ensures hai hai observed hai 
gamma 
gamma 
ensures gamma 
hai gamma 
hai 
corollary rd bisimulation coarsest congruence contained barbed bisimulation rd 
language inp section language inp 
syntax obtained extending syntax processes language new construct inp process inp tests tuple hai ts available removed process chosen executed 
order describe behavior sos style add new label set label rules table ones table 
case side condition new label ff added rule rule table 
axiom table indicates program inp synchronize tuple hai removing program find required message guess absence performing action labeled axiom 
process willing perform labeled derivation composed parallel agent executability jq depends inability offer message guess wrong operation executed rule 
hand rule agent restricted name operation local step computation labeled agents offer message words search finished local name 
rule uses negative premise easy see transition system specification strictly gro exists unique transition system agreeing 
example section shown implementation ram language show extended language inp allows simpler implementation registers represented means tuples active agents 
fact inp primitive allows test absence certain tuple order verify register contains value 
new version ram model contents registers way register contains number tuples hr tuple space 
succ instruction register adds new tuple hr register executes inp operation message name tuple hr removed jump specified instruction obtained introducing corresponding program counter tuple 
succ def rec def rec inp agent modeling program inputs nm defined hp ij hr ij times hr ij nm times observational semantics inp investigate coarsest congruence contained barbed bisimulation 
new operator inp requires discussion notion reduction inp 
fact reasonable consider transition labeled reduction step reductions usually defined transformation steps self contained agent able perform independently context 
true transitions labeled new label label introduced helping sos formulation semantics conceptually internal step redefine reductions gamma 
iff gamma 
gamma 
inp new definition reduction coarsest congruence contained barbed equivalence called inp bisimulation defined follows 
definition binary symmetric relation agent inp bisimulation implies ffl ff gamma 
ff exists ff gamma 
ffl gamma 
exists gamma 
gamma 
agents inp bisimilar written inp exists inp bisimulation new inp bisimulation allows simulate transition labeled internal labeled action 
law holds inp inp intuitively holds tuple hai inp behaves inp behaves right hand side process executed tuple hai reason left hand side process needs summand 
proposition states agent derivation labeled contain tuple hai derivation labeled 
proposition agent gamma 
gamma proof 
induction proof transition gamma 
proposition inp bisimulation congruence operators inp 
theorem agents inp 
jr ffl qjr agent inp proof 
structure proof proof theorem 
agent proof theorem 
relation defined proof theorem 
pair analysis possible derivations gamma 
gamma 
cases gamma 
new gamma 

ffl gamma 
def fa gamma 
subset cardinality set avoid derivation gamma 
matched produce tuples hl message names ts disallowing perform derivations 
proposition agent sjr execute sequence reduction steps agents ag generate tuples hl term ag ag ag ag ag agent ag ag ag ag lnl ag sjr gamma 
ag jr def gamma 
ag jr def gamma 
sj hl ij hb ij ag jr def barbed bisimilar agent jr allow sequence reductions jr gamma 
gamma 
gamma 
ffl order generate presence tokens hb agents ag involved hl ij hb ij ag jr agent able perform reduction due gamma 
gamma 
hl ij hb ij ag jr def agent allow reduction step gamma 
ffl usual observations presence tokens allow state involved reduction step 
tuples hl consumed occurrence hl easy see hl occurs possible remember hl consumed agents ag involved step remove tuples hl step inferred agent output input step agent environment synchronize step 
derivation labeled performed presence environment tuple hai remember definition gamma 
implies 
derivation labeled hl ij hb ij ag jr gamma 
tuples hl presence tokens hb removed 
letr term nfl ag jr gamma 
nfl hl ij hb ag jr def gamma 
nfl hl ij nfl hb jr def gamma 
jr def ffl gamma 
gamma 
gamma 
ffl consumption presence tokens steps ensures jr observe jr ffl jr ensures ffl gamma 
proof previous case difference set defined def fb gamma 
ag 
case message name element mimic step derivation labeled fact new definition possible derivations gamma 
gamma 
corollary inp bisimulation coarsest congruence contained barbed bisimulation inp 
language rdp section language rdp 
syntax obtained extending syntax processes language new construct rdp process rdp tests tuple hai ts available program chosen consuming tuple executed 
table semantics rdp primitive rdp gamma 
rdp gamma 
table additional rules rdp 
defined action reading tuple hai choice process labeled axiom process chosen label axiom 
semantics language rdp defined axioms rules table plus side condition ff rule ff rule rule table defining behavior synchronization due labels rules table defining behaviour label parallel composition restriction new axioms table 
adding rules transition system specification remains strictly gro 
observational semantics rdp investigate coarsest congruence contained barbed bisimulation 
definition reduction considers reduction steps derivations labeled coarsest congruence contained barbed equivalence called rdp bisimulation defined follows 
definition binary symmetric relation agent rdp bisimulation implies ffl ff gamma 
ff exists ff gamma 
ffl gamma 
exists gamma 
exists gamma 
gamma 
ffl ff gamma 
ff exists ff gamma 
gamma 
exists gamma 
gamma 
agents rdp bisimilar written rdp exists rdp bisimulation peculiar feature rdp bisimulation matched labeled derivation rdp rdp intuitively law holds rdp performs internal transition reading tuple hai checking absence hai effect behaves general term able perform derivation completely simulates behavior independently context 
matchings allowed rdp bisimulation ones rd inp bisimulation addition new derived 
derived matchings follows fact derivations labeled matched labeled derivations turn matched pair derivations labeled conditions explained 
proposition rdp bisimulation congruence operators rdp 
theorem agents rdp 
jr ffl qjr agent rdp proof 
structure proof proof theorem 
agent proof proposition 
relation defined proof proposition 
pair analysis possible derivations gamma 
gamma 
cases gamma 
gamma 
gamma 

ffl gamma 
proof similar corresponding case section set defined def fb gamma 
jr ffl 
gamma 
gamma 
jr jr tuples corresponding names ts derivation labeled synchronize tuple hbi 
proof theorem agent defined section sjr gamma 
gamma 
sj hl ij hb ij ag jr def barbed equivalent agent jr offer jr gamma 
gamma 
hl ij hb ij ag jr def ffl agent able perform reduction due gamma 
gamma 
hl ij hb ij ag jr def agent allow reduction step gamma 
ffl shown agents ag involved reduction step tuples hl consumed 
derivations labeled performed derivations labeled performed 
fact gamma 
derivation inferred gamma 
reasoning prove jr jr definition tuple hci derivation gamma 
possible 
possible cases gamma 
gamma 
second case tuples available reading tuples hl implies gamma 
definition shown section tuples hl presence tokens hb removed gamma 
gamma 
jr def gamma 
gamma 
ffl jr ffl gamma 
proof previous case difference set defined def fc gamma 
jr ffl 
case message name element mimic step derivation labeled fact new definition possible derivations gamma 
gamma 
gamma 
derivation gamma 
ffl gamma 
consider hai gamma case combine techniques sections 
def fc gamma 
jr ffl 
consider sequence reduction steps renames tuples hai hc generates tuples hl agent defined section sjr gamma 
gamma 
hc ijr def gamma 
gamma 
sj hc ij hl ij hb ij ag jr def combine observations sections concluding jr gamma 
gamma 
gamma 
ffl hc ij hl ij hb ij ag jr hai gamma observed section derivation gamma 
holds hai 
agent able perform reductions 
term hc ij ag ag ag ag ag fagg ag gamma 
hl ag jr def gamma 
hl ag jr def gamma 
hl ag jr def gamma 
hl ag jr def gamma 
hl jr def derivations possible agent ag involved creation tuples hl fact ffl gamma 
gamma 
ffl presence token hb ensures excluding derivation gamma 
agent reply reductions performed ag analyze derivation gamma 
shown section inferred agent labels kind allowed 
possible cases gamma 
gamma 
second case tuples available reading tuples hl hai 
implies gamma 
definition 
shown section presence tokens hb removed shown section tuples hc renamed hai gamma 
gamma 
hc ijr def gamma 
gamma 
jr def gamma 
gamma 
ffl jr gamma 
hai gamma 
gamma 
gamma 
rd gamma 
inp gamma 
inp gamma 
rdp gamma 
rdp gamma 
ff gamma 
ff gamma 
ff gamma 
jq ff gamma 
jq ff gamma 
gamma jq gamma 
jq gamma 
gamma 
jq gamma 
jq gamma 
gamma 
jq gamma 
jq ff gamma 
pna ff gamma 
na ff gamma 
pna gamma 
na ff gamma 
ff gamma 
table operational semantics 
corollary rdp bisimulation coarsest congruence contained barbed bisimulation rdp 
languages section analyze remaining combinations rd inp languages extend rdp 
name complete language rd inp rdp complete set sos rules recalled table 
example example shows possible rd rdp primitives 
table client server system access control 
specify kind services describe coordination mechanisms clients server access controller 
set possible user indexes set obtain access permission 
client send server service request emitting tuple complying request client server checks tuple hii local space shared server controller 
client enabled service performed message sent client client enabled answer sent 
client receives answer asks agent controller introduced set enabled users waits answer controller 
index client set controller emits tuple hii sends client corresponding answer enable index client set blocks waiting coming answer controller 
system def client nu client def rec req perm rd enable server def rec req rdp controller def rec perm enable table client server system access control 
observational semantics previous cases investigated coarsest congruence contained barbed bisimulation remaining combinations 
result languages equivalence rdp bisimulation 
proved proofs section 
summarize results introducing function obs languages returns adequate observational semantics obs obs rd rd obs inp inp obs rdp obs rd inp obs rd rdp obs inp rdp obs rdp trivial verify obs obs 
proposition compares bisimulations 
proposition consider bisimulations rd inp rdp language 
hold rd inp rd rdp inp rdp interesting result rdp bisimulation coarsest congruence contained barbed bisimulation language rd inp language contain rdp primitive 
clear observing rd inp rdp law holds agents allow derivations 
bisimulation relation finer rdp bisimulation couple agents equated rdp shown rdp rdp transitivity substitutivity rd inp rdp terms contain rdp primitive 
observe inclusions strict rd bisimulation inp bisimulation comparable 
examples section justify observation 
relation syntactic semantic lattices illustrated theorem 
theorem languages obs obs 
proof 
obs obs difference consists additional matchings obs involving labels occur transitions derivable agents related incrementally process algebra able express features generative communication 
main original contributions satisfactory interleaving operational semantics linda coordination primitives primitives received operational treatment see comparison rdp appear time 
ii characterization observational semantics different languages particular rd bisimulation rdp bisimulation completely new semantics classic bisimulation mil inp bisimulation bgz coarsest congruence result new 
lot left research 
instance definition suitable axiomatization congruences languages 
provided typical laws give flavour axiomatizations 
relevant development suitable semantics theory weak version barbed semantics 
language reasonable claim semantics denote identifies example processes showing order output operations irrelevant 
unfortunately congruence parallel composition language including non blocking conditional operations agent inp distinguishes agents jin inp jin inp fact left hand side agent generate tuple hci right hand side 
conclude predicates allows observe order emission messages 
currently investigating problem finding coarsest congruences various languages 
issue definition distributed semantics suitable truly concurrent observational semantics 
operational point view problem solved bgz receives distributed semantics terms petri nets inhibitor contextual arcs 
research leave characterization satisfactory observational semantics setting 
short comparison related literature 
operational approaches asynchronous communication literature proposals process algebras asynchronous communication 
basically different approaches followed considers messages passive entities stored buffers bkp represents messages active autonomous entities ht cy pug bgz 
papers group model buffers different ways communication medium explicitly represented language considered external data structure accessed active agents bkp encapsulation operator introduced explicitly model buffers containing sent messages 
far papers second group concerned see different main approaches bgz instantaneous semantics ordered semantics unordered semantics 
instantaneous semantics proposed ht bou order introduce asynchronous version calculus mpw 
approach represents message ts instance jp parallel composition process immediately input message words considered structurally congruent obtain asynchronous calculus outputs prefixes 
approach quite demanding implementation point view think approach suitable language linda 
instantaneous semantics different technicalities pug introduced asynchronous ccs uses hybrid form output prefix emission message delayed read sending agent executes observable synchronization action 
ordered semantics considered internal step sender sends message available potential partners 
way order emission respected rendering order 
implementation simpler sender sends message waits ts 
approach received operational treatment :10.1.1.50.4418
unordered semantics proposed bgz emission rendering message distinct autonomous actions 
operation implemented send operation message ts 
distributed systems precise knowledge relative speed processes messages assumed order emission needs respected rendering order order arrival messages ts 
bgz proved semantics comparable simple sublanguage inp 
operational semantics include cy value passing ccs asynchronous communication 
operations modeled explicit emission internal step proposal message remains related process sent 
approach fit properly feature generative communication requires sent messages equally accessible processes bound 
example cy message read sending process linda allowed 
observational semantics asynchronous communication argued trace semantics detecting deadlock behavior authors said failure semantics fails case asynchronous communication framework refusal information required 
bkp authors move special purpose failure semantics 
fact emission message represented means observable action labeled forcing new notion stable state labeled actions fired actions representing emission messages 
contrary authors defined plain failure semantics subset including non blocking conditional operations axiomatized finite processes :10.1.1.50.4418
rooted weak bisimulation studied suitably axiomatized 
semantics shares fact processes asynchronous observer synchronous observer equally detect presence inputs outputs tuples 
ht acs assumed observers asynchronous outputs tuples observationally relevant 
honda tokoro ht solves problem considering ordinary strong bisimulation enlarged transition system 
additional transitions derived extra rule stating state input possible reached state offers new copy corresponding received tuple 
acs reports mathematically nicer version semantics transition system modified novel bisimulation semantics called asynchronous bisimulation introduced 
asynchronous bisimulation proved coarsest congruence contained barbed semantics asynchronous calculus instantaneous semantics 
contrary show ordered semantics coarsest congruence classic notion bisimulation observer asynchronous 
want stress kind matchings rd bisimulation reminiscent matching asynchronous bisimulation read operation rd simulated instantaneous semantics writing hai semantics 
law rd rd reminds asynchronous law acs semantics read operation papers semantics linda dp cjy dp take account inp rdp predicates 
consider way model read operation 
dp observational equivalences testing dh applied language obtained embedding linda primitives simple sequential host language 
read operation dp treated input subsequent emission consumed message 
means rd just macro dp studies testing semantics suitable axiomatic characterization assuming synchronous observer 
similar operational modeling read operation cjy studies semantic equivalences 
anonymous referees suggestions helpful improving presentation 
acs amadio castellani sangiorgi 
bisimulations asynchronous calculus 
concur volume lncs pages springer verlag 
bou boudol 
asynchrony calculus 
technical report inria sophia antipolis 
bgz busi gorrieri zavattaro 
truly concurrent view linda interprocess communication 
technical report department computer science university bologna ublcs 
bgz busi gorrieri zavattaro 
semantics output operation asynchronous communication 
proc 
coordination volume lncs appear 
bkp de boer klop palamidessi 
asynchronous communication process algebra 
lics pages 
ieee computer society press 
de boer kok palamidessi rutten 
failure failures paradigm asynchronous communication 
concur volume lncs pages 
springer verlag 
ciancarini gorrieri zavattaro :10.1.1.50.4418
calculus generative communication 
proc 
st ifip conf 
pages 
chapman hall 
cjy ciancarini jensen 
operational semantics coordination language 
object models languages concurrent systems volume lncs pages springer verlag 
cy cleaveland 
operational framework value passing processes 
proc 
popl 
dh de nicola hennessy 
testing equivalences processes 
theoretical computer science 
dp de nicola pugliese 
observational semantics linda 
proc 
strict pages springer verlag 
dp de nicola pugliese 
process algebra linda 
proc 
coordination volume lncs pages springer verlag 
gel gelernter 
generative communication linda 
acm transactions programming languages systems 
gro groote 
transition system specifications negative premises 
theoretical computer science 
hansen 
bisimulations asynchronous mobile processes 
proc 
symposium language logic computation 
ht honda tokoro 
object calculus asynchronous communication 
ecoop volume lncs pages 
springer verlag 
mil milner 
communication concurrency 
prentice hall 
mpw milner parrow walker 
calculus mobile processes 
information computation 
ms milner sangiorgi 
barbed bisimulation 
icalp volume lncs pages springer verlag 
min minsky 
computation finite infinite machines 
prentice hall englewood cliffs 
plo plotkin 
structural approach operational semantics 
technical report university aarhus daimi fn 
pug pugliese 
process calculus asynchronous communication 
proc 
world scientific 
ss shepherdson sturgis 
computability recursive functions 
journal acm 
tau 
finite representations ccs programs automata petri nets 
volume lncs springer verlag 
