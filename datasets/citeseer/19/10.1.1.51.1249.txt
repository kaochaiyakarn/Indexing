logic programming database transactions anthony bonner michael kifer propose extension classical predicate calculus called transaction logic provides logical foundation phenomenon state changes logic programs databases 
transaction logic comes natural model theory sound complete proof theory 
proof theory verifies programs executes logic ideal tool declarative programming database transactions state modifying logic programs 
semantics transaction logic leads naturally features amalgamation single logic proved elusive past 
features include hypothetical committed updates dynamic constraints transaction execution non determinism bulk updates 
transaction logic holds promise logical model hitherto non logical phenomena including called procedural knowledge ai behavior object oriented databases especially methods side effects 
presents semantics transaction logic sound complete proof theory horn subset logic 
logics databases information systems updates crucial component database programming language 
simplest database transactions withdrawal bank account require updates 
unfortunately updates accounted classical horn semantics logic programs deductive databases limits usefulness real world applications 
short term practical solution logic programming languages resorted handling updates ad hoc operators logical semantics 
address problem provides theoretical foundations logic programming updates 
accomplished ways develop general logic state change called transaction logic including natural model theory ii show logic horn fragment procedural declarative semantics iii show programs logic executed sld style proof procedure logic programming tradition 
result rule language purely logical semantics sound complete proof theory users program execute database transactions 
absence updates language reduces classical horn logic 
represents conservative extension logic programming paradigm 
transaction logic short general logic state change accounts database updates transactions important related phenomena order update operations transaction abort rollback dynamic constraints bk bon 
applications areas including databases logic programming workflow management artificial intelligence 
applications practical theoretical discussed detail bk bon 
instance logic programming provides clean logical alternative assert retract operators prolog 
relational databases provides logical language programming transactions updating database views specifying active rules 
object oriented databases combined object oriented logics logic klw provide logical account methods procedures hidden inside objects manipulate objects internal states kif 
ai suggests logical account procedural knowledge planning subjunctive queries counterfactuals 
logics 
surface logics available specifying database transactions logics reason updates related phenomena time action 
despite plethora action logics researchers continue complain clear declarative semantics updates databases logic program logic transactions ming bee ban pdr 
particular database transaction languages founded action logics way query languages founded classical logic 
main reason believe reasoning action thing declarative programming especially database context 
difference manifests ways logics action designed database programming 
intended specifying properties actions relationships actions reasoning 
instance specify event comes event comes infer comes logics propositional notion database state query notion named procedures views subroutines 
logics poor candidates job formalizing database programming languages 
ii logics action designed reasoning programs 
logics typically separate languages procedural language representing programs logical language reasoning properties 
programs declarative logical akin algol 
logic inside programs specify database queries outside programs specify program properties 
exact opposite database languages logic programs 
goal programming declarative possible logic programming language significant part 
result difficult integrate action logics database query languages logic programs unnatural impedance mismatch 
iii logics action execute programs update database 
logics hypothetical 
best infer true program executed database unchanged inferences 
execute program update database separate runtime system needed outside logic 
contrary idea logic programming logical proof theory acts runtime system programs executed proving theorems 
iv logics action get bogged called frame problem mh rei problem logically specifying action 
instance robot picks block things change color block weight block number blocks course great unrelated facts change mass earth number planets solar system reason actions invariants specified logical axioms known frame axioms 
great deal research invested concisely 
fortunately frame axioms needed simply wants program execute transactions 
instance program logics databases information systems mers need specify frame axioms run time system reason frame axioms executing programs 
show applies database transactions expressed appropriate logic 
way frame axioms frame problem issue 
prolog 
database transactions defined prolog operators assert retract 
operators perform updates prolog addresses problems listed properties wish model programming language horn subset full logic ii programs executed sld style proof procedure separate run time system iii updates real hypothetical iv absence updates reduces classical horn logic frame problem issue 
unfortunately updates prolog non logical operations time programmer uses assert retract moves away declarative programming 
prolog support important features database transactions abort rollback 
reasons state changing procedures awkward prolog programs difficult understand debug maintain 
addition updates prolog integrated host logical system subset predicate calculus prolog 
clear assert retract interact logical operators disjunction negation 
instance assert assert mean 
assert 
assert retract 
logically account fact order updates important 
questions addressed prolog operational semantics classical theory logic programming 
transaction logic 
provides general solution aforementioned limitations prolog action logics 
solution consists parts general logic state change ii horn fragment supports logic programming 
horn fragment users specify execute transaction programs full logic users express properties programs reason bk 
develops syntax semantics full logic 
rest develops horn fragment shows provides logic programming language updates 
central feature development sld style proof procedure unification key requirement practical logic programming language 
proof procedure sound complete executes logic programs updates database proves theorems 
logic transactions horn fragment allows users combine elementary database operations complex logic programs 
logics action horn concerned axiomatization elementary operations logical combination programs 
logical axiomatization elementary operations needed reasoning properties actions programming executing 
axiomatizations carried full bk considered needed logic programming 
logic programming databases pascal application programmers spend little time specifying elementary operations devote great deal time combining complex transactions programs 
logic build programs simple operations main focus 
despite focus combining operations underlying set elementary operations important feature programming language determines domain application 
practice elementary operations vary widely 
example pascal changing value variable elementary operation 
prolog asserting retracting clause elementary 
database applications sql statements basic building blocks 
scientific engineering programs basic operations include fourier transforms matrix inversion squares fitting operations dna sequences grs 
workflow management systems elementary operations include number application programs legacy systems bsr 
cases elementary operations building blocks larger programs software systems built 
elementary operations vary dramatically logic combining 
fact control features arise 
features include sequential composition iterative loops conditionals subroutines recursion 
provides logical framework similar control features expressed 
framework orthogonal elementary operations 
set elementary database operations including destructive updates 
achieve flexibility treats database collection data types special purpose access methods 
methods provided elementary operations combined programs complex transactions 
approach separates specification elementary operations logic combining 
shall see separation main benefits allows develop logic programming language state changing procedures committing particular theory elementary updates ii allows accommodate wide variety database semantics classical non monotonic various nonstandard logics 
way provides logical foundations extending logics databases information systems logic programming paradigm host new applications set operations combined larger programs software systems 
due lack space interesting applications described 
likewise part logic deals hypothetical actions omitted corresponding applications counterfactuals 
interested reader referred bk development aspects extensions dealing concurrency communication described bk bon complexity results bon 
overview introductory examples specifying executing programs similar prolog 
specify programs user writes set logical formulas 
formulas define transactions including queries updates combination 
execute programs user submits logical formula theorem proving system acts run time system 
system executes transactions updates database generates query answers result proving theorems 
transactional features abort rollback handled theorem prover bon 
section provides simple examples showing kind behavior carried completely logical framework 
examples illustrate dimensions capabilities 
capabilities mentioned outset nondeterministic transactions 
non determinism useful areas especially suited advanced applications artificial intelligence 
instance user robot simulator instruct robot build stack blocks may say care blocks 
likewise user cad system request system run electrical line point fixing exact route form loose constraints run line close wet exposed areas 
transactions final state database indeterminate predicted outset depends choices system run time 
enables users say choices allowed 
user issues non deterministic transaction system particular choices 
choices may implementation dependent process guided sound complete inference system database ends allowed new states 
elementary applications transaction execution characterized just initial final state sequence intermediate states database passes 
example robot simulator piles block block block transaction execution pass logic transactions state state state 
final state intermediate states may uniquely determined start execution 
example robot may non deterministic choice block grasp 
call sequence database states execution path transaction 
represents execution paths explicitly 
doing express wide range constraints transaction execution 
example user may require intermediate state satisfy condition may forbid certain sequences states 
execution transactions formally described statements called executional entailment express form logical entailment dn formula database states set formulas called transaction base 
intuitively set transaction definitions transaction invocation dn sequence database states representing states transaction execution 
formal semantics statement means formula true respect sequence dn informally means sequence execution path transaction 
current database state user issues transaction typing gamma prolog database may go state state state reaches state dn transaction terminates 
emphasize word may non deterministic transaction 
execution paths proof theory derive paths non deterministically selected actual execution path final state dn path new database 
formalisms transaction logic neutral question queries updates syntactically distinct 
perfectly compatible distinctions force user 
formally transaction programs represented logical formulas built class query formulas update formulas 
fact formula oe cause state change viewed query 
state affairs formally expressed statement oe special case statement 
case sequence databases length 
approach provides flexible framework users kinds distinctions wish 
instance uniform treatment queries updates needed object oriented domain object oriented systems sharply distinguish state changing information retrieving methods kif 
hand syntactic dis logics databases information systems desired sorts predicates queries updating transactions 
philosophy quite different situation calculus mh approaches dynamic process logics har queries updates represented different classes syntactic objects predicates vs function terms vs modal operators 
rest section illustrates notation capabilities number simple examples 
examples illustrate uses logical operators combine simple actions complex ones 
simplicity examples horn insertion deletion individual tuples relational databases 
represent relational databases usual way sets ground atomic formulas 
noted restricted relational databases update operations single tuples 
instance databases deductive object oriented disjunctive collection scientific objects matrices dna sequences 
likewise database operations include bulk updates bk insertion deletion rules complex scientific calculations fourier transform matrix inversion 
simple transactions transactions combination queries updates 
queries change database expressed classical logic 
contrast updates change database expressed extension classical logic 
call simplest kind updates elementary updates elementary state transitions represent atomic formulas 
formulas truth value side effect database 
formally write executional entailment says atomic formula name update changes database state state atomic formula update programming practice reserve special set predicate symbols purpose 
example predicate symbol predicate symbol ins represent insertions likewise predicate symbol del represent deletions example elementary updates suppose president binary predicate symbol 
atoms president del usa bush president ins usa clinton elementary updates 
intuitively president del usa bush means delete logic transactions atom president usa bush database 
likewise atom president ins usa clinton means insert president usa clinton database 
user perspective typing gamma president del usa bush interpreter changes database gamma usa bush likewise typing gamma president ins usa clinton changes database usa clinton express behavior formally statements true transaction base gamma usa bush president del usa bush usa clinton president ins usa clinton gamma denote set union difference respectively 
sufficient relational databases sets ground atomic formulas 
complex databases insertion deletion complex operations km :10.1.1.26.2661
note insertion deletion built semantics fact committed particular set elementary updates 
intrinsic connection names ins del names merely convention purposes illustration 
fact ins del ordinary predicates connection established called transition oracle explained 
basic way combining transactions sequence execute 
example may take money account withdrawal succeeds deposit money account 
combine transactions sequentially extend classical logic new binary connective omega called serial conjunction 
formula omega oe denotes composite transaction consisting transaction followed transaction oe 
elementary updates sequential transactions intermediate states initial final states 
express behavior formally statements omega oe means executing transaction gamma omega oe changes database initial state intermediate state final state 
example serial conjunction expression came omega saw ins omega conquered ins came saw conquered ground atomic formulas denotes sequence insertions preceded test 
transaction means check came true logics databases information systems insert saw database insert conquered 
initial database user issues transaction typing gamma came omega saw ins omega conquered ins execution database change provided came initially true express behavior formally statement holds transaction base came true came omega saw ins omega conquered ins example illustrates preconditions 
express postconditions tests intermediate database states just naturally 
rules non deterministic transactions rules formulas form oe atomic formula oe formula 
classical logic formula just convenient abbreviation oe 
formal declarative interpretation rules 
operationally formula oe means execute sufficient execute oe 
interpretation important provides subroutine facility logic programming possible 
instance rule oe predicate symbol acts name procedure variable acts input parameter formula oe acts procedure body definition exactly horn clause logic programming 
rule body may formula frequently serial conjunction 
case rule form omega omega omega atom 
rules users define transaction subroutines write transaction logic programs 
note facility possible transactions represented predicates distinguishes logics action actions modal operators function terms 
logics subroutines awkward impossible express 
notational convenience assume free variables rule universally quantified outside rule 
rule oe simply abbreviation oe 
example tossing coins coin head mean coin lying face 
likewise coin tail means tail facing 
transaction base defines action flipping coin toss coin coin ace omega del coin ace omega ins coin head toss coin coin ace omega del coin ace omega ins coin tail toss coin logic transactions coin say dime rules say ways toss dime determine side dime facing delete fact database insert dime head insert dime tail 
third possibility coin 
gamma toss dime non deterministic transaction 
formally dime initially head side tossing dime represented statements fup dime head fg fup dime head toss dime fup dime head fg fup dime tail toss dime fup dime head toss dime means know advance exact outcome action 
transaction bases section gives simple realistic examples transaction bases comprised finite sets rules 
examples show updates combined queries define complex transactions 
example financial transactions suppose balance bank account act relation balance act amt 
modify relation provided pair elementary update operations balance del act amt delete tuple relation balance ins act amt insert tuple relation 
updates define transactions balance change act bal bal change balance account withdraw amt act withdraw amount account deposit amt act deposit amount account transfer amt act act transfer amount account 
transactions defined rules transfer amt act act withdraw amt act omega deposit amt act withdraw amt act balance act omega amt omega balance change act gamma amt deposit amt act balance act omega balance change act amt balance change act balance del act omega balance ins act second third rule atom balance act acts query retrieves balance specified account 
atoms updates 
logics databases information systems example uses robot actions illustrate non deterministic rules 
planning robot actions discussed detail bk 
example non deterministic recursive robot actions transaction base simulates movements robot arm world toy blocks 
states world defined terms database predicates says block top block says top block wider says strictly wider rules define actions change state world 
action evaluates premises order action fails premises fails case database left original state 
stack omega move omega stack gamma stack move pickup omega putdown pickup omega omega del omega ins putdown wider omega omega ins omega del actions pickup putdown mean pick block put block top block wider respectively 
defined terms elementary inserts deletes database relations 
remaining rules combine simple actions complex ones 
instance move means move block top block stack means stack arbitrary blocks top block 
actions pickup putdown deterministic set argument bindings specifies robot action 
contrast action stack non deterministic 
perform action inference system searches database blocks stacked represented variable 
step blocks placed top stack system arbitrarily chooses 
observe rules easily rewritten prolog form replacing omega replacing elementary state transitions assert retract 
resulting seemingly innocuous prolog program execute correctly 
problem prolog updates undone backtracking 
instance suppose move action robot picked blka widest block table 
move action logic transactions fail robot put blka stack blka wide 
inference system simply backtracks tries find block pick 
prolog backtrack leave database incorrect state undo pickup action 
blka previously top blka remain deleted stay database 
constraints classical conjunction constrains non determinism transactions 
general transaction oe deterministic oe execution oe allowed execution allowed execution oe 
illustrate consider conjunction robot actions go kitchen pass bedroom conjunct non deterministic action ways carried 
composite action constrained conjuncts 
way conjunction reduces nondeterminism allows user specify done 
formulation example formula section note classical conjunction cause conjuncts executed separate transactions 
combines single tightly constrained transaction constrains entire execution transaction just final state 
general constrains transactions ways causing transactions fail ii forcing nondeterministic transactions execute certain ways 
example transaction failure consider pair sequential transactions gamma bought ins omega wanted ins gamma wanted ins omega bought ins 
transactions transform database state state 
pass different intermediate states passes state passes state 
conjunction bought ins omega wanted ins wanted ins omega bought ins fails single sequence states valid execution path conjuncts 
formally statements true bought ins omega wanted ins wanted ins omega bought ins logics databases information systems statement false sequence databases dn dn bought ins omega wanted ins wanted ins omega bought ins example reducing non determinism consider pair non deterministic transactions gamma lost ins ins gamma lost ins won ins 
starting database follow path terminate 
fact database reached transactions 
execution transaction gamma lost ins ins lost ins won ins final database state 
formally true lost ins ins lost ins won ins iff way classical conjunction reduces non determinism particular example yields completely deterministic transaction 
bk explore potential expressing constraints 
expressiveness comes serial conjunction especially combined negation 
example formulas natural meaning constraint omega omega means sequence omega omega allowed 
oe omega means transaction immediately follow transaction oe 
oe omega means transaction immediately follow transaction oe 
formulas simplified dual operator phi called serial disjunction 
example formula rewritten oe phi 
repertoire executional constraints expressible large 
easy specify transactions overlap start simultaneously terminate bk show full set temporal relationships allen logic time intervals simple natural representation specific role expressing constraints traditional role forming logic programs classical logic finite set rules equivalent conjunction rules set 
logic transactions syntax section begins formal development define alphabet language consist symbols countably infinite set variables 
countably infinite set function symbols 
symbol non negative arity indicating number arguments take 
infinitely symbols arity 
constants treated ary function symbols 
countably infinite set predicate symbols 
functions predicate symbols arity infinitely predicate symbols arity 
ary predicate symbols viewed propositional constants 
logical connectives classical disjunction conjunction omega serial conjunction classical negation 
additional connectives defined terms 
quantifiers 
auxiliary symbols 
terms defined usual order logic variable term ary function symbol terms term 
write 
adopt prolog convention variables upper case function constant symbols lower case 
transaction formulas extends syntax order predicate logic new binary connective omega called serial conjunction 
resulting logical formulas called transaction formulas 
formally transaction formulas defined recursively follows 
atomic transaction formula expression form predicate symbol terms 
second oe transaction formulas expressions oe oe oe omega oe 
oe oe variable 
examples transaction formulas omega omega omega logics databases information systems informally formula oe omega means oe slightly formally point time oe finishes starts 
note classical order formulas transaction formulas omega classical logic introduce convenient abbreviations complex formulas 
instance oe abbreviation oe transaction formulas oe 
useful define phi called serial disjunction logical dual omega oe phi oe omega 
informally oe phi means point time oe finishes starts 
elementary operations classical logic theories come parameter language constructing formed formulas 
language fixed set constants variables predicate symbols plugged 
likewise theories parameterized language 
addition semantic parameter pair oracles called data oracle transition oracle specify elementary database operations 
data oracle specifies set primitive database queries static semantics states transition oracle specifies set primitive database updates dynamic semantics states 
oracles encapsulate elementary database operations 
language logic oracles fixed pair oracles plugged theory 
state data oracles goals underlying design general deal kind database state including relational databases general deductive databases 
may tempted define state arbitrary order formula close issue 
things turn involved 
thing stating database state order formula determine set truths state 
databases logic programming usually assigns non standard semantics database states clark completion founded model semantics llo gl 
chosen insulate dynamic aspects transaction execution static aspects pertaining truth database states 
allow transaction logic different database semantics enables study dynamics statics databases separately 
problem logically equivalent order formulas may represent different database states 
instance databases logic programming fp qg viewed different state fq pg logic transactions formulas classically equivalent 
database considered true false second state just opposite 
achieve needed generality semantics states specified state data oracle 
assume countable set symbols called state identifiers oracles refer database states 
note symbols part language just oracles part 
transaction formulas address database states oracles directly 
state identifiers oracles define semantics proof theory definition state data oracle state data oracle mapping set state identifiers sets closed order formulas 
intuitively state identifier set formulas considered truths known state 
practice necessary materialize truths 
logical formulas oe state identifier proof theory needs know oe 
inference enumeration needed 
state id uniquely identifies state shall terms state state id interchangeably 
right intuition examples order formulas fact relational databases state identifiers 
appropriate useful oracles conveniently described terms formulas 
results definitions depend representation general construct state identifier 
get better grasp idea oracle database state section provides typical examples 
state transition oracles step specify elementary changes database 
way define changes build semantics mw nk bon bon che av mcc 
problem approach adding new kinds elementary transitions requires redefining notion model entails entire theory including need soundness completeness results 
words theories extensible 
problem aggravated fact arbitrary logical databases semantics elementary updates clear relatively simple updates insert delete 
example mean insert atom database entails especially explicitly database 
insertion fqg fp qg insertion fq pg 
true answer question logics databases information systems solutions proposed see km comprehensive discussion :10.1.1.26.2661:10.1.1.26.2661
furthermore katsuno mendelzon km pointed generally state transitions belong major categories updates revisions category different flavours transitions worth looking :10.1.1.26.2661
appears small single set elementary state transitions best purposes 
reason committing fixed set elementary transitions chosen treat elementary state transitions parameter set elementary transitions gives rise different version logic 
achieve elementary state transitions specified outside notion state transition oracle 
way elementary transitions separated issue specifying complex transactions 
procedural declarative language specifying elementary transitions 
definition state transition oracle state transition oracle mapping ordered pairs state identifiers sets ground atomic formulas 
refer ground atoms elementary transitions 
intuitively state identifiers set elementary updates transform state state elementary update non deterministic update transition oracle defines binary relation states 
practice relation materialized 
update state proof theory needs enumeration possible successor states transition oracle returns ground atoms elementary updates completely specified 
see suppose contained formula intuitively mean transforms database state state know 
names elementary transitions ins del section special status ordinary atomic formulas just happen mentioned oracle 
principle prevents user putting rules ins transaction base 
fancy names predicates convention adopted illustrative purposes 
examples section gives examples data transition oracles 
examples database state set data items persistent object tuple disk page file logical formula 
formally database state structure access logic transactions oracles 
oracles combined yield powerful oracles 
typically combinations possible oracles operate disjoint domains data items 
relational oracles 
state identifier set ground atomic formulas 
data oracle simply returns formulas 
predicate symbol transition oracle defines new predicates ins del representing insertion deletion single atoms respectively 
formally ins iff fp likewise del iff gamma fp sql style bulk updates defined transition oracle bk primitives creating new constant symbols 
scientific oracles 
state set square matrices 
matrix state data oracle defines ternary relations dft representing matrix dimensional discrete fourier transform dft respectively 
formally iff likewise dft iff dft way data oracle provides built views matrix 
transition oracle defines predicates set update matrix predicate sets value element matrix 
formally set iff just state likewise swaps rows matrix swaps columns note main memory systems updates implemented efficiency comparable variable assignment efficiently assert retract prolog 
classical oracles 
state consistent set variable free classical order formulas 
data oracle defines logical implications formulas 
denotes classical entailment 
transition oracle defines primitives adding removing formulas database resolving conflicts new formulas existing formulas 
conflicts resolved numerous ways shown katsuno mendelzon km :10.1.1.26.2661
instance order formula transition oracle define predicates update erase revise contract doing updates erasure revision contraction defined km :10.1.1.26.2661
founded oracle 
state id set generalized horn rules set literals positive negative founded model 
oracles represent rule base logics databases information systems founded semantics includes horn rule bases stratified rule bases locally stratified rule bases 
advanced applications may want augment rules transition oracle provides primitives adding deleting clauses states 
generalized horn oracles 
state id set generalized horn rules classical herbrand model oracles represent horn rule bases stratified rule bases locally stratified rule bases rule bases stable model semantics gl rule base meaning classical herbrand model 
may want augment rules transition oracle provides primitives adding deleting clauses states 
pragmatics oracles formulas transaction base expect oracles coded casual users 
oracles allow different semantics states state changes envision logic programming system carefully selected repertoire built database semantics tightly controlled mechanism adding new ones 
mechanism available ordinary programmers 
reason assume data transition oracles fixed 
unfortunately general solution practical problem oracles best implemented 
classical oracle described problem partly solved grahne mendelzon winslett gm win 
winslett showed general problem updating propositional formulas np hard 
subsequently grahne mendelzon proved updating sets ground atoms arbitrary propositional formulas done polynomial time 
importantly result carries deductive databases extensional part updated 
case relational databases updates fast straightforward 
design issue specifying implementing elementary operations orthogonal 
data transition oracles external parameters matters practically existence algorithm compute outcome operation enumerate possible outcomes operation non deterministic 
note transaction definitions independent oracles 
point contributes making lucid flexible language defining transaction programs 
logic transactions model theory just syntax basic ideas serial conjunction elementary transitions semantics fundamental ideas transaction execution paths database states executional entailment transaction execution paths 
user executes transaction database may change going initial state state 
doing execution may pass number intermediate states 
example execution gamma ins omega ins omega ins takes relational database initial state intermediate states fag fa bg final state fa cg 
idea sequence states central semantics 
allows model wide range constraints 
example may require intermediate state satisfies condition may forbid certain sequences states 
model transactions start modal semantics state represents database elementary update causes transition state changing database 
point modal logic transaction logic part 
major difference truth structures hinge set arcs states 
focus paths sequences states 
emphasis paths refer semantic structures path structures 
second truth path structures defined paths states 
example say path fag fa satisfies formula ins omega ins 
intuitively formula represents transaction inserts inserts path represents complete execution transaction 
contrast shorter paths fa satisfy formula represent complete executions transaction 
example illustrates general property formula may true path false proper subpaths 
kind transaction formula represents depends paths satisfy 
paths length consist single state transaction query paths length transaction usually elementary update paths length greater transaction composite update 
paths various lengths different executions transaction program correspond different kinds transaction 
way model theoretic device paths accounts queries updates general transactions 
logics databases information systems database states 
difference modal logic transaction logic nature states 
modal logic state basically order semantic structure state specifies truth set ground atomic formulas 
structures adequate representing relational databases representing general theories indefinite databases general logic programs 
take general approach 
modal logic set states may vary semantic structure semantic structure set states determined data oracle 
changing oracles change set states set semantic structures 
way different oracles give rise different versions executional entailment 
logics action notion truth associated properties actions formulas evaluated states 
instance dynamic logic ff oe true current state oe true state results executing update ff 
notion truth associated execution formulas evaluated paths sequences states 
notion executional entailment provides logical account execution described detail section 
path structures models section preceding discussion precise 
formal definition path structures relies familiar notion classical order semantic structures 
symbol denotes satisfaction structures classical satisfaction 
purposes convenient augment classical structures special structure denoted 
define satisfy order formula 
classical structure shall call classical adding classical logic change logic essential way simply adds model formula notions satisfiability consistency require minor adjustments 
having convenient provides degree tolerance inconsistency may exist database states views 
simple adaptation techniques paraconsistent logics kl analyze knowledge contained inconsistent states 
reader referred bk bk discussion 
described section comes language determines syntax formulas pair oracles determine semantics databases oracles come set database state identifiers states 
define path length path finite sequence states hd 
rest logic transactions language oracles set database states corresponding set paths implicit 
definition path structure domain objects interpretation function symbols 
interpret formulas path structure 
definition path structures order language function symbols predicate symbols path structure quadruple hu path domain interpretation function symbols assigns function gamma 
ary function symbol struct denote set classical order semantic structures form hu mapping interprets predicate symbols relations accordance earlier assume struct contains special classical structure 
path total mapping assigns path order semantic structure struct subject restrictions compliance data oracle path hdi oe formula oe 
compliance transition oracle path hd atom 
mapping path serves semantic link transactions paths path transaction formula path determines formula true path definition 
intuitively compliance restriction says path hdi provides window database formula true true path hdi 
second compliance restriction says elementary updates transition oracle claims 
points path structures worth noting 
points reflect flexibility built path allows model knowledge encoded transaction base 
compliance oracles way 
formulas formulas true path hdi 
likewise formulas formulas true path hd oracles source logics databases information systems formulas 
particular transaction base supplies formulas formulas true paths shall see 

arbitrary path semantic structure path independent subpaths 
intuitively means know relationship transactions subtransactions 
knowledge exists encoded transaction base 
definition satisfaction relates paths subpaths shall see 
defining satisfaction convenient define path splits 
path hs state path defines split path parts hs hs path split parts fl ffi write fl ffi ffi classical logic variable assignments define semantics open quantified formulas 
variable assignment mapping gamma 
takes variable input returns domain element output 
mapping extends variables terms usual way 
definition satisfaction hu path path structure path variable assignment 

path atomic formula 

oe oe 

oe oe 

usual meaning dual oe oe 

oe omega fl oe ffi split fl ffi ffi path 

meaning phi dual omega oe phi fl oe ffi split fl ffi ffi path 

oe oe variable assignment agrees variables 
meaning dual oe oe variable assignment agrees variables logic transactions classical logic variable assignment omitted sentences formulas free variables 
deal sentences explicitly stated 
items definition interpreted terms programming languages 
instance item establishes relationship path subpaths 
corresponds relationship program components 
intuitively formula oe omega program execute path path corresponds execution oe followed execution 
example item allows atoms true arbitrary paths 
horn atoms play role subroutine calling sequences 
intuitively atom subroutine name arguments exactly classical logic programming 
executing subroutine corresponds finding path true 
definition models transaction formulas path structure model formula oe denoted oe oe path path structure model set formulas model formula set 
usual order logic define oe oe mean oe resp oe mean oe oe 
replacing phi obtain interesting pair serial connectives left serial implication oe stands phi oe right serial implication oe denotes oe phi 
intuitively formulas say action oe immediately preceded resp followed action 
connectives identical oe equivalent oe oe equivalent oe 
easy verify path structure model formulas analogous de morgan laws oe omega oe omega omega oe phi oe phi phi oe phi oe phi phi oe omega 
oe omega omega dualities easy verify oe oe oe phi oe omega xoe oe execution entailment define executional entailment concept connects model theory transaction execution 
recall program consists distinct parts transaction base initial database state logics databases information systems parts database updatable 
transaction base contains logical rules define complex queries transactions normally composed formulas containing serial connectives omega phi classical order formulas allowed 
contrast database precisely data oracle tells consists entirely classical formulas 
definition executional entailment transaction base oe transaction formula dn sequence databases order formulas 
statement dn oe true hd dn oe model related statement oe true iff database sequence dn true 
intuitively statement means successful execution transaction oe change database state dn formally means model satisfies oe path hd dn normally users issuing transactions know initial database state know execution path advance cases just want reach final state execution 
account situation version entailment allows omit intermediate final database states 
intuitively statement means transaction oe execute successfully starting database context clear simply say transaction oe succeeds 
likewise statement true say transaction oe fails 
section inference system allows compute database sequence dn satisfies statement transaction succeeds 
example executional entailment suppose contains rules ins omega ins del omega del relational oracle described section statements true logic transactions fg fag fa bg ins omega ins fa bg fbg fg del omega del fg fag fa bg fa bg fbg fg fg fag fa bg fa bg fbg fg fg fag fa bg fbg fg omega fg fag fa bg fbg fg omega statements true fg ins omega ins fa bg del omega del fg fa bg fg fa bg fg omega fg omega lemma basic properties executional entailment transaction base database sequence dn closed transaction formulas ff fi statements true 
dn ff dn fi dn ff fi 

ff dn fi dn ff omega fi 

ff fi dn fi dn ff 

ff ff 

ff ff 
items ff order formula denotes classical entailment 
note lemma suggests simple inference system items axioms items inference rules 
corresponds special case transaction update database acts query 
case classical serial conjunction identical lemma conjunctive queries transaction base database state transaction formulas ff fi ff fi ff omega fi logics databases information systems intuitively lemma says result evaluating conjunctive query conjuncts evaluated sequentially classical fashion 
fact prove stronger result show absence updates serial conjunction reduces classical conjunction serial disjunction reduces classical disjunction executional entailment reduces classical entailment lemma relationship classical logic transaction base set order formulas derived replacing occurrence omega occurrence phi order formula ff database ff ff special case classical oracles ff ff proof theory classical logic horn subset called serial horn simple sld style proof theory gives serial horn programs procedural semantics 
property allows user program transactions logic 
section defines serial horn subset develops proof theory 
classical logic programming proof procedure section computes new database states query answers 
detailed development proof soundness completeness bk 
serial horn programs idea serial goal 
serial goal transaction formula form omega omega omega atomic formula 
write denotes empty goal 
serial horn rule form omega omega omega body omega omega omega serial goal head atom 
rules section serial horn 
serial horn transaction base simply finite set serial horn rules 
observe serial horn transaction base transformed classical horn rulebase replacing occurrence omega transformation changes serial horn rule omega omega classical horn rule lemma implies absence updates executional entailment horn reduces ordinary entailment classical horn logic 
classical horn logic special case serial horn horn fragment database states represented generalized horn oracle described section 
say combination logic transactions transaction base generalized horn data oracle serial horn set serial horn rules satisfying independence condition database state predicate symbols occurring rule heads occur rule bodies 
intuitively independence condition means database define predicates terms transactions 
rule database rule transaction base rule database 
independence condition arises naturally situations database relational set atomic formulas ii conceptual distinction desired updating actions non updating queries 
case database trivially independent database atom empty premise 
case logic sorts predicates query predicates action predicates 
action predicates defined transaction base query predicates defined database 
action predicates defined terms query predicates express pre conditions post conditions viceversa 
serial horn conditions support essential features logic programming paradigm 
instance classical horn rules conditions viewed demand complete information serial horn rules imply actions completely specified generalized horn oracles imply database states completely specified contain indefinite disjunctive information 
described conditions lead simple practical sld style inference system logic programming tradition 
addition serial horn conditions extended accomodate negation failure 
possible classical horn rules set serial horn rules unique minimal herbrand model 
fact theory negation classical logic programs carries transaction logic programs straightforward way including familiar notions stratification abw local stratification prz 
negation subject interested reader referred bk bk details 
serial horn expressive logic useful programs non horn 
programs negated premises just example 
examples involve dynamic constraints applied programs serial horn see section 
instance suppose predicate goto defined serial horn program intuitively means go location 
non horn formula intuitively means go kitchen logics databases information systems passing bedroom goto kitchen path omega bedroom omega path path abbreviation true paths 
observe addition serial conjunction formula involves classical conjunction disjunction negation 
kinds dynamic constraints described detail bk 
inference describe inference system called checking statements form transaction successfully execute starting state inference succeeds finds execution path transaction sequence databases dn dn 
shall see certain inference strategies generate execution path way corresponds intuitive notion transaction execution 
particular top inference corresponds forward execution normal kind bottom inference corresponds reverse execution described 
bk introduce dual system ii useful bottomup transaction execution 
additionally hypothetical transactions allowed bk describes uniform inference system ii complete presence hypothetical modal operators 
systems formulated natural deduction systems 
possible formulate refutation systems 
serial horn case transaction existential serial conjunction formula form omega omega omega am atomic 
free variables assumed existentially quantified omit reminder leave front transactions 
note existential quantification consistent traditions logic programming databases 
inference rules focus left transactions 
highlight focus write serial conjunctions oe omega rest oe piece conjunction inference system currently focussed rest rest conjunction 
definition inference transaction base system axioms inference rules database state identifiers 
axioms inference rules rules oe substitution atomic formulas oe rest serial goals 
logic transactions 
applying transaction definitions suppose oe rule variables renamed rule shares variables omega rest 
unify mgu oe oe omega rest oe omega rest 
querying database boe share variables boe rest oe omega rest 
performing elementary updates boe share variables boe rest oe omega rest inference system manipulates expressions form oe called sequents 
informal meaning sequent transaction oe succeed executed path emanating database inference rule consists sequents interpretation upper sequent inferred lower sequent inferred 
starting axiom sequents system repeatedly applies inference rules infer sequents 
understand inference system note axioms describe empty transaction 
transaction succeeds 
inference rules describe complex transactions capturing roles transaction base database transition base respectively 
interpret rules follows rule replaces subroutine definition oe calling sequence rule attaches pre condition front transaction rest 
rule change current database state attaches elementary update front transaction rest resulting transaction starts state unifier oe practical sld style inference system returns unifiers answers prolog see section 
classical resolution instance answer substitution valid answer query 
logics databases information systems definition general deduction inference system deduction proof sequent seq series sequents seq seq seq gamma seq seq axiom derived earlier sequents inference rule 
theorem soundness completeness serial horn conditions executional entailment oe holds deduction sequent oe 
execution deduction having developed inference system proving statements form oe come back original problem proving statements form dn oe initial database state state moment transaction oe began executing 
note moment intermediate states dn gamma final state dn unknown 
important task inference system compute states 
general notion deduction tight conveniently general deduction may record execution unrelated transactions mixed haphazard way 
interested execution particular transaction introduce specialized notion executional deduction sacrificing completeness defines narrower range deductions definition 
definition executional deduction transaction base 
executional deduction transaction oe deduction seq seq satisfies conditions 
initial sequent seq axiom 

sequent seq obtained previous sequent seq gamma inference rules system seq gamma numerator rule seq denominator 

final sequent seq form oe database theorem remains valid deductions required executional 
stronger form deduction prove stronger results 
theorem instance specify execution path transaction 
executional deduction 
execution paths easily extracted executional deductions 
key observation system applies elementary transitions exactly logic transactions oe delta delta delta 
oe inference rule delta delta delta 
oe inference rule delta delta delta 
dn construction executional deduction deduction involves inferences sequents initial sequent final sequent 
deduction includes changes state carried inference rule inferences sequent sequent 
inference rule invoked 
invoking rule inference analogue executing elementary transition 
need pick points executional deduction inference rule applied 
define execution path deduction sequence dn theorem provides model theoretic meaning execution paths 
relates executional deduction executional entailment definition 
theorem executional soundness completeness serial horn conditions executional entailment dn oe holds executional deduction oe execution path dn constructing executional deductions execute transactions 
shows constructing deduction top database systematically updated dn call forward execution 
likewise constructing deduction bottom database systematically updated dn dn gamma call reverse execution 
process constructing deductions executing transactions developed detail bk 
logics databases information systems example inference unification prolog inference system returns substitution 
substitution specifies values free variables transaction succeeds 
example similar example robot simulator moves blocks table top 
consider transaction base containing rule describes effect picking block pickup omega omega del omega ins suppose order robot pick block typing gamma pickup 
block left unspecified transaction non deterministic 
inference system attempts find value enables transaction succeed updating database process 
illustrate suppose initial database represents arrangement blocks blka top stands 
robot picks blka database changes state blka blka blka blka executional deduction robot picks blka shown 
sequent derived sequent immediately inference rule bottom sequent axiom 
inference involves unifying leftmost atom transaction database fact returned data oracle transaction name defined transaction base elementary transition returned transition oracle 
example deriving sequent sequent inference system unifies atom transaction atom blka database way system chooses pick blka 
likewise deriving sequent sequent inference system unifies atom blka transaction atom blka database 
way system retrieves block blka resting 
note line table shows items numbered sequent inference rule deriving sequent unifying substitution 
answer substitution obtained composing unifiers yields fx blka projecting substitution yields fx 
operational interpretation proof robot picked blka 
logic transactions rule unifier sequent pickup omega omega del omega ins blka blka omega del blka omega ins del blka omega ins ins executional deduction pickup related vast amount related research 
section examines selection closely related works 
comprehensive comparison bk 
convenience divide formalisms classes aimed specifying database transactions aimed reasoning programs 
outset mention feature distinguishes formalisms described state transition oracles support arbitrary notions state update 
contrast formalisms assume state relational database updates limited insertion deletion tuples 
support inserting rules deductive database inserting disjunctions disjunctive database 
formalisms database oriented come tradition procedural programming languages 
typically assume state set program variables update changes variable value 
declarative languages database transactions dynamic prolog 
warren mw developed dynamic prolog logic programming language database transactions 
language far similar instance dynamic prolog logic programming languages account just updates transaction abort rollback 
proof theory dynamic logics databases information systems prolog impractical carrying updates know final database state inference begins 
proof theory verification system initial state final state transaction program proof theory verifies program causes transition just initial state program compute final state 
words proof theory execute transaction programs proof theory 
apparently realizing drawback warren developed interpreter aim execute transactions 
interpreter incomplete respect model theory furthermore proof theory 
certain extent said warren managed formalize intuition program inference system 
addition differences dynamic prolog instance dynamic prolog assumes databases relational support bulk database updates constraints program execution 
furthermore execution path dynamic prolog consists initial final state record intermediate states 
consequence impossible express constraints transaction execution needed advanced applications ai workflow management bk 
ldl 
naqvi krishnamurthy nk extended datalog update operators incorporated ldl language nt 
ldl geared database applications extension bulk updates operational semantics exists 
unfortunately model theory nk nt somewhat limited 
matches execution model ldl propositional case cover bulk updates 
second defined update programs commutativity elementary updates assumed 
sequences updates hold semantics turns tricky certainly qualify model theoretic 
third definition legal programs nk nt highly restrictive making difficult build complex transactions simpler ones 
chen calculus 
chen developed calculus equivalent algebra constructing transactions che 
calculus uses logical operators construct database transactions elementary updates 
differences 
calculus part full logic 
second assumes databases relational 
third different semantics conjunction 
specifically uses express dynamic constraints chen calculus uses express parallel actions 
main motivation parallel actions bulk updates easy express logic transactions important database feature 
disadvantages way achieved 
calculus express kind dynamic constraints bk expresses bulk updates means bk 
second parallel actions greatly complicate semantics require minimality principle algebra non monotonic absence negation 
third syntax closed 
instance negation applied formulas 
particular updating transaction rules allowed equivalent formula meaning chen calculus 
calculus developed full logic straightforward satisfying way 
furthermore calculus limited programming language mechanism defining recursion subroutines 
abiteboul vianu update languages 
abiteboul vianu developed family datalog style update languages av abi including comprehensive results complexity expressibility 
transaction logic languages part full logic arbitrary logical formulas constructed operational semantics corresponding model theory logical inference system 
addition languages lack features assume databases relational 
second support subtransactions partial abort rollback 
third facility constraining program execution program output concern 
fourth support subroutines 
seen clearly procedural languages defined av 
lack subroutines reflected pspace data complexity languages subroutines lead alternating pspace exptime bon 
logics reasoning programs dynamic logic process logic 
dynamic logic har process logic allow user express properties procedural programs reason 
dynamic logic reasons initial final states program execution 
speak result execution program terminates value 
process logic extends ability reason intermediate states 
speak happens execution iteration loop value 
process logic dynamic logic model consists set states actions cause transitions state 
emphasis intermediate logics databases information systems states semantics closely related process logic dynamic logic 
instance process logic formulas evaluated states paths sequences states 
process logic dynamic logic logic programming languages 
difference shows ways 
process logic dynamic logic represent programs procedurally sets logical rules 
second sld style proof procedure executing programs 
fact intended executing programs reasoning properties 
third process logic dynamic logic logic outside programs specify properties 
particular logic constructing programs specifying database queries 
fourth process logic dynamic logic designed database programming 
instance notions database query support named procedures subroutines views 
mccarty van der meyden 
mccarty van der meyden develop theory reasoning indefinite actions 
orthogonal main similarity works concerned defining complex actions terms simpler ones works actions may non deterministic indefinite 
address action execution updating databases 
give idea consider transaction base consisting exactly rules omega omega omega main point complex actions defined terms elementary actions 
effects elementary actions specified oracle invoked execute 
contrast mechanism specifying effects elementary actions 
focuses closed world inferences form told action occurred infer action omega omega occurred action omega occurred action occurred 
occurrence action implies occurrence action technical differences 
instance allow function symbols rules define complex actions reasoning problems undecidable outside re 
addition committed particular model states 
basic theory different circumscription second order intuitionistic logic 
logic transactions earlier mccarty outlined logic action part larger proposal reasoning deontic concepts mcc 
proposal contains distinct layers logic order predicate logic logic action logic permission obligation 
ways layers similar especially action layer uses logical operators construct complex actions elementary actions 
interest deontic concepts mccarty defines notions satisfaction 
notion called strict satisfaction conjunction corresponds parallel action chen che 
notion called satisfaction symbol corresponds constraints focus strict satisfaction development dynamic constraints considered 
analogue transition oracle elementary updates considered correspond insertion deletion atomic formulas 
unfortunately promising proposal developed detail 
instance model theory sequences partial states sound complete proof theory mechanism executing actions updating database 
situation calculus 
situation calculus methodology specifying effects elementary actions order classical logic 
introduced mccarthy mcc developed mccarthy hayes mh 
database perspective transactions specified situation calculus insert delete atomic formulas arbitrary logical formulas 
transactions add new rules deductive database add tuples null values relational database disjunctions disjunctive database 
limitations apply transactions representation language situation calculus strictly powerful full situation calculus axiomatize effects elementary actions reason ability combine actions limited 
instance support loops conditionals subroutines recursion non deterministic choice 
formally situation calculus subset order classical logic subset situation calculus subsumed full hand methodology classical logic independent logical system situation calculus orthogonal horn horn emphasizes combination elementary actions complex ones specification elementary actions 
situation calculus reverse emphasizes specification elementary actions combination complex actions 
formalisms hand glove 
specifically oracle mechanism horn combine elementary actions specified situation calculus 
logics databases information systems difference mentioned earlier frame problem arise horn language programming executing transactions reasoning 
fact frame problem issue theory examples 
contrast frame problem central issue situation calculus mh rei 
frame problem issue full reason properties actions context frame axioms unavoidable bk 
reiter theory database evolution 
main stream ai treating situation calculus mere curiosity years received renewed development reiter 
particular reiter developed approach frame problem suffer usual blow number frame axioms rei 
original situation calculus entirely order mcc mh reiter development includes induction axiom specified second order logic reasoning action sequences rei 
applying approach reiter developed logical theory database evolution rei 
theory perfectly compatible oracle mechanism theory specify semantics database states elementary actions 
horn combine actions complex programs full reason 
perspective database theory ahv ull reiter theory database evolution quite unusual 
instance database state usually modeled set relations logical formulas reiter theory state identified sequence actions 
different transactions terminate different states effect database 
example state resulting action insert insert formally different state resulting insert insert 
addition theory adopts view databases updated transactions executed 
initial database state preserved forever history database transactions recorded kind log 
current database state materialized virtual 
framework queries current state answered querying log reasoning backwards initial state rei 
unfortunately means simple operations retrieving single tuple database long complicated reasoning processes 
database logs typically large millions transaction records long reasoning backwards unacceptably expensive 
recognizing problem reiter colleagues looked ways materializing current database state rei lr lll 
theory logic transactions showing materialization carried logical framework 
reiter theory apply logic programs deductive databases 
reasons 
theory provide minimal model semantics database states 
reiter theory databases semantics logic programs 
theory requires databases purely order classical semantics 
unfortunately means familiar database logic programming methodology apply 
instance transitive closure trivial express deductive database expressed databases reiter theory transitive closure order definable au 
lack minimal model semantics complicates representation relational databases 
representing sets ground atomic formulas usual way theory uses clark completion llo rei case databases requires large order formulas 
ai terminology complications arise reiter theory open worlds databases closed worlds 
unfortunately updating open worlds intractable problem general result update may finite representation order logic lr 
second theory protect deductive rules database updates 
particular updates damage destroy rules 
example suppose deductive database consists single rule suppose atom inserted database 
update formalized reiter theory updated database equivalent formulas point rule changed result inserting 
change direct result reiter approach frame problem rei intuitively says atoms explicitly inserted deleted atoms retain old truth values 
case atom true initial database true final database rule premise modified ensure course dictum completely contrary idea database views virtual data depends base data change indirect effect database updates 
ai terminology example ramification problem fin rei 
account views reiter treats view definitions integrity constraints maintained transaction system 
approach views defined horn rules 
axioms transaction system modified treat views stored data 
instance example logics databases information systems transaction inserts deletes atom database modified axioms insert delete atom rei 
way system behaves database contained deductive rule minimal model semantics 
unfortunately approach view definitions depend transaction definitions 
time transaction modified defined change propagated view definitions 
addition approach requires views defined directly terms base predicates 
views recursive views defined terms views 
sum notion database state reiter theory allow fundamental features deductive databases logic programs recursion view composition minimal model semantics 
consequently theory provide logical account query update databases 
golog 
levesque developed golog procedural language programming complex actions including database transactions 
syntactically golog similar procedural database language ql developed chandra harel ch extended subroutines nondeterministic choice 
semantically golog complex meaning elementary actions specified situation calculus meaning larger programs specified formulas second order logic 
logical semantics possible express properties golog programs reason extent 
unfortunately despite claims developers golog logic programming language 
having logical semantics thing programming logic 
certainly formalizing semantics fortran logic fortran logic programming language possible reason fortran programs 
fact ways golog opposite logic programming 
obviously golog programs defined sets horn rules procedural statements algol language 
golog come sld style proof procedure executes programs updates databases proves theorems 
horn golog include classical logic programming special case 
classical logic programs deductive databases golog programs programs 
addition golog programs combined classical logic programs query update deductive databases 
golog reiter theory database evolution described apply logic programs deductive databases 
initial database state described classical horn rules golog logic transactions treat rules logic program 
instance suppose initial state described rules tr tr tr deductive database rules specify transitive closure relation golog 
transitive closure requires minimal model semantics deductive databases golog lacks 
addition golog protect rules database updates described rules progressively damaged destroyed relation updated 
transitive closure defined golog deductive rules 
user write algol procedure illustrated 
way golog sacrifices deductive databases algol 
reason golog difficulty specifying database views especially recursive views rei 
difficulties arise golog abandons logic programming paradigm 
golog numerous differences 
instance golog subroutines logical entities macros specified outside logic 
refer logic particular quantify reason 
addition logics action updates golog hypothetical real 
golog uses situation calculus reason true action took place 
actual execution actions requires separate run time system outside golog 
reiter theory database evolution kinds states golog represent including prolog programs negation failure 
likewise kinds updates golog represent including insertion rules deductive databases insertion disjunctions disjunctive databases 
datalog state 
number researchers worked adding notion state datalog programs zan 
works states represented special distinct argument added updatable predicate 
updates modeled state transitions 
approach viewed adaptation situation calculus datalog 
important differences reiter theory database evolution golog 
reiter theory datalog state uses form closed world semantics xy stratification zan closer database tradition 
reiter theory datalog state problem representing database views recursive 
second actions datalog state limited insertion deletion ground atomic formulas 
logics databases information systems restriction frame problem serious issue needs axiomatized small fixed number actions 
third golog datalog state notion subroutine 
transaction programs named programs 
approach database updates discussed chapter 
acknowledgments alberto mendelzon provided insights regarding updates logic theories 
ray reiter commenting various aspects especially issues related frame problem approach issue 
mariano consens survived draft improvements due 
discussions grahne peter revesz helpful progress 
anonymous referees valuable comments 
author supported part research natural sciences engineering research council canada university toronto 
second author supported part nsf iri 
support computer systems research institute university toronto gratefully acknowledged 
notes 
opposed event calculus simulate updates kow 

additional information including prototype implementation tutorial benchmark tests available www cs toronto edu bonner transaction logic html 
examples assume non strict version insert delete means executing ins state true change state likewise del executed state false 

assuming block top block 

assuming bought wanted 
assuming won 
assuming won 
allow arbitrary closed formulas returned transition oracle complicate theoretical development clear applications generalization 

preventing user definitions elementary transitions may policy 

discrete fourier transform numerous numerical operations typically provided built operations scientific software packages 

generalized horn rules possibly negated premises 

example suppose view defined rule suppose current database state contains literal insertion database cause inconsistency 
logics action mere possibility happening cause global inconsistency rendering entire logical system useless database states consistent 
prevents kind global collapse isolating inconsistency state causes 
note case horn databases main focus inconsistency possible difference 

number different process logics proposed literature pratt original pra 
version closer incarnation process logic aware 

syntax translated original syntax 

initial final database suppressed called situation argument 
situation arguments identify database state situation calculus unnecessary describing formulas true state 
abi abiteboul 
updates new frontier 
intl 
conference database theory pages 
abw apt blair walker 
theory declarative knowledge 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann los altos ca 
ahv abiteboul hull vianu 
foundations databases 
addison wesley 
allen 
general theory action time 
artificial intelligence july 
au aho ullman 
universality data retrieval languages 
acm symposium principles programming languages pages 
av abiteboul vianu 
procedural languages database queries updates 
journal computer system sciences 
av abiteboul vianu 
datalog extensions database queries updates 
journal computer system sciences 
ban bancilhon 
logic programming object oriented cocktail 
sigmod record september 
bee beeri 
new data models languages challenge 
acm symposium principles database systems pages new york june 
acm 
logics databases information systems bk bonner kifer 
reasoning action transaction logic 
preparation 
dagstuhl seminar logic databases meaning change september international conference research center computer science schloss dagstuhl germany 
bk bonner kifer 
overview transaction logic 
theoretical computer science october 
bk bonner kifer 
transaction logic programming logic declarative procedural knowledge 
technical report csri university toronto november 
www cs toronto edu bonner transaction logic html 
bk bonner kifer 
concurrency communication transaction logic 
joint intl 
conference symposium logic programming pages bonn germany september 
mit press 
bonner kifer consens 
database programming transaction logic 
ohori beeri shasha editors proceedings international workshop database programming languages workshops computing pages 
springer verlag february 
workshop held aug sept new york city ny 
bon bonner 
power cooperating transactions 
submitted publication 
bon bonner 
intuitionistic deductive databases polynomial time hierarchy 
journal logic programming october 
bon bonner 
logical semantics hypothetical deletion 
journal logic programming august 
bon bonner 
transaction datalog compositional language transaction programming 
proceedings international workshop database programming languages estes park colorado august 
springer verlag 
long version available www cs toronto edu bonner papers html transaction logic 
bsr bonner 
database benchmark high throughput workflow management 
intl 
conference extending database technology number lec ture notes computer science pages avignon france march 
springer verlag 
ch chandra harel 
computable queries relational databases 
journal computer system sciences 
che chen 
declarative specification evaluation database updates 
intl 
conference deductive object oriented databases volume lecture notes computer science pages 
springer verlag december 
kifer ramakrishnan ramakrishnan 
logic modelling analysis workflows 
preparation october 
enderton 
mathematical logic 
academic press 
fin finger 
exploiting constraints design synthesis 
phd thesis stanford university 
gl gelfond lifschitz 
stable model semantics logic programming 
logic programming proceedings fifth conference symposium pages 
gm grahne mendelzon 
updates subjunctive queries 
information computation february 
grs nathan goodman steve lincoln stein 
requirements deductive query language database 
raghu ramakrishnan editor applications logic databases pages 
kluwer 
ftp genome wi mit edu pub papers requirements ps 
har harel 
order dynamic logic volume lecture notes computer science 
springer verlag 
harel kozen parikh 
process logic expressiveness decidability completeness 
journal computer system sciences october 
kif kifer 
deductive object oriented data languages quest integration 
intl 
conference deductive object oriented databases lecture notes computer science pages singapore december 
springer verlag 
keynote address intl 
conference deductive object oriented databases 
kl kifer 
logic reasoning inconsistency 
journal automated reasoning november 
logics databases information systems klw kifer lausen wu 
logical foundations objectoriented frame languages 
journal acm pages july 
km katsuno mendelzon :10.1.1.26.2661
difference updating knowledge base revising 
gardenfors editor belief revision volume cambridge tracts theoretical computer science pages 
cambridge university press 
kow kowalski 
database updates event calculus 
journal logic programming january 
hamann lausen 
logical framework active rules 
proceedings th intl 
conference management data india december 
tata hill 
lll lesp erance levesque lin marcu reiter 
logical approach high level robot programming progress report 
control physical world intelligent systems working notes aaai fall symposium 
aaai press new orleans la november 
llo lloyd 
foundations logic programming second edition 
springer verlag 
lr lin reiter 
progress database logical foundations 
jon doyle erik sandewall pietro torasso editors proceedings international conference knowledge representation reasoning pages 
levesque reiter lesperance lin scherl 
golog logic programming language dynamic domains 
journal logic programming 
appear 
bonner dent 
machine analysis acoustical signals 
pattern recognition 
appears proceedings workshop issues acoustic signal image processing recognition san italy august 
mcc mccarthy 
situations actions clausal laws memo 
stanford artificial intelligence project 
mcc mccarty 
permissions obligations 
intl 
joint conference artificial intelligence pages san francisco ca 
morgan kaufmann 
mh mccarthy hayes 
philosophical problems standpoint artificial intelligence 
meltzer michie editors machine intelligence volume pages 
edinburgh university press 
reprinted readings artificial intelligence tioga publ 
mccarty van der meyden 
reasoning indefinite actions 
proceedings international conference knowledge representation reasoning pages cambridge ma october 
mw warren 
logic language database updates 
minker editor foundations deductive databases logic programming pages 
los altos ca 
nk naqvi krishnamurthy 
database updates logic programming 
acm symposium principles database systems pages new york march 
acm 
nt naqvi tsur 
logical language data knowledge bases 
computer science press rockville md 
pdr ross 
glue nail deductive database system 
acm sigmod conference management data pages new york 
acm 
pra pratt 
process logic 
acm symposium principles programming languages pages january 
prz przymusinski 
declarative semantics deductive databases logic programs 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann los altos ca 
rei reiter 
logical reconstruction relational database theory 
brodie mylopoulos schmidt editors conceptual modelling perspectives artificial intelligence databases programming languages pages 
springerverlag 
rei reiter 
frame problem situation calculus simple solution completeness result goal regression 
lifschitz editor intelligence mathematical theory computation papers honor john mccarty pages 
academic press 
rei reiter 
proving properties states situation calculus 
artificial intelligence december 
rei reiter 
specifying database updates 
journal logic programming october 
logics databases information systems ull ullman 
principles database knowledge base systems volume 
computer science press rockville md 
van gelder ross schlipf 
founded semantics general logic programs 
journal acm 
win winslett 
model approach updating databases incomplete information 
acm transactions database systems 
zan carlo zaniolo 
unified semantics active deductive databases 
proceedings workshop rules database systems workshops computing 
springer verlag edinburgh 
