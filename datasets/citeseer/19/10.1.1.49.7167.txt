wrappers rescue john brant brian foote ralph johnson donald roberts department computer science university illinois urbana champaign urbana il brant foote johnson cs uiuc edu 
wrappers mechanisms introducing new behavior executed lieu existing method 
examines ways implement wrappers smalltalk compares performance 
smalltalk programmers smalltalk lookup failure mechanism customize method lookup 
focus different 
changing method lookup process modify method objects lookup process returns 
call objects method wrappers 
method wrappers construct program analysis tools coverage tool class collaboration tool interaction diagramming tool 
show method wrappers construct extensions smalltalk synchronized methods assertions multimethods 
wrappers relatively easy build smalltalk designed reflective facilities allow programmers intervene lookup process 
languages differ degree accommodate change 
experience value power utility openness 
benefit building programming languages objects programmers able change way running program works 
languages smalltalk clos represent program elements classes methods objects manipulated runtime allow programmers change ways objects need arises 
focuses intercept augment behavior existing methods order wrap new behavior 
approaches examined contrasted relative performances compared 

source code modifications 
byte code modifications 
new selectors 
dispatching wrappers 
class wrappers 
instance wrappers 
method wrappers examine tools extensions built wrappers 
coverage tool 
class collaboration diagram tool 
interaction diagram tool 
synchronized methods 
assertions 
multimethods taken time easy dismiss smalltalk specific minutiae language specific hacks 
taken illustrate power importance reflective facilities support 
methods know appeared flavors loops 
common lisp object system clos provides powerful method standard combination facility includes methods 
clos method qualifier specializes generic function executed primary methods methods called primary method called methods called 
method wrap option completing rest computation 
method combination mechanism built clos lets programmers build method qualifiers combination schemes powerful 
unfortunately method combination lead programs complex hard understand 
application programmers save little code systems hard understand maintain 
facilities solve application level problems symptomatic serious design problems addressed refactoring 
result methods gained bad reputation 
method wrappers reflective facility normal application programming technique 
think way impose additional structure underlying reflective facilities 
example dynamically determine calls method methods called 
methods wrappers treated disciplined form reflection carefully complexity problem 
experience method wrappers smalltalk 
smalltalk reflective facilities 
smalltalk language cast elements object oriented language classes class objects 
ability trap messages understood implement proxies distributed systems 
ability manipulate contexts implement debuggers back trackers exception handlers 
ability compile code dynamically standard programming environments easy define new code management tools 
smalltalk programmers change system accesses global variable change class object 
possible change aspect smalltalk 
smalltalk built virtual machine defines objects laid classes messages handled 
virtual machine changed smalltalk vendors changes reflective facilities virtual machine provides 
change message lookup works specify happens fails 
change method returns trap returns method 
change method executed change method 
method wrappers change method executed 
common reason changing method executed execution method wrappers purpose 
compiled methods method wrapper implementations discussed helpful understand methods understand different implementations 
discussion focuses visualworks implemented wrappers visualage smalltalk 
implemented dialects smalltalk 
method names structure objects somewhat different 
complete discussion implement wrappers dialects smalltalk scope 
smalltalk represents methods class instances subclasses 
knows smalltalk source provides information method set messages sends bytecodes define execution method 
interestingly know selector associated 
oblivious name invoked names arguments 
similar lisp lambda expressions respect 
compiled method invoked reside 
fact construct 
instance variables literal frame stored variable part accessible put methods 
instance variables bytes mclass sourcecode 
sourcecode variable holds index retrieve source code method changed different sources appear method browsed 
changing variable affect execution method 
mclass instance variable contains class compiled method 
uses extract selector method 
bytes literal frame important parts 
bytes instance variable contains byte codes method 
byte codes stored small integer method small byte array contain items literal frame 
items literal frame include standard smalltalk literal objects numbers integers floats strings arrays symbols blocks copying full blocks 
symbols literal frame specify messages sent 
classes literal frame method sends message super class 
class placed literal frame virtual machine knows method lookup 
associations stored literal frame represent global class pool variables 
compiler store types objects literal frame principle kind object stored 
shows method 
method stored key lection method dictionary 
showing integer method sourcecode variable dashed line indicates source code integer points 
implementing wrappers different ways implement method wrappers smalltalk ranging simple source code modification complex byte code modification 
sections discuss possible implementations properties 
implementation details smalltalk specific languages provide similar facilities varying degrees 
source code modification common way wrap methods modify method directly 
wrapper code directly inserted original method source resulting code compiled 
requires parsing original method determine code placed possible locations code 
locations return statements parsing locations method exited 
ways leave method exceptions non local block returns process termination 
self 

class 

mclass bytes sourcecode fig 

method visualworks allows catch exit method method 
method evaluates receiver block block exits normally abnormally evaluates argument block 
new source method argument code original method source code method appear unchanged source index new method set source index old method 
furthermore original method need saved recompiled source retrieved source index 
biggest drawback approach compile method changes 
requires compile original method 
compiling slower approaches listed runtime images allowed compiler 
byte code modification way modify method modify directly recompiling 
technique inserts byte codes literals code directly method need recompiled 
installation faster 
unfortunately approach handle code 
insert code convert byte codes original method byte codes block executed method 
conversion non trivial byte codes method different byte codes block 
furthermore type transformation depends knowledge byte code instructions virtual machine 
codes standardized change warning 
new selector way wrap methods move original method new selector create new method executes code sends new selector executes code 
approach new method argument code self argument code approach cker build tracers 
implementation couple desirable properties 
original methods need recompiled moved new selectors 
contain direct selectors moved selector number arguments 
property new forwarding methods code copied forwarding method number arguments 
cloning objects prototype pattern faster compiling new ones 
main difference forwarding methods send different selectors original methods 
symbol sent easily changed replacing method literal frame 
changes methods sourcecode mclass variables 
mclass set class method sourcecode set original method sourcecode source code changes aren noticed 
byte codes modified original method new forwarding method needs compiled installation faster source code modification approach 
problem approach new selectors visible user 
cker addressed problem modifying browsers 
new selectors conflict selectors super subclasses conflict users adding new methods 
furthermore difficult compose different method wrappers remember selectors represent original methods new selectors 
dispatching wrapper way wrap new behavior existing methods screen message sent object dispatched 
smalltalk mechanism long purpose approach works action taken regardless method called coordinating synchronization information 
extra data structures implement wrapping method basis 
example implement clos style method combination mechanism 
common way introduce class superclass intercept dispatching mechanism allow instance changes behavior 
mechanism slow screening message sent object just change behavior methods wasteful inelegant 
sections examine smalltalk meta architecture lets precisely target facilities need 
class wrapper standard approach specializing behavior object oriented programming subclassing 
subclassing specialize methods add code 
case specialized subclass essentially wraps original class creating new method executes code calls original method super mechanism executes code 
methods new selector approach methods specialized subclass copied compiler needed 
subclass created installed system 
install subclass new class inserted hierarchy subclasses wrapped methods 
inserted superclass method change superclass subclasses class wrapped wrapper 
original class system dictionary replaced subclass 
existing instances original class converted new subclass 
accomplished getting allinstances original class method change class new subclass 
new selector approach requires additional message send 
sorts wrappers take longer install 
class requires scan object memory look instances original class 
instances iterate changing classes 
instance wrapper class wrapper approach wrap methods instance basis time 
replacing class system dictionary change objects want wrap method objects 
instance wrappers change way individual objects behave 
intent decorator pattern 
decorations immediately visible existing original object objects decorated dynamically 
method wrapper method wrapper new selector old method replaced new invokes old 
method wrapper add new entries method dictionary 
invoking old method sending message receiver method wrapper evaluates original method directly 
method wrapper know original method able execute current arguments 
executing easy responds arguments message executing receiver array arguments 
way keep track original method subclass new instance variable stores original method 
defines receiver arguments methods helper methods 
methods contain code 
arguments method executes original method receiver argument array 
anobject arguments args self 
anobject arguments args self remaining problem send arguments message 
method able refer executing smalltalk provide standard way refer currently executing method 
executing receiver message self current computation 
visualworks smalltalk code method evaluates currently executing method inefficient 
need kind static variable initialize method smalltalk feature 
fact smalltalk method keeps track literals constants uses 
compiled marked literal array size 
created system replaces literal 
trick receiver value message sent compiling argument receiver self value argument replacing empty array position literal frame method 
receiver value method helper methods 
responsible converting value argument array sending arguments method 
mclass bytes sourcecode class 
self 

mclass bytes sourcecode receiver fig 

method shows wrapping method 
replaced method dictionary 
original method variable 
empty array initially compiled method replaced wrapper 
new selector approach need compiled method 
just need prototype number arguments copied 
copied method sets method literal source index mclass 
method wrapper directly execute original method new entries needed method dictionary original method 
smalltalk objects byte code designed primarily smalltalk portable 
smalltalk historic openness continues pay unexpected dividends 
table table compare different approaches runtime overhead installation time 
tests performed mb memory running windows visualworks 
byte code modification approach implemented shown 
dispatching wrapper omitted installation times instance technique 
added listings inlined method wrapper 
new method wrapper inlines code wrapper defining additional methods 
saves message sends default method wrapper 
helps runtime efficiency hurts installation times inlined wrappers larger 
table shows overhead approach 
method modification approach lowest overhead method contain return contains return overhead method modification jumps times greater techniques 
return occurs block context object table 
overhead method calls ms number arguments approach method modification returns method modification returns new selector dispatching wrapper class wrapper method wrapper inlined method wrapper created runtime 
normally context objects created execution faster 
new selector class wrapper approaches best times 
method wrapper approaches dispatching wrapper approaches double overhead new selector class wrapper approaches method wrappers dispatching wrappers create arrays arguments 
table contains installation times installing various approaches subclasses model metaclass classes methods 
method wrapper techniques fastest need change entry method dictionary 
new selector approach slightly slower needs change entries method dictionary 
class wrapper needs add entry scan object memory instances class convert new subclass wrapper 
method modification approach slowest compile method 
wrappers relatively fast overhead associated predictable may suitable time critical applications classical smalltalk approaches 
applications method wrappers different areas 
section outline different uses 
coverage tool image application method wrappers image 
remove unused objects usually methods classes image memory efficient 
default shipped visualworks removes development environment compilers browsers image 
table 
installation times methods classes sec approach time method modification new selector class wrapper method wrapper inlined method wrapper different approach stripping see methods program running remove unused ones 
finding methods coverage problem handled method wrappers 
counting times method called method wrapper needs flag signify method called 
method called original method restored calls occur normal speeds 
created subclass adds new instance variables selector called 
selector variable contains method selector called flag signifies method called 
method wrapper need method executed needs redefine method called iffalse called true 
mclass selector method sets flag original method 
iffalse test avoids infinite recursion case method called performing operation 
execution application program slow rapidly increases base set methods 
method wrapper correctly reports called 
stripping scheme requires method coverage 
method test suite removed test suite provide method coverage rarely remove method needed 
removing methods manner introduce errors correct program 
methods saved file removed 
removed methods called loaded installed executed 
best way detect deleted method called mechanism possible method wrappers purpose 
class collaboration method wrappers dynamically analyze collaborating objects 
example create call graphs help developers better understand software works 
furthermore information help developer visualize coupling objects 
help developer quickly analyze inappropriate objects interacting 
method wrappers capture information getting current context just debugger 
method called wrapper needs record called method call occurred method statement inside method starting times method method terminated normally return abnormally signal 
meth ods return abnormally problem programmers programmed case 
information collected method wrappers create class collaboration graph shown 
object class sends message object class line drawn 
classes objects collaborate lot attracted 
collaboration graph help programmer see objects collaborating collaborating 
interaction diagrams interaction diagrams illustrate dynamic sequence message traffic objects runtime 
interaction diagram application allows users select set methods watched 
methods wrapped tool records traffic 
wrappers removed interactions objects sent received messages depicted 
diagrams generated tool similar interaction diagrams seen books notable exception 
select methods observe messages 
result times message received method entered send message 
example suppose fig 

class collaboration graph refactoring browser foo bar new bar initialize initialization bar class new super new initialize wrap foo bar initialize 
send foo message event recorded 
send new message bar class method wrapped observed 
new method sends initialize method bar observed observed method send 
events called indirect message sends displayed yellow lines 
see sent closed message object wasn wrapped resulted update method called selected 
fig 

interaction diagram refactoring browser facility wrapping watched methods tools intervene source binary code levels 
instance lange nakamura modify source code instrument programs tracing 
relative absence tools languages support wrappers difficulty intervening levels 
probe arbor intelligent systems object visualizer ibm visualage smalltalk generate interaction diagrams method wrappers 
probe uses method wrappers similar described code inlined wrapper 
object visualizer uses combination lightweight classes method wrappers capture runtime interaction information 
method wrappers directly wrapped method 
look method send 
instance wrappers better choice approach 
synchronized methods method wrappers useful synchronizing methods 
multithreaded environment objects concurrently different threads corrupt 
classic example smalltalk transcript 
transcript global variable programs print output 
print debugging information 
processes write transcript time corrupt cause exceptions raised 
solve problem need ensure process accesses transcript time 
solution define language construct synchronization 
example java takes approach defining method tag specify method synchronized 
system ensures method tagged synchronized keyword running time instance static method tagged running time single class 
smalltalk compiler need directly support synchronized methods smalltalk exposes implementation allow implement features 
example implement static synchronized methods method wrappers wrapper acquires lock executing original method releases method executes 
similarly non static synchronized methods implemented class wrappers instance class wrapper wrap super message send lock 
method class wrappers add functionality dynamically java forces recompile change method attribute 
pre post conditions pre post conditions help programmers produce quality software describing component helping detect misused 
earlier error detected easier fix 
eiffel supports pre post conditions directly require ensure keywords 
conditions enabled invocations method required meet conditions executing method ensures conditions executing 
systems smalltalk directly support pre post conditions programmers write checks directly code 
example method checks non empty 
times conditions written comments code written 
useful checks code developing software useful releasing software 
user unhandled empty collection signal raised empty check unhandled index bounds signal raised error check eliminated 
cause product fail 
useful developer system implements pre post conditions able add remove quickly easily 
pre post conditions implemented method wrappers 
method method wrapper created test pre condition evaluate wrapped method test post condition exit 
post conditions old values 
old values useful comparing values occur executing method values execution 
support old values added special selector old sent expression refer value expression execution method 
selector appears message send preprocessing step replaces temporary 
receiver message assigned temporary method executed 
example consider method 
pre condition self size post condition self size old self size size collection execution size 
method wrapper example old old self size 
self size value iffalse self raise 
code evaluate wrapped method old self size value iffalse self raise notice self size old post condition replaced temporary receiver self size assigned wrapper 
implemented pre post conditions smalltalk modified compiler generate conditions directly methods 
require complete recompile un installing conditions 
allowed conditions turned completely eliminated complete recompile 
shows browser pre post conditions inspecting method 
text panes bottom display method pre condition source post condition 
pre condition post condition panes eliminated programmer wish view 
pre post conditions separated method don need augment method definition special keywords special message sends eiffel smalltalk implementations 
multimethods common lisp object system clos metaobject protocol provide elaborate facilities method wrapping 
clos method combination mechanism provides programmers great deal control different kinds methods interact inheritance hierarchy determine methods executed 
clos standard method combination mechanism executes methods outermost innermost order 
primary methods executed followed methods innermost outermost order 
methods resumed 
basic wrappers simpler 
execute code primary code wrapper calling wrapped method 
method wrapped code primary code executed 
clos methods wrappers may decide call wrapped methods 
fig 

browser pre postconditions method wrappers construct mechanisms clos 
describe build clos style generic functions method combination multimethods 
multimethods methods dispatched runtime identities methods arguments account just message receiver case languages smalltalk java 
java static overloading distinguish methods compile time types arguments 
multimethods powerful choose method runtime 
clos multimethods share function name selector members generic function name 
function called determines multimethods apply calls appropriate order 
way multimethods called determined method combination object 
multimethods specialized types arguments may qualified 
instance standard method combination object conducts execution primary methods qualifiers account 
clos metaobject protocol permits optimizations process sort partial evaluation discriminating functions effective methods 
smalltalk multimethod implementation uses dormant type syntax built visualworks smalltalk compiler syntax specializing multimethod arguments 
syntax lets specify literal instances 
smalltalk browser accepts method specializations creates multimethod object 
multimethods subclasses selectors distinct normal methods 
multimethods sure instance selector defined 
keep track 
subclasses intercept calls occupy slots normal method selector go 
gains control passes receiver arguments determine multimethods execute order 
passing control object 
subclasses implementing standard fore primary style combinations constructed collect values primary methods clos call methods innermost outermost order beta 
called dispatch argument done information optimize task 
illustrate syntax power multimethods consider impact multimethods visitor pattern 
consider typical smalltalk implementation visitor self self self anode anode value optimized anode anode self symboltable multimethods available double dispatching methods disappear type information need selectors calls visitor objects 
visitor correctly dispatches calls correct multimethod 
adding visitor longer requires changing classes 
anode self value optimized anode anode self symboltable savings visitor side may appear merely cosmetic 
methods replaced corresponding anode methods specialized sort node service 
savings possible particular node implementation shared superclass 
instance multimethods sent optimized message node value share implementation method defined 
hand coded implementations usually provide stub implementation subclass node version method avoid breach encapsulation 
approaches systems provide ways programs augment preempt behavior existing functions 
language permit modifications programmers resort low level implementation specific schemes achieve ends 
wrapping strategies limited languages 
instance routines macintosh toolbox wrapped 
architects toolbox designed calls rom built toolbox functions accessed indirectly table ram 
indirection allowed apple ship patched copies toolbox entries correct supplement existing routines 
gave software designers opportunity change routines system built 
years macintosh programmers shown remarkable ingenuity ways exploited hooks system 
instance applications wide desktops screen savers built wrapping toolbox 
shows wisdom designing systems flexible foundations 
programmers microsoft windows achieved similar results dynamic linking mechanism implement dynamic link libraries dlls 
function wrapped providing wrapping implementation dll referenced wrapped dll 
standard mechanisms allowing programmers intercept calls functions virtual 
programmers exploited common implementation mechanism dispatching virtual functions table gain access 
falling back unsafe code treating table entries simple function pointers programmers dynamically alter contents table entry class objects 
substituting function signature table entry entry wrapped code add actions calling calling original method 
table mechanisms part standard complex features multiple inheritance virtual bases employ elaborate implementations programmers write portable code depends table surgery 
interestingly classes contained mechanism allowed programmers specify function called call member functions constructors called return member function 
call return functions resemble dispatching wrappers 
contrast microsoft component object model com defines explicit binary format similar customary implementation simple tables 
com object adhere format provides potential basis wrapping methods table manipulation rules tables play explicitly stated 
importance open smalltalk reflective facilities wrappers allowed construct powerful program analysis tools language extensions relative ease 
ease add remove wrappers runtime tools interaction diagramming tool possible 
contrast adding feature dynamic coverage analysis existing program impossible users traditional systems difficult tool vendors 
wrappers principle solve problems meta language level analysis tools language extensions reflective applications exploit ability manipulate program objects pieces program representations application level concerns 
case tools fact program built objects lets inspect alter objects fly 
tools need inside view program 
instance wrap object interaction tool exploiting language level role program element indifferent domain specific behavior engenders 
case linguistic extensions openness language objects permitted construct extensions write domain specific code 
raw reflective facilities construct extensions way harness power reflection 
examples method wrappers domain specific 
domain specific uses reflective facilities methods frequently symptoms problems application structure better addressed refactoring design 
reflective facilities useful alternatives system redesigned 
able change language level gives programmers big lever buy time resources system available 
metalevel tricks substitute properly addressing system serious long term structural problems 
generation smalltalk programmers turned smalltalk lookup failure exception time came extend language 
examined strengths weaknesses ways intervening lookup process 
approaches brute force quality screen message sent 
method wrappers intervene precisely selectively 
needed way build power efficient programming tools language extensions wrappers came rescue 
original smalltalk designers wonderful job building language objects users change 
rarely run keep signs frustrate users languages 
lets add new tools programming environment keep latest database network technology maintain enhance systems evolve 
acknowledgments ian chai manolescu joe yoder provided valuable comments insights earlier version 
james noble suggested useful simplification visitor pattern example 
ecoop program committee reviewers suggested number valuable improvements 
interaction diagramming tool originally project done david wheeler jeff xu ralph johnson cs class 
report project radon ece uiuc edu interaction html 
code referenced article st www cs uiuc edu brant applications html 
kent beck 
demand loading 
smalltalk report january 

john bennett 
design implementation distributed smalltalk 
proceedings oopsla pages december 
published acm sigplan notices volume number 

heinz dieter cker rgen tracers ecoop oopsla conference proceedings sigplan notices volume number october 
dan bobrow linda demichiel richard gabriel keene gregor kiczales david moon 
common lisp object system specification 
sigplan notices september 

daniel bobrow mark stefik 
loops manual 
xerox parc 


inside ole second edition microsoft press redmond washington 

manuela jesus garcia molina 
eiffel assertions private methods smalltalk 
tools pages 

pierre cointe system laboratory study reflection smalltalk oopsla ecoop workshop reflection metalevel architectures object oriented programming ibrahim organizer 

margaret ellis bjarne stroustrup 
annotated manual 
addison wesley reading massachusetts 

brian foote ralph johnson 
reflective facilities smalltalk 
proceedings oopsla pages october 
published acm sigplan notices volume number 

erich gamma richard helm ralph johnson john vlissides design patterns elements reusable object oriented software addison wesley 

guerraoui 
implementation replicated objects platform 
distributed systems engineering journal 

james gosling bill joy guy steele java tm language specification addison wesley 

guerraoui 
system 
ieee concurrency 

bob ralph johnson 
exception smalltalk 
smalltalk report november 

bob jones ralph johnson 
debugging objects 
smalltalk report july 

daniel ingalls evolution smalltalk virtual machine smalltalk bits history words advice glenn krasner editor wesley reading ma 
gregor kiczales jim des rivieres daniel bobrow art metaobject protocol mit press 

gregor kiczales john lamping issues design implementation class libraries oopsla vancouver bc sigplan notices volume number october 

bent kristensen ole lehrmann madsen moller pedersen nygaard object oriented programming beta language october 

wilf lalonde mark van 
building backtracking facility smalltalk kernel support 
proceedings oopsla pages november 
published acm sigplan notices volume number 

danny lange nakamura interactive visualization design patterns help framework understanding proceedings oopsla pages october published acm sigplan notices volume number 
paul mccullough 
transparent forwarding steps 
proceedings oopsla pages december 
published acm notices volume number 

steven kent beck 
active variables smalltalk 
technical report cr computer research lab tektronix 

bertrand meyer 
eiffel language 
prentice hall 

geoffrey pascoe 
new software paradigm smalltalk 
proceedings oopsla pages november 
published acm sigplan notices volume number 

fred 
smalltalk reflective language 
proceedings reflection 

bjarne 
design evolution 
addison wesley reading ma 

michael 
solving rpc problem gnu 
usenix conference pages 

weinreb moon 
lisp machine manual symbolics 
