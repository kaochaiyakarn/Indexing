draft program comprehension may program comprehension spencer rugaber georgia institute technology may copyright spencer rugaber definition program comprehension program comprehension process acquiring knowledge computer program 
increased knowledge enables activities bug correction enhancement reuse documentation 
efforts underway automate understanding process significant amounts knowledge analytical power required today program comprehension largely manual task 
motivation program comprehension emerging interest area software engineering field 
software engineering concerned improving productivity software development process quality systems produces 
currently practiced majority software development effort spent maintaining existing systems developing new ones 
estimates proportion resources time devoted maintenance range 
greatest part software maintenance process turn devoted understanding system maintained 
report time spent actual enhancement correction tasks respectively devoted comprehension activities 
involve reading documentation scanning source code understanding changes 
implications want improve software development look maintenance want improve maintenance facilitate process comprehending existing programs 
terminology relationship activities terms describe activities related program comprehension 
chikofsky cross standard definitions 
example reverse engineering process analyzing subject system identify system components interrelationships create representations system form higher level abstraction 
draft program comprehension may variation reverse engineering design recovery 
design recovery advantage taken source code information domain knowledge documentation line commentary mnemonic variable names 
goals similar reverse engineering concentrating particularly discovery design decisions rationale 
closely related term reengineering 
reverse engineering moves program code higher level abstraction reengineering uses increased understanding reimplement code new form 
terms renovation reclamation describe activity 
need reengineering may arise due changes operational environment moving centralized computational setting decentralized degradation system structure due long term maintenance alterations enhancements system existing architecture longer appropriate 
term reengineering popular context business process reengineering 
case target reengineering organization software system goal reformulation 
smith give definition basic level re engineering means radically redesigning way organization performs business achieve dramatic improvements performance 
course extent way doing business expressed software systems software reengineering business process reengineering intimately linked 
related term restructuring 
desirable reformulate program abstracting higher level 
example older software typically written versions cobol fortran contain modern control structures heavy goto statements 
readability improved replacing uses goto modern equivalents structured conditional looping constructs 
process reformulating program raising level abstraction called restructuring commercial tools available languages automate process 
ii 
program comprehension difficult 
program comprehension difficult 
difficult bridge different conceptual areas 
particular importance bridges gaps 
gap problem application domain solution programming language 
gap concrete world physical machines computer programs world high level design descriptions 
gap desired coherent highly structured description system originally envisioned designers actual system structure may time 
gap hierarchical world programs associational nature human cognition 
gap bottom analysis source code top synthesis description application 
draft program comprehension may application domain program programs solutions problem situations application domain 
may may hints program particular problem 
hints take form mnemonic variable names line comments 
hints inherently informal tend date respect program 
totally automatic program comprehension tools restricted working formal program text 
job person trying understand program called reverse engineer program reader reconstruct mappings application domain program 
course requires knowledge programming application domain 
surprise find automatic tools restricted analyzing program text address application domain 
physical machines descriptions computer programs incredibly detailed 
essence control values bits memory inside computer 
jobs reverse engineer decide detail important concepts 
process called abstraction reverse engineer create representation program mass concrete details 
abstraction process linear 
section program may part abstractions 
abstractions said interleaved designer plan delocalized section 
typically documentation source code interleaving 
coherent models incoherent artifacts program originally constructed coherent structuring details 
process creates structuring called design 
large variety design methods representation techniques developed aid process 
programming languages features intended facilitate abstraction structuring higher level design representations may lost allowed date time program comprehension required 
importantly maintenance activities porting bug fixing enhancement original structure program may deteriorated 
job person trying understand program detect purpose high level structure program original purpose program may changed fact program may serve accomplish purposes 
hierarchical programs associative cognition computer programs highly formal 
obey strict rules limit expression ideas control ideas effect computer run 
types rules syntax semantics organized hierarchically broad concepts program function defined terms narrower ones declaration expression 
formal world meaning syntactically correct program determines output produced specific input 
human cognition extent understood associatively 
raw data perceived patterns detected abstractions called chunks constructed relating 
process human understanding controlled expectations derived draft program comprehension may application domain program large body programming knowledge held reverse engineer knowledge programming language typical programming practices algorithms data structures 
program understood extent reverse engineer build correct high level chunks low level details evident program 
bottom program analysis top model synthesis experienced reverse engineer looks program detects patterns indicate intent section code 
low level patterns part higher level constructs intended accomplish larger purposes 
case process analyzing program proceeds bottomup 
time programmer idea purpose program accomplished 
program concept refined complete description adding lower level details 
synthesis process proceeds top 
difficulty activities need proceed time synchronized fashion 
iii 
program comprehension people program comprehension currently done humans 
order understand process important look human factors involved comprehension 
study called software psychology 
result efforts variety models human program comprehension process proposed 
ultimately tools developed support 
information matter reader referred surveys von vans robson paul quilici empirical study 
software psychology study software psychology pioneered shneiderman 
attempts discover describe human limitations interacting computers 
shneiderman defines software psychology study human performance computer information systems 
uses techniques experimental psychology analyze aspects human performance computer tasks 
applies concepts cognitive psychology cognitive perceptual processes involved computer interaction 
case maintenance understanding human skills capacity software necessary order facilitate maintainer examination understanding source code 
strengths limitations human abilities serve underlying factors determining functionality software maintenance tools 
software psychologists focus human factors ease simplicity learning improved reliability reduced error frequency enhanced user satisfaction 
particular areas programming activity experiments performed program comprehension composition debugging modification 
relevance software maintenance experiments program comprehension 
program comprehension studied experiments requiring memorization reconstruction programs 
memorization reconstruction task consists studying program reconstructing memory 
experience subjects plays vital role task 
experiment shneiderman draft program comprehension may showed experience increased ability reconstruct proper program increased rapidly 
experienced programmers wrote functionally equivalent syntactically different versions 
explanation subjects gain experience programming improve capacity recognize meaningful program structures enabling recode syntax higher level internal semantic structure 
subject completes reconstruction task experimenter analyzed reconstructed code terms information chunks give insight kinds internal information structures contained code 
terms internal structures code interpreted understood subjects 
shneiderman identifies structures model 

shneiderman model program comprehension majority program maintenance tasks founded program comprehension 
shneiderman views comprehension programs consisting levels low level comprehension function line code mid level comprehension nature algorithms data high level comprehension program function 
possible understand line code understand program function 
possible understand function program understand individual lines code algorithms data 
mid level comprehension involves knowledge control structures module design data structures understood knowledge levels 
thorough comprehension involves levels understanding 
experienced programmers possess network multi leveled concepts long term memories 
concepts extracted experience independent programming language environment comprise programmer semantic knowledge 
semantic knowledge consists concepts assignment statement stack implemented strategies sorting set elements 
kind information stored programmer long term memory syntactic knowledge 
knowledge consists details different programming languages systems proper positioning semicolons legal syntax assignment conditional statements available data types features language environment 
shneiderman views comprehension process converting code program internal semantic form 
conversion achieved help programmer semantic syntactic knowledge 
highest level programmers form idea program purpose 
recognize lower level structures algorithms sorting searching familiar streams statements 
reach understanding program 
understanding represented internal form 
internal representation program independent syntactic form extracted capable expressed languages contexts 

examples software psychology experiments commenting 
influence comments program understanding resolved 
studies short programs show comments code interfere process understanding draft program comprehension may require filtering reading code date misleading cause errors semantic representation code 
comments code programs longer disrupt flow code 
experiments longer realistic programs reported shneiderman 
may case importance comments increases length program 
experiments cited shneiderman show functionally descriptive comments facilitate faster conversion code internal semantic structure non descriptive comments hinder 
functionally descriptive comments high level comments describe actions effects obvious viewing code 
low level non descriptive comments restate function code hinder program understanding unnecessarily interrupting subject thought process 
variable names 
mnemonic variable names contributes program comprehension 
mnemonics add semantic information relevant code 
mnemonics different meanings different programmers 
allowing systematic substitution variable names individual programmer specifications improve comprehension 
having meaningful mnemonics reduces programmer short term memory load making comprehension easier 
indentation 
programmers indentation experimentally advantages indentation substantiated 
experiments weissman show indented commented programs difficult read 
love shows indentation improve understanding short fortran programs shneiderman mckay show indented long programs difficult read deep indentation cause lines split order accommodate margins 
models comprehension software psychology studies variety models proposed process program comprehension 
described illustrate issues involved modeling complex behavior 
developed brooks elliot soloway 
highest level basic structure cognitive models consists components target system comprehended 
consists information sources available understander source code supporting documentation 
knowledge base encodes understander experience background knowledge comprehension task 
knowledge base internal understander mind external example manual programming language 
mental model encodes current state understanding target program 
constantly updated course comprehension 
assimilation process interacts components update current state understanding 
differences models human comprehension terminology describing contents knowledge base approach adopts assimilation process 
draft program comprehension may models contain mechanisms utilize top bottom approaches comprehension process brooks model emphasizes top approach soloway model bottom 

brooks model brooks model deals comprehension completed programs 
basis areas outside computer science thermodynamics problem solving physics problem solving chess 
model initially created explain major sources variation observed act program comprehension 
functionality program understood 
programs perform different computations vary comprehensibility 
differences program text 
programs written different languages differ comprehensibility calculation performed 
motivation understander comprehend program 
comprehension process vary depending motivation debug program enhance 
individual differences abilities comprehend program purpose 
understander find program easier comprehend 
account areas variation brooks created model main ideas 
programming process construction mappings task domain intermediate domains programming domain 
comprehension process program reconstruction part mappings 
reconstruction process expectation driven creation confirmation refinement hypotheses 
hypotheses describe various domains relationships 
comprehension process re creating set mappings develop program 
mappings expressed hypotheses 
example high level hypothesis program produces invoices 
hypothesis maps task domain programming domain program 
start understanding process understander forms primary hypothesis global description understander thinks program 
formed soon understander obtains information purpose program 
example hearing program name usually provides information form primary hypothesis 
primary hypothesis produces cascade subsidiary hypotheses 
cascading done depth decision hypothesis pursue understander motivation comprehending program 
cascading continues produces hypothesis specific understander verify program code supporting documentation 
specifically understander begins verification hypothesis hypothesis deals operations draft program comprehension may associated visible details program code 
term beacons describes details show presence particular structure operation 
example typical beacon hypothesis sort pair loops inside section code values elements compared conditionally interchanged 
beacons important link top hypotheses actual program text 
existence verified experiments done wiedenbeck 
method experiments memorization recall assumption high recall part program brief study indicates recalled part important understanding program 
tested hypothesis experts locate parts efficiently novices 
effect confirmed effect experts recalling beacons lines successfully non beacon lines beacon versus non beacon 
result opposite novices recalled non beacon lines better beacon versus non beacon 
effect explained factors 
syntactic markers placed line considered non beacons 
second novices recalled lines program effectively lines beacon lines fairly deeply embedded program net result increase percentage wise non beacon lines beacon lines 
stated earlier brooks theory attempts explain sources variation act comprehension 
functionality program 
intrinsic complexity task domain nuclear physics versus causes higher level hypotheses complex result greater number intermediate domains task domain programming domain 
documentation explaining intermediate domains rarer documentation covering original program task 
program text 
code supporting documentation affect ease beacons located ease binding actual source code hypotheses 
features language effect confirmation beacons 
example hypothesis variable pi contains easy confirm language pi defined const statement 
easy language constant declarations put pi program confirm pi changed 
understander task 
motivation understander affects strategy creating subsidiary hypotheses 
example debugging output format error causes entire subsidiary hypotheses dealing input computation remain unexplored lack relevance task hand 
understander individual abilities 
knowledge understander domains affects process levels 
specifically task domain knowledge affects quality primary higher level hypotheses 
programming domain knowledge affects lower level bindings beacon location process 

soloway model elliot soloway model deals comprehension completed programs divides knowledge base assimilation process differently 
soloway terminology draft program comprehension may understand program recover intention code 
goals denote intentions plans denote techniques realizing intentions 
plans rewrite rules convert goals subgoals program code 
program comprehension defined process recognizing plans code combining plans reversing rewrite rules form subgoals combining subgoals higher level goals 
knowledge base model contains parts including 
programming language semantics 
deals understander knowledge language target program written 
goal knowledge 
encoding understander set meanings computational goals 
goals encoded independently algorithms languages implement 
plan knowledge 
encoding solutions problems understander solved understood past 
solutions low level components include universally known programmers 
plan knowledge includes plans understander acquired domain specific knowledge 
efficiency knowledge 
detect inefficiencies influence efficiency issues programming code plans 
problem domain knowledge 
understander knowledge world application domain computational domain domains 
discourse rules 
knowledge certain programming conventions allow understander attach greater meaning aspects source code documentation ordinarily possible 
example discourse rule variable name forms word meaning word related purpose variable 
supporting experiments performed concern behavior events short periods time 
example events reading line code formulating question stating hypothesis events looked detail 
clear advantages approach experimental evidence support theory relatively easy obtain 
empirical studies shown existence discourse rules plans concept de localized plan single plan physically implemented separate sections source code explain varying levels complexity comprehension 
major implications model concern building manipulation knowledge base 
element domain knowledge similar brooks domains 
elements goal subgoals similarly correspond task intermediate domains discussed earlier 
formally defined plans correspond mappings low level domains brooks mentions 
mappings high level domains addressed plans 
direct consequence formal rigid structure plans gained expressive power low level sacrificing power needed express high level domain relationships 
draft program comprehension may iv 
foundations automated program comprehension computers rigorous formal humans 
understand computer program comprehend programs underlying formal basics program analysis appreciated 
section presents compendium ideas related program analysis 
serves vehicle ideas indication variety approaches undertaken far 
proceeds straightforward textual analysis increasingly complex static approaches dynamic analysis executing programs 
textual analysis programs basic sequences characters crude measure comprehensibility program just number characters contains 
useful measure group characters lines number lines code indication size program 
fact single factor best predicts amount effort required comprehend program number lines contains 
factors control flow complexity pattern variable usage secondary 
programs range size apl systems contains millions lines code ones control telephone switches 
lexical analysis just natural languages sequences characters program text fall certain lexical categories 
nouns verbs adjectives lexical units comprising programs consist identifiers operators keywords strings numbers punctuation marks 
lexical analysis process decomposing sequence characters program input file constituent lexical units 
lexical analysis performed various useful representations program information enabled 
common cross listing 
report program identifiers listed numbers lines occur 
program maintainer easily locate examine code segments affected modification program text 
compilers produce cross listings regular part compilation process 
popular software complexity metrics enabled lexical analysis 
metric devised halstead uses total number identifiers total number operators number unique identifiers number unique operators order compute various measures including difficulty comprehension effort program 
lexical analysis naturally performed lexical analyzer lexer part programming language compiler 
typically uses rules describing lexical program structure expressed mathematical notation called regular expressions 
fact commonplace today build lexical analyzers automatically tools called lexical analyzer generators lex flex 
tools take input set regular expressions produce set tables modeling finite state acceptor language interpreted actual code analysis directly 
draft program comprehension may result lexical analysis stream tokens lexemes set tables compiler symbol table describe properties lexemes 
lexical analyzer produces information easily answer questions average length variable names 
syntactic analysis complex form automated program analysis syntactic nature 
just parse natural language text phrases sentences compilers tools determine expressions statements modules program 
syntactic analysis performed parser 
requisite language properties expressed mathematical formalism case called context free grammar 
usually grammars described stylized notation called backus naur form bnf various program parts defined rules terms constituents 
case syntactic analysis parsers automatically constructed description grammatical properties programming language 
types representation hold results syntactic analysis 
primitive called parse tree 
similar parsing diagrams show natural language sentence broken constituents 
parse trees contain details unrelated actual program meaning punctuation sole purpose direct parsing process 
removal extraneous details leads structure called syntax tree ast basis sophisticated program analysis tools 
ast contains just details relate actual meaning program 
ast tree traversed walked 
nodes tree visited pre set sequence depth order information contained node delivered analyzer 
approach serves basis tools analyst requests desired knowledge high level query expressed terms node types 
standard tree walker interprets query delivers requested information 
control flow analysis program syntactic structure determined possible perform control flow analysis cfa 
forms 
intraprocedural analysis provides determination order statements executed subprogram 
interprocedural analysis determines calling relationship program units 
intraprocedural analysis proceeds constructing control flow graph cfg similar flow chart 
construct cfg basic blocks subprogram determined 
basic block maximal collection consecutive statements control flow top leave bottom conditional unconditional branch 
statement block executes statements execute 
basic block corresponds node control flow graph 
arcs indicate possible flows control 
arcs forward usually indicating branch backward indicating loop 
draft program comprehension may cfg directly constructed ast walking tree determine basic blocks connecting blocks control flow arcs 
control flow graph gives picture ways subprogram execute cluttered details statements basic blocks 
popular metric computed control flow graph 
metric called cyclomatic complexity devised mccabe 
measure amount branching program 
assumption programs similar greater amount branching complex 
interprocedural control flow analysis determination routines invoke 
information displayed call graph main routine top routine connected arcs routines call downward arcs routines calls 
absence procedure parameters pointers analysis trivially computed ast looking statements call 
procedure parameters pointers allow possibility actual routine called known run time 
situations interprocedural analysis performed conservatively routines static analysis possibly value procedure parameter pointed procedure pointer listed possible targets call 
course may lead situation routines listed analysis effectively worthless 
data flow analysis control flow analysis useful questions answer statements may affected execution assignment statement 
answer kind question understanding definitions defs uses required 
usual way variable defined occurs left hand side assignment statement 
note variable may defined numerous statements 
variable value referenced statement example appears parameter call function operand arithmetic expression 
data flow analysis dfa concerned answering questions related definitions flow uses program 
data flow analysis significantly complex control flow analysis 
particular cfa merely detect possibility loops dfa describe happen variables inside loop body 
significant additional power derives additional effort perform dfa 
example code execute variables defined statements altered bug fixed examples tasks enabled data flow analysis 
interprocedural data flow analysis graph def dependencies extended procedural boundaries 
problems arise procedure called arguments correspond memory location 
called alias aliases arise pointers 
simple representation interprocedural dfa information structure chart 
structure chart call graph arcs annotated names formal parameters indication arc supplying values called procedure returning 
draft program comprehension may program dependence graphs refinement dfa construction program dependence graph pdg 
pdgs developed researchers interested converting programs run machines parallel architectures 
pdg control data flow dependencies treated representation 
uniform treatment data control convenient situations require dfg cfg 
addition allowing uniform treatment pdgs structural properties useful program comprehension 
example representing control flow basic blocks cfg pdg represents regions control dependence 
applications regions conceptually appropriate basic blocks canonical 
regions depend control conditions basic blocks cfg depend control conditions 
regions may factored defined terms dependence 
regions common control conditions exist region depends exactly common control conditions 
said control dependent 
popular extension pdg represent data dependence static single assignment ssa form 
ssa form establishes variable reached exactly definition variable variable defined 
determining answers def questions done significantly efficiently ssa form reachable unique definition 
slicing popular derivative data flow analysis provided slicing 
slicing introduced weiser served basis numerous program comprehension tools 
slice program particular variable particular line program just part program responsible giving value variable spot 
obviously debugging determine value variable particular line incorrect easier search faulty code looking appropriate slice examining entire program 
recognition elaboration static program analysis proposed 
involves searching program text instances common programming patterns 
patterns called idioms research tools provide libraries automatically perform searches 
example pattern describing loops performing linear search 
obviously value searched data structure searched possibly mechanism determining match parameters complicating detection process 
variety ways programming linear search variations due parameters ignored 
recognition difficult research problem abstraction power provides promises useful program comprehension technique 
draft program comprehension may interpretation final approach static program analysis mentioned 
just syntactic properties program specified grammar expressed bnf semantic properties provided mathematical technique called denotational semantics 
approach meaning program expressed terms various data types called semantic domains 
example program state bindings variables values denoted table domain 
meaning syntactic program construct statement function describes happens corresponding domains 
example meaning assignment statement function maps state assignment executed state 
possible denotational semantics perform static program analysis 
case alternative functions defined variations original semantic domains 
example wished know variable changed subprogram interpret semantic function assignment statement refer variable worrying possible values single boolean variable indicate changed 
process re interpretation called interpretation popular variety analysis tasks particularly area logic programming languages prolog 
dynamic analysis analysis techniques described far static performed source code program 
possible gain increased understanding systematically executing program 
process called dynamic analysis frequently trying understand performance correctness properties program called respectively profiling testing 
statement level profiler determines number times statement executed procedure level profiler thing procedure calls returns 
profilers instrumenting program inserting extra code counting construct approximation periodically interrupting executing program determine currently doing constructing statistical model 
course testing common form dynamic analysis variety techniques exists making sure test suite thoroughly exercises covers program 
statement coverage assures statement executed 
branch condition path coverage measure extent branches conditions paths executed 
numerous variations exist techniques described section 
partial evaluation final form dynamic analysis deserves mention 
say trying understand complicated real time system implements complex state machine architecture referring collection global variables series nested conditional statements 
systems common telecommunications industry 
suppose trying understand particular anomalous program behavior arises certain circumstances draft program comprehension may example global variables specific values 
traditional way understand situation play computer mentally simulate execution determining flow control evaluating predicates conditional statements terms known values global variables 
course process breaks program gets large 
approach called partial evaluation devised address problems 
partial evaluator software tool takes input program values certain program input parameters 
produces output smaller program equivalent original parameters 
partial evaluator executes program possible replacing program statements values computed 
paint numbers toy manufacturer partially evaluated painting supplying outline leaving consumer produce final picture 
case telecommunications system input parameters really indications state switch hardware lines correspond natural way global variables defining system state 
partial evaluation currently research topic promises provide help understanding programs 
program comprehension tools tools developed aid program comprehension 
available commercially research prototypes 
commercial tools 
compilers compilers course commonly program understanding tools 
senses compiler thought understand program 
compiler understand program translate language underlying machine 
optimizations 
optimizing compilers sure transformations apply program carefully preserve program semantics 
compilers understand errors 
compilers attempt guess programmer really meant erroneous construct supply corresponding correction 
course compilers supply sorts auxiliary information cross tables warnings portability problems possible anomalies uninitialized variables 
compilers provide various additional services augmenting executable version program information support profiling debugging 

class commercial tools specifically designed improve comprehensibility programs 
class includes 
input typically older program written early version language include modern control draft program comprehension may structures undergone sufficient maintenance original structure purpose longer obvious 
program control flow patterns replacing spaghetti code featuring numerous goto statements conditional statements loops 
level analysis fairly superficial help improve comprehensibility localizing related code segments suggesting higher level abstractions 
similar knowledge program layout issues indentation bracketing conventions compound statements whitespace expressions 
particularly useful standardizing appearance large program undergone maintenance different programmers various styles 

translators kinds commercial tools exist convert program different form 
specifically aimed improving comprehensibility allowing algorithm expressed alternative form tools may enable simplifications effect 
example language language translator example 
languages level abstraction transformed code comprehensible original 
happens superficial level understanding typical commercial translator source program 
target language higher level particularly adapted application area successful translation lead significantly smaller modular program 
example sql version cobol program take advantage features built database utilities remove voluminous cobol file manipulation code 
similar nature 
tools capable advantage regularities algorithm produce code vector hardware boxes parallel machines producing answers efficiently 
example loops replaced single statement acting simultaneously elements array 
resulting program consequently reduced size original presumably easier understand 

case tools computer aided software engineering case segment computer software market originally promoted helping initial construction large software systems teams developers 
case tools typically provide variety graphical editors expressing high level designs consistency checkers detecting problems cases code generators producing programs 
case vendors realized types diagrams previously manually drawn developers prove useful understanding existing code 
cases diagrams automatically constructed code 
probably common diagram structure chart 
indicates subprograms invoke names types arguments passed 
types available diagrams include dataflow diagram indicating major software modules draft program comprehension may data repositories data control information flow entityrelationship diagram describe major external sources sinks data modules 
expect case tools sophisticated types diagrams analyses added 

program analysis transformation tools class tools entered marketplace differs significantly ones mentioned 
tools class idea wide spectrum language specifying program analyses transformations 
wide spectrum language contains features classes languages typically imperative functional object oriented logic languages 
added power provide language enables terse expression queries program features 
example class language refine successfully variety ambitious program understanding projects 
refine basis collection commercial tools called software refinery 
software refinery consists components provide comprehensive toolkit 
piece consists set language specific browsers analyzers deep understanding particular language 
browsers analyzers capable producing variety reports including mentioned cross listing structure chart 
example refine tool provides source code structure chart dataflow diagram browsers variety reports describing names programs 
second third pieces software refinery building language specific tools refine second parser generator third user interface builder 
tools express results refine refine compiler fourth tool 
refine includes pattern matching features support querying syntax trees built language specific parsers 
ast symbol table results analyses stored object oriented repository refine language statements easily access 
repository fifth component software refinery architecture 
sixth set built language independent analyzers constructing common representations structure charts 
software refinery described detail advanced tools commercially available complexity indicative amount effort required perform modest analyses 
research tools section gives quick look variety tools currently development research community 
purpose show breadth approaches undertaken making claims completeness 

confused dataflow analysis described earlier 
draft program comprehension may 
gen gen analyzer generator 
input description specific program query analysis desired programs 
output analyzer program performs query program 
language queries contains variety high level constructs specifying tree walks formatting output 
tool strength comes depth knowledge notoriously difficult language build tools comprehensive ast representation contains data extracted analysis 

cia cia cia stands information cia variant 
tools placing results standard analysis relational database 
queries database give answers questions concerning program 
tools program data model containing entities relationships describing structure typical programs 
examples typical entities modules global variables files typical relationships include function calls file inclusions variable declarations 
data model analysis fixed tool presence query language permits tools answer complex queries unanticipated original tool designers 

example recognition system 
analyzer builds dataflow graph annotated control flow information constraints 
representation programs allows efficiently deal variations sophisticated techniques handle 
power comes library ability detect instances programs efficient graph parsing algorithm 
describe common programming knowledge sort list knowledge application domain particular ways schedule events simulation programs 

desire ambitious systems developed desire tool microelectronics computer consortium 
desire goal design recovery uses informal knowledge variable names comments traditional formal analysis build hierarchy concepts describe program 
uniqueness desire fact concepts domain concepts program concepts stressing knowledge related program 
desire experimental feature uses neural network technology help recognition process 

tango difficult part understanding program nuances core algorithms 
active research area called software visualization attempts draft program comprehension may aid process providing graphic tools display representations fundamental operations underlying data structures program execution 
example array sorted viewed order provide dynamic depiction contents ordered 
tango tool provides analyst relatively easy mechanism producing animations 
analyst annotate program key points specify operations drive creation modification geometric shapes display screen 
sorting example array elements represented blocks heights corresponds values move position position program exchanges values 
course sort animation useful understanding execution existing program teaching algorithmic concepts programmers 
vi 
examples applications program comprehension program comprehension useful variety purposes 
purposes relate acquiring sufficient knowledge system enable migrating adapting enhancing system 
tasks adds challenges difficult task understanding system 
section provides variety applications program comprehension 
database migration older commercial software systems originally developed cobol database technology probably aimed mainframe computing environment 
cobol flat files hold data contained abundant code provide services currently provided part commercial database management system 
today relational database technology dominates strong movement distributed computation networked workstations 
migrate older programs requires determining structure data deciding appropriate new organization ascertaining operations performed data determining best obtain services new environment 
approaches solving database re engineering problem batini ceri navathe book 
user interface migration similar albeit understood problem concerns adapting software system uses form user interface technology 
simple moving graphical user interface gui widget set ambitious adding graphical interface batch program 
database migration small set defined data schemas exist user interface migration problem deal issues large variety commercial toolkits matching look feel 
order re engineer application new user interface old interface determined extracted replacement designed code updated support new approach 
little done area 
reader referred 
draft program comprehension may interest object oriented languages led desire migrate existing legacy systems object oriented languages 
requires detection candidate objects existing code affiliated operations 
object requires small set related data items limited number operations accessing 
candidates identified code translated target language 
area reported 
specification extraction trend direction increased formal methods software development 
formal specification reduces ambiguity enables proof techniques ascertain properties correctness security safety 
formal specification involves statement mathematical notation predicate logic conditions subprogram correctly operate preconditions statement describing effect program state postconditions 
straight line code conditionals automatically constructing pre postconditions straightforward loops cause problems 
understanding loop requires constructing predicate describes typical operation 
automated techniques task currently exist 
basili mills describe manual specification extraction help understand program 
describes attempts automate process 
cics project england related technique support complete reengineering large transaction processing system 
business rule extraction large software systems thought capital assets 
written description enterprise conducts business 
accuracy user system manuals degrade time system arbiter existing business conduct 
necessary read code run program get answers fundamental questions 
activity come called business rule extraction case tool vendors support process 
vii 
challenges progress area program understanding remains done 
section describes outstanding challenges researchers field study 
scaling program understanding tools restricted various ways 
restrictions relate sheer size programs capable dealing ability deal multiple concurrent processes relatively low level representations provide 
example commercial tool organizes results analyses database indexed names draft program comprehension may various functions procedures global data systems analyzed 
tool incapable dealing legacy system organized processes external names may duplicated distinct processes 
database support instances name independent processes 
size system study grows larger issues architecture dominate questions concerning details programming 
existing tools better able deal 
fact area software architecture come examination research community 
implication large systems person necessarily involved analysis 
questions arise knowledge shared analysts redundant reduced avoided 
date reported application collaboration technology problems program understanding 
final problem relates sheer volume data generated analysis large systems 
dataflow diagrams structure charts valuable navigating system containing procedures little help looking systems orders magnitude larger 
preliminary problem reported 
process issues known effective process management significantly aid production software study area primarily concerned development systems initial conception delivery analysis reengineering 
example development managers existing system may confronted decision continue maintenance system reengineer scrap rebuild scratch 
little available data guidelines help management decision 
process models proposed little validation done 
software technology support center hill air force base compiling project histories 
software engineering institute producing best practices guidebook 
interesting experience report contains actual cost analysis boehm includes chapter book software engineering economics software maintenance projects 
rugaber discuss transition strategies particular case reengineering mainframe management information systems distributed workstation environment 
domain knowledge discussed progress automated program understanding leveraged compiler technology 
implication answer questions questions answers essential full advantage legacy systems 
questions relate program constructs problem program supposed solve 
application problems typically couched terms application domain analysis data locate underground reservoirs oil computation accelerated depreciation allowance income tax return preparation 
draft program comprehension may order fully understand programs application domain understood preferably modeled 
domain problem area application domain analysis currently active area research 
typically application programs exist solve problems single domain 
prieto diaz give prerequisites presence domain existence comprehensive relationships objects domain community interested solutions problems domain recognition software solutions appropriate problems domain store knowledge collected wisdom address problems domain 
recognized domain characterized vocabulary common assumptions architectural approach literature 
role domain description play reverse engineering program 
general domain description give reverse engineer set expected constructs look code 
computer representations real world objects tax rate tables deductions 
may algorithms lifo method inventories 
architectural schemes client server architecture implementing transaction processing system 
domain broader single problem may expectations engendered domain representation specific program inventory algorithm may appear program compute personal income taxes business tax program program accurate date may things missing incorrectly expressed program despite domain representation 
program purpose may include components appear domain representation balancing feature income tax package 
domain representation establish expectations confirmed program 
furthermore objects domain representation related organized prototypical ways may likewise recognized program 
domain representation act schema controlling reverse engineering process template organizing results 
incorporating domain information program understanding process essential answering important questions 
domain analysis applied problem program comprehension 
exception desire system described previously 
research project area described rugaber 
validation study program comprehension emerging discipline 
readily accepted infrastructure exists validate proposed advances 
example exist agreed benchmarks comparing analysis tools 
exist mechanism integrating tools 
example standard language describing commonly occurring programming patterns repository built researchers rely 
course final arbiter value research software development practitioners agreed standard evaluation turing test proposed measure success natural language understanding programs 
program understanding draft program comprehension may research community commercial vendors need address problems widely accepted 
viii 
resources aside provided article reader referred sources information topics program understanding reverse engineering 
conferences workshops international conference software maintenance workshop program comprehension working conference reverse engineering symposium partial evaluation program manipulation reverse engineering forum 
journals journal software maintenance reverse engineering newsletter committee reverse engineering ieee computer society 
additionally mainstream journals software area ieee transactions software engineering ieee software communications acm journal automated software engineering software practice experience occasionally publish articles program analysis understanding 
books books published area arnold software reengineering tutorial software restructuring software reuse reverse engineering edited hall redo compendium reverse engineering software maintenance empirical studies programmers series published ablex 
re engineering tool report hill air force base software engineering institute planned best guidebook collect experiences actual reengineering projects 
theses theses published area griswold hartman letovsky ning wills 
world wide web page contains pointers area url www cc gatech edu reverse 
ix 
barry boehm 
software engineering economics 
prentice hall 
swanson 
characteristics application software maintenance 
communications acm june 

application program maintenance study report respondents 
proceedings guide philadelphia pa april 
elliot chikofsky james cross ii 
reverse engineering design recovery taxonomy 
ieee software january 
draft program comprehension may smith 
re engineering fit 
proceedings sixth annual hawaii conference systems sciences 
volume iii information systems dss knowledge systems jay nunamaker jr ralph sprague jr editors ieee computer society press pp 
edsger dijkstra 
go statement considered harmful 
communications acm november 
spencer rugaber kurt linda wills 
interleaving problem program understanding 
nd working conference reverse engineering toronto ontario canada july appear 
eliot soloway pinto stan letovsky david littman robin 
designing documentation compensate delocalized plans 
communications acm november 

guided tour program design methodologies 
ieee computer october pp 

belady lehman 
programming system dynamics meta dynamics system maintenance growth 
technical report rc international business machine september 

understanding debugging programs 
international journal studies february 
soloway ehrlich 
empirical studies programming knowledge 
ieee transactions software engineering se september 
brooks 
behavioral theory program comprehension software engineering 
proceedings third international conference software engineering may atlanta georgia ieee computer society pp 

stephen spencer rugaber 
reverse engineering resolving conflicts expected actual software designs 
proceedings conference software maintenance orlando florida november pp 

von vans 
program understanding survey 
cs department computer science colorado state university august 
robson bennett munro 
approaches program comprehension 
journal systems software elsevier north holland february 
paul atul prakash erich buss john henshaw 
theories techniques program understanding 
tr ibm canada laboratory october 
alex quilici 
memory approach recognizing programming plans 
communications acm may 
ben shneiderman 
software psychology human factors computer information systems 
little brown 
ben shneiderman 
exploratory experiments programmer behavior 
international journal computer information sciences june 
draft program comprehension may 
effectiveness comments pilot study 
ibm technical report sdd july 
ben shneiderman 
measuring computer program quality comprehension 
international journal man machine studies 
weissman 
psychological complexity computer programs experimental methodology 
acm sigplan notices 

fortran program comprehension function documentation 
school business administration university wisconsin milwaukee wisconsin 
tom love 
relating individual differences computer programming performance human information processing abilities 
ph thesis university washington 
ben shneiderman mckay 
experimental investigations computer program debugging modification 
proceedings th international congress international ergonomics association college park maryland july 
brooks 
theory cognitive processes computer programming 
international journal man machine studies 
brooks 
theory comprehension computer programs 
international journal man machine studies 
susan wiedenbeck 
processes computer program comprehension 
empirical studies programmers eliot soloway iyengar editors ablex publishing norwood new jersey pp 

soloway ehrlich 
empirical studies programming knowledge 
ieee transactions software engineering se september 
published rich waters editors readings artificial intelligence software engineering morgan kaufmann 
eliot soloway jeffrey kate ehrlich 
cognitive strategies looping constructs empirical study 
communications acm november 
stanley letovsky 
cognitive processes program comprehension 
empirical studies programmers soloway iyengar editors ablex publishing norwood new jersey 
letovsky soloway 
delocalized plans program comprehension 
ieee software may 
eliot soloway pinto stan letovsky david littman robin 
designing documentation compensate delocalized plans 
communications acm november 
maurice halstead 
elements software science 
elsevier 
john levine tony mason doug brown 
lex yacc nd edition 
reilly associates october 
backus 
syntax semantics proposed international algebraic language zurich acm conference 
proceedings international conference information processing unesco paris france june 
draft program comprehension may matthew hecht 
flow analysis computer programs 
north holland 
mccabe 
complexity measure 
ieee transactions software engineering december 
stevens myers constantine 
structured design 
ibm systems journal 
jeanne ferrante karl ottenstein joe warren 
program dependence graph optimization 
acm transactions programming languages systems july 
mark weiser 
program slicing 
proceedings th international conference software engineering san diego california march ieee computer society pp 

linda mary wills 
automated program recognition graph parsing 
tr mit artificial intelligence laboratory july 
scott strachey 
mathematical semantics computer languages computers automata fox editor polytechnic institute brooklyn press pp 

cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
fourth annual acm symposium principles programming languages los angeles california january pp 

herbert harry 
reverse engineering programs dynamic analysis 
proceedings working conference reverse engineering baltimore maryland may pp 

elaine weyuker 
evaluation program software test date adequacy criteria 
communications acm june 
frank 
partial computation construction language processors 
prentice hall 
robert arnold 
tutorial software restructuring 
april ieee computer society 
feldman david gay mark 
fortran converter 
computing science technical report bell laboratories may 
waters 
program translation abstraction reimplementation 
ieee transactions software engineering august 
hans zima barbara chapman 
supercompilers parallel vector computers 
acm press 
elliot chikofsky 
computer aided software engineering case nd edition 
ieee computer society press 
james martin mcclure 
structured techniques basis case revised edition 
prentice hall 
draft program comprehension may chen 
entity relationship model unified view data 
acm transactions database systems march pp 


local formalisms widening spectrum wide spectrum languages 
program specification transformation meertens editor elsevier north holland pp 

douglas smith gordon stephen 
research knowledgebased software environments kestrel institute 
ieee transactions software engineering november 
software refinery toolkit 
reasoning systems incorporated palo alto california 
devanbu 
genoa customizable language front independent code analyzer 
proceedings fourteenth international conference software engineering melbourne australia may pp 

yih chen michael ramamoorthy 
information abstraction system 
ieee transactions software engineering march 
judith grass yih chen 
information 
usenix conference pp 

wills 
flexible control program recognition 
working conference reverse engineering baltimore md may 
ted biggerstaff bharat dallas webster 
program understanding concept assignment problem 
communications acm may 
price ronald baecker ian small 
principled taxonomy software visualization 
journal visual languages computing september 
john stasko 
tango framework system algorithm animation 
ieee computer september 
william premerlani michael blaha 
approach reverse engineering relational databases 
communications acm may 
carlo batini stefano ceri navathe 
conceptual database design entity relationship approach 
benjamin cummings 
merlo girard kontogiannis panangaden 
reverse engineering user interfaces 
proceedings working conference reverse engineering ieee computer society press baltimore maryland may 
larry van zheng yang liu michael 
recovering user interface specifications porting transaction processing applications 
nd workshop program comprehension july capri italy 
melody moore 
spencer rugaber phil 
knowledge user interface migration 
proceedings international conference software maintenance victoria british columbia canada september pp 

ong tsai 
class object extraction imperative code 
journal object oriented programming march april 
draft program comprehension may liu roger norman wilde 
object finder design recovery tools 
serc tr university florida software engineering research center january 
cimitile munro 
program comprehension identification data types 
proceedings rd workshop program comprehension pp 
washington november 
basili mills 
understanding documenting programs 
ieee transactions software engineering se may 
philip mark richard linger alan 
function abstraction understand program behavior 
ieee software january 
ian hayes 
applying formal specification software development industry 
ieee transactions software engineering se february 
gregory abowd robert allen david garlan 
style understand descriptions software architecture 
sigsoft december acm pp 

stephen eick joseph steffen eric sumner jr seesoft tool visualizing line oriented software statistics 
ieee transactions software engineering november 
lowell jay arthur 
software evolution 
john wiley sons 
chris mike murdock 
re engineering tools report 
software technology support center hill air force base may 
hobbs john mitchell glenn richard 
re engineering old production systems case study systems re development evaluation success 
emerging information technologies competitive advantage economic development proceedings information resources management association international conference may pennsylvania pp 

barry boehm 
software engineering economics 
prentice hall 
spencer rugaber srinivas 
transition application programs cobol fourth generation language 
conference software maintenance september montreal canada pp 

guillermo prieto diaz 
domain analysis concepts research directions domain analysis software systems modeling prieto diaz guillermo editors ieee computer society press 
jean marc spencer rugaber 
domain analysis reverse engineering 
proceedings international conference software maintenance victoria british columbia canada september pp 

cimitile munro 
program comprehension identification data types 
proceedings rd workshop program comprehension washington november pp 

draft program comprehension may alan turing 
computing machinery intelligence 
computers thought feigenbaum feldman editors mcgraw hill pp 

robert arnold 
software reengineering 
ieee computer society 
hall editor software reuse reverse engineering practice 
chapman hall 
henk van editor 
redo compendium reverse engineering software maintenance 
john wiley 

understanding programs devices 
ohio state university ph thesis 

inter module code analysis techniques software maintenance 
ph thesis university durham computer science 
william griswold 
program restructuring aid software maintenance 
ph thesis tr department computer science engineering university washington august 
john hartmann 
automatic control understanding natural programs 
ph thesis department computer sciences university texas austin may 
letovsky 
plan analysis programs 
ph thesis yale university 
ning 
knowledge approach automatic program analysis 
ph thesis university illinois urbana campaign october 
