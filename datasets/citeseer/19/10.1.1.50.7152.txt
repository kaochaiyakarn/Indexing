henk typed intermediate language simon peyton jones university glasgow oregon graduate institute erik meijer university utrecht oregon graduate institute may growing interest richly typed intermediate languages sophisticated compilers higher order typed source languages 
intermediate languages typically stratified involving terms types kinds 
sophistication type system increases levels look similar attractive approach single syntax single data type compiler represent 
theory called pure type systems precisely identification 
describes henk new typed intermediate language closely particular pure type system lambda cube 
way give tutorial lambda cube 
overview compilers divided main stages 
front translates source language intermediate language middle transforms efficient form back translates intermediate language target language 
past intermediate languages source languages rich type systems usually un typed 
compiler type checks source program translates program intermediate language discarding type information 
type checking simply ensured program go wrong run time checked types 
increasing interest typed intermediate languages peyton jones peyton jones shao appel tarditi 
motivations approach compiler may able take advantage type information generate better code may desirable treat types values run time case necessary maintain june workshop types compilation 
accurate compile time types compiler check activity desired checking type correctness intermediate program 
elaborate points section 
describes design new typed intermediate language henk designed compilers purely functional languages 
distinctive features ffl henk directly lambda cube expressive family typed lambda calculi 
shortage introductory material lambda cube tutorial section 
ffl henk small language constructors data type expressions 
real language sense rich compiler intermediate language 
ffl lambda cube heritage henk uses single syntax terms types kinds 
better compilers henk single data type represent levels 
leads considerable economy syntax language utility functions compiler 
ffl henk explicit concrete syntax 
intermediate languages typically expressed data type particular compiler 
giving concrete syntax apparently trivial step believe important compiler writers pay little attention 
compiler front produce henk consumed back different compiler transformed external program fed back original compiler 
introduces new technical results 
main contribution build bridge type theory compiler research community ffl suggest lambda cube basis typed intermediate language 
bother 
see persuasive reasons dramatically reduces number data types volume code required compiler 
example glasgow haskell compiler ghc separate data types terms types kinds separate algorithms parsing printing typing transforming 
collapsing levels gets rid duplication 
easier accommodate new developments type system source language lambda cube type language expressive term language 
ffl give tutorial lambda cube emphasising aspects relevant compiler builders 
literature relatively post written point view theorists 
initial focus non strict languages hope henk neutral respect strict non strict question 
having variants henk strict non strict hope single language treats styles class citizens allows free mixing single program 
assume familiarity lambda calculus general second order lambda calculus called particular 
background motivation type directed compilation recognized time maintaining type information right code generation beneficial 
specifically ffl accurate type information guide compiler analyses transformations 
example strictness analysis non flat domains guided type information peyton jones partain 
compiler may able efficient representations data values knows types 
example integer represented integer pointer box containing integer strict language lazy contexts integer certainly evaluated 
price paid unboxed integers passed polymorphic functions representation differs simple pointer polymorphic code typically expects 
guided type information specialise polymorphic function unboxed types peyton jones launchbury tarditi 
transformations remove intermediate data structures called deforestation fusion transformations rely heavily types guide transformation 
cases correctness transformation relies parametricity property typed polymorphic functions gill launchbury peyton jones hu iwasaki takeichi launchbury sheard 
ffl traditional static type checking performed completely compile time 
sophisticated settings may useful postpone type checking run time 
example reasonable programs readily expressed static type systems notably ones involving meta programming 
proposals incorporating type dynamic statically typed language involve run time check type value matches expected type 
statically specialise polymorphic function types called pass type explicit argument function behave appropriately harper morrisett 
tag free garbage collectors need run time type information guide tarditi tolmach 
applications require accurate type information available run time compile time 
ffl debugging compiler nightmare 
evidence incorrect transformation segmentation fault large program compiled compiler 
identifying cause crash tracing back faulty transformation long slow business 
compiler type checks intermediate language program transformation huge majority transformation bugs short order 
quite difficult write incorrect transformation type correct 
furthermore program crash type correct incorrect transformations give unexpected result crash usually easier trace 
call henk type checker core lint 
compiler correct core lint useful switched default 
experience ability localise compiler bugs justify typed intermediate language 
compilers maintain type information compiler come called type directed 
standard ml new jersey type directed time shao appel internal type system monomorphic track types polymorphic functions 
glasgow haskell compiler ghc language second order lambda calculus intermediate language peyton jones peyton jones 
til compiler uses considerably sophisticated complicated intermediate language capable expressing intensional polymorphism including recursive functions level types tarditi 
til uses stratified type system simplifies proof theory lead considerable duplication compiler transformations tarditi 
speculate lambda cube provide theoretically sound way get best worlds 
shao developing typed intermediate language flint similar goals til shao 
implicit vs explicit typing important distinguish typing requirements source language intermediate language 
source languages degree implicitly typed 
continuum full type inference type information programmer type checking type information 
type system source language usually delicate compromise expressiveness type inference 
expressive type system guidance form type signatures type checker 
hand highly implausible implicitly typed intermediate language hard ensure transformation preserves delicate property types inferred program source 
desugaring expression lambda abstraction applied right hand side definition 
intermediate language explicitly typed 
front translates source program intermediate language decorate type information results type inference source program 
compiler reason wants check type correctness intermediate language program matter type checking type inference 
practical terms type checking involve unification sophisticated algorithms 
furthermore explicitly typed intermediate language expressive type system source language 
example intermediate language permit arbitrary universal quantification types source language ml haskell restrict universal quantification top level type lambda cube obvious retrospect breakthrough realised second order lambda calculus precisely needed express maintain type information intermediate language compiler 
peyton jones gives examples 
large body theory design choices pressed immediate service 
henk aim take idea step body theory lambda cube adopting design choices structure language 
haskell type classes give rise intermediate language constants rank polymorphic type nice example way language feature type discipline unworkable full generality 
specifically henk goes second order lambda calculus ways ffl elegantly parameterised 
simply selecting discarding type rules force henk equivalent simply typed lambda calculus secondorder lambda calculus girard extension higher order kinds 
girard calculus constructions coquand huet 
section show extract predicative version 
ffl happens haskell type system allows type variables range type constructors merely types generality 
required 
henk puts extension firm theoretical foundation somewhat ad hoc extension ghc earlier core language 
ffl henk provides full lambda calculus level types 
provided recursion disallowed restriction easily expressed type system evaluation types strongly normalising guaranteed terminate really defining property type 
lambda calculus subsumes haskell type synonyms receive ad hoc treatment ghc permits explore ambitious paths suggested til 
ffl despite extra richness henk small language 
data type expressions example constructors 
better syntax expressions types kinds 
economy reflected type system single set rules say term typed type kinded kind formed 
compiler single data type represents terms types kinds single set utility functions parse print type check 
object compiler data type represent terms types allow buggy compiler construct ill formed terms attributing type variable 
ghc current structure thing identified ill typed compiling compiler datatype representing terms place datatype representing types 
ghc current structure may prevent compiler accidentally constructing bogus terms eliminate 
example true legal value datatype terms course ill formed 
rely core lint section identify bugs 
folding levels postpone detection certain unusual errors compiler compilation time compiler run time 
constant variable ee application abstraction pix quantification syntax pure type system expressions pure type systems lambda cube new typed intermediate language look 
fortunately barendregt done hard barendregt 
pure type systems pts elegant way presenting explicitly typed lambda calculi uniform way give exactly want 
literature pure type systems written perspective theorists excellent faint 
section tutorial pure type systems small expression language 
section elaborate calculus real language 
familiar core syntax pts expressions 
productions familiar variables applications abstractions 
language explicitly typed variable bound lambda abstraction annotated type 
fifth production pi abstraction key idea pts see shortly subsumes function arrow universal quantification 
mixing terms types unusual feature pts world type bound variable lambda abstraction simply expression 
types syntax terms 
attractive idea 
terms conventional syntax types includes constants int type variables applications tree int abstractions form type synonyms polymorphic system binding construct universal quantification 
furthermore second order lambda calculus requires abstractions applications types appear terms 
pts single form abstraction application suffices syntactic point view 
example expression written ff ff id ff introduces type abstraction binds type variable ff turn type body abstraction polymorphic identity function type ff ff ff applied ff square brackets indicate type application 
pts language abstraction application forms serve types terms rewrite expression ff ff id ff notice decision forces attribute type variable ff 
type type called kind kind constant usually pronounced type 
ff simply says ff kind type ff type variable 
question begs asked kind 
answer 
type variables range type constructors types precisely distinguishes 
example 
write 
int tree lambda abstracts kind 
second lambda abstracts values type int 
abstraction applied type constructor tree kind presumably 
short syntax forced attribute type ff move 
done 
extra power 
required compiler intermediate language 
clearly depends source language extra power certainly required haskell type system explicitly includes higher kinded type variables particularly support constructor classes jones 
far attractive worries 
interpret function arrow language types 
constant 
special intimate relationship abstraction application term level 

play role universal quantification language types 
take experimentation convince oneself inappropriate purpose 

types values mixed sure resulting expression sense 
give sensible type rules language 
questions elegantly resolved fifth form expressions turn attention 
notation helpful establish terminology 
identified levels far terms types kinds 
expression described syntax denote term type kind 
call levels sorts say expression innovation haskell earlier versions haskell higher kinded type variables 
sort term sort type sort kind 
commonly simply say expression term type kind 
unfortunately hard avoid word type multiple purposes 
particular note difference sort type kind type 
example int tree 
sort type int kind type int 
formed term belongs type formed type kind 
type system specifies precisely expressions formed 
general pts may levels infinite number study particular family ptss called lambda cube 
type system lambda cube ensures levels required apart solitary constant fourth level shall see 
writing example programs typewriter font term variables constants int greek font type variables ff fi 
writing program schemes example type rules range variables sorts range expressions sorts 
generally sort higher say term type 
range constants 
quantification fifth production syntax pts expressions introduces dependent product pi 
essentially equivalent ways interpreting expression pix purposes useful pix type functions values type values type result type may depend value argument definition immediately clear pi subsumes function arrow abbreviation pi underscore symbol denote anonymous variable 
say pix occur free pi 
obvious pi subsumes universal quantification 
consider type piff type 
type type functions values kind 
types values type terms type may mention ff 
precisely interpretation give ff short ff abbreviation piff example consider combinator defined write typing judgement body fffi ff fi fffi ff fi fi pts write judgement ff fi ff fi piff ff fi fi blow pi deals worries section 
price making third worry worrying 
example writing types 
pix int int bool type functions values type int result type int argument greater bool 
type checking may require arbitrary computations term level 
pts framework allows answer question ways 
arrange strange types ill formed 
decide expressiveness gives permit 
choice equivalent adopting calculus constructions coquand huet 
pts framework allows terms types mix 
ensure construct expressions sense means type system discuss 
lambda cube type system write typing judgements conventional way 
judgement gamma read environment gamma expression type 
environment gives types free variables expression example correctly state fint int int intg int int int type rules lambda cube 
var rule quite familiar simply says environment gamma attributes type conclude premise checks type formed 
context gamma sequence set inner bindings right outer ones 
weakening rule weak allows throw away irrelevant bindings checking formed usually applied necessary just var rule 
remember just abbreviation pi star gamma gamma var gamma gamma gamma weak gamma pix gamma gamma app gamma gamma pix gamma pix lam gamma gamma gamma pix pi gamma gamma fi gamma conv type rules lambda cube second rule star easy 
states constant super kind 
hierarchy stops lambda cube 
typing rule appear explicitly program 
things interesting meet rule applications app 
ordinary lambda calculus usually sees rule gamma gamma gamma remembering abbreviation pi easy see ordinary rule obtained specialising rule app substitution special case occur meant 
exciting thing rule app deals correctly type applications 
rule type applications called spec specialises polymorphic type gamma ff gamma ff moments thought remembering ff abbreviation piff convince app subsumes time substitution app vital just substitute ff 

judgement rule app expects pi type 
rule lam shows pi types introduced place 
helpful compare rules 
rules value type abstractions gamma gamma gamma gamma ff ff states assuming type prove body abstraction type abstraction type compare rule lam premise match rules directly 
second premise interesting 
mission check legitimate variable expression type simply requiring type legitimate type type 
example type abstraction ff permitted iff type ff oe permitted oe 
course just begs question 
precisely pi type valid type 
answer look pi rule 
specifies find type expression pix 
premise checks formed finds type second remembering bring scope 
third premise uses new judgement form defined axioms axioms involve constants judgement generate copies rule pi values fact lambda cube describes family type systems defined selecting subset axioms discuss 
specialise rule pi axiom 

mean 
means kind types moving back rule lam term variable term expression 
read 
terms depend terms 
furthermore axiom value abstractions sort abstractions allowed simply typed lambda calculus 
needed allow type abstractions need second order lambda calculus 
looking rule lam need type variable fi plus usual rules symmetry reflexivity transitivity 
conversion rules expressions kind 
body type abstraction term type 
get need axiom read terms depend types get 
need kind higher kind 

premise pi requires gamma 
turn requires give typing judgement pi 
re rule pi 
immediate consequence require axiom order conclude 


requires axiom read types depend types 
happen added final axiom 
allow types depend terms calculus constructions coquand huet 
territory compilers stay clear avoid 
summarise equivalences system corresponding subset simply typed calculus 


calculus constructions 
systems selecting subset remaining axioms gives rise term lambda cube 
systems sense ones just identified interesting ones 
completing type system final rule conv states deduce type expression fi equivalent valid type rule necessary 
notice rule app substitute arbitrary term type expression type expression necessarily normal form application example 
second notice premise rule app requires type pi expression 
suppose type expression evaluates pi expression piy 
rule conv simply allows necessary reduction take place 
fi relation defined 
slight awkwardness read notation backwards means depend 
confusingly read terms types judgement levels away original thing 
star gamma gamma var gamma 
pix gamma fi gamma app gamma gamma pix gamma pix lam gamma 
gamma 
gamma pix pi gamma 
wh gamma 
red syntax directed rules lambda cube syntax directed rules inference rules directly suitable core lint type checker rules syntax directed 
particular decide point derivation rule conv applied simply looking structure term consideration 
seek syntax directed presentation rules sound complete respect old set new presentation type exactly terms exactly way 
generality ptss task quite tricky pollack van benthem jutting mckinna done hard 
gives simplified version syntax directed system 
main difference compared rules strategic distribution reduction 
rules 
notation 
wh means reduces weak head normal form new judgement form gamma 
means gamma gamma 
wh rule red states 
taken opportunity introduce socalled valid context optimization 
assume initial context formed notion easy define formally remain formed rules extend lam pi binding type formed 
need check formedness rules var weak 
furthermore adopt barendregt convention variable names distinct 
result regard gamma unordered bag sequence means weak altogether favour premise gamma var 
known pollack van benthem jutting mckinna section 
type means type type star type type var type type type app type type type pix lam type type type pix pi type type fi pi type conv type type judgement type factoring typing judgement typing judgement things ffl checks expression formed 
ffl finds type 
inside compiler hope program formed initial type check compiler quite frequently want find type expression 
type judgement type finds type formed expression environment 
achieve annotate bound occurrence variable type 
property useful practice means compiler contain simple function corresponding type maps expression type needing plumb environment 
expensive annotate variable occurrence 
necessarily 
compiler maintains graph single data structure represent int say simply point data structure binding site occurrence site 
app type rule uses neat trick due nederpelt nederpelt 
perform substitution rule app simply apply type function argument conv type allows evaluate applications necessary additional pi reduction rule pix pi pi new presentation practical advantage compiler allowing separate type finder evaluator compiler type longer mentions substitution 
extract type expression evaluate 
curious feature way doing things type expression may formed 
consider expression id int 
rule app type say type piff ff ff int 
type evaluates formed int int expected wellformed 

piff ff ff type pi type 
bit suspicious intermediate ill formedness advantages persuasive 
note rules var app rules easily modified incorporate changes introduced section 
predicative variant disadvantage system described far impredicative 
impredicative system type variables range universally quantified types 
example suppose ff ff int 
type application legitimate fi fi fi instantiated polytype fi fi fi 
wrong sense typed programs go wrong ability type variable range greatly complicates business providing model calculus mitchell chapter 
defining predicative variant fortunately fairly easy produce predicative variant calculus 
just kind need constants kind monotypes 
kind corresponding kinds super kinds 

requires new rule star 
system predicative requires distinctions depend 
new rule pi 
judgement defined 
rules new judgement specify types monotypes 
example assuming int deduce int int int ff ff int 
ff ff int int 
gamma 
star gamma gamma gamma pix pi 


modified rules predicative variant example shows value polymorphic type passed argument function resulting function type kind 
notice third rule differ need place judgement 
rules 
say legitimate variable monotype polytype giving polytype case 
says ok create lambda abstractions type level provided variable monotype 
imagine having allowing variable polytype doesn pressing reason add life simpler 
important thing axiom form corresponding fact variable 
pure type systems rules take outside lambda cube 
fortunately generalisation studied 
generalised pi rule original rules var lam app define pure type system 
pts defined ffl rules var lam app pi 
ffl set constants case 
ffl set typing axioms relating constants 
case 
ffl set rules ranging constants sq 
pts called functional ffl ffl practice practically useful ptss certainly ones functional 
useful theorems substitution lemma subject reduction proved arbitrary ptss true functional ptss uniqueness types barendregt section 
functional ptss combine desirable theorems remarkable degree flexibility example developed predicative variant section draft completed 
real language elaborate small language previous section full language complete concrete syntax 
full language 
compared previous section add features ffl program consists set mutually recursive data declarations introduces new data type section 
sequence value declarations may recursive non recursive section 
ffl expressions augmented letrec case section 
ffl special anonymous variable provided section 
ffl variety abbreviations provided section syntactic sugar 
abbreviations marked left column 
purpose reduce number characters takes print program comprehensible human reader 
name space 
haskell programs name data type data constructor need renamed expressed henk 
production come primitive operations 
program program type declaration data tvar tvar value declaration bind non recursive letrec bind recursive binding bind tvar expr expression expr tvar expr tvar expr pi tvar expr tvar expr 
expr expr local declaration case expr alt case expr alt application tvar variable literal literal constant box constant expr typed variable tvar var var variable var 
binding sites identifier case alternative alt pat 
expr pat tvar 
expr case patterns pat tvar literal indicates syntactic sugar concrete syntax type declarations important design choice introduce new types explicit declarations outside syntax expressions 
data declaration defines new algebraic data type 
introduces new type constructor plus number data constructors environment 
example type generalized trees values type defined data tree 
branch 
tree 
tree declaration introduces type constructor tree data constructor branch specified type 
ml haskell type constructors data constructors required start upper case letter 
main design alternative provide primitive type constructors unit sum product lifting recursion ordinary value declarations introduce new types 
example introduce lists list 
rec 
lift unit whilst nice theoretical standpoint disadvantages ffl generalise easily handle mutual recursion non uniform data types common legal ml haskell 
ffl hard know unwind recursion example testing types equality 
ffl harder prove strong normalisation types 
opted conservative exploit type structure know 
extra generality arbitrary products sums worth complexity 
value declarations value binding binds variable value 
term value int type value diag pair 
value bindings grouped recursive non recursive declarations 
value declarations appear top level program local declarations inside expressions 
anonymous variable anonymous variable binding site variable mentioned scope 
useful concrete syntax reduce creation new names 
importantly useful inside compiler allows evaluator eliminate substitution step applying abstraction pi bound variable unused 
abstractions common function arrow turns 
case expressions case expression takes apart values built constructors 
example case reverse xs cons 
ys rhs 
nil 
rhs 
int case expression expression called scrutinee 
scrutinee reverse xs example 
evaluates expression head normal form matches alternatives 
pattern case alternative literal constructor name patterns case expression type 
list types clause gives types constructors instantiated empty patterns literals 
example xs presumably list int cons nil instantiated int 
alternative selected right hand side applied values arguments constructor 
reverse xs evaluates cons int 
result case expression ys rhs 


pattern selected fail match regardless order 
form case little unusual 
typically patterns bind variables case reverse cons ys 
rhs 
nil 
rhs 
provide conventional form syntactic sugar section core form reduces number expressions bind new variables 
turn reduces clutter compiler losing expressiveness 
syntactic sugar syntactic sugar greatly reduces size printed form program apart simply give conventional equivalent forms ffl means 
ffl means 
ffl xn means xn ffl 
means 
ffl binding occurrence un annotated variable means 
allows omit annotation type variables 
ffl bound occurrence un annotated variable means annotation binding site 
may necessary perform ff conversion expected meaning 
abbreviation allows omit annotations bound occurrences 
ffl clause case expression omitted readily re inferred 
ffl case alternative yn 
means 
yn variables yn need annotated types types recovered type constructor instantiating types clause 
type rules extend typechecking rules deal extended language 
rules declarations return environment type declaration 
avoid clutter rules letrec case mention single binding alternative respectively 
main interesting point case rules 
form app rule type derived form expression typed 
rely conversion rules don space convert resulting type required form necessary app case 
rule raises interesting question 
clearly need check legal bound variable body delta 
binding recursive say letrec need check legal bound variables believe answer 
see consider expression clearly check clear correct answer plan find 
believe lambda cube provides solid foundation intermediate langauge sophisticated compilers 
subtle system extending real language raises new technical issues just seen 
probably problems old hat theorists direct link studied system valuable 
groundwork left ffl extended pts framework recursive data types letrec case constants necessary prove standard pts theorems go 
noted uncertainty exact typing rule letrec previous section 
ffl section defines predicative variant henk intention tractable model exhibit model 
ffl provide operational semantics henk 
subsequently plan move implementation ghc 
hope giving henk clear definition concrete syntax may able closely compiler writers 
ghc intended substrate research daunting monster requires certain determination delve 
hope henk may provide route ghc back ends analysis tools vice versa 
koen claessen john launchbury randy pollack mark shields comments earlier drafts 
acknowledge gratefully support oregon graduate institute funded contract air force material command 
barendregt lambda calculi types handbook logic computer science volume ii abramsky dm gabbay tse maibaum eds oxford university press 
th coquand huet calculus constructions information computation gill launchbury sl peyton jones june short cut deforestation proc functional programming languages computer architecture copenhagen acm girard interpr etation elimination des coupures dans arithm etique ordre sup erieur phd thesis universit paris vii 
harper morrisett jan compiling polymorphism intensional type analysis nd acm symposium principles programming languages san francisco acm rw harper jc mitchell moggi jan higherorder modules phase distinction th acm symposium principles programming languages san francisco acm hu iwasaki takeichi may deriving structural hylomorphisms recursive definitions proc international conference functional programming philadelphia acm mp jones jan system constructor classes overloading implicit higher order polymorphism journal functional programming gamma delta delta gamma delta jk gamma theta vk theta gamma tn vn prog gamma gamma fx ag gamma gamma letrec fx ag gamma gamma gamma data fx bg data gamma delta gamma delta delta gamma gamma gamma gamma gamma wff case 
case 
case extra rules nederpelt march canonical typing pi conversion barendregt cube journal functional programming launchbury sheard june warm fusion proc functional programming languages computer architecture la jolla acm 
jc mitchell foundations programming languages mit press 
dec compiling types phd thesis cmu cs carnegie mellon university 
sl peyton jones jan compilation transformation report european symposium programming esop linkoping sweden springer verlag lncs sl peyton jones cv hall hammond wd partain pl wadler march glasgow haskell compiler technical overview proceedings joint framework information technology technical conference keele dti serc sl peyton jones launchbury sept unboxed values class citizens functional programming languages computer architecture boston hughes ed lncs springer verlag sl peyton jones wd partain measuring effectiveness simple strictness analyser functional programming glasgow hammond jt donnell eds workshops computing springer verlag pollack van benthem jutting mckinna may typechecking pure type systems types proofs programs nijmegen may selected papers springer verlag lncs 
shao flint compiler system presentation ifip working group 
shao aw appel june type compiler standard ml sigplan symposium programming language design implementation pldi la jolla acm tarditi optimizing ml phd thesis carnegie mellon university 
tarditi morrisett cheng stone harper lee may til type directed optimizing compiler ml sigplan symposium programming language design implementation pldi philadelphia acm 
tolmach june tag free garbage collection explicit type parameters acm symposium lisp functional programming orlando acm 
