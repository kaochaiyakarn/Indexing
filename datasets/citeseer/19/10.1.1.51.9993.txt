programming hybrid constraint languages vineet gupta radha jagadeesan vijay saraswat daniel bobrow 
language hybrid cc modeling hybrid systems compositionally 
language declarative programs understood logical formulas place constraints temporal evolution system 
show expressiveness language presenting examples including model 
describe interpreter language provide traces example programs 
motivation constant marketplace demand greater functionality lower price forcing artifacts industrial society designs complex 
advent silicon complexity unmanageable 
economics power digital computation medium choice gluing controlling complex systems composed electro mechanical computationally realized elements 
result construction software implement monitor control diagnose systems nearly impossible task 
instance traditional product development methods systems photo printers involve hundreds systems engineers mechanical designers electrical hardware software engineers working tens months hard prototyping cycles 
software controlling systems produced hand separate analyses performed software hardware systems engineers substantial time spent group meetings discussions coordinating different design decisions changes assessing impact decisions teams involved 
automated tools available help production documentation principles operation module system operating descriptions analysis design product 
different team starting little product box little documentation produces computational systems help field service representatives diagnose fix products field 
practices unable deal increasing demand faster time market flexibility product lines 
producing product necessary produce family plug play generic components mailboxes scanners fax modules imaging systems high capacity may come time customer site 
xerox palo alto research center coyote hill road palo alto ca saraswat parc xerox com dept mathematical sciences university lake shore campus chicago il radha math luc edu software controlling systems produced way configuration controlled known run time 
address problems investigating application modelbased computing techniques 
central idea develop compositional declarative models various components photo copier product family different levels granularity customized different tasks 
instance marker viewed transducer takes timed streams sheets video images produce timed streams prints model marker viewpoint scheduler set constraints capture precisely triples hs fact physically realizable marker 
marker model constructed models nips rollers motors belts control gates models hooked exactly way corresponding physical components linked 
software architectures developed tasks need accomplished scheduling simulation machine control diagnostic tree generation 
linking special purpose reasoners operating configuration time produce information right kind task architecture component models system configuration 
expect approach useful variety tasks scheduling 
model system specifies outputs produced continuous input control commands 
principle model search space inputs control commands description system output 
practice design inference engine complex inherent combinatorial complexity search process 
formal model hand possible automated techniques better understand search space design special purpose reasoners 
approach currently deployed collaboration teams development schedulers new generation products xerox 
code generation 
physical model system envisionment studying possible paths evolution system 
parameters system controlled possible develop automatically controllers specify parameters leading system desirable state away paths lead unsafe states 
diagnostic tree generation 
model components interconnection correct possibly faulty behavior information prior probabilities failure possible construct line procedures 
service technicians guides making probes determine root cause manifest symptom 
explanation 
simulation model possible annotate behavioral rules text way text systematically composed provide natural language explanations observable parameter particular value 
productivity analysis 
models may analyzed determine corresponding product designs perform different job mixes sequence black white jobs followed double sided color jobs 
model computing approach places set requirements nature modeling language 
motivate demands considering concrete example path simple see 
image transfer mechanism tray acq roll vacuum belt exit roll reg 
motion belt fig 

simple example transportation 
loaded tray left machine 
signal received acquisition roll lowered pulls top sheet set rollers 
grasped set rollers acquisition roll lifted rollers pull forward till reaches registration 
starts precise moment perfect alignment image belt 
transferred image transfer mechanism 
vacuum belt transports roll fuses exits 
hybrid modeling 
collection components continuous behavior example rollers belts 
control program discrete event driven system 
modeling language able describe interaction control program continuous components modeling language fall framework hybrid systems bg mmp 
executability 
model system possible predict behavior system inputs supplied 
model executable possible view models programs 
allow hybrid control programs written notation component models 
sensors actuators coupling language implementation physical environment provided fact possible programs notation drive physical mechanisms 
compositional modeling 
considerations reuse clear models composite systems built models components models components reflect physics reflecting pre compiled knowledge structure configurations function structure principle 
concretely implies modeling language expressive modularly describe support extant control architectures techniques compositional design hybrid systems see example hmp hoo nk 
programming language standpoint modularity concerns addressed analysis underlying synchronous programming languages bb hal bg hcp har clm adapted dense discrete domains bbg analysis leads demands modeling language 
modeling support interconnection different components allow hiding interconnections 
example model copier composition control program model path 
model path turn composition models rollers furthermore example jams control program cause rollers 
model rollers isolation need knowledge potential error conditions 
modeling language support orthogonal preemption ber signal cause preemption :10.1.1.42.1557
language allow expression multiple notions logical time example notion time relevant tray occurrences event removing tray notion time relevant acquisition roll determined rotation rate roller notion time image transfer mechanism duration action transferring images demand modeling language algebra processes includes concurrency hiding preemption time 
declarative view 
possible systems engineers people quite different training background software engineers formalism 
typically systems engineers understand physics system designed analyzed mathematical constraint formalisms equational algebraic models transfer functions differential equations expressing knowledge 
suggests possible view model fragment expressed language declaration facts real time temporal logic see example mp ah 
reasoning 
model path control procedures governing possible perform tolerance analysis establish early late arrival sheets papers various sensors path particular physical component may exhibit behavior specified tolerance 
engineering tasks suggest modeling language amenable adapting methodology developed extensive research reasoning hybrid real time systems example specification verification properties hybrid systems qualitative reasoning physical systems wd envisionment qualitative states 
describes programming modeling language hybrid cc hybrid concurrent constraint programming 
intuitively hybrid cc obtained freely extending untimed non monotonic language default cc continuous time 
hybrid cc key features notion continuous constraint system describes continuous evolution system trajectories 
hybrid constraint languages developed generically continuous constraint systems obtained adding single temporal construct called 
intuitively formula read asserting holds continuously current instant 
continuous variants preemption control constructs timing constructs definable hybrid cc 
formal foundations hybrid cc discussed 
rest organised follows 
describe computational intuitions underlying hybrid cc 
follow brief description interpreter language hybrid cc framework 
describe series examples show traces execution interpreter 
examples illustrate programming idioms expressiveness hybrid cc 
hybrid cc computational intuitions background concurrent constraint programming mentioned previous section crucial characteristics hybrid programming language easy specification composition model fragments 
led consider concurrent constraint programming languages sar srp starting point languages built top constraint systems expressive desired fine grained concurrency compositionality achieved effort 
concrete general purpose programming languages implemented paradigm deb jh 
concurrent constraint programming cc languages declarative concurrent languages construct logical formula 
cc replaces traditional notion store valuation variables notion store constraint possible values variables 
store consists pieces information restrict possible values variables 
cc program consists set agents running concurrently interacting shared store 
agents basic kinds tell agents add information store written ask agents conditionals words agent program interchangeably usually referring fragments program agents 
written query store validity information reduce agents valid yields grammar new monotonic added store 
ask actions synchronization query answered positively agent proceed waits possibly forever till information store entail information query 
computation performed state quiescence reached store output 
information added store consists constraints drawn constraint system 
formally constraint system system partial information consisting set primitive constraints tokens minimal order structure variables existential quantification 
associated constraint system entailment relation denoted specifies token deduced denoted examples systems system herbrand underlying logic programming tokens equalities terms finite trees variables ranging trees fd hsd finite domains tokens equalities variables expressions saying range variable finite set 
salient aspect cc computation model agents may thought imposing constraints evolution system 
agent imposes constraint 
imposes constraints logically conjunction new imposes constraints hides variable agents logically thought form existential quantification 
agent imposes constraints provided rest system imposes constraints logically thought implication 
declarative way looking programs complemented operational view 
basic idea operational view network agents interacting shared store primitive constraints 
agent viewed adding store instantaneously 
behaves simultaneous execution new starts creates new local variable information communicated outside 
agent behaves current store entails main difficulty cc languages modeling cc programs detect presence information absence 
reactive systems important handle information saying certain event occur examples timeouts unix presence jams usually inferred reaching point specified time 
problem assuming absence information called negative information computation may invalidated adds information leading invalidation subsequent computation 
hiding agents new hide information needed modularity 
tokens denoted 
attempt fixing problem addition sequence phases execution cc paradigm 
phase executed cc program gave output phase produced agents executed subsequent phases 
phase detected absence information phase reactive tcc 
phase denoted time tick discrete model time 
default cc 
addition time cc left problem detect negative information instantaneously 
necessary applications acceptable wait phase utilize negative information 
negative information detected time step done level untimed language cc 
cc paradigm inherently opposed instantaneous negative information detection 
order allow negative information detected computation cycle modify cc default cc 
basic idea default cc final output computation known negative information obtained output negative information invalidated final output information added 
default cc program executes cc program execution guesses output store 
negative information requests resolved respect guess default cc program adds information store queries store positive information just cc program 
computation store equal guess guess correct valid answer 
branch execution terminated backtracking 
actual implementation backtracking done compile time runtime simple table lookup 
default cc paradigm augments cc paradigm ability detect negative information new syntax need add cc syntax negative ask combinator reduces guessed output imply default cc syntax grammar new agent imposes constraints rest system imposes constraint logically thought default rei 
timed contexts discussed subtlety non programs intimately related causality issues synchronous programming languages arises combinator 
see note may cause information added store current time instant agents may simultaneously active adding information store 
requiring note quite distinct agent assuming constraint system closed negation 
reduce iff final store entail reduce iff final store entails difference arises nature stores contain partial information may strong entail information absent amounts making demand stability negative information 
language permits instantaneous negative information detection 
enables write strong timeouts signal produced certain time execution program terminated time time timed cc 
order get language modeling discrete reactive systems introduce phases default cc program executes 
extend default cc time need just construct starts copy phase current 
extend default cc real time get language hybrid reactive systems subsection 
continuous evolution time 
follow similar intuition developing hybrid cc continuous timed language obtained uniformly extending default cc real continuous time 
accomplished technical developments 
formal development see 

enrich constraint system possible describe continuous evolution state 
intuitively allow constraints expressing initial value integration problems constraints form dot infer time technical innovation presentation generic notion continuous constraint system ccs builds general notion constraint sytems just extra structure needed enable definition continuous control constructs committing particular choice vocabulary constraints involving continuous time 
result subsequent development parametric underlying constraint language choice ccs get hybrid programming language 
give example simple constraint system language built 
program combinators 
second add untimed default cc temporal control construct interpreting real time 
declaratively imposes constraints real time instant current 
operationally invoked time new copy invoked instant 
agents propositions holds holds holds hold holds new exists instance holds hold holds instant intuitively appear specialized construct requires repetition program subsequent time instant 
combine powerful ways positive negative ask operations yield rich patterns temporal evolution 
key idea negative asks allow instantaneous preemption program program fact execute time instants true 
consider concrete examples 
suppose require agent executed time point current time true 
expressed new 
intuitively time point current condition checked 
holds executed 
local way generated agent fact generates continuously generates 
copy executed time point current upto excluding time detected 
similarly execute precisely time instant assuming holds execute new 
particular continuous version general preemption control construct clock introduced definable hybrid cc 
patterns temporal behavior described obtainable specializations clock 
programs containing clock combinator may equationally rewritten programs containing combinator 
conceptually simple understand requires execution subsequent real time instant 
powerful combinator may impossible implement computationally 
example may possible express programs form new dot rational require execution rational 
programs implementable 
hybrid cc computationally realizable basic intuition exploit general physical systems change slowly points discontinuous change followed periods continuous evolution 
captured stability condition continuous constraint systems guarantees constraint neighborhood entails point 
rules constraints rational inadmissible 
restriction computation hybrid cc may thought progressing alternating phases computation time point open interval 
computation time point establishes constraint effect instant sets program execute subsequently 
computation succeeding open interval determines length interval constraint continuous evolution describes state system 
implementation simple implementation hybrid cc built top simple continuous constraint system 
interpreter built top prolog consideration simplicity efficiency 
identified ways performance significantly enhanced standard logic programming techniques 
continuous constraint system basic tokens formulas prev atomic proposition equation form dot variable non negative integer real number 
tokens consist basic tokens closed conjunction existential quantification 
rudimentary arithmetic done underlying prolog primitives 
inference relations defined obvious way interpretation states true dot states mth derivative prev asserts true limit left states time holds 
inference relations trivially decidable functions time expressible exactly polynomials 
non trivial computation involved finding smallest non negative root univariate polynomials done numerical methods 
basic interpreter interpreter simply implements formal operational semantics discussed detail 
operates alternately point interval phases passing information phase ends 
discrete change takes place point state executes simple default cc program 
continuous phase computation progresses evolution time 
interval state exited soon status conditionals changes fired fire anymore starts firing 
interpreter takes hybrid cc program starts point phase time 
point phase 
input point phase set hybrid cc agents prev store carries information previous interval phase atomic propositions values variables right endpoint interval initially time empty 
outputs store current instant printed passed interval phase initial store agent continuation executed interval phase 
interpreter takes agent processes 
maintains store pair lists list contains atomic propositions known true point second contains list variables information known values derivatives 
maintains lists suspended conditionals statements constraints known true false list agents executed interval phase 
tell action constraint seen added store check consistency 
constraint form dot means derivatives order continuous values copied prev store 
conditional agents suspended reactivated placed pool active agents 
conditional agent appears constraint immediately checked validity 
determined appropriate action taken consequence agent discarded added pool active agents 
added indexed list suspended conditionals processing 
action placed list agents executed interval 
active agents left interpreter looks suspended agents form defaults 
successful termination conditions hold agent final store entails final store incorporates effect executing interpreter nondeterministically choose alternative default 
current implementation non deterministic choice implemented backtracking execution current phase terminating successful branch 
interval phase 
quite similar point phase return duration phase 
input set agents initial store determines initial values differential equations true store 
output set agents executed point phase store giving values variables interval phase length phase 
initially assume length infinite trimmed execution phase 
tell processed added similar store suspended conditionals 
conditional agents added suspended list conditions known valid invalid consequence agent added active pool discarded 
addition condition decided compute duration status hold 
example dot store initial store know 
ask immediately know true current interval discarded 
know solving equation status hold seconds interval phase longer seconds 
need solve polynomial equations 
processing defaults processed trim length interval phase 
remaining suspended conditionals checked valid reduce duration phase necessary 
computation done find store interval information passed point phase 
agents form interval phase agent executed point phase interval phase agents execute program terminates 
combinators basic syntax hybrid cc quite write programs 
noticed recurrent patterns programs written definable combinators job programming considerably easier 
note defined combinators definable terms basic combinators 
defined combinators merely syntactic sugar compiled away basic combinators 
formal principles underlying compilation process discussed companion 

read logically necessity modality 
parameterless recursion mimicked replace recursive process body body 
parameters handled textual substitution 
waiting condition 
reduces time instant true defined notion occurrence note occurrence situation occurs interval happens agent cases invoked 
defined terms basic combinators mentioned previous section 
discussion definable combinators rest shall repeat caveat subtlety definedness occurrences events 
watchdogs 
watching read logically strong abortion interrupt esterel ber :10.1.1.42.1557
familiar construct vein 
watching behaves time instant entailed entailed killed instantaneously 
defined basic constructs follows 
watching watching watching watching watching watching watching watching new watching new watching free watching new watching time 
time denotes process notion time occurrence evolves store entails defined structural induction 
implementation defined constructs 
laws suffice implement constructs interpreter 
sake efficiency implemented constructs directly level basic constructs 
construct course trivial implemented rule 
implemented similarly construct entailed carried phase 
effect interval phase reason mentioned 
watching similar implemented analogously 
thing noted passed phase passed inside watching proper termination spawned agents achieved true 
time similar remembering rule passing spawned agents phases 
programming examples illustrate programming model description style hybrid cc examples 
examples write conceptually distinct components separately 
exploit expressive power hybrid cc combine subprograms submodels appropriate combinators get complete program model 
trace interpreter examples 
sawtooth function start simple example sawtooth function defined gamma denotes greatest integer mentioned prev read asserting left limit equals 
sawtooth prev prev dot trace program executed interpreter seen 
execution point interval phases displayed separately 
phases execution contents store displayed 
addition interval phase interval displayed continuous variables displayed polynomials time 
interval note time measured interval 
program infinite output aborted time 
time 
store contains dot 
time interval store contains 
time 
store contains dot 
time interval store contains 
time 
store contains dot 
time interval store contains 
time 
store contains dot 
prolog interruption help 
execution aborted temperature controller 
model simple room heating system consists furnace supplies heat controller turns 
temperature furnace denoted temp 
furnace modeled signal furnace modeled signal furnace 
actual switching modeled signals switch switch 
furnace temperature rises rate 
furnace temperature falls rate 
controller detects temperature furnace switches furnace temperature reaches certain pre specified thresholds cut maximum temperature cut minimum temperature 
heating furnace modeled 
time construct ensures heating occurs signal furnace 
furnace heat time dot temp furnace cooling furnace modeled 
time construct ensures heating occurs signal furnace 
furnace cool time dot temp gamma furnace furnace parallel composition heating cooling programs 
furnace furnace heat furnace cool controller modeled program instant program watches thresholds exceeded turns appropriate switch 
controller cut cut switch furnace watching switch switch furnace watching switch prev temp cut switch prev temp cut switch entire assembly defined parallel composition furnace controller 
controlled furnace cut cut furnace controller cut cut trace program parameters cut cut initial conditions temp signal switch executed interpreter seen 
time 
store contains furnace switch dot temp dot temp 
time interval store contains furnace temp 
time 
store contains furnace switch dot temp dot temp 
time interval store contains furnace temp 
time 
store contains furnace switch dot temp dot temp 
time interval store contains furnace temp 
prolog interruption help 
execution aborted cat mouse 
consider example cat chasing mouse 
mouse starts origin running speed metres second hole metres away 
traveled metres cat released runs speed metres second mouse 
positions cat mouse modeled respectively 
cat wins modeled signal catches mouse hole loses modeled signal 
cat mouse modeled quite simply 
positions cat mouse change respective velocities 
note cat position hole mouse program similarly cat program 
essential reuse models 
mouse dot cat dot entire system assembly components 
mouse wins reaches hole cat wins mouse reached hole 
combination watching prev exception handler handles case mouse reaching hole 
similarly combination watching prev prev exception handler handles case cat reaching hole 
higher priority watching prev relative 
watching prev captured lexical nesting program cat catches mouse reach hole simultaneously 
system configuration mouse prev cat watching prev prev watching prev prev trace program executed interpreter time 
store contains dot dot 
time interval store contains 
time 
store contains dot dot dot dot 
time interval store contains 
time 
store contains 
termination time 
initial conditions 
store 
alternative mouse wins cat mouse reach hole 
captured reversing lexical nesting 
watching prev 
watching prev 
concretely program system configuration mouse prev cat watching prev prev watching prev prev trace program executed interpreter time 
store contains dot dot 
time interval store contains 
time 
store contains dot dot dot dot 
time interval store contains 
time 
store contains 
termination time 
initial conditions 
store 
simple game model pool table balls 
balls roll straight line till collision ball edge occurs 
collision occurs velocity balls involved changes discretely 
ball falls pocket disappears game 
simplicity assume balls equal mass radius called 
model ball collisions assume friction 
impulses denoted assumed vectors 
velocities positions assumed pairs component component 
structure program ball kind collision check ball modeled programs 
ball basically record fields name position velocity 
agent ball maintains ball ball initial position velocity 
game evolves position changes velocity dot ball pos ball velocity changes effect collisions 
propositional constraint change ball shared collision ball agents communicates occurrences changes velocity ball named ball 
ball process terminated ball removed 
falls pocket higher priority watching ball relative 
watching change ball captured lexical nesting 
ball ball ball pos ball vel watching change ball change ball ball ball ball pos ball dot ball pos ball vel watching ball table assumed start length xmax breadth ymax 
ball hits edge velocity component reversed sign component unchanged 
edge collision pos pos xmax gamma change gamma vel vel pos pos ymax gamma change vel gamma vel program syntax allows declaration procedures 
syntax xn read asserting xn xn equivalent ball ball collisions involve solutions quadratic conservation energy equation 
jij jij chooses correct solution 
solution balls go 
distance short hand computation distance 
ball collision pos pos vel vel distance gamma gamma gamma change change ball center distance pocket 
pocket ball pocket xmax ymax ball pos ball pocket xmax ymax distance distance ymax distance xmax distance xmax ymax distance xmax distance xmax ymax copier path larger example utilizes programming ideas illustrated previous toy examples 
model copier path mentioned section 
discussed model components path hybrid cc put produce model entire path 
model underlying intuitions discussed detail gss overview 
constraint system model richer constraint system described simple propositions order formulas assert arithmetic inequalities variables derivatives real constants 
allow expression attribute value lists list refer value list exists 
adds attributes value 
intuitions 
basic idea construct models individual components rollers belts build model sheets going 
addition need model local interaction sheet transportation element belt roller 
interaction results transportation elements applying forces sheet sheet transmits forces moves influence 
local interactions naturally induce partition sheet segments view individual entities analyzing diagrams 
number modeling assumptions simplify model 
example model acceleration sheet view velocity changing discretely change takes place influences 
assume sheet homogeneous straight things discussed detail gss 
model 
modeled segment real line component occupies segment real line 
forces velocities oriented respect 
model fragment describes basic transportation element specialized models different types belts rollers 
properties initial state element specified attribute value list init 
element nominal velocity nom velocity supplied motor 
actual velocity act may differ nominal velocity sheet may pulling pushing element 
force exerted transportation element denoted act force exerted motor denoted resist equation relates 
resist bounded fast slow remaining constraints show relation forces velocities assert element going faster nominal velocity nom force act maximum value similarly minimum value 
init transport loc init loc init fast init fast slow init slow normal init normal act resist gamma fast resist slow act nom act fast act nom act gamma slow model simply enumeration constraints transportation element true 
value nom set done specialization generic transportation element description various particular kinds elements 
component sheet travels 
number properties initial location 
furthermore sheet partitioned various segments portions sheet contact transportation element 
contact segments extreme contact segments 
order create segments new operator forall 
simply parallel composition finitely true 
declarative style programming particularly useful way asserting existence segments simpler dynamic creation destruction segments done imperative program 
sheet init loc init loc sheet width init width length init length thickness init thickness elasticity init elasticity init strength init strength condition tearing torn forall transport engaged loc loc contact loc loc forall contact forall contact forall contact contact ub lb forall contact contact lb loc lb forall contact contact ub ub loc dot lb loc vel lb loc dot ub loc vel ub loc watching torn brevity omit code segments sheet 
agent interact creates interaction process transportation element overlapping sheet 
sheet transportation process models interaction sheet transportation element 
asserts force exerted element sheet equal opposite force exerted sheet element 
gives equation contact segment bounds amount force exerted transportation element amount friction 
friction velocities related 
interact forall transport engaged loc loc loc loc new friction loc loc friction mu theta normal te act lb left ub right te te friction vel ub act te gamma friction vel ub act te friction provide model shown 
various kinds transportation elements modeled followed typical sheet composed give entire 
new combinator wait waits seconds starting expressed terms basic combinators 
new sheet placed time signal sync received scheduler 
init init nom init nom engaged roller init init rubber fast slow normal act slow act gamma fast broken init init rubber fast slow normal act slow broken belt init init steel fast slow normal init init rubber fast slow normal init init engaged nom init nom watching nom watching sheet length width thickness elasticity glossy strength loc sync new roller nom loc roller nom loc nom loc rubber fast slow normal nom loc belt nom loc nom loc rubber glossy steel glossy sync new interact wait model executed simulate 
put various uses mentioned exploiting fact hybrid tcc defined mathematical semantics 
simple model verify properties true 
example want assert sheets tear forall sheet 
torn error 
similarly properties asserted proved various theorem proving model checking techniques 
want prove successive sheets overlap proof give condition far apart sync signals 
similar techniques may control code generation 
applications mentioned formal models semantics 
qualitative simulation 
interpretation hybrid tcc programs provide alternate conceptual framework qualitative modeling approaches 
hybrid tcc model exactly systems continuous discrete change 
example model tap drain 
inflow capacity new netflow outflow amount constant monotone constant inflow constant capacity netflow outflow inflow outflow amount dot amount netflow watching amount capacity dot amount lines assert parameters vary time monotone function argument assuming value input 
essentially information qsim produces graph shows initial state possible qualitative states program transit possible input values inflow capacity overflows level capacity capacity 
reasoning qsim employs knowledge behavior continuously varying functions 
hybrid tcc provides exact description model possible interpretation program get qualitative reasoning qsim 
useful cases precise value inputs known range 
interpretation useful verification 
example cat mouse example may know exact velocities cat mouse range velocities 
may possible prove mouse wins 
ability run program abstractly possible values velocities provides alternative way verification property 
presents simple programming language hybrid computing extending untimed computation model default cc uniformly reals 
conceptually computation performed real time point language compiled finite automata style 
interpreter language directly extending interpreter default cc integrator computing evolution set variables subject constraints involving differentiation 
demonstrate expressiveness language programming examples show preemption control constructs integer time synchronous programming languages watching extend smoothly hybrid setting 
remains done 
semantic foundations higher order hybrid programming programs representable data objects 
hybrid modeling methodology combined program structuring ideas object oriented programming 
appropriate notion types setting 
frameworks static analysis programs data control flow analysis interpretation techniques generalize setting 
appropriate techniques partial evaluation program transformation programs 
language issues number modeling implementation issues appropriate continuous constraint systems fast algorithms deciding entailment relation 
boundary value problems solved framework 
stepsize numerical integration techniques affect execution visualization results 
subject papers 

supported part onr vijay saraswat radha jagadeesan nasa 
radha jagadeesan supported nsf 
ah alur henzinger 
logics models real time survey 
de bakker huizing de roever andg 
rozenberg editors rex workshop real time theory practice volume lncs 
bb benveniste berry 
synchronous approach reactive real time systems 
special issue look real time systems proceedings ieee september 
bbg benveniste le paul le guernic 
hybrid systems signal approach 
number lncs 
springer verlag 
ber berry :10.1.1.42.1557
preemption concurrent systems 
proc 

springer verlag 
lncs 
bg benveniste le guernic 
hybrid dynamical systems signal language 
ieee transactions automatic control 
bg berry gonthier 
esterel programming language design semantics implementation 
science computer programming november 
clm clarke long mcmillan 
compositional specification verification finite state hardware controllers 
proceedings ieee september 
de bakker huizing de roever rozenberg editors 
rex workshop real time theory practice volume lncs 
deb saumya debray 
qd janus sequential implementation janus prolog 
software practice experience december 
johan de kleer john seely brown 
qualitative reasoning physical systems chapter qualitative physics 
mit press 
published aij 
fromherz bell bobrow copier modeling project 
working papers eighth international workshop qualitative reasoning physical systems pages june 
le guernic le gauthier le 
programming real time applications signal 
special issue look real time systems proceedings ieee september 
vineet gupta radha jagadeesan vijay saraswat daniel bobrow 
computing continuous change 
technical report xerox palo alto research center may 
submitted 
robert grossman anil nerode anders ravn hans rischel editors 
hybrid systems 
springer verlag 
lncs 
gss vineet gupta vijay saraswat peter struss 
model path 
proceedings nd ijcai workshop engineering problems qualitative reasoning august 
hal halbwachs 
synchronous programming reactive systems 
kluwer international series engineering computer science 
kluwer academic publishers 
har harel 
statecharts visual approach complex systems 
science computer programming 
hcp halbwachs caspi pilaud 
synchronous programming language lustre 
special issue look real time systems proceedings ieee special issue look real time systems september 
hmp henzinger manna pnueli 
refining temporal specifications hybrid systems 
grossman nerode ravn rischel editors hybrid systems volume lncs pages 
hoo 
compositional approach design hybrid systems 
grossman nerode ravn rischel editors hybrid systems volume lncs pages 
hsd pascal van hentenryck vijay saraswat yves deville 
constraint processing cc fd 
technical report computer science department brown university 
jh janson seif haridi 
programming paradigms andorra kernel language 
logic programming proceedings international symposium 
mit press 
ben kuipers editor 
qualitative simulation 
mit press 
mmp maler manna pnueli 
timed hybrid systems 
de bakker huizing de roever andg 
rozenberg editors rex workshop real time theory practice volume lecture notes computer science pages 
mp manna pnueli 
temporal logic reactive 
springer verlag 
pp 
nk nerode kohn 
multiple agent hybrid control architecture 
number lncs 
springer verlag 
nicollin olivero sifakis yovine 
approach description analysis hybrid systems 
number lncs 
springer verlag 
nicollin sifakis yovine 
atp timed graphs hybrid systems 
de bakker huizing de roever rozenberg editors rex workshop real time theory practice volume lncs 
rei ray reiter 
logic default reasoning 
artificial intelligence 
sar vijay saraswat 
concurrent constraint programming 
logic programming doctoral dissertation award series 
mit press march 
gert smolka 
constraint programming newport papers chapter object oriented programming oz 
mit press 
saraswat jagadeesan gupta 
constraint programming chapter programming timed concurrent constraint languages 
nato advanced science institute series series computer system sciences 
springer verlag 
saraswat jagadeesan gupta 
foundations timed concurrent constraint programming 
samson abramsky editor proceedings ninth logic computer science ieee computer press july 
saraswat jagadeesan gupta 
default timed concurrent constraint programming 
proceedings second acm symposium principles programming languages san francisco january 
srp saraswat rinard panangaden 
semantic foundations concurrent constraint programming 
proceedings eighteenth acm symposium principles programming languages orlando january 
wd weld de kleer 
readings qualitative reasoning physical systems 
morgan kaufmann 
article processed macro package llncs style 
