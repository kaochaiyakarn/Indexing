membership constant time minimum space andrej ian munro department computer science university waterloo waterloo ontario canada uwaterloo ca 
investigate problem storing subset elements searches canbe performed constant time space constant factor minimum required 
initially focus static version problem conclude enhancement permits insertions deletions 
universal set gamma subset fe membership problem determine query element element standard approaches solve problem list elements hash table list answers bit map size 
small approach comes close information theoretic lower bound number bits needed represent arbitrary subset size function lg gamma delta 
similarly large say ffm approach near optimal space utilization 
focuses middle ground natural approaches require space nonlinear lower bound 
introduce feature space constant factor lower bound query time constant constants modest 
basic approach perfect hashing bit map achieve optimum space bound partition universe subranges equal size 
discover care couple iterations splitting subranges small succinct indices single table possible configurations small ranges table small ranges permit encoding minimal space bound 
technique example call word size truncated recursion cf 

recursion needs continue level small subproblems point indexing table solutions suffices 
happens large extent level single word machine model big encode complete solution small problems 
research supported part natural science engineering research council canada number information technology research centre ontario 
organized follows section notation definitions short overview relevant literature 
sect 
complete static solution followed solution dynamic problem sect 

sect 
pair examples usage static structure final remarks 
notation definitions background noted universal set assumed gamma size hand arbitrary subset cardinality solving membership problem trivially gives solution assume membership problem answer query element problem obvious dynamic extension includes operations insert delete 
standard cell probe model cf 
word size dlg bits 
words register represent single element entire domain specify elements set size lg elements refer portion data structure role dlg bit blend 
convenience measure space usage bits words 
furthermore assume machine perform usual operations words unit time 
information theoretic lower bound number bits needed represent arbitrary set size universe size lg stirling approximation defining formula replaced approximation lg lg error estimate lg 
short literature searching problem central problems computer science extensive literature 
section point particular essential 
aspects addressed static case dynamic case information theoretic tradeoffs 
cases assumed space list keys bit map 
dealing situation afford space 
start static case particular implicit data structures yao sense 
notion implicit structure room store data notation lg describe binary logarithm log items constrained logical table 
words term implicit structure meant structure uses registers lg bits additional storage 
data structures yao showed bounded universe exists subset implicit data structure requires logarithmic search time 
fiat naor put better bound size subset proved awkward case larger quantity lies lg lg ffl ffl 
particular proved exists implicit scheme omega log ffl 
adding storage changes situation 
example yao showed exists constant time solution lg tarjan yao constant time solution lg bits space ffl ffl 
fredman closed gap developing constant time algorithm uses data structure size lg bits log log additional bits storage fiat naor schmidt siegel decreased number additional bits dlg ne log 
combining result fiat naor construction implicit search scheme omega log get scheme uses log additional bits memory 
moving dynamic case dietzfelbinger 
proved omega log worst case lower bound class realistic hashing schemes 
scheme results standard achieved constant amortized expected time operation high probability 
worst case time operation non amortized omega 
dietzfelbinger meyer auf der heide upgraded scheme achieved constant worst case time operation high probability 
similar result obtained dietzfelbinger gil matias pippenger 
turn information theoretic 
elias addressed general version static membership problem involved different types queries 
queries discussed tradeoff size data structure average number bit probes required answer queries 
particular set membership problem described data structure size lg bits required average ffl lg bit probes answer query 
worst case necessary probe bits 
elias flower generalized notion query database 
defined set data set queries general setting studied relation size data structure number bits probed set possible queries 
arrangement rigorously studied 
log denotes iterated logarithm logarithm function applied times solution static case mentioned earlier half elements solve complementary problem 
solutions implicit subrange bucket half elements single bit flag indicate solving complementary problem 
static solution parts 
part describe solution log log second part deal case log log cases predefined constant greater 
refer case sparse second dense 
cases extreme situation 
gammaffl ffl 
case need omega log bits list keys 
space perfect hashing function flavours cf 
retain constant response time worst case 
extreme large ffm ff number bits necessary case omega bit map size represent subset 
indexing solution log section focus case log 
top range log case simple approaches require space theta log 
furthermore solution suggests iteration general approach log case 
lemma 
log log algorithm answers membership query constant time bits space data structure 
proof 
idea split universe buckets determined large possible 
data falling organized perfect hashing 
buckets contiguous ranges equal sizes key falls bucket reach individual buckets index array pointers 
consider detail assume split universe buckets 
build index pointers individual buckets pointer occupies dlg bits 
total size index delta dlg bits 
store elements fall bucket perfect hash table bucket 
ranges buckets equal space required hash tables fi lg bits element describe elements buckets require delta fi bits 
allocate bits index buckets achieve desired space bound 
structure supports constant time queries 
remains show bits store elements buckets perfect hash tables 
limit size index get dlg theta log log buckets range theta log log 
range bucket defines number bits element hash table fi theta log log gamma log turn gives total size hash tables theta log log gamma log 
order matches information theoretic lower bound log ut cases covered far summarized table 
column table holds ranges increasing function second column contains approximations top range column obtained third column defines data structure range defined column 
table find solutions small large solution log ffm log ff assume lie awkward range subset hand dense 
table 
ranges structures represent subset range structure single bit theta log unordered list gammaffl theta log hash table gammaffl log theta log indexing log ffm theta log ffm theta bit map complete solution return table particular subsets sizes lie range 
dense apply technique lemma split universe equal range buckets bits pointers 
time ranges buckets remain big hash tables apply splitting scheme 
particular treat bucket new separate smaller universe number elements falling bucket falls range defined respect size smaller universe recursively split 
straightforward strategy leads worst case log level structure log search time log delta space requirement 
observe level number buckets range increases furthermore number large different 
build table possible subsets universes size certain threshold 
build table small ranges replace buckets main structure pointers indices table see example 
refer technique word size truncated recursion 
structure truncation occurs splittings 
rest section give detailed description structure analysis 
returning problem hand split partition universe log buckets range log gives kinds buckets second level sparse dense dense ones 
sparse buckets apply solution 
dense ones fraction ff elements bit map 
remaining dense buckets number elements range defined re apply splitting 
time number buckets log smaller buckets range log point build table small ranges consists bit map representations possible subsets chosen universe size oe replace buckets main structure indices varying sizes table 
order table number elements subset lexicographically 
store representation pointer table small ranges record consisting fields number elements bucket takes dlg oee bits lexicographic order bucket question buckets containing elements sigma lg gamma oe delta upsilon bits compute actual position corresponding bit map bucket gamma oe gamma sum table lookup search performed constant time 
concludes description data structure 
obviously structure allows constant time membership queries remains seen space occupies 
analysis interested dense subsets range defined structure 

analyze main structure order bind results need lemma lemma 
suppose subset elements universe defined 
universe partitioned buckets sizes containing elements lg gamma delta gamma proof sketch 
observe lg gamma delta gamma delta gamma delta ut main structure analyzed top bottom 
level index consists pointers size fi lg bits 
size complete index delta fi log delta lg log log range defined 
second level kinds buckets sparse dense dense 
sparse buckets solution 
dense bit map 
structures guarantee space requirements constant factor information theoretic bound number bits 
holds dense buckets lemma complete main structure uses bits 
note apply lemma freely number buckets 
remains see large second level dense buckets 
purpose consider size bottom level pointers indices table small ranges 
mentioned pointers records consisting fields field occupies dlg oee bits second field information theoretic bound number bits required defined 
dlg oee complete pointer takes twice information theoretic bound number bits hand size index bounded expression similar 
subsequently lemma limits size dense second level buckets constant factor information theoretic necessary number bits 
turn limits size complete main structure bits 
remains compute size table small ranges 
oe entries table entries oe bits wide oe log gives total size table oe oe delta oe limits size structure bits proves theorem theorem 
algorithm solves static membership problem time data structure size bits 
note constants order notation relatively small time level recursion final probe table small ranges certainly space 
fine tuning structure adjust constants ffl ff mentioned table 
note size pointer dependson number elements fall bucket elements bucket bigger pointer dynamic version solution previous section deals fixed set 
natural ask incorporate updates maintaining time space bound 
dynamic solution retains space bound bits time operation expected bound high probability 
solution uses standard technique doubling 
core method maintain time appropriate data structure situation changes switch better structure 
new structure built certain threshold reached smoothly sufficient number preceding operations 
additional due build adds constant amount operation retains time bound 
remains shown apply doubling technique static structure 
structure employs number different substructures supports smooth version doubling technique including hashing cf 
dynamic perfect hashing construction table small ranges appropriate extend table doubling range 
slight memory management problem indexing 
size bucket remains size sub buckets grows level doubled find space sub bucket inside big bucket 
obvious solution allocate space big bucket created copy sub bucket sufficiently big empty slot 
copying done smooth version doubling technique affect time space bounds 
construct case technique requires initial allocation bits space big bucket 
avoid situation background daemon sub bucket 
roughly time proportional size big bucket goes sub buckets empty slots compresses sub buckets 
hard see daemon require constant additional time operation leaves total time operation worst case high probability total space bits 
natural examples situations dealing subset chosen bounded universe size subset relatively big big bit map representation 
mention examples 
set primes smaller number known approximately ln primes 
pretend set primes random store primes kind structure order allow quick answering query number prime 
clearly kind compression bit map representation leave numbers sieve carefully purpose example 
happens example elements sub bucket shuffled 
second example consider canada social insurance numbers allocated individual person 
canada approximately people person digit social insurance number 
may want determine number allocated 
query fact membership query universe size subset size delta examples approximately log method 
directly 
furthermore special features data space calculations slightly pessimistic 
typically case applying complex data structures real world data tuning helpful 
original version allocated bits memory index examples allocated ib bits constant perfect function buckets described 
argument similar lemma observe worst case distribution occurs buckets equally full assume bucket elements 
total ib bits memory index buckets lg bits list elements lg bits describe number elements lg bits describe range buckets 
table gives sizes data structures examples standard approaches hash function bit map size structure 
table includes size universe size subset dealing information theoretic lower bound number necessary bits computed 
table 
space usage subsets primes sins different data structures 
example hash bitmap primes sins discussion solution static membership problem 
solution answers queries constant time uses space small constant factor minimum required information theoretic lower bound 
data structure consists major sub structures different ranges depending ratio size subset universe size subset gammaffl fixed ffl perfect hash tables size subset ffm fixed ff bit map size subset range values recursive splitting 
depth recursion bounded word size truncation case 
addressed dynamic problem proposed solution standard doubling technique 
acknowledgments martin dietzfelbinger helpful comments including pointing relevance non oblivious hashing 
anonymous referee suggestion direct proof lemma 

dietzfelbinger gil matias pippenger 
polynomial hash functions reliable 
proceedings th international colloquium automata languages programming volume lecture notes computer science pages 
springer verlag 

dietzfelbinger karlin mehlhorn meyer auf der heide rohnert tarjan 
dynamic perfect hashing upper lower bounds 
th ieee symposium foundations computer science pages 

dietzfelbinger meyer auf der heide 
new universal class hash functions dynamic hashing real time 
proceedings th international colloquium automata languages programming volume lecture notes computer science pages 
springer verlag 

elias 
efficient storage retrieval content address static files 
journal acm april 

elias flower 
complexity simple retrieval problems 
journal acm july 

van emde boas 
machine models simulations 
van leeuwen editor handbook theoretical computer science volume algorithms complexity chapter pages 
elsevier amsterdam holland 

fiat naor 
implicit probe search 
siam journal computing 

fiat naor schmidt siegel 
hashing 
journal acm october 

fredman 
storing sparse table worst case access time 
journal acm july 

fredman saks 
cell probe complexity dynamic data structures 
st acm symposium theory computing pages seattle washington 

gabow tarjan 
linear time algorithm special case disjoint set union 
journal computer system sciences 

hagerup mehlhorn munro 
optimal algorithms generating discrete random variables changing distributions 
proceedings th international colloquium automata programming volume lecture notes computer science pages 
springer verlag 


bit probe complexity measure revisited 
proceedings th symposium theoretical aspects computer science volume lecture notes computer science pages 
springer verlag 

tarjan yao 
storing sparse table 
communications acm november 


yao 
tables sorted 
journal acm july 
article processed macro package llncs style 
