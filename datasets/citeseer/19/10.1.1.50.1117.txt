automata theoretic verification real time systems rajeev alur computing science research bell labs murray hill nj 
email alur research att com david dill computer science department stanford university stanford ca email dill cs stanford edu november formal methods specifying analyzing manipulating behavior concurrent systems attractive practical automated 
number methods finite state representations achieved considerable success practical applications protocol hardware verification precisely problems decidable finite state representations 
finite state verification methods include checking equivalences bisimulation preorders simulation temporal logic properties 
ctl model checking inclusion language automaton 
temporal logics finite automata primarily concerned qualitative temporal reasoning systems 
example system deadlocks livelocks property true response eventually occurs 
ways extending finite state techniques timed systems discovered retain desirable properties conventional finite representations 
chapter concentrate linear time models finite state real time techniques applied branching time problems timed ctl model checking bisimulation checking 
linear time model assumed execution completely modeled sequence states system events called trace 
behavior system set traces 
set sequences formal language leads naturally automata specification verification systems 
systems finite state finite automata leading effective constructions decision procedures automatically manipulating analyzing system behavior 
qualitative models useful describe non terminating executions liveness properties request occurs infinitely response expressed 
consequently verification theories theory regular languages reasons sets infinite strings finite strings usually considered ordinary regular languages system cospan kur system abb 
linear real time model execution infinite trace events time added pairing event trace time value 
time values chosen set reals 
model called dense time model 
alternative discrete time model uses integer time values requires continuous time approximated choosing fixed quantum priori limits accuracy physical systems modeled 
dealing dense time finite automata framework difficult dealing discrete time transformation set dense time traces ordinary formal language obvious 
developed theory timed formal languages timed automata support automated reasoning systems 
study timed finite automata yielded interesting theoretical results progress continues current rate succeed practice just qualitative finite state methods 
overview overview automata verification untimed systems section 
define timed automata augmenting automata set real valued variables called clocks clocks reset independently transitions automaton keep track time elapsed reset 
transitions automaton put certain constraints clock values transition may taken current values clocks satisfy associated constraints 
mechanism model timing properties channel delivers message time units receipt 
timed automata accept timed words infinite sequences real valued time occurrence associated symbol 
timed automata capture interesting aspects real time systems qualitative features liveness fairness nondeterminism quantitative features periodicity bounded response timing delays 
overview formal language theory timed automata 
due realvalued clock variables state space timed automaton infinite 
algorithm discussed detail section constructs finite quotient space key algorithmic solutions decision problems timed automata 
section outlines application timed automata verification timed systems 
timed system modeled collection timed automata representing various components system 
specification checked deterministic timed automaton representing correct behaviors 
system satisfies property language product automata modeling components contained language specification automaton 
algorithmic solution verification problem 
alleviate high computational complexity verification algorithm different verification tools different heuristics 
discuss implemented solutions 
automata theoretic verification untimed systems section briefly review relevant aspects theory regular languages application modeling automatic verification untimed systems 
refer reader tho summary theory regular languages kur application verification 
buchi automata familiar definition formal language set finite words finite alphabet 
opposed language consists infinite words 
language buchi automaton accepting words infinitely finite alphabet sigma subset sigma set infinite words sigma 
automata provide finite representation certain types languages 
automaton essentially nondeterministic finite state automaton acceptance condition modified suitably handle infinite input words 
transition table tuple sigma ei sigma input alphabet finite set automaton states set start states theta theta sigma set edges 
automaton starts initial state hs ai automaton change state reading input symbol formally infinite word oe oe oe alphabet sigma say oe gamma 
oe gamma 
oe gamma 
delta delta delta run transition table oe provided hs gamma oe 
run set inf consists states infinitely 
different types automata defined adding acceptance condition definition transition tables 
buchi acceptance condition alternatives streett acceptance muller acceptance lead expressively equivalent definitions see tho 
buchi automaton transition table sigma ei additional set accepting states 
run word oe sigma accepting run iff inf 
words run accepting iff state set repeats infinitely language accepted buchi automaton consists words oe sigma accepting run oe 
example consider state automaton alphabet fa bg 
states start states accepting state 
automaton accepts words infinite number 
automaton expresses constraint followed language called regular iff accepted buchi automaton 
class regular languages closed boolean operations 
language intersection implemented product construction buchi automata 
known constructions complementing buchi automata 
buchi automata modeling finite state concurrent processes verification problem reduces language inclusion 
inclusion problem regular languages decidable 
test language automaton contained check emptiness intersection automaton complement second 
testing emptiness easy need search cycle reachable start state includes accepting state 
general complementing buchi automaton involves exponential blow number states language inclusion problem known pspace complete 
checking language automaton contained language deterministic automaton done polynomial time 
transition table sigma ei deterministic iff single start state number labeled edges starting states symbols sigma 
deterministic transition table current state input symbol determine state uniquely 
consequently deterministic automaton run word allows efficient way complement 
trace semantics trace semantics associate set observable events process model process set traces trace linear sequence events may observed process runs 
example event may denote assignment value variable pressing button control panel arrival message 
model trace sequence sets events 
events happen simultaneously corresponding trace set fa bg model 
formally set events trace oe oe oe infinite word set nonempty subsets untimed process pair comprising set observable events set possible traces 
example consider channel connecting components 
represent arrival message stand delivery message channel 
channel receive new message previous reached 
consequently events alternate 
assuming messages keep arriving possible trace oe fag fbg fag fbg denote singleton set fag symbol infinite repetition ab process represented fa bg ab 
various operations defined processes useful describing complex systems simpler ones 
consider important operations parallel composition 
parallel composition set processes describes joint behavior processes running concurrently 
parallel composition operator conveniently defined projection operation 
projection oe written formed intersecting event set oe deleting empty sets sequence 
instance example oe trace notice projection operation may result finite sequence purpose suffices consider projection trace oe oe nonempty infinitely set processes fp ng foe ng oe trace iff trace common events definition corresponds unconstrained interleavings traces 
hand event sets identical trace set composition process simply set theoretic intersection component trace sets 
example consider channel connected channel example 
event message arrival event denote delivery message process fb cg bc 
composed require synchronize common event pair allow possibility event happening event event happening occurring simultaneously 
event set fa cg infinite number traces 
framework verification question language inclusion problem language implementation automaton subset language specification automaton 
intuitively specification automaton gives set allowed behaviors implementation included specification actual behavior implementation allowed 
implementation specification untimed processes 
implementation process typically composition smaller component processes 
say implementation correct respect specification iff example consider channels example 
implementation process 
specification process fa cg abc 
specification requires message reach message arrives case meet specification traces specifically trace ab acb automata verification observe untimed process language alphabet 
regular language represented buchi automaton 
model finite state untimed process event set buchi automaton alphabet 
states automaton correspond internal states process 
automaton transition hs ai process change state participating events acceptance conditions automaton correspond fairness constraints process 
automaton accepts generates precisely traces process 
process called regular process user describes system consisting various components specifying individual component buchi automaton 
particular consider system comprising components component modeled regular process 
implementation process 
automatically construct automaton implementation construction language intersection buchi automata 
specification buchi automaton alphabet 
implementation meets specification iff 
case verification problem reduces checking emptiness verification problem provably computationally expensive pspace complete 
size exponential description individual components 
nondeterministic complement involves exponential blow practice deterministic automata specifications user provides complement specification automaton accepts bad traces 
variety heuristics implement verification strategy outlined 
note testing language inclusion corresponds finding cycles product automata complement need explicitly construct product automaton search done fly 
search may done enumerating states depth fashion manipulating sets states breadth fashion 
technique called symbolic model checking turns effective systems large number states see mcm overview symbolic model checking binary decision diagrams 
complex problems verification algorithm conjunction compositional hierarchical proof methods allow systematic decomposition verification problem see dil kur lt methodologies article lynch volume 
train gate controller consider example automatic controller opens closes gate railroad crossing 
system composed components train gate controller shown 
modeled buchi automata 
example simplified suffices illustrate basic concepts automata theoretic automated verification 
note model sequencing events component timing added model 
event set train automaton exit id event id represents idling event train required enter gate 
train communicates controller events approach exit events mark events entry exit train railroad crossing 
event set gate automaton lower id gate open state closed state communicates controller signals lower raise 
events denote opening closing gate 
gate take idling transition id states forever 
event set controller exit raise lower id controller idle state receives signal approach train responds sending signal lower gate 
receives signal exit responds signal raise gate 
entire system train gate controller 
event set union event sets components 
example automata particularly simple deterministic fairness constraints run accepting run 
automaton specifying entire system obtained composing automata 
safety correctness requirement system train inside gate gate closed 
safety property specified automaton 
edge label stands event set containing edge label means event set containing containing 
automaton disallows states accepting states 
verify safety requirement need check language contained language safety automaton 
done automated tool cospan 
desired inclusion hold verification tool reports trace violates safety property trace consists events approach followed 
need introduce sufficient delay events approach safety property approach approach train gate id id id controller id lower raise exit exit lower raise train gate controller satisfied 
timed languages introduce time trace semantics define timed words coupling real valued time symbol word 
timed languages set nonnegative real numbers chosen time domain 
time sequence delta delta delta infinite sequence time values satisfying constraints 
monotonicity increases strictly monotonically 
progress timed word alphabet sigma pair oe consisting infinite word oe oe oe sigma time sequence timed language sigma set timed words sigma 
symbol oe interpreted denote event occurrence corresponding component interpreted time occurrence oe progress requirement ensures disallow infinitely events occur finite interval time 
consider examples timed languages 
safety property example alphabet fa bg 
define timed language consist timed words oe time 
language oe 
oe example language consisting timed words alternate successive pairs time difference keeps increasing 
language ab gamma gamma 
gamma language theoretic operations intersection union complementation defined timed languages usual 
addition define operation discards time values associated symbols considers projection timed trace oe component timed language sigma language consisting words oe oe time sequence instance referring example language words contain finitely consists single word ab adding timing traces untimed process models sequencing events actual times events occur 
description channel example gives sequencing events delays 
timing added trace coupling sequence time values 
timed trace set events pair oe oe trace time sequence 
timed trace oe gives time events oe occur 
particular gives time observable event assume define 
timed process pair finite set events set timed traces example consider channel example 
assume message arrives time subsequent messages arrive fixed intervals length time units 
furthermore takes time unit message traverse channel 
process single timed trace ae represented timed process fa bg fae 
operations untimed processes extended obvious way timed processes 
get projection oe intersect event set oe delete empty sets associated time values 
definition parallel composition remains unchanged uses projection timed traces 
parallel composition processes require processes participate common events time 
rules possibility interleaving parallel composition timed traces single timed trace empty 
example example consider channel connected possible trace oe bc addition timing specification says time taken message traversing channel delay real value 
timed process infinitely timed traces fb cg oe gamma gamma description obtained composing ae timed trace composition process uncountably timed traces 
example trace time values associated events discarded operation 
timed process untimed process event set trace set consisting traces oe oe time sequence note example shows sides necessarily equal 
words timing information retained timed traces constrains set possible traces processes composed 
example channels example composition unique untimed trace abc infinitely traces pair events possible orderings event event admissible 
verification problem posed inclusion problem 
implementation composition timed processes specification timed process 
example consider verification problem example 
model implementation timed process meets specification specification timed process fa cg abc 
observe specification constrains sequencing events correctness respect crucially depends timing constraints channels 
timed automata augment definition automata accept timed words develop theory timed regular languages analogous theory regular languages 
example timed transition table transition tables timing constraints extend transition tables timed transition tables read timed words 
automaton state transition choice state depends input symbol read 
case timed transition table want choice depend time input symbol relative times previously read symbols 
purpose associate finite set real valued clocks transition table 
clock set zero simultaneously transition 
instant reading clock equals time elapsed time reset 
transition associate clock constraint require transition may taken current values clocks satisfy constraint 
define timed transition tables formally consider examples 
example consider timed transition table 
start state single clock annotation form edge corresponds action resetting clock edge traversed 
similarly annotation form 
edge gives clock constraint associated edge 
automaton starts state moves state reading input symbol clock gets set transition 
state value clock shows time elapsed occurrence symbol 
transition state enabled value 
cycle repeats automaton moves back state timing constraint expressed transition table delay 
constrain delay transitions require particular clock reset associate appropriate clock constraint note clocks set asynchronously 
means different clocks restarted different times lower bound difference readings 
having multiple clocks allows multiple concurrent delays example 
example timed transition table uses clocks accepts language abcd clock gets set time automaton moves reading check 
associated transition ensures happens time preceding similar mechanism resetting independent clock reading 
timed transition table clocks checking value reading ensures delay greater 
notice example constrain delay automaton put explicit bounds time difference important advantage having multiple clocks set independently 
clocks automaton correspond local clocks different components distributed system 
clocks increase uniform rate counting time respect fixed global time frame 
fictitious clocks invented express timing properties system 
alternatively consider automaton equipped finite number watches started checked independently watches refer clock 
clock constraints clock interpretations define timed automata formally need say type clock constraints allowed edges 
atomic constraint compares clock value time constant clock constraint conjunction atomic constraints 
value set nonnegative rationals time constant 
formally set clock variables set phi clock constraints ffi defined inductively ffi ffi ffi clock constant clock interpretation set clocks assigns real value clock mapping say clock interpretation satisfies clock constraint ffi iff ffi evaluates true values denotes clock interpretation maps clock value 
denotes clock interpretation assigns agrees rest clocks 
timed transition tables timed transition table tuple sigma ei ffl sigma finite alphabet ffl finite set states ffl set start states ffl finite set clocks ffl theta theta sigma theta theta phi gives set transitions 
edge hs ffii represents transition state state input symbol set gives clocks reset transition ffi clock constraint timed word oe timed transition table starts start states time clocks initialized 
time advances values clocks change reflecting elapsed time 
time changes state transition form hs oe ffii reading input oe current values clocks satisfy ffi 
transition clocks reset start counting time respect time occurrence transition 
behavior captured defining runs timed transition tables 
run denoted timed transition table sigma ei timed word oe infinite sequence form hs oe gamma 
hs oe gamma 
hs oe gamma 
delta delta delta clock interpretation satisfying requirements ffl initiation ffl edge form hs gamma oe ffi gamma gamma gamma satisfies ffi equals 
gamma gamma gamma 
set inf consists states infinitely 
example consider timed transition table example word give initial segment run 
clock interpretation represented listing values 
hs gamma 
hs gamma 
hs gamma 
hs gamma 
hs delta delta delta timed regular languages couple acceptance criteria timed transition tables define timed languages 
timed buchi automaton short tba tuple sigma fi sigma ei timed transition table set accepting states 
run tba timed word oe called accepting run iff inf 
tba language timed words accepts defined set oe accepting run oe analogy class languages accepted buchi automata call class timed languages accepted timed regular languages timed language timed regular language iff tba example language example timed regular language timed transition table coupled acceptance set consisting states accepts 
regular language sigma timed language oe oe lg timed regular 
typical example nonregular timed language language example 
requires time difference successive pairs form increasing sequence 
nonregular language properties timed automata closure properties decision problems timed automata play important role application verification 
mention relevant results refer reader ad details 
class timed regular languages closed intersection 
possible construct tba accepts intersection 
construction modification product construction buchi automata 
consider sigma disjoint clock sets 
set clocks product automaton states form hs ki th component tuple keeps track state component counter cycling accepting conditions individual automata 
initially counter value incremented modulo iff current state th automaton accepting state 
initial states form hs start state transition obtained coupling transitions individual automata having label 
fhs ffi ng set transitions automaton label corresponding set joint transition state form hs ki labeled new state hs ji mod 
set clocks reset transition associated clock constraint ffi counter value cycles range gamma infinitely iff accepting conditions automata met 
consequently define accepting set consist states form hs gamma class timed regular languages closed union 
closed complement 
example language accepted automaton fag complement language characterized tba 
complement needs sure pair separated distance 
bound number happen time period length keeping track times past time unit require unbounded number clocks 
section give algorithm testing language tba empty 
recall test language buchi automaton contained test emptiness language product automaton complement 
strategy possible automatically complement tba 
fact algorithm testing language tba contained 
automaton language inclusion problem undecidable 
language inclusion problem solvable deterministic specification automata 
deterministic timed automata recall untimed case deterministic transition table single start state state input symbol state uniquely determined 
want similar criterion determinism timed automata extended state input symbol time occurrence extended state transition uniquely determined 
allow multiple transitions starting state label require clock constraints mutually exclusive time transitions enabled 
timed transition table sigma ei called deterministic iff 
start state js 
sigma pair edges form hs gamma gamma ffi hs gamma gamma ffi clock constraints ffi ffi mutually exclusive ffi ffi unsatisfiable 
timed automaton deterministic iff timed transition table deterministic 
deterministic timed automata easily complemented deterministic timed transition table run timed word 
algorithm checking emptiness test language tba included language deterministic tba 
details regarding deterministic ad 
checking emptiness section describe algorithm checking emptiness language timed automaton 
existence infinite accepting path underlying transition table clearly necessary condition language automaton nonempty 
timing constraints automaton rule certain additional behaviors 
show buchi automaton constructed accepts exactly set untimed words consistent timed words accepted timed automaton 
recall definition timed automata allows clock constraints involve comparisons rational constants 
clock constraints automaton involve rational constants multiply constant common multiple denominators constants appearing clock constraints transformation leaves untimed language unchanged 
consequently checking emptiness restrict timed automata clock constraints involve integer constants 
clock regions point time behavior timed transition table determined state values clocks 
motivates definition timed transition table sigma ei extended state pair hs clock interpretation number extended states infinite fact uncountable possibly build automaton states extended states extended states state agree integral parts clock values ordering fractional parts clock values runs starting extended states similar 
integral parts clock values needed determine particular clock constraint met ordering fractional parts needed decide clock change integral part 
example clocks extended state transition clock constraint followed transition clock constraint depending current clock values satisfy 
integral parts clock values get arbitrarily large 
clock compared constant greater actual value exceeds consequence deciding allowed paths 
formalize notion 
fract denotes fractional part btc denotes integral part btc fract 
assume clock appears clock constraint 
largest integer compared clock constraint appearing equivalence relation defined set clock interpretations iff conditions hold 
exceed 
fract fract iff fract fract 

fract iff fract 
clock region equivalence class clock interpretations induced 
denote clock region belongs 
region uniquely characterized finite set clock constraints satisfies 
example consider clock interpretation clocks 
clock interpretation satisfies constraint represent region 
nature equivalence classes best understood example 
example consider timed transition table clocks 
clock regions shown 
role region equivalence understood defining time transition relation extended states 
extended states hs hs alphabet corner points open line segments open regions clock regions symbol define hs hs iff exists time increment edge hs ffii satisfies ffi 

hs hs iff automaton extended state hs time elapse read input symbol transition hs crucial property equivalence relation hs hs exists clock interpretation hs hs due property equivalence relation called time bisimulation 
note finite number regions 
note clock constraint ffi satisfies ffi iff satisfies ffi say clock region ff satisfies clock constraint ffi iff ff satisfies ffi region represented specifying clock clock constraint set fx fc gamma fx pair clocks gamma gamma appear fract equal greater fract 
counting number possible combinations equations form conclude number clock regions bounded jcj 
delta jcj delta pi 
number clock regions exponential encoding clock constraints 
region automaton step decision procedure checking emptiness construct transition table paths mimic runs certain way 
denote desired transition table region automaton state records state timed transition table equivalence class current values clocks 
form hs ffi ff clock region 
intended interpretation extended state hs state hs region automaton starts state hs start state clock interpretation assigns clock 
transition relation defined intended simulation obeyed 
edge hs ffi hs ff labeled iff state clock values ff transition extended state hs ff timed transition table sigma ei corresponding region automaton transition table alphabet sigma 
ffl states form hs ffi ff clock region 
ffl initial states form hs ffl edge hhs ffi hs ff ai iff hs hs ff ff example consider timed automaton shown 
alphabet fa dg 
state automaton accepting state 
corresponding region automaton shown 
regions reachable initial region hs shown 
note 
timing constraints automaton ensure transition taken 
reachable region state component satisfies constraints region outgoing edges 
region automaton helps concluding transitions follow transition 
establish correspondence runs runs 
run form hs oe gamma 
hs oe gamma 
hs oe gamma 
delta delta delta define projection sequence hs oe gamma 
hs oe gamma 
hs oe gamma 
delta delta delta definition edge relation follows run oe 
time progresses bound clock reset infinitely certain time onwards increases bound 
infinitely satisfies 
prompts definition run ff region automaton progressive iff clock infinitely ff satisfies 
correspondence runs runs precise progressive run oe exists time sequence run oe equals 
example consider region automaton 
run suffix forms automaton cycles regions hs hs ii automaton stays region hs self loop iii automaton stays region hs case iii corresponds progressive runs 
runs type gets reset infinitely value 
runs type ii value bounded clock reset finitely value bounded 
progressive run corresponds run type iii 
construction timed automaton region automaton recognize 
purpose need add acceptance conditions progressive runs satisfy accepting conditions 
leads main theorem timed automata 

automaton region automaton tba sigma fi exists buchi automaton sigma accepts equivalently timed language timed regular regular 
example consider region automaton example 
states accepting description progressive runs example follows transition table changed buchi automaton choosing accepting set consist single region hs consequently ac ac check language tba empty check emptiness language corresponding buchi automaton 
timed buchi automaton sigma fi emptiness checked time jsj jej delta jffi jffi length encoding clock constraints blow length clock constraints unavoidable technically problem checking emptiness tba pspace complete 
note source complexity choice model time 
pspace lower bound holds leave syntax timed automata unchanged discrete domain model time 
verification section discuss theory timed automata prove correctness finite state real time systems 
verification timed automata timed process timed language 
timed regular process set timed regular language represented timed automaton 
finite state systems modeled 
underlying transition table gives graph system 
seen clocks represent timing delays various physical components 
acceptance conditions correspond fairness conditions 
notice progress requirement imposes certain fairness requirements implicitly 
finite state process associate tba consists precisely timed traces implementation described composition components 
component modeled timed regular process 
possible construct tba represents composite process 
verification procedure outline explicitly construct implementation automaton specification system timed regular language alphabet system correct iff deterministic tba solve algorithmically 
consider hp deterministic tba hp assume loss generality clock sets disjoint 
verification algorithm constructs transition table region automaton corresponding product timed transition tables set clocks states form hs initial states form hs transition obtained coupling transitions individual automata labeled consistent event sets 
transitions region automaton defined edges described section 
test desired inclusion algorithm searches cycle region automaton accessible initial state satisfies condition clock cycle contains region satisfying definition composition requires consider infinite runs automaton participates infinitely times require cycle contains transition automaton participates fairness requirements implementation automata met cycle contains state th component belongs accepting set fairness condition specification met cycle contain state th component belongs accepting set desired inclusion hold iff cycle conditions 
verification example revisit railroad controller example 
introduce timing characteristics model section 
train required send signal approach minutes enters crossing 
furthermore know maximum delay signals approach exit minutes 
gate responds signal lower closing minute responds signal raise minutes 
response time controller approach signal minute signal exit minute 
constraints easily expressed clocks revised model shown fig 
implementation timed automaton parallel composition train gate controller 
addition safety requirement consider real time liveness requirement gate closed stretch minutes 
real time liveness property specified timed automaton 
automaton requires followed minutes 
note automaton deterministic complemented 
furthermore observe acceptance condition necessary include state acceptance set 
progress time ensures self loop state clock constraint taken indefinitely automaton eventually visit state correctness specifications checked separately outlined section 
observe safety property purely qualitative property hold discard timing requirements 
case properties region automaton 
approach train gate id id id controller id lower raise exit 


exit lower 
approach raise 
train gate controller timing product reachable vertices approximately tools verify property quickly minute 
heuristics number regions region automaton exponential total number clocks proportional magnitudes constants clock constraints 
alleviate blow variety heuristics proposed 
manipulating zones heuristic attempts group regions 
consider timed transition table sigma ei 
clock zone union clock regions 
zone automaton transition table alphabet sigma ffl states form hs ffi ff clock zone 
ffl initial states form hs ffl edge hs ffi hs ff iff zone ff contains clock interpretations hs hs ff 
real time liveness property reachable zone automaton example revisit region construction example see 
reachable part zone automaton shown 
note region automaton zone automaton vertex successor input symbol 
number vertices number vertices 
emptiness language timed automaton checked searching cycles zone automaton 
theoretically number zones exponential number regions zone automaton may exponentially bigger region automaton 
practice zone automaton fewer reachable vertices leads improved performance 
furthermore number clock regions grows magnitudes constants clock constraints experience indicates number reachable zones relatively insensitive magnitudes constants 
observe timed transition table clocks zone subset dimensional euclidean space zone represented linear inequalities clock variables 
call zone simple described conjunction clock constraints formulas form gamma gamma gamma gamma clocks constant simple zone convex described comparing clock value difference clocks constants 
structure timed transition tables ensures vertex hs ffi zone automaton reachable initial state zone ff finite union simple zones 
simple zone nicely represented structure called difference bound matrix dbm see dil details 
searching cycles zone automaton zone maintained union dbms edges zone automaton computed fly 
dbm representation allows efficient computation successors vertex 
furthermore dbm representation canonical testing equality zones easy 
tool kronos allows verification timed automata search zones 
deterministic timed automata specifications kronos uses timed calculus specification language 
refer reader hnsy theory underlying kronos description tool applications 
approximations variety interpretation techniques improve performance searching zone automaton 
indicated manipulating simple zones efficient 
vertices zone automaton contain unions simple zones 
search speeded replacing union simple zones smallest simple zone containing 
instance zone replaced simple zone 
formally timed transition table approximate zone automaton transition table follows 
state pair hs ffi consisting state simple zone ff 
state hs ffi initial ff contains single clock interpretation assigns clocks 
edge hs ffi hs ff iff zone ff smallest simple zone contains clock interpretations hs hs ff 
words zone automaton edge hs ffi hs ff ff convex hull ff edge hs ffi hs ff transition table approximates 
acceptance conditions translated acceptance conditions 
searching search cycles 
note searching approximate zone automaton done efficiently manipulating dbms 
language empty language language represents product components complement specification means system satisfies specification 
language nonempty conclude nonemptiness language 
case may need perform search 
effective techniques perform repeated search simple zones developed 
see won variety approximation techniques zone automata experimental results applications 
iterative verification consider tba sigma ei 
computational complexity verification problem depends number clocks magnitudes constants clock constraints 
iterative approximation strategy considers iteration tests emptiness 
approximations satisfy property ffl tba approximation 
ffl tba state transition structure simpler clock constraints constraints edges number clocks constants smaller magnitudes 
ffl increases better approximation ae 
ffl approximations converge finite number number iterations 
specifically state transition structure clock constraint simplified true 
testing emptiness easy simply need search reachable cycle contains accepting state 
empty done 
word oe accepting run oe 
step test exists time sequence run oe follows state sequence problem computationally easy solved efficiently polynomial time 
run oe infer nonempty 
algorithm needs compute approximation approximation computed adding minimal set constraints run corresponding variety heuristics purpose 
example illustrates ideas 
example consider tba shown alphabet unary accepting state 
automaton uses clocks largest constant 
region automaton large number vertices 
observe empty 
approximation language nonempty accepting run run checked constraints run inconsistent follow run 
algorithm computes minimal set fx zg clocks thee constraints clocks sufficient inconsistency case fy zg 
algorithm attempts relax constraints lower bounds decreased upper bounds increased 
particular replaced 
possible divide constants greatest common divisor constants 
leads approximation automaton clocks constants small 
region automaton conclude empty implies empty 
step iteration conclude emptiness nonemptiness need add additional constraints relaxed bounds obtain better approximation 
precise details iterative scheme see 
heuristic implemented tool cospan see experimental results 
cases original emptiness question answered iterations 
advantage method cases algorithm computes tight bounds needed prove specification 
discussion chapter shown extend theory finite automata incorporate timing illustrated application verification real time systems 
various tools cospan kronos incorporate timing verification principles 
details implementations experimental results reader referred won 
iterative verification related extensive literature verification timed systems 
examples formalisms admit modeling real time systems include timed petri nets ram timed transition systems ost hmp timed automata la process algebras timed csp rr atp nrsv jm 
algorithmic techniques developed timed automata apply models 
automata describe system write correctness requirements 
alternatively real time requirements written formulas timed temporal logics 
model checking algorithms various timed temporal logics developed examples include discrete linear time logics jm ost ah dense linear time logics afh discrete branching time logics emss cc dense branching time logics acd hnsy considered algorithmic methods verification fully automated apply finite state systems 
real world problems need decomposition verification problem subproblems verification algorithms applied 
decomposition requires careful modeling admits compositional hierarchical reasoning 
issues discussed instance lv sha 
hybrid systems model timed automata extended continuous variables clocks temperature imperfect clocks modeled 
hybrid automata useful modeling discrete controllers embedded continuously changing environment 
verifying correctness hybrid automata computationally expensive timed automata simple cases railroad controller allows reasoning parametric bounds 
refer reader ach hybrid automata hh verifier hytech 
abb aziz brayton cheng kam krishnan ranjan sangiovanni singhal wang 
bdd environment formal verification 
proc 
design automation conference 
acd alur courcoubetis dill 
model checking dense real time 
information computation 
ach alur courcoubetis henzinger ho nicollin olivero sifakis yovine 
algorithmic analysis hybrid systems 
theoretical computer science 
ad alur dill 
theory timed automata 
theoretical computer science 
afh alur feder henzinger 
benefits relaxing 
proceedings tenth acm symposium principles distributed computing pages 
ah alur henzinger 
really temporal logic 
journal acm 
alur itai kurshan yannakakis 
timing verification successive approximation 
information computation 
abadi lamport 
old fashioned recipe real time 
real time theory practice rex workshop lncs pages 
springer verlag 
cc campos clarke 
real time symbolic model checking discrete time models 
theories experiences real time system development amast series computing 
dil dill 
timing assumptions verification finite state concurrent systems 
sifakis editor automatic verification methods finite state systems lncs pages 
springer verlag 
dil dill 
trace theory automatic hierarchical verification speed independent circuits 
acm distinguished dissertation series 
mit press 
emss emerson mok sistla srinivasan 
quantitative temporal reasoning 
clarke kurshan editors computer aided verification nd international conference cav lncs pages 
hh henzinger ho 
hytech cornell hybrid technology tool 
technical report cornell university 
hmp henzinger manna pnueli 
temporal proof methodologies real time systems 
proceedings th acm symposium principles programming languages pages 
hnsy henzinger nicollin sifakis yovine 
symbolic model checking real time systems 
information computation 
jm jahanian mok 
safety analysis timing properties real time systems 
ieee transactions software engineering se 
jm jahanian mok 
graph theoretic approach timing analysis implementation 
ieee transactions computers 
kur kurshan 
computer aided verification coordinating processes automata theoretic approach 
princeton university press 
la lynch attiya 
mappings prove timing properties 
distributed computing 
lt lynch tuttle 
hierarchical correctness proofs distributed algorithms 
proceedings seventh acm symposium principles distributed computing pages 
lv lynch vaandrager 
action transducers timed automata 
proceedings third conference concurrency theory concur lncs pages 
springer verlag 
mcm mcmillan 
symbolic model checking approach state explosion problem 
kluwer academic publishers 
nicollin olivero sifakis yovine 
results description analysis timed systems 
technical report verimag grenoble france 
nrsv nicollin luc sifakis 
atp algebra timed processes 
proceedings ifip tc working conference programming concepts methods sea israel 
ost 
temporal logic real time systems 
research studies press 
ram 
analysis asynchronous concurrent systems petri nets 
technical report mac tr massachusetts institute technology 
rr reed roscoe 
timed model communicating sequential processes 
theoretical computer science 
sha shankar 
simple assertional proof system real time systems 
proceedings th ieee real time systems symposium pages 
tho thomas 
automata infinite objects 
van leeuwen editor handbook theoretical computer science volume pages 
elsevier science publishers 
won wong toi 
symbolic approximations verifying real time systems 
phd thesis stanford university 
