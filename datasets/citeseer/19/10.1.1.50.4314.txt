functional programming january fl cambridge university press deriving lazy machine peter sestoft department mathematics physics royal veterinary agricultural university dk denmark mail sestoft dina dk version march derive simple machine lazy evaluation lambda calculus starting launchbury natural semantics 
lazy evaluation means non strict evaluation sharing argument evaluation call need 
machine derive lazy version krivine machine originally designed call name evaluation 
extend datatype constructors base values final machine implements dynamic aspects lazy functional language 
development efficient machine lazy evaluation usually starts graph reduction machine environment machine 
graph reduction machines perform substitution rewriting term graph program 
sharing argument evaluation application implemented sharing subgraph representing argument term obviously correct 
rewriting program subterms precludes efficient implementation sequential imperative computers graph reduction machines refined give efficient implementations 
machines complicated obviously correct cf 
machine augustsson johnsson 
environment machines perform substitution updating environment mapping variables terms modifying program 
resemble sequential imperative computers obviously efficient 
implement call name evaluation modified implement sharing argument evaluation 
machines complicated obviously efficient cf 
instruction machine tim fairbairn wray 
ingenious efficient hybrids graph reduction machines environment machines exist improvements initial simplicity cf 
spineless tagless machine peyton jones 
take different approach 
develop machine lazy evaluation natural semantics published launchbury 
graph reduction schemes semantics accounts sharing outset machine derived easily 
sestoft contributions show known implementation techniques developed published natural semantics lazy evaluation 
number refinement steps proving correctness non trivial ones 
initially consider simple language lambda calculus augmented mutually recursive bindings 
natural semantics language obtain machine naturally lazy version krivine machine curien 
machine instructions simple close sequential computer potentially efficient 
extending language natural semantics include datatype constructors base values show known efficient implementations derived 
steps may seen reverse engineering techniques spineless tagless machine peyton jones 
development covers dynamic aspects lazy functional language static aspects type inference 
hope demonstrates lazy functional language implementation time clearly correct small understandable efficient 
motivation goal pedagogical understand lazy evaluation 
extensional properties lazy functional languages simple elegant lazy languages satisfy laws strict ones 
conversely intensional aspects space consumption evaluation order harder understand 
practice intensional aspects important extensional ones engineer able estimate properties including time space requirements programs just understands properties artefacts bridges power lines computer hardware 
study model implementation developed may help students understand intensional aspects lazy languages 
similarly model implementation useful describing experimenting implementation design choices particular representation environments 
goal provide foundation intensional program analyses 
instance evaluation order analysis may determine compile time approximation evaluation order subexpressions 
semantic foundation analysis incorporate notion evaluation order true real implementation 
machine close links operational semantics candidate foundation 
put 
sansom peyton jones devised cost semantics instrumentation launchbury semantics time space costs 
modified version derivation proof show machine profiling close actual implementation correct respect cost semantics 
working level semantics machine enables precise discussion alternative cost attributions 
deriving lazy machine outline section small lazy functional language operational semantics launchbury 
section derive simple machine evaluation stack prove correctness respect semantics 
introduce environment avoid modifying program evaluated replace variable names de bruijn indices 
section identify solve problem space consumption machine 
extend language semantics machine algebraic datatypes section base values section 
section evaluate resulting machine section discuss related 
lazy language natural semantics lazy evaluation understand normal order reduction weak head normal form whnf sharing argument evaluation 
syntax launchbury presents natural semantics lazy evaluation called normalized lambda expressions xn argument application variable ensures sharing argument evaluation requiring non trivial argument expressions bound treating bound expressions appropriately 
general lambda expressions may transformed normalized ones new bindings 
simultaneous recursive binding distinct 
write fx binding xn denotes syntactical identity expressions denotes naive simultaneous substitution free occurrences fx fx fx fx implicit renaming bound variables assumed 
write simultaneous substitution pn xn xn distinct 
launchbury semantics heap store gamma 
mapping variables expressions dom gamma denote heap domain set variables bound gamma sestoft gamma gamma lam gamma delta delta theta gamma theta app gamma delta gamma 
delta 
var gamma 
delta gamma fx delta fig 

launchbury natural semantics lazy evaluation rng gamma range set expressions bound gamma gamma 
heap maps variable gamma 
write gamma 
gamma 
pn 

configuration gamma consists heap gamma expression evaluated 
judgement gamma theta says heap gamma expression evaluate value producing new heap theta 
launchbury defines relation configurations set inference rules operational semantics reproduced 
proved semantics correct respect denotational 
rule lam lambda abstraction value whnf evaluates heap gamma unmodified 
rule app application evaluated heap gamma evaluating lambda abstraction producing new heap delta 
argument substituted formal parameter evaluated heap delta obtain final result final heap theta 
rule var variable bound expression heap gamma 
evaluated evaluating gamma obtain value new heap delta 
achieve laziness avoid re evaluation heap updated reduced value giving heap delta 

duplicates expression cause name clashes bound variables copy replaced fresh variables indicated renaming notation observe evaluated heap gamma binding evaluation whnf requires evaluation fails indicating black hole direct program rule binding fx evaluated binding expressions variables evaluating resulting heap gamma 

program closed expression bound variables distinct 
value program computed finding derivation fg delta easy induction shows result lambda abstraction semantics rules deterministic modulo variable renaming essentially deriving lazy machine sequential build derivation tree determine final heap left hand premise proceeding right hand premise 
properties launchbury semantics semantics rules adequately model lazy evaluation function argument evaluated unevaluated expression gets duplicated 
normalized expression see section non trivial function argument bound variable bound expression evaluated whnf twice 
bound removed heap gamma evaluated rebound whnf attempt refer rebinding fail rule var applicable bound heap 
rebinding subsequent just retrieve whnf heap rules var lam 
furthermore expressions whnf duplicated 
app rule substitutes variable variable duplicate variables 
var rule duplicated expression whnf form rules model lazy evaluation 
duplication rule var violates full laziness peyton jones chapter may contain redex free occurrences redex may reevaluated application desired full laziness obtained introducing new binding maximal free expression recursively replace maximal free expression fresh variable 
semantics avoid variable capture naive substitution app rule avoid rebinding variable bound heap delta var rule 
launchbury ensures requiring bound variables program distinct renaming bound variables point expression containing bound variables may duplicated var rule 
renaming strategy unsuitable basis machine design 
problem variable freshness locally checkable var rule binding 
may deleted gamma previous application var rule 
see evaluate expression empty heap 
applying var rule evaluate re bind evaluation possible rename occurs local expression heap 
cause trouble re binding evaluated heap delta invalidating launchbury page theorem distinct naming 
check freshness inspect derivation tree built far undesirable 
furthermore unnecessary rename bound variables var rule economical approach adequate preferable implementation 
sestoft gamma gamma lam gamma delta delta theta gamma theta app gamma fpg delta gamma 
delta 
var gamma 
delta gamma fx delta rule variables pn distinct fresh occur gamma fx notation means pn xn 
fig 

revised natural semantics lazy evaluation revising semantics change renaming machinery obtaining revised semantics 
identical launchbury respects renaming 
section show avoids variable capture 
freshness locally checkable extending judgement set variables left gamma premise var rule 
intuitively set variables values currently computed 
secondly move renaming var rule rule rename bound variables 
renaming xn fresh variables pn gives expression pn denotes result naive substitution pn xn 
distinct defined 
variable fresh occur gamma xn intuitively fresh variables corresponds allocation unused heap addresses pn naturally done rule var rule 
value whnf closed expression computed finding derivation fg fg delta revised semantics rules 
henceforth distinguish heap pointers introduced rule program variables originating expression evaluated 
soundness distinction follows observation derivation tree evaluation closed expression occurrences heap pointers expressions free possibly bound heap occurrences program variables bound lambda 
proved 
deriving lazy machine properties revised semantics show variable capture substitution rule app rebinding variable bound heap delta rule var expression bv denote lambda bound variables free variables extend notation configurations bv gamma bv bv rng gamma fv gamma fv rng gamma revised semantics satisfies derivation fg fg delta closed bound variables program variables free variables heap pointers introduced rule 
formalize 
definition set variables 
configuration gamma dom gamma disjoint fv gamma dom gamma bv gamma dom gamma disjoint 
context judgement gamma gamma requirements say variable value computed bound gamma free variable computed bound gamma dangling pointers program variables pointers distinct definition judgement gamma gamma promising gamma 
derivation promising judgement distinction program variables pointers maintained lemma assume judgement gamma gamma derivation 
gamma gamma dom gamma dom gamma judgement derivation promising 
proof induction structure derivation 
proposition closed expression consider derivation fg fg theta instance rule app variable capture instance rule var bound delta 
proof closed fg fg definition 
lemma judgement gamma delta derivation promising judgement configurations gamma delta 
follows instance app rule fv gamma dom gamma dom delta gamma 
delta bv delta disjoint dom delta bv variable bound captured substitution 
instance var rule fpg dom delta disjoint delta fpg 
bound delta 
sestoft proposition says expression closed variable capture rebinding derivation fg fg delta computes value revised renaming strategy adequate 
note bound variables need distinctly named 
illustrate renaming evaluate expression naively substitute beta reduction lam fp pg fg fp pg lam fp pg fg fp pg app fp pg fg fp pg fg fg fp pg premise rule fresh variable substituted expressions second premise app rule argument substituted variable capture 
deriving simple machine operationally speaking evaluation natural semantics builds derivation tree fg fg delta bottom computation machine builds state sequence 
turn recipe tree construction recipe state sequence construction 
challenge lies representation context subtrees 
instance applying var rule build subtree premise context rule tells update heap delta computed value create delta 

context explicit machine state sequence corresponding subtree remember update heap app var rules change context subtrees 
app rule remember build second subtree building var rule remember update heap building subtree 
subtree built rule result delta subtree result entire tree new context needed 
step machine context continuation subtree explicit state 
context extensible subtree context extension context convenient stack representing context 
longstanding tradition control context procedure invocation algol pascal represented stack return addresses 
step introduce stack state machine triple gamma gamma just heap expression configuration gamma stack represents context configuration part surrounding derivation tree 
traditionally component called control machine 
deriving lazy machine heap control stack rule gamma app gamma gamma app gamma gamma 
var gamma gamma var gamma 
gamma letfx ge gamma 
rule notation means pn xn variables pn distinct fresh occur gamma fx fig 

machine mark stack ffl lam rule give rise machine rules machine action required leave heap expression 
ffl app rule natural semantics gives rise machine rules app begins computation corresponding left subtree app begins computation corresponding right subtree 
ffl var rule gives rise machine rules var begins computation corresponding subtree var updates heap computed result 
ffl rule gives rise machine rule allocates new heap addresses begins computation corresponding subtree 
stack list arguments update markers reduced value lambda abstraction control lambda abstraction examine stack top element act accordingly ffl argument stack top reminder applied evaluated 
done app rule 
ffl update marker stack top reminder heap updated 

done var rule 
intuitively value expression previously bound heap achieve sharing binding updated reduced value 
values lambda abstractions considered check update markers correctly implement var rule 
version machine shown 
set update markers stack corresponds closely set revised natural semantics rules 
initial heap stack empty initial state fg 
machine terminates rule applies 
terminal state form sestoft heap gamma control stack rule fp 
pg fp 
pg app fp xg var fp xg app fp xg app fg var fp xg var fp xg var fp xg app fp xg var fp xg var fig 

example evaluation machine mark gamma representing successful termination result form gamma dom gamma representing discovery black hole program 
rules deterministic modulo choice fresh variables 
terminology peyton jones section natural semantics eval apply model machine push enter model 
evaluates application evaluating applying result evaluates pushing argument entering function derivation correctness proof show models closely related 
see machine action show achieves sharing subcomputations consider evaluation 
final result expected 
step fresh heap pointers allocated substituted free occurrences redex reduced twice body 
application rule var needlessly overwrites expression whnf 
identical updates avoided pushing update marker accessing whnf rule var 
refinement machine may introduced stage desired 
correctness machine correctness machine respect revised semantics established proposition need auxiliary properties 
ap fq sg stand set argument pointers stack similarly fq sg stand set update markers stack lemma deriving lazy machine gamma delta gamma ap dom gamma gamma delta derivable gamma delta 
proof induction derivation gamma delta lemma ensures premises promising ap dom delta 
case lam lam rule says gamma gamma clearly gamma gamma empty sequence computation steps 
case app assume gamma theta rule app 
note ap fpg ap gamma ap dom gamma lemma induction hypothesis applies line 
gamma gamma rule app delta left premise ind hyp 
delta rule app theta right premise ind hyp 
case var assume gamma 
delta 
rule var observe necessarily lambda abstraction line note fpg induction hypothesis applies 
gamma 
gamma rule var gamma premise ind hyp 
gamma 
rule var case assume gamma fx delta rule pn occur gamma fx occur ap gamma fx gamma 
rule delta premise ind hyp 
lemma shows machine simulate derivations natural semantics 
show converse computes results natural semantics introduce concept balanced computation 
intention balanced computation corresponds derivation sub tree 
say stack extends stack stack objects 
definition balanced computation computation gamma delta initial final stacks intermediate stack extends initial 
successful computation fg gamma balanced 
want prove balanced computation satisfying restrictions sestoft corresponding derivation tree 
show balanced computation simple structure 
definition trace computation gamma tr gamma tr delta delta delta trn gamma sn sequence tr tr tr transition rules 
balanced trace trace balanced computation 
possible forms balanced traces 
empty trace having state transitions balanced 
assume initial stack non empty balanced trace app var app var produce intermediate stack extension trace begins app producing intermediate stack form eventually app transition occur restores stack transition 
subtrace app occurrence app balanced stacks extensions subtrace balanced stacks extensions 
trace form app bal app bal bal stands arbitrary balanced traces 
trace begins var producing intermediate stack form eventually var transition occur restores stack subtrace var occurrence var balanced 
furthermore control var app var transition follow remove element stack contradict trace 
occurrence var element trace form var bal var trace begins subtrace balanced trace form bal 
summary balanced traces derived grammar bal ffl app bal app bal var bal var bal possibilities correspond natural semantics rules lam app var 
potentially balanced trace structure derivation tree lemma gives formal proof shows natural semantics simulate balanced computation machine 
lemma gamma gamma holds gamma gamma balanced gamma gamma derivable 
proof induction structure balanced traces grammar 
case ffl follows rule lam gamma gamma case app bal app bal 
state app gamma state app delta 
trace balanced gamma delta derivable induction hypothesis 
state app delta trace delta gamma balanced delta gamma derivable induction hypothesis 
app rule conclude gamma gamma derivable 
deriving lazy machine case var bal var gamma gamma 
gamma delta 
gamma delta 
state var gamma state var delta subtrace balanced gamma fpg delta derivable induction hypothesis applicable fpg 
var rule find gamma 
delta 
derivable 
case bal fx renaming pn chosen occur gamma fx state gamma 
trace balanced gamma 
gamma derivable induction hypothesis 
pn occur gamma letfx ge rule conclude gamma letfx ge gamma derivable 
proposition assume fg delta fg fg delta derivable 
proof follows lemma fg fg delta derivable promising 
observe computation fg delta necessarily balanced result follows lemma 
proposition says machine terminates value control natural semantics successfully derives value 
systems deterministic modulo choice fresh variables rules 
second possibility machine may terminate heap pointer control indicating black hole case natural semantics permits derivations 
third possibility machine may embark infinite computation corresponding infinite derivation tree natural semantics 
determinism implies possibilities mutually exclusive 
retrospect surprising proving lemma requires machinery lemma 
proof create sequence tree just matter recursive flattening 
proof create tree sequence harder notion balanced trace device recover tree structure sequence 
second step introduce environments closures machine uses substitution expression model application app rule renaming rule 
unsatisfactory implementation point view modifies expression run time 
avoid introduce environment mapping program variables heap pointers environment thought delayed substitution applied meet program variable control 
previously perform substitution obtaining new expression build pair fy 
pg expression environment fy 
pg 
general previously expression shall pair expression environment sestoft heap control environment stack rule gamma app gamma gamma app gamma gamma var gamma gamma var gamma gamma letfx ge gamma rule variables pn distinct fresh occur gamma letfx ge new environment xn pn 
fig 

machine mark stack environment ee result applying substitution expression pair traditionally called closure 
henceforth heap maps pointers closures expressions similarly bind free variables control add environment machine state tuple gamma 
expression control heap may free program variables bound environment associated resulting machine shown 
revised app var rules performs tasks finds heap pointer bound behaves old app var rule 
correctness modification clear computation sequences mark mark machines closely related 
state mark computation mapped corresponding state mark machine replacing closure expression ee 
environments change result computation 
increases set heap addresses transitively reachable machine components mark rule app substitution embed new control occurs free mark rule app retained new environment 
regardless occurs free 
considerable difference heap addresses may transitively reachable closure pointed heap gamma 
terms lazy language implementations introduced space leak problem appears mark treatment bindings 
shall return issue section 
deriving lazy machine heap control environment stack rule gamma pk app gamma pu gamma app gamma gamma 
pk var gamma pu gamma var gamma 
gamma fe gamma 
app var rules pu th element environment pk 
rule addresses pn fresh occur gamma new environment pn fig 

machine mark stack environment de bruijn indices third step introduce variable indices step get rid program variable names replacing de bruijn indices numbers similar variable offsets conventional compiler terminology syntax normalized lambda expressions de bruijn indices de bruijn index positive integer 
environment mapping positive integers heap pointers represented list heap pointers maps index efficient representations exist 
transition rules final machine shown 
rules app ensure environment contains bindings variables scope bound bound 
occurrence variable replaced de bruijn index equal number lambdas binding lambda occurrence plus standard barendregt appendix 
de bruijn indices point may premature permits comparison krivine machine permits derivation known simple representation data constructors section turn leads known implementation base values section 
sestoft related machines krivine machines cr page sestoft page may obtained combining rules app single rule requires application take restricted form 
machines allocate closure argument ensure sharing 
evaluating application argument expression variable creates superfluous indirection requires extra update 
recursive function chain indirections may build causing space leak 
advantage machine sharing rule separated application app rule 
introduce bindings necessary transforming expressions normalized form 
addition define recursive functions cyclic data krivine machines need separate mechanism 
study machine relation instruction machine tim fairbairn wray observe normalized lambda expressions closely related ordinary sequential code reads push push pointer stack reads take take argument stack reads enter enter closure fe reads fe recursive bindings inspection rules shows instructions push take enter performs bounded amount computation 
instructions tim tim take instruction take arguments stack single 
lazy versions tim usually tie sharing argument passing krivine machines consequences chains indirections build special precautions 
bindings separate sharing argument passing preferable 
tim take instruction efficient single argument take instruction call name case causes complications call need case may update markers arguments taken stack 
machine instruction machine 
experimental implementations machine easily written scheme standard ml provide destructive update underlying garbage collector 
deriving lazy machine space considerations machine quite efficient uses memory space leak environments hold useless closures hinted section 
solve problem 
leaky program see machine far leaks space consider example program abbreviates evaluation expression terminate 
real problem evaluation requires unbounded amount space 
shall evaluate expression mark machine mark machine de bruijn indices obscure presentation 
evaluation outer allocates closure ff 
heap address say 
evaluation call body binds pointer enters body environment fn 

evaluation inner allocates closure address say 
environment part fx 


contains bindings needed evaluating recursive call binds pointer enters body environment fn 

second evaluation inner allocates new closure address say environment part fx 


recursive call binds enters body environment fn 

third evaluation inner allocates new closure address say fx 


evaluates recursive call 
undesirable effect build growing chain closures points closure containing gamma points closure containing gamma point execution closures reachable machine environment stack garbage collected 
consequently space consumption grows linearly execution time program 
practical consequences example contrived similar space leaks appear recursive programs 
show problem significant practice implemented extended version leaky machine ran standard ml new jersey 
data heap sizes reported implementation 
printing prefix list natural numbers defined sestoft heap control environment stack rule gamma letfx gamma jt jt variables pn fresh occur gamma new environment trimming 
xn 
pn 
fig 

revised rule environment trimming machine mark nats cons map add nats nats requires heap space proportional length prefix printed 
improved non leaky machine arbitrary prefix printed bounded small amount space 
similar experiment computing printing prime numbers eratosthenes sieve requires kb heap space leaky machine kb non leaky 
important solve problem 
environment trimming solution refine environments mark machines model closely substitutions performed mark machine 
ideally environment machine environments stored closures heap bind superfluous variables 
idea spineless tagless machine peyton jones section shall trim environments bound expressions free variables included perform trimming annotate bound expression body set free variables 
annotation called mark machine environment mapping variable names pointers just set names trimming respect simply restriction mapping domain shows revised mark rule trimming 
adding mark example previous section find free variables empty set fg fg fx fg ffg ffg see environment closures allocated empty space leak occur 
closures allocated execution quickly unreachable subject garbage collection 
mark machine environment list pointers sub sequence de bruijn indices deriving lazy machine trimming sub list 
de bruijn indices variable occurrences adjusted environment gets trimmed 
adjustment depends set free variables expression compiled 
general passes expression required compile time adjustment poses problems 
closures bound expressions written heap potentially long life time prone cause space leaks reason explicitly trimming environments 
similarly lambda abstraction whnf bound expression closure lambda abstraction written heap 
lambda abstraction ignores argument inclusion environment may cause space leak 
lambda abstraction occur right hand side binding body environments trimmed environment may contain superfluous variables 
trimming environment lambda abstraction entail run time adjustment de bruijn indexes variable occurrences body 
related approaches intermediate language spineless tagless machine stg expression annotated set free variables 
making closure bound expression stg instruction environment 
trim environment body harm lambda abstractions stg machine appear right hand sides 
stg machine suffer potential space leak machine lambda abstraction ignores argument stg machine fixed easily 
lambda lifting johnsson machine automatically performs environment trimming turning local function bindings top level function bindings passing free variables arguments 
may explain lambda lifting works lazy languages spite destroying scope information introducing parameter passing pointer copying required parameter passing required anyway environment trimming lazy language 
trim environment bound expressions 
trimming incurs run time overhead reduces time access variables environments represented linked lists 
trimmed environment represented vector linked list argument values case bound values see followed vector values free variables 
simplicity linked lists 
introducing constructors case expressions shall return environment trimming 
lazy approach environment trimming proposed designers instruction machine fairbairn wray page 
heap allocated environment equipped form bit vector indicating entries environment live 
bit vector generated compile time 
sestoft gamma pa gamma pa cons gamma delta ck pa delta ek yk pa theta gamma case fc theta case fig 

natural semantics rules constructors garbage collection live pointers environment followed copy mark phase 
scheme probably spends time trimming requires space 
advantage variable indexes need adjusted 
efficient environment representations safe space complexity studied strict functional languages shao appel 
relevant designing environment representations lazy languages space efficiency trade offs different closures created higher rate lifetime values harder predict 
algebraic datatypes machine instructions handling algebraic datatypes derived natural semantics rules 
algebraic datatypes known standard ml haskell introduce new forms expressions constructor applications case expressions case fc ja constructor arguments variables ensure sharing components additional bindings may introduced satisfy requirement 
assume typed language constructors different datatypes confused runtime constructor fixed arity 
constructors fully applied 
case expression case object ja alternative 
exactly alternative constructor datatype 
brevity write fc list alternatives vector ja variables 
launchbury gives natural rules evaluation constructor application case see added component 
follows rules reduced value may constructor application lambda abstraction constructors mark machine changes needed handle constructors mark machine shown 
recall machine stack represents continuation computation says join subcomputations corresponding flattening derivation tree 
deriving lazy machine heap control stack rule gamma case alts case gamma alts gamma ck pa alts case gamma ek gamma ck pa var gamma 
ck pa ck pa notation alts stands list fc alternatives yk stands vector yk variables 
case rule ek right hand side th alternative ek abbreviates ek yk pa 
fig 

constructor rules machine mark ffl new cons rule similar lam rule gives rise new machine rules constructor application value requires machine action 
ffl new case rule similar app rule gives rise new machine rules case begins computation corresponding left subtree case begins computation corresponding right subtree 
ffl new version var var rule needed result var rule may constructor application just lambda abstraction constructor application finds update marker stack update heap 
new rules shown 
new kind stack object similar purpose argument needed store case alternatives evaluating case object ffl case marker list fc alternatives 
rule case pushes case marker starts evaluating case object application ak constructor encounters case marker rule case starts evaluating th alternative 
correctness constructor rules proof lemma easily extended account new rules case cons trivial empty sequence computation steps lam 
case case assume gamma case fc theta rule case sestoft gamma case fc gamma fc rule case delta ak fc left premise ind hyp 
delta ki rule case theta right premise ind hyp 
direction 
balanced traces 
arguing section find balanced traces new machine derived grammar bal ffl app bal app bal var bal var bal var bal var case bal case bal ffl trace corresponds cons rule lam rule possibilities correspond var rule case rule respectively 
secondly lemma amended slightly result computation may constructor application ak lemma gamma gamma holds gamma gamma balanced ak gamma gamma derivable 
proof induction structure balanced traces 
case ffl 
follows rule lam cons ak case app bal app bal case var bal var case bal lemma 
case var bal var gamma gamma 
gamma delta 
ak gamma delta 
state var gamma state var delta ak 
subtrace balanced gamma fpg delta ak derivable induction hypothesis applicable fpg 
var rule find gamma 
delta 
ak ak derivable 
case case bal case bal case fc state case gamma fc state case delta ak fc 
trace balanced gamma delta ak derivable induction hypothesis 
state case delta ki trace delta ki gamma balanced delta ki gamma derivable induction hypothesis 
case rule find gamma case fc gamma derivable 
proposition amended similarly proof appeal extended lemmas 
constructors mark machine introduce environments avoid doing substitutions code section derived mark machine 
possible free variables righthand sides alternatives case rule store environment deriving lazy machine heap control environment stack rule gamma case alts case gamma alts gamma ck xa alts case gamma ek gamma ck xa var gamma 
ck ck notation alts stands list fc alternatives yk stands vector yk variables 
case rule ek right hand side th alternative ak var rule stands vector xa variables 
fig 

constructor rules machine mark heap control environment stack rule gamma case alts case gamma alts gamma ck ua alts case gamma ek gamma ck ua var gamma 
ck ck notation alts stands list fc alternatives 
case rule ek right hand side th alternative ua environment ek var rule stands vector ua de bruijn indices 
fig 

naive constructor rules machine mark alternatives case marker stack rule case extract 
case marker form fc 
substitution rule case replaced environment extension 
new rules shown 
constructors mark machine replacing variable names de bruijn indices section syntax alternative simply 
pattern variables ja replaced indices right hand side seemingly inverse order indices natural corresponds indices parameters lambda abstraction ja resulting machine shown 
sestoft improving constructors mark machine handling constructors case expressions improved requiring constructor application restricted form arguments ak exactly indices bound variables 
case new environment second rule just environment appended variables need represent arguments explicitly constructor application application constructor represented just showing tag arity arrived representation constructors peyton jones lester tag arity restriction constructor application enforced defining named constructors illustrated standard list constructors nil cons arities nil cons application cons named constructor ordinary application arguments variables ensure sharing 
illustrate encoding consider evaluating cons update marker stack top assume gamma gamma app gamma app gamma app gamma app gamma 
var moving cons arguments environment stack may cumbersome scheme simple permits partial application constructor encodings cons 
realistic implementation frequent case applying known constructor arguments detected optimized compiletime 
improved constructor rules shown 
note elements constructor application environment constructor arity 
need store elements heap meeting update marker 
particularly efficient environment linked list vectors heap pointers constructor arguments represented fixed size vector heap pointers append operation build rule case done constant time independently size deriving lazy machine heap control environment stack rule gamma case alts case gamma alts gamma ck alts case gamma ek gamma ck var gamma 
ck ck notation alts stands list fc alternatives 
case rule ek right hand side th alternative var rule abbreviates 
fig 

improved constructor rules machine mark environment trimming constructors space behaviour rules need improved ways 
rule case storing entire environment case marker stack may cause space leak 
may hold large value case object evaluated 
trim environment storing stack 
rule case alternative free variables environment contain variables free alternatives 
alternative lambda expression closure written heap causing space leak free variables 
trim environment alternative just trim environment body 
rule var better including arguments writing constructed value heap 
add separate alternative joint list alts alternatives 
set variables free including variables bound left hand side set variables free fc excluding variables bound left hand sides 
arrive improved rules shown 
spineless tagless machine joint environment alternatives case peyton jones section 
machine 
base values additional machine instructions handling base values integers introduced ways 
section derive mechanisms base value handling representations suggested peyton jones launchbury 
alternatively may derive nearly base value operations launchbury operational semantics sestoft appendix 
sestoft heap control environment stack rule gamma case alts case gamma alts gamma ck alts case gamma ek jt gamma ck var gamma ck ck notation alts stands list fc 
alternatives 
case rule ek right hand side th alternative var rule abbreviates 
fig 

final constructor rules environment trimming machine mark gamma gamma int gamma delta delta theta gamma theta add fig 

natural semantics rules integers deriving base value handling integers addition illustrate base values note operands addition need variables shared 
shall assume expressions typed applied expressions evaluate integers 
launchbury evaluation rules shown 
integer reduces immediately rule int addition evaluated evaluating operands turn adding results rule add 
reflects base value operators strict arguments evaluated operation applied 
exploit ideas due peyton jones launchbury constructors represent boxed integers case expressions evaluate arguments application 
recall boxed base value represented closure evaluated obtain unboxed value just bit pattern representing value 
boxed value may turn undefined attempt evaluate closure may loop unboxed value defined 
represent boxed integer constructor application int int constructor datatype boxed integers arity corresponding generic constructor final constructor representation deriving lazy machine heap control environment stack rule gamma cst cst gamma int gamma op add gamma int fig 

rules base values machine mark developed section boxed integer int represented pair int element vector containing pointer closure representing unboxed integer unboxed just bit pattern shall element vector containing directly giving boxed representation int 
secondly case expressions force argument evaluation 
instance addition integer valued expressions defined peyton jones launchbury page slightly simplified case int case int int de bruijn indices section case expression translates ignore environment trimming case fint gg indices base value constants means add values environment 
rules say evaluate case expression unboxed addition 
suffices postulate new machine instruction op computes unboxed sum values current environment creates boxed result int 
replace innermost case alternative int op 
single new instruction needed perform addition 
new instruction cst needed introduce integer constants evaluate int 
required new rules shown 
illustration consider evaluation compiled case fop gg abbreviation case fop inner case sestoft gamma case fe gamma fe case gamma int fe evaluate gamma case op case gamma fop case gamma int fop evaluate gamma op case gamma int add close correspondence computation sequence tree derived add rule natural semantics 
subcomputations starting case just case correspond left right subtree respectively 
occurrence case initiates evaluation right hand subtree second occurrence case activates add step performs addition rule 
bound expression evaluates integer result int encounter update marker machine stack 
int just constructor situation handled rule var update heap closure int desired 
introducing base value stack base value handling developed simple inefficient 
intermediate base values held environment component closures stack computation 
may prevent optimization environment representations may complicate garbage collection mixing base values pointers stack 
better separate value stack intermediate base values 
introduce separate value stack replace general int constructor really special constructor called ret handle boxed base values 
boxed value closure ret environment component hold unboxed value simplifies updating heap 
new ret op instructions access unboxed value representation ret ret 
new instruction ret push unboxed integer environment value stack 
contrast int extend environment behave argument constructor behavior prescribed case var rules 
rule case ret encounters case marker feg stack activate push base value held value stack rule var ret encounters update marker stack update heap ret 
rules cst op modified 
clearly cst evaluate ret 
addition operator op find arguments value stack evaluate ret 
new rules shown 
action performed ret return address kept stack deriving lazy machine heap control env values stack rule gamma cst cst gamma ret gamma op add gamma ret gamma ret feg ret gamma gamma ret ret gamma ret ret fig 

rules base values machine mark value stack top activates single closure case marker stack name 
originally ret introduced code trick fairbairn wray handle base values instruction machine called self ret adopted peyton jones lester called return 
new derivation ret ordinary constructor consider evaluation new rules 
expression compiled case fe abbreviates case fop gamma case fe gamma fe gamma ret fe gamma case fop gamma fop gamma ret fop gamma op gamma ret type correctness ensure stack top objects encountered ret instruction update markers case markers feg argument pointer consider introducing abbreviation seq case fc seq associates right 
compilation seq seq op reverse polish form expression 
net effect evaluating base value expression push reduced value value stack 
boolean values conditionals printing boolean values may represented argument constructors false true may tested case expressions 
constructors generated basic comparison instructions op op op op op operate value stack 
alternatively boolean values may represented integers may introduce new conditional sestoft cond peyton jones lester section test require duplication machinery environment trimming 
printing data structures done systematically see peyton jones lester section sestoft section 
new machine instruction suffices 
print string side effect activate closure case marker stack activation closure corresponds demand new substructure print print instruction forces evaluation composite data structures usual lazy language implementations 
reason printing trivial concern wants argue correctness evaluation order analysis respect machine know printing drives evaluation 
assessment improvements final machine consisting figures plus operations booleans printing shown twelve instructions implements dynamic aspects lazy functional language 
wrote straightforward experimental implementation standard ml example language peyton jones lester 
standard ml implement heap gamma rely standard ml system garbage collection 
computing printing prime numbers eratosthenes sieve takes approximately seconds implementation running standard ml new jersey version linux intel dx mhz processor 
times slower mark jones gofer system version written 
list positive negative properties machine performs tail calls constant space build indirection chains gamma performs identical updates easily avoided gamma values test stack top exploit strictness information eliminate identical updates pushing update markers values evaluated gamma strictness information hard eliminate tests stack top element gamma variable access constant time linked environment structure traversed 
surprisingly overhead incurred identical updates experimental implementation negligible 
realistic implementation eliminating identical updates stack top tests probably give significant speed 
environment trimming performed case expressions may appear expensive cost machine instruction machine tim applying super combinators spineless tagless machine environment trimming explicit bindings necessary avoid space leaks 
deriving lazy machine experimental implementation environment linked list pointers 
extreme design space tim representation environment vector pointers 
representation gives fast application slow variable access tim representation gives slow application fast variable access 
linked list vectors obvious compromise trimming 
compile time optimizations may improve implementation known fully applied constructors 
similarly may improve base value handling compilation scheme peyton jones lester page 
maintaining symbolic value stack compile time may detect constant op instruction necessarily find arithmetic operation case marker stack top run time 
cases ret step may skipped base value operations performed directly value stack 
short believe realistic implementation spineless tagless machine derived refinements 
related literature derivation machines rich 
closest hannan miller formal derivation call name krivine machine natural semantics call name evaluation hannan machines 
derivation differs environments de bruijn indices introduced natural semantics 
hannan miller general transformation branching natural semantics rules non branching ones essentially introducing explicit stack premises proved 
transformation non branching natural semantics rules flat machine rules proceeds steps ad hoc 
altogether achieve smaller steps somewhat correctness proof proposition 
hand notion balanced traces intuitive significance provided easy extension correctness proof augmenting language data structures section 
cast logical framework hannan miller derivation lends formalization hannan pfenning mechanically verified translation proof elf 
attempted machine verification believe supporting concepts formalized feasible 
wand derived compiler machine denotational semantics continuation passing style 
gave denotational semantics lazy functional languages 
presumably wand approach derive lazy machine 
fairbairn wray developed instruction machine tim callby name evaluation super combinators lazy update markers stack 
argo studied inefficiencies improvements tim particular handling shared partial applications representation environments argo argo 
krivine developed machine call name evaluation descrip sestoft tion curien 
borrowing update marker technique tim people krivine machine lazy including cr sestoft 
close relation krivine machine tim studied cr page mogensen 
simple krivine machine practically useful strict version core efficient interpretive caml light system due leroy 
developing spineless tagless machine peyton jones studies aspects lazy language evaluation 
point departure graph reduction solid operational understanding lazy languages formal description 
necessary intuition gained studying peyton jones peyton jones lester 
developed simple known machine natural semantics lazy evaluation 
proceeded number refinement steps proving correctness non trivial steps demonstrated known implementation techniques derived semantics 
resulting machine sophisticated machine augustsson johnsson spineless tagless machine peyton jones refined instruction machine argo peyton jones lester simple correctness requires separate proof 
shows lazy functional language implementation time demonstrably correct understandable small quite efficient 
addition having pedagogical value machine development provide foundation program analyses concerned operational properties lazy languages 
visit andy moran john hughes chalmers university technology inspired 
anonymous referees provided helpful advice presentation subject matter 
carsten kehler holst torben mogensen simon peyton jones comments suggestions 
argo 

improving instruction machine 
pages fourth international conference functional programming languages computer architecture 
imperial college london 
reading ma addison wesley 
argo 

efficient laziness 
ph thesis department computing science university glasgow 
draft pages 
augustsson 

compiler lazy ml 
pages acm symposium lisp functional programming austin texas 
new york acm 
barendregt 

lambda calculus 
syntax semantics 
revised edn 
amsterdam north holland 
deriving lazy machine cr 

machine normalization terms 
pages acm conference lisp functional programming nice france 
new york acm 
cr 

machines environnement pour la eduction evaluation 
ph thesis universit paris vii france 
curien 

ae calculus framework environment machines 
rapport de recherche liens 
ecole normale sup erieure paris france 
fairbairn wray 

tim simple lazy machine execute supercombinators 
pages kahn 
ed functional programming languages computer architecture portland oregon 
lecture notes computer science vol 

berlin springer verlag 
hannan 

making machines 
pages hughes 
ed functional programming languages computer architecture th acm conference cambridge massachusetts august 
lecture notes computer science vol 

berlin springer verlag 
hannan miller 

operational semantics machines preliminary results 
pages acm conference lisp functional programming nice france 
new york acm 
hannan pfenning 

compiler verification lf 
pages scedrov 
ed seventh annual ieee symposium logic computer science 
ieee computer society press 
johnsson 

efficient compilation lazy evaluation 
pages acm sigplan symposium compiler construction sigplan notices vol 

new york acm 
johnsson 

lambda lifting transforming programs recursive equations 
pages jouannaud 
ed functional programming languages computer architecture nancy france 
lecture notes computer science vol 

berlin springer verlag 


semantics lazy functional languages 
theoretical computer science 
launchbury 

natural semantics lazy evaluation 
pages twentieth acm symposium principles programming languages charleston south carolina january 
new york acm 
leroy 

zinc experiment economical implementation ml language 
rapport technique 
inria rocquencourt france 
mogensen 

re lambda lifting necessary 
personal communication 
peyton jones 

implementation functional programming languages 
prentice hall 
peyton jones 

implementing lazy functional languages stock hardware spineless tagless machine 
journal functional programming 
peyton jones launchbury 

unboxed values class citizens nonstrict functional language 
pages hughes 
ed functional programming languages computer architecture th acm conference cambridge massachusetts august 
lecture notes computer science vol 

berlin springer verlag 
peyton jones lester 

implementing functional languages 
prentice hall 
sansom peyton jones 

time space profiling non strict higher order functional languages 
pages popl nd acm symposium principles programming languages san francisco california january 
new york acm 
sestoft sestoft 

analysis efficient implementation functional programs 
ph thesis diku university copenhagen denmark 
diku research report 
sestoft 

deriving lazy machine 
tech 
rept 
id tr 
department computer science technical university denmark 
pages 
shao appel 

space efficient closure representations 
pages acm conference lisp functional programming orlando florida june 
wand 

deriving target code representation continuation semantics 
acm transactions programming languages systems 
wand 

semantics directed machine architecture 
pages ninth acm symposium principles programming languages albuquerque new mexico january 
new york acm 
