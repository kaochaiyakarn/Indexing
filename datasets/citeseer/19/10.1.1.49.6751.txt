formal specification java tm virtual machine instructions objects methods subroutines qian bremen institute safe systems fb informatik universitat bremen bremen germany 
chapter formally specify subset java virtual machine jvm instructions objects methods subroutines official jvm specification official java language specification sun jdk implementation jvm 
formal specification describes runtime behaviors instructions relevant memory areas state transitions structural linking constraints instructions static typing system 
typing system includes core bytecode verifier resembles data flow analysis 
state properties formal specification sketch proofs 
properties jvm program statically typed respect typing system runtime data program type correct 
formal specification clarifies ambiguities incompleteness removes view unnecessary restrictions description official jvm specification 
java virtual machine jvm platform independent computing machine containing instruction set running various memory areas 
jvm typically intermediate machine implementation programming language java 
official jvm specification lindholm yellin defines syntax instructions describes semantics instructions related memory areas 
chapter specifies subset instructions objects methods subroutines giving formal semantics 
formal specification sun jdk implementation jvm particular bytecode verifier official java language specification gosling joy steele 
formal specification provides foundation exposing behaviors subset jvm 
programs instructions jvm directly web formal specification defines parts security internet programming java 
appear jim alves foss ed 
formal syntax semantics java tm springer verlag lncs formal specification considers essential instructions load store instructions objects integers object creation instruction operand stack management instruction control transfer instructions method invocation instructions return instructions jsr ret instructions implementing clauses 
features jvm considered chapter 
multi threads arrays primitive types type int word wide data class initialization method access control modifiers exception native methods wide runtime exceptions memory organization overflow underflow operand stack legality accesses local variables class file format details constant pool resolution details difference static link time 
assume classes loaded single class loader 
due space constraints briefly sketch proofs chapter 
considers larger subset jvm instructions particular exception handling 
addition contains proofs 
main ideas approach follows formalize operational semantics instructions defining instruction state transition 
time formulate static typing system 
typing rules system may try derive static type memory location static type covers types runtime data possibly held memory location 
typing system characterizes aspects data flow analysis see 
formal specification consists state transition machine typing system 
state transition machine defined programs static types memory locations derivable respect typing system 
practically typing system includes core bytecode verifier 
state properties formal specification 
particular state type inference system successful runtime data guaranteed type correct 
large extent formal specification follows 
extensions changes semantics necessary desirable 
follows page requires static type operand stack entry local variable upper bound types possible runtime data upper bound jvm type 
problem subtyping relation interfaces allows multiple inheritance interfaces need common 
solution allow set interfaces classes static type operand stack entry local variable 
page uses special type indicating object new created instruction new initialized instance initialization method 
introduce kinds special types indicating different stages object initialization specification indicates object uninitialized indicates object initialized instance initialization method encountered invocation instance initialization method 
distinguish stages objects different stages dealt differently 
introduces concept subroutines jsr instruction jumps calls subroutine ret instruction returns subroutine 
mechanism subroutines correct return addresses 
defines new primitive type indicating value return address 
formal specification refine type family special types called subroutine types value subroutine type address jsr instruction calling subroutine compute return address subroutine 
see subroutine types crucial specification constraints jsr ret instructions 
clearly distinguish types memory locations types runtime data 
formal specification clearly distinguish static types memory locations types tags runtime data 
formally discuss type safety property runtime data execution 
chapter notations 
notation ff denote syntactical objects ff delta delta delta ff notation delta delta deltag set define size fff ng fff 
ff ff ff hold denote mapping mapping ff ff mapping element defined concrete case 
fact concrete case mapping element element special value failure explicitly defined 
define dom 
ff fff mapping ff denote result mapping ff write ff 
ff mapping equal maps ff ff set define jd fff 
ff ff dom dg gammad fff 
ff ff dom gamma dg list ff delta delta delta ff gamma special mapping fi 
ff ng 
list lis define lis ff lis size lis 
ff 
related stata abadi proposed type system set instructions focusing subroutines proved soundness 
considered instructions provide lengthy proofs clarify key semantic issues subroutines 
freund mitchell significant extension stata abadi type system considering object initialization doing discovered bug sun implementation bytecode verifier allows program object initialized 
fix bug wrote typing rule ensures time program execution may uninitialized object created new instruction usable 
realizing bug discovered freund mitchell detected early version current contains bug 
point results current independent stata abadi freund mitchell 
differences approach theirs 
follow constraint solving framework typing rules generate constraints define legal types 
second consider jvm instructions details 
examples approach allows inner subroutine return directly outer jsr instruction nested subroutines approach subroutine return approach assigns type local variable information local variable modified subroutine approach consider case 
cohen described formal model subset jvm called defensive jvm runtime checks assure type safe execution 
approach different design static type inference system assures statically typed programs runtime type errors 
addition current consider subroutines specification 
goldberg gave formal specification bytecode verification 
compared considered array types subroutines 
addition formal specification dataflow analysis closer implementation 
hagiya type system subroutines 
interesting points approach introduce mechanism distinguish called unused data subroutine 
idea kind special types indicating certain memory location subroutine content memory location call subroutine 
project quite successful testing running bytecode verifiers detecting flaws 
general testing precise specification 
formal specification may useful testing 
dean studied formal model relating static typing dynamic linking proved safety dynamic linking respect static typing :10.1.1.39.3682
mentioned formal specification consider issue static typing dynamic linking 
formal specification considers single class loader 
saraswat studied static type un safety java presence class loader jvm uses structures java language type system jvm resembles data flow analysis quite different formal specification type system java :10.1.1.35.622
jvm programs methods data areas frames byte bits word size larger byte 
byte wide data build instructions word wide data represent runtime data 
byt range byte data wrd word wide data 
allows word wide integers 
mentioned consider word wide data chapter simplicity 
jvm program chapter defined contain set methods 
assume method unique method code 
cod range method code 
address pair cod word wide datum called byte offset 
address cod byte offset define cod cod 
instruction may longer byte 
program point denoted pp starting address instruction 
consider multi threads assume just program count register contains current program point 
mentioned chapter program point jsr instruction may computing returning program point subroutine 
fact byte offset program point program point may see ret instruction uses program point jsr instruction method jsr instruction 
may talk byte offset jsr rest chapter 
consider arbitrary fixed program prg note methods program may stem different class files 
method prg consists instructions prg program points contain method code 
mth denote arbitrary fixed method prg prg mth denote sets program points prg mth respectively 
assume mth contains unique element form 
intuitively starting program point method 
define function offset byt byt yields byt byt word wide value failure 
specification object formally word wide datum 
obj range object 
furthermore null denote special object 
formally specify int primitive type word wide integers val range integers 
cnam mnam range names classes interfaces methods fields respectively 
formal specification require qualified name 
record formally mapping form 
wrd maps elements special value failure rec range records 
jvm heap memory objects allocated 
formally heap state defined mapping form 
rec maps elements obj special value failure hp range heap states 
frame created time method invoked contains local variable table operand stack method 
frame destroyed method completes 
local variable table state list form wrd delta delta delta wrd gamma 
lvs range local variable table states 
method fixed number local variables 
operand stack state list wrd delta delta delta wrd gamma 
stk range operand stack states 
method fixed maximal length operand stacks 
note need define formally frame frames explicitly specification 
jvm thread java stack store old current frame return address method invocation 
method invocation completes normally old current frame current frame return address current program point 
chapter java stack contains tuples lvs stk pp lvs old current local variable table state stk old current operand stack state pp return address 
consider multi threads need consider java stack 
range java stack states 
program state tuple form pp lvs stk hp 
stat range program states 
static types defines static types 
static analysis memory location program point may obtain static type indicating types runtime data memory location may hold program point executions 
simplicity may omit phrases program point executions rest chapter 
type set ref type null class interface name java 
primitive type int subroutine type sbr pp raw object type pp cnam init cnam unusable value type unusable static types introduce static type null 
memory location may hold special object null memory location may static type null 
static type null class interface names java called types 
note java lang object short object class name java 
nonempty type set static type 
intuitively memory location may hold null objects types ref delta delta delta raw objects see may obtain static type worth mentioning sun implementation implement concept type sets bytecode verifier 
specification single type regarded identical singleton set containing type 
memory location may hold elements primitive type int may obtain static type int 
mentioned byte offset jsr instruction regarded element subroutine type corresponding called subroutine 
memory location may hold valid byte offsets jsr instructions call common subroutine starting pp memory location may obtain subroutine type sbr pp static type 
note sbr pp sbr pp pp pp memory location may hold valid invalid byte offsets jsr instructions memory location may obtain static type forms pp cnam init cnam static types memory locations holding raw objects 
concretely memory location may hold objects class cnam created common new instruction program point pp memory location may obtain static type pp cnam 
memory location may hold object currently initialized instance initialization method class cnam encountered instance initialization method current instance initialization method memory location may obtain static type init cnam 
note pp cnam pp cnam pp pp cnam cnam init cnam init cnam cnam cnam memory location may obtain static type unusable 
particular memory location may hold runtime data incompatible types obtain static type unusable indicating content memory location unusable practice 
example local variable may hold object element type int specification enforce local variable obtain static type unusable 
represent intuitive semantics precisely define partial order static types smallest reflexive transitive relation satisfying ref sbr pp pp unusable static types relation read covers 
intuitively covers instruction applicable memory location applicable memory location note relation implies example covers int type ref unusable 
short notations zero static types syntax means identifier left denotes arbitrary static type identifier void explicitly occurs denoted identifier right 
conceptually identifier void static type 
just auxiliary identifier denoting situation static type 
example ref denotes arbitrary class interface name null denotes arbitrary type set primitive type notnull void denotes arbitrary class interface name void denotes arbitrary static type 
program point types program types general guarantee class file asked loaded properly formed 
bytecode verifier ensure class file satisfies constraints 
particular bytecode verifier able statically derive static type local variable operand stack entry program point ensure derived static types satisfy constraints 
purpose define local variable table type list form delta delta delta gamma 
range local variable class name cnam arbitrary class name interface name arbitrary interface name type ref cnam null primitive type prim int void type void type null notnull cnam prim type ty ref prim type set refs type set refs prim subroutine type sbr sbr pp raw object type raw pp cnam init cnam type void notnull void notnull void type set raw object type refs raw refs raw type set raw object type subroutine type refs raw sbr refs raw sbr raw sbr unusable auxiliary symbols denoting zero static types table types 
delta delta delta delta delta delta define holds hold define operand stack type list form delta delta delta gamma 
range operand stack types 
delta delta delta delta delta delta define holds hold definitions local variable operand stack entry hold values arbitrary static types 
record instance initialization method called inside instance initialization method initialization tags unknown 
range initialization tags 
relation defined tags follows unknown define program point type tuple mod mod defined section 
range program point types 
mod mod 
relation holds mod mod hold relation defined section 
intuitively relation ensure instruction applicable program states program point type applicable program states program point type program prg program type mapping fpp 
pp pp prg range program types 
program types 
define holds pp pp holds pp prg 
concepts defined fixed method mth 
type hierarchy type hierarchy jvm java 
formally define subtyping relation smallest reflexive transitive relation type sets refs satisfying cnam cnam cnam extends cnam cnam cnam implements extends object null ref ref ref note consider array types 
relation denote direct subclass relation classes 
constrain types actual formal parameters method invocation define relation type sets primitive type int int int note int int degenerate case widening primitive conversion 
suffices degenerate case consider primitive type int 
constrain types variable value assignment define relation type sets primitive type int requires extends narrowing primitive conversions integer constants 
consider difference simplicity 
intuitively type set contains super subtype subtype redundant 
practically bytecode verifier implement elimination redundant types type set respect subtyping relation optimization step 
constant pool resolution class interface constant pool entries name entities classes interfaces methods fields referenced code class interface respectively constant pool entries 
individual instruction class interface respectively may carry index entry constant pool execution instruction jvm responsible resolving entry determining concrete entity entry 
process resolving entry called constant pool resolution 
formal specification introduce defined functions called resolution functions hide details resolution 
fact resolution processes take correct sorts data argument yield correct sorts data failure result details important formal specification proofs chapter 
explain definitions resolution functions order give feeling resolution functions proper abstractions real resolution processes 
resolution function section takes parameter wide integers ind ind build index offset ind ind constant pool 
sense resolution function constant pool implicit parameter 
resolution function index index yields class name cnam cnam define function cnam notnull notnull name type field class note field class cnam directly defined class superclass class 
field name qualified name need consider problem hiding fields 
define resolution function field ind ind cnam notnull name field cnam class containing field declaration notnull type field 
define resolution function special method ind ind mnam cnam ty notnull void cod mnam name method cnam class containing declaration method ty notnull void descriptor method cod method code length local variable table method 
define resolution function static method ind ind mnam cnam ty notnull void cod define resolution function instance method ind ind mnam cnam ty notnull void function ind ind yield method code 
doing need define function obj mnam ty notnull void cod takes object obj yields method code cod object obj length local variable table method 
define resolution function interface method ind ind mnam ty notnull void name interface class contains declaration method 
furthermore define obj mnam ty notnull void cod convenience define auxiliary function pp mnam cnam ty notnull void mnam method containing pp ty notnull void descriptor method cnam class containing declaration method number local variables method 
constraint domain constraints previous sections fact introduced part constraint domain formal specification 
problems completely formally define concepts constraint domain discuss part informally chapter due space limit 
data data structures local variable table states operand stack states program states static types type structures local variable table types operand stack types program point types types defined previous sections elements constraint domain 
elements sorted 
informally time introduce identifier range kind data data structures static types type structures introduce sort 
introduced identifiers names sorts 
possible sort names 
example sort byt consists byte wide data sort wrd wide data sort pp program points sort lvs local variable gilad bracha clarifying comments semantics method dispatch point 
table states sort stk operand stack states sort stat program states sorts ref refs refs raw corresponding static types respectively defined sort local variable table types sort operand stack types sort program point types 
standard data type structures sets lists data types build sorts necessarily sort name 
subsort relation sorts corresponds subset relation 
particular defines sort occurs alternative right sort left supersort 
example sort ref supersort sorts cnam contains null sort prim contains int sort notnull supersort sorts cnam prim refs contains ref element sort ref singleton type set type ref regarded static type define sort refs supersort sort ref sort countable set variables 
general completely capitalized version sort name denotes variable sort 
example byt variable byt wrd variable wrd notional simplicity introduce variable sort pp sort lvs sort stk sort sort hp lg sort sg sort xi sort stat lt sort st sort sort mod pi sort phi sort denote wildcard variable 
general terms built variables constants functions constraint domain 
terms sorted usual 
sort subsort term supersort 
term sort 
partially capitalized version sort name letter changed capital letter range terms sort 
example pp stat range terms sorts pp stat respectively 
term containing variables called closed 
fact element constraint domain closed term 
logical formulas built order predicate logic predicates take sorted arguments constraint domain 
range logical formulas 
form denote logical formula containing occurrences terms forms occur context rule sort logical formula obtained replacing substitution finite mapping form fxn 
sort term subsort sort delta delta delta consider closed substitutions chapter closed term oe range closed substitutions 
constraint logical formula 
set constraints fq delta delta delta represents logical formula delta delta delta true 
constraint satisfied substitution oe oe closed holds constraint domain 
constraint satisfiable substitution constraint satisfied 
formal specification may define function yields results sort arguments special value failure arguments term sn constraint say term required 
intuitively usage implicitly requires sn yield failure formally may define new sort supersort contains failure constant define result sort replace constraint constraints sn new variable sort reason constraint sn assures equal failure failure sort failure satisfiable 
note functions yielding failure need assume yield different failure sort term failure may exist 
formal specification consists parts 
part defines state transition relation program states stat stat read stat changes stat 
relation defined state transition rules form premises xi xi premises set constraints 
fv premises fv xi xi rule means constraints premises satisfied substitution oe oe xi oe oe xi oe holds 
sequel may say xi changes xi informal discussion simplicity 
specify program types program forms constraints particularly important pp pp says program point type pp says program point type pp covers program point pp reached preceding program point quite convenient write constraint form constrain program point type pp 
type system formal specification introduce constraints program type method mth 
require typing rules contain common program type variable phi 
general typing rule form set logical formulas called applicability conditions contains distinguished constraint mth instr term instr gives form instruction 
intuitively determine program point rule applied 
identifier stands set logical formulas 
contains logical formulas form phi intuitively constrains phi 
identifier stands set logical formulas form phi cases pp stands successor program point 
reason write typing rule form typing rule suggests intuitive data flow analysis step 
roughly speaking data flow analysis arrives program point pp satisfying particular constraint mth pp instr program type pp satisfies program type successor program point pp satisfy corresponding constraint fv gamma phig fv gamma phig typing rule formally introduces constraint easy see constraint holds satisfied substitution oe dom oe phig substitution oe dom oe phig oe jq phig oe oe hold 
constraints mth denote set constraints introduced typing rules 
say method mth program type program type program type method mth constraints constraints mth satisfied phi 

note program may program type 
example local variable method may arbitrary static type program type 
program said statically typed program type 
rules formal specification constraints occur rules 
omit explicit presentation constraints notational simplicity 
typing rule implicitly contains constraint pp mth phi assures pp program point starting address instruction 
specification consider instructions word wide data 
rules assumption data local variables operand stack word wide 
load store instructions state transitions loading storing objects integers type int defined rules 
aload iload instructions load local variable operand stack 
astore istore instructions store value operand stack local variable 
prg aload ind iload ind xi xi ind prg astore ind istore ind xi wrd xi ind 
wrd state transitions load store instructions typing rules load store instructions 
explain rule show tricky points formulation constraints 
refs raw lt ind expresses membership constraint static type lt ind sort refs raw refs raw instantiated element sort refs raw implies aload instruction load initialized uninitialized objects 
addition rule says local variable table type instruction componentwise cover instruction 
hold operand stack type operand stack type extended static type ind th local variable 
similar constraint hold components mod 
precise definitions mod sections 
note variables phi lt terms phi lt ind higher order function variables terms form chapter regarded applications implicit function app order arguments 
similar explanations typing rules 
point worth noticing rule variable refs raw sbr element sort sbr variable refs raw rule 
means required implemented sun implementation astore instruction store valid invalid byte offset aload instruction load 
instruction loads null 
state transition rule typing rule defined 
mth aload ind phi pi lt st refs raw lt ind phi pi lt st refs raw mod mth iload ind phi pi lt st int lt ind phi pi lt st int mod mth astore ind phi pi lt st refs raw sbr phi pi lt ind 
refs raw sbr st mod mth istore ind phi pi lt st int phi pi lt ind 
int st mod typing rules load store instructions prg null xi xi null mth null phi pi st phi pi st null state transitions null state transitions getfield putfield defined 
getfield instruction replaces object top operand stack content field referenced object 
putfield instruction stores content top operand stack field object referenced second top operand stack 
prg getfield ind ind notnull ind ind wrd obj xi obj xi wrd prg putfield ind ind ind ind rec obj 
wrd xi obj wrd xi obj 
rec state transitions getfield putfield typing rules getfield putfield 
sort variable refs pi st refs pi st refs assures obj really object 
constraint refs cnam assures obj dom dom obj holds obj obj 
wrd defined sense 
typing rules ensure condition obj dom holds obj may hold null run time 
obj dom holds obj yields failure premises rules satisfiable 
fact case need state transition rule describe kind runtime exception thrown 
mentioned formal specification consider 
object creation new instruction creates object 
state transition typing rules instruction defined 
condition obj dom rule assures object obj new 
rule says operand stack type instruction covers cnam top indicates operand stack may hold object initialized instance initialization method init uninitialized object 
mentions type gives details specification 
mth getfield ind ind phi pi st refs cnam notnull ind ind refs cnam phi pi st notnull mth putfield ind ind phi pi st refs cnam notnull ind ind refs cnam notnull phi pi st typing rules getfield putfield prg new ind ind cnam ind ind obj dom dom rec cnam xi xi obj obj 
rec mth new ind ind phi pi lt st cnam ind ind cnam lt cnam st phi pi lt st cnam state transition typing rule new typing rule forbids memory location static type form forbids uninitialized object 
constraints cnam lt cnam st assure program point new object created new instruction new object 
strictly weaker say new object created new instruction memory location allowed hold new object created new instruction memory location type unusable 
example see section 
operand stack management instructions give rules dup 
rules instructions similar 
prg dup xi wrd xi wrd wrd mth dup phi pi st phi pi st state transition typing rules dup control transfer instructions prg byt byt obj obj offset byt byt obj obj xi obj obj xi prg byt byt val val offset byt byt val val xi val val xi prg goto byt byt xi xi offset byt byt state transitions control transfer instructions mth byt byt phi pi st refs refs phi offset byt byt pi st phi pi st mth byt byt phi pi st int int phi offset byt byt pi st phi pi st mth goto byt byt phi pi phi offset byt byt pi typing rules control transfer instructions control transfer instructions dealt similar way 
consider control transfer instructions 
state transitions instructions 
quite straightforward 
requires page uninitialized objects may exist operand stack local variable control transfer instruction causes backwards branch 
specification requirement unnecessary rule 
method invocation return instructions state transitions method invocation instructions defined 
consider state transition rule invokespecial 
instruction invoke instance instantiation methods init 
private methods perform method invocations super function 
state transition says execution invoked method starts program state operand stack empty local variables hold object method invoked actual arguments 
notation lvs denote arbitrary local variable table state length state transition invokevirtual invokeinterface similar invokespecial 
difference uses functions respectively compute method code associated obj uses function thing independent obj note bytes byt invokeinterface instruction useless 
contained instruction historical reasons 
invocation method leads execution method code 
typing rule constrains program point type prg invokespecial ind ind notnull void cod ind ind xi obj xi cod lvs 
obj 
prg invokevirtual ind ind mnam notnull void ind ind mnam init 
cod obj mnam notnull void xi obj xi cod lvs 
obj 
prg invokeinterface ind ind byt mnam notnull void ind ind byt gamma cod obj mnam notnull void xi obj xi cod lvs 
obj 
prg invokestatic ind ind notnull void cod ind ind xi xi cod lvs wrd state transitions method invocation instructions mth mnam cnam notnull void mnam init notnull void void cnam object lt uu 
init cnam cnam object lt uu cnam mnam cnam notnull void lt uu 
cnam 
mnam cnam notnull void lt uu 
ty phi lt mod typing rule starting program point method code method code 
rule totally independent method invocation instructions 
rule says method init instance static method 
static types local variables depend kind method general local variable store object method invoked actual parameter type unusable 
means content local variable program explicitly assigns local variable 
means content local variable program explicitly assigns local variable 
uu denote list unusable delta delta delta unusable consisting unusable 
case init 
method local variable stores object initialized 
static type local variable initialization tag depend class cnam containing method code object 
cnam object initialization tag static type local variable init cnam initialization tag means instance initialization method needs called exactly current method code case see rule change initialization tag rule checks initialization tag really 
note cnam object object initialized need initialized init 
current init 
point class cnam chosen containing init 
method 
fact rule assure cnam original class object initialized superclass 
safe cnam place original class rule contains component mod defined section 
cases instance method static method straightforward 
explanation rules necessary 
typing rules method invocation instructions 
method invocation instructions quite different mechanisms require operand stack program point instruction contain correct number arguments certain types 
order express typing rules contains constraints forms delta delta delta void delta delta delta resolution function ind ind phi pi delta delta delta st delta delta delta delta delta delta ty consider rule invokespecial detail 
rule looks quite complicated part rule basically gives cases 
program point type program point invokespecial instruction satisfy cases 
mth invokespecial ind ind mnam cnam notnull void ind ind phi pi lt st refs raw ty mnam init refs raw cnam lt lt cnam refs raw st st cnam refs raw mod refs raw init cnam cnam cnam cnam cnam lt lt cnam refs raw st st cnam refs raw mod notnull void void mnam init refs raw cnam lt lt notnull void notnull st st notnull notnull void void st st phi pi lt st typing rule invokespecial case init 
method invoked object init 
method invoked 
case operand stack entry containing object initialized static type cnam 
rule requires class containing init 
method cnam instruction occurrences cnam changed cnam indicating object initialized 
note rule changes component mod case 
definition mod section 
second case instruction invokes init 
method object initialized enclosing init 
method initialization tag operand stack entry object static type init cnam 
case init cnam introduced rule 
mentioned discussion rule enclosing method class cnam constraint cnam cnam cnam cnam means invoked init 
method class enclosing method immediate superclass 
analogous case instruction changes occurrences init cnam cnam indicating instruction inside enclosing init 
method object initialized regarded having initialized 
addition constraint rule expresses change initialization tag 
rule return tag determine init 
method really invokes init 
method 
constraint notnull void void assures init 
method return type 
note rule changes component mod second case 
definition mod section 
third case concerns invocation usual instance method super 
case constraint refs raw cnam assures class cnam superclass possible classes object method invoked 
addition constraint implicitly implies refs raw refs holds 
method may return type 
operand stack type st instruction st notnull st rules invokevirtual invokeinterface invokestatic 
similar third case rule 
difference resolution functions respectively 
addition rule needs deal number byt byt explicitly occurring invokeinterface instruction 
invokestatic need object method invoked mth invokevirtual ind ind mnam cnam notnull void ind ind phi pi st refs ty ref cnam mnam init notnull void void st st notnull void notnull st st notnull phi pi st mth invokeinterface ind ind byt byt byt byt mnam gamma notnull void ind ind phi pi st refs gamma ty byt gamma ref mnam init notnull void void st st notnull void notnull st st notnull phi pi st mth invokestatic ind ind mnam notnull void ind ind phi pi st ty mnam init notnull void void st st notnull void notnull st st notnull phi pi st typing rules method invocation instructions prg areturn ireturn xi wrd xi wrd prg return xi xi state transitions return instructions state transition rules return instructions 
state transition uses return address stored current java stack 
mth areturn phi pi st refs ref ref ref mth ireturn phi pi st int int mth return mnam void mnam init phi pi typing rules return instructions typing rules return instructions 
rules need additional explanations 
thing worth mentioning return instruction may terminate init 
method 
case rule checks initialization tag assure init 
method invoked init 
method 
note init 
method object tag set method 
note general may exist uninitialized objects operand stack local variables method terminates 
possibility pass uninitialized object invoking method see theorem 
implementing clauses jsr ret instructions control transfer instructions typically implement clauses java 
call program point jsr instruction jumps jsr target code starting jsr target subroutine 
ambiguity possible call jsr target subroutine 
roughly speaking jsr instruction calls subroutine ret instruction returns subroutine 
formally subroutine need ret instruction 
sb range jsr targets subroutines write sb variable 
prg jsr byt byt xi xi offset byt byt prg ret ind cod xi xi cod ind state transitions jsr ret state transitions jsr ret 
rule says jsr instruction pushes byte offset current program point operand stack transfers control jsr target offset byt byt 
rule ret 
uses byte offset local variable compute program point jsr returning program point 
typing jsr ret complex requires features path subroutine needs reach ret instruction 
subroutine implicitly terminates current method terminates 
subroutines may nested subroutine call subroutine 
feature useful implementing nested clauses 
nested subroutines inner subroutine may contain ret instruction directly returns arbitrary outer subroutine 
execution returning program point ret instruction 
furthermore outer program point ret instruction inner subroutine directly returns returning program point subroutine inner outer subroutine able returning program point 
technically mechanism complex takes additional situations account 
implementation clause needs reachable different execution paths 
second different execution paths common local variable hold contents incompatible 
third content stored local variable execution path execution clause may need execution clause 
example situations consider implementation try catch clause 
concretely clause needs reachable try clause catch clause try clause needs store return integer value local variable execution clause catch clause stores exception local variable execution clause 
problem common local variable may hold incompatible contents described second situation usual typing rules formal specification force local variable particular clause type unusable 
local variable individual execution path clause described third situation impossible 
solve problem suggests change usual typing process execution path local variable modified accessed clause type execution clause execution clause 
need mechanism record local variables modified accessed clause 
component mod program point type reserved purpose 
formally define component mod build set grf pairs jsr targets representing directed acyclic graph 
build set csb jsr targets 
component mod mapping dom mod grf csb mod sb sb sb sb grf mod sb sb csb sets indices local variables 
intuitively pair sb sb grf denote call subroutine sb inside subroutine sb grf contain nested non recursive subroutine calls may reach current program point 
set grf need tree subroutine may contain call subroutine subroutine may contain calls subroutine 
set csb contain current subroutines subroutines contain current program point 
set mod sb sb sb sb grf contain indices local variables may modified accessed execution path sb sb mod sb sb csb sb current address 
define notations nod mod sb sb sb dom mod grf mod sb sb sb sb dom mod csb mod sb dom mod define mod mod holds grf mod grf mod csb mod csb mod hold mod sb sb mod sb sb holds sb sb grf mod mod sb mod sb holds sb csb mod 
typing rules jsr ret 
consider rule 
rule defines constraint program point mth jsr byt byt phi pi st sb offset byt byt sb nod phi sb pi st sbr sb sb sb 
sb sb csb 
mth ret ind phi pi lt lt ind sbr ind pi lt mth phi pi lt lt ind lt ind mth ret ind phi lt st mth jsr byt byt sb offset byt byt lt ind sbr sb phi pi lt st phi lt 
lt sb sb st sb sb sb dom 
sb sb sb sb sb dom typing rules ret jsr jsr instruction sb nod assures called subroutine sb called recursively 
subroutine sb new records addition edges sb sb representing calls sb inside old current subroutines csb elimination old current subroutines csb addition new current subroutine sb sb 
denotes local variables modified accessed new current subroutine sb rule ret 
constraint lt ind sbr assures local variable ind holds byte offset 
constraint ind pi lt delta delta delta assures method mth ret instruction subroutine 
serious restriction ret instructions needed write ret place second ret goto instruction ret 
rule introduces constraints program type returning program point ret returns calling jsr subroutine formulation rule uses new auxiliary functions 
auxiliary function computes set indices local variables may modified accessed execution path program point current program point 
component mod program point type subroutine sb nod mod define sb mod sb sb grf mod mod sb sb sb mod sb csb mod mod sb sb csb mod term sb rule set containing indices local variable may modified accessed sb second auxiliary function computes subroutines called call outer subroutine current subroutine 
component mod program point type subroutine sb nod mod define sb mod ae sb sb grf mod sb mod sb csb mod sb csb mod order change subroutine types subroutines set subroutines invalid subroutine types define function ae sbr sb sb note second line arbitrary static type 
convenience lift function operand stack types delta delta delta delta delta delta order compute part mod reachable subroutine set subroutines define function mod mod sb sb 
mod sb sb sb sb dom mod sb mod sb sb dom mod sb rule applicability conditions phi lt delta delta delta mth jsr byt byt sb offset byt byt lt ind sbr sb assure ret causes subroutine sb return program point calling jsr note constraint ind pi lt delta delta delta rule enforces exists jsr rule 
rule expresses relationship program types jsr calls subroutine sb ret returns subroutine sb local variable definitely modified accessed sb static type covers local variable may modified accessed sb static type covers static type subroutine type subroutine possibly called sb static type covers operand stack type covers operand stack entry subroutine type subroutine called sb static type entry covers initialization tag covers subroutines called include called sb local variables possibly modified accessed call current subroutine include call current subroutine sb plus possibly modified accessed sb final tricky point ret instruction rule accesses local variables subroutine type subroutine called typing rule need treat explicitly 
reason indices variables contained set sb rule 
fact local variable holds program point jsr instruction sb program point stored local variable astore instruction sb typing rule astore see discussion definition index local variable included set sb 
instructions modify access local variables time give precise definitions term mod term mod terms mod mod 
consider typing rules 
notations formally define mod 
sb sb csb typing rule introduces program point type starting program point method 
define mod 
consider rule invokespecial 
cases rule consider initialization raw object regard local variables contents raw object modified 
notations formally define mod 
sb fi cnam lt sb csb mod 
sb fi init cnam lt sb csb note third case rule deal initialization raw object cause extension examples section real methods illustrate check method program type 
notational simplicity instructions abbreviated follows instruction opcode byt byt program point pp opcode fif goto pp abbreviated opcode byt byt 
instruction opcode ind ind opcode putfield new invokespecial invokevirtual invokeinterface abbreviated opcode ind ind 
instruction ind byt abbreviated invokeinterface ind ind 
gives type checking method 
row contains program point instruction method program point type program type program point typing rule applied program point possible successor program points respect rule 
method deal subroutines instance initializations consider local variable table type operand stack type program point type 
assume declaration method void contained class furthermore assume interfaces entry index constant pool method takes parameters yields result 
program point static type top entry operand stack needs represented set top entry may second actual parameter interfaces need smallest common 
rule applied program point constraint ref rule assures invoked method exist 
method lt st rule successors method void aload null null aload goto aload invokeinterface fj return method containing interface method invocation second example shows subroutine types 
method contains jsr instructions calling subroutine 
subroutine contains jsr calling inner subroutine subroutine directly returns corresponding calling jsr outer subroutine 
return subroutine types sbr sbr changed local variable different static types calling jsr 
local variable modified accessed subroutine return subroutine static type local variable calling jsr 
method lt st rule successors method void jsr unusable unusable astore unusable aload unusable astore unusable jsr return astore unusable unusable sbr jsr unusable sbr ret unusable sbr sbr method containing subroutines static typedness vs runtime properties requires type correctness nearly runtime uses data checked statically 
formal specification considers subset jvm formally prove program statically typed runtime data definitely correct types 
doing need define precisely types runtime data 
tags runtime data previous sections informally mentioned types runtime data 
examples follows section mentioned new instruction creates object 
informally implies created datum object 
section mentioned jsr instruction pushes byte offset operand stack 
problem object byte offset word wide data constraint domain 
words type datum determined datum 
need additional mechanism explicitly determine type datum 
mechanism built steps define possible types runtime data second extend state transition relation define types contents local variables operand stack 
relatively simple set possible types runtime data called tags defined follows tag cnam null int addr undefined intuitively tag cnam tag object class cnam null special null int element primitive type int 
mentioned need deal byte offset jsr 
introduce tag addr byte offsets 
tag undefined indicates content local variable operand stack entry explicitly defined instruction execution far 
tag range tags 
note set tags relatively simple contain express object raw object offset special subroutine type 
fact problems definition types contents local variables operand stack complicated 
consider simple set due space limits chapter 
record type content local variable operand entry lists tags form tag delta delta delta tag gamma introduced 
define tag delta delta delta tag tag tag delta delta delta tag failure 
list form called local variable state tag consists types contents local variables called operand stack state tag consists types contents operand stack 
readability range local variable state tags operand stack state tags 
notational simplicity write lg variable sort sg sort local variable state tag operand stack state tag record type object held field object directly local variable operand stack entry 
need introduce class record mapping 
cnam class record maps elements obj special value failure range concrete class records variable sort order record local variable state tags operand stack state tags methods stored java stack define java stack tag list consisting entries form 
range java stack tags jg variable sort define program state tag tuple rest chapter range program state tags 
define extended program state pair stat stat pp lvs stk hp size size size lvs size size stk size hold 
extend state transition rules section 
call extended state transition rule extended rule original state transition rule extended rule section 
order ensure extended rule relation affect original state transition relation require original rule section form premises stat stat extended rule obtained form premises stat stat satisfying fv fv program states stat stat extended program state stat substitution oe dom oe fv premises fv stat stat stat oe stat stat oe stat oe premises hold substitution oe dom oe dom oe fv oe hold stat oe extended program state 
notational simplicity omit premises stat stat parts definition extended rule section 
note parts may contain variables occurring stat stat parts 
extended rules java stack tags changed local variable state tags operand stack state tags changed completely analogous way local variable states operand stack states respectively 
extended rules aload new extended rules 
give definitions omit explicit presentation extended rules due space constraints 
jg lg sg jg lg sg lg ind jg lg sg jg obj 
cnam lg sg cnam extended rules aload new contains extended rule getfield 
rule slightly tricky way get tag loaded content depends loaded content object 
object tag obtained class record program state 
value primitive type tag primitive type 
chapter primitive type type int 
model define auxiliary function yields tag content held field type notnull object obj notnull obj hp hp obj notnull cnam int notnull int failure jg lg sg jg lg sg notnull obj extended rule getfield rules method invocations change java stack states 
extended rules change java stack tags 
extensions similar 
situation similar rules 
extended rules 
extended rules ud stands list undefined delta delta delta undefined consisting times undefined 
jg lg sg tag jg lg sg ud 
tag jg lg sg lg sg tag jg lg sg lg sg tag extended rules invokespecial areturn jg lg sg jg lg sg addr jg lg sg jg lg sg extended rules jsr ret contains extended rules jsr ret 
note rule program state tag change 
intuition ret may change validity byte offsets 
consider simple tag addr byte offsets intuition reflected 
mentioned simple tag addr replaced family tags indexed subroutines 
consider 
concepts runtime type safety model correctness tag tag respect static type formally define relation correct correct null refs correct cnam refs cnam refs correct cnam cnam correct cnam init cnam cnam cnam correct int int correct addr sbr correct undefined unusable correct tag correct tag define correct holds size size correct size correct holds size size correct size 
heap hp class record define correct hp holds conditions true 
dom hp dom 

obj 
rec hp notnull obj dom rec 

obj rec hp notnull obj notnull ref rec dom 

obj rec hp notnull obj notnull ref rec notnull 
intuitively condition says determine class object hp 
condition assures object hp contains fields required class 
condition assures object hp contains field type class interface field holds object class determined condition says class object held field condition subtype class interface field 
note notnull ref notnull int conditions effects 
wonder define condition constraining rec 
intuition runtime type datum primitive type runtime type static type 
int obj obj 
rec hp content rec integer type int 
condition useless 
runtime properties assume program prg program type formally define arbitrary execution prg stat stat delta delta delta stat delta delta delta extended program states stat form pp delta delta delta prg pp form invokestatic delta delta delta 
stat stat denote zero step execution stat delta delta delta stat rest chapter assume stat pp lvs stk hp pp pp pp pp pp mod pp 
note imply pp pp give lemmas theorems 
proofs omitted due space limits 
theorem states runtime type safety 
theorem 
execution stat stat delta delta delta correct pp correct pp correct hp hold correct pp correct pp correct hp hold delta delta delta 
proof follows induction length execution extended rules typing rules 
practical consequence theorem follows corollary 
offset manipulated instruction described formal specification 
created stored operand stack jsr 

manipulated operand stack stack manipulation instruction dup 

stored operand stack local variable astore 

local variable compute return address ret 
consider raw objects instance initialization methods 
theorems proved set tags runtime data refined current careful analysis possible executions 
note theorems completely trivial method may pass values heap 
theorem 
assume method invokes method 
invoked method pass raw object back invoking method 
theorem 
assume method invokes method init 
invoking method pass raw object invoked method 
easy show instance initialization method invokes instance initialization method 
theorem 
instance initialization method class object fragment execution path starting address return instruction method includes exactly invocation instance initialization method class immediate superclass object initialized 
instance initialization method class object fragment includes invocations instance initialization method object initialized 
state static type local variable operand stack entry ensures contains raw object 
theorem 
assume stat stat delta delta delta execution stk xt lvs xt stk xt 
xt pp cnam holds pp cnam contains uninitialized object class cnam created new pp 
xt init cnam holds cnam contains object cnam initialized inside init 
initialized init 
lemma shows impossible different local variables operand stack entries program point static type pp cnam pp cnam hold different uninitialized objects 
fact lemma states correctness typing rule invokespecial instance initialization method object local variable operand stack entry static type pp cnam initialized occurrences pc cnam replaced cnam lemma 
assume stat stat delta delta delta execution stk xt yt lvs xt lvs yt conditions hold time indices xt yt pp cnam holds certain pp cnam 
contain different uninitialized objects created new pp 
know memory location class static type holds initialized object null 
theorem 
assume stat stat delta delta delta execution stk xt lvs xt xt cnam holds cnam contains initialized object cnam null 
typing rules instruction specify precisely instruction behaves uninitialized object 
theorem summarizes results theorem 
uninitialized object instruction described formal specification dup aload astore invokespecial 
case invokespecial method init object initialized class init 

inside method init 
declared class object call init 
object initialized invokespecial called init 
declared class immediate superclass calling init 
call object initialized instruction described formal specification dup aload astore 
shown formal specification substantial subset jvm instructions 
formal specification clarifies ambiguities incompleteness removes view unnecessary restrictions description official java virtual machine specification 
worth mentioning study semantics jvm chapter led discovery possibility writing constructor invoked constructor jdk implementation jvm clearly implementation bug respect official java virtual machine specification page 
gilad bracha david von oheimb clarifying comments useful feedback hagiya pointing error description 

aho sethi ullman 
compilers principles techniques tools 
addison wesley publishing 

cohen 
defensive java virtual machine specification 
technical report computational logic 

dean 
security static typing dynamic linking 
proc 
th acm conf 
computer communications security 
acm 

eisenbach 
java type safe probably 
proc 
th european conf 
object oriented programming pages 
springerverlag lncs 

freund mitchell 
type system object initialization java bytecode language 
int 
workshop security languages oct 

freund mitchell 
type system object initialization java bytecode language summary 
electronic notes theoretical computer science 
www elsevier nl locate entcs volume html 

goldberg 
specification java loading bytecode verification 


gosling joy steele 
java tm language specification 
addisonwesley 

hagiya 
new method fot dataflow analysis java virtual machine subroutines 


lindholm yellin 
java tm virtual machine specification 
addisonwesley 

nipkow von oheimb 
java ight type safe definitely 
proc 
st acm symp 
principles programming languages 

qian 
formal specification java tm virtual machine instructions 
technical report fb informatik universitat bremen september 
revised version appear june 

saraswat 
java type safe 
technical report research 

sirer bershad 
java system security architecture 
cs washington edu 

stata abadi 
type system java bytecode subroutines 
proc 
st acm symp 
principles programming languages 

syme 
proving java type soundness 
technical report university cambridge computer laboratory 
