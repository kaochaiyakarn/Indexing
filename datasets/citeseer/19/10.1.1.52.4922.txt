programming pipelined image processor thomas olson personal systems laboratory texas instruments box dallas tx john taylor fore systems pittsburgh pa robert lockwood digital systems design tektronix sw karl braun drive beaverton running head programming pipelined image processor correspondence addressed thomas olson texas instruments box dallas tx phone email olson csc ti com real time computer vision systems dedicated image processing hardware perform pixel oriented operations typical early vision 
type hardware notoriously difficult program limiting types experiments performed posing serious obstacle research progress 
describes pair programming tools developed simplify task building real time early vision systems special purpose hardware 
system allows users describe computations terms coarse grained dataflow graphs constructed interactive graphical tool 
initialization time compiles graphs efficient executable programs underlying hardware 
system implemented popular commercial pipelined image processor 
describe computational model system supports facilities provides building real time vision applications algorithms generate effective execution schedules target machine 
vision systems robots autonomous vehicles meet severe throughput latency requirements place extreme demands current generation computing hardware 
pipelined image processors proven cost effective way meet demands early visual processing popular researchers working real time vision problems 
unfortunately machines powerful sophisticated difficult program 
difficulty writing software machines limits kinds experiments performed serious obstacle progress 
describes software system developed simplify task programming datacube mv pipelined image processor widely research robot vision 
system presents view device capabilities allowing programmer focus computation performed manipulations needed map computation hardware 
model machine system supported architectures 
core programming system veil virginia extensible imaging library library provides dataflow abstraction programming underlying machine 
veil represents computations directed graphs nodes standard image processing operators add subtract convolve arcs represent communications channels 
user programs construct veil graphs procedurally calling functions instantiate nodes link inputs outputs needed 
veil automatically maps nodes arcs graph underlying hardware breaking graph subgraphs computation complex performed step 
user programs control interact running veil graphs various ways making easy synchronize vision tasks robot control computations 
extension mechanisms allow veil support development special purpose routines incorporation new hardware 
programming veil straightforward compile edit debug cycle exploratory programming tedious 
simplify program development written graphical user interface called merlin runs top veil supports rapid prototyping early vision algorithms 
merlin allows users create run modify veil graphs drawing workstation screen 
graphs constructed merlin loaded veil applications controlled manner procedurally constructed graphs 
remainder organized follows section describes context presents design goals veil merlin system 
overview mv architecture section 
sections describe veil merlin user point view 
section describes veil internals particular attention scheduler 
section presents plans 
background primary motivation writing veil support research robot vision 
particularly concerned problems active vision 
goal active vision allow autonomous agents vehicles robots visual information accomplish tasks real world 
active vision characterized emphasis interactions sensing behavior 
visual information gathered incrementally guide real time decisions sensor parameters viewpoint controlled incoming images processed 
active vision applications extreme demands underlying hardware software systems 
typical computations require fast line processing large amounts image data 
latencies kept small allow agent respond quickly changes environment 
image computations tightly interleaved control planning activities environment image processing able support general computations activities 
type image processing performed may change rapidly response shifts agent goals priorities 
extraordinary processing requirements robot vision applications exceed capabilities current generation computers dedicated image processing hardware necessary 
nature research hand demands systems support rapid prototyping exploratory programming dedicated image processing systems notoriously difficult program 
conflict motivated consider ways making programming easier 
previous experience building coarse grained dataflow systems suggested dataflow para provide adequate flexibility programmer map dedicated image processors :10.1.1.52.6357
line research led development veil merlin 
related software environments computer vision image processing development years take variety forms 
generally perform functions encapsulating primitives image processing algorithms tend rely heavily repeated applications small number understood primitive operations convolution pixelwise arithmetic point transforms 
image processing environments provide encapsulated implementations primitives 
may take form subroutine libraries stand executable programs primitive commands textual graphic shell 
interactive composition primitives modern systems allow users invoke sequences primitive operations interactively observe results 
primitives available stand executables operating files pipes hips vista base system 
systems provide invocation menus 
systems allow primitives defined invoked interactive interpreted language lisp tcl 
analysis display systems provide facility examining results image processing computation displaying images monitor 
include sophisticated data analysis plotting tools 
software engineering image processing systems see lawton mcconnell survey expressly designed support construction large complex applications include facilities version control image code database management automatic interface generation 
years coarse grained dataflow emerged paradigm choice interactive construction image processing programs 
paradigm computation expressed directed graph usually constructed graphical user interface 
nodes graph primitive operations provided system named input output ports corre sponding arguments outputs operations 
conceptually source nodes graph generate potentially infinite sequences images 
images flow arcs graph triggering execution primitive function arrive node 
paradigm applied image processing hi visual language applied scientific visualization signal processing simulation data acquisition 
number visual dataflow languages built explore issues user interface design implementation efficiency :10.1.1.52.6357
paradigm known widely distributed system retrofitted older image processing vision systems 
concerns programming systems dedicated image processing hardware differ somewhat general purpose systems described 
processing speed raison tre exotic architectures programming interfaces tend favor efficient machine ease programming 
mirror structure hardware type interface 
programming environment pipe example allows users construct programs manipulating graphical representations machine registers datapath elements 
zebra zed provide similar level access datacube products 
software tools type programming architectures pleasant 
require programmer specify detail computation mapped hardware 
resulting programs closely tied target architecture non portable hard modify 
attempts devise languages programming image processing vision hardware 
text languages apply neighborhood operators adapt split merge computations allow restricted classes image processing operators expressed ada language data parallel extensions 
originally designed support vision applications warp systolic array ported number architectures 
insight text dataflow language programming reconfigurable networks proteus vision machine 
systems designed handle intermediate high level vision computations image processing 
price generality programmers required abandon imperative programming constructs code definitional dataflow language 
researchers described coarse grained dataflow visual programming environments image processing hardware 
system instructed distribute processes local area network 
stewart dyer proposed coarse grain dataflow environment pipe described heuristic algorithms mapping dataflow graphs hardware 
describe similar programming system proposed vision engine 
veil merlin earlier attempt develop visual programming language mv 
owe general appearance interaction style earlier dataflow visual languages avs mavis underlying computational model signal processing systems gabriel :10.1.1.52.6357
veil differs earlier systems primarily support building embedded applications combine image processing higher level vision control computations 
particular provides novel elegant mechanism communication dataflow programs running accelerator conventional programs running host 
veil produces highly efficient code targets type architecture addressed previous 
veil merlin fully implemented daily number sites 
design goals design veil driven desire conduct experimental research active vision real time image processing hardware 
encountered trying existing tools 
experiences led establish requirements design ease 
fundamental requirement system easy learn easy 
particular programmers expertise vision ai able write useful programs day introduced system 
rapid prototyping 
ease system extend development cycle 
developing algorithms workstation porting real time environment users able develop debug applications directly specialpurpose hardware 
efficiency 
ease achieved great sacrifice terms speed 
loss efficiency probably inevitable inherent design system 
application specific optimizations necessary accomplished extending base system abandoning recoding lower level language 
flexibility 
active vision computations take place behavioral context tightly interleaved planning motor control activities 
reason system may place undue restrictions form user programs take 
allow image processing operations embedded arbitrary programs allow program start image processing computations modify parameters time 
extensibility portability 
system extensible levels 
support incremental performance enhancement 
programmers able develop custom image processing routines optimized particular applications freely combination standard primitives provided system 
second system support incorporation new hardware available model general allow porting architectures 
goal adopt veil providing direct support high level vision computations 
immediate reason decision target architecture optimized low level pixel processing provides support image descriptions 
generally felt dataflow paradigm encourages functional programming style suited image processing poorly suited high level vision 
object oriented style provided image understanding environment natural 
accordingly veil programs expected dataflow express pixel oriented operations perform higher level analysis conventional sequential code 
veil provide image processing systems natural flexible way combine dataflow image processing higher level sequential code single program 
hardware veil designed independent underlying hardware design strongly affected capabilities particular device chosen initial target architecture datacube mv 
section describe mv architecture programming model 
datacube real time image processing system widely active vision research 
shows block diagram device 
mv architecture broken main sections programmable switch set smart image memories set deeply pipelined processing elements 
switch heart device responsible considerable flexibility 
allows inputs connected outputs 
connection allows bit data transmitted mhz providing maximum bandwidth mbytes second 
memories capacity megabyte expanded sixteen mb versions device 
memory contains pair address generators allow function dimensional vector register 
address generators transfer rectangular arrays bit pixels raster scan order switch memory rate mhz 
memory read port write port read write port supporting vme access 
ports active simultaneously 
processing elements perform computations raster arrays received switch generated internally 
device complex network multiplexors switches alus cetera 
basic services provided devices device analog digital conversion video signals variety formats 
ag device analog video output overlay 
au device alu operations multiplication weighted sums statistics 
ap device paired convolution lookup tables histogramming 
devices designed operate pixel arrays raster scan order mhz 
programming model mv program counter instruction set execute programs usual sense 
host computer typically unix workstation controls device operation storing values appropriate registers 
order perform computation host configures switches multiplexors processing elements form network performs desired operations data pass 
commands device transmit rectangular arrays pixels data sources device memories network inputs store data appearing network outputs data sinks ag device memories statistics histogramming sections processing elements computations complex performed single pass host repeat process stored results previous computation inputs 
standard programming interface mv vendor supplied software package called imageflow 
imageflow consists sophisticated device driver library functions called user programs written library conceals necessary lowlevel register manipulations programmer allowing describe computation referring processing elements switch ports name 
typical imageflow program begins constructing processing networks called pipes imageflow terminology 
calling imageflow functions declare pixel arrays memory establish connections appropriate pixel arrays switch ports processing elements set processing attributes convolution kernels filter parameters desired 
imageflow automatically configures mv memory address generators timing raster arrays reflects desired geometric relationship 
example images added imageflow ensures corresponding pixels arrive alu time 
pipes constructed application program number options controlling execution 
request fired executed continuously 
firing non blocking application fire pipe perform perform blocking wait event associated pipe 
series pipes packaged pipe altering thread pat uploaded mv device driver execute pipes sequence rapidly possible repeatedly 
feature allows user programs perform tasks mv works complex multi pipe computation 
programming problem imageflow library insulates programmer hardware provides powerful flexible way controlling mv computations 
programming mv imageflow remains painful relatively simple computations 
obvious problem simply device extremely complex 
example au device hardware manual identifies distinct functional elements provides pages block diagrams showing interconnections 
result trivial programs require dozens function calls 
second subtler source difficulties programming mv arises fact imageflow programs describe computations referring explicitly physical resources memories computational elements required produce 
programmers simply state image streams added specify alus memory images stored path images take reach alu 
programmer responsible ensuring operand resides distinct memory bank right lookup tables convolution kernels cetera loaded right places datapath computational element twice pipe 
result explicit problem code reuse extremely difficult 
imageflow program contains dozens hard coded assumptions data laid memory flow device 
imageflow programs invariably incompatible memory maps conflicting demands computational resources 
net result modifying existing imageflow application merging difficult rewriting scratch 
veil veil programming library real time image processing datacube mv 
provides class definitions allow programmers describe image processing computations terms coarse grained dataflow graphs 
translates graphs appropriate imageflow structures program initialization 
computational model supports form homogeneous synchronous data flow 
paradigm node dataflow graph produces exactly token arc invocation 
veil adds restriction data sources synchronous fire simultaneously 
restriction flow tokens graph depends topology graph 
implies valid execution schedule computed statically minimizing run time overhead 
pure paradigm allow structure execution order graph change graph created 
order provide greater flexibility veil allows applications create multiple graphs start modify execution 
escape mechanism provides flexibility needed active vision applications 
particular allows user code implement conditional iterative control structures application requires 
veil addresses programming problems identified previous section 
handles complexity problem abstracting functionality mv presenting set reusable image processing primitives 
addresses problem explicit concealing physical resources mv programmer providing unbounded number virtual resources 
fact physical prevent program building graph convolution nodes veil scheduler simply detects conflict schedules convolutions sequentially allocating memory buffers needed store intermediate results 
allows veil programmer describe computation terms data streams transformations terms physical device doing point time 
programming veil fundamental activity veil supports construction execution dataflow graphs 
provides programmer new object classes data types graphs operators 
graphs correspond single computations consisting set operators graph nodes corresponding image processing primitives 
operator number input output ports connected links form graph 
operators attributes specify details computation 
attributes common operators 
example input port operator attribute specifies size relative position pixel array port processes 
attributes specific individual operator types 
include things masks convolution morphological operations contents lookup tables output scaling arithmetic operations 
programs veil creating graph object number operators 
operators inserted graph attributes set inputs outputs connected complete graph 
program may proceed create graphs perform initialization requires 
program invokes veil scheduler verifies topological correctness builds execution schedule graph 
scheduler arranges graphs share physical resources memory buffers lookup table banks convolution kernels possible 
application executes graph invoking veil execution control methods 
presents example simple mv computation expressed veil imageflow 
upper left graphical representation computation programmer think program design 
computation graph consists camera mv converter configured capture rs video data connected threshold operator turn connected monitor display vga monitor 
veil declarations code needed build execute graph procedurally shown lower left 
right hand optimized program performs computation raw imageflow 
difference apparent complexity imageflow veil programs obvious 
obvious equally important difference imageflow program commits particular strategy performing computation incoming image sent converter directly lookup table thresholding buffered memory bank zero 
veil program commitment modified extended fear introducing conflicts resource switch usage 
veil program pay price greater flexibility 
programs achieve maximum possible throughput frames second veil program buffers camera output memory introducing additional latency half video frame time 
veil provides number ways applications programs control execution dataflow graphs 
cycle method example instructs imageflow device driver iteration graph immediately completion previous iteration 
graphs input comes video cameras iteration graph deferred start full video frame 
cycle non blocking 
run method causes graph execute halt blocking host application graph computation completes 
non blocking version run provided application parallel mv computation desired synchronize graph blocking wait call 
application halt graph time replace graph computation better suited current sensing situation 
veil applications modify computation performed graph opposed halting starting graph changing attributes graph operators 
example calling graph cycle veil program change threshold running graph calling threshold value 
similar calls allow modification convolution kernels constant multipliers computational parameters 
unfortunately imageflow allow fly changes attributes affect mv internal pipeline delays 
possible example change size position pixel array sent operator halting graph rescheduling 
programs multiple graphs may need data produced graph input graph 
veil supports pair operators called source sink 
operators correspond pixel arrays mv memories source operator injects pixels graph input sink operator stores data receives mv memory 
scheduler instructed treat sink source pair aliases physical memory buffer 
result pixels sent sink operator graph fed graph source operator graph executed 
veil provides mechanisms transferring information image processing graphs host application 
number operators specifically designed gather information host output ports 
operators provide methods allow host retrieve current contents buffers 
example histogram statistics ssd sum squared difference operators accumulate information grey levels images summing image array allow host read vector containing results 
import operator receives array pixels graph allows host read specified subarray user memory 
export operator serves companion import operator allowing host copy pixels user memory mv memory buffer serves source graph 
operator useful example injecting test images graph development 
data transfer methods operators may called time 
called graph running cycling block execution cycle order reduce risk read write conflicts 
veil information gathering operators described requires programmer keep track graph state explicitly 
order support event driven style programming veil allows callback functions associated operators 
callback added operator veil scheduler instructs imageflow device driver generate event completion imageflow pipe terminates operator 
program calls graph update graph cycling veil wait events order scheduled call appropriate callback event arrives 
merlin merlin graphical user interface allows users build execute veil graphs interactively 
written standard veil library interface suit user interface toolkit 
functionality provides similar dataflow environments discussed section 
user creates graph selecting veil operators bank menus placing workspace connecting inputs outputs mouse 
graph built executing pressing cycle button invokes veil scheduler cycles graph 
merlin supports graph editing standard direct manipulation techniques operators links repositioned created destroyed mouse 
selecting operator mouse causes operator attributes displayed scrollable palette appropriately typed widgets 
user widgets change value attribute time 
possible merlin requested changes immediately 
mentioned section attribute changes require graph halted rescheduled 
rescheduling may take seconds attribute changes type deferred user halts graph explicitly requests rescheduling 
visual cues provided inform user deferred attribute changes pending 
merlin veil allow users save graphs files load 
allows graphs developed interactive merlin environment loaded embedded non interactive veil applications 
application gain access operators looking name table 
names consist ascii strings appear merlin icon representing operator instance 
constructing graph procedurally application loading file calling graph find obtain handle threshold operator 
experience shown users prefer build applications way allows change image processing program recompiling 
typically keep merlin window open time turning interactive execution test applications turning back modify save graph 
sample merlin screen shown 
graph displayed area performs set image processing operations horswill brooks experiment reactive robot control 
nodes top graph digitize camera input subsample factor dimension producing image 
graph splits separate streams 
right hand stream approximates temporal derivative backward differencing 
left hand stream performs logarithmic scaling look table estimates gradient sobel operator computes sum absolute values gradient components approximation gradient magnitude 
result passed threshold altered interactively dial widget left 
time derivative thresholded gradient magnitude sent host display pair windows 
status line lower left reports veil scheduler broke computation sequentially executed subgraphs pipes achieved data rate frames second 
data rate limited input video frame rate particular graph mv idle time 
veil internals internal architecture veil divided logical components 
graph manager consists data structures functions allow user programs construct graphs set attributes 
operator set set available image processing primitives 
scheduler responsible mapping computation described veil graph hardware building execution schedule 
executive communicates imageflow device driver allows user programs control computation desired 
graph manager role graph manager relatively simple defines basic graph class provides methods needed create modify computation graphs 
basic operations supports creating destroying graph inserting deleting operator creating destroying link operators 
graph manager serves repository information graph object scheduled running physical resources uses 
serves launch point executive 
graph smallest executable object veil execution control commands naturally expressed methods graph class 
operator set design operator set critical operation components system 
various operator types organized class hierarchy ultimately subclasses generic class operator 
operator instance provides information port descriptors 
input output port descriptor identifies links attached port input ports size alignment incoming pixel array 
information normally set application programmer 
descriptor specifies name physical switch port mv port produces accepts data 
information derived class definition accessible scheduler 
attribute descriptors 
attribute descriptor specifies name ascii string type current value 
resource list 
operator class contains list physical mv resources uses 
include switch ports mentioned port descriptors plus multiplexors computational elements requires order perform function 
scheduler uses list determine set operators run parallel 
build method 
operator defines procedure called build method 
invoked build method constructs partial imageflow pipe begins ends physical switch ports identified port descriptors 
pipe passes computational elements listed resource list 
build method reads current values attributes configures computational elements transform data passing appropriately 
graph manager scheduler executive manipulate veil operators superclass level information methods described 
dynamic inheritance allows jobs hard coded knowledge individual operator classes 
relatively straightforward programmers familiar basic imageflow programming add new operator types veil 
simply declare new subclass class operator supply appropriate descriptors methods 
process painless easier writing complete imageflow pipe 
done new operator automatically inherits schedulability operator class modification veil application 
scheduler job veil scheduler compile data structure describing veil graph form executive imageflow device driver perform computation 
section informal examples scheduling problem define problem formally describe veil scheduling algorithm 
discuss scheduler performance limitations 
simple cases scheduler may able embed input veil graph directly mv hardware 
shows example situation 
graph left takes array pixels supplied host export operator mask returns absolute value result host import operator 
convolve abs absolute value operators disjoint resource lists run part computational pipeline shown right 
note buffering computational operators presence second operator essentially impact running time graph execution time number pixels rectangle divided pipeline data rate mhz 
order build imageflow pipe computation scheduler calls build methods operators 
build methods convolve abs opera tors construct partial pipes described 
build methods import export operators invoke resource allocator reserve space memory pixels update switch port addresses contained port descriptors 
scheduler connections switch ports identified port descriptors completing pipe 
complex cases may possible schedule entire veil computation single imageflow pipe 
example graph may contain operators resource needs conflict may require connections switch support 
veil scheduler handles difficult cases partitioning graph set subgraphs small run single pipe 
outgoing data flow arcs cross partition boundary connected temporary buffers mv memory 
buffers inputs subgraphs input arcs cross partition boundary 
subgraphs executed sequentially inside imageflow pat manner order execution operators topological sort input graph 
guarantees memory buffers change result computation 
graph illustrates problems posed complex graphs 
lut threshold operators execute simultaneously require exclusive access mv single input look table shrink delay operators handled specially contain internal memory buffers 
shrink operator subsamples image constant factor implemented commanding vector address generator memory write port omit rows columns sent 
shrink operation performed course storing image memory 
delay operator uses memory buffer store pixels received current iteration releases graph iteration 
operator uses veil callback mechanism transfer pixels mv host display workstation screen 
shows veil scheduler partition graph 
partition simply copies camera buffer memory buffer associated shrink operator 
done shrink operator terminate pipe node ready execute 
second partition subtracts result shrink operation current contents delay buffer sends output buffer 
time sends current contents shrink buffer lookup table lut derivative operator dxdy input lookup table lut 
point scheduler closes pipe deposits lut result temporary buffer temp 
add threshold operator current pipe resource needs conflict lut copy shrink buffer delay buffer 
third partition contents temp sent buffer threshold operator shrink buffer copied delay buffer 
mhz partition works arrays takes half video frame time 
remaining partitions arrays take frame time 
entire schedule runs hz limited video frame rate 
scheduling problem scheduling problem formalized follows directed acyclic graph vertices taken set representing available operators 
compatibility relation pair vertices compatible resource lists corresponding veil operators disjoint 
vertex associated integer cost specifies number pixels largest rectangle flowing node 
graph scheduled system memory banks switch support simultaneous connections 
mv values respectively 
valid schedule graph partition graph sequence disjoint subgraphs satisfying constraints ancestors vertices subgraphs guarantees operator execute input data available 
vertices subgraph mutually compatible 
ensures resource conflicts vertices subgraph operators partition execute simultaneously part imageflow pipe 
subgraph contains arcs including arcs cross partition boundary 
guarantees switch bandwidth route data computational elements memory buffers implement subgraph computation 
arc crosses partition boundary assigned integer range input output arcs single subgraph assigned integer 
restriction captures constraint mv memory bank read port write port support read write pipe 
subgraphs schedule executed sequentially execution time entire schedule sum execution times subgraph 
pipeline delay setup time negligible images reasonable size execution time subgraph approximated time required send largest pixel array subgraph switch 
optimal time schedule veil graph obeys constraints minimizes cost function problem finding optimal time schedules veil graphs np complete multiprocessor scheduling problems 
simply finding partition compatible subgraphs equivalent coloring complement graph defined compatibility relation 
assigning integers arcs cross partition boundaries involves graph coloring problem 
substantial body literature approximation algorithms problems type original intent adapt algorithms veil scheduling problem 
experiments see shown naive heuristic algorithm produces reasonably schedules sort problems arise 
resort sophisticated strategies 
scheduling algorithm current veil scheduler constructs execution schedule traversing graph topologically sorted order starting sources 
stage attempts pack remaining nodes possible current pipe subject resource topology constraints 
nodes added current pipe connects outputs pipe temporary memory buffers creates new empty pipe 
nodes scheduled temporary buffers bound physical memory locations register coloring algorithm partitions generate pat 
algorithm expressed concisely follows max mark sources ready repeat create new empty current partition exists ready operator compatible operators current partition add current partition check operators outputs mark ready appropriate output arcs current partition connect arcs temporary memory buffers 
operators scheduled algorithm simple fast ignores great deal potentially useful information 
particular adds operators current partition order encounters 
cases better schedules produced algorithm considered alternate orders heuristic criteria decide operator add 
scheduler performance evaluated veil scheduler comparing output experimental branchand bound scheduler produces provably optimal schedules 
collected set thirteen veil graphs developed support various projects lab ranging size operators 
space permit detailed description graphs shows typical example graph uses phase differencing estimate horizontal component motion field 
veil scheduler adds nodes current pipe order encounters 
output depends order nodes created graph construction 
order take account tested scheduler instances test graph randomly permuting order node creation time 
instance recorded estimated running time resulting schedule 
number possible node orderings large number topologically distinct schedules scheduler find invariably small usually identical running times 
sequence running times observed trials contains small number distinct values 
dividing number occurrences value gives relative frequency value estimate probability observing value random trial 
entries double line table summarize results experiment thirteen test graphs 
heuristic scheduler table gives sample distribution trials expressed relative frequency running time observed trials 
table reports sample mean running time heuristic schedules running time optimal schedule percentage sample mean running time exceeds optimal running time 
test graphs heuristic schedules degenerate sample distributions running times trials identical equal running time optimal schedule 
remaining graphs heuristic running times optimal average 
execution times heuristic scheduler second cases compared minutes hours branchand bound scheduler 
somewhat surprising current scheduler works test graphs 
constraint compatibility relation theoretically possible construct graphs running time heuristic schedule exceeds optimal schedule arbitrary amount 
shows construction graph 
practice finite bandwidth mv puts upper bound degree parallelism optimal schedule exhibit 
worst graph able produce construction shown heuristic scheduler worst case running time exceeds optimal schedule 
entry table summarizes results trials graph 
fortunately conditions produce behavior arise rarely practice 
speculate relatively performance current veil scheduler due fact topological resource constraints mv place tight limits space valid schedules 
graph induced compatibility relation fairly sparse limiting opportunity parallel execution 
fact nodes shrink force termination current pipe limits parallelism 
architecture similar mv offering switch bandwidth potential parallelism probably increase benefit obtained intelligent scheduler 
improved scheduling heuristics investigated part current veil 
scheduler limitations current veil scheduler finds reasonably schedules graphs test set 
constrained solve problem formalized break input graph series partitions executed sequence 
modifying definition valid schedule result better performance cases 
approach relax requirement graph partitions executed strict sequence 
example possible execute series pipes operate small images parallel single pipe operates larger images 
option optimize schedule repeated execution software pipelining done gabriel scheduler 
software pipelined schedule multiple iterations loop executed parallel 
example instance nth invocation partition executed parallel minus st invocation third partition 
computation performed graph unchanged latency iteration period reduced 
note software pipelining requires prologue epilog code handle initial final iterations general case increase latency 
done formal experiments determine gained redefining scheduling problem allow parallel pipes wrapped execution order 
hand inspection graphs showed allowing parallel pipes reduce running time disparity filter graph affect graphs 
permitting wrapped execution order saves cases pipe schedule executed parallel 
permitting parallel pipes wrapped execution significantly useful yielding savings thirteen test graphs 
caution numbers verified implementing schedules question reliable simulation results table 
believe qualitatively correct 
implication modifying scheduling paradigm cut running time schedules nearly half produce modest improvements cases 
ultimate test veil scheduler compare schedules hand coded imageflow 
computational elements mv deeply pipelined contain complex internal datapaths allow data routed elements going switch 
veil exploit possibility operators defined accept input produce output switch ports 
imageflow programmers restriction able improve veil scheduler cases 
unfortunately reimplementing entire test set imageflow take months full time effort practical 
hand coded implementations gaussian laplacian pyramid computations carefully inspected graphs identify opportunities optimization 
graphs including pyramid computations unable improvement available permitting parallel pipes wrapped schedules 
graphs including phase graph appears possible reduce running times 
savings obtained embedding sum product subgraphs internal datapaths au device 
speedup obtained veil creating special purpose operator implements appropriate algebraic operation 
executive job veil executive allow programs control communicate graph computations 
implemented series methods graph class 
control operations running halting graph computation map directly calls imageflow device driver 
communications synchronization methods imageflow event mechanism provides semaphore variables set cleared waited application running pat 
user defined callbacks handled storing pointer callback function operator object instructing imageflow device driver issue event completion pipe containing operator 
application invokes blocking execution command asynchronous update command executive waits pipe events order issue calls appropriate callbacks pipe 
operations set run time modifiable attributes retrieve data mv executed immediately graph halted 
graph currently executing deferred occurrence appropriate event 
executive limitations current version veil halt mv data transfers execution user callback functions 
running time graph deterministic advantage real time vision applications 
possible applications communicate running graph receive corrupt inconsistent data attribute changes take effect middle computation iterations 
may occur host unix scheduler fails run user process timely fashion user code fails complete task quickly 
possible prefer build robust applications tolerate errors kind 
non robust applications blocking run execution command enforce mutual exclusion 
run command allows programs synchronize reliably graph boundaries 
cases inadequate 
consider program contains statistics operators 
single statistics unit mv operator execute separate pipe 
order obtain valid data operator application read data operator runs hardware statistics buffer cleared preparation executing second operator 
level service guaranteed user process unix 
solution problem put statistics operator separate graph run repeatedly awkward unintuitive 
currently testing experimental version executive uses events guarantee exclusive access data gathering operators type 
veil merlin provide powerful environment developing real time vision systems 
veil coarse grained dataflow model allows programmer concentrate image processing task hand details resource management scheduling synchronization 
provides extensive facilities interaction synchronization image processor programs running host making easy embed veil computations robot autonomous vehicle control programs 
veil scheduler produces efficient execution schedules compare hand coded imageflow 
merlin interface allows veil graphs constructed modified interactively supporting exploratory programming 
veil number limitations correctable fundamental consequences design 
observed previous section scheduler ignores potentially useful information considers restricted class schedules 
underlying computational model problem computations expressed graphs implemented escaping code mechanism awkward programs difficult maintain 
far serious problem encounter veil stems fact veil applications run user processes unix 
places mercy unix scheduler impossible write programs rely meeting hard real time constraints 
secondary design criteria veil potential ported image processing architectures 
portions veil directly visible applications programs including merlin largely device independent modified architecture fairly easily 
code implements individual veil operators hand intimately tied mv architecture 
fortunately machine dependencies localized rewritten new architecture little effect rest system 
portable parts system scheduler executive need completely redesigned order different architecture 
surprising operations provided veil executive turned inappropriate architectures particularly cpus rely host general purpose computation 
current veil directed improving usability particularly users outside laboratory 
veil mv successor mv 
configurations containing multiple mv boards requires user specify board operator execute 
merlin rewritten tcl tk order increase speed easier remote users compile 
continue scheduler add new operator types need arises 
currently veil daily basis support robotics distributed remote sites 
believe met goals established began project 
new users productive hours experienced users feel little motivation bypass 
largely removed development time consideration deciding implement new algorithm mv conventional workstation 
decision tends driven intrinsic strengths weaknesses machine orientation pixel processing lack floating point arithmetic 
current versions veil merlin available anonymous ftp ftp cs virginia edu directory pub veil world wide web www cs virginia edu vision 
hope veil vision research community help establish higher standard software tools generation high speed image processors 
acknowledgments authors acknowledge contributions past members uva computer vision group particularly worthy martin frank brill shawn scott glenn wasson jennifer wong 
grateful veil users world providing valuable feedback bug fixes technical support engineers datacube helping understand imageflow 
imageflow mv trademarks datacube supported part defense advanced research projects agency number part national science foundation number cda 

ackerman data flow languages ieee computer february pp 


aho sethi ullman compilers principles techniques tools addisonwesley reading 

aloimonos weiss bandyopadhyay active vision proceedings st international conference computer vision london pp 


artificial intelligence programmers manual artificial intelligence amherst massachusetts 

gross kung lam webb warp computer architecture implementation performance ieee trans 
computers december pp 


babb ii parallel processing large grain data flow techniques ieee computer july pp 


bacon graham sharp compiler transformations high performance computing acm computing surveys december pp 


bajcsy active perception proceedings ieee pp 


ballard frames animate vision eleventh international joint conference artificial intelligence detroit august pp 


new approach effective environment proc 
th iapr int conf 
pattern recognition jerusalem october pp 


tanimoto system research pyramid machine algorithms proc 
second international workshop visual languages dallas june pp 


buck ha lee messerschmitt ptolemy framework simulating prototyping heterogeneous systems int 
journal computer simulation press 

burt adelson laplacian pyramid compact image code ieee transactions communications pp 


burt bergen hingorani lee leung object tracking moving camera proc 
ieee workshop visual motion irvine march pp 


coombs horswill von disparity filtering proximity detection segmentation proc 
spie intelligent robots computer vision xi algorithms techniques active vision boston nov pp 


datacube graphical programming tool high performance imaging datacube ma 

datacube hardware manual datacube massachusetts 

datacube imageflow manual datacube massachusetts 

garey johnson computers intractability guide theory npcompleteness freeman new york 

webb 
wu low level vision warp apply programming model parallel computation computers artificial intelligence janusz ed pp 
kluwer academic publishers boston 

haralick 
yao shapiro phillips 
hwang harrington 
chen liu chen 
proteus control management system proc 
camp workshop computer architectures machine perception new orleans december pp 


hirakawa iwata tanaka ichikawa hi visual iconic programming proceedings ieee computer society workshop visual languages linkoping sweden 

ian horswill rodney brooks situated vision dynamic world chasing objects proc 
aaai st paul pp 


wang labview computer february pp 


practical multiprocessor scheduling algorithms efficient parallel processing ieee transactions computers nov pp 


kent pipe pipelined image processing engine journal parallel distributed computing pp 

kohl mundy development image understanding environment proc 
ieee comp 
soc 
conf 
computer vision pattern recognition seattle pp 


landy cohen hips unix image processing system computer vision graphics image processing march pp 


lawton mcconnell image understanding environments proceedings ieee august pp 


lee 
ho bier bhattacharyya gabriel design environment dsp ieee trans 
acoustics speech signal processing nov 

lee messerschmitt static scheduling synchronous data flow programs digital signal processing ieee transactions computers january pp 


lee messerschmitt synchronous data flow proceedings ieee september pp 


lockwood heuristic scheduling veil ms thesis department computer science university virginia charlottesville may 

olson klop mavis visual environment active computer vision proc 
ieee workshop visual languages vl seattle september pp 


ousterhout tcl tk toolkit addison wesley publishing reading massachusetts 

pausch young iii deline suit pascal user interface toolkits proceedings uist annual acm siggraph symposium user interface software technology november 

pope lowe vista software environment computer vision research proc 
ieee comp 
soc 
conf 
computer vision pattern recognition seattle pp 


williams integrated data flow visual language software development environment journal visual languages computing pp 


sarkar partitioning scheduling parallel programs multiprocessors 
mit press cambridge 

shapiro haralick insight dataflow language programming vision algorithms reconfigurable computational network int 
pattern recognition artificial intelligence pp 


lee compile time scheduling heuristic interconnection constrained heterogeneous processor architectures ieee trans 
parallel distributed systems pp 


silicon graphics computer systems iris explorer user guide document silicon graphics computer systems mountain view california 

stewart dyer heuristic scheduling algorithms pipe proc 
ieee workshop comp 
arch 
pattern analysis machine intelligence october 

swain stricker editors 
promising directions active vision written attendees nsf active vision workshop august 
university chicago technical report cs november 

taylor lockwood olson visual programming system pipelined image processors spie machine vision applications architectures systems integration boston nov pp 


tanimoto visual language image processing journal visual languages computing pp 


tilley zebra application object oriented microprogramming register level devices university rochester department computer science tech 
rep 

upson schlegel van dam application visualization system computational environment scientific visualization ieee computer graphics applications july pp 


webb steps architecture independent image processing 
ieee computer february pp 


wolberg interactive image processing software package technical report cucs columbia university department computer science 

yang dsc scheduling parallel tasks unbounded number processors ieee transactions parallel distributed systems sept pp 


hl program configure heterogeneous multiprocessor proc 
workshop comp 
arch 
machine perception paris december pp 

ag switch image alus vme host memories address generators block diagram mv 
principal components switch memories processing devices ag ap au 
luts multipliers ap device feature extraction statistics au device main graph graph camera camera threshold threshold monitor monitor veil init build graph graph insert camera graph insert monitor graph insert threshold connect inputs outputs graph connect camera threshold graph connect threshold monitor schedule executing graph graph schedule graph cycle void main int argc char argv int oaa oas oaa aa oas ag acquisition pipe camera mem lut create src dest surfaces gates oas adc oaa aa mem aa rcv connect source gate dest lut oaa dq csr aa op oaa aa lut aa op set digitizer attributes oas gain oas lpf lowpass dq dt unsigned oas dtm dq dtt signed set lut attributes oaa aa lut oaa aa lut xff create continuous pipe memory dq trg continuous dq dsm pipe display pipe memory vga monitor create surfaces gates ag dac vga vga ag rcv aa disp connect src dest ag section oaa aa disp aa dm oaa aa dm aa cgr ag red ag dac lut src miscellaneous display pipe attributes oaa aa disp ag dac lut dq create pipes dq trg continuous dq dsm pipe formulations mv computation takes pixel data camera thresholds sends monitor display 
upper left conceptual representation equivalent veil code 
right hand optimized implementation imageflow 
camera threshold import typical merlin screen 
illustrated graph subsamples image computes temporal derivative filtered thresholded gradient magnitude described 
simple veil graph 
graph mapped single pipelined computation mv 
ag switch vme host memories ap au export convolve abs import import export convolve abs delay threshold shrink temp partition camera shrink partition delay shrink lut lut temp dxdy subtract partition veil schedule graph 
shaded operators implemented mv memory buffers 
computation broken subgraphs executes single imageflow pipe 
delay subtract add atan monitor camera shrink convolve delay convolve multiply multiply multiply multiply phase horizontal motion estimator veil test set 
extract sine phase cosine phase components image point 
ratio appropriate sums products components current previous images proportional horizontal rate change phase see burt 
class graph veil heuristic scheduler produce arbitrarily bad schedules 
suppose nodes graph left incompatible label 
clearly optimal schedule contains exactly partitions shown center 
veil scheduler examines ready nodes left right order produce schedule shown right number partitions running time proportional number nodes graph 
graph name number nodes heuristic schedule distribution optimal schedule difference mean optimal running times cent optimal time frequency running time mean running time running time tracker derivatives horswill temporal filter tracker change detect gaussian phase motion laplacian disparity filter phase motion filter ad hoc scheduler breaker table scheduler test results running times milliseconds 
entries double line test set 
final entry graph designed specifically provoke worst case behavior 
