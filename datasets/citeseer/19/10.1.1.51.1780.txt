generic programming david musser rensselaer polytechnic institute computer science department amos eaton hall troy new york alexander stepanov hewlett packard laboratories software technology laboratory post office box palo alto california generic programming centers idea abstracting concrete efficient algorithms obtain generic algorithms combined different data representations produce wide variety useful software 
example class generic sorting algorithms defined finite sequences instantiated different ways produce algorithms working arrays linked lists 
kinds abstraction data algorithmic structural representational discussed examples building ada library software components 
main topic discussed generic algorithms approach formal specification verification illustration terms partitioning algorithm quicksort algorithm 
argued generically programmed software component libraries offer important advantages achieving software productivity reliability 
international joint conference issac rome italy july 
issac stands international symposium symbolic algebraic computation applied algebra algebraic algorithms error correcting codes 
published lecture notes computer science springer verlag pp 

author sponsored part subcontract computational logic sponsored turn defense advanced research projects agency arpa order 
views contained document authors interpreted representing official policies expressed implied defense advanced research projects agency government computational logic ii contents contents classification abstractions data abstractions algorithmic abstractions structural abstractions representational abstractions algorithmic abstractions generic partition algorithm algorithm specification verification basic specification partition obtaining sequence satisfying test correctness swap assignment operation correctness body partition generic programming mean definition algorithms data structures generic level accomplishing related programming tasks simultaneously 
central notion generic algorithms parameterized procedural schemata completely independent underlying data representation derived concrete efficient algorithms 
purpose convey key ideas generic programming focusing mainly establishing methodological framework includes appropriate notions algorithm data abstractions means formally specify verify abstractions 
issues relating generic algorithms mainly terms single example partition algorithm quicksort large collection examples developed ada part ada generic library project 
structure library designed achieve higher degree modularity previous libraries completely separating data representations algorithmic data abstraction issues 
goals common parameterized programming approach advocated goguen fundamental difference goguen mainly addresses manipulate theories primary interest building useful theories manipulate 
notion generic algorithms new unaware similar attempt structure software library founded idea 
ada library developed booch example limited generic algorithms 
booch developed interesting taxonomy data structures populated different data types implementations data types part built directly ada data structure facilities data abstractions library little layering implementations 
generic algorithms layering described list tree structure algorithms afterthought chapter utilities 
fact development abstraction facilities past decade focused data abstraction 
algorithmic abstraction received little attention object oriented programming 
procedural abstraction language algorithm oriented attempting find elegant concise linguistic primitives goal find representations efficient algorithms 
example algorithmic abstraction consider task choosing implementing sorting algorithm linked list data structures 
merge sort algorithm classification abstractions properly implemented provides efficient sorting algorithms linked lists 
ordinarily program algorithm directly terms pointer record field access operations provided programming language 
away concrete representation express algorithm terms smallest possible number generic operations 
case essentially need just operations set accessing cell list detecting list test binary predicate data cells 
particular representation linked lists obtains corresponding version merge sorting algorithm instantiating generic access operations subprograms access representation 
believe better possible give programming examples real language pseudo language frequently done 
argue ada perfect expressing programming abstractions useful adequate cases supports goal efficiency compile time expansion generics provision directing subprograms compiled inline 
numerous examples generic programming techniques scheme language brief discussion relative merits ada scheme type programming see 
classification abstractions discuss classes abstractions useful generic programming shown table lists examples packages ada generic library 
ada packages written provide generic algorithms generic data structures fall corresponding abstraction class 
data abstractions data abstractions data types sets operations defined usual definition abstractions mainly understood formally specified techniques algebraic axioms independently actual implementation 
ada data abstractions written packages define new type procedures functions type 
degree abstractness achieved generic package type elements stored generic formal parameter 
library program data abstractions directly necessary create fundamental data representations define implemented algorithmic abstractions data abstractions system allocated singly linked data types operations user allocated singly linked defined representational algorithmic abstractions sequence algorithms families data abstractions linked list algorithms common algorithms vector algorithms structural abstractions singly linked lists intersections doubly linked lists algorithmic abstractions vectors representational abstractions double ended lists mappings structural stacks abstraction output restricted deques table classification abstractions example ada packages terms ada types arrays records access types 
data abstractions obtained combining existing data abstraction packages packages structural representational classes defined 
algorithmic abstractions families data abstractions set efficient algorithms common refer algorithms generic algorithms 
example ada library package generic algorithms linked lists general package sequence algorithms members linked list vector representations sequences 
linked list generic algorithms package contains different algorithms example generic merge sort algorithms instantiated various ways produce merge sort subprograms structural abstraction packages singly linked lists doubly linked lists 
stress algorithms level derived abstraction concrete efficient algorithms 
structural abstractions structural abstractions respect set algorithmic abstractions families data abstractions data abstraction belongs structural abstraction algorithmic abstractions intersection algorithmic abstractions belongs 
example singly linked lists intersection sequence linked list singly linked list algorithmic abstractions 
family data abstractions implement singly linked representation sequences connection detailed structure representations inspires name structural abstraction 
note intersection algorithmic abstractions family data abstractions smaller algorithm abstraction classes contained larger number algorithms possible structure operate completely defined 
programming structural abstractions accomplished ada kind generic package structure generic algorithms 
singly linked lists package contains subprograms obtained instantiating calling various ways member sequence algorithms package linkedlist algorithms packages 
ada place data abstraction singly linked lists family instantiates singly linked lists package actual parameters type set operations type data abstraction package system allocated singly linked defines appropriate representation 
representational abstractions mappings structural abstraction creating new type implementing set operations type means operations domain structural abstraction 
example stacks easily obtained structural abstraction singly linked lists 
note obtains really family stack data abstractions usual programming techniques give single data abstraction 
sections give detailed examples algorithmic abstractions 
discussion examples data structural representational abstraction may 
algorithmic abstractions example generic algorithms consider sequence algorithmic abstraction diverse data abstractions sequentially traversed 
data abstractions belong numerous different families singly linked lists doubly linked lists vectors trees 
algorithms sense require simple access operations implementation find element accumulate values theta example count elements satisfying predicate solution taken common lisp index kinds sequences natural numbers 
common lisp generic find function returns natural number particularly useful linked lists 
generic programming approach generic indexing generic formal type coordinate 
coordinate instantiated type natural vectors linked lists cells serve coordinate values 
generic find return coordinate value located element directly 
intended semantics coordinate functions ffl initial sequence coordinate ffl coordinate coordinate ffl sequence theta coordinate boolean ffl ref sequence theta coordinate third type element sequence natural number called length coordinates ffl initial gamma ffl elements ref ref ref gamma ffl false gamma true assume functions initial ref constant time operation 
important ref provides constant time access find returns coordinate possible access data additional traversal sequence 
example natural numbers coordinates sequences linked lists 
ada write generic type sequence private type coordinate private type element private function initial sequence return coordinate algorithmic abstractions function coordinate return coordinate function sequence coordinate return boolean function ref sequence coordinate return element package definitions sequence algorithms count find search generic function test sequence coordinate return boolean procedure find sequence result coordinate boolean find procedure function case element satisfying test require extra coordinate value returned extra value exist instances coordinate type 
note find generic procedure addition forming instance sequence algorithms package programmer create particular instances find particular test equality particular value substituted test 
body find expressed follows package body things procedure find sequence result coordinate boolean current coordinate flag boolean current initial current loop test current result current true return current current loop result current false find noted possible data abstraction contains set elements member sequence algorithmic abstraction 
data abstractions contain explicit coordinate type stacks queues example 
intuitively speaking intended data abstractions iterated sideeffects coordinate type represent current position manner allowing constant time access 
generic partition algorithm limitation sequence algorithms defined previous section allow directional traversals sequences 
algorithms require bidirectional traversal sequences variables type coordinate advancing 
assume prev operation prev prev swap operation exchanging elements obtain generic implementations procedures reverse partition quicksort 
examine partition algorithm particular detailed example issues arise programming reasoning algorithmic abstractions 
ada provide algorithms generic package generic type sequence private type coordinate private function coordinate return coordinate function prev coordinate return coordinate procedure swap sequence coordinate package example procedure reverse sequence generic function test sequence coordinate return boolean procedure partition sequence algorithm specification verification coordinate middle coordinate boolean sequence algorithms package construct collections algorithms different kinds linear lists 
package need element ref generic parameters algorithms reverse partition directly refer 
describe partition algorithm informally formal treatment follows section speak giving larger coordinate prev giving smaller speak elements satisfy test don bad 
provided swap exchanges elements coordinates leaves elements unchanged partition algorithm rearranges elements coordinates elements come followed bad elements 
middle computed coordinate inclusive elements smaller coordinates elements greater coordinates bad th element middle ok true 
middle ok needed elements possibilities boundary bad elements guaranteed having coordinate values general assume existence coordinate values outside range complication arise usual concrete partition algorithm coordinates integers values gamma example extra care taken expressing algorithm level 
partition algorithm expressed ada shown 
somewhat shorter implementation achieved calls test arguments repeated test generic parameter careful avoid redundant calls instantiate algorithm test fairly expensive compute 
algorithm specification verification main idea approach specification verification generic algorithm similar classical program verification techniques dijkstra idea weakest pre procedure partition sequence coordinate middle coordinate boolean coordinate coordinate loop loop middle test return exit test loop loop exit test prev middle false return loop swap middle false return prev loop partition body partition algorithm algorithm specification verification conditions attempts obtain strong statement result computation making assumptions possible initial conditions 
discussing preconditions ordinary nongeneric algorithms assumptions operations terms algorithm expressed fixed operations fixed 
generic algorithms want operations generic parameters vary assumptions goal consider variety possible postconditions maximize number different models data types algorithm attains postcondition 
terms proof theory want consider prove various postconditions variety assumptions generic parameters easily prove correctness wide variety instances 
appears best approach build specifications verification lemmas stages just build algorithmic capabilities layers 
fact find advantageous layering specifications proofs construction algorithms 
introduce main ideas terms partition algorithm previous section 
minimal assumptions need generic parameters terms partition programmed sequence coordinate types prev swap operations 
want algorithm partitioning usual sense abstraction coordinate type specific integer type array version pointer type linked list version carry specification proof step strong assumptions generic parameters 
weaker assumptions generic parameters obtain lemma results partition enables deal conventional instances partitioning 
example suppose interested part output consisting elements satisfy test need process elements don satisfy 
obtain efficient partitioning algorithm swap operation just performs assignment element th coordinate th coordinate 
stronger assumption swap exchanges elements sequence theorem generic algorithm applicable instance 
carry specification proofs layers allows tap level need verify second kind partition usual kind verified additional assumptions swap combined lemma stated level 
assume associated coordinate type predicate basic specification partition founded partial ordering coordinate defined coordinates define coordinate range ng smallest integer note prev gammai basic specification partition initially weak assumption swap swap assumption coordinate range swap computes coordinate range gamma fi jg test test reason get weak assumption simply express result partition computes equivalent produced straight line sequence calls swap 
specification asserts existence sequences coordinate values serve arguments swap calls constrains relationship values 
syntactic specification procedure partition sequence coordinate middle coordinate boolean formal semantics prev assumed obey relations discussed side effects swap assumed obey swap assumption 
inputs partial ordering relation defined partition outputs middle middle ok note generic parameter package expressing algorithms expensive implement say doubly linked lists 
algorithm specification verification 
coordinate range 
sets coordinates accept coordinate range true coordinate range gamma fmg false reject coordinate range gamma accept nonnegative integer coordinate sequences test false test true 
accept gamma fi test true 
reject gamma fj test false 
final value computed swap 
swap fact coordinate type considerable care specification avoid mention coordinate values exist write coordinate range gamma fmg coordinate range prev 
show input output specification proved lemma annotating algorithm assertions inductive assertions method 
consider combine specification additional assumptions swap order draw stronger output partition 
add assumptions time obtaining useful lemmas apply different instances partition 
obtaining sequence satisfying test making second assumption swap draw stronger partition 
swap assumption coordinate range swap computes test test combined basic partition specification deduce obtaining sequence satisfying test partition lemma swap satisfies swap assumptions sequence computed partition satisfies partition property accept test true 
similarly introduce swap assumption coordinate range swap computes test test combined basic partition specification deduce partition lemma swap satisfies swap assumptions sequence computed partition satisfies partition property reject test false 
partition lemma swap satisfies swap assumptions sequence computed partition satisfies partition properties 
note assumption swap exchanging elements sequence assumed affect elements coordinates insofar determined test changes th element test value th vice versa 
example sequences integers test just checks element positive swap operation assigns gamma th element th nonpositive positive satisfy swap assumption 
able conclude sequence computed partition permutation input need assume swap satisfies swap assumption coordinate range swap computes coordinate range gamma fi jg ref ref swap assumption coordinate range swap computes ref ref 
algorithm specification verification swap assumption coordinate range swap computes ref ref 
assumptions obtain partition lemma swap satisfies swap assumptions satisfies swap assumptions partition partition properties partition property output sequence permutation input sequence correctness swap assignment operation suppose performing exchange elements swap just assignment operation satisfies swap assumption swap assumption 
conclude partition lemma swap satisfies swap assumptions satisfies swap assumptions partition partition property partition property sequence elements output sequence coordinates accept subsequence elements coordinates coordinate range satisfying test 
tells instantiating partition swap assignment operation obtain version brings elements satisfy test 
yield elements satisfy test applications need information 
main benefit dividing specification assumptions swap partition small pieces deal question correctness different instances merely citing appropriate lemmas create prove new lemmas comparatively little effort 
proof factored small steps allow benefits reuse proofs generic algorithms allow programming 
correctness body partition correctness body partition prove partial correctness add internal assertions body partition 
assertions note refers initial value variable refers current value point assertion 
inner loop 
nonnegative integer coordinate sequences test false test true coordinate range gamma fi test true coordinate range gamma test false current value value computed swap swap 
second inner loop 
assertion test false 

just swap call 
assertion test true 
assertions entry exit assertions obtained formal semantics algorithm sufficient carrying inductive assertions proof partial correctness path procedure exit composed finite number path segments assertions verify path segment assertion combined semantics statements path implies assertion 
omit proofs 
prove total correctness need show procedure terminates 
result prove conditional termination test swap 
note 
shown inductively times 
path segment defined partial correctness proof repeated execution procedure contains assignment increases decreases path changed violating execution consists finite number path segments 
path segment contains assignment statements equality tests calls test swap partition lemma generic parameters test swap terminate partition terminates 
attempted develop framework sufficient encompass key aspects generic programming illustrations experience building library generic software components ada 
documentation initial library informal carried formal specification verification library components believe task mathematically interesting practically useful 
mathematical side correctness generic algorithms offers greater challenges tedium concrete algorithms create appropriate concepts terms effectively express reason behavior algorithm collection algorithms 
nature problem verifying generic algorithms attractive researchers computer science mathematics problem concrete algorithms regarded tedious worth doing done automated reasoning system 
practical side considerable composing formal specification carrying detailed proof correctness generic level compensated ease able deal correctness distinct instantiations 
difficult justify amount effort required formal verification concrete programs case software life critical systems possibility verifying components generic software libraries may open way benefits technology widely available 
booch software components ada 
benjamin cummings 

dahl dijkstra hoare structured programming academic press 
dijkstra discipline programming prentice hall englewood cliffs new jersey 
goguen parameterized programming transactions software engineering se september 
musser stepanov higher order imperative programming computer science dept rep rensselaer polytechnic institute troy new york april 
musser stepanov library generic algorithms ada proc 
acm international conference boston december 
musser stepanov ada generic library linear list processing packages springer verlag 
book general electric corporate research development reports crd crd april 
steele common lisp language digital press 
wirth algorithms data structures programs prentice hall 
