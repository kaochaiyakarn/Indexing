transaction logic programming anthony bonner department computer science university toronto toronto ontario canada bonner db toronto edu michael kifer department computer science suny stony brook stony brook ny kifer cs sunysb edu extension predicate logic called transaction logic proposed accounts clean declarative fashion phenomenon state changes logic programs databases 
transaction logic natural model theory sound complete proof theory logics allows users program transactions 
semantics leads naturally features amalgamation single logic proved elusive past 
features include hypothetical committed updates dynamic constraints transaction execution nondeterminism bulk updates 
transaction logic holds promise logical model hitherto non logical phenomena including called procedural knowledge ai behavior object oriented databases especially methods side effects 
presents semantics transaction logic coupled sound complete proof theory horn subset logic 
appear proceedings th international conference logic programming iclp held budapest hungary june 
supported part operating natural sciences engineering research council canada university toronto 
supported part nsf ccr new york science technology foundation 
done sabbatical year university toronto 
support computer systems research institute university toronto gratefully acknowledged 
transaction logic abbr novel logic accounts clean completely order manner phenomenon updating arbitrary logical theories including databases logic programs 
procedures specified declaratively logic programs executed proof theory accordance model theoretic semantics 
procedures called transactions may side effects form permanent temporary changes database 
database simple relational database complex disjunctive logic program 
presents model theory proof theory designed applications mind especially databases logic programming ai 
developed general logic solve wide range update related problems 
individual applications carved different fragments logic 
applications practical theoretical discussed great detail 
instance provides logical account update related phenomena 
logic programming leads clean logical treatment assert retract operators prolog effectively extends theory logic programming include updates queries 
object oriented databases combined object oriented logics logic provide logical account methods procedures hidden inside objects manipulate objects internal states 
logic covers structural aspect object oriented databases combination account behavioral aspect 
ai suggests logical account planning 
strips actions instance aspects hierarchical non linear planning easily expressed spite previous efforts give phenomena declarative semantics unifying logical framework account 
surface candidates logic transactions logics reason updates related phenomena time action 
despite plethora action logics researchers continue complain clear declarative semantics updates databases logic programming 
fact stark contrast classical logic action logic core databases logic programming theory practice 
appear simple reasons existing action logics 
major problem logics time action hypothetical permanently change database 
reason happen certain actions took place 
instance infer pawn took knight rook threatened 
logics useful reasoning alternatives executing database updates provide executable specifications actions 
contrast logic supports real hypothetical updates 
procedures may commit updates reason committing combination thereof 
major problem logics time action designed strips early ai planning system simulated actions robot arm 
programming 
intended specifying properties programs reasoning 
logics assign names composite transactions 
intended context reasoning sequences actions shortcoming 
logics inappropriate programming transactions specifying transactions naming facility programming subroutines 
programming standpoint lack straightforward naming facility defeats purpose logic place free user low level details 
problem logics relational databases clear distinction non updating queries actions side effects 
distinction blurred object oriented systems queries updates special cases single idea method invocation message passing 
systems update thought query side effects 
fact method simply program operates data 
models uniformity naturally treating methods equally providing logical foundation object oriented databases 
non logical nature prolog assert retract operators extensively discussed literature point proposals overcoming problems fall short integrating updates complete logical system 
clear assert retract interact logical operators disjunction negation 
instance assert assert mean 
assert 
logically account fact order updates important 
mean update database contains arbitrary logical formulas 
questions addressed prolog classical semantics subsequent works 
gives general solution limitations prolog action logics providing syntax semantics updates combined logical operators build large number interesting useful formulas 
classical logic horn version particular interest logic programming 
horn transaction defined prolog style rules premise specifies sequence queries updates 
furthermore just extension classical order logic horn extension classical horn clause logic 
importance focuses horn horn clean simple proof theory section sound complete respect model theory section 
overview introductory examples user point view similar prolog user writes logic program specifying rules may pose queries perform updates 
users see obvious immediate difference queries updates 
update just query side effects detected issuing subsequent queries 
general user issues transactions system responds displaying answers updating database 
section provides simple examples behavior appears user described formally 
examples illustrate dimensions capabilities 
capabilities mentioned outset non deterministic transactions 
non determinism applications areas especially suited advanced applications artificial intelligence 
instance user robot simulator instruct robot build stack blocks may say care blocks 
likewise user cad system request system run electrical line point fixing exact route form loose constraints run line close wet exposed areas 
transactions final state database indeterminate predicted outset depends choices system run time 
enables users say choices allowed 
user issues non deterministic transaction system particular choices may implementation dependent putting database allowed new states 
elementary applications transaction execution characterized just initial final state sequence intermediate states database passes 
example robot simulator piles block block block transaction execution pass state state state 
final state intermediate states may uniquely determined start execution 
example robot may non deterministic choice block grasp 
call sequence database states execution path transaction 
represents execution paths explicitly 
doing express wide range constraints transaction execution 
example user may require intermediate state satisfy condition may forbid certain sequences states 
execution transactions formally described statements called executional entailment express form logical entailment logical formula finite sets logical formulas 
called transaction base 
intuitively set transaction definitions transaction invocation sequence databases representing states transaction execution 
statement means execution path transaction 
current database state user issues transaction typing gamma prolog database may go state state state reaches state transaction terminates 
emphasize word may may non deterministic transaction 
may execution paths proof theory derive paths non deterministically selected actual execution path final state path new database 
differences transaction base database database updated transactions transaction base immutable 
second formulas transactions base may full syntax database formulas limited classical logic subset formalisms draw thick line transactions queries 
fact transaction oe cause state change viewed query 
state affairs formally expressed statement oe special case statement 
case sequence databases length 
uniform treatment transactions queries crucial successful adaptation object oriented domain object oriented systems syntactically distinguish state changing information retrieving methods 
rest section illustrates notation capabilities number simple examples 
examples illustrate uses logical operators combine simple actions complex ones 
simple transactions transactions combination queries updates 
queries change database expressed classical logic 
contrast updates change database expressed extension classical logic 
call simplest kind updates elementary updates elementary state transitions 
principle restrictions changes elementary update database practice expect simple cheap 
insertion deletion atomic formulas canonical examples elementary updates 
kinds elementary updates may useful 
instance relational assignment express sql style bulk updates elementary updates atomic decomposed simpler updates 
represent atomic formulas 
atomic formulas elementary updates truth value addition side effect database 
formally represented executional entailment says atomic formula name update changes database state state atomic formula update programming practice reserve special set predicate symbols purpose 
example predicate symbol predicate symbol ins represent insertions likewise predicate symbol del represent deletions example elementary updates binary predicate symbol 
atoms ins pie sky del pie sky elementary updates 
intuitively ins pie sky means insert atom pie sky database 
likewise atom del pie sky means delete pie sky database 
user perspective typing gamma ins pie sky interpreter changes database fin pie sky likewise typing gamma del pie sky changes database gamma fin pie sky express behaviour formally statements true transaction base fin pie sky ins pie sky gamma fin pie sky del pie sky gamma denote set union difference respectively 
sufficient relational databases sets atomic formulas 
complex databases insertion deletion complex operations 
note insertion deletion built semantics fact committed particular set elementary updates 
intrinsic connection names ins del names merely convention purposes illustration 
fact ins del ordinary predicates connection established axioms called transition base explained 
basic way combining transactions sequence execute 
example may take money account withdrawal succeeds deposit money account 
combine transactions sequentially extend classical logic new binary connective omega called serial conjunction 
formula omega oe denotes composite transaction consisting transaction followed transaction oe 
elementary updates sequential transactions intermediate states initial final states 
express behavior formally statements omega oe gamma omega oe changes database intermediate state 
example serial conjunction expression unlucky omega ins poor omega ins sad unlucky poor sad ground atomic formulas denotes sequence insertions preceded test 
transaction means check unlucky true insert poor database insert sad 
initial database user issues transaction typing gamma unlucky omega ins poor omega ins sad execution database change provided unlucky initially true express behaviour formally statement holds transaction base unlucky true unlucky omega ins poor omega ins sad example illustrates preconditions 
express post conditions tests intermediate database states 
rules non deterministic transactions rules formulas form oe atomic formula oe formula 
classical logic formula just convenient abbreviation oe 
formal declarative interpretation rules 
operationally formula oe means execute sufficient execute oe 
interpretation important provides subroutine facility logic programming possible 
instance rule oe predicate symbol acts name procedure variable acts input parameter formula oe acts procedure body definition exactly horn clause logic programming 
rule body may formula frequently serial conjunction 
case rule form omega omega omega atom 
rules users define transaction subroutines write transaction logic programs 
note facility possible transactions represented predicates distinguishes logics action especially actions modal operators 
logics subroutines awkward impossible express 
notational convenience assume free variables rule universally quantified outside rule 
rule oe simply abbreviation oe 
example flipping coins suppose transaction base contains rules lip ins heads lip ins tails rules say flip coin say dime insert heads dime database insert tails dime 
gamma lip dime non deterministic transaction 
formally result flipping dime represented dime lip dime dime lip dime means know advance exact outcome flipping action 
transaction bases section gives simple realistic examples transaction bases comprised finite sets rules 
examples show updates combined queries define complex transactions 
example body rule sequence atomic formulas queries updates 
examples illustrate transaction subroutines 
example financial transactions suppose balance bank account relation balance acnt amt 
modify relation provided pair elementary update operations del balance acnt amt delete tuple relation ins balance acnt amt insert tuple relation 
updates define transactions change balance acnt bal bal change balance account withdraw amt acnt withdraw amount account deposit amt acnt deposit amount account transfer amt acnt acnt transfer amount account 
transactions defined rules transfer amt acnt acnt withdraw amt acnt omega deposit amt acnt withdraw amt acnt balance acnt omega change balance acnt gamma amt deposit amt acnt balance acnt omega change balance acnt amt change balance acnt del balance acnt omega ins balance acnt second third rules atom balance act bal query retrieves balance specified account 
atoms updates 
example non deterministic recursive robot actions transaction base simulates movements robot arm world toy blocks 
states world defined terms database predicates says block top block clear says top block wider says wider rules define actions change state world 
action evaluates premises order action fails premises fails case database left original state 
stack omega move omega stack gamma stack move pickup omega putdown pickup clear omega omega del omega ins clear putdown omega wider omega clear omega ins omega del clear basic actions pickup putdown mean respectively pick block put block top block wider defined terms elementary inserts deletes database relations 
remaining rules combine simple actions complex ones 
instance move means move block top block stack means stack arbitrary blocks top block actions pickup putdown deterministic set argument bindings specifies robot action 
contrast action stack non deterministic 
perform action inference system searches database blocks stacked 
stage process blocks placed top stack system arbitrarily chooses 
observe rules easily rewritten prolog form replacing omega replacing elementary state transitions assert retract 
resulting apparently innocuous prolog program execute correctly 
problem prolog updates undone backtracking 
instance suppose move action robot picked blka widest block table 
move action fail robot put blka stack blka wide 
inference system simply backtracks tries find block pick 
prolog backtrack leave database incorrect state undo pickup action 
blka previously top blka remain deleted clear stay database 
constraints classical conjunction constrains non determinism transactions 
general transaction oe deterministic oe execution oe allowed execution allowed execution oe 
illustrate consider conjunction robot actions assuming block top block 
go kitchen don pass bedroom conjunct non deterministic action ways carried 
composite action constrained conjuncts 
way conjunction reduces non determinism allows user specify done 
note classical conjunction cause conjuncts executed separate transactions 
combines single tightly constrained transaction constrains entire execution transaction just final state 
general constrains transactions ways causing transactions fail ii forcing non deterministic transactions execute certain ways 
example transaction failure consider gamma ins bought omega ins wanted gamma ins wanted omega ins bought 
transactions transform database state state 
pass different intermediate states 
goes state passes state 
conjunction ins bought omega ins wanted ins wanted omega ins bought fails single sequence states valid execution path conjuncts 
formally statements true ins bought omega ins wanted ins wanted omega ins bought statement false sequence databases ins bought omega ins wanted ins wanted omega ins bought example reducing non determinism consider pair non deterministic transactions gamma ins lost ins gamma ins lost ins won 
starting database follow path terminate 
fact database reached transactions 
execution transaction gamma ins lost ins ins lost ins won final database state 
formally true ins lost ins ins lost ins won iff way classical conjunction reduces non determinism particular example yields completely deterministic transaction 
explore richness expressing constraints 
expressiveness comes serial conjunction especially combined negation 
example formulas natural meaning constraint ffl omega omega means sequence omega omega allowed 
assuming bought wanted assuming won ffl oe omega means transaction immediately follow transaction oe 
ffl oe omega means transaction immediately follow transaction oe 
formulas simplified dual operator phi called serial disjunction 
example formula rewritten oe phi 
repertoire executional constraints expressible large 
easy specify transactions overlap start simultaneously terminate show full set temporal relationships allen logic time intervals simple natural representation novel expressing constraints traditional role forming logic programs classical logic finite set rules equivalent conjunction rules set 
syntax syntax distinguishes kinds formulas transaction formulas elementary transitions define composite transactions define elementary updates 
transaction formulas formulas users define transactions formulate queries 
transaction formulas extend order formulas new connective omega called serial conjunction 
formally transaction formulas defined recursively follows 
atomic transaction formula expression form predicate symbol terms classical predicate calculus 
oe transaction formulas oe oe oe omega oe oe oe variable 
expression omega transaction formula 
intuitively omega oe means oe 
dual connective serial disjunction useful section phi oe equivalent oe omega 
transaction formulas combine simple transactions complex ones 
need way specify elementary changes database 
way define changes build semantics 
problem approach adding new kinds elementary transitions leads redefinition notion model entire theory including proofs soundness completeness 
drawback quite serious appears small single set elementary transitions best purposes 
committing fixed set elementary transitions chosen treat transitions parameter set transitions gives rise different version logic 
achieve elementary transitions defined logical axioms 
elementary transitions formulas form hoe iu oe closed order formulas atomic formula name transition 
intuitively formula says update transforms database oe database 
instance section predicates ins del defined enumerable set elementary transitions consisting formulas hd ins hd gamma del relational database enumerable sets transitions called transition bases 
practice transaction bases materialized generated demand algorithm 
reader referred detailed discussion 
model theory just syntax basic ideas serial conjunction elementary transitions semantics fundamental ideas ffl transaction execution paths transaction causes sequence database state changes ffl database states database state set classical order semantic structures ffl executional entailment transaction execution corresponds truth sequence states 
transaction execution paths user executes transaction database may change going initial state state 
doing execution may pass number intermediate states 
example execution gamma ins omega ins omega ins takes database initial state intermediate states fag fa bg final state fa cg 
idea sequence states central semantics 
allows model wide range constraints 
example may require intermediate state satisfy condition may forbid certain sequences states 
model transactions start modal semantics state represents database elementary update causes transition state changing database 
point modal logic transaction logic part 
major difference truth structures hinge set arcs states 
focus paths sequences states 
emphasis paths refer semantic structures path structures 
second truth path structures defined paths states 
example say path fag fa bg satisfies formula ins omega ins represents insertion followed insertion path length corresponds single database state 
way model theoretic device paths accounts databases updates queries general transactions 
database states difference modal logic transaction logic nature states 
modal logic state basically order semantic structure state specifies truth set ground atomic formulas 
structures adequate representing relational databases representing general theories indefinite databases general logic programs 
take general approach 
database order formula set order models general order formula defining insertion deletion involved 
define state set order semantic structures 
state corresponds particular database database having precisely models comprising approach states provides lot flexibility defining elementary updates 
flexibility needed general databases semantics elementary updates clear relatively simple updates insert delete 
example mean insert atom database entails especially explicitly database 
consensus answer question solutions proposed see comprehensive discussion 
reasons take general approach elementary updates 
elementary update mapping takes database database database order formula 
generally elementary update may non deterministic just mapping binary relation databases 
path structures models section preceding discussion precise 
definitions path structure domain objects interpretation function symbols interpret formulas path structure 
definition path structures order language function symbols predicate symbols path structure quadruple hu path ffl domain ffl interpretation function symbols assigns function gamma 
ary function symbol struct denote set usual order semantic structures form hu mapping interprets predicate symbols relations ffl non empty set states state non empty subset struct 
element called state path structure path length finite sequence states hs ffl path mapping assigns path order semantic structure struct subject restriction path hsi state 
recall set semantic structures 
mapping path serves semantic link transactions paths path transaction transaction formula path determines formula true path definition 
restriction path hsi guarantees path length view database state model underlying database 
note arbitrary path semantic structure path independent subpaths 
intuitively means know relationship transactions subtransactions 
knowledge exists encoded transaction base 
definition satisfaction paths subpaths related 
defining satisfaction convenient define path splits path hs state path defines split path parts hs hs path split parts fl ffi write fl ffi ffi fl prefix ffi suffix 
classical logic order define satisfaction quantified formulas open formulas convenient introduce variable assignments 
variable assignment mapping gamma 
takes variable input returns domain element output 
extend mapping variables terms usual way 
definition satisfaction hu path path structure path variable assignment 

path denotes classical satisfaction order logic atomic formula 

oe oe 

oe oe 
usual meaning dual 

oe omega fl oe ffi split fl ffi ffi path 

oe oe variable assignment agrees usual meaning oe dual oe 
classical logic variable assignment omitted sentences formulas free variables 
deal sentences explicitly stated 
atoms play role subroutine calling sequences programming language parlance 
intuitively executing subroutine corresponds finding path true 
item establishes relationship path subpaths corresponds relationship transaction subtransactions 
particular atom may true path false proper subpaths vice versa 
intuitively means transaction call recursively 
definition models transaction formulas path structure model formula oe denoted oe oe path path structure model set formulas model formula set 
usual order logic define oe oe mean oe resp oe mean oe oe 
replacing phi dual omega obtain interesting pair serial connectives left serial implication oe standing phi oe right serial implication oe denoting oe phi 
intuitively formulas say action oe immediately preceded resp followed action 
connectives identical oe equivalent oe oe equivalent oe 
easy verify path structure model formulas analogous de morgan laws oe omega oe omega oe omega oe phi oe phi oe phi oe omega 
oe omega oe omega oe phi oe phi oe phi definition tells means path structure model transaction formula oe 
formulas define complex transactions terms simpler ones 
addition define means model elementary state transition hd iu 
intuitively formula means update changes database database definitions idea precise 
definition correspondence hu path path structure 
order formula expression means set order models struct 
say corresponds database note meaning depends domain interpretation function symbols 
path structure clear context 
definition models transition bases path structure hd iu elementary state transition suppose transition satisfied denoted hd iu states hs definition hs path length entailment relation definition 
intuitively statement hd iu means true arc note transaction formulas true paths truth elementary transition determined respect entire path structure 
say model transition base satisfies elementary state transition execution entailment define executional entailment concept connects model theory transaction execution 
recall program consists distinct parts transaction base database transition base part plays distinct role defining executional entailment 
parts database updatable 
parts specify procedures updating database answering queries 
transition base defines elementary updates state transitions transaction base contains logical rules define complex queries transactions normally composed formulas containing serial connectives omega phi classical order formulas allowed 
contrast database consists entirely classical formulas 
definition executional entailment transition base transaction base 
oe transaction formula sequence databases order formulas 
statement oe true model path hs hs oe 
related statement oe true iff database sequence true 
intuitively statement means successful execution transaction oe change database state formally means model path corresponding satisfies oe 
normally users issuing transactions know initial database state account situation version entailment allows omit intermediate final database states 
intuitively statement means transaction oe execute successfully starting database context clear simply say transaction oe succeeds 
likewise statement true say transaction oe fails 
section inference system allows compute database sequence satisfies statement transaction succeeds 
lemma basic properties executional entailment transition base transaction base database sequence transaction formulas ff fi statements true 
ff fi ff fi 

ff fi ff omega fi 

ff fi fi ff 

hd iff ff 

order formula denotes classical entailment 
note lemma suggests simple inference system items axioms items inference rules 
corresponds special case transaction affect database acts query 
case classical serial conjunction identical lemma conjunctive queries transition base transaction base database transaction formulas ff fi ff fi ff omega fi intuitively lemma says result evaluating conjunctive query conjuncts evaluated sequentially parallel 
proof theory sound complete proof procedure 
procedure relatively complex scope 
fortunately classical logic horn version called serial horn substantially simpler proof theory 
classical horn programs serial horn programs procedural declarative semantics 
property allows user program transactions logic 
section defines serial horn subset develops proof theory practical sld style proof procedure unification 
classical logic programming proof procedure section computes new database states query answers 
serial horn programs idea serial conjunction 
serial conjunction transaction formula form omega omega omega atomic formula 
serial horn rule form omega omega omega body omega omega omega serial conjunction head atom 
rules section serial horn 
non updating queries expression omega omega equivalent classical horn rules special case serial horn rules 
serial horn program transaction base transition base database satisfy transaction base set serial horn rules 
ii database set classical horn rules 
iii transaction query existential serial conjunction formula form oe oe serial conjunction list free variables oe 
iv database independent transaction base intuitively means database define predicates views terms transactions 
formally predicate symbols occur rule heads occur rule bodies conditions ii iv apply current database database mentioned transition base condition independence arises naturally situations database relational set atomic formulas ii conceptual distinction desired updating actions non updating queries 
case database trivially independent database atom empty premise 
case logic sorts predicates query predicates action predicates 
action predicates defined transaction base query predicates defined database 
action predicates defined terms query predicates express pre conditions post conditions vice versa 
serial horn expressive logic useful programs horn 
programs typically arise user applies constraints execution programs serial horn see section 
constraints handled generalpurpose proof theory efficient special purpose inference system reported 
inference develop inference system called checking transaction successfully execute starting state inference succeeds finds execution path transaction sequence databases 
shall see certain inference strategies generate execution path way corresponds intuitive notion transaction execution 
particular top inference corresponds forward execution normal kind bottom inference corresponds reverse execution starting current state compute new states executing updates reverse 
introduce dual system ii useful bottom transaction execution 
additionally hypothetical transactions allowed describes elegant inference system ii complete presence hypothetical modal operators 
dealing serial horn case transaction existential serial conjunction formula form omega omega omega am atomic 
free variables assumed existentially quantified omit reminder leave front transactions 
note existential quantification consistent traditions logic programming databases 
inference rules focus left transactions 
highlight focus write serial conjunctions oe omega rest oe piece conjunction inference system currently focussed rest rest conjunction 
definition inference suppose transition base transaction base 
satisfy serial horn conditions system axioms inference rules database mentioned axioms inference rules rules atomic formulas unify mgu oe rest serial conjunction atoms 

applying transaction definitions oe rule oe omega rest oe omega rest 
querying database boe denotes classical provability rest oe omega rest 
performing elementary updates hd ib transition rest oe omega rest presents natural deduction system 
difficult see sld style companion 
system manipulates expressions form oe called sequents 
informal meaning sequent transaction oe succeed executed path emanating database inference rule consists sequents interpretation upper sequent inferred lower sequent inferred 
starting axiom sequents system repeatedly applies inference rules infer sequents 
notice rule changes database 
transition base infinite implementation rule include algorithm enumerating elements transition base 
implementing infinite axiom base algorithm way akin algorithmic implementations inference rules resolution rule finite representation classical logic 
system enumeration algorithm take update database state input enumerate possible successor states states hd ib transition base 
instance ins fa cg input algorithm return fa dg output 
procedures perform elementary updates treated black boxes plugged inference system 
understand inference system note axioms describe empty transaction 
transaction succeeds 
inference rules describe complex transactions capturing roles transaction base database transition base respectively 
interpret rules follows rule replaces subroutine definition oe calling sequence rule attaches precondition front transaction rest rule attaches elementary update front transaction rest resulting transaction starts unifier oe practical sld style inference system returns general unifiers answers prolog see section 
classical resolution instance answer substitution valid answer query 
invoking classical provability oracle 
database horn oracle needs examine fixpoint database unifies atom lfp 
done sld resolution suitable mechanism 
definition general deduction inference system deduction proof sequent seq series sequents seq seq seq gamma seq seq axiom derived earlier sequents inference rule 
theorem soundness completeness transition base transaction base oe transaction formula 
oe satisfy serial horn conditions executional entailment oe holds iff deduction sequent oe 
execution deduction having developed inference system remind original goal proving statements form oe form oe database state time user issues transaction gamma oe 
note intermediate states gamma final state unknown time 
important task inference system compute states 
general notion deduction tight conveniently general deduction may record execution unrelated transactions mixed haphazard way 
interested execution particular transaction introduce specialized notion executional deduction sacrificing completeness defines narrower range deductions definition 
definition executional deduction transition base transaction base 
executional deduction transaction oe deduction seq seq satisfies conditions 
initial sequent seq form database 
final sequent seq form oe database 
sequent seq obtained previous sequent seq gamma inference rules system seq gamma numerator rule seq denominator 
theorem remains valid deductions required executional 
stronger form deduction prove stronger results 
theorem instance specify execution path transaction 
executional deduction 
execution paths easily extracted executional deductions 
key observation system applies elementary transitions exactly inference rule invoked 
invoking rule inference proof theoretic analogue executing elementary transition 
need pick points executional deduction inference rule applied 
define execution path deduction sequence theorem provides model theoretic meaning execution paths 
relates executional deduction executional entailment definition 
oe delta delta delta oe inference rule delta delta delta oe inference rule delta delta delta executional deduction theorem executional soundness completeness transition base transaction base executional deduction oe execution path iff statement true oe constructing executional deductions execute transactions 
shows constructing deduction top database systematically updated call normal execution 
likewise constructing deduction bottom database systematically updated gamma call reverse execution 
process constructing deductions executing transactions developed detail 
example inference unification prolog inference system returns substitution 
substitution specifies values free variables transaction succeeds 
example similar example robot simulator moves blocks table top 
consider transaction base containing rule describes effect picking block pickup clear omega omega del omega ins clear suppose order robot pick block typing gamma pickup 
block left unspecified transaction non deterministic 
inference system attempts find value enables transaction succeed updating database process 
illustrate suppose initial database represents arrangement blocks blka top stands 
robot picks blka database changes state blka clear blka blka clear blka clear clear rule unifier sequent pickup clear omega omega del omega ins clear blka blka omega del blka omega ins clear del blka omega ins clear ins clear executional deduction pickup executional deduction robot picks blka shown 
sequent derived sequent immediately inference rule 
inference involves unifying leftmost atom transaction atom database transaction base transition base 
example deriving sequent sequent inference system unifies atom clear transaction atom clear blka database way system chooses pick blka 
likewise deriving sequent sequent inference system unifies atom blka transaction atom blka database retrieving block blka resting 
note line table shows items numbered sequent inference rule deriving sequent unifying substitution 
answer substitution obtained composing unifiers yields fx blka projecting substitution yields fx 
operational interpretation proof robot picked blka 
comparison far logic programming concerned aware approach logics updates comprehensive particular works discussed capable expressing constraints execution complex transactions 
likewise seamlessly accommodate hypothetical state transitions transitions commit permanently change current database state exception works limited updating sets ground atomic facts 
extensive comparison 
winslett foundational meaning updates general logical theories 
grahne katsuno mendelzon axiomatized various theories state transition studied tractable cases call elementary state transitions 
approach state transitions inspired results 
warren introduce dynamic prolog logic system update transactions right failed leave residue database 
logic update views transactions nondeterministic 
distinguish update predicates query predicates drawback keep eye object oriented applications explained 
furthermore bulk updates constraints transaction execution insertion deletion rules expressed due chosen semantics 
addition proof theory dynamic prolog impractical carrying updates know final database state inference begins 
proof theory verification system initial state final state update procedure proof theory verify procedure causes transition just initial state procedure compute final state execute procedures proof theory 
apparently realizing drawback warren developed interpreter executing transactions 
interpreter incomplete respect model theory furthermore proof theory dynamic prolog 
certain extent said warren managed formalize intuition procedurally inference system 
naqvi krishnamurthy extended datalog update operators incorporated ldl language 
ldl geared database applications extension bulk updates operational semantics exists 
unfortunately model theory somewhat limited 
matches operational semantics propositional case cover bulk updates 
second defined programs commutativity elementary updates assumed 
sequences updates hold semantics turns tricky certainly qualify model theoretic 
third definition legal programs highly restrictive making difficult build complex transactions simpler ones 
chen developed calculus equivalent algebra constructing transactions 
calculus uses logical operators construct actions elementary updates 
main differences 
calculus analogue transition base specifying elementary updates restricted insertion deletion single tuples 
second difference semantics conjunction uses express constraints chen calculus uses express parallel actions 
main motivation parallel actions bulk updates easy express important database feature 
disadvantages way achieved 
calculus express kind sophisticated constraints 
time sequential updates achieve effect parallel updates 
way parallel actions introduced undesirable complicates semantics greatly making non monotonic absence negation 
achieves effect simpler monotonic way 
syntax calculus closed 
instance negation applied formulas 
particular updating transaction rules meaning equivalent 
calculus developed full blown logic straightforward satisfying way 
furthermore calculus limited programming language mechanism defining recursion subroutines 
mccarty outlined logic action part larger proposal reasoning deontic concepts 
proposal contains distinct layers logic order predicate logic logic action logic permission obligation 
ways layers similar especially action layer uses logical operators construct complex actions elementary actions 
interest deontic concepts mccarty defines notions satisfaction 
notion called strict satisfaction conjunction corresponds parallel action chen 
notion called satisfaction symbol corresponds constraints focus strict satisfaction development path constraints considered 
analogue transition base elementary updates considered correspond insertion deletion atomic formulas 
obviously interesting action logic developed detail 
instance model theory sequences partial states sound complete proof theory mechanism executing actions updating database 
contrast mccarty van der meyden detailed different intended updating databases 
ai workers represent actions classical predicate logic situation calculus 
research focuses general reasoning actions complementary focuses defining transactions executing 
ai formalisms actions usually hypothetical actions hypothetical real 
important difference avoids infamous frame problem ai complicates reasoning actions 
possible performs real updates materialized databases just ordinary programs 
approaches perform general reasoning difficulty basic database features views post conditions especially recursion involved 
advanced features path constraints nondeterministic actions difficult formalize situation calculus 
georgeff lansky develop formalism called procedural logic intent similar 
important differences practically philosophically 
difference arise largely procedural logic separate things implementation called prs provides functionality formalization accounts fraction functionality 
probably fair say formalization accounts prs 
shortcomings procedural logic summarized follows formalization include database updates defined ii declarative semantics procedural anticipate prolog style backtracking interpreter iii operational semantics interpreter logical inference system interpreter incomplete respect declarative semantics 
path structures reminiscent path models process logic 
important differences 
process logic intended reasoning properties programs updating databases programming executing transactions 
process logic lacks subroutine facility defining composite actions facility transition base defining elementary actions 
second state changes process logic hypothetical easy permanent 
abiteboul vianu developed family update languages provided impressive results complexity expressibility 
languages lack features apply relational databases arbitrary sets order formulas 
second facility constraining transaction execution 
transaction output concern 
third languages part full blown logic arbitrary logical formulas constructed operational semantics model theory logical inference system 
languages flexibility find applications domains ai 
languages support transaction subroutines 
transaction name invoked repeatedly language facilities practical programming language provide 
lack subroutines reflected data complexity languages pspace recursive subroutines require alternating pspace exptime 
works related borrow syntax deductive databases semantics operational inspired logical model theory 
languages different league mention works allen logic time intervals event calculus kowalski sergot logic halpern shoham 
methodology programming allen time intervals classical setting halpern shoham develop propositional modal logic 
approaches represent aspects transaction programming approaches completely adequate task pursues different goal 
instance features listed section supported straightforward way approaches straightforward subroutine facility 
just case situation calculus methodology event calculus conjunction acknowledgments alberto mendelzon provided insights regarding updates logic theories 
ray reiter commenting various aspects especially issues related frame problem 
mariano consens took close look draft improvements due comments 
discussions grahne peter revesz helpful progress 
abiteboul vianu 
procedural declarative database update languages 
acm sigact sigmod sigart symposium principles database systems pods pages new york 
acm 
allen 
general theory action time 
artificial intelligence july 
bancilhon 
logic programming object oriented cocktail 
sigmod record september 
beeri 
new data models languages challenge 
acm sigart symposium principles database systems pods pages san diego ca june 
acm 
bonner kifer 
transaction logic programming logic declarative procedural knowledge 
technical report csri university toronto april 
revised february 
ftp csri technical reports report ps bonner kifer 
general logic state change 
technical report csri university toronto 
preparation 
chen 
declarative specification evaluation database updates 
intl 
conference deductive object oriented databases dood volume lecture notes computer science pages 
springer verlag december 
de simon 
non deterministic queries updates deductive databases 
intl 
conference large data bases vldb 
morgan kaufmann san francisco ca 
georgeff lansky 
procedural knowledge 
proc 
ieee special issue knowledge representation volume pages 
grahne mendelzon 
updates subjunctive queries 
technical report krr tr csri university toronto july 
halpern shoham 
propositional modal logic time intervals 
intl 
symposium logic computer science lics pages 
harel kozen parikh 
process logic expressiveness decidability completeness 
journal computer system sciences october 
katsuno mendelzon 
difference updating knowledge base revising 
proceedings international conference knowledge representation reasoning kr pages boston mass april 
kifer lausen wu 
logical foundations object oriented languages 
journal acm may 
kowalski 
database updates event calculus 
journal logic programming january 
kowalski sergot 
logic calculus events 
new generation computing 
warren 
logic language database updates 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann los altos ca 
mccarthy 
situations actions clausal laws memo 
stanford artificial intelligence project 
mccarthy hayes 
philosophical problems standpoint artificial intelligence 
meltzer michie editors machine intelligence volume pages 
edinburgh university press 
reprinted readings artificial intelligence tioga publ 
mccarty 
permissions obligations 
intl 
joint conference artificial intelligence ijcai pages san francisco ca 
morgan kaufmann 
mccarty van der meyden 
reasoning indefinite actions 
proceedings international conference knowledge representation reasoning kr pages cambridge ma october 
naqvi krishnamurthy 
database updates logic programming 
acm sigact sigmod sigart symposium principles database systems pods pages new york march 
acm 
ross 
glue nail deductive database system 
acm sigmod conference management data pages new york 
acm 
reiter 
formalizing database updates preliminary report 
proc 
rd intl 
conf 
extending database technology march 
winslett 
model approach updating databases incomplete information 
acm transactions database systems 
