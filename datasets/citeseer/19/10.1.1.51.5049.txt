strong modes change world 
fergus henderson department computer science university melbourne australia cs mu oz au november supervisor dr lee naish investigate compile time garbage collection structure reuse destructive assignment logic programming languages expressive strong mode system 
attaching groundness uniqueness information node variable type tree mode system forms basis carrying optimizations 
system allows polymorphic mode definitions achieve high level expressiveness 
implement simple preprocessor structure re optimization prolog programs annotated mode declarations 
show mode system provide declarative logical programming languages 
acknowledgments lee naish supervisor harald jeff schultz alistair moffat winsborough parents fellow students flat mates 
apologize phil wadler title adapted linear types change world wad 
contents motivation logic programming languages importance destructive assignment previous approaches strong mode systems new approach structure re type system basic mode system relationship interpretation extended mode system aliasing polymorphic modes implementation overview syntax mode annotations mode checking algorithm compile time garbage collection difficulties lost indexing structure reuse destructive assignment results logically sound declarative unique modes chapter report explores certain optimization techniques logic programming languages strong mode system basis optimizations 
discuss motivations investigating optimizations detail chapter suffices say consider key optimizations required achieve efficiency conventional languages 
assume reader general knowledge logic programming 
knowledge standard techniques implement prolog terms variables stored memory useful essential 
optimizations question variously known compile time garbage collection structure re destructive assignment 
terms ambiguous general usage take opportunity clearly delineate different optimizations adopting definitions ffl compile time garbage collection refers detecting areas memory unreferenced returning free memory pool 
ffl structure reuse requires detecting areas memory unreferenced returning free memory pool immediately reuse memory build new term 
structure reuse known simply local reuse fw 
ffl destructive assignment works linking input argument output argument replacing single argument value destructively updated replace input output 
destructive assignment different structure reuse reuses terms reuses memory block time 
distinctions different optimizations discussed chapter 
implement optimizations requires data flow analysis determinism analysis 
determinism analysis required ensure memory wish reuse needed backtracking 
report investigate determinism analysis analysis quite straight forward possession necessary data flow information easy extend results include example lee naish nac preprocessor determinism analysis data flow information provided nu prolog declarations nai determinism analysis 
prototype implementation safe destructive assignment primitive trails destructive assignments terms older choice point destructive assignments undone backtracking 
case trailing required incurs small overhead test ensures soundness transformations trailing required optimizations turn code function correctly 
rely mode declarations provide data flow information required 
provides great simplification advantages discussed chapter section chapter 
mode system suggest expressive seen 
idea mode mapping state instantiatedness 
som attach mode information node variable type tree allow recursive mode declarations 
allow polymorphic modes mode declarations may contain instantiatedness variables way polymorphic type declarations may contain type variables 
purposes optimizations allow mode declarations specify uniqueness know term may reused 
rest report organized follows 
chapter explains particular optimizations question important 
chapter defines mode system section chapter defines syntax expressing modes gives examples 
remainder chapter discusses implementation optimizations give algorithm mode checking show modified perform compile time garbage collection structure reuse optimization 
chapter looks application mode system expressing input output logically pure declarative code 
chapter motivation logic programming languages logic programming offers advantages high level declarative programming implicit memory management executable specifications remains relatively unsuccessful compared conventional languages 
major factor preventing widespread acceptance logic programming languages relative lack efficiency compared conventional procedural languages pascal 
compilation techniques improving developments tay rd hsc shown benchmarks prolog faster remains case common algorithms example hashing efficient languages reasons prolog logic programming languages competitive comes raw speed remain niche programming languages 
important reason prolog programs implemented efficiently conventional language programs logical variable 
variables conventional languages represent areas machine storage variables prolog powerful notion difficult map underlying hardware particular possible directly express low level notion destructive assignment assignment prolog 
standard programs pascal destructive assignment modify large data structures current prolog implementations equivalent prolog programs copying data structures order modify 
sophisticated compiler take advantage situations structures copied old copy discarded generate code destructive assignment done procedural versions 
generally compiler may detect certain areas memory longer referenced re areas immediately return pool unused memory avoiding need run time garbage collection areas 
important optimizations provide motivation report 
importance destructive assignment consider destructive assignment optimizations subsumes important optimization opportunities industrial prolog compilers taken advantage 
important reasons ffl optimizations give trans linear speedup 
destructive assignment modifying structure size order operation destructive assignment 
ffl re structure avoid allocating new memory avoid overhead having garbage collect old structure 
dramatically reduce memory bandwidth limiting factor prolog computations improve locality cache performance 
ffl allows arrays data structures hash tables binary trees implemented efficiently 
ffl avoids need tricky schemes open ended data structures 
schemes programs difficult comprehend sit type mode systems 
worst cases involve explicit calls non logical predicates var programmers code sacrificed declarative semantics quest efficiency 
example means ground representation meta programming need efficient non ground representation believe efficiency barrier overcome sufficient incentive programmers language implementors switch logically pure ground representation 
ffl means deterministic code approach speed conventional languages 
ffl means algorithms conventional languages prolog fairly directly having worry resulting program may un inefficient 
previous approaches date fair amount research algorithms detecting structure sharing opportunities structure reuse compile time garbage collection generally involving global analysis interpretation 
examples sort research fw 
actual implementations real prolog systems 
expect global analysis programs norm optimizing compilers time appears full complexities global analysis barrier successful implementations 
constraint logic programming language logic programming language know allow destructive update 
unfortunately done appears fairly ad hoc limited manner doubt pragmatic reasons 
result mixture prolog pascal 
possible modes input output input output symbolic 
input variables ground procedure entry output variables ground procedure exit 
symbolic variables correspond unrestricted logical variables prolog inputoutput variables represent pair variables input output may destructively updated assignment operator just pascal 
vod inevitable loss readability input output modes notes large arrays inefficiency alternative prohibitive 
destructive assignment doubt great boon practical programmers believe general approach blends better underlying logic semantics language possible practical 
chapter outlines mode system foundation general approach 
addition constraint language symbolic variables may constraints attached 
chapter strong mode systems new approach structure re mode system allows programmers express programs constraining directions data flow particular mode systems generally allow specify predicate required inputs outputs 
mode systems early war proven particularly useful coroutining parallel languages nu prolog declarations form modes tz parlog cg cdb 
strong analogy type systems mode systems fruitful source ideas 
strong mode systems share advantages strong type systems 
particular strong mode systems offer benefits ffl efficient code predicates different ways flexibility comes cost efficiency 
generating separate code different modes predicate regain lost efficiency 
importantly generating separate code mode practical compile directly machine code 
information provided mode declarations allows variety different optimizations 
ffl quicker compilation mode systems provide information optimizing compiler obtain possibly lengthy analysis program 
ffl predictable compiler optimization behaviour strong mode systems possible programmer effect suggest compiler apply certain optimizations mode system reject suggestions code contains mode error programmer confident compiler able carry optimizations 
contrast techniques global analysis interpretation difficult programmer determine sort optimizations compiler able perform piece code 
ffl readable maintainable programs just types modes important form documentation 
easier understand dynamic behaviour code clear predicate intended 
ffl reliable programs strong modes strong types eliminates class programming errors 
furthermore appropriate mode system help possible develop efficient programs incrementally 
initially program developed modes simple mode declarations impose constraints 
programmer go back refine precision mode declarations enable compiler generate efficient code 
way benefits strong modes available require possible prototype code quickly worrying modes mode systems useful providing control information coroutining parallel systems purely sequential systems re order conjunctions mode dependent computation rule report restrict attention sequential systems left right computation rule 
type system base mode system simple polymorphic regular tree style type system mo 
types represented trees recursive types allowed type tree conceptually infinite 
type system allows polymorphic types parameterized type variables 
considerable discussion type systems logic programming refer interested reader pfe vod 
believe ideas equally apply just reasonable type system shall dwell issue 
basic mode system remainder chapter develop theoretical foundation mode system 
avoid going details syntax implementation reader may find concepts easier understand looking examples section 
som attach mode information node type tree 
remarked earlier researchers considered notion modes believe approach novel aspects key insight note mode predicate considered mapping initial state instantiation arguments predicate final state instantiation 
point execution node type tree variable instantiatedness ffl practice author finds extra redundancy compile time checking provided strong typing possible develop working prototypes quickly optional type declarations omitted despite extra typing involved pun intended expect situation mode declarations 
ffl free ffl bound 
refer different possibilities instantiatedness instantiatedness tags 
instantiatedness tree assignment instantiatedness node type tree satisfies constraints ffl children free node 
ffl children bound node bound free 
ffl top level root node 
associate instantiatedness trees variables occurrences variables 
instantiatedness tree specify exact instantiation pattern binding variable bound node leaves corresponding value unspecified means instantiatedness tree include instantiatedness sub tree bound nodes just 
furthermore allow variables instantiated specified instantiatedness trees means specifying instantiatedness free doesn provide information just means possibly unbound 
contrast bound means definitely bound 
reason need define free way sharing different variables 
unify free variables unify variables constant variables bound 
try keep track possible sharing variables simply adopt conservative definition free 
node instantiatedness means node parent node may bound 
nodes may corresponding node variable current binding actual machine storage allocated existence case purely conceptual 
instantiatedness tag ensure correspondence nodes type tree nodes instantiatedness tree 
way viewing matters say instantiatedness tree maps subtree type tree leaves instantiatedness tree free nodes type tree may deeper instantiatedness tree 
choosing alternatives basically just aesthetic issue semantically little difference 
recursive types instantiatedness tree infinite completely unrolled type tree infinite 
introduce regular instantiatedness trees subset instantiatedness trees defined finite recursive definition 
practical implementations course restricted regular instantiatedness trees 
execution progresses variables may instantiated 
mode mapping initial instantiatedness final instantiatedness satisfies constraints execution progresses node may free bound instantiatedness tag free unique defined exception rule free unique nodes free 
free node may bound bound node free free node may 
correspondence modes modes language som give names modes familiar note corresponding modes unused free free free outbound bound outbound created free bound outbound inbound bound bound inbound possible mode tree assignment modes node type tree variable 
initial instantiatedness tree mode tree tree corresponding initial instantiatedness mode type tree 
similarly final instantiatedness tree mode tree tree corresponding final instantiatedness mode type tree 
possible mode tree genuine mode tree initial instantiatedness tree final instantiatedness tree satisfy constraints instantiatedness trees 
alternately mode mapping defined mapping initial instantiatedness tree final tree 
difference mode mapping mode tree mapping trees tree mappings 
syntax suggest mode mappings allow simple notation instantiatedness trees doesn need refer nodes 
mode mappings ground ground free ground correspond standard notions input output modes 
ground indicate mode tree nodes bound free context indicates mode tree top root node free nodes 
hand mode mappings express complex data flow patterns example easy express equivalent parlog weak input modes outer functor need bound cdb 
give examples discuss syntax chapter 
term approximated instantiatedness tree node type tree term ffl corresponding node term node free variable corresponding instantiatedness instantiatedness tree free ffl corresponding node term node functor constant corresponding instantiatedness instantiatedness tree free bound 
mode declaration predicate assignment mode tree argument position predicate 
mode declaration considered assertion programmer call predicate argument terms approximated initial instantiatedness trees mode declaration succeeds result binding argument terms turn approximated final instantiatedness trees mode declaration 
refer assertion associated mode declaration mode declaration constraint 
mode set predicate set mode declarations predicate 
impose constraints allowable mode sets ensure mode checking algorithm linear exponential 
mode set considered assertion programmer predicate called argument terms approximated initial instantiatedness trees mode declarations set specified mode declarations allowed modes predicate 
refer assertion associated mode set mode set constraint 
come defining 
want reject programs mode declaration constraints mode set constraints satisfied 
general undecidable problem compiler programmer 
want definition easy compiler determine easy programmer understand 
requiring global analysis entire program determining predicate moded require local analysis clauses predicate mode declarations called predicates 
prompts definition predicate moded respect mode declaration iff possible prove ffl corresponding mode declaration constraint correct ffl mode set constraints called predicates violated predicate ffl code predicate ffl assumption mode declaration constraints called predicates hold particular calls ffl details computation rule note proof definitions called predicates allowed mode sets 
ensures local analysis required 
reason definition phrased terms existence proof truth implication simply quite clear assumptions allowed 
definition merely theoretical chapter mode checking algorithm determine predicate moded respect mode proof exists 
offer proof soundness completeness algorithm 
soundness algorithm accepts predicates fairly obvious description algorithm completeness algorithm accepts moded predicates immediately obvious despite careful choice definition case modify algorithm ways definitely eliminate completeness order ensure linear exponential performance 
say predicate moded qualifications moded respect mode declarations mode set 
program moded predicates moded 
query moded respect program possible prove mode set constraints called predicates violated query 
assumptions allowed proof allowed proving predicate moded 
relationship interpretation instantiatedness trees defined form domain suitable interpretation 
mode checking corresponds loosely interpretation mode declarations available need single pass predicate necessary iterate multiple times fixpoint reached 
full interpretation type originally described myc yield mode inference algorithm 
extended mode system strong modes form defined basic mode system advantages previously discussed specific interest mode system capture data flow information required structure reuse destructive assignment 
proceed expand mode system record number term zero 
recording information mode system closely related way wadler embeds uniqueness information type system notion linear types functional languages wad wad concepts leads refined definition instantiatedness 
point execution node type tree variable instantiatedness ffl ffl free ffl bound ffl free unique indicating node type tree unbound variable live node note aware correspondence event somogyi modes represent unique producers som originally led investigate ideas 
ffl bound unique indicating node type tree bound variable live node ffl dead indicating variable referred 
instantiatedness tags possible specify mode predicates may safely re inputs returning free memory pool compile time garbage collection destructively updating 
example node mode initially bound unique may safely re dead 
mode mappings ground unique dead free unique ground unique correspond unique input arguments unique output argument modes analogous input output argument modes mentioned earlier possible express complicated mode mappings cases necessary 
order compiler mode information generate code destructive update necessary record additional details 
compile time garbage collection suffices record just nodes reusable case include additional instantiatedness tag ffl dead reusable indicating variable node type tree variable referred variable may safely re structure reuse destructive update necessary record value bound node bound nodes zero information available 
include additional instantiatedness tags ffl bound unique term ffl dead reusable term refined definition instantiatedness extended mode system leads refined definition instantiatedness tree 
instantiatedness tree assignment instantiatedness node type tree variable satisfies constraints ffl children free free unique 
ffl children bound unique dead reusable node bound free dead bound unique free unique dead reusable 
ffl children bound node bound free dead 
ffl top level node 
dead free unique bound unique dead free bound instantiatedness transitions forward execution execution progresses nodes variable type tree may instantiated term general sense strictly speaking instantiatedness tags encode information just free bound may slightly misleading 
possible transitions summarized defines partial order referring arrows go instantiated instantiated dead 
define mode transition initial instantiatedness final instantiatedness final instantiatedness instantiated initial instantiatedness 
aliasing section introduce instantiatedness tag var record aliasing information 
dead reusable dead reusable term bound unique term instantiatedness tags var intended internally compiler preprocessor intended directly programmer mode declarations 
remarked earlier attempt keep track possible sharing variables 
means circumstances may lose information 
example know bound 
situation occurs simply ignore issue 
especially true keep parts analysis simple mode checking algorithm introduces sharing sort 
improve precision mode system allow mode system record aliases occur variable known definitely identical 
allow aliases component variable node variable type tree root node different variable 
purposes introduce instantiatedness tag var 
traversing mode tree variable come node instantiatedness tag means actual instantiatedness node descendants obtained looking mode tree var tag means simply var alias node 
situations recording aliases transparent rest mode system remember dereference aliases necessary orthogonal informative name dead unique require changes 
aliases introduced encounter unification variables variable term containing variables 
example instantiatedness free see unification set instantiatedness tag vice versa difference 
see unification look instantiatedness find turn look instantiatedness turns free 
unifying free variable constant bind variable set new instantiatedness bound 
instantiatedness remains 
correctly determined unifications bound 
case recording aliases important unify variables instantiatedness free unique bound unique 
normally unify unique variables referenced unification variables multiply referenced lose uniqueness 
record alias consider equivalent single avoid losing uniqueness 
doing means slightly careful consider variable dead unique consider variables dead unique occurrence aliases 
alternative explored far keep compile time count variables 
polymorphic modes mode system quite precise fairly restrictive 
particular adequate representing modes predicates take arguments polymorphic types 
smallest example demonstrates difficulty unification predicate eq problem complicated examples append 
type eq 
polymorphic type type variable eq 
able provide small number mode declarations predicate suffice possible 
possible monomorphic mode system defined far 
different calls eq eq eq require mode declaration order mode system determine bound calls 
cater possible calls require infinite number mode declarations eq 
situation allow polymorphic mode declarations 
way polymorphic types allow specify type leaving unspecified value certain type variables polymorphic modes specify mode leave value certain instantiatedness variables unspecified 
example mode eq correctly handle cases mode eq 


instantiatedness variables 
mode declaration specifies eq may called initial instantiatedness arguments resultant final instantiatedness arguments correspond instantiatedness variable 
polymorphic modes declarations specify impossible mode free ground instantiatedness parameters declarations implicitly universally quantified variables ranging set instantiatedness trees resulting mode mappings consistent 
examples polymorphic mode declarations section 
chapter implementation overview ideal system strong modes types integral part language mode information compiler perform compile time garbage collection structure reuse destructive assignment optimization addition variety purposes discussed earlier 
short term practical implement mode system top conventional prolog prolog declarations mode annotations 
requiring compiler mode checking perform desired optimizations construct separate preprocessor task 
compiler need provide simple built predicates actual deallocation destructive assignments 
syntax mode annotations syntax mode annotations suggest follows 
standard prolog syntax clauses annotations form declarations 
mode declarations theory optional absence mode declaration system safely assign mode free free argument practice give mode declaration predicate generally need give mode declarations predicates calls avoid mode error 
start syntax types naish mycroft keefe type checker 
type list 
nil cons list 
type intlist list int 
type list list 
list extend firstly allow definitions instantiatedness trees inst definitions 
names free built inst definitions indicating instantiatedness tree top node indicated nodes 
names ground built inst definitions indicating instantiatedness tree nodes bound bound unique respectively 
addition allow explicit declaration complicated instantiatedness patterns example inst 
bound nil cons free 
inst 
nil cons 
inst definitions mode definitions defined mode mappings 
example mappings built mode input ground 
ground 
mode output free 
ground 
mode 
dead 
mode 

allow inst mode definitions polymorphic 
examples polymorphic definitions way inst 
bound nil cons 
inst free 
mode output free 
mode input 
mode output 
mode input 
arrive predicate mode declarations 
forms convenient predicates multiple modes pred length list int 
mode length input 
mode length output 
second form convenient predicates mode allows combine mode type declarations mode square int input int output 
square number mode input list input 
test membership predicate mode declarations may polymorphic 
parameters declarations implicitly universally quantified variables ranging set instantiatedness trees resulting mode mappings consistent 
give longer example leading mode declarations append 
inst 
bound nil cons 
mode 

mode free 

useful abbreviation uniq mode meaning mode instantiatedness tags free bound ground dead replaced unique versions 
alternative involves certain amount duplication inst 
nil cons 
mode 

mode 

basic modes append pred append list list list 
mode append 
mode append 
mode destructive append mode append 
append called arguments free generate infinitely solutions 
generally indicates programming error give mode declaration append 
effect achieved inserting explicit call list construction predicate necessary 
include mode declaration append called arguments free look mode append free free free free note final instantiatedness third argument simply free fact third argument may bound list uninstantiated tail 
free means possibly unbound definitely free discussed earlier 
plan syntax prototype preprocessor moment simplicity accepts subset constructs 
mode checking algorithm give simple algorithm mode checking basic mode system 
mode check check program moded 
predicate mode declaration predicate mode set clause predicate mode check clause mode check clause check clause moded 

move head unification body clause 
initialize instantiatedness trees variables head clause initial instantiatedness trees mode declaration predicate 
interpret goal body clause 
check instantiatedness trees variables head clause compatible final instantiatedness trees mode declaration predicate interpret goal goal instantiatedness trees non local variables goal determine instantiatedness variables executing goal 
done interpretation goal full interpretation know mode declarations called predicates locally single pass globally iterating fixpoint reached 

goal conjunction interpret goal half conjunction succession disjunction interpret goal half disjunction new instantiatedness trees greatest lower bound instantiatedness trees resulting half handling disjunctions discussed unification initialize instantiatedness trees new variables introduced unification ii 
abstractly unify instantiatedness trees terms unified predicate call firstly separate argument unification splitting call unifications followed predicate call arguments variables ii 
interpret goal unifications iii 
non deterministically choose mode declaration predicate called iv 
check instantiatedness trees argument variables compatible initial instantiatedness trees mode declaration predicate called replace instantiatedness trees argument variables final instantiatedness trees mode declaration predicate called real system handle cases cut various special built predicates note way handle disjunctions greatest lower bound may lose information may cause reject clauses moded definition chapter 
alternative mode check part clause follows disjunction twice possible mode disjunction assuming modes different 
avoid reasons firstly mode checking algorithm exponential number disjunctions secondly generated code depend modes cause size code generated compiler exponential number disjunctions 
feel rejecting clauses imposes great restriction language necessary programmer may achieve effect transforming clause bodies form resultant code duplication explicit 
mode check fails may back track different choice mode declaration called predicates 
may cause mode checking algorithm exponential length clause body 
avoid requiring initial instantiatedness arguments extended mode system knowledge variables textually dead call possibly uniquely determine resultant final instantiatedness arguments 
fact difficult ensure discuss 
suppose different mode declarations initial instantiatedness trees compatible current instantiatedness arguments 
cases cover 
firstly initial instantiatedness trees mode strict initial instantiatedness trees just choose mode 
example choose append ground 
ground 
free 
append free 
free 
free 
cases mode declarations 
secondly case check final instantiatedness trees different different modes 
cases final instantiatedness trees matching mode declarations anyway 
example arguments instantiatedness append ground ground ground matching mode declarations append ground ground ground ground free ground append free ground free ground ground ground final instantiatedness arguments definitely going append ground ground ground cases holds situation difficult 
approach final instantiatedness trees greatest lower bound final instantiatedness trees matching mode declarations want additionally ensure final instantiatedness trees instantiated initial instantiatedness trees 
rare cases lose information greatest lower bound result mode error predicate 
cases rare encountered examples problem occur case easy programmer fix problem simply adding new mode declaration called predicate specifies correct final instantiatedness 
return additional minor restrictions guarantee algorithm worst case time space usage linear number modes predicate times size program times size instantiatedness trees required proof offered believe clear description algorithm 
theory number modes predicate exponential number arguments practice tends quite small suspect having abnormally large number modes predicate probably indication predicate performs unrelated functions separated distinct predicates 
believe instantiatedness trees required typically small performance algorithm effectively linear size program 
far left things unspecified notion compatible instantiatedness trees greatest lower bound instantiatedness trees details unification instantiatedness trees 
quite simple instantiatedness tree compatible instantiatedness tree iff term approximated approximated compute obviously test possible term 
compare nodes trees partial order 
arrows diagram go information information 
node specifies information corresponding node compatible phrase information defined follows node specifies information node iff path arrows partial order diagram 
readers note diagram include necessary explore nodes determine compatibility 
strictly speaking spoken node instantiatedness just node previous paragraph 
understood practical implementation probably store nodes instantiatedness trees 
notion compatibility computed partial order instantiatedness tags turn defines partial order instantiatedness trees 
respect partial order take greatest lower bound 
bound unique term dead bound unique dead term free dead bound free unique information content partial order instantiatedness greatest lower bound operation combines information instantiatedness trees way resulting instantiatedness tree compatible original trees 
compute traversing original original trees simultaneously constructing nodes new tree go instantiatedness tag node new tree greatest lower bound instantiatedness tags original trees greatest lower bound instantiatedness tags defined terms partial order shown 
need continue traversing trees past nodes 
note fact algorithm slightly complex want preserve aliases original trees aliases trees course discarded 
unification operation basic mode system traverses trees similar manner greatest lower bound operation instantiatedness tags nodes new tree obtained upper bound partial order defined 
partial order corresponds instantiated opposed information 
extended mode system handle uniqueness variables death variables 
compile time garbage collection mode checking algorithm implementing compile time garbage collection structure reuse relatively simple 
compile time garbage collection extend mode system record nodes variable dead reusable discussed chapter 
simple modify mode checking algorithm inserts call return memory free list immediately instantiatedness node dead reusable case node root node 
case commonly occurs head unification argument mode mapping unique input 
example consider code 
mode sum list int dead int input int output 
sum 
sum xs sum xs 
mode checking algorithm moves head unification body clause abstractly interprets body determining instantiatedness trees variables goes 
annotated second clause show algorithm progresses 
sum ground unique bound free xs bound unique xs ground unique root node dead reusable nodes dead safely deallocate root node deallocate bound sum xs 
bound probably simplest way deal complex cases node dead reusable root node split complex unifications smallest possible units introducing fresh variables unification replaced ensures node root node easily reused dead reusable 
investigations compile time garbage collection purely theoretical unfortunately underlying implementation nu prolog run time garbage collection opportunity try ideas practice 
difficulties lost indexing potential problem code results applying optimization head unification moved body clause may lose clause indexing 
compiler may longer able detect argument sum bound clauses succeed code deterministic 
compiler fail detect determinism generate efficient code 
ways problem 
compiler smarter examine unifications head variables occur body clause just implicit head unifications analyzing code determine clause indexing 
course compiler may case problem won occur place 
second method generate auxiliary predicate passes additional arguments question 
method previous example result code sum sum 
sum 
sum xs deallocate sum xs 
unfold sum xs xs disadvantage method increased complexity compile time garbage collection optimizer additional overhead executing code 
recommend method method impractical example compile time garbage collection optimizer implemented stand preprocessor 
structure reuse structure reuse optimization similar compile time garbage collection deallocating unused memory returning memory management system reuse 
free unique variable unified constant functor know output unification 
mode checking algorithm cover case part unify operation modify algorithm encounters unification checks see memory required output unification obtained reusing allocated memory 
searching current instantiatedness trees variables clause searching dead reusable term node reused output unification 
theory node occupies right amount memory reused currently prototype reuse nodes functor term output primitive destructive assignment allow update arguments compound term functor 
find node reused determine arguments functor need replaced insert code destructively assign arguments replace output unification input unification unifies variable term just reused 
input unifications cheaper operations output unifications avoid allocating new heap space 
output unifications occur prolog programs occur part head unification 
increase opportunity structure reuse optimization delay output unifications moving clause 
delaying output unifications way important optimization right clause fails don execute output unifications course improvement deterministic code stated report concerned determinism analysis 
hand moving output unifications clause means lose call optimization definitely don want 
compromise clause predicate call mode output unifications just call clause 
example consider predicate squares elements list mode list int list int 

xs ys xs ys 
performed mode analysis inherent mode checking algorithm moved output unification obtain 
ground unique free unique xs input unification ground unique xs ground unique dead reusable xs ground unique read reusable ys output unification ys free unique bound unique ground unique ys xs ys 
xs dead ys ground unique reuse storage occupied output unification xs ys xs ys 
built predicate destructive assignment call effect replacing argument structure just compile time garbage collection situation complicated node reused root node decompose complex unifications simplest possible parts introducing fresh variables ensure dead reusable term nodes root node variable 
fw foster winsborough note structures contain variables safely reused live structure live variables 
constants nested structures pose problem copied registers decomposing structures 
variables hand copied way variable placed register 
solution foster winsborough adopt problem test runtime structure contains variables reuse doesn 
information provided mode system able selective 
concerned structure components replace matter arguments functor remain unchanged 
second examining instantiatedness tags components replaced determine compile time may live 
reuse structure know replacement safe instantiatedness node replaced bound unique dead reusable 
combining structure reuse compile time garbage collection course careful ensure nodes reused optimization deallocated 
destructive assignment structure reuse certainly helps room improvement 
passing pair arguments structure modified 
really want generate code passes single argument destructively updates argument way write code procedural language 
turns really difficult 
predicate contains argument initial instantiatedness free unique argument final instantiatedness dead predicate unifies variables possible just single argument position variables 
required replace occurrences free unique argument argument definition predicate calls predicate 
unifications assignments unnecessary eliminate unnecessary code 
predicate discussed previous section example 
destructive assignment optimization looks 
xs xs optimized xs xs optimized xs 
important example destructive append 
unfortunately standard code append immediately amenable destructive assignment optimization 
original source code mode append list list list 
append xs xs 
append xs ys zs append xs ys zs 
structure re optimization append append ys xs zs append xs ys zs 
problem base case clause unifies second third arguments recursive case structure reuse optimization unifies third arguments 
change clause append destructive assignment things fine difficulty assignment passed value original value changed possible combine third arguments single argument 
possible write append way apply destructive assignment optimization 
optimize case argument empty list allow case optimized adding auxiliary predicate 
auxiliary predicate obtained unfolding recursive call second clause 
append 
append append 
append ys ys 
append xs ys zs append xs ys zs 
structure reuse optimization auxiliary predicate looks append ys ys append ys xs zs xs append ys zs 
clauses unify third arguments arguments modes unique input unique output respectively apply destructive assignment optimization 
want apply common sub expression elimination avoid output unification note common sub expression elimination quite easily done time structure reuse optimization 
optimizations similar replaces output unification input unification replaces output unification destructive updates followed input unification 
final code append applying optimization follows 
append 
append append 
append ys ys 
optimized append ys zs optimized optimized append ys 
note require fairly smart compiler avoid losing indexing 
code append corresponds directly code main difference code needs auxiliary predicate loop code just statement inside statement 
smart prolog compiler recognize auxiliary predicate called point program generate code predicate inline generating subroutine call 
list append list list null return list tmp tmp tail null tmp tmp tail tmp tail return main drawback approach programmer carefully unfold code append similar predicates compiler apply destructive assignment optimization 
desirable declaration compiler directive instructed compiler generate auxiliary predicate unfold code automatically 
results process implementing prototype preprocessor structure re optimization sequential nu prolog 
preprocessor performs source level transformation introduces calls nu prolog built primitive perform actual destructive updates simple convert preprocessor prolog provides appropriate primitives 
unfortunately prototype complete stage provide statistics time taken mode checking algorithm performed transformation manually common algorithms provide statistics execution time memory usage transformed programs 
programs versions quicksort simple version append plus difference list version naive reverse chosen simply benchmark append 
performed structure reuse optimization algorithm described earlier measured effect performing destructive assignment optimization append 
quicksort amenable destructive assignment optimization done partition procedure 
procedure partitions unique input argument unique output arguments having matching pair arguments unique input unique output 
algorithm method cpu time ms heap space bytes naive quicksort difference list quicksort naive reverse table performance measurements simple programs statistics sorting reversing list random integers 
version built destructive update predicate omits run time tests 
due space limitations include code obtain statistics appendix code available author request 
results show cases structure reuse optimization slows code factor saves dramatically heap space usage quicksort reverse reuse memory occupied input arguments 
results show destructive assignment optimization append huge difference speed appending long lists occurs naive reverse benchmark 
reason slow structure reuse working low level nu prolog built predicate destructive assignment implemented efficiently 
working compiler level expect improvement times 
nu prolog compiler compiles byte code interpreted useful measurements compiler compiled machine code certainly case destructive assignment implemented efficiently machine level 
difference speed exaggerated measurements 
genuine industrial prolog systems nu prolog run time garbage collection time original versions include time required garbage collect heap space consumed 
unfortunately time comparisons basically useful meaningful 
able compare speed linked list version quicksort array version course prolog doesn arrays 
interesting simulate arrays functors arg array indexing done 
compare speeds programs written nu prolog uses byte code interpreter unfair comparison fair comparison need prolog compiler compiles machine code 
chapter logically sound declarative unique modes major problems prolog widespread side effects nonlogical code 
major reasons code prolog efficiency input output 
destructive assignment optimization negates need sideeffects efficiency show unique modes provide clean logical alternative traditional technique side effects input output 
basic idea quite simple 
model change state implicit traditional approach input output providing explicit state world variable passed different predicates program 
real world allow previous states linger program 
model making mode state world variable unique mode occurs program 
changes state undone backtracking possible trail input output 
determinism analysis mentioned 
program entry predicate mode mode main list string 
modes predefined modes explained chapter 
argument list strings command line passed program 
arguments represent state world execution program 
type built data type input output predicates modes type 
char eof 
type getchar 
preferable io state data type exported standard input output module course require language include sort module system 
note predicate names functions departed int represent character file 
logically represented disjoint union done 
smart compiler notice type represented single machine word generate code anyway 
type putchar char 
mode putchar input 
simple cat program copies input output look main input output cat input output 
mode cat 
cat state state getchar state state cat state state 
mode cat input 
cat eof state state 
cat char state state putchar char state state cat state state 
logically pure require extra shuffling state arguments 
difficult get compiler optimize variables done special case generally ensure compiler optimizes variables unit types types value optimization commonly done functional languages define unit type 
hand argument shuffling burden programmer difficult cleanly avoid 
wave wand magical syntactic tricks prolog definite clause grammar notation extra 
main 
cat 
cat 
cat 
getchar cat 
cat input 
cat eof 
cat char 
putchar char cat 
declarations abbreviations longer mode declarations 
similar continuation passing style input output functional languages ability output modes examples argument getchar functional languages gives pleasant syntax 
result code superficially looks conventional languages built genuinely pure logical foundation 
chapter believe strong type strong mode systems combined type mode inference herald new era logic programming languages compared current languages hold promise greatly improved efficiency greater reliability expressiveness elimination need logically impure code side effects 
shown simple practical method structure reuse destructive assignment optimization built top strong mode system 
discussed new paradigm logical unique modes 
process implementing simple prototype techniques preprocessor sequential nu prolog 
bibliography cdb jim andrew davison alastair burt matthew lam 
parallel parlog user manual 
parlog group department computing imperial college london june 
cg keith clark steve gregory 
notes implementation parlog 
journal logic programming april 
fw ian foster winsborough 
copy avoidance compile time analysis local reuse 
vijay saraswat ueda editors logic programming proceedings international symposium pages san diego usa 
mit press 
hsc bruce holmer barton sano michael carlton peter van roy ralph william bush alvin despain joan tep 
fast prolog extended general purpose architecture 
proceedings seventeenth annual international symposium computer architecture pages may 
mo mycroft richard keefe 
polymorphic type system prolog 
artificial intelligence 
anne william winsborough maurice bruynooghe 
analysis shared data structures compile time garbage collection logic programming languages 
proceedings seventh international conference logic programming pages june 
myc alan mycroft 
interpretation optimising transformations applicative programs 
phd thesis university edinburgh scotland 
nai lee naish 
negation control prolog 
number lecture notes computer science 
springer verlag new york 
pfe frank pfenning editor 
types logic programming 
mit press 
rd van roy despain 
benefits global flow analysis optimizing prolog compiler 
proceedings second north american conference logic programming october 
som zoltan somogyi 
parallel logic programming system strong precise modes 
technical report university melbourne january 
tay andrew taylor 
lips mips results prolog compiler risc 
proceedings seventh international conference logic programming june 
tz james thom justin zobel 
nu prolog manual version 
technical report department computer science university melbourne melbourne australia 
vod paul 
types 
proceedings fifth international conference symposium logic programming pages 
wad philip wadler 
linear types change world 
proceedings ifip tc conference programming concepts methods pages april 
wad philip wadler 
linear logic 
proceedings symposium partial evaluation semantics program manipulation 
war warren 
implementing prolog 
dai research report university edinburgh scotland 
