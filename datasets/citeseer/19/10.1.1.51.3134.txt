state constraints revisited fangzhen lin ray reiter department computer science university toronto toronto canada email fl ai toronto edu reiter ai toronto edu march appear journal logic computation 
special issue actions processes 

fellow canadian institute advanced research pursue perspective reiter situation calculus formalize primitive determinate actions axioms include disjoint sets set successor state axioms set action precondition axioms 
posed problem automatically generating successor state axioms set effect axioms set state constraints 
special version traditionally called ramification problem 
surprise state constraints role yield indirect effects actions 
implicit axioms action preconditions 
intimately related classical qualification problem 
discovered kinds state constraints arise related formalization strategic control information 
devoted describing results lines focusing ramification qualification state constraints 
specifically propose step procedure determining axiomatization monotonically solves versions ramification qualification problems 
justify step semantically appealing suitable minimization policy 
step justify simple clark predicate completion 
pursue perspective reiter situation calculus formalize primitive determinate actions axioms include disjoint sets set successor state axioms set action precondition axioms 
reiter shows obtain successor state axioms purely syntactic manipulations effect axioms causal rules called 
address ramification problem approach fails presence state constraints 
attempt remedy posed problem automatically generating successor state axioms set effect axioms set state constraints 
surprise state constraints role yield indirect effects actions 
implicit axioms action preconditions 
constraints relate qualification problem way indirect effects ramification problem 
learned observation ginsberg smith 
discovered kinds state constraints arise related formalization strategic control information 
devoted describing results lines focusing constraints relevant indirect effects action preconditions 
particular propose step procedure determining axiomatization monotonically solves versions ramification qualification problems 
justify step semantically appealing suitable minimization policy 
step justify simple clark predicate completion 
roughly speaking action primitive defined terms actions 
see lesp erance levesque lin reiter scherl forthcoming approach complex actions situation calculus 
problem illustrate example 
free variables formula considered universally quantified outside 
consider painting blocks world action paint paints block color represented effect axiom oss paint oe color paint action oss means action possible robot perform paint close necessary paint oss paint oe nearby state constraint block just color color color oe known addition axioms need called frame axioms 
case property color oss paint oe oe color paint color axioms axiom allows infer possible paint 
order act need guarantee possible paint 
normally absolute guarantee exist 
example order paint block clear paint frozen dilemma instance traditionally called qualification problem mccarthy 
assumption need solving problem particular example condition prevents robot executing paint implied axioms 
case simple predicate completion clark oss paint nearby expect formally done minimizing oss lifschitz 
unfortunately general case minimization straightforward especially presence frame problem 
particular solve frame problem qualification problem 
answer solve qualification problem 
axioms oss form implicitly assumed order really matter 
general shall assume necessary frame axioms compute oss 
shall see motivation assumption 
assumption implicitly ginsberg smith 
qualification problem gets complicated axioms oss explicitly 
traditionally state constraints considered yield indirect effects actions sources ramification problem finger 
shall see state constraints fact implicit axioms oss 
state constraints complicate qualification problem way indirect effects frame problem 
imagine ancient kingdom yellow reserved emperor 
robot world respects rule color yellow result robot sure initially block yellow allowed paint block yellow oss paint yellow simply logical consequence effect axiom constraint 
state constraints straightforward fun 
imagine lenient emperor tolerates single yellow block color yellow color yellow oe poor robot time sure initially block yellow yellow block paint block yellow painting yellow block different color color yellow oe oss paint yellow notice time necessary condition executing paint deduced effect axiom state constraint 
derive frame axiom 
need determined frame axioms computing oss 
example illustrates importance distinguishing indirect effect yielding state constraints state constraints 
syntactically constraints similar 
pragmatic roles different 
example compute indirect effect paint conclude logical consequence painting block yellow cause existing yellow block change color oss paint yellow oe color yellow oe color yellow paint yellow hand taken account generating frame axiom effect axiom law inertia oss paint oe oe color paint color compute oss frame axiom conclude incorrectly impossible paint block different color color oe oss paint yellow paint may available purpose say making orange paint 
conclude state constraints play different roles axiomatization 
contributes ramifications paint contributes new information oss 
reversing roles leads counterintuitive results 
shall call indirect effect yielding state constraints ramification constraints yielding action preconditions qualification constraints 
ginsberg smith shall explicitly distinguish kinds constraints 
summary ramification constraints cause complications traditionally called ramification problem frame problem 
qualification constraints cause symmetric problem qualification problem 
section version situation calculus 
describe approach solving problems 
discrete situation calculus clear serious study situation calculus requires foundational principles analogous ways peano foundational axioms number theory 
obvious counts appropriate axiomatization peano situation calculus axioms intuitively appealing useful ways 
formulating true set foundational axioms exploring meta mathematical properties remains ongoing goal research program 
usual shall sorted language situation calculus 
domain independent sorts situation action 
emphasize sort action primitive actions 
unique situation constant symbol denoting initial situation 
number peano arithmetic 
peano arithmetic unique successor function family successor functions modeled binary function action theta situation situation 
place peano axioms oe oe oe axioms unique names assumptions 
eliminate finite cycles merging 
axiom second order induction 
amounts domain closure axiom situation obtained initial applying function 
discussion induction situation calculus see reiter :10.1.1.38.3791
reality action executable situation 
formalize binary predicate oss 
write obtained sequence executable actions 
inductively oss shorthand shall denote sigma set axioms far including ones 
clear second order induction axiom situation domain model sigma isomorphic smallest set satisfying 

domain actions model 
sigma categorical sort situation 
axioms origin reiter :10.1.1.38.3791
similar axioms pinto reiter 
proposition summarizes simple consequences sigma 
proofs appendix 
proposition transitivity oe anti reflexivity unique names oe induction oss oe oe oe addition domain independent sorts may domain dependent sorts 
sequel shall assume fixed additional sort object objects domain interest 
shall primed subscripted versions denote variables ranging domain object 
ary fluent predicate arity object theta situation 
ary action prototype function arity object action 
shall assume set unique names axioms denoted una actions 
axioms forms xn yn oe delta delta delta xn yn xm yn different action prototypes 
ramification problem section deals frame problem presence ramification constraints 
solutions proposed literature cf 
baker lin shoham circumscription mccarthy 
consensus different minimization semantics turn equivalent determinate actions cf 
costello kartha 
section defines precisely minimization policy 
lin shoham 
differences 
lin shoham minimization done respect fixed action 
minimization actions simultaneously 
secondly axioms lin shoham deal oss predicate 
reflecting decision solve frame problem minimization policy shall fix oss 
motivate minimization policy consider language single action states initial resulting state action performed cf 
lifschitz 
fluent replace predicates tuple xn xn stands xn xn xn 
consider action load loads gun 
suppose unary fluents loaded alive 
fluents yield propositions loaded gun initially loaded loaded gun loaded performing load alive fred alive initially alive fred alive performing load 
consist axioms loaded ab loaded loaded ab alive alive intuitively want minimize ab ab formalize law inertia 
question predicates fixed allowed vary 
mccarthy original proposal predicates allowed vary conclude counter intuitively ab ab implies loaded gun loaded initially 
little thought reveals fix initial situation loaded alive allow resulting situation vary 
formally minimize ab ab loaded alive fixed ll conclude correctly ab loaded ab normally situation calculus formalize actions effects depend starting situation past irrelevant sufficient capture effects action respect generic starting resulting situations 
seen done minimizing changes starting situation fixed 
exactly minimization policy 
recall language sorts situation action object 
shall divide variable assignment oe parts oe oe oe assigns variables sort situation second variables sort action third variables sort object 
definition model theory minimal iff model variable assignment situations oe 
universe 

differ interpretations fluents 
particular interpret oss 

assignment oe fluent xn oe oe xn iff oe oe xn 
assignments oe oe fluent xn oe oe oe oss ab xn oe oe oe ab xn ab xn shorthand xn xn 
assignments oe oe fluent xn oe oe oe oss ab xn oe oe oe ab xn circumscriptive specification ramification problem minimization policy hand position provide take semantic specification counts solution ramification problem 
precisely characterize axioms minimized 
general suppose addition foundational axioms sigma unique names axioms actions una sets axioms 
set ef effect axioms form oss oe psi oe xn form oss oe psi gamma oe xn ary fluent psi psi gamma simple state formulas free variables xn simple state formula mention oss situation term unique situation variable 

set ram ramification constraints form rc rc simple state formula unique free variable axioms hand identify solution ramification problem minimal models sigma una ram ef section give independently motivated syntactic procedure sigma una ram ef computes certain monotonic theory show suitable circumstances monotonic theory logically equivalent minimal model nonmonotonic theory 
compute successor state axioms reiter shows address frame problem absence state constraints 
idea effect axioms compute set explanation closure axioms schubert 
assumption effect axioms completely describe causal laws domain axiomatized explanation closure axioms seen intuitively force frame axioms 
natural consistency assumption axioms effect explanation closure axioms shown logically equivalent set successor state axioms 
particularly simple computationally useful form shall describe 
words effect axioms hand provides conceptually computationally simple solution frame problem 
unfortunately solution frame problem longer applies presence ramification state constraints 
reason solution relies prior availability effect axioms explicitly hand explanation closure successor state axioms computed 
state constraints possible derive new effect axioms old effect axioms constraints 
words longer certain effect axioms explicitly hand purpose determining successor state axioms 
possibility implicit effect axioms frame problem difficult state constraints 
implicit effect axioms explicit deduction effect axioms ramification constraints compute successor state axioms solving frame problem 
intuition approach frame problem section 
axiomatization sigma una ram ef described task generate successor state axiom reiter fluent xn oss oe xn phi phi simple state formula free variables xn having explicit successor state axioms desirable reasons 
shown reiter successor state axioms computationally appealing allow regression waldinger pednault property shall shortly exploit 
secondly clear having set successor state axioms completely formalizes effects actions fluents 
discussion section suggests ary fluent xn determine positive effect axioms derivable state constraints effect axioms including course effect axiom ef sigma una ef ram xn oss oe xn oe xn 
sigma una ef ram xn oss oe xn oe xn simple state formulas 
sure got collect single effect axiom sigma una ef ram xn oss oe psi oe xn psi xn simple state formulas equivalent delta delta delta similarly find single negative effect axiom sigma una ef ram xn oss oe psi oe xn psi psi general condition true false situation argument reiter yields successor state axiom oss oe xn psi xn psi know determined positive negative effect axioms amounts thing psi psi general condition true false 
theorem gives sufficient conditions successor state axioms determined way correct respect minimal model semantics section 
theorem ss set successor state axioms fluent form oss oe xn psi xn psi xn ary fluent psi psi satisfy respectively 
suppose 
consistency condition reiter holds una xn psi psi 
ramification constraints relativised states accessible derivable successor state axioms sigma una ss frc oe rc rc ram order structure minimal model sigma una ram ef iff model sigma una ss gamma ram ram gamma ram set ramification constraints relativised states accessible gamma ram oe rc rc ram ram set ramification constraints restricted initial state ram frc rc ram 
theorem says conditions nonmonotonic theory sigma una ram ef minimization policy section captured monotonic theory sigma una ss gamma ram ram 
generally shown initial state description ds ram conditions theorem satisfied nonmonotonic theory sigma una ram ef equivalent monotonic sigma una ss gamma ram ds 
notice gamma ram included monotonic theory successor state axioms characterize action effects action possible 
practise turns consequence normally monotonic theory derive entailments relativised situations accessible example ai planning applications concerned deriving entailments form defines goal state green reiter 
database applications reiter concerned querying database update transaction sequence queries form denotes database state resulting performing sequence updates starting initial database state normally state known accessible say preconditions executing transaction sequence known true reiter calls states legal states 
settings planning problems database query evaluation entailments interest relativised situations accessible clear purpose deriving entailments kind sentences gamma ram role play purpose deriving entailments relativised situations accessible gamma ram ignored sufficient monotonic theory sigma una ss ds shall consider general case theorem greater detail moment 
treat important special case 
ram elementary syntactic manipulations reiter provably correct respect minimal model semantics corollary correctness successor state axioms absence state constraints reiter suppose ram loss generality fluent suppose ef contains exactly positive effect axiom exactly negative effect axiom 
successor state axiom defined reiter exactly 
consistency condition holds order structure model sigma una ss iff minimal model sigma una ef return general case theorem 
theorem suggests approach derivation successor state axioms ramification constraints ram effect axioms ef 
ram ef derive set effect axioms forms compute corresponding successor state axioms 

deriving new effect axioms verified entailments hold 
case ss corresponding successor state axioms equivalent monotonic theory sigma una ss gamma ram ram clearly procedure guaranteed terminate 
pinto studies simple classes state constraints set successor state axioms effectively computed 
shall consider examples 
doing prove lemma facilitate proof condition normally require induction situations reiter proposition :10.1.1.38.3791
lemma induction proof reducing theorem proving task simple entailment unique names axioms actions 
formulate lemma require concept regression formula psi psi regression psi set successor state axioms ss cf 
waldinger pednault reiter result substituting phi ff oe subformula ff oe mentioned psi substitution performed fluent mentioned psi 
phi xn successor state axiom 
shall write psi psi possibility confusion 
instance successor state axiom oss oe lip lip shown independently propositional fluents steven shapiro 
regression lip lip lip lip lip regression oe oe lip lip notice regression purely syntactic manipulation may preserve logical properties 
instance regressions logically equivalent formulas generally equivalent 
lemma ramification state constraint rc sigma una ss frc oe rc iff una rc oss oe rc example derive set successor state axioms painting example 
rewrite causal rule oss oe paint oe color rewrite ramification constraint color oe oe color axioms infer oss oe paint oe color axiom causal rule psi color paint psi color paint get successor state axiom oss oe paint color paint effect axioms nearby psi nearby psi nearby alse 
get oss oe nearby alse nearby alse equivalent oss oe nearby nearby similarly oss oe remains check conditions theorem verify set successor state axioms obtained right 
consistency conditions unique names axioms actions entail psi color psi color 
psi nearby psi nearby psi psi identically true 

deriving ramification constraints state constraint denote rc rc color color oe lemma need show una frc oss fr color color successor state axiom color equivalently written oss oe paint color paint need show una frc oss paint color paint paint color paint proved cases follows ffl una frc oss paint paint follows unique names axioms actions 
ffl una frc oss paint color paint holds premises inconsistent 
ffl una frc oss paint color paint holds inconsistency premises 
ffl una frc oss color color paint follows rc color color 
general proof theoretic procedure complete simply may multiple minimal models 
minimal model unique may captured set successor state axioms 
fact may captured order theory 
example ternary fluents action constant 
consider ef ram 
ef oss oe oe 
ram oe oe order theory capturing minimal model theory order sentence oss entail transitive closure known order definable 
determining action precondition axioms section concerns qualification problem large degree independent section 
assume means succeeded obtaining set successor state axioms ss symmetric treatment ramification problem assume sets 
set nec direct necessary conditions oss form oss xn oe pi xn ary action prototype pi simple state formula free variables xn 
set qual qualification constraints form qc qc simple state formula unique free variable goal generate set action precondition axioms action prototype form oss xn theta theta simple state formula free variables xn qc qual qualification constraint clear action xn ss xn oss xn oe qc xn qc xn regression operator defined section 
ss qual xn oss xn oe qc xn formula qc xn defined usually unwieldy 
cases need simplified qual unique names axioms una shall see example 
pi qc simple state formula una qual xn qc xn pi qc una ss qual xn oss xn oe pi qc loss generality suppose necessary condition axiom nec oss xn oe pi obtain action precondition axiom predicate completion clark oss oss xn pi pi qc big conjunction ranges state constraints qual pre set action precondition axioms obtained 
theorem ss qual pre 
cls domain closure axiom actions delta delta delta action prototypes 
qualification constraint qc qual sigma una ss pre cls qc oe oe qc proof principle induction proposition corollary sigma una ss pre cls gamma qual qual qual gamma qual set qualification constraints relativised states accessible gamma qual oe qc qc qual qual set qualification constraints restricted initial state qual qc qual corollary interest 
tells provided initial state satisfies qualification constraints qc qc entailed axioms specifying initial state constraints entailed background theory sigma una ss pre cls gamma qual means ramification constraints discarded effects compiled action precondition axioms 
highlights difference solution qualification problem ginsberg smith 
action qualifications stored computed time action attempted 
notice background axioms corollary include gamma qual original qualification constraints relativised states inaccessible recall precisely situation arose earlier treatment ramification constraints theorem gamma ram included monotonic theory equivalent nonmonotonic minimal model semantics 
observed theory derive entailments relativised situations accessible normal case axioms gamma ram play role discarded 
exactly observation applies case corollary purpose deriving entailments relativised situations accessible gamma qual ignored sufficient background axioms sigma una ss pre cls example derive action preconditions painting example 
nec consists axiom oss paint oe nearby shall consider world yellow block allowed qual consists 
write qualification constraint qc 
qc color yellow color yellow oe ss set successor state axioms generated example 
unique names axiom actions paint paint oe qc paint simplified yellow color yellow yellow yellow color yellow yellow oe qual simplified yellow color yellow yellow color yellow oe equivalent color yellow yellow oe pi qc formula obtain action precondition axiom entails oss paint nearby color yellow yellow oe notice procedure computing action precondition axioms theorem explicitly relies regression prior availability set successor state axioms ss assume computed methods section 
having done apply method section compile qualification constraints 
resulting set sentences sigma una ss pre cls take monotonic theory solving frame ramification problems 
examples qualification constraints theory including set successor state axioms generation action precondition axioms straightforward regression seen section 
result simple potential applications 
action may conditions action carried physically 
example order move block block clear order turn light robot near switch 
observed earlier kind precondition encoded directly necessary action precondition axiom 
cases conditions best formalized state constraints 
example block world block put top kinds preconditions naturally encoded qualification constraints 
restrict behavior robot putting constraints desired states 
example robot motion planning don want robot running obstacles obstacle oe contact vladimir lifschitz example 
tower hanoi rules game bigger disc top smaller bigger oe employee salary database may policy employee salary exceed supervisor sal sal supervisor oe far considered state constraints represented simple state formulas 
called static integrity constraints database theory 
see reiter situation calculus treatment database updates 
particularly interesting kinds formulas constrain action preconditions 
example standard dynamic integrity constraint employee salary decrease represented sal sal oe suppose successor state axiom salary update change means change salary oss oe change sal change regressing dynamic integrity constraint get necessary condition oss change oss change oe sal oe general remarks necessity qualification constraints 
purpose qualification constraint generate necessary conditions oss may ask just supply conditions directly 
argue intuition deciding constraint qualification constraint enforced action preconditions 
reasons don want list action preconditions explicitly 
entirely eliminate need constraints check initial state satisfies constraint corollary 

ginsberg smith argued computational epistemological reasons listing action preconditions explicitly won 

generating preconditions state constraints results modular generic theory 
illustrate point suppose want tell robot crack floor room way cross 
examine robot knowledge base find actions change position add precondition actions executable robot destination side crack starting position 
uniform modular elegant way tell robot dynamic constraint considered semantics crack robot robot oe robot generate correct preconditions 
kinds state constraints remarked earlier state constraints different ramification qualification ones 
moment don full story 
clear examples 
certain control strategies best formalized state constraints purpose compute effects actions generate action preconditions 
example absolutely useless repeat state equiv oe dont dont means don action equiv means equivalent robot point view 
instance relevant fluent robot color equiv color color notice difference oss dont assume robot carry action oss satisfied 
dont true robot carry action may best interest 
robot unaware painting red block red achieves prevent doing 
examples kind control oriented state constraints consider game playing 
player avoid move certainly result loss loss oe dont example step look ahead player game oss loss oe dont kind lookahead analogous alpha beta pruning minimax achieved 
began observing ginsberg smith kinds state constraints corresponding ramifications qualifications 
contribute indirect effects actions implicit axioms oss 
proposed step procedure determining axiomatization monotonically solves ramification qualification problems 
determine effect axioms ramification constraints set successor state axioms 
done computing set new effect axioms old ones constraints completing resulting set effect axioms method reiter 
sufficient condition theorem determining new effect axioms determined 
point ramification constraints discarded favour successor state axioms 

secondly appealing regression successor state axioms computed step qualification constraints determine set action precondition axioms 
point qualification constraints discarded favour action precondition axioms 
justified step semantically appealing minimization policy lin shoham 
step justified simple clark predicate completion 
result step process proposed axiomatization monotonically solving ramification qualification problems sigma una ss pre cls ffl sigma consists foundational axioms situation calculus 
ffl una unique names axioms actions 
ffl ss successor state axioms computed step 
ffl pre action precondition axioms computed step 
ffl cls domain closure axiom actions 
ffl ds initial state axioms include ramification qualification constraints restricted initial state 
far know attempt literature solve ramification qualification problems providing explicit concise monotonic axiomatization 
haven achieved 
step approach solving ramification qualification problems computed successor state axioms ignoring qualification constraints axioms giving explicit necessary conditions oss 
second step axioms taken account 
means semantically applying step minimization policy 
conceivable appropriate uniform minimization policy result simultaneously computing successor state action precondition axioms 
unfortunately idea moment correctly done 
step process justified informally intuition performing action leads state violates qualification constraint action impossible carry real world 
order know performing action lead violation constraint need relevant knowledge effects action say need frame axioms 
technically means compute oss state constraints regression relies prior availability set successor state axioms 
problematic aspect solution provide syntactic way distinguishing ramification qualification constraints 
unsatisfying situation worse fact conjoining ramification constraint qualification constraint leads syntactically acceptable constraint type 
observed kinds state constraints distinct ramifications qualifications appear control oriented 
intuition intimately related various deontic notions explore idea depth 
wish vladimir lifschitz javier pinto richard scherl helpful discussions comments earlier drafts 
research supported part government canada institute robotics intelligent systems part national science engineering research council canada 
appendix proofs proposition transitivity oe anti reflexivity unique names oe induction oss oe oe oe proof transitivity 
apply induction sentence entailed axiom 
inductively assume oe prove oe 
suppose 
prove 
axiom equivalent oss inductive assumption disjunct assumed implies 
second disjunct implies oss implies 
induction axiom transitivity axiom holds 
anti reflexivity 
induction applying transitivity axiom inductive step 
unique names 
follows anti reflexivity rewriting oe induction 
stand oe instantiate induction axiom proving theorem prove lemma 
lemma ramification state constraint rc sigma una ss frc oe rc iff una rc oss oe rc proof part straightforward induction proposition 
prove part 
suppose sigma una ss frc oe rc prove una rc oss oe rc suppose model una suppose oe oe variable assignments state action variables respectively oe oe rc oss 
show oe oe rc 
construct 
share domains sort action sort object 

interprets state independent predicate state independent function 
sigma 

variable assignment object variables oe fluent oe iff oe oe 

oss 

ss clearly oe sigma una ss frc fp oss assumption oe rc 
ss oe oss oe rc iff oe rc 
rc result replacing rc construction oe rc iff oe oe rc oe oe rc 
proves part lemma 
theorem ss set successor state axioms fluent form oss oe xn psi xn psi xn ary fluent psi psi satisfy respectively 
suppose 
consistency condition reiter holds una xn psi psi 
ramification constraints relativised states accessible derivable successor state axioms sigma una ss frc oe rc rc ram order structure minimal model sigma una ram ef iff model sigma una ss gamma ram ram gamma ram set ramification constraints relativised states accessible gamma ram oe rc rc ram ram set ramification constraints restricted initial state ram frc rc ram proof model sigma una ss gamma ram ram show minimal model sigma una ef ram show model theory 
consider fluent suppose oss oe psi oe ef recall construction psi equivalent formula form delta delta delta psi sigma una psi oe psi sigma una ss oss oe psi oe similarly addition consistency condition show fluent oss oe psi gamma oe ef sigma una ss oss oe psi gamma oe sigma una ss ef sigma una ss gamma ram ram ram implies 
assumption model model 
suppose model oe variable assignment situations 
universe 

differ interpretations fluents 

assignment oe object variables fluent xn oe oe xn iff oe oe xn assignments oe oe action object variables respectively fluent xn suppose oe oe oe oss ab xn model ss oe oe oe psi oe oe oe psi psi way psi psi satisfy respectively model model left hand side conclude oe oe oe ab xn definition minimal models section conclude minimal model 
minimal model 
show model 
construct structure follows 
universe interpret truth values fluents 

interpret fluents assignment oe fluent xn oe xn iff oe xn 
inductively variable assignment oe oe oss fluent xn oe xn iff oe xn oe oss fluent xn assignment oe oe oe oe oe oe xn iff oe psi xn psi psi psi 
clearly defined 
claim model 
clear need show model gamma ram fact claim model ram prove induction 
rc ram construction agrees satisfies rc 
oe assignment situation variables 
assume inductively oe rc show assignment oe action variables oe oe rc cases 
oe oe oss construction agrees satisfies rc 
suppose oe oe oss 
condition lemma una rc oss oe rc oe oe rc 
oe oe fp oss ss oe oe rc 
induction rc 
ram show induction 
construction agree oe assignment situation variables 
inductively assume agree oe oe xn iff oe oe xn assignment oe object variables 
show oe oe oe xn iff oe oe oe xn assignments oe oe action object variables respectively 
cases 
oe oe oe oss follows construction assume oe oe oe oss model proved part proof oe oe oe ab xn oe oe oe ab xn 
minimal oe oe oe ab xn iff oe oe oe ab xn agree agree 
induction model 
andrew baker 
nonmonotonic reasoning framework situation calculus 
artificial intelligence 
keith clark 
negation failure 
gallaire minker editors logics databases pages 
plenum press new york 
tom costello 
solutions ramification problem 
working papers nd symposium logical formalizations commonsense reasoning pages austin texas 
jeff finger 
exploiting constraints design synthesis 
phd thesis department computer science stanford university stanford ca 
matthew ginsberg david smith 
reasoning action ii qualification problem 
artificial intelligence 
green 
application theorem proving problem solving 
proceedings international joint conference artificial intelligence ijcai pages 
kartha 
soundness completeness theorems formalizations action 
working papers nd symposium logical formalizations commonsense reasoning pages austin texas 
vladimir lifschitz 
formal theories action 
proceedings tenth international joint conference artificial intelligence ijcai pages 
vladimir lifschitz 
frames space situations 
artificial intelligence 
vladimir lifschitz 
restricted monotonicity 
proceedings eleventh national conference artificial intelligence aaai 
fangzhen lin yoav shoham 
provably correct theories action preliminary report 
proceedings ninth national conference artificial intelligence aaai anaheim ca 
john mccarthy 
epistemological problems artificial intelligence 
ijcai pages 
cambridge ma 
john mccarthy 
applications circumscription formalizing commonsense knowledge 
artificial intelligence 
john jules ch 
meyer 
different approach deontic logic deontic logic viewed variant dynamic logic 
notre dame journal formal logic 
john jules ch 
meyer hans wieringa 
specification language static dynamic deontic integrity constraints 
thalheim editors proceedings nd symposium mathematical fundamentals data base systems pages 
lncs 
edwin pednault 
synthesizing plans contain actions contextdependent effects 
computational intelligence 
javier pinto 
temporal reasoning situation calculus 
phd thesis department computer science university toronto toronto canada february 
javier pinto raymond reiter 
extending situation calculus event occurrences 
second symposium logical formalizations commonsense reasoning 
raymond reiter 
simple solution frame problem 
technical report department computer science university toronto 
preparation 
raymond reiter 
frame problem situation calculus simple solution completeness result goal regression 
vladimir lifschitz editor artificial intelligence mathematical theory computation papers honor john mccarthy pages 
academic press san diego ca 
raymond reiter 
specifying database updates 
technical report department computer science university toronto 
krr tr 
raymond reiter :10.1.1.38.3791
proving properties states situation calculus 
artificial intelligence 
len schubert 
monotonic solution frame problem situation calculus efficient method worlds fully specified actions 
loui carlson editors knowledge representation defeasible reasoning pages 
kluwer academic press boston ma 
steven shapiro 
order solutions frame problem 
sc 
thesis department computer science university toronto toronto canada 
richard waldinger 
achieving goals simultaneously 
michie editors machine intelligence pages 
ellis horwood edinburgh scotland 
