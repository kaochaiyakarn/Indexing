type system object initialization java tm bytecode language stephen freund john mitchell department computer science stanford university stanford ca cs stanford edu phone fax april standard java implementation java language program compiled java bytecode 
bytecode may sent network site interpreted java virtual machine 
bytecode may written hand corrupted network transmission java virtual machine contains bytecode verifier performs number consistency checks code interpreted 
illustrated previous attacks java virtual machine tests include type correctness critical system security 
order analyze existing bytecode verifiers understand properties verified develop precise specification statically correct java bytecode form type system 
focus subset bytecode language dealing object creation initialization 
subset prove java bytecode program satisfies typing constraints object initialized 
type system easily combined previous system developed stata abadi bytecode subroutines 
analysis subroutines object initialization reveals previously unpublished bug sun jdk bytecode verifier 
supported part nsf ccr ccr onr muri award nsf graduate research fellowship 
contents object initialization jvml operational static semantics notation 
values types 
operational semantics 
static semantics 
soundness extensions jvml 
jvml 
basic types instructions 
sun verifier sun jdk verifier 
corrected sun verifier 
related jvml soundness useful lemmas 
step soundness 
progress 
soundness 
soundness extensions jvml 
jvml 
primitive types basic operations 
java compiler loader bytecode interpreter class file class 
class void 
java class class file java virtual machine verifier linker network trusted code untrusted code java virtual machine java programming language statically typed general purpose programming language implementation architecture designed facilitate transmission compiled code network 
standard implementation java language program compiled java bytecode bytecode interpreted java virtual machine 
previous programming languages implemented bytecode interpreter java architecture differs programs commonly transmitted users network compiled form 
bytecode may written hand corrupted network transmission java virtual machine contains bytecode verifier performs number consistency checks code interpreted 
shows point verifier checks program compilation transmission execution process 
class file containing java bytecodes loaded java virtual machine possibly network pass bytecode verifier linked execution environment interpreted 
trusted bytecode linker interpreter 
protects receiver certain security risks various forms attack 
verifier rejects program uses uninitialized value jumps invalid code performs operations values wrong type 
fairly conservative static analysis techniques check conditions meaning faulty programs rejected programs execute erroneous sequence instructions 
bytecode program generated conventional compiler accepted 
need conservative analysis stems undecidability halting problem efficiency considerations 
specifically bytecode result compilation little benefit developing complex analysis techniques recognize patterns occur 
intermediate bytecode language refer jvml typed machine independent form assembly language low level instructions reflect specific high level java source language constructs 
example classes basic notion jvml form local subroutine call return designed allow efficient implementation source language try construct 
amount type information included jvml type checking possible high level properties java source code easily detected resulting bytecode 
example called returned property local subroutines 
property hold jvml program generated compiling java source effort required confirm property bytecode programs sa 
example initialization objects 
clear java source language statement new class constructor called methods invoked pointer obvious simple scan resulting jvml program 
reason bytecode instructions may needed evaluate parameters call constructor 
bytecode executed space allocated object object initialized 
reason discussed detail section structure java virtual machine requires copying pointers uninitialized objects 
form aliasing analysis needed sure object initialized 
published attacks early forms java virtual machine illustrate importance bytecode verifier system security 
cite specific example bug early version sun bytecode verifier allowed applets create certain system objects able create class loaders 
problem caused error constructors verified resulted ability potentially compromise security entire system 
clearly problems give rise need correct formal specification bytecode verifier 
variety reasons established formal specification primary specification informal english description occasionally odds current verifier implementations 
develop specification fragment bytecode language includes object creation allocation memory initialization 
prior study bytecodes local subroutine call return sa 
brief develop specification statically correct bytecode fragment jvml includes object creation initialization 
specification form type system technical ways type system low level code jumps stack locations registers differs conventional high level type systems 
prove soundness type system traditional method operational semantics 
follows soundness theorem bytecode program passes static checks initialize object 
examined broad range alternatives specifying type systems capable identifying kind error 
cases possible simplify specification conservative current verifiers 
generally resisted temptation hoped gain understanding strength limitations existing verifier implementations 
addition proving soundness simple language structured main lemmas proofs apply additional bytecode commands satisfy certain general conditions 
relatively straightforward combine analysis prior abadi stata showing type soundness bytecode programs combine object creation subroutines 
analyzing interaction object creation subroutines identified previously unpublished bug sun implementation bytecode verifier 
bug allows program object initialized details appear section 
type framework possible evaluate various repairs fix error prove correctness modified system 
described opens promising directions 
major task currently undertaking extend specification correctness proof entire java virtual machine language jvml including method call stack full object system 
believe feasible generate implementation bytecode verifier specification proven correct 
specification expressed kind typing rules variant notation 
expect long run useful incorporate additional properties static analysis java programs 
java popular satisfactory general purpose programming language efficiency reasons necessary replace current run time tests conservative static analysis reverting run time tests static analysis fails 
section describes problem object initialization detail section presents jvml language formally study 
operational semantics type system language section 
sound extensions jvml including subroutines discussed section section describes relates sun implementation 
section discusses projects dealing bytecode verification section gives directions concludes 
object initialization object oriented languages java implementation creates new objects steps 
step allocate space object 
usually requires operation obtain appropriate region memory 
second step user defined code executed initialize object 
java initialization code provided constructor defined class object 
steps completed method invoked object java source language allocation initialization combined single statement 
illustrated code fragment 
point new point print line indicates new point object created calls point constructor initialize object 
second line invokes method object allowed object initialized 
java object created statement line difficult prevent java source language programs invoking methods objects initialized 
subtle situations consider constructor throws exception issue essentially clear cut 
difficult recognize initialization bytecode 
seen looking lines bytecode produced compiling preceding lines source code new class point 
dup iconst invokespecial method point int 
invokevirtual method void print 
striking difference memory allocation line separated constructor invocation line lines code 
intervening line dup duplicates pointer uninitialized object 
reason instruction pointer object passed constructor 
convention parameter passing stack architecture parameters function popped stack function returns 
address duplicated way code creating object access initialized 
second line iconst pushes constructor argument stack 
line bytecode program dup needed prior line 
depending number type constructor arguments different instruction sequences may appear object allocation initialization 
example suppose new objects passed arguments constructor 
case necessary create argument objects initialize passing constructor 
general code fragment allocation initialization may involve substantial computation including allocation new objects duplication object pointers jumps branches locations code 
pointers may duplicated form aliasing analysis 
specifically constructor called may pointers object initialized result pointers uninitialized objects 
order verify code uses pointers initialized objects necessary keep track pointers aliases name object 
hint bytecode sequence new class point 
new class point 
dup iconst invokespecial method point int 
invokevirtual method void print 
line reached execution different uninitialized point objects 
bytecode verifier check object initialization statically able determine point object initialized line point remaining uninitialized object 
verifier prevent initialized object allow uninitialized 
sun java virtual machine specification ly describes alias analysis sun jdk verifier 
line bytecode program status information recorded local variable stack location 
location points object known initialized executions reaching statement status include property uninitialized line number uninitialized object created 
duplicated stack stored loaded local variables analysis duplicates line numbers having line number assumed refer object 
object initialized pointers refer objects created line number set initialized 
words uninitialized objects certain type partitioned equivalence classes statically known point uninitialized objects created line assumed aliases 
aliasing irrelevant initialize analysis objects initialized necessary track aliasing leads initialized object 
simple highly conservative form aliasing analysis far sophisticated methods considered 
approach implemented efficiently sufficiently accurate accept bytecode produced standard compilers 
specification statically correct java bytecode section uses form aliasing analysis sun jdk verifier 
approach type status information associated recorded part type 
limitation aliasing analysis line numbers verifiable program able objects allocated line initializing 
situation occur exist different objects static aliasing equivalence class 
unfortunately oversight regard development sun verifier allowed case exist version 
discussed section aliasing line numbers problematic subroutine return uninitialized object 
jvml section describes jvml language subset jvml encompassing basic constructs object initialization 
language smaller jvml sufficient study object initialization formulate sound type system encompassing static analysis described 
run time environment jvml consists operand stack finite set local variables 
model object heap demonstrate necessary study problem object initialization 
jvml program sequence instructions drawn list instruction push pop store load new oe init oe oe halt local variable name oe object type address instruction program 
simple example shows program written extended form jvml instructions defined follows push pushes integer stack 
adds value top stack value integer 
pop removes top element stack provided stack empty 
top element stack execution jumps instruction execution steps sequential instruction 
assumes top element integer 
store removes value top stack stores local variable load loads value local variable places top stack 
halt terminates program execution 
new oe allocates new uninitialized object type oe 
init oe initializes previously uninitialized object type oe 
represents calling constructor object 
model assume constructors properly initialize argument return 
described section additional properties checked verify constructors fact behave correctly 
oe performs operation initialized object type oe 
corresponds operations jvml including method invocation invokevirtual accessing instance field putfield getfield cases covered definitions illegal 
example pop instruction executed stack empty 
dup appear jvml simplicity aliasing may arise storing loading object local variables 
operational static semantics notation section briefly reviews framework developed stata abadi sa studying jvml 
program formally modeled partial function addresses instructions 
refer set possible instruction addresses addr 
shall integers represent elements set distinguish elements addr integers 
set local variables accessible program var 
dom represents set addresses program th instruction program dom include address usually range ng equality partial maps defined iff dom dom dom update substitution operations defined 
dom 
ae ae range codomain notation partial maps 
sequences 
empty sequence ffl delta represents placing front sequence sequence element delta ffl abbreviated convenient shall treat sequences partial maps positions elements sequence 
sequence dom set indices th element right 
dom delta 
appending sequence written ffl operation defined equations ffl ffl delta ffl delta ffl 
final operation sequences substitution ffl ffl delta delta ae delta delta kind stored sequence values types types integers object types 
objects assume set possible object types 
types example correspond possible object type names program may refer 
addition set types uninitialized objects 
contents set defined terms oe iff oe addr type oe object type oe allocated line program initialized 
definitions jvml types generated grammar int oe oe top oe oe type int integers 
discuss addition basic types section 
type top super type types value type having type top 
type represent unusable values static analysis 
general type variable may refer type including form oe oe case type variable known refer uninitialized object type write example 
object type uninitialized object type corresponding infinite set values distinguished values type 
object type oe set values oe likewise set values oe uninitialized object types oe values form refer values known uninitialized object type 
basic type rules values value top integer int extend values types sequences ffl ffl ff delta delta ff ff ff ffl ff ffl ff operational semantics bytecode interpreter jvml modeled standard framework operational semantics 
instruction characterized transformation machine states machine state tuple form hpc si meaning ffl pc program counter indicating address instruction executed 
ffl total map var set local variables values stored local variables current state 
ffl stack values representing operand stack current state execution 
machine begins execution state ffli 
state instruction program executed operand stack empty local variables may contain values 
means may map local variables values 
bytecode instruction yields rules operational semantics 
rules judgment hpc si hpc pc hpc delta si hpc delta si pc pop hpc delta si hpc si pc push hpc si hpc delta si pc load hpc si hpc delta si pc store hpc delta si hpc 
si pc hpc delta si hpc si pc hpc delta si hl si pc new oe oe pc unused hpc si hpc delta si pc init oe oe oe unused hpc delta si hpc si pc oe oe hpc delta si hpc si jvml operational semantics 
indicate program state hpc si move state hpc step 
complete step operational semantics jvml shown 
integer value addresses local variable 
operational semantic rules exception added study object initialization discussed detail sa 
rules designed step illegal state pop empty stack 
rules object initialization additional judgment unused defined unused var unused allow virtual machine pick value currently program 
values appear operand stack local variables 
new object created currently unused value uninitialized object type placed stack 
type value determined object type named instruction line number instruction 
value uninitialized object initialized init oe instruction occurrences value replaced new value corresponding initialized object 
new value required unused 
allows program distinguish different objects type initialized fact necessarily needed study properties addressed 
int delta ff dom int delta int delta sl dom dom pop pop delta dom push push int delta dom load load dom delta dom store store dom 
delta dom halt halt new new oe oe delta oe dom oe dom init init oe oe oe oe delta ff oe oe ff dom dom oe oe delta dom static semantics 
static semantics program typed exist map addr functions mapping local variables types map addr stack types type operand stack location program 
described sa elements map addr accessed 
type local variable line program 
judgment allows conclude program typed wt prog top ffl dom top function mapping variables var top 
lines wt prog constrain initial conditions program execution match type values initial state operational semantics 
third line requires instruction program typed local judgments 
static type rules new straightforward 
new rule requires type object allocated new instruction left top stack 
rule requires initialized object type top stack 
init rule implements static analysis method described section 
rule requires occurrences type top stack replaced initialized type 
change types object initialized static equivalence class type 
java virtual machine specification ly describes verifier computing type information stored checking 
assume information stored computed prior type checking stage 
simplifies matters separates tasks prevents type synthesis complicating static semantics 
words need trust implementation type inferencing part analysis 
type checker trusted 
stages combined current implementations bad program accepted due error process computing type information 
separating tasks prevents type checker accepting bad program due error 
soundness section outlines soundness proof jvml main soundness theorem states typed program cause run time type error 
stating main soundness theorem step soundness theorem 
step soundness implies valid transition formed state leads formed state 
theorem step soundness pc pc hpc si hpc pc var pc consistentinit pc pc pc var pc consistentinit pc pc pc dom theorem lists factors dictate state formed 
values operand stack types expected static type rules local variable contents match types addition program counter domain program 
assumed left hand side implication operational semantics guarantee transitions pc defined 
program counter domain program step 
final requirement state formed consistentinit property 
informally property means machine state access different uninitialized objects created line code 
mentioned section invariant critical soundness static analysis 
consistentinit property unique correspondence uninitialized object types run time values 
paragraph describes formal definition consistentinit appears 
possible uninitialized object type cons init rule guarantees value corresponding occurrence type local variables stack 
precisely uninitialized object type value type occurrence static types local variables matched current state 
condition line corr rule 
stack case covered line defines correspondence values uninitialized object types inductively 
proof theorem case analysis possible instructions pc 
proof theorem follow appear appendix complementary theorem step formed state program reached halt instruction 
progress theorem stated theorem progress pc pc var pc consistentinit pc pc pc dom pc halt pc hpc si hpc theorem theorem prove inductively program valid initial state formed state regardless steps 
addition program get stuck reaches halt instruction 
reach halt instruction stack correct type important return value program method full jvml returned top value stack 
theorem captures soundness property cons init corresponds consistentinit corr dom stackcorresponds corresponds sc stackcorresponds ffl ffl sc stackcorresponds stackcorresponds delta delta sc stackcorresponds stackcorresponds delta delta consistentinit judgement 
theorem soundness pc ffli hpc si pc hpc si hpc pc halt pc program executing machine model attempts perform operation leading type error get stuck operations defined operational semantics 
prove typed programs get stuck halt instruction reached know programs attempt perform illegal operations 
theorem implies form correctness static analysis showing erroneous programs accepted 
extensions extensions jvml framework proofs described previous sections studied 
mentioned previously additional static checks performed constructors order guarantee properly initialize objects 
section presents jvml extension jvml modeling constructors 
extension jvml combining object initialization subroutines described section 
section shows languages may easily extended basic operations primitive types 
combination features yields sound type system covering complex pieces jvml language 
pop push load store new oe init oe oeg constructs zl constructs super true constructs halt true constructs rules checking super class constructor called prior reaching halt instruction 
jvml typing rules section adequate check code creates initializes uses objects assuming calls init oe fact properly initialize objects 
initialization performed user defined constructors verifier check constructors correctly initialize objects called 
section studies verification jvml constructors jvml extension jvml rules checking constructors defined ly summarized basic points ffl constructor invoked local variable contains object initialized 
ffl constructor apply different constructor class constructor parent class object initialized constructor exits 
simplicity may refer actions invoking super class constructor 
ffl deviation requirement constructors class object 
java language definition object class superclass constructors object need call constructor 
special case modeled rules trivial add 
jvml programs sequences instructions containing instructions jvml plus new instruction super 
instruction represents calling constructor parent class class different constructor current class 
model initial state constructor invocation class jvml program assumed state local variable contains uninitialized 
corresponds argument constructor 
prior halting program call super object 
represents calling super class constructor 
simplicity rest section assumes describing constructor object type type object stored local variable start execution 
value local variable drawn set assume addr includes domain program 
machine state operational semantics augmented fourth element indicates super class constructor called object initialized 
rules instructions super affect derived directly rules 
example rule pc hpc delta zi hpc delta zi demonstrated theorem initial state execution constructor 
ffl falsei super operational semantics rule pc super oe oe oe unused hpc delta zi hpc truei typing rule super similar rule init oe shown judgment determining program valid constructor objects type 
typing rules appearing 
super super oe oe oe oe oe delta ff oe oe ff dom wt constructor top ffl false dom dom constructs constructs wt constructor rule analogous wt prog section 
rule places additional restriction structure typed programs 
judgment constructs local judgment gives value true false depending possible execution sequences reaching instruction called super 
local judgments defined 
seen rules conclude program valid constructor path halt instruction called super 
existence unreachable code may cause value conform rules 
unique program assume program unique canonical form unique value instruction main soundness theorem constructors includes guarantee constructors call super uninitialized object theorem constructor soundness constructs pc 
ffl falsei hpc zi pc hpc zi hpc pc halt true pc jsr hpc si hl pc delta si pc ret hpc si hf si operational semantics jsr ret 
main difference proof theorem comparison theorem corresponding step soundness theorem requires additional invariant 
invariant states program state hpc zi zp pc proof theorem appears appendix 
analysis constructors combined analysis normal methods complete jvml model currently developed 
jvml jvml bytecodes subroutines added jvml extended language jvml section go details subroutines detailed discussions bytecode subroutines works sa ly 
subroutines compile clauses exception handlers java language 
subroutines share activation record method uses called different locations method enabling locations code executed jump single subroutine containing code 
flexibility mechanism bytecode verification difficult main reasons ffl subroutines polymorphic local variables 
ffl subroutines may call subroutines long call stack discipline preserved 
words called subroutine return 
slight simplification rules subroutines defined ly allow subroutine return level implicit subroutine call stack certain cases match definitions sa 
jvml programs contain set instructions jvml programs jsr jumps instruction pushes return address stack 
return address instruction immediately jsr instruction 
ret jumps instruction address stored local variable operational semantics type rules instructions shown 
rules rules stata abadi sa 
meaning rp flg ret defined basically means instruction instruction belonging subroutine starting address rules jvml main issue addressed type rules jsr ret consistentinit invariant 
type loophole created allowing subroutine caller subroutine exchange uninitialized objects certain situations 
example behavior described section 
jsr jsr dom dom dom dom dom dom dom dom sl ret delta ret dom ret dom dom ret ret rp flg dom ret dom dom jsr dom type rules jsr ret 
subroutines compile blocks java compiler uninitialized object passed subroutine 
java language prevents program splitting allocation initialization object code inside outside clause part java operation described section 
steps occur outside subroutine steps occur inside subroutine 
restrict programs uninitialized objects accessible calling returning subroutine 
ret lines added 
prevent subroutine allocating new object initializing dom dom similar lines added jsr 
discussion interaction subroutines uninitialized objects java virtual machine specification vague inconsistent current implementations rules developed fit general strategy described specification 
certainly way prevent subroutines object initialization causing problems 
example slightly restrictive rules added jsr dom dom lines allow uninitialized objects subroutine called objects touched stored local variables accessed body subroutine 
allow type rules accept programs programs created compiler valid java program 
main soundness theorem theorem proved jvml jvml subroutines combining proof jvml soundness stata abadi 
proofs appear appendix 
basic types instructions jvml instructions variants operations different basic types 
example add instructions corresponding addition values type int float long double 
likewise simple operations different forms 
instructions basic types added jvml extended languages easily 
instructions complicate soundness proofs operate basic types interfere object initialization subroutine analysis 
example showing simple instructions added framework appears appendix 
tricky case long double values take local variables stack slots stored word values 
requires additional check rules load store prevent program accessing partially written word value pose serious difficulty 
bytecode instructions jvml approximately fall category may added jvml trouble full presentation operational type rules instructions scope 
additions methods described previous subsections jvml framework extended cover bytecode language full object system concurrency 
considering objects classes requires addition object heap method call stack typing environment containing class declarations 
jsr store store new jsr ret store load init load program uses uninitialized object accepted sun verifier 
sun verifier section describes relationship rules developed object initialization subroutines rules implicitly verify programs sun implementation 
describe mistake sun rules compare corrected rules rules jvml sun jdk verifier direct result insight gained carrying soundness proof jvml previously unpublished bug discovered sun jdk implementation bytecode verifier 
simple program exhibiting incorrect behavior shown 
line program uses uninitialized object code accepted specific implementation verifier 
basically program able allocate different uninitialized objects line code initializing violating consistentinit invariant 
program accomplishes allocating space new object inside subroutine storing object local variable subroutine polymorphic calling 
initializing objects 
bug attributed verifier placing restrictions presence uninitialized objects calls jsr ret checks sun verifier analogous jsr ret rule originally appeared sa additions described previous section 
removing lines allows subroutines return uninitialized objects caller store uninitialized values subroutine calls clearly leads problems 
bug immediately create security loopholes sun java virtual machine demonstrate need formal specification verifier 
demonstrates fairly model bytecode language extremely useful examining complex relationships different parts language uninitialized objects subroutines 
corrected sun verifier describing bug sun development team taken steps repair verifier implementation 
exact rules changed implementation close potential type loophole 
section briefly describes difference approach 
sun implementation may summarized follows lia ffl uninitialized objects may appear local variables operand stack jsr ret instructions instruction executed 
words static type top post instruction state 
difference affect ability sun rules rules accept code created valid java language programs 
ffl static types assigned uninitialized objects pass constructors value type form oe framework treated differently uninitialized objects types sun verifier 
values types may call exit subroutine 
superclass constructor may called including inside subroutine 
treating uninitialized object types constructor arguments differently uninitialized types allows verifier accept programs subroutine called prior invoking super class constructor 
java language specification requires superclass constructor called prior start code protected exception handler flexibility required correctly check valid java programs analysis difficult 
fact published attacks including described section may attributed errors part verifier 
differences verification techniques apparent handwritten bytecodes uninitialized object types unusual ways 
method slightly restrictive verification soundness proofs simpler believe method reasonable 
related projects currently examining bytecode verification creation correct bytecode verifiers 
section describes projects related contexts java 
studies java language type system sym de focus bytecode level projects 
studies certainly useful closely related respects address unique way bytecode language special structures jvml 
addition framework developed stata abadi sa different strategies developed describe jvml type system bytecode verification formally 
closely related qia presents static type system larger fragment jvml 
system uses general approach attempted simpler type system abstracting away unnecessary details left qian framework different forms name resolution constant pool varying instruction lengths 
model subroutines stata abadi different 
rules object initialization original version qian similar sun faulty rules incorrectly accepted program 
announcing discovery sun bug revised version qian containing rules similar rules released 
approach concurrent constraint programming developed sar 
approach transforming jvml program concurrent constraint program 
approach deal difficulties analyzing subroutines object initialization statically remains seen yield better worse framework studying jvml results easily translated verifier specification 
completely different approach taken cohen developing formal execution model jvml require bytecode verification coh 
safety checks built interpreter 
run time checks performance defensive jvm slow practice method useful studying jvml execution understanding checks required safely execute program 
project developed experimental method determine correctness existing bytecode verifiers smb 
implementing verifier scratch programs randomly inserted errors fed verifier commercially produced verifiers 
differences implementations meant potential flaw 
approach fairly tracking certain classes implementation mistakes effective software engineering perspective lead concise formal model approaches including approach 
may find jvml specification errors complex bugs described section 
studied type systems low level languages jvml studies include til intermediate languages ml tmc typed assembly language 
studies touch issues study 
languages contain constructs jvml require aspects static analysis required jvml alias analysis required object initialization 
need guarantee type safety mobile java code developing correct type checking analysis techniques jvml crucial 
existing specification fully captures java bytecodes type checked 
built previous stata abadi develop specification formulating sound type system fairly complex subset jvml covers subroutines object initialization 
step developing sound type system bytecode language 
type system jvml complete describe formal specification verifier better understand safety security guarantees 
model proved effective foundation examining jvml existing bytecode verifiers 
complete object model notion object heap able study initialization interaction subroutines 
fact previously unpublished bug sun verifier implementation result analysis performed studying soundness proofs 
study date examined complex areas jvml important issues address detail including issues scale adding full object system model 
methods described section allow variants simple instructions added standard straightforward way examining methods factor jvml complete minimal set instructions 
addition java object system studied discussed contexts ag sym de qia previous results basis objects jvml model 
currently process finishing soundness proof language encompassing issues plus objects interfaces classes exceptions 
issues addressed date concurrency dynamic loading key concepts java virtual machine 
intend develop synthesis method generating executable bytecode verifier type rules 
provide way generate verifiers guaranteed check type rules correctly 
addition may serve basis adding new static checks verifier examine complicated safety properties help eliminate currently necessary run time checks 
example may eventually able eliminate run time checks array bounds pointer casts statically check certain locking conventions concurrent jvml model 
acknowledgments mart abadi raymie stata dec src assistance project 
frank yellin sheng liang useful discussions 
jvml soundness useful lemmas section state prove lemmas rest appendix 
lemmas conclude correspondence specific values types contents top stack contents specific local variable 
lemma consistentinit delta delta corresponds delta delta proof assume hypotheses implication satisfied consistentinit delta delta corresponds delta delta 
proceed show contradiction 
suppose stackcorresponds delta delta true concluded corresponds delta delta way concluded rule sc 
rule applied conclude stackcorresponds delta delta violating assumption correspond assumption incorrect 
corresponds delta delta 
lemma consistentinit corresponds proof assume hypotheses implication satisfied consistentinit corresponds 
proceed show contradiction 
suppose 
contradiction exists concluded corresponds exists local variable domain type value assumption wrong 
lemmas show consistentinit preserved values popped stack 
show corresponds preserved single pop 
lemma corresponds delta delta corresponds proof assume hypotheses implication satisfied 
assumed corresponds delta delta know dom stackcorresponds delta delta 
true able conclude sc sc 
cases stackcorresponds true 
corresponds follows rule corr 
may state notion consistentinit 
lemma consistentinit delta delta consistentinit proof assume hypotheses implication satisfied choice choose corresponds delta delta 
exists assumption consistentinit delta delta 
choice corresponds follows lemma 
may chosen way consistentinit follows 
previous lemma may generalized popping number values stack shown lemma 
lemma ff ff ff ff consistentinit ff ffl ff ffl consistentinit ff proof proof induction length ff jff ff ffl ffl making ff ffl ff ff ffl equalities consistentinit ff follows assumption consistentinit ff ffl ff ffl 
inductive case assume implication holds ff jff suppose jff 
case ff delta ff jff ff ffl ff delta ff ffl ff delta ff ffl ff 
likewise ff ffl delta ffl ff consistentinit ff ffl ff ffl reached applying lemma inductive hypothesis allows conclude consistentinit ff 
fashion similar previous lemmas prove pushing number values affect consistentinit long new values uninitialized objects 
start corresponds lemma corresponds corresponds delta delta proof assume hypotheses implication satisfied 
assumed corresponds equation holds dom stackcorresponds true 
stackcorresponds delta delta follows rule sc 
corresponds delta delta follows corr 
lemma consistentinit consistentinit delta delta proof assume hypotheses implication satisfied 
choose corresponds 
exists assumption consistentinit 
choice prove corresponds delta delta lemma 
know conditions lemma satisfied implying corresponds delta delta 
chosen way conclude consistentinit delta delta cons init 
lemma ff ff ff dom ff ff consistentinit ff consistentinit ff ffl ff ffl proof proof induction length ff assume hypotheses implication satisfied 
jff ff ffl ffl making ff ffl ff ff ffl equalities consistentinit ff ffl ff ffl follows assumption consistentinit ff 
inductive case assume implication holds ff jff suppose jff 
case ff delta ff jff ff ffl ff delta ff ffl ff delta ff ffl ff 
likewise ff ffl delta ffl ff inductive hypothesis consistentinit ff ffl ff ffl 
guaranteed assumption ff lemma applied conclude consistentinit delta ff ffl ff delta ffl consistentinit ff ffl ff ffl 
lemma shows value known correspond certain uninitialized object type may stored local variable breaking correspondence 
lemma dom corresponds corresponds 

proof assume hypotheses implication satisfied 
assumed corresponds know stackcorresponds order corr prove lemma show dom 


proving note dom dom 

cases consider ffl case 

likewise 

corresponds true equation true choice ffl case 

satisfied conditions corr satisfied may conclude lemma holds 
similarly value known uninitialized object certain type may stored local variable breaking known correspondence type value 
lemma dom corresponds corresponds 

proof assume hypotheses implication satisfied 
assumed corresponds know stackcorresponds order corr prove lemma show dom 


proving note dom dom 

cases consider ffl case 

likewise 

corresponds true equation true choice ffl case 
satisfied conditions corr satisfied may conclude lemma holds 
lemmas section concern substitutions 
shows substitution initialized object type uninitialized object type initialized object corresponding uninitialized object preserves stack type 
correspondence uninitialized object type value stack preserved substitution 
lemma oe oe stackcorresponds oe oe oe oe oe oe stackcorresponds oe oe oe proof assume hypotheses implication satisfied 
prove induction proof stackcorresponds oe 
base case inductive cases consider depending judgment final step proof ffl sc case ffl ffl 
follow trivially 
ffl sc case delta oe delta know stackcorresponds oe true allowing conclude oe oe stackcorresponds oe oe oe inductive hypothesis 
clear equations hold oe oe oe oe allow conclude oe oe oe 
combining fact equation know delta oe oe oe delta oe oe delta oe oe oe delta follows 
half satisfied 
stackcorresponds oe delta oe oe delta oe follows sc plus fact oe oe 
equations rewritten stackcorresponds oe oe oe delta delta oe distributive nature substitution sequences 
ffl sc case delta delta oe 
know proceed previous case conclude oe oe stackcorresponds oe oe oe inductive hypothesis 
cases know oe may conclude oe oe delta oe oe delta oe oe true 
means delta oe oe oe delta true 
addition stackcorresponds oe oe delta oe oe delta oe follows rule sc oe oe oe 
may rewritten stackcorresponds oe oe delta delta oe second half follows 
case top valid types top oe 
ruled sc final step proof stackcorresponds delta delta oe 
value type top oe oe top top may conclude oe oe true 
assertion oe oe follows directly 
stackcorresponds oe oe delta oe oe delta oe follows rule sc oe oe oe stackcorresponds oe oe delta delta oe true 
lemma analogous previous specific local variable lemma oe oe dom oe oe oe oe oe oe oe oe oe proof assume hypotheses implication satisfied 
cases ffl oe know oe oe oe 
oe assumptions clause true 
oe oe second clause true 
ffl oe know oe oe 
case possibilities case oe satisfied 
case top valid types oe top 
top true top making clause true 
oe top second clause follows 
lemma shows initializing object uninitialized object type affect correspondence uninitialized object types values 
lemma oe oe stackcorresponds oe oe stackcorresponds oe oe proof show stackcorresponds oe oe true induction proof stackcorresponds 
base case inductive cases consider depending judgment final step proof ffl sc case ffl ffl follows easily 
ffl sc assume delta delta stackcorresponds oe oe true inductive hypothesis 
stackcorresponds delta oe oe delta follows rule sc oe may rewrite stackcorresponds oe oe 
ffl sc assume delta delta inductive hypothesis stackcorresponds oe oe true 
oe oe oe rule sc stackcorresponds oe oe delta oe oe delta true 
rewritten stackcorresponds oe oe 
step soundness order prove theorem prove required invariants preserved program step 
invariant state general property instruction behavior operational static semantics guarantees invariant violated instruction exhibiting property 
properties allow easily reason instructions preserve global invariants common case 
example property describes behavior easily proved guarantee stack typed instruction executed 
property instruction state preserves relation preserves pc pc hpc si hpc pc pc ff ff ff ffl ffl pc ff ffl ff pc ff ffl ff instructions property pop push store new oe oe proof representative cases shown 
case assume pc pc satisfy hypotheses ffl operational semantics pc pc delta delta pc pc int delta ff ff 
choose ff int ff ff ff int 
clearly ff ff integers 
assumption pc may conclude delta int delta ff ff meaning ff ffl operational semantics pc fpc lg 
delta integer stack addition pc int delta pc choose ffl ff int ff pc ff ffl 
know ff int 
assumption pc conclude delta int delta pc pc meaning ff type judgment ffl ffl implies ff property may prove part theorem grouping instructions exhibiting property single case 
lemma pc pc hpc si hpc pc var pc consistentinit pc pc pc proof assume hypotheses implication satisfied 
proceed examining possible instructions pc noting pc halt transition current state ffl pc preserves property may choose ff ff ffl pc ff ffl ff ff ff pc ffl pc load operational semantics know delta rule load fact pc pc know pc pc delta pc true 
assumption var pc know pc 
addition pc delta pc delta pc true allowing conclude pc ffl pc init oe operational semantics pc pc delta oe rule init pc oe delta ff pc oe oe ff true 
prove pc note pc consistentinit pc pc imply corresponds pc pc oe lemma 
means stackcorresponds pc oe order proved stackcorresponds ff oe true 
oe oe different types initialized object type second uninitialized object type 
ff oe oe may apply lemma conclude pc property captures behavior instructions known alter local variables 
property instruction state preserves relation preserves pc pc hpc si hpc pc pc pc instructions property pop push load new oe oe proof representative cases shown 
case assume pc pc satisfy hypotheses ffl operational semantics pc pc pc pc pieces information clear pc pc true 
ffl operational semantics pc fpc lg 
addition pc pc possible values pc conclude pc pc lemma pc pc hpc si hpc pc var pc consistentinit pc pc var pc proof assume hypotheses implication satisfied 
proceed examining possible instructions pc 
note pc halt ffl pc preserves property pc pc assumed var pc 
substitution equalities var pc 
ffl pc store operational static semantics know pc pc 
pc pc 
delta pc delta pc cases consider prove pc var case pc pc 
hypotheses implication pc true 
pc pc know pc 
pc ffl pc init oe case know pc pc static operational semantics imply pc oe oe pc delta pc oe delta ff 
oe oe addition corresponds pc pc oe follows lemma meaning pc oe implies var 
facts lemma may applied conclude oe oe pc var satisfied 
property complex previous properties 
behavior captured instruction touch local variables may pop number values stack push number new values long new ones uninitialized objects 
parts implication property truth may obtained simple examination jvml semantics 
property instruction state preserves consistentinit relation preserves consistentinit pc pc hpc si hpc pc var pc consistentinit pc pc pc ff ff ff ffl ffl pc ff ffl ff pc ff ffl ff dom ff ff pc pc instructions property pop push oe proof representative cases shown 
case assume pc pc satisfy hypotheses ffl operational semantics know pc pc delta delta pc pc int delta ff ff pc pc choose ff int ff ff int 
clearly ff ff integers 
assumption pc may conclude delta int delta ff ff meaning ff int implying dom ff ff ffl operational semantics pc fpc lg delta integer stack addition implies pc int delta pc pc pc choose ffl ff int ff pc ff ffl 
ff int 
assumption pc conclude delta int delta pc pc meaning ff type judgment ffl ffl implies ff ff ffl uninitialized object type ff show consistentinit preserved instructions 
lemma pc pc hpc si hpc pc var pc consistentinit pc pc consistentinit pc pc proof assume pc pc satisfy hypotheses 
proceed case analysis pc case contain instructions satisfy property 
know pc halt instruction 
ffl pc preserves consistentinit property may choose ff ff ff conditions listed property satisfied 
note ensures ffl pc ff ffl ff consistentinit pc pc lemma proves consistentinit pc ff 
know ff uninitialized types appear ff lemma may applied prove consistentinit pc ff ffl ff ffl 
pc pc consistentinit pc pc true 
ffl pc new oe operational semantics delta know pc oe delta pc rule init fact pc pc 
means oe choose corresponds pc pc conclude lemma true 
cases consider oe choose oe pc true static semantics obvious stackcorresponds pc oe true may proved rules sc sc 
rule sc know stackcorresponds pc oe true 
know operational static semantics pc pc true 
addition know dom pc pc oe know true dom pc pc oe corresponds pc pc true rule corr 
oe choose corresponds pc pc 
assumption consistentinit pc pc know equations true dom pc pc stackcorresponds pc pc pc dom pc pc true 
oe stackcorresponds oe delta pc delta follows rule sc applied corresponds pc pc follows corr 
ffl pc init oe operational semantics pc pc delta oe 
rule init pc oe delta ff ff meaning ff oe follow assumption pc know pc oe oe ff pc oe oe pc rule 
find corresponds pc pc 
consistentinit pc pc follows rule cons init 
true cases oe choose note oe oe true oe initialized object type oe uninitialized object type 
lemma lemma dom oe oe pc oe oe pc oe stackcorresponds oe oe pc oe true 
lemmas may applied hypotheses implication facts oe oe satisfy conditions lemmas 
corresponds pc pc oe follows directly equations rule corr 
oe choose corresponds pc pc 
assumption consistentinit pc pc show corresponds pc pc true 
dom oe oe pc oe oe pc true 
suppose 
exist dom oe oe pc oe oe pc case oe oe pc pc oe equal violating statement pc dom pc contradicts assumption corresponds pc pc 
exists hold 
know stackcorresponds oe oe ff true lemma 
corresponds pc pc oe true rule corr applied 
ffl pc store operational semantics pc pc delta 
rule store pc delta pc pc pc 
assumed pc know find corresponds pc pc 
consistentinit pc pc follows rule cons init 
cases choose corresponds pc pc 
guaranteed exist assumption consistentinit holds 
store ensures dom pc lemma may applied conclude corresponds pc 
pc 

simplifying appealing lemma conclude corresponds pc pc choose case corresponds pc pc true lemma 
may apply lemma conclude corresponds pc 
pc 

know corresponds pc pc true lemma 
ffl pc load operational semantics pc pc delta rule store pc pc delta pc pc pc know pc 
find corresponds pc pc 
consistentinit pc pc follows rule cons init 
cases pc choose corresponds pc pc 
know stackcorresponds pc 
stackcorresponds pc delta pc delta follows directly rule sc corresponds pc pc true 
pc choose 
consistentinit pc pc conclude corresponds pc pc pc stackcorresponds pc pc lemma 
applying sc know stackcorresponds pc delta pc delta pc true corresponds pc pc true 
property trivial jvml include symmetry previous invariants useful proofs extensions jvml property instruction state preserves relation preserves pc pc hpc si hpc pc pc dom instructions property pop push load store new oe oe init oe proof representative cases shown 
case assume pc pc satisfy hypotheses ffl operational semantics pc pc 
pc dom 
ffl operational semantics pc fpc lg 
possible values pc domain lemma pc pc hpc si hpc pc var pc consistentinit pc pc pc dom proof guaranteed pc preserves instructions jvml exhibit property 
lemma follows directly property 
may prove theorem restatement theorem pc pc hpc si hpc pc var pc consistentinit pc pc pc var pc consistentinit pc pc pc dom proof theorem follows directly lemmas 
progress proofs section corresponding proofs stata abadi 
progress theorem easily proved showing instruction halt allow program take step formed state 
instruction simply show construct state program step 
restatement theorem pc pc var pc consistentinit pc pc pc dom pc halt pc hpc si hpc proof assume hypotheses implication satisfied pc proceed case analysis possible instructions pc 
proof case simply choose values pc step may taken program operational semantics 
ffl pc push choose delta pc pc 
ffl pc assumed pc pc int delta pc follows delta choosing delta pc pc allow progress 
ffl pc pop pc pc delta ff follows pop delta choose pc pc 
ffl pc assumed pc pc int delta pc sl follows delta choosing pc pc pc allow progress 
ffl pc store pc pc delta pc follows pop delta choose 
pc pc 
ffl pc load choose delta pc pc 
ffl pc new oe oe pc contains infinite number values meaning value unused 
choose delta pc pc 
ffl pc init oe pc pc oe delta pc rule init delta oe oe contains infinite number values meaning value unused 
choose pc pc 
ffl pc oe pc pc oe delta pc follows delta oe choose 
pc pc 
soundness extend step soundness theorem execution sequences length lemma pc ffli hpc si pc var pc consistentinit pc pc pc dom proof proof induction number execution steps 
base case 
case hpc si ffli 
implication follows initial machine state assumption programs line constraints rule wt prog 
prove inductive step assume lemma true sequences length prove lemma execution sequences length 
case execution sequence ffli hpc hpc si pc steps taken ffli reach hpc may apply inductive hypothesis conclude pc var pc consistentinit pc pc pc dom applying theorem conditions execution step hpc hpc si conclude pc var pc consistentinit pc pc pc dom lemma true execution sequences length 
restatement theorem pc ffli hpc si pc hpc si hpc pc halt pc proof assume hypotheses implication satisfied 
prove clause 
suppose ffli hpc si pc halt step taken program 
lemma true pc var pc consistentinit pc pc pc dom assertions assumption pc halt mean theorem exist state program step 
contradicts assumption program stuck hpc si conclude assumption pc wrong 
pc halt 
conclude second half conjunction pc true directly application lemma assumptions implication 
soundness extensions jvml section gives brief overview soundness proof jvml constructors 
previously described step soundness theorem augmented global invariant stating equivalents run time state theorem constructor step soundness pc pc hpc zi hpc pc var pc consistentinit pc pc pc pc var pc consistentinit pc pc pc pc dom proof sketch exception proving new invariant preserved instructions proof theorem may obtained minor modifications proof theorem appendix prove pc define new property property instruction state preserves constructor relation preserves constructor pc pc hpc zi hpc pc pc pc note instructions super oe guarantee property 
hypotheses theorem satisfied pc proved case analysis pc 
pc preserves constructor follows property assumption pc super oe possible instruction true follows operational semantics pc true follows definition fact pc pc 
equation holds possible instructions theorem true 
extending previously described progress theorem appendix cover constructors relatively straightforward constructor soundness theorem follows restatement theorem constructs pc 
ffl falsei hpc zi pc hpc zi hpc pc halt true proof sketch half follows reasoning similar proof appendix 
second half true facts equal pc static semantics guarantees pc true pc halt 
jvml section outlines soundness proof jvml subroutines 
refer reader extended version sa details omitted section 
proof sketch consists basic steps 
define jvml subroutines terms structured operational semantics semantics section sa additional definitions needed proof 
state discuss step soundness theorem structured semantics 
third step relates structured semantics semantics jvml shown previously 
part uses simulation structured semantics 
complete steps leading main soundness theorem jvml follow easily proofs appendix proofs stata abadi 
shows structured operational semantics jvml machine state fourth component ae representing subroutine call stack implicit real virtual machine 
instructions change ae jsr ret static type rules structured operational semantics rules 
judgment conclude program typed wt prog sub top ffl fg dom labeled dom map described relates line program subroutine line belongs 
rp represents canonical program stating step soundness theorem additional definitions needed 
define function assigns types local variables account subroutine call pc hpc delta aei hpc delta aei pc pop hpc delta aei hpc aei pc push hpc aei hpc delta aei pc load hpc aei hpc delta aei pc store hpc delta aei hpc 
aei pc hpc delta aei hpc aei pc hpc delta aei hl aei pc jsr hpc aei hl pc delta pc delta aei pc ret hpc pc delta aei hpc aei pc new oe oe pc unused hpc aei hpc delta aei pc init oe oe oe unused hpc delta aei hpc aei pc oe oe hpc delta aei hpc aei jvml structured operational semantics 
stack 
type pc ae defined rules tt dom pc pc ae pc tt dom pc ae pc delta ae see long ae satisfies formedness conditions pc ae defined local variables 
definition matches definition sa 
need judgment ensures subroutine call stack formed wf dom pc var pc ffl wf gamma jsr rp pc dom pc dom ae pc delta ae pop push load store new oe init oe oeg labeled rl labeled jsr rl flg labeled ret xg labeled rules labeling instructions subroutines presence subroutines consistentinit invariant described section insufficient guaranteeing uninitialized objects strengthened 
define new invariant pc consistentinit pc pc var dom pc pc ae line definition ensures necessary correspondence values uninitialized object types account subroutine call stack 
addition guarantee uninitialized objects hidden variables inaccessible program current instruction 
definitions may state step soundness theorem 
theorem structured step soundness pc ae pc ae hpc aei hpc ae pc var pc ae pc ae pc pc pc ae var pc ae pc pc dom proof sketch full details proof scope sketch actual proof 
proceed briefly justifying invariants listed theorem ffl pc follows proofs similar lemma lemma property augmented ae 
ffl pc dom follows proof similar lemma instructions language 
complicated case ret proved stata abadi 
ffl pc ae appendix sa proves invariant 
instructions jsr ret satisfy conditions lemma preserve invariant simply affect subroutine call stack domain visible local variables 
ffl var pc ae proved stata abadi instructions added study object initialization 
new oe oe trivial prove init oe fairly tricky 
rely previous proofs take account polymorphism local variables 
case equations derived operational static semantics pc pc ae ae pc oe oe pc oe know corresponds pc pc oe lemma 
prove var pc ae find dom pc know pc ae pc 
lemma oe oe pc true meaning pc 
dom pc dom pc know pc ae pc 
choose pc 
dom pc case pc ae pc ae 
assumption pc know pc ae oe done local variable affected 
pc ae top top case holds 
choose pc ae ffl pc know ae ae dom pc dom pc clauses may proved true restricting proofs appendix consider variables dom pc noting variables outside domain current instruction affected executing instruction 
takes care cases jsr ret jsr know var dom pc pc ae pc 
know dom pc pc jsr 
rule guarantees dom sl sl dom dom pc dom pc pc uninitialized object types sl clear consistentinit pc pc true 
know pc delta ae pc ae var dom tt statements know pc ae type making second half pc true 
ret know ae pc delta ae types stored pc constrained ways 
variables domain subroutine returning type pc pc types belong constrained ret 
variables dom pc dom pc contain uninitialized object types local variables types pc pc gamma true pc gamma jsr jsr rule constrain variables belong dom pc pc true 
uninitialized object types appear pc pc making consistentinit pc pc trivially true 
second half pc easily follows statements 
third step proving soundness jvml subroutines show simulation structured semantics 
describe details proof follows directly appendix stata abadi insight new oe init oe oe change subroutine call stack touch value type corresponding return address 
simulation shown main soundness theorem easily proved 
primitive types basic operations benefits proof style appendix relates simple properties instruction execution preservation global invariants required step soundness theorem 
example instruction operational static semantics exhibit property guaranteed preserve invariant operand stack typed 
properties add instructions basic types jvml little effort 
reasoning global invariants directly may reason terms simpler properties 
example add instruction iadd 
operational static semantics instruction pc iadd hpc delta delta si hpc delta si iadd iadd int delta int delta ff int delta ff dom show soundness theorems proved jvml apply jvml iadd suffices prove properties appendix apply iadd progress instruction executed formed state 
prove properties ffl iadd preserves assume hypotheses property satisfied 
pc pc pc know delta delta integers choose delta ff int delta int ff ff ff int 
ffl iadd preserves operational static semantics know pc pc pc pc ffl iadd preserves consistentinit choose ff ff ff stack case 
note pc pc int follow operational static semantics pc pc 
ffl iadd preserves operational semantics pc pc iadd ensures dom 
show progress assume hypotheses theorem satisfied pc iadd 
know delta delta values choose pc pc delta ag ken arnold james gosling 
java programming language 
addison wesley 
coh rich cohen 
defensive java virtual machine version alpha release 
available www cli com software index html november 
de drossopoulou eisenbach 
java type safe probably 
european conference object oriented programming pages 
drew dean edward felten dan wallach 
java security hotjava netscape 
proceedings ieee computer society symposium research security privacy pages 
lia sheng liang 
personal communication november 
ly tim lindholm frank yellin 
java virtual machine specification 
addison wesley 
greg morrisett karl crary neal glew david walker 
system typed assembly language 
proc 
th acm symposium principles programming languages january 
tobias nipkow david von oheimb 
java light type safe definitely 
proc 
th acm symposium principles programming languages january 
qia qian 
formal specification java tm virtual machine instructions draft 
available www informatik uni bremen de qian abs html november 
sa raymie stata mart abadi 
type system java bytecode subroutines 
proc 
th acm symposium principles programming languages january 
sa raymie stata mart abadi 
type system java bytecode subroutines extended version 
submitted publication january 
sar vijay saraswat 
java bytecode verification problem 
available www research att com vj november 
smb emin gun sirer sean brian bershad 
java system architecture 
available cs washington edu november 
sym don syme 
proving java type soundness 
technical report university cambridge computer laboratory technical report 
tmc tarditi morrisett cheng stone harper lee 
til type directed optimizing compiler ml 
acm sigplan notices may 
sun sun microsystems java trademarks registered trademarks sun microsystems united states countries 
