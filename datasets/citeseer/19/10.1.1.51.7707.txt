efficient collision detection interactive graphics virtual environments dissertation james thomas klosowski graduate school partial fulfillment requirements degree doctor philosophy applied mathematics statistics state university new york stony brook may fl copyright james thomas klosowski state university new york stony brook graduate school james thomas klosowski dissertation committee candidate doctor philosophy degree recommend acceptance dissertation 
joseph mitchell dissertation advisor professor applied mathematics statistics steven skiena committee chair associate professor computer science esther arkin associate professor applied mathematics statistics amitabh varshney assistant professor computer science approved university committee graduate studies dean graduate studies research ii dissertation efficient collision detection interactive graphics virtual environments james thomas klosowski doctor philosophy applied mathematics statistics state university new york stony brook collision detection paramount importance applications computer graphics visualization 
typically input collision detection algorithm large number geometric objects comprising environment set objects moving environment 
addition determining accurately contacts occur pairs objects needs real time rates 
applications haptic force feedback require collision queries second 
initially analyze methods performing collision detection utilize standard box data structures 
methods compared iii sophisticated technique computational geometry results ray shooting meshes low stabbing number 
building results develop analyze method bounding volume hierarchies efficient collision detection objects moving highly complex environments 
choice bounding volume bv discrete orientation polytope dop convex polytope facets determined halfspaces outward normals come small fixed set orientations 
compare variety methods constructing hierarchies bv trees bounding dops including novel technique bv tree oscillates constructed 
propose algorithms maintaining effective bv tree dops moving objects rotate performing fast collision detection bv trees moving objects environment 
maintaining front objects move environment able exploit temporal coherence collision detection checks accelerate tree traversal algorithm considerably 
algorithms implemented tested publicly released quickcd library collision detection routines 
provide experimental evidence showing approach yields substantially faster collision detection previous methods 
test practicality effectiveness method demonstrate efficiency performing nc verification testing tool paths axis machining 
iv marianne 
contents previous 
overview 
preliminary investigation 
mesh algorithm 
mesh generation 
collision detection mesh 
simple box methods 
grid boxes 
tree method 
trees boxes 
experimental results 
environments flying objects 
flight paths 
collision detection results 

vi bv trees 
design criteria 
discrete orientation polytopes 
design choices constructing bv trees 
preprocessing step 
degree tree 
top versus bottom 
static versus dynamic structures 
choice dops 
splitting rules building hierarchies 
choice axis 
choice split point 
collision detection bv trees 
tumbling bv trees 
tree traversal algorithm 
time critical computing 
depth flying hierarchy 
overlap intersection tests 
dop overlap tests 
order interval tests 
triangle triangle intersection tests 
vii implementation experimentation 
memory requirements 
experimental set 
experimental results 
average costs 
average collision detection query times 
splitting rules split points 
tree traversal algorithms 
parallel close proximity 
behavior cd time flight 
improvements extensions 
faster preprocessing 
improving design bv trees 
choice dops 
splitting rules building hierarchies 
improved selection threshold 
oscillating bv tree 
working problem data skinny triangles 
improving usage bv trees 
ordered overlap tests 
truncating overlap test 
front tracking temporal coherence 
viii quickcd 
current implementation status 
experiments 
experimental results 
newest results 
application bv trees nc verification 

nc verification experiments 
datasets 
tool paths 
results 
extensions 
ix list figures simple example compute dops 
dop triangle shown dashed lines 
approximations object bounding volumes bounding box aabb sphere oriented bounding box obb dop 
spitfire aircraft corresponding dops level level hierarchy 
spitfire aircraft corresponding dops level level hierarchy 
illustration approximation method ii updating dop approximates rotating object 
example illustrate philosophy ordering intervals overlap test 
directions oriented relatively closely result overlap projections boxes 
direction oriented degree angle disjointness discovered 
individual collision detection query times pipes dataset pipes torus datasets 
swept datasets 
hand moving interior dataset 
contact region highlighted red 
front tracking flying object moves environment maintain front colored nodes environment bv tree 
colored internal nodes known disjoint root flying bv tree 
cd query time vs number tetrahedra quickcd rapid 
sgi indigo 
breakdown cd query time 
individual collision detection query times pipes dataset dops 
maximum query time roughly milliseconds 
individual collision detection query times pipes dataset rapid 
maximum query time roughly milliseconds 
overlayed highlight difference individual collision detection query times pipes dataset dops rapid 
clarity steps shown 
xi list tables characteristics test environments number vertices triangles environment respectively 
st number triangles stored grid tree methods 
heights tree tree provided 
complexities flying objects ch number vertices triangles convex hull vertices respectively 
number wins method 
weighted ranking method 
flight statistics scenes 
flight statistics terrains 
flight statistics 
number full resolution checks second method 
xii standard data sets recorded volumes environment hierarchies splitting rules longest side min sum min max splatter split points mean median 
standard data sets report height environment hierarchies splitting rules split points 
total memory megabytes required store environment hierarchy datasets 
total memory required store flying object hierarchy datasets 
megabytes kilobytes abbreviated mb kb respectively 
number bytes required store flying object hierarchy excluding rep vertices convex hull 
number bytes required store reps original flying hierarchy 
number bytes required store convex hull flying object 
total memory megabytes required store environment flying object bv trees 
average costs ms different choices average cd time ms splatter splitting rule 
preprocessing time minutes dop method 
xiii average cd time ms dop method dividing mean 
average cd time ms dop method dividing median 
average cd time ms dop method current tree traversal algorithm modified algorithm 
comparisons splitting rule splatter method splitting point mean 
numbers overlap queries dops faceted nested spheres different values alpha 
numbers overlap queries dops faceted nested spheres different values alpha 
preprocessing time seconds dop method 
average cd query times ms dop methods 
method parentheses number splitting directions constructing bv trees 
methods splatter splitting rule mean splitting point 
total volume occupied bv trees constructed dop method 
method parentheses number splitting directions constructing 
methods splatter splitting rule mean splitting point 
number triangles flying objects datasets 
xiv average cd time ms dop method various threshold values 
average cd time ms dop method various threshold values 
average cd time ms dop method various threshold values 
average cd time ms dop method various threshold values 
percentage improvement dop methods newer criterion selecting threshold 
value produced fastest average collision detection times tables 
range values percent best cd query time 
number comparisons required testing dops overlap 
ordering intervals environment dop able reduce average number comparisons needed 
preprocessing times seconds sun ultra 
preprocessing times seconds sgi indigo 
average cd query times ms sun ultra 
average cd query times ms sgi indigo 
average cd query times ms packages 
average cd query times ms packages 
xv statistics nc verification terrain data 
statistics nc verification industrial mold data 
xvi acknowledgments enormous number people helped graduate studies 
take time 
express utmost joseph mitchell mentor friend 
continued support encouragement today 
thoroughly enjoyed hours spent office discussing 
martin held great friend colleague served second advisor martin integral role research 
joe martin great team 
thesis committee members friends esther arkin steven skiena amitabh varshney 
appreciate time spent taught acknowledge help alan tucker door open support staff department wonderful people hard overlooked appreciated 
scott connelly claire terry mills victor poon 
wife marianne 
constant companion time stony brook continuous source love support encouragement 
finished 
parents tom mary lu provided love support 
wonderful foundation life built 
accomplish life directly attributed years hard love 
sisters judy joy brother john making trips home worthwhile 
holding things forgetting 
new family home sunday 
friends time stony brook enjoyable 
jane leroy rich single peg boyle times twisting drive 
yi jen chiang mary jane graham lorraine greenwald lee cl audio silva jim wagner friends 
chapter collision detection cd problem takes input geometric model scene environment large collection complex cad models set moving flying objects possibly articulated asks determine instants time exists nonempty intersection pair flying objects flying object environment model 
usually information flying objects moving current instant time motions may change rapidly depending evolution simulation modeling physics system due input devices control user 
collision detection system flexible handle situations 
applications important computations geometry region intersection pairs colliding objects cases detect collision occurs report pairs primitive geometric elements triangles intersecting instant 
chapter 
distinguish cd problem pure detection cd problem detect report 
real time collision detection critical importance computer graphics visualization simulations physical systems robotics solid modeling manufacturing molecular modeling number fields 
day researchers programmers finding new applications solving collision detection problem essential 
applications important factor typically solving collision detection problem speed 
requirement speed interactive virtual environments particularly challenging haptic force feedback require order intersection queries second 
may example wish interact virtual world models cluttered mechanical workspace ask easily assemble access replace component parts workspace particular removed collisions parts requiring undue awkwardness mechanic haptic force feedback mechanic alerted visually collision feels force exerted body haptic device 
simple minded approach cd involves comparing pairs primitive geometric elements 
method quickly infeasible model complexity rises realistic sizes 
consider example environment consisting triangles single flying object consisting triangles 
naive approach cd location flying object check triangles flying object chapter 
triangles environment 
total need perform triangle triangle checks position flying object determine comes contact static environment 
current implementation triangle triangle check discussed sections testing location flying object take hours perform far cry intersection checks second required applications utilizing haptic force feedback 
approaches proposed address issue efficiency discuss 
previous algorithms practice due widespread importance abundance problem collision detection 
approaches hierarchies bounding volumes spatial decompositions address problem 
idea approaches approximate objects bounding volumes decompose space occupy decompositions reduce number pairs objects primitives need checked contact 
indicated previous section checking pairs primitives infeasible approach realistic sized input 
octrees trees bsp trees indices tetrahedral meshes regular grids examples spatial decomposition techniques 
dividing space occupied objects needs check contact pairs objects parts objects chapter 
nearby cells decomposition 
decompositions hierarchical manner octrees bsp trees speed collision detection process 
hierarchies bounding volumes popular technique collision detection algorithms 
widely areas computer graphics ray tracing 
building hierarchies objects obtain increasingly accurate approximations objects exact geometry object reached 
choice bounding volume spheres axis aligned bounding boxes aabbs due simplicity checking volumes overlap intersection :10.1.1.46.2687:10.1.1.46.3524
addition simple transform volumes object rotates translates 
bounding volume popular oriented bounding box obb surrounds object bounding box rectangular facets orientation arbitrary respect coordinate axes volume advantage general yield better tighter outer approximation object orientation chosen order volume small possible 
ballard created dimensional hierarchical structure known strip tree approximating curves oriented bounding boxes plane 
barequet generalized dimensions resulting hierarchy obbs known boxtree applications oriented bounding boxes fast ray tracing collision detection 
zachmann similar term boxtree hierarchies oriented boxes collision detection chapter 
differently constructed boxtree barequet leading system publicly available performing collision detection arbitrary polygonal models rapid system hierarchy oriented bounding boxes called implemented gottschalk lin manocha 
efficiency method due part algorithm determining oriented bounding boxes overlap 
algorithm examining projections small set separating axes claimed order magnitude faster previous algorithms 
note greene previously published similar algorithm aware empirical comparisons algorithms 
rapid system addressed cd problem address moving single object large number unstructured complex models 
reason run experiments back back rapid see chapter 
purpose spatial subdivisions bounding volume hierarchies reduce number polygons primitives need tested contact 
tried approach reduction problem modified culling technique 
method removes polygons normals face away moving polygon polygons lie far side object hit 
assumes polygons near side object hit prevent deep penetration 
approaches collision detection included space time bounds dimensional geometry bound positions chapter :10.1.1.46.3524
objects near 
fourth dimension represent simulation time contacts pin pointed exactly methods restrictive require motion pre specified closedform function time 
hubbard space time bounds requirement assuming bound acceleration objects able avoid missing collisions fast moving objects :10.1.1.46.3524
collection innovative utilizes voronoi diagrams keep track closest features pairs objects :10.1.1.139.265
popular system collide uses spatial temporal coherence addition sweep prune technique reduce pairs objects need considered collision :10.1.1.139.265
software works simultaneously moving objects objects restricted convex 
ponamgi manocha lin generalized include non convex objects 
collide system greatly improved replacing closest pairs features algorithm separating vector algorithm quickly finds separating plane convex polytopes intersect 
empirical evidence shown collide significantly faster collide cases order magnitude faster 
collide collide designed environments consisting convex objects move simultaneously :10.1.1.139.265
addressing different problems run comparisons versus collide software publicly available collide software available 
chapter 
mirtich designed clip voronoi clip improvement closest feature algorithm collide 
limitations original algorithm handle penetrations objects non convex objects particularly robust fairly complicated implement 
clip developed address problems limited designed objects bounded closed surfaces highly non convex 
software package designed order perform interactive collision detection vrml environments 
collide combines sweep prune algorithm collide pairwise collision detection check rapid 
unfortunately collide integrated vrml browser due authors lack browser source code remains open effective practice 
system tested stand mode preliminary results show promise prototype considerable amount memory 
methods mentioned point polygon 
nice progress voxel collision detection 
dissertation shall focus exact methods collision detection polygonal models 
theoretical results addition practical highlighted considerable number theoretical results problem collision detection field computational geometry 
particular chapter 
distance intersection convex polytopes determined log time total number vertices polytopes dobkin kirkpatrick hierarchy takes time space construct 
case convex polytope non convex polytope intersection detection time increases log computing intersection takes log time size input plus output 
detects intersection translating iso oriented polyhedra non convex having normals directions fixed constant time log 
general polyhedra moving fixed known trajectories thiel obtained ffl algorithm case pure translations ffl algorithm rotation polyhedron fixed axis 
ffl arbitrarily small constant affecting constant big oh 
generalized method yield provably worst case sub quadratic time algorithm general collection polyhedra motion fixed trajectories result purely theoretical interest having sophisticated unimplemented techniques 
suri hubbard hughes theoretical results may help explain practicality bounding volume methods 
particular show collection objects bounded aspect ratio scale factor number pairs objects bounding volumes intersect roughly proportional asymptotically number pairs objects intersect plus number objects 
suri result obtain output sensitive algorithm detecting chapter 
intersections set convex polyhedra having bounded aspect ratio scale factor time bound log polyhedra number pairs polyhedra intersect 
aspect ratio object defined ratio volume smallest enclosing sphere largest enclosed sphere 
scale factor collection objects ratio volume largest enclosing sphere object smallest enclosing sphere object 
overview preliminary investigation collision detection problem chapter 
implemented methods standard box data structures compare experimentation mesh method motivated theoretical results obtained meshes low stabbing number computational geometry 
results experiments chapter indicate data structures tree considerable potential efficiently performing collision detection queries 
chapter discusses generalization structure great detail 
particular provide bv trees discrete orientation polytopes design choices constructing effective bv trees 
chapter presents collision detection algorithm key issues related efficient bv trees 
method implemented tested wide variety data 
discuss implementation details provide collection experimental results chapter 
chapter 
improvements extensions method reported chapter 
discuss options building better bv trees including new idea lets tree oscillate constructed build tightest possible hierarchy 
introduce new ideas efficient bv trees provided 
promising includes front takes advantage temporal coherence accelerate tree traversal algorithm 
library collision detection algorithms data structures current state chapter comparisons versus libraries 
chapter highlights application successfully applied collision detection algorithms data structures 
nc numerically controlled verification natural application techniques problem nc milling verify tool collide material left milling desired shape 
extensions chapter 
note dissertation compare collision detection timings various chapters 
essentially cases changes code compiler hardware 
important thing keep mind relative timings various software packages 
specific location experimental results attempt possible comparisons accurate fair 
see date experimental results collision detection system refer chapter 
chapter preliminary investigation chapter largely written martin held joseph mitchell 
new method performing collision detection tracking motion flying object tetrahedral mesh 
determine practicality method implemented additional methods performing collision detection standard data structures 
experiments conducted determine method efficient performing collision detection queries 
mesh algorithm fully implemented martin held refer complete coverage method including generation meshes implementation details relevant properties meshes 
included brief overview generation meshes completeness 
mesh collision detection particularly interested included description algorithm 
include details methods chapter 
preliminary investigation utilize standard box data structures 
data structures tree foundation rest dissertation built 
relevant experimental results reported section full set experimental results refer reader 
recall collision detection problem takes input geometric environment moving flying object asks find instants time flying object comes contact environment 
assume environment boundary set polyhedral obstacles 
representation typically consists facets obstacles shall assume triangulated 
refer triangles environment obstacle triangles 
flying object shall refer described triangles comprise surface 
chapter shall occasionally distinguish types collision detection ffl static collision detection check flying object particular position orientation intersects environment 
ffl pseudo dynamic collision detection check flying object intersects environment set discrete position orientation pairs corresponding object motion 
chapter 
preliminary investigation ffl dynamic collision detection check volume swept flying object intersects environment 
study focused mainly pseudo dynamic collision detection consistent vast majority related subject 
exact methods treating dynamic collision detection addressed considering dimensional time space problem modeling configuration space exactly 
mesh algorithm mesh method collision detection computational geometry results ray shooting meshes triangulations low stabbing number 
computational geometry data structures developed support ray shooting queries determine object hit ray emanates query point query direction 
possible obtain log query time roughly space sublinear query time space 
excellent subject see 
practical point view apparently promising methods pedestrian approach ray shooting build subdivision mesh low stabbing number query processing simply walk subdivision 
complexity query simply number cells triangles mesh met query ray hits obstacle 
line stabbing number mesh maximum number cells met query ray encounters obstacle 
shown chapter 
preliminary investigation worst case best possible triangulation set points space line stabbing number theta steiner points theta steiner points 
collision detection method introduced preprocessing step construct decomposition free space complement obstacles tetrahedral mesh marking triangular facets correspond obstacle boundaries 
rest section provide brief overview mesh generation method followed collision detection algorithm utilizes mesh 
algorithm foundation pedestrian approach searching subdivision 
mesh generation current attempt generate conforming meshes low stabbing number delaunay triangulation obstacle vertices steiner points added order triangulation mesh conform mesh conforms tetrahedron lies partially inside partially outside environment obstacle 
words boundary obstacle environment corresponds union faces tetrahedra 
start original vertices compute delaunay triangulation 
check triangular facet intersected facet delaunay tetrahedron 
course compute pairwise intersections facets tetrahedra scan mesh checking neighborhood obstacle triangle 
intersection exists mesh conforms 
chapter 
preliminary investigation obstacle triangle steiner point chosen delaunay triangulation incrementally updated 
scheme applied repeatedly mesh conforms 
suitable steiner points obtained points intersections edges obstacle triangles facets tetrahedra vice versa 
collision detection mesh suppose tetrahedral mesh conforms obstacle environment flying object facets assumed triangles 
want determine query instance position orientation intersects environment 
obviously flying object intersect environment facet triangles intersects environment obstacle environment lies completely inside flying object vice versa 
address problem section 
simple observation refined phase approach static collision detection mesh phase compute bb axis aligned bounding box enumerate tetrahedra lie partially inside bounding box 
sake simplicity current implementation enumerates possibly larger set tetrahedra bounding boxes overlap bb 
provided tetrahedron contains corners bb known tetrahedra determined straightforward computationally inexpensive breadth search faces tetrahedra part obstacle boundary collision occur 
phase ii full resolution static collision chapter 
preliminary investigation check performed checking facet triangle collision hopefully obstacle faces determined phase theory pairs collision check facets selected obstacle faces avoided making mesh 
attempts take additional advantage mesh structure turned competitive limited pairs check practice 
static collision check easily extended pseudo dynamic collision check 
preprocessing step locate vertex bb mesh determine tetrahedron contains 
locating point done shooting ray center gravity tetrahedron point 
soon vertex located static check collision carried 
motion step vertices bb updated 
furthermore new location corner bb mesh obtained shooting ray previous location algorithm outlined applied 
algorithm shooting ray fairly simple 
basically tetrahedron neighbors face shared tetrahedra intersected ray 
algorithm stops soon goal point contained actual tetrahedron new intersection ray face tetrahedron exists 
note test lies completely interior obstacle vice versa easily carried starting boundary environment mesh scanned tetrahedra lie inside obstacle marked 
test lies completely implemented 
chapter 
preliminary investigation interior obstacle obstacle lies completely interior boils checking tetrahedra partially occupied marked 
tetrahedra enumerated collision check anyway checked efficiently 
simple box methods mesh method implemented tested order determine practicality necessary compare alternatives 
section describe alternative collision detection algorithms implemented tested comparison purposes experimental results described section 
methods standard data structures attempt localize flying object environment greatly reduce number obstacle triangles need considered contact flying object grid boxes simplest method imagine doing spatial indexing imposing grid equal sized boxes workspace assumed unit cube 
implementation method theta theta grid boxes cubes 
ran experiments optimize choice typically kept relatively small order 
box voxel grid store list obstacle triangles intersect voxel 
single obstacle triangle may stored lists chapter 
preliminary investigation voxels size resulting data structure large comparison size input 
issue addressed experimentation 
preprocessing trivially done worst case time delta possible faster time proportional sum list sizes boxes scan converting obstacle facet grid time proportional number boxes intersected facet 
processing collision query done means phase approach phase compute axis aligned bounding box bb flying object identify set voxels intersect bb simply checking ranges bb 
consider obstacle triangle associated voxels 
bb bb know intersect bb bb witness potential collision perform full resolution check phase ii triangle flying object identify voxels intersected bb check intersection associated obstacle triangles stopping find intersection 
phase ii information gathered phase check triangle intersection facets bounding box intersect bb 
alternative method query compute set voxels intersected scan conversion test obstacle triangle associated lists intersection alternative implemented 
chapter 
preliminary investigation tree method simple approach representing spatial data store tree binary space partition bsp tree cuts chosen orthogonal coordinate axes 
root node associated workspace box 
node tree associated hyperrectangle box implicitly set obstacle triangles intersect box 
non leaf node associated cut plane 
define children node decisions cut orthogonal axis 
value chosen coordinate axis partition take place 
number obstacle triangles intersecting box falls threshold box partitioned corresponding node leaf tree 
explicitly store leaf list obstacle triangles intersect box 
process query region tested intersection environment start comparing cut plane root 
lies entirely side cut plane visit recursively corresponding child visit children 
visit leaf node check associated obstacle triangles intersection implementation process intersection query doing phase search tree 
phase search tree bb checking leaves intersection bounding box bounding box obstacle triangle 
find intersection immediately enter second full resolution phase search tree triangular facet flying object chapter 
preliminary investigation checking leaves intersection obstacle triangle stored leaf 
implementation choice split box axis split splitting midpoint corresponding box length 
consider option splitting median value coordinate issue median respect discrete values 
problem obstacle vertices associated triangles may fall outside range box 
choice different ways choose works best average minimize minimize jn gamma minimize delta divide longest side box 
sizes number associated obstacle triangles new problems created children 
results reported section choice selected running comparisons 
set gain threshold handle instances near high degree vertex splitting node decrease number obstacle triangles children 
allow splitting occur cases bounded number times gain threshold 
ran experiments optimize choice threshold ended runs reported 
trees boxes alternative tree representation obstacles simple idea trees rectangle trees variants 
basic idea partition set obstacles associated node chapter 
preliminary investigation partitioning bounding box space associated node done bsp tree 
child nodes correspond respective subsets obstacles associated space occupied bounding boxes may overlap 
level tree obstacle triangle associated single node 
type data structure extensively studied database community numerous comparisons performed determine performs best fastest queries fewest disk accesses 
information please refer 
describe binary tree version multi ary trees possible 
node tree corresponds rectangular axis aligned box subset obstacle triangles 
root associated entire workspace obstacles 
consider node having associated set obstacle triangles 
jt threshold value parameter experiments node leaf store triangles list associated leaf 
split roughly half median coordinate centroids assigning triangles children nodes centroids fall respect median value 
select choices splits minimizing volumes bounding boxes subsets result choice split 
results reported choose minimize selected running comparisons 
chapter 
preliminary investigation experimental results environments flying objects ideally purpose experimentation algorithm generate random instances realistic obstacle environments 
problem generating random collections obstacles challenging problem generating single random simple polygon set vertices open 
approach set experiments random bsp tree partition workspace unit cube set disjoint boxes leaves place scaled copies various obstacles 
generate random bsp tree follows gamma stages desired number leaf boxes select random leaf box split set active leaves initially just single node consisting workspace 
axes corresponding box longer ffl ffl 
gamma select random split box plane perpendicular axis point uniformly distributed min ffl max gamma ffl min max min max box coordinates chosen axis 
purpose ffl prevent obstacles generated 
leaf removed active list new children leaves created 
recorded flight statistics different groups obstacle environments called scenes tetrahedra terrains 
groups generated means random bsp tree partition described random subset leaves filled chapter 
preliminary investigation simple objects environments scenes group tetrahedra group 
various test objects chess pieces mechanical parts aircraft models animals 
table summarizes complexities environments denotes number vertices denotes number triangles 
third group environments generated data real world terrains 
sampled called degree dem data converting theta elevation arrays theta elevation arrays 
elevation arrays converted triangulated surfaces means straightforward triangulation data points 
table lists terrains tests 
groups environments tested flying objects various complexities listed table 
environments scaled fit unit cube flying objects scaled fit cube side length 
flight paths choice flying object obstacle environment wanted gather statistics efficiency collision detection rigid motions free space 
option doing pick random feasible initial placements perform random rigid flight paths stopping obstacle encountered 
reasonably test objects obtained means anonymous ftp ftp site navy mil converted various data formats input format 
obtained dem data means anonymous ftp ftp site cr usgs gov 
chapter 
preliminary investigation grid tree tree env 
name st height height st buffalo denver denver eagle canyon jackson seattle rp rp room room easy cows table characteristics test environments number vertices triangles environment respectively 
st number triangles stored grid tree methods 
heights tree tree provided 
chapter 
preliminary investigation flying object vch tetra bishop balloon spitfire table complexities flying objects ch number vertices triangles convex hull vertices respectively 
cluttered workspaces method resulted short flight paths collision experiment repeated order obtain extensive data selection random start point relatively costly generated random placement checked feasibility event cluttered environments 
alternatively construct full configuration space relative generate point random space believed approach costly implement 
devised simple solution path generation problem billiard paths allowing bounce obstacle hits 
attempt simulate real bounce simply reverse trajectory collision occurs 
motion generated simple scheme randomly perturbing previous motion parameters displacement vector angles rotation obtain new motion parameters 
algorithms heavily rely availability bounding box implemented fast method updating bb flight 
particular step new bounding box obtained efficiently chapter 
preliminary investigation simple hill climbing algorithm applied precomputed convex hull collision detection results sequel describe results collision detection experiments 
note implementation programming language order achieve optimal speed 
tests fair methods implemented rely basic primitives 
potential speed gained fine tuning expected benefit methods uniformly 
tests reported run silicon graphics indigo single mhz processor main memory 
time consumed algorithms includes computations exception rendering 
random flight paths generated run time included timings 
new location flying object transform vertices object located new position workspace 
rationale visualize flight objects environment current location object rendering 
currently interested detecting collision occurs flying object environment location determined collision terminate collision detection algorithm 
report pairs triangles contact exists 
tables chapter flight statistics gathered methods tested 
method environment flying object pair list frame rate number collision detection queries perform second 
frame rates chapter 
preliminary investigation listed determined follows environment flying object pair methods recorded statistics flight object billiard path steps average displacement flying object subsequent steps 
values elapsed cpu time number full resolution collision checks recorded 
elapsed cpu time number steps average number frames steps second computed 
average frame rate highly depends number full resolution collision checks large majority computations performed identical methods environment object pair 
order able compare frame rates different flying objects different environments normalized frame rates respect number actual full resolution collision checks 
tables column shows hypothetical average frame rate flight steps give rise full resolution collision check 
translates full resolution checks steps flights averaged full resolution collision checks actual collision 
normalized frame rates counted number times method fastest methods see table 
case close ties methods counted winners 
summarizing rtree method clear winner mesh method second place tree method clear loser 
previous ranking counts number wins may correctly highlight method performs best average 
second method ranking follows 
environment object chapter 
preliminary investigation env 
name tree grid tree mesh terrains scenes total table number wins method 
pair assigned score methods sorted fastest method scored slowest fourth method scored methods scored 
scoring adapted close ties 
summing environment object pairs best method hypothetical average case method smallest total score see table 
tree took place comparison closely followed grid method tree third place mesh algorithm fourth place 
env 
name tree grid tree mesh terrains scenes total table weighted ranking method 
mesh method evident tables computational overhead carried mesh method high pay relatively simple flying objects 
tests mesh method far slowest flying tetrahedron tetra 
chapter 
preliminary investigation competitive complex flying objects quite wins flying aircraft models spitfire 
similarly investigated mesh method performed poorly environments scenes group room room cows 
environments flights achieved surprisingly low number full resolution collision checks mesh method little gain exploiting structure mesh 
box methods tables clearly show tree method fastest test environments 
somewhat surprised positive results encouraging lead extensive investigation data structures type 
optimizing various parameters methods chose grid method threshold tree 
tree threshold number triangles stored equals number original triangles 
numbers triangles stored methods columns st table 
columns labelled height refer heights various trees 
full resolution checks second algorithms collision detection phase methods 
phase crude bounding box flying object determine refined second phase need entered 
second phase referred full resolution phase actual triangles facets flying object searching appropriate data structure 
chapter 
preliminary investigation frame rates tables average number collision queries algorithms able perform second 
averages taken flights steps length collision queries resulted expensive full resolution checks 
flight required considerably full resolution checks average framerate drop dramatically 
investigated amount time required perform full resolution check worst case queries reached second phase algorithms know queries answer second 
determine cpu time consumed static full resolution collision check ran series experiments 
environments groups environments flying objects timed different full resolution collision checks 
timings obtained moving flying objects billiard path timing collision checks placements flying object resulted collisions 
order get accurate timings collision check particular placement flying object performed repeatedly total cpu time consumed measured divided number collision checks performed 
averaging different placements yielded average cpu consumption full resolution collision check 
resulting numbers full resolution checks second table 
roughly ranking algorithms number full resolution checks matches rankings tables 
chapter 
preliminary investigation implemented simple box methods answering collision detection queries compared mesh method founded principles low stabbing number meshes put forth computational geometry literature 
chapter experimental study comparing relatively straight forward methods complex theoretical method determine perform better practice 
results experiments somewhat surprising 
simply counting number times method won tree method far fastest 
distant second place mesh method 
looking average performance methods ranking methods finished environment flying object pair mesh method performed worst methods 
tree best followed closely grid method 
tree method fastest method memory efficient 
recall grid tree methods stored obstacle triangles cells leaves increasing amount memory needed 
tree method stores triangle important sizes datasets increase hundreds thousands millions triangles 
reasons thorough investigation tree method chapter 
preliminary investigation variations new extensions 
chapters notation terminology changed considerably describing tree method 
fact shall longer refer tree implies axis aligned bounding boxes bounding volumes node tree 
soon shall see chapter bounding volumes efficient 
chapter 
preliminary investigation mesh grid tree tree env object rp tetra rp rp bishop rp balloon rp spitfire rp rp tetra rp rp bishop rp balloon rp spitfire rp rm tetra rm rm bishop rm balloon rm spitfire rm rm tetra rm rm bishop rm balloon rm spitfire rm easy tetra easy easy bishop easy balloon easy spitfire easy cows tetra cows cows bishop cows balloon cows spitfire cows tetra bishop balloon spitfire table flight statistics scenes 
chapter 
preliminary investigation mesh grid tree tree env object buffalo tetra buffalo buffalo bishop buffalo balloon buffalo spitfire buffalo denver tetra denver denver bishop denver balloon denver spitfire denver denver tetra denver denver bishop denver balloon denver spitfire denver eagle tetra eagle eagle bishop eagle balloon eagle spitfire eagle canyon tetra canyon canyon bishop canyon balloon canyon spitfire canyon jackson tetra jackson jackson bishop jackson balloon jackson spitfire jackson tetra bishop balloon spitfire seattle tetra seattle seattle bishop seattle balloon seattle spitfire seattle table flight statistics terrains 
chapter 
preliminary investigation mesh grid tree tree env object tetra bishop balloon spitfire tetra bishop balloon spitfire tetra bishop balloon spitfire tetra bishop balloon spitfire tetra bishop balloon spitfire tetra bishop balloon spitfire tetra bishop balloon spitfire tetra bishop balloon spitfire table flight statistics 
chapter 
preliminary investigation env 
name fly 
obj 
tree grid tree mesh eagle tetra eagle eagle bishop eagle balloon eagle spitfire eagle canyon tetra canyon canyon bishop canyon balloon canyon spitfire canyon tetra bishop balloon spitfire tetra bishop balloon spitfire rp tetra rp rp bishop rp balloon rp spitfire rp rm tetra rm rm bishop rm balloon rm spitfire rm table number full resolution checks second method 
chapter bv trees chapter collision detection method hierarchy axis aligned bounding boxes trees promising methods considered 
success method directed investigation utilizing similar data structures 
chapter provide thorough description data structures including choice bounding volume design choices constructing hierarchies 
preliminary investigation built hierarchy environment build hierarchy flying object dramatically reduce collision detection query times 
parts chapters originally published journal written martin held joseph mitchell henry karel 
chapter 
bv trees assume input set geometric objects purposes generally expected triangles specify boundary polygonal models 
discussion applies general objects 
bv tree tree bvt specifies bounding volume hierarchy node bvt corresponds subset root node associated full set internal non leaf node bvt children maximum number children internal node bvt called degree bvt denoted ffi 
subsets correspond children node form partition set objects associated complete bv tree leaf nodes associated singleton subsets total number nodes bvt gamma height complete tree dlog ffi ne achieved bv tree balanced 
associated node bvt bounding volume outer approximation set smallest instance specified class shapes boxes spheres convex hulls polytopes class 
emphasize bv trees hierarchy geometric objects hierarchy partitioning space octrees bsp trees trees spatial subdivisions naive geometric hashing tend blow memory consumption objects overlap boundary cells subdivisions stored multiple times 
goal handle complex environments potentially consisting millions polygons chapter 
bv trees afford memory blowup 
discuss algorithms data structures chapters indicate memory requirements methods section provide summary total memory usage 
focusing primarily case single rigid object specified set boundary primitives triangles particular position orientation moving flying environment specified set obstacle primitives triangles 
refer bvt flying hierarchy bvt environment hierarchy 
designing constructing bv trees important decisions need 
important class bounding volumes approximate set objects associated node hierarchy 
issue addressed sections 
design criteria choice class classes shapes bounding volumes bv tree usually dependent application domain different constraints inherent 
ray tracing example bounding volumes chosen tightly fit primitive objects allow efficient intersection tests ray bounding volumes 
hooper greenberg discussed making choice ray tracing provided cost function help analyze hierarchical structures bounding chapter 
bv trees volumes 
gottschalk lin manocha looked cost function context collision detection 
large input models hierarchies built approximate total cost check models intersection quantified theta theta total cost function collision detection number pairs bounding volumes tested overlap cost testing pair bounding volumes overlap number pairs primitives tested contact cost testing pair primitives contact 
equation reasonable measure cost associated performing single intersection detection check take account cost updating flying hierarchy flying object rotates 
choices bounding volumes spheres little cost associated updating flying hierarchy general cost particular experience update cost choice dops 
propose collision detection motion simulation cost best written sum component terms theta theta theta defined equation number nodes flying hierarchy updated cost updating node 
cost function bounding volumes approximate tightly input primitives lower permit chapter 
bv trees rapid intersection tests determine bounding volumes overlap lower updated quickly primitives consequently bounding volumes rotated translated scene lower 
unfortunately objectives usually conflict balance reached 
discrete orientation polytopes concentrate experience bounding volumes convex polytopes facets determined halfspaces outward normals come small fixed set orientations 
polytopes coined term discrete orientation polytopes dops short 
see page illustration dimensions dop fixed normals determined orientations sigma sigma sigma sigma degrees 
axis aligned bounding boxes dops orientation vectors determined positive negative coordinate axes 
concentrate dops dops dops dops defined orientations particularly natural see section detail 
researchers ibm dops call boxes visual approximation purposes dix 
learned researchers ge begun dops called gems speeding visualization large datasets 
idea planes fixed orientations approximate set primitive objects introduced ray tracing kay alternative name call dop term fixed directions hull slightly precise term harder pronounce abbreviation 
chapter 
bv trees kajiya 
axis aligned bounding boxes aabbs hierarchies simple compute allow efficient overlap queries 
aabbs particularly poor approximations set bound leaving large empty corners consider example needle object lies degree orientation axes 
highlights situation 
dops larger values allows bounding volume approximate convex hull closely 
course improved approximation tends lower comes cost increasing cost testing pair dops intersection cost updating dops flying hierarchy 
keep associated costs small possible dops discrete orientation normals come pairs collinear oriented vectors 
kay kajiya referred pairs bounding slabs 
aabb bounds finds minimum maximum values primitives directions dops bound primitives directions 
words think dops capturing dimensions objects lines project objects set lines compute extents line 
computing dop carried computing simple dot products vertices vectors 
consequently computing dop set polyhedral objects total vertices done straight forward brute force approach kn time 
importantly simple robust computation 
chapter 
bv trees simple example compute dops 
dop triangle shown dashed lines 
illustrate compute dops consider simple dimensional triangle shown 
example approximate triangle dop shown described 
compute dop triangle dot product vertices triangle vectors gamma define particular dop 
example find minimum maximum extents direction perform dot products ffi ffi ffi chapter 
bv trees determine minimum maximum respectively 
performing dot products find minimum maximum extents directions gamma gamma respectively 
procedure easily modified compute dops complicated objects 
tools computational geometry prove better bound complexity computing dop large 
result interesting right typically construction dops done straight forward approach due ease implemented 
proposition bounding dop set triangles computed time log log hg complexity convex hull proof 
compute ch time log 
compute dobkin kirkpatrick hierarchy ch time extremal queries directions answered time log query 
ut thinking dops intervals set directions conservative test intersection dops essentially trivial checking aabbs overlap simply perform interval overlap tests 
complete discussion overlap test dops please refer section 
test far simpler checking intersection chapter 
bv trees obbs convex hulls 
elegant results comparing obbs takes operations average operations worst case significantly harder comparing dops 
defining directions fixed memory required store dop values value plane orientations planes known advance 
bounding spheres natural choice approximate object particularly simple test pairs overlap update moving object trivial 
spheres similar aabbs poor approximations convex hull contained object 
see 
bounding spheres yield low costs may result large number bounding volume overlap tests large number pairs primitives test 
result spheres general poor approximations objects considerable amount preprocessing time required construct hierarchical approximation spheres illustrated hubbard 
oriented bounding boxes obbs yield tighter approximations spheres aabbs illustrated 
particular obb approximate single dimensional triangle oriented box tend flat axes parallel normal vector triangle 
relatively simple update obb multiplying transformation matrices 
cost determining obbs overlap roughly order magnitude larger aabbs 
extreme convex hulls provide tightest possible convex bounding volume test overlap update costs chapter 
bv trees relatively high 
comparison choice dops bounding volumes hopes striking compromise relatively poor tightness bounding spheres aabbs relatively high costs overlap tests updates associated obbs convex hulls 
parameter allows flexibility striking balance competing objectives 
moderate values cost conservative overlap test dops order magnitude faster testing obbs 
updating dop rotating object complex updating bounding volumes developed simple approximation approach discussed section works practice 
page highlights differences typical bounding volumes 
provide simple dimensional illustration object corresponding approximations axis aligned bounding box aabb sphere oriented bounding box obb dop 
design choices constructing bv trees important decisions building bv trees class bounding volume approximate input models 
having discussed issue previous sections deciding dops highlight additional decisions extremely relevant 
sections consider comparison various design choices constructing bv trees including degree ffi tree binary ternary chapter 
bv trees top versus bottom construction static versus dynamic data structures fixed directions dops splitting rules 
mention words building bv trees general 
preprocessing step general construction bv tree bvt preprocessing step done real time 
permits optimizations done may result greater speed real time usage tree collision detection 
preprocessing effort free 
applications may acceptable spend hours preprocessing large environment order optimize bv tree speed interactive applications user willing wait seconds minutes complete preprocessing 
feel important allow user select options control degree optimization speed preprocessing 
option allow user input output pre computed bv trees possible perform extensive optimizations complex environments peak times handy matter seconds needed 
sections chapter shall describe choices need constructing bv trees 
appropriate shall highlight amount preprocessing time needed various options 
complex option optimization performed faster hope queries 
may instance chapter 
bv trees want spend week building bv tree get speed query time compared bv tree built hour 
degree tree minimizing height tree usually desirable quality building hierarchy searches performed traverse tree root leaf small number steps 
degree ffi specifies maximum number children node 
typically higher degree smaller height tree 
course trade trees high low degree 
tree high degree tend shorter expended node search 
hand low degree tree greater height expended node search 
chosen binary ffi trees experiments reported reasons 
simpler faster compute fewer options splits set partitions set subsets 
second analytical evidence suggests binary trees better ffi ary trees ffi 
particular considers balanced trees leaves internal nodes degree ffi amount expended searching single path root leaf proportional ffi ffi gamma delta log ffi ffi gamma ffi children need tested know descend 
simple calculus shows function ffi monotonically increasing interval ffi 
restricting ffi integer values greater see ffi minimized ffi 
course analysis address chapter 
bv trees fact typical search bv tree consist single root leaf path 
limited investigation typical searches choice ffi justified 
leave thorough experimental investigation trade offs different values ffi 
top versus bottom constructing bv tree set input primitives top bottom manner 
bottom approach begins input primitives leaves tree attempts group recursively advantage local information reach single root node approximates entire set example approach boxtree barequet 
top approach starts node approximates uses information entire set recursively divide nodes reach leaves 
example approach 
tests reported construct bv trees topdown approach 
limited experience bottomup method tree construction experience comparing alternatives able definitive better leave issue investigation 
chapter 
bv trees static versus dynamic structures constructing bv trees distinguish static dynamic data structures 
static structure constructed easily modified accommodate insertions deletions set geometric objects 
change set primitive objects entire structure needs rebuilt scratch 
dynamic data structure just opposite updated new objects added removed set static structures specify objects set initially building hierarchy 
advantage dynamic structures having full knowledge objects approximated allow perform optimizations get potentially better query times 
course time restricted change input set rebuilding bvt 
top bottom approaches constructing static structures top approach common 
dynamic structures due flexibility provide 
dealing large datasets amount time required build order hours days 
need change primitive objects set want rebuild entire hierarchy scratch 
speed hierarchy update procedure change typically great concern little sense spend time updating hierarchy take rebuild entirely 
update operations done real time 
general dynamic structures built bottom fashion chapter 
bv trees application data retrieval example 
typically assume input set primitives completely provided cd queries performed build static data structures 
approach taken cd packages available rapid 
arguments assumption different applications cd queries different views 
applications working approach reasonable 
instance engineers finished designing large model new boeing change 
making assumption sense 
approach deemed reasonable ray tracing 
environment designed model office building house going change time preprocessing step worth effort 
previously mentioned trees performing collision detection 
structures frequently searching retrieving information large multidimensional databases 
application databases subject insertions deletions able efficiently maintain dynamic data structure important 
viewpoint assuming full knowledge set primitive objects realistic done 
typically hierarchies application built inserting deleting primitive object time updating hierarchy accordingly 
general dynamic structures permit queries fast performed static structures interesting note comparing hierarchical data structures data retrieval sr tree chapter 
bv trees dynamic performs vam split tree static structure 
choice dops discussed rationale dops sections 
having done need decide fixed directions 
investigations consisted choices dops dops aabbs dops dops dops 
specifically choice dop find minimum maximum coordinate values vertices primitives directions defined vectors gamma gamma gamma gamma 
particular dop uses halfspaces define facets aabb additional diagonal halfspaces serve cut corners aabb possible 
recall problems mentioned aabbs tendency leave empty corners 
tried avoid problem cutting corners 
choice dop derives halfspaces aabb augments additional diagonal halfspaces serve cut edges aabb halfspaces determined axes defined direction vectors gamma gamma gamma 
choice dop simply determined union defining halfspaces dops dops utilizing halfspaces aabb plus diagonal halfspaces cut corners plus halfspaces cut edges aabb 
emphasize choice dops strongly influenced ease chapter 
bv trees bounding volumes computed 
particular normal vectors chosen integer coordinates set gamma implying multiplications required computing 
leave investigation larger values dops determined normal vectors having integer coordinates set sigma sigma 
page provides example dops 
center picture input model spitfire aircraft 
images show left right top bottom corresponding dop dop dop dop approximates spitfire 
bv tree model bounding volumes shown represent bounding volume associated root node level choice similarly depict approximations spitfire dops level dops level dops level 
chapter 
bv trees splitting rules building hierarchies node bv tree corresponds set primitive objects bounding volume bv 
constructing effective bv trees goal assign subsets objects child node way minimize function sizes children size typically volume surface area 
ray tracing applications objective usually minimize surface area probability ray intersect bv proportional surface area 
collision detection minimize volume expecting proportional probability intersects object 
binary trees assignment objects children reduces problem partitioning 
js gamma different ways afford consider partitions 
associate triangle single representative point centroid split picking plane orthogonal coordinate axes assigning triangle side plane centroid lies 
results delta js gamma different nontrivial splits choices axis axis js gamma different splits centroid points 
choice axis choose plane orthogonal axis objective functions chapter 
bv trees min sum choose axis minimizes sum volumes resulting children 
min max choose axis minimizes larger volumes resulting children 
splatter project centroids triangles coordinate axes calculate variance resulting distributions 
choose axis yielding largest variance 
longest side choose axis dop longest 
amount time required evaluate objective functions varies greatly leads corresponding variation preprocessing time build bv tree 
longest side method fastest requiring subtractions comparisons determine axis choose 
fastest splatter method runs linear time js 
slowest methods min sum min max require calculate volumes occupied pairs possible children requires time compute dops candidate children plus log compute volumes dops 
chapter report results experiments comparing methods selecting axis 
see tables 
default method current software splatter method giving volume dop computed finding rep identify vertices summing volumes tetrahedra tetrahedralization dop obtained simply vertex information 
rep dop time log explained section 
chapter 
bv trees slightly worse collision detection times min sum method gives preprocessing time order magnitude min sum 
interesting variation investigate effect allowing axis chosen larger set may beneficial permit axis directions define dops bv tree 
course potential improvement collision detection time weighed increased cost preprocessing 
investigated option report effectiveness section 
choice split point chosen axis orthogonal splitting plane determine position splitting plane js gamma possibilities 
investigated depth natural choices splitting point mean centroid coordinates chosen axis median centroid coordinates 
chapter preliminary investigation bounding volume hierarchies median splitting rationale wants obtain balanced possible bv tree 
investigate option splitting mean case results tighter fitting bounding volume approximation harming balance tree severely 
table shows total volume environment hierarchies dop method datasets pipes torus swept interior commonly testing collision detection algorithms 
see chapter details datasets 
datasets chapter 
bv trees splitting rules described earlier section computed total volume occupied environment bv tree splitting points mean median 
computations mean produced hierarchy smaller total volume median 
cases reduction volume great cases reduction 
discovered min sum splitting rule provided hierarchy total volume longest side rule produced hierarchies greatest volumes 
previously mentioned trade mean opposed median longer generate balanced bv trees guarantee height hierarchy logarithmic 
experience height increase dramatically mean 
table height environment hierarchies dop method splitting rules splitting points 
median split point split rules generate bv trees height report median single row table 
datasets reported section compared number operations required collision detection hierarchies built choices 
test run operations performed median mean 
hierarchies deeper mean amount done collision detection checks due better approximations 
addition average collision detection chapter 
bv trees split rule mean median pipes longest side min sum min max splatter torus longest side min sum min max splatter longest side min sum min max splatter swept longest side min sum min max splatter interior longest side min sum min max splatter table standard data sets recorded volumes environment hierarchies splitting rules longest side min sum min max splatter split points mean median 
chapter 
bv trees split point splitting rule pipes torus swept interior median mean longest side mean min sum mean min max mean splatter table standard data sets report height environment hierarchies splitting rules split points 
time greater case median smallest increase largest increase 
clear tighter approximations provided mean outweighed better balanced trees produced median 
details experiments please refer tables section 
previously mentioned median advantages guarantee height bv tree logarithmic 
fact proposition highlights amount time takes build bv tree set input triangles 
proposition balanced bv tree built full height log constructed time log log ng 
proof 
construct bounding dop full set primitives store root 
determine split split median coordinate centroids takes time standard assuming select constant number splitting axes 
chapter 
bv trees proposition compute time log ng new dops resulting children recurse 
divide conquer algorithm requires time log ng solves log log ng 
ut implementation selects possibilities mean median split point 
propose alternatives investigation optimizing splitting decision depending preprocessing time available constructing hierarchy optimize js gamma different centroid coordinates random subset coordinates 
chapter 
bv trees aabb sphere obb dop approximations object bounding volumes bounding box aabb sphere oriented bounding box obb dop 
chapter 
bv trees level level spitfire aircraft corresponding dops level level hierarchy 
chapter 
bv trees level level spitfire aircraft corresponding dops level level hierarchy 
chapter collision detection bv trees turn problem best flying hierarchy bvt environment hierarchy bvt perform collision detection cd queries 
processing cd queries consider choices method updating dops flying hierarchy flying object rotates continue approximate subset primitive objects algorithm comparing bv trees determine collision depth flying hierarchy overlap test dops 
chapter 
collision detection bv trees tumbling bv trees position flying object need bv tree representing flying hierarchy order able perform cd queries efficiently 
flying object translate bv tree construct initial position orientation remain valid modulo translation vector position 
flying object rotates 
means transform translate rotate bounding dop represented node flying hierarchy new set bounding dops forming valid bv tree transformed object normal vectors defining different set vectors defining dops environment hierarchy rotate 
defeat purpose having dops bounding volumes overlap test dops having different defining normal vectors far costly conservative disjointness test required aligned dops 
important address issue tumbling bounding dops flying hierarchy 
cost updating operation denoted equation 
brute force approach issue recompute entire flying hierarchy step flight 
clearly slow consideration easily take seconds time hierarchy constructed 
somewhat naive approach preserve structure flying hierarchy changes sets update bounding dops node flying hierarchy step flight 
involves finding new maximum minimum values primitive vertex chapter 
collision detection bv trees coordinates axes defining dops 
costly terms time terms storage store node coordinates primitive vertices convex hull set vertices 
considered methods nodes preserving structure original hierarchy hill climbing algorithm stores rep boundary representation convex hull uses perform local updates obtain new exact bounding dop bounding dop previous position orientation 
local updates involve checking vertex previously extremal say maximal directions see maximal done examining neighbors vertex 
vertex longer maximal climb hill going neighboring vertex corresponding coordinate value increases 
nature algorithm exploits step step coherence requiring time updates corresponding smaller rotations 
worst case complexity upper bound tight extremal vertices may require omega gamma local moves rep update 
ii approximation method attempts find approximation outer approximation true bounding dop transformed method stores vertices dop computed model initial orientation 
important transform original rep vertices chapter 
collision detection bv trees brute force method compute exact bounding dop transformed set bounding dop contains transformed need smallest dop bounding 
shows dimensional example method ii 
example original object dop shown 
depicts object rotated degrees counterclockwise corresponding dop 
result tumbling original dop recomputing new dop shown 
dashed lines represent rotated original dop solid lines show new dop approximate object 
ideally want approximate dop close exact dop shown 
note dop need strictly larger exact dop rotated object typically case 
instance dop depicted rotating object degrees causes dop coincide exact dop 
methods ii rely preprocessing step compute rep method precompute convex hull vertices store result simple rep method ii compute vertices rep dop original orientation means compute intersection halfspaces 
done appealing fact see intersection set halfspaces determined computing convex hull set points dual planes defining halfspaces bounding dop step 
transform bounding dop compute new bounding dop transform bounding volume grow increasingly larger step 
standard definition duality dual point associated plane chapter 
collision detection bv trees converting convex hull back primal space vertex edge facet convex hull corresponds facet edge vertex intersection halfspaces 
compute convex hull dual points simple incremental insertion algorithm see 
dop dop rotated object dop rotated dop illustration approximation method ii updating dop approximates rotating object 
equation ax cz point 
see 
algorithm worst case quadratic running time works practice preprocessing small 
worst case optimal log time algorithms known problem see 
chapter 
collision detection bv trees considered trade offs methods ii 
nodes closest root flying hierarchy frequently visited searching 
important bounding dops nodes tightly fitting possible hopefully prune branch tree 
suggests apply method root node nodes close root node flying hierarchy 
implemented tested algorithm methods conducted experiments determine extra cost method worth nodes near root hierarchy 
cases worthwhile spending time compute exact bounding dop root node time saved due pruning greatly outweighed additional time spent doing hill climbing 
performed experiments applied method nodes levels tree close root 
additional overhead justified time saved due additional pruning outweigh extra time required perform hill climbing 
fact total running time increased method nodes root node 
consequently currently approximation method ii nodes hierarchy root node perform hill climbing 
regardless method update nodes flying hierarchy important understand necessarily required update nodes hierarchy location flying object 
cases able determine triangles flying object contact environment updating node 
shall see section searching environment chapter 
collision detection bv trees hierarchy root node flying bv tree 
determine environment triangles overlap node approximation flying object determined flying object environment disjoint update nodes flying bv tree 
root node flying bv tree overlap environment triangles may additional nodes highly pathological case nodes flying bv tree need updated 
addition node particular location flying object due flag maintained node flying hierarchy 
flying object moved new location may need updated determined search algorithm updated location flying object 
interesting research question suggested 
flying hierarchy constructed object initial position orientation 
alternative try finding optimal orientation flying object optimal possibly interpreted orientation minimizes total volume hierarchy allows efficient collision checks 
tree traversal algorithm environment hierarchy bvt flying hierarchy bvt traverse trees efficiently determine part flying object collides part environment 
algorithm chapter 
collision detection bv trees currently outlined algorithm 
consists recursive call current node flying hierarchy current node environment hierarchy 
initially set root nodes hierarchies 
prior calling search algorithm update method described section approximating flying object current location 
nodes flying hierarchy updated prior recursive call step see description 
algorithm input node flying hierarchy node environment hierarchy 

leaf 
leaf 
triangle 
triangle 
check test triangles intersection 

child 


child 

return algorithm pseudo code tree traversal algorithm 
general stage traversal algorithm test overlap bounding volume bounding volume 
disjoint done call function 
chapter 
collision detection bv trees leaf step level environment hierarchy recursively calling children leaf check leaf triangle triangle intersection tests triangle triangle step level flying hierarchy recursively calling children stage update nodes flying hierarchy updated particular location flying object 
comparison purposes implemented variant traversal algorithm step algorithm replaced root environment hierarchy 
rationale variant may bounding volume node flying hierarchy intersects large number leaves environment hierarchy bvt children form tighter approximation intersect far fewer leaves bvt 
especially true nodes flying hierarchy approximation method tumbling dops results looser fitting bounding volumes 
restarting search root bvt child may fewer overlap checks total 
experimentally variant perform practice describe algorithm 
general approach performs overlap checks updates nodes default search algorithm 
cases variant better yielding slightly lower average cd time usually inferior 
particular suite experiments reported variant slower cases 
table chapter 
collision detection bv trees section compares search algorithms dop method 
emphasize search algorithm efficient circumstance 
having information priori interaction moving object environment greatly improve collision detection query time better tailor search algorithm specific conditions 
time critical computing 
bounding volume hierarchies useful time critical cd checks cf 
hubbard essential maintain frame rate haptics expense interrupting cd algorithm completes query definitive answer 
course cd query discovers disjointness stops reports cd query algorithm interrupted know flying object disjoint environment 
possibility algorithm instance contact flying object environment completed search contacts 
run algorithm time critical mode report conservative answer collide 
effectiveness bounding volume hierarchies time critical computing depends bound degree overlap depth possible penetration cases terminate search prematurely 
see particular order terminate small degree possible overlap consider carefully choice tree traversal algorithm descending trees environment flying object lock step alternately descending level hierarchy able decrease chapter 
collision detection bv trees average overlap bounding volumes cover flying object cover environment obstacles state search 
contrast searching strategy employ described goal traverse trees way minimize total time needed report collisions exactly 
depth flying hierarchy depth flying hierarchy significant impact total cost associated performing collision detection query affect values equation 
deeper hierarchy tend increase number bounding volume overlap tests number nodes updated decrease number pairs primitives triangles checked contact 
shallower tree tend opposite effect 
depth hierarchy increases quality approximation input models increases 
referring page page see quality approximation level bv tree better tighter level approximation dop methods 
similarly compare level approximation uses dops level tightly fitting set bounding volumes 
plain see level approximation consists dops best 
problem selecting optimal depth difficult address general highly data dependent dependent costs chapter 
collision detection bv trees moment hard coded threshold number triangles associated node falls consider node leaf tree 
experiments reported threshold environment hierarchy threshold flying hierarchy 
values determined large variety datasets 
leave open problem determine effective methods automatically determining thresholds allowing variable thresholds different nodes hierarchy 
taken closer look selection hard coded thresholds section suggest simple minded scheme lead improved cd query times 
overlap intersection tests processing cd query frequently called function usually testing dops overlap 
cost operation denoted equation 
recall dops defined fixed set directions particular dop completely defined intervals describing extents directions 
case aabb defined intervals axis dops overlap intervals overlap corresponding interval find dops overlap directions conclude dops may overlap 
may disjoint separated plane parallel edge dop efficiency chapter 
collision detection bv trees conservative disjointness test directions 
need comparisons floating point numbers arithmetic operations overlap test 
dop overlap tests indicated dops overlap intervals define dops disjoint 
claim proposition corollary proposition convex polytopes disjoint interiors exists separating hyperplane spanned set gamma vectors parallel edges proof 
gamma hyperplane supporting facet gamma separates gamma completes proof known facets gamma form gamma faces facet spanned set gamma edges gamma edges parallel edges ut specifically dimensional polytopes immediately corollary denotes projection line 
results closely related called separating axis theorem gottschalk 
lou cornell university discussions facts polyhedral theory 
proof included 
chapter 
collision detection bv trees corollary set lines parallel set directions determined cross products pairs edges results raise interesting question sufficient check intervals defined directions determine dops overlap 
known testing axis aligned bounding boxes dops simply check intervals defined directions 
checking dops sufficient test intervals defined normal vectors 
checking intervals conclude dops overlap intervals overlap fact dops overlap 
approach conservative pointed collisions objects 
define closure set normal vectors normals define dop set direction vectors obtained cross product pair edges dops 
facets dops fixed directions edges dop certain set fixed directions 
find directions edges dop simply cross product pair normal vectors define facets dop 
naive bound number directions closure set normal vectors conclude proposition corollary closure equals closed sufficient check intervals defined normals determine dops overlap 
chapter 
collision detection bv trees proposition sets vectors define dop dop dop dop respectively 
proof 
proof proposition means exhaustive enumeration directions closure particular dops 
ut dop dop suspect closure sets superset closed operation 
note determinants matrices closures set vectors having integer coordinates sigma sigma gamma nonzero elements defining distinct directions 
enumerate sets 
dops easily perform exact overlap test candidate separating directions closure mentioned taken conservative approach problem directions define dop 
note conservative approach exact dops 
order interval tests performing overlap test order check intervals may effect efficiency primitive 
example intervals defined direction overlap intervals defined direction fairly close chapter 
collision detection bv trees result overlap 
order interval tests test intervals largely different directions 
doing hope quickly find direction exists intervals overlap exit routine 
highlights situation 
project boxes axis denoted see projections clearly overlap 
similarly boxes projections second direction oriented fairly closely results overlap 
fact directions result overlap projections 
consider direction varies greatly may able determine boxes overlap case 
course pointed boxes overlap directions matter order intervals tested result overlaps 
purpose approach terminate routine quickly possible determining dops disjoint 
current implementation uses philosophy ordering intervals overlap test 
considering orderings may speed average overlap queries 
details discussed section triangle triangle intersection tests lowest level cd query algorithm leaf environment hierarchy overlaps leaf flying hierarchy ultimately able test primitives triangles intersect 
refer dimensional boxes dops 
chapter 
collision detection bv trees cost operation denoted involves arithmetic operations floating point numbers 
martin held developed collection efficient intersection tests pairs primitive geometric elements see held details triangle triangle intersection test 
chapter 
collision detection bv trees example illustrate philosophy ordering intervals overlap test 
directions oriented relatively closely result overlap projections boxes 
direction oriented degree angle disjointness discovered 
chapter implementation experimentation algorithms implemented tested variety platforms sgi sun pc 
run general polygonal models called polygon soup easily handle cracks self intersections deficiencies input data 
applications forced handle bad data may cad surface models having topologically consistent boundary representation having unintentional penetrations pairs primitives 
assumed topological structure input 
simply cracks gaps surface polygonal model caused edge having incident face 
chapter 
implementation experimentation assume input consists list vertices list triangles adjacency information 
reason report surface intersections volumetric intersections 
bv tree construction collision detection algorithms robust relatively simple decisions topology data run inconsistency problems due floating point errors searching building bv trees 
avoid missing collisions objects epsilon threshold ffl specified user 
ffl search bv trees opted buffer dops environment hierarchy ffl computed 
ensures collisions search slowed arithmetic operations 
course routines test triangles intersection perform arithmetic operations ffl 
order maintain efficiency implementation dops hard coded logic choices choose value appropriate code compile time means compiler switches 
chapters report comparisons system called rapid rapid accurate polygon interference detection publicly available university north carolina chapel hill utilizes oriented bounding box trees 
www cs unc edu geom obb html chapter 
implementation experimentation rapid developed parallel system reported siggraph see leading cd systems available 
results reported show system quickcd compares favorably rapid speed memory usage substantially faster cases 
conclude cases methods bounding dops potentially better choice methods oriented bounding boxes 
memory requirements environment dataset input triangles store array bytes vertices triangles coordinates byte floating point numbers array bytes integer indices vertex array indicating triangles vertices comprise 
indices absolutely necessary triangles share vertices memory efficient expense appearing wasteful memory calculations 
node environment hierarchy need store numbers define bounding dop bytes pointers children node bytes integer index indicate triangle stored leaf bytes 
need bytes node 
approximately gamma exact nodes hierarchy complete binary tree leaf containing just triangle 
total need bytes store triangles environment hierarchy 
substituting chapter 
implementation experimentation pipes torus swept interior 
triangles dop dop dop dop rapid table total memory megabytes required store environment hierarchy datasets 
see need bytes input triangle respectively 
comparison reported rapid implementation requires bytes input triangle 
table highlights total memory required store environment bv tree datasets typically testing collision detection algorithms 
datasets introduced shortly 
memory store flying object triangles identical storing environment bytes 
memory needed flying hierarchy difficult put closed form expression highly data dependent 
particular threshold stopping construction hierarchy discussed section means having gamma nodes hierarchy gamma denotes number leaves vary need store original rep vertices initial dops section node numbers vary choice flying object 
compute worst case upper bounds number chapter 
implementation experimentation pipes torus swept interior dop mb mb mb kb kb dop mb mb mb kb kb dop mb mb mb kb kb dop mb mb mb kb kb rapid mb mb mb kb kb table total memory required store flying object hierarchy datasets 
megabytes kilobytes abbreviated mb kb respectively 
vertices rep dops maximum possible number vertices dop respectively 
node flying hierarchy store numbers define dop bytes pointers children bytes number triangles bounded dop bytes threshold case list triangle indices bounded node number original rep vertices bytes list rep vertices integer indicate node bytes avoid re tumbling node accessed single cd query section 
addition need store rep convex hull associated root node flying hierarchy section 
experiments reported flying pipes dataset required memory megabytes store convex hull 
table reports actual total memory store flying object hierarchy datasets 
discussion include memory required run time environment 
chapter 
implementation experimentation pipes torus swept interior dop mb mb mb kb kb dop mb mb mb kb kb dop mb mb mb kb kb dop mb mb mb kb kb table number bytes required store flying object hierarchy excluding rep vertices convex hull 
pipes torus swept interior dop mb kb kb kb kb dop mb kb kb kb kb dop mb kb kb kb kb dop mb mb mb kb kb table number bytes required store reps original flying hierarchy 
break memory usage components 
indicated number leaves flying hierarchy helps determine amount memory required bv tree 
number leaves flying bv trees respectively pipes spikes swept interior datasets 
information tabulated table memory needed store flying object hierarchy excluding reps convex hull 
remaining components contribute memory needed flying object computed simple formula 
tabulated actual memory needed datasets components tables 
chapter 
implementation experimentation pipes torus swept interior dop mb kb kb kb kb dop mb kb kb kb kb dop mb kb kb kb kb dop mb kb kb kb kb table number bytes required store convex hull flying object 
pipes torus swept interior dop dop dop dop rapid table total memory megabytes required store environment flying object bv trees 
total memory required methods process datasets listed table 
see smallest dops require memory rapid implementation 
dop requires memory pipes dataset general bounding volume require memory obb rapid 
experimental set experiments real simulated datasets various complexities ranging tens triangles triangles 
chapter 
implementation experimentation special effort devise datasets particularly difficult method 
instance considered swept volume datasets moving object swept space random motion numerous obstacles randomly placed close penetrating swept volume fly object original path causing come close collision thousands nearby obstacles hitting 
challenging datasets arise practice goal study systematic comparison alternative methods alternative choices parameters methods 
results reported silicon graphics indigo single mhz ip processor megabytes main memory maximum impact graphics board 
code compiled gnu gcc respectively rapid 
timings obtained adding system user times reported library function times 
order smooth minor variations timings tests run repeatedly report average times 
ran rapid machine timing command appreciate difficulty exists making comparisons different algorithms implemented different people 
issues tolerances overlaps geometric primitives tested intersection play crucial role algorithm performance 
know extent rapid optimized achieve efficiency 
rapid assembler code order speed computations serves indication certainly optimized extent 
chapter 
implementation experimentation experimental results average costs reporting results experiment determine average cost testing primitives triangles intersection code 
triangle triangle intersection queries bounding boxes overlap order avoid simple rejections average query time test milliseconds ms 
investigate costs vary choice table show experimental results comparing average cost testing dops overlap 
table shows average time required perform updates dops approximating dops method described section 
dops tests taken directly experiments flights described section 
dop dop dop dop table average costs ms different choices average collision detection query times table shows timing data typical datasets pipes pipeline flying larger copy system pipes torus chapter 
implementation experimentation deformed torus flying presence boeing model flying random disjoint tetrahedral obstacles swept axis shaped polyhedron flying swept volume surrounded random tetrahedral obstacles 
figures show portion flights chapter pages 
pipes torus swept interior env 
size tri 
object size tri 

steps 
contacts dop dop dop dop rapid rapid dop table average cd time ms splatter splitting rule 
order simulate motion flying objects implemented form billiard paths flying object moved random path bouncing obstacles hits environment 
identical method path generation described chapter 
detailed look accurately handling collision response please refer moore wilhelms bouma large collection baraff 
datasets graciously provided university north carolina chapel hill 
chapter 
implementation experimentation timing results fifth dataset interior listed table 
images particular flight shown page figures 
industrial dataset provided boeing models small section interior airplane 
flying object case model hand path generated engineer boeing data glove example collision detection immersed virtual environment 
collision detection algorithms applied flight order detect contacts pairs triangles intersection flight 
seen table contacts flight average contacts step steps intention engineer generating data provide rigorous cd algorithms 
comparison recorded results obtained collision detection library rapid 
timings reported give average cpu consumption check collision exclusive rendering motion simulation 
tests report contacts collisions occurred 
naturally expect tests faster case detection collision 
chose report contacts done rapid system wanted direct comparisons 
solely times dop dop dop methods perform comparison rapid obb method running faster datasets exception dop method flight generated data 
expected dop method axis aligned bounding boxes perform methods chapter 
implementation experimentation obbs rapid implementation 
methods dop bounding volume bv trees appears best 
addition collision detection times milliseconds millisecond allows perform queries real time rates 
row table highlights improvement dop method rapid implementation obbs 
divided time required obbs time required dops see relative speed 
best case swept dop method times faster 
worst case times faster 
splitting rules split points results table hierarchies built fastest construction algorithms splatter splitting rule discussed section 
chose algorithm speed fast cd query times obtained 
dop method appears best provided tables highlight amount preprocessing time required construction methods longest side min sum min max splatter cd query times method generated 
table highlights amount time minutes takes preprocess build environment hierarchy dop method construction rules longest side min sum min max splatter fastest methods clearly longest side splatter algorithms cases split mean median 
chapter 
implementation experimentation construction method pipes torus swept interior longest side min sum min max splatter rapid table preprocessing time minutes dop method 
essentially equal datasets 
likewise min sum min max methods require amount methods typically order magnitude slower 
fastest method terms preprocessing time rapid requires time required splatter method 
longest preprocessing time witnessed minutes occurred min max method interior dataset dop method 
order avoid lengthy wait time code run standard dataset software option store environment hierarchy binary file 
dataset having input triangles binary file store dop hierarchy roughly megabytes size takes just seconds load 
conjunction table table highlights corresponding cd query times construction methods 
table clear min sum method typically best afford spend great deal additional time preprocessing environments best choice appears splatter method takes considerably chapter 
implementation experimentation construction method pipes torus swept interior longest side min sum min max splatter table average cd time ms dop method dividing mean 
time preprocess provides cd query times nearly 
addition construction methods mentioning discussed section option splitting mean versus median centroid coordinates selected axis 
preceding tables mean 
provide justification mean default included table shows average cd query time dop method splitting rules median mean 
construction method pipes torus swept interior longest side min sum min max splatter table average cd time ms dop method dividing median 
comparing tables see median results faster query times 
quite cases median method chapter 
implementation experimentation slower mean method pipes dataset median method slower entries 
preprocessing times required median method identical mean 
cases slightly faster slightly slower 
tree traversal algorithms recall section discussed current algorithm searching bv trees determine flying object comes contact environment 
highlighted alternative search algorithm average perform 
table report average collision detection times methods dop method 
refer current algorithm current alternative algorithm modified 
mentioned earlier alternative method typically slower 
pipes torus swept interior current modified table average cd time ms dop method current tree traversal algorithm modified algorithm 
comparisons splitting rule splatter method splitting point mean 
chapter 
implementation experimentation parallel close proximity tables report random flight paths generated exception interior flight tried design experiments methods perform order fair comparison 
particular rapid reported perform especially situations exists parallel close proximity models 
situation occurs points flying object come close points environment large number nodes hierarchies searched order resolve conflicts 
examples situation virtual prototyping tolerance analysis applications 
run experiment similar run order see methods dops competitive situation 
generated datasets consisting polygonal approximations concentric spheres outer sphere having radius inner sphere scaled copy outer sphere having radius gamma ff small positive values ff 
parallel close proximity situation points inner sphere close points outer sphere intersection inner outer surfaces 
objectives determine bounding volume overlap queries required process collision detection query inner surface intersect outer surface 
previously discussed default implementation uses threshold terminate construction flying hierarchies 
rapid uses threshold builds complete binary tree 
chapter 
implementation experimentation order fair comparison modified code particular experiment consistent rapid threshold flying hierarchy 
methods produce trees having identical number internal nodes leaf nodes 
structures hierarchies particular heights course different 
alpha dop dop dop dop rapid table numbers overlap queries dops faceted nested spheres different values alpha tables report results spheres triangles spheres triangles came surprise rapid implementation requires fewer bounding volume comparisons axis aligned bounding boxes dops 
fact nested spheres triangles obbs require order magnitude fewer queries consistent drawn similar experiment 
goal compare obb method dops runs fastest construction algorithms splatter splitting rule 
chapter 
implementation experimentation alpha dop dop dop dop rapid table numbers overlap queries dops faceted nested spheres different values alpha methods 
tables show datasets dop dop dop methods performed fewer bounding volume overlap queries largest value ff nested spheres relatively separated 
remaining values ff perform considerably fewer overlap queries spheres dataset having triangles 
perform fewer queries smaller dataset magnitude 
ff small happens nested spheres close dop methods start overtake obb method 
emphasize modifying methods experiment considerably 
nature obbs tend approximate single triangle box axis aligned normal vector triangle 
obb tend flattened dimensional box directions 
dops proficient approximating triangle dops directions predetermined 
chapter 
implementation experimentation surprising experiment force triangles inner sphere come close triangles outer sphere rapid implementation perform fewer bounding volume overlap tests 
having said interesting experiment get better feel bounding volumes perform 
behavior cd time flight compiled results primarily statistic collision detection time important applications study worst case collision detection time flight moving object 
putting upper bound worst case cd time especially important virtual reality applications needs perform time critical collision detection see section 
typical flight pipes flown larger system pipes show plot cd time varies position flight steps simulation 
see cd time increases substantially various positions flight correspond flying object comes close proximity environment 
particular example maximum cd query time roughly milliseconds 
chapter 
implementation experimentation time collision detection query time ms steps individual collision detection query times pipes dataset 
chapter 
implementation experimentation pipes torus pipes torus datasets 
chapter 
implementation experimentation swept swept datasets 
chapter 
implementation experimentation interior close hand moving interior dataset 
contact region highlighted red 
chapter improvements extensions descriptions data structure algorithm collision detection chapters pointed possible improvements 
sections shall discuss additional modifications tested 
changes lead significant improvements average collision detection cd query time part current implementation see chapter 
interesting right included benefits provide outweigh additional cost longer preprocessing additional memory associated 
motivation improvements exception discussed section speed average cd query time classified modifications underlying method improving design bv trees making better bv trees provided 
chapter 
improvements extensions involves constructing better tighter approximations environment flying object usually complicated preprocessing step 
consists new ideas clever ways improving current ideas 
prior presenting modifications discuss dramatic improvement construction bv trees 
particular construct trees amount preprocessing time required greatly reduced 
faster preprocessing disappointing statistics chapter obb implementation known rapid performing preprocessing step considerably faster methods 
methods perform collision detection queries faster average users may choose obb method due faster hierarchy construction 
spent time improving preprocessing step reorganizing code making better code available 
particular eliminating options shown inferior answering collision detection queries median split point node bv tree able simplify code considerably achieve dramatic speed ups 
addition cleaning done implemented basic operations macros achieve greater efficiency 
additional item may helped timings machine run chapter 
improvements extensions experiments upgraded megabytes mb main memory opposed mb originally ran experiments reported section 
comparison table included table current preprocessing times dop method 
case mean splitting point 
note units new table seconds opposed minutes 
speed ups quite dramatic 
interior dataset example previously required minutes preprocess matter seconds 
previously said large majority speed due reorganizing code simplifying things due greatly reduced number options cluttered original code 
improvements great deserving criticism implementing preprocessing step efficiently place 
instances macros inefficiently original code fairly slow larger datasets 
addition completely fair comparisons rapid implementation preprocessing times reported tables release version rapid system 
times reported chapter describes current implementation quickcd compares latest versions collision detection systems including rapid 
chapter 
improvements extensions construction method pipes torus swept interior longest side splatter rapid table preprocessing time seconds dop method 
improving design bv trees choice dops chapter explained rationale choosing dops bounding volumes bv trees 
section discussed specific dops investigating dop dop dop dop 
time discussed dops 
tried additional bounding volumes values greater slightly modified versions existing ones 
particular tried removing planes define axis aligned bounding box dop dop dop 
produced dops dops dops 
felt dops quite natural experiment order see remaining planes shave corners edges bounding box approximate primitives increase query time significantly 
exchange loss accuracy approximations consequently increase number bounding volume overlap tests potentially save comparisons interval overlap tests overlap test 
new dops maintain nice properties original ones chapter 
improvements extensions particular easily construct multiplications see section 
results new dops shall reported section 
splitting rules building hierarchies recall section node bv tree corresponds subset original set input primitives internal node tree need divide primitives triangles subsets minimize function sizes children 
splitting rules plane orthogonal coordinate axes chosen divide triangles 
dividing coordinate axes natural bounding volumes axis aligned bounding boxes aabbs boxes thought bounding extents slabs directions 
highlighted section dops considered simple generalization aabbs thought extents directions define dops 
proposed earlier natural consider planes orthogonal directions splitting triangles subsets 
doing hope compute bv trees tighter approximations set primitives consequently perform cd queries quickly 
new choices dops discussed previous section axes part directions implemented split directions 
dop dop dop split coordinate axes chapter 
improvements extensions split directions respectively 
course generalization require time preprocessing 
table re run datasets new set dop methods 
methods include dops dops dops dops splitting directions dops splitting directions dops splitting directions dops splitting directions dops dops splitting directions dops splitting directions 
parentheses column table number splitting directions method 
number original splitting method axis newer methods 
pipes torus swept interior avg 
rank dop dop dop dop dop dop dop dop dop dop table average cd query times ms dop methods 
method parentheses number splitting directions constructing bv trees 
methods splatter splitting rule mean splitting point 
compare original dop dop dop methods versus chapter 
improvements extensions new modified versions splitting planes see added flexibility pays occasionally 
particular new method faster original just runs 
method faster improvement 
speed ups consist improvement percentage points dop torus dop dop torus dop dop runs respectively 
mentioned earlier modification requires additional preprocessing time 
turns occasional savings get new idea comes expense increasing preprocessing time minimum maximum average 
generalizing splitting rule consider splitting directions hoping compute bv trees better tighter previous ones 
general case 
recall table tabulated total volume occupied bv trees dop method splitting rules splitting points 
table highlights total volume occupied bv trees generated dop method splitting rule splatter original directions directions described 
see datasets new method produced hierarchies occupied greater amount total volume original methods 
terribly surprised new methods resulted slower cd query times due poorer approximations resulting 
average collision detection query times average rank method provided table 
dataset fastest chapter 
improvements extensions pipes torus swept interior dop dop table total volume occupied bv trees constructed dop method 
method parentheses number splitting directions constructing bv trees 
methods splatter splitting rule mean splitting point 
method ranked slowest ranked 
ties runs simply ranked methods order finished worrying methods close 
summing rankings datasets determined average rank method included final column table 
dop method continues best method original approach coordinate axes splitting nodes fastest average 
dop methods followed dop methods 
dop dop methods line dop dop pulled rear 
average comparing versus splitting directions direction methods faster 
concluded general option worthwhile due significant increase preprocessing time provided occasional best improvement query times 
addition find new dops dop dop dop previous section great interest performing cd queries 
results shown new bounding volumes performed poorly managing outperform axis aligned chapter 
improvements extensions bounding box dop 
dop appears worst possible choice dop finished nearly runs cases huge margin 
poor performance dop method easily explained uses bounding volumes essentially worst possible respect objects nearly axis aligned pipes interior datasets 
points sensitivity orientation model small 
improved selection threshold section discussed importance threshold terminate construction flying bv trees 
threshold determine node distinguished leaf bv tree 
number primitives triangles associated node falls level consider node leaf tree 
threshold chosen worked average large variety datasets 
choice fairly early design data structures algorithms 
revisit choice hopes increasing average cd query time large percentage datasets 
datasets chapter varied threshold constructing bv trees flying objects 
values include multiples including 
results tables 
point entries tables empty reasons 
runs unnecessary due size flying objects 
example swept dataset flying object triangles chapter 
improvements extensions values flying bv tree constructed query time result 
entries tables absent simply grew impatient 
particular pipes dataset value increased value decreased average cd query time increased dramatically 
ended terminating small number runs typically pipes dataset 
point threshold decreased amount memory required increases considerably 
consideration pipes dataset far largest flying object 
lastly entries interior dataset empty discovered values minimum query times achieved 
increased threshold times continued increase bother running dataset values 
reminder number triangles flying objects datasets shown table 
dataset pipes torus swept interior object size tri 
table number triangles flying objects datasets 
tables determine particular dataset input models flight path value threshold provide fastest cd query times 
unfortunately instances luxury performing tests determine best values parameters 
instance situation chapter 
improvements extensions threshold pipes torus swept interior table average cd time ms dop method various threshold values 
chapter 
improvements extensions threshold pipes torus swept interior table average cd time ms dop method various threshold values 
chapter 
improvements extensions threshold pipes torus swept interior table average cd time ms dop method various threshold values 
chapter 
improvements extensions threshold pipes torus swept interior table average cd time ms dop method various threshold values 
chapter 
improvements extensions demonstration set input primitives 
environment flying object positions flying object going change particular demo run spending lot time initially adjust parameters optimal performance may reasonable 
typically user want move flying object environment change objects input 
addition time required perform large batch experiments usually available 
need threshold value predetermined available information run time number primitives input 
consider query times tables notice datasets smaller flying objects swept interior see smaller threshold best choice regardless value datasets larger flying objects threshold quite bit larger 
unfortunately clear choice value larger datasets 
part problem flying objects larger necessarily larger deeper flying hierarchies consequently perform bounding volume overlap tests update nodes flying bv tree 
pointed section cost operations directly related choice cost perform overlap test update node requires asymptotically time 
see effect choice clearly consider average query times torus dataset tables 
dop method ideal threshold value probably fall range 
chapter 
improvements extensions dop method range increases 
value increases best choice increases respectively 
ranges determined fastest cd query time value determining range values query times percent fastest cd time 
ranges see larger values thresholds perform best larger 
happening bv tree built dop method constructed deeply say dop method operations performing expensive dop method 
pays terminate construction earlier perform primitive primitive tests 
answer question value considering simple natural idea threshold determined complexity size flying object 
flying objects relatively small say triangles regardless value objects larger triangles vary value tables conclude average value dop dop dop dop methods respectively 
thresholds certainly provide best query times cases average pretty 
addition emphasize datasets produced 
datasets provided group researchers works collision detection problems produced independent 
datasets come different sources threshold values chapter 
improvements extensions fairly average 
pipes torus swept interior dop dop dop dop table percentage improvement dop methods newer criterion selecting threshold table highlights percentage gained dop methods utilize newer values percentage change compared original threshold value reported tables 
example table original threshold value achieved average cd query times milliseconds datasets 
new approach get milliseconds 
potential weakness section highlights potential weakness approach 
possible value may datasets poorly 
people may worry having determine threshold values best particular application 
understandable concern overly troubled due results tables 
table highlights bounding volumes value chapter 
improvements extensions pipes torus swept interior dop dop dop dop table value produced fastest average collision detection times tables 
produced fastest average cd query times standard datasets 
ideally known values choose run previously mentioned usually case 
hope value chosen close ideal value reported table produces query times close generated ideal value 
closer examination tables see great deal flexibility making choice believed 
pipes torus swept interior dop dop dop dop table range values percent best cd query time 
fastest query times provided values table generated ranges produced query times chapter 
improvements extensions percent best query time 
ranges reported table 
see table fact great deal flexibility choosing value instance note dop method threshold value torus dataset produces query times percent fastest query time 
choice just large pipes datasets range respectively 
similar results seen wide ranges threshold values methods large datasets 
surprising range threshold values large smaller flying objects see reasonable range values chosen value fall 
oscillating bv tree constructing bv trees need split node hierarchy children 
described section choices need performing split ffl coordinate axes split 
ffl point axis split 
described detail methods making choices concluded worked best seeing performed best wide variety datasets 
having concluded mean centroid value splitting point splatter splitting rule determine axis split ended investigation chapter 
improvements extensions constructing effective hierarchies 
worry making bad decision splitting node children effect quality rest tree 
wondered default methods worked poorly better split yielding tighter fitting bounding volumes children done 
knew average methods worked little preprocessing time methods improved 
fear making poor decision particular split lead refer oscillating bv tree 
explain works assume splitting node bv tree 
goal split set primitives triangles associated subsets determine children idea temporarily split node normally done children 
children split grandchildren grandchildren split great grandchildren node 
point splits determined parameter splitting process regroup merge resulting descendants actual children node clarify exactly mean assume moment stopped splitting process grandchildren nodes created original splitting methods 
shall refer grandchildren number 
associated descendants set primitives dop approximate primitives 
union primitives associated grandchildren course chapter 
improvements extensions exactly equal set primitives associated nodes want merge wind exactly sets primitives determine actual children node items pair exactly ways 






determine pairings best perform apply splitting rules longest side splatter min sum min max objective function 
general min sum rule works best table 
rationale approach going levels hierarchy regrouping descendants actual children node essentially erase poor decision come split original node 
interesting note cases regrouping resulted exactly split originally current splitting techniques 
chapter 
improvements extensions general split node stopped descendants gamma gamma possible pairings resulting sets primitive order sets irrelevant 
clarify situation stopped splitting grandchildren generated consider different item listed 
preliminary results results encouraging new method helps produce better quality reduced total volume hierarchies faster cd query times 
fact method help regards 
increased query times opposed original splitting methods 
encouraging method original splitting techniques working able produce hierarchies generate faster query times complicated preprocessing step 
point time single instance generated faster query times 
honest result somewhat surprising 
great deal preprocessing time times original methods expect hierarchies better resulting query times 
began looking case soon discovered splitting rules complicated 
happening occasionally best merging descendants node isolate single descendant rest get unbalanced split terms number primitives chapter 
improvements extensions resulting children 
type split tends lead fairly deep hierarchies increase number bounding volume overlap tests increase average cd query times 
having performed experiments feel better quality hierarchies current construction methods produce 
having said feel complicated splitting rule take account relevant factors number primitives sizes resulting children interesting area research 
working problem data skinny triangles 
dop certainly yields better approximation long skinny objects sphere aabb 
long skinny triangles tend cause troubles necessarily result long skinny dops 
cause significant overlaps dops corresponding sets neighboring skinny triangles 
unfortunately skinny triangles arise practice polyhedral approximations pipes particular pipes dataset known lots skinny triangles 
situation gets particularly troublesome splitting rule split mean centroid fails separate small triangles skinny triangles cause spurious intersection tests avoided skinny triangles separated small triangles 
attempt address problem building individual hierarchies account size triangles 
skinny triangles want take account predominant orientation triangles 
potentially cost drastically increased bookkeeping chapter 
improvements extensions diverse trees approach provide better bounding volumes 
decided take ambitious pragmatic approach 
statistics recorded algorithms convinced long skinny triangles issue nc machining applications see section mechanical parts tend contain small number skinny triangles 
natural get rid triangles simply subdividing appropriately long sides 
allowing number triangles increase say able longest triangles achieve better bv trees 
instance pipes example replacing longest triangles adding total triangles provided speed slightly average cd check 
improving usage bv trees ordered overlap tests previously mentioned frequently called routine collision detection query test dops overlap 
overlap test cost denoted equation consists testing intervals dop versus corresponding intervals dop 
exists direction intervals extents overlap know dops overlap conservatively conclude see section 
test simple generalization testing axis aligned bounding boxes overlap 
chapter 
improvements extensions section discussed order test intervals overlap effect efficiency routine 
approach point order intervals intervals largely different directions tested 
investigate alternative ordering scheme may decrease average time spent overlap routine 
idea presently investigating involves ordering intervals bounding slabs called 
rationale slab tend prune away dops thicker ones overlap routine terminated earlier 
question immediately arises order intervals respect node flying object hierarchy respect node environment hierarchy 
flying object rotates dops flying bv tree rotated 
fixed order intervals widths slabs constantly changing nodes 
recompute ordering node flying bv tree prior traversing environment hierarchy 
environment static precompute ordering part preprocessing ordering overlap tests 
ordering bytes need stored node environment hierarchy additional bytes required environment triangle 
implemented option tested effect datasets discussed chapter 
results dop method shown table 
rows table recorded number chapter 
improvements extensions pipes torus swept interior overlap calls num 
overlaps percentage original overlap total comparisons comp 
misses avg 
comp ordered overlap total comparisons comp 
misses avg 
comp percent reduction total comparisons avg 
comp table number comparisons required testing dops overlap 
ordering intervals environment dop able reduce average number comparisons needed 
chapter 
improvements extensions pairs bounding volumes tested overlap number tests ended overlap result corresponding percentage tests overlaps 
interior dataset resulted largest percent overlap results swept dataset fewest 
reason point numbers previously discussed section dops overlap extra ordering intervals wasted order irrelevant intervals overlap 
rows table show original overlap routine new ordered overlap routine total number comparisons performed overlap tests number comparisons tests result disjoint dops misses average number comparisons overlap call results term comparison mean inequality test greater comparison floating point numbers 
interval test consists comparisons overlap test dops result comparisons 
final rows table highlight effect modified overlap routine 
see total number comparisons reduced minimum maximum 
average number comparisons reduced average 
savings quite reasonable suggest ordering scheme included current implementation 
special ordering intervals node environment hierarchy need perform additional indexing array determine chapter 
improvements extensions order 
weigh savings number interval comparisons versus additional overhead time space 
ignoring added space component calculated average cd query time modified routine query times typically slower percentage points 
disappointing current implementation new routine pay maintain hope time effort new clever ideas idea may worth 
truncating overlap test additional modification looked truncating overlap test fixed number intervals tests 
assumes course sophisticated ordering scheme just described 
rationale approach dops overlap intervals dops overlap 
extra determine order intervals testing gaining 
intervals tested hoping large majority disjoint dops discovered just interval tests 
fact consider average number comparisons needed testing disjoint dops see table typically need comparisons equivalent interval overlap test takes comparisons 
suggest technique may fairly 
making change reducing number interval overlap tests pairs bounding volumes tested overlap chapter 
improvements extensions overlap 
exchange reduction going perform bounding volume overlap tests nodes originally disjoint th interval test reported overlapping terminate routine discovered dops disjoint 
unfortunately modification similar effect previous 
average query time increased datasets 
number additional bounding volume overlap tests outweighed savings received overlapping nodes 
effort new ideas approach 
knew large number bounding volume overlap tests resulted overlaps technique similar may reduce average cd query time 
front tracking temporal coherence bv trees approximate flying object environment traverse hierarchies determine flying object current position collides models environment 
algorithm traversing hierarchies originally discussed section traverse environment hierarchy root flying bv tree 
leaf reached take geometric primitive associated leaf traverse flying bv tree 
leaf reached traversal need test actual geometric primitives triangles intersect 
originally applied tree traversal algorithm naively position flying object checked bv trees see collisions 
approach correctly determine contacts chapter 
improvements extensions wasteful began scratch step traversing environment hierarchy find nodes disjoint root flying bv tree previous position disjoint root current position 
flying object expected change position drastically position 
particular tree traversal determines root flying bv tree overlaps leaf environment instant time quite root flying bv tree overlap leaf leaf representing geometric primitive close short period time instant 
similarly node environment bv tree overlap root node flying bv tree fair chance overlap instants time 
order exploit temporal coherence avoiding scanning root nodes environment bv tree repeatedly maintain front keeping track root node flying environment bv tree assume root flying bv tree gets pushed traverses environment bv tree 
root may get pushed leaves parts environment bv tree may higher nodes parts environment bv tree 
front maintains list ordered left right nodes environment bv tree disjointness determined list leaves overlapped cd query started nodes front root environment bv tree 
chapter 
improvements extensions provides illustration front 
particular example looking tree represents environment bv tree 
leaves tree contains triangle 
colored nodes represent front current position flying object 
see root flying object overlaps leaves environment overlap left child root environment bv tree 
node disjointness witness needing explore branch environment bv tree 
time step time step time step time step time step time step front tracking flying object moves environment maintain front colored nodes environment bv tree 
colored internal nodes known disjoint root flying bv tree 
course need update front accordingly flying object keeps chapter 
improvements extensions moving 
node previously disjoint overlaps drop front replacing node front children recursively applying scheme children 
example left child root environment bv tree 
figures node intersect root flying bv tree element front 
time step nodes overlap replace node front new nodes determine disjointness 
particular case node replaced descendants leaves 
addition dropping front provide mechanism raise front closely monitors overlap relationship environment bv tree 
particular node previously overlapped turns disjoint raise front successor front sibling overlap current implementation pushing front done recursively front gets raised level time 
operation seen flying object moves right left environment 
time step leaves right hierarchy overlapped root flying bv tree 
time step find nodes longer overlap root replace front nodes parent 
flying object continues move see examples front propagated upwards manner 
raising front requires additional overlap tests exactly clear anyway raising front level yield speed 
chapter 
improvements extensions benefit front reducing number bounding volume overlap tests required testing contact hierarchies flying object environment 
results implementation quite encouraging 
comparing total number bounding volume overlap tests naive search algorithm section versus current search algorithm exploits coherence number overlap tests experiments reported table reduced minimum average maximum 
reduction number overlap tests performed come free 
overhead maintaining front included query times 
instances number overlap tests reduced average query times roughly search algorithms 
cases front percentage points slower 
majority experiments front pay lowered average cd query time 
reduction query time order 
surprise tremendously profiling code shown percentage time spent performing overlap tests roughly total query time 
reducing average indicated achieve speed roughly 
addition reducing average cd query time hopeful maintaining front reduce maximum query time required cd queries 
pointed earlier section section bounding worst case query time great importance chapter 
improvements extensions applications require time critical collision detection 
determined maximum query times standard datasets front 
please refer section results 
front implemented array cells contains pointer corresponding node environment bv tree pointers preceding succeeding cells front 
maintain front requires bytes cell array 
worst case size front equal number leaves environment bv tree case equals number triangles environment 
situation occurred concentric sphere experiments discussed section 
practice front consists nodes 
experiments reported section chapter maximum size front exceeded total number environment triangles 
chapter quickcd method efficient collision detection polygonal models bounding volume hierarchy bv tree bounding volumes dops discrete orientation polytopes 
chapter introduced bounding volumes number design choices constructing bv trees 
collision detection algorithm chapter highlighted important issues performing efficient queries 
vast collection experimental results highlighted success method 
numerous options described algorithm data structure tried address practicality 
chapter continued testing options new ones 
course investigation collision detection problem implementation method evolved quickcd library collision detection routines 
point time shall summarize current state chapter 
quickcd implementation 
current implementation status bounding volumes course dops 
values included library dop proven efficient default method 
directions define bounding volumes defined section 
investigation additional dops section unsuccessful contained current version code 
completeness included additional dops latest round experiments section provide justification 
default method constructing bv trees splatter splitting rule rules longest side min sum min max available section 
currently splitting rule split internal node hierarchy axis generalization section directions appear worthwhile time 
consequently option included current release quickcd 
median split point shown produce quality hierarchies option unavailable current implementation 
mean split point included 
hierarchies binary trees built top fashion sections 
bv trees constructed utilize algorithm section process collision detection queries 
accelerate tree traversal algorithm included front implementation chapter 
quickcd section takes advantage temporal coherence flying object moves 
quickcd provides user option front passing parameter collision detection routine 
threshold determines node leaf flying bv tree defined section 
relatively small flying objects fewer triangles threshold regardless value larger objects value respectively values 
current attempts reduce average time necessary check bounding volumes overlap unsuccessful sections 
continuing approach described section 
section described techniques updating dops flying object rotates 
originally chose convex hull hillclimbing algorithm method update root node flying bv tree 
due speed ups alternative method tumbling nodes recomputing approximate dops decided method root node 
hill climbing technique expensive operation tumbling node recomputing approximate dop tightest possible dop set primitives trying approximate node approximation 
hill climbing algorithm faster due fewer overlap tests required traversing environment bv tree 
switching approximate method slowing cd query 
addition sacrificing speed able free user chapter 
quickcd having precompute convex hull flying object wish 
code cleaned considerably removing option feel loss speed small price pay cleaner code 
experiments describe series experiments performed compare collision detection library leading collision detection packages 
addition rapid implementation utilized obbs compare quickcd cd library publicly available 
new library solid builds bounding volume hierarchies approximate input objects uses bounding boxes aabbs choice bounding volume 
software hardware 
latest tests compare quickcd leading publicly available codes rapid version solid version 
code compiled gnu compiler optimization option turned 
order ensure validity portability different hardware experiments conducted multiple platforms pentium pro pc mhz mb running red hat linux sgi indigo mhz mb running irix sun ultra mhz mb running solaris 
unfortunately solid compiled crashed stl related errors sgi 
chapter 
quickcd gathering data 
standard datasets see section series experiments 
flight executed times runs solid 
mean cpu times ms collision detection check reported careful timing routine time done systems 
times include motion simulation exclude rendering 
compatibility rapid solid ran quickcd report mode detecting intersecting pairs location truncating test primitive pair intersect 
tried conduct fair meaningful comparisons systems 
checked carefully codes reporting essentially set contacts dataset flight 
remind reader comparing collision detection timings sections chapters meaningless due changes code compilers hardware occur 
relevance timings lies relative speed ups collision detection systems particular experiment experiments 
fact timings reported section sgi considerably slower previously reported 
software changed slightly previous chapters vast majority change timings due different version compiler 
see timings quickcd rapid slowed considerably due new compiler relative timings greatest importance 
chapter 
quickcd experimental results preprocessing time 
construction algorithms bv trees designed optimize fast query processing effort expended preprocessing 
standard datasets preprocessing times seconds sgi sun default choice dops 
comparing rapid dop method slower sun faster sgi rapid 
comparing solid uses simpler hierarchies aabbs dop method slower sun solid execute correctly sgi 
tested different choices dops 
typical example pipes dataset method sun took seconds respectively 
rapid took sec solid took sec 
dop time slightly faster solid dops aabbs just solid uses 
sgi method compares favorably rapid sec rapid vs sec 
tables report preprocessing times datasets sun ultra sgi indigo cd query times 
datasets ran quickcd various choices dops results shown tables 
choice dop optimal case best average extensive experience datasets convinced dops default quickcd 
note dops dops dops chapter 
quickcd pipes torus swept interior dop dop dop dop dop dop dop rapid solid table preprocessing times seconds sun ultra pipes torus swept interior dop dop dop dop dop dop dop rapid table preprocessing times seconds sgi indigo 
poor choices bounding volume 
dop remains far worst possible choice 
please refer back section discussion poor performance dops dop particular 
direct comparisons rapid solid appear table 
see exception pipes rapid faster solid 
solid uses aabbs perform pipes pipes dataset axis aligned 
see quickcd essentially ties rapid chapter 
quickcd pipes torus swept interior dop dop dop dop dop dop dop table average cd query times ms sun ultra pipes torus swept interior dop dop dop dop dop dop dop table average cd query times ms sgi indigo 
torus times faster datasets sun 
note torus interior dops lead slightly better query times quickcd platforms 
quickcd performs bit better sgi sun making speed differences visible 
performed experiments see method scales range similar datasets complexity number obstacle triangles increases 
chose dataset control scene complexity varying number randomly generated tetrahedra 
results varying number tetrahedra number triangles 
see rapid takes chapter 
quickcd cd package pipes torus swept interior ultra quickcd dop rapid solid sgi indigo quickcd dop rapid pc pentium pro quickcd dop rapid solid table average cd query times ms packages 
factor longer 
effectiveness front tracking 
experiments reported table result front tracking reduction number bv bv tests average decrease 
accounting small overhead maintaining front net speed ups query times sun average 
relatively modest improvement easily understood profiling code shows roughly cd query time spent bv bv tests decrease bv bv tests results speed 
maximum improvement came swept dataset obstacles tightly clustered near trajectory flying object exploiting coherence effective 
discussed section goal front reduce maximum query times flights 
experiments run sun ultra determined datasets maximum query time chapter 
quickcd number quickcd rapid cd query time vs number tetrahedra quickcd rapid 
sgi indigo particular step front 
front maximum query time reduced flights ranging average 
profiling 
dop method broke cd query time component times described section performing bounding volume overlap tests theta updates tumbling nodes flying hierarchy theta primitive comparisons triangle triangle tests theta 
results shown 
note interior time spent triangle triangle tests due large number actual intersections 
chapter 
quickcd pipes spikes swept interior bounding volume overlap test updating tumbling nodes triangle triangle intersection breakdown cd query time 
newest results section chapter date experiments collision detection library quickcd 
comparing numbers table table see slight decrease cd query times datasets 
improvements resulted improving implementation previous ideas opposed inserting new ideas 
swept dataset notice larger decrease due bug code 
bug effected swept dataset result code running incorrectly running efficiently chapter 
quickcd cd package pipes torus swept interior ultra quickcd dop rapid solid sgi indigo quickcd dop rapid table average cd query times ms packages 
running 
times rapid solid libraries exactly table new releases libraries 
mentioned times see sections dissertation maximum cd query times important factor consider 
section tabulated cd query times step pipes flight dop method rapid method best competition 
looking figures initially appear difference timings tend spike moments flight flying object comes contact close proximity environment 
look carefully magnitude cd query times axis see dop method takes considerably time rapid 
maximum time method takes particular flight milliseconds rapid system took milliseconds cd query 
fact rapid system takes time step flight dop method 
chapter 
quickcd get better idea systems compare overlayed sections figures 
clarity included steps flight overlay remaining sections graphs see relationship 
solid dotted line represents dop rapid timings 
see clearly zoomed image difference timings systems particular flight 
chapter 
quickcd time collision detection query dop time ms steps individual collision detection query times pipes dataset dops 
maximum query time roughly milliseconds 
time collision detection query rapid time ms steps individual collision detection query times pipes dataset rapid 
maximum query time roughly milliseconds 
chapter 
quickcd time collision detection query dop rapid time ms steps overlayed highlight difference individual collision detection query times pipes dataset dops rapid 
clarity steps shown 
chapter application bv trees successfully collision detection algorithms data structures application nc numerically controlled verification natural application techniques common problems nc milling verify tool collide material left milling desired shape 
section originally appeared manuscript written martin held joseph mitchell 
implementation martin held responsible coding routines test primitives triangles spheres cylinders tori contact 
generated terrain datasets tool paths experiments 
note chapter performed prior incorporating improvements extensions chapter current version cd software 
software produce results chapter 
application bv trees closely resembles software chapter reported original collision detection results 
improvement included version software usage front tracking technique described section 
addition quite natural nc verification tool paths tool moving far discrete location 
advantage temporal coherence able speed checking queries 
nc verification addition fundamental advances collision detection give applications foundational method general purpose cd algorithm problem nc verification 
geometric models input stock goal shape cutting tool problem determining tool path results removing appropriate material input stock avoiding cutting paramount importance verifying tool path prior production machining 
tool path generated manually automatically semi automatically essential check path deficiencies prior making potentially costly wasteful error 
system developed solve problem underlying technology provided quickcd 
currently supports axis machining 
methodology supports axis axis machining integrating existing system remains 
chapter 
application bv trees related theory nc verification solved problem geometry part machined derived geometry cutter tool tool path sequence regularized boolean operations standard csg modelers 
approach practical tool path part modest complexity contain thousands path segments contributes swept volume element subtracted 
ray casting techniques proposed order speed avoid csg constructive solid geometry evaluation process see instance wang wang menon ray representation 
approaches nc verification discretizing part surface computer graphics techniques buffer variants extensions thereof modeling material removal cf 

early systems emphasis placed visualizing material removal specified direction view 
image space techniques kept playing important role nc verification 
see instance image space sweeping hui 
verification posts surface part machined simulating material removal akin lawn cutting blade tool clips vectors simulates material removal sequence line clipping processes 
extended idea modeling part family discrete vectors information tool path generation 
discretize part surface chapter 
application bv trees respect specified chordal tolerance triangular mesh approximates part surface 
bounds amount cutting cutting obtained computing distances approximations swept volume tool points part surface 
see similar approach oliver goodman 
discrete representation map employed yang lee 
space subdivisions performing nc verification popular researchers variants including quadtrees octrees buffers 
unifying idea decompose part simpler cells reducing computational complexity boolean operations 
nc verification experiments demonstrate applicability cd system real world problems designed test tool paths axis machining 
developed underlying structure quickcd enhancements added 
addition able move polygonal models environments able handle actual spheres cylinders part flying object 
tools nc verification ball shaped easily polyhedral approximation tool moving object doing introduce approximation factor problem 
actual sphere cylinder avoid 
similarly actual cylinder model tool arm volume swept ball shaped chapter 
application bv trees tool 
allows avoid problem checking tool versus environment case goal shape fixed number discrete locations 
checking swept volume tool find instances occur 
enhancement ability take advantage translation motion 
incorporated axis machining nc verification system tools rotate translate location 
designing collision detection methods flexible handle option take advantage situations user knows translation assumption appropriate 
datasets 
tests data provided machines resemble bottles part part part part part 
addition generated synthetic terrain sampled real world elevation data called degree dem data converting theta elevation arrays theta elevation arrays 
elevation arrays converted triangulated surfaces means straightforward triangulation data points 
terrain contains triangles 
dem data obtained mean anonymous ftp ftp site cr usgs gov 
tool paths 
industrial able real world paths nc tool paths computed means ez mill cnc package developed distributed machines 
tool paths chapter 
application bv trees computed axis machining ball ended tool 
tool paths distorted slightly order ensure encounter collisions 
synthetic terrain created tool paths 
pure zigzag paths created locally offsetting dimensional polygons 
polygons correspond rows elevation array polygons space 
selected tenth row polygon computed locally correct offset 
tip ball ended tool stays contact terrain collisions occur tool moving polygon forms ridge terrain 
collisions occur tool moving valley terrain 
matter fact runs slowed quite cases reported 
addition checking discrete positions ball ended tool sphere ran second set experiments modeled true swept volumes means cylinders 
nc paths generated ball shaped tools tested tools different shapes paths 
addition sphere tested right cylinder polyhedral approximation sphere polyhedral approximation cylinder polyhedral approximations tools 
tool flat ended cylindrical tool rounded corners tool nearly conical rounded tip 
tools scaled approximately size original sphere tool path computation moved tips touch point tip sphere 
swept volumes additional tools differ chapter 
application bv trees significantly swept volume sphere 
conical tool significantly incidents reported 
results runs reported section conducted pc running linux pentium pro processor megabytes main memory 
table shows timings terrain 
expected cd check sphere far fastest query 
considering sphere plus swept volume results strongly depend number contacts encountered 
denver terrains checking entire swept volume sphere considerably faster checking polyhedral tools discrete tool positions 
simply endpoints tool path segment tool position checked 
case contacts overhead dealing general cylinder dominant due increased costs overlap tests cylinder dop average time consumed check goes increased 
observation confirmed tests cylindrical tool sphere 
corresponding entries omitted table due lack space 
polyhedral tools compare timings timings obtained rapid 
chapter current version rapid time experiments performed 
apparent obbs particularly wasteful case buffalo includes portions lake erie course level plane 
rapid better rugged terrain chapter 
application bv trees faster factor 
reason selected experiment 
polyhedral tools approximated swept volumes brute force way sampling tool path tool path points sample ffl units apart predecessor successor ffl 
parts size theta units true sphere calculating paths radius units 
additional results omitted confirmed statistics table 
timings industrial reported table give evidence hypothesis elaborate dops hardly pays queries spheres cylinders lot intersections encountered 
exception hypothesis part exhibited speed increasing spite small number intersections 
part complex dataset exceptional reason environment rapid won scoring 
examined dataset test runs offer explanation rapid performed particularly part comparison 
particular part striking similarity part part rapid get close winning 
success system experiments exciting feel greatest achievement incorporated release version ez mill cnc package sold machines 
thing perform pseudo realistic experiments determine method works best 
entirely matter implementation incorporated chapter 
application bv trees commercial product successfully customers day 
especially proud fact 
tested system versus software packages specifically designed nc milling verification rapid general collision detection system system considered valuable industry leading companies 
chapter 
application bv trees buffalo denver denver eagle seattle env 
size tri 
steps ball shaped tool contacts dop dop dop dop ball shaped tool cylindrical swept volumes contacts dop dop dop dop polyhedral ball shaped tool tri 
contacts dop dop dop dop rapid rapid dop polyhedral tool rounded corners tri 
contacts dop dop dop dop rapid rapid dop polyhedral conical tool rounded tip tri contacts dop dop dop dop rapid rapid dop table statistics nc verification terrain data 
chapter 
application bv trees part part part part part env 
size tri 
steps ball shaped tool contacts dop dop dop dop ball shaped tool cylindrical swept volumes contacts dop dop dop dop polyhedral ball shaped tool tri 
contacts dop dop dop dop rapid rapid dop polyhedral tool rounded corners tri 
contacts dop dop dop dop rapid rapid dop polyhedral conical tool rounded tip tri contacts dop dop dop dop rapid rapid dop table statistics nc verification industrial mold data 
chapter began investigation collision detection algorithms utilizing standard box data structures 
initial motivation validate practicality method building tetrahedral mesh environment tracking motion moving objects mesh 
somewhat surprise naive data structures tree quite efficient usage memory ability answer collision detection queries accurately rapidly 
building preliminary examination proposed method efficient collision detection polygonal models bounding volume hierarchy bv tree bounding volumes dops discrete orientation polytopes 
dops form natural generalization axis aligned bounding boxes providing flexibility choice parameter studied problem updating approximate bounding dop moving rotating objects studied application bv trees collision detection problem 
chapter 
methods implemented tested variety datasets various choices design parameters 
results show methods compare favorably leading system rapid acm siggraph hierarchy oriented bounding boxes 
system compares publicly available collision detection system solid utilized axis aligned bounding boxes approximations 
algorithms robust relatively simple implement applicable general sets polygonal models 
experiments shown algorithms perform interactive rates real simulated data consisting hundreds thousands polygons 
demonstrate applicability real world problems extended quickcd system produce system efficiently nc verification 
experimental results aside incorporation latest commercial release ez mill ample evidence fact 
extensions dissertation mentioned possible extensions including alternative methods constructing bv trees values larger dops section alternative splitting rules section bottom method construct bv trees section bv trees degree greater section 
chapter 
suggested possible investigations lead faster collision detection queries including finding optimal orientation initial flying hierarchy section avoiding hard coded threshold control depth hierarchies section specially designed ordering performing interval overlap queries section 
addition design alternatives investigate extensions bv tree methods including multiple flying objects 
quickcd easily support multiple flying objects naive manner checking pair hierarchies collision checking flying object environment done moving object 
efficient method sweep prune technique collide :10.1.1.139.265
natural generalize method somewhat strategy discretizing orientations project flying objects lines corresponding dops maintain projection intervals time 
note projection intervals come free trivially derived dop root flying hierarchy 
obviously need check flying objects pairwise collision overlapping intervals projections 
chapter 
dynamic environments 
insertions deletions objects pose challenge method relies preprocessing order achieve highspeed queries 
quickcd handle insertions new obstacle model way perform collision queries traversing environment tree identify placement new obstacle primitives tree 
deletions done 
analogous insertion deletion data tree 
course repeated insertions deletions may cause bv tree highly unbalanced 
need re balancing local re optimizations 
section provided brief dynamic data structures situations 
additional applications data structures perform approximate nearest neighbor queries points arbitrary dimensions 
building bv tree points able quickly answer types queries metrics 
thorough investigation application warranted 
bibliography agarwal aronov suri 
line stabbing bounds dimensions 
manuscript dec 
agarwal matousek 
ray shooting parametric search 
proc 
th annu 
acm sympos 
theory comput pp 

agarwal sharir 
ray shooting amidst convex polytopes dimensions 
proc 
th acm siam sympos 
discrete algorithms pp 

anderson 
detecting eliminating collisions nc machining 
comput 
aided design july 
arvo kirk 
survey ray tracing acceleration techniques 
glassner editor ray tracing pp 

academic press 
isbn rd printing 
atherton earl fred 
graphical simulation system dynamic axis nc verification 
show sme pp 
detroit mi usa nov 
society manufacturing engineers sme 
bibliography avila schroeder 
interactive visualization aircraft power generation engines 
proc 
ieee visualization pp 
phoenix az usa oct 

pagel 

optimizing spatial data structures static data proc 
geographic information systems vol 
lecture notes comput 
sci pp 

ballard 
strip trees hierarchical representation curves 
commun 
acm 
baraff 
curved surfaces coherence non penetrating rigid body simulation 
comput 
graphics siggraph proc pp 
dallas tx usa aug 
baraff 
fast contact force computation rigid bodies 
comput 
graphics siggraph proc pp 
orlando fl usa jul 
baraff 
interactive simulation solid rigid bodies 
ieee comput 
graph 
appl may 
barequet chazelle guibas mitchell tal 
boxtree hierarchical representation surfaces 
comput 
graph 
forum 
proc 
eurographics 
beckmann 
kriegel schneider seeger 
tree efficient robust access method points rectangles 
bibliography proc 
acm sigmod int 
conf 
management data atlantic city nj usa pp 
may 
bentley 
multidimensional binary search trees associative searching 
comm 
acm 
bouma jr collision detection analysis physical simulation 
eurographics workshop animation simulation pp 
vienna austria sep 
cameron 
collision detection dimensional intersection testing 
ieee trans 
robot 
autom 
canny 
collision detection moving polyhedra 
ieee trans 
pattern anal 
mach 
intell 

vectors simulate material removed numerically controlled milling 
comput 
aided design may 

new approach automatic tool path generation numerically controlled milling machines 
proc 
th int 
conf 
manufacturing engineering pp 
brisbane australia may 
chazelle edelsbrunner grigni guibas hershberger sharir snoeyink 
ray shooting polygons geodesic triangulations 
proc 
th int 
colloq 
automata lang 
program vol 
lecture notes comput 
sci pp 

springer verlag 
bibliography cheng 
algorithms ray shooting intersection searching 
algorithms 
chung 
efficient collision detection algorithm polytopes virtual environments 
master philosophy thesis cs dept hong kong 
cohen lin manocha ponamgi :10.1.1.139.265
collide interactive exact collision detection system large scale environments 
proc 
acm interactive graphics conf pp 

international business machines 
user guide ibm interaction accelerator tm version release ibm watson res 
center yorktown heights ny usa sep 
rossignac 
box intersection minimax boxes 
internal report ibm watson res 
center yorktown heights ny usa 
de berg 
efficient algorithms ray shooting hidden surface removal 
ph dissertation dept comput 
sci utrecht univ utrecht netherlands 
de berg halperin overmars snoeyink van kreveld 
efficient ray shooting hidden surface removal 
proc 
th annu 
acm sympos 
comput 
geom pp 

bibliography dobkin hershberger kirkpatrick suri 
computing intersection depth polyhedra 
algorithmica 
dobkin kirkpatrick 
fast detection polyhedral intersection 
theoret 
comput 
sci 
dobkin kirkpatrick 
linear algorithm determining separation convex polyhedra 
algorithms 
dobkin kirkpatrick 
determining separation preprocessed polyhedra unified approach 
proc 
th int 
colloq 
automata lang 
program vol 
lecture notes comput 
sci pp 

springer verlag 
mehlhorn 
complete efficient algorithm intersection general convex polyhedron 
proc 
rd workshop algorithms data struct vol 
lecture notes comput 
sci pp 

springer verlag 
hauck 
discrete simulation nc machining 
algorithmica 
garcia alonso serrano 
solving collision detection problem 
ieee comput 
graph 
appl may 
goldsmith salmon 
automatic creation object hierarchies ray tracing 
ieee comput 
graph 
appl 
bibliography goodrich tamassia 
dynamic ray shooting shortest paths balanced geodesic triangulations 
proc 
th annu 
acm sympos 
comput 
geom pp 

gottschalk lin manocha 
obb tree hierarchical structure rapid interference detection 
comput 
graphics siggraph proc pp 
new orleans la usa aug 
greene 
implementation performance analysis spatial data access methods proc 
th int 
conf 
data engineering pp 
los angeles ca usa feb 
greene 
detecting intersection rectangular solid convex polyhedron 
heckbert editor graphics gems iv pp 

academic press 
isbn 
guttman 
trees dynamic index structure spatial searching proc 
acm sigmod int 
conf 
management data pp 
boston ma usa june 
kaufman 
collision detection volumetric models 
proc 
ieee visualization pp 
phoenix az usa oct 
held 
collection efficient reliable intersection tests 
appear graphics tools 
held klosowski mitchell 
evaluation collision detection methods virtual reality fly throughs 
proc 
th canad 
bibliography conf 
comput 
geom pp 
qu ebec city qu ebec canada aug 
held klosowski mitchell 
real time collision detection motion simulation complex environments 
siggraph visual proc new orleans la usa aug 
held klosowski mitchell 
quickcd efficient collision detection system bv trees 
manuscript dept appl 
math 
stat suny stony brook ny usa mar 
hershberger suri 
pedestrian approach ray shooting shoot ray take walk 
proc 
th acm siam sympos 
discrete algorithms pp 

huang oliver 
nc milling error assessment tool path correction 
comput 
graphics siggraph proc pp 
orlando fl usa july 
hubbard :10.1.1.46.3524
collision detection interactive graphics applications 
ieee trans 

comput 
graph sep 
hubbard 
approximating polyhedra spheres time critical collision detection 
acm trans 
graph july 
hudson lin cohen gottschalk manocha 
accelerated collision detection vrml 
proc 
nd annu 
sympos 
virtual reality modeling language monterey ca usa 
bibliography hui 
solid sweeping image space application nc simulation 
visual comput 
hauck 
methods detecting errors numerically controlled machining surfaces 
ieee comput 
graph 
appl jan 

approximate methods simulation verification numerically controlled machining programs 
visual comput dec 
jagadish 
spatial search polyhedra proc 
th int 
conf 
data engineering los angeles usa pp 
feb 
kajiya kay 
ray tracing complex scenes 
comput 
graphics siggraph proc pp 
dallas tx usa aug 
katayama satoh 
sr tree index structure high dimensional nearest neighbor queries 
proc 
acm sigmod int 
conf 
management data tucson az usa 
flexible quantitative method nc machining verification space division solid model 
visual comput may 
klosowski held mitchell 
efficient collision detection bounding volume hierarchies dops 
ieee trans 

comput 
graph mar 
bibliography lin 
efficient collision detection animation robotics 
phd thesis eecs dept california berkeley ca usa 
lin canny 
efficient algorithms incremental distance computation 
proc 
ieee int 
conf 
robot 
automat pp 

lin manocha 
fast interference detection geometric models 
visual comput 
liu 
dimensional verification nc machining profiles extended quadtrees 
comput 
aided design nov 
logan troy wills 
voxel realtime collision detection 
manuscript univ hull 

challenge industrial haptic simulation 
manuscript boeing 
menon robinson 
advanced nc verification massively parallel 

review june 
menon voelcker 
comprehensive formulation nc verification mathematical computational problem 
design 
mirtich 
clip fast robust polyhedral collision detection 
submitted acm trans 
graph merl technical report tr june 
bibliography mitchell mount suri 
query sensitive ray shooting 
proc 
th annu 
acm sympos 
comput 
geom pp 

moore wilhelms 
collision detection response computer animation 
comput 
graphics siggraph proc pp 
atlanta ga usa aug 
mount 
intersection detection separators simple polygons 
proc 
th annu 
acm sympos 
comput 
geom pp 

naylor thibault 
merging bsp trees yields polyhedral set operations 
comput 
graphics siggraph proc pp 
aug 
fukuda 
fast interference check method octree representation 
advanced robotics 
oliver 
graphical verification numerically controlled milling programs surfaces 
phd thesis department cs michigan state mi usa 
oliver goodman 
direct dimensional nc verification 
comput 
aided design 
rourke 
computational geometry cambridge university press new york 
isbn 
palmer 
collision detection animation sphere trees 
comput 
graph 
forum june 
bibliography pellegrini 
stabbing ray shooting dimensional space 
proc 
th annu 
acm sympos 
comput 
geom pp 

ponamgi manocha lin 
incremental algorithms collision detection general solid models 
proc 
symp 
solid modeling 
applications pp 

preparata hong 
convex hulls finite sets points dimensions 
comm 
acm 
preparata shamos 
computational geometry 
springer verlag new york 
isbn 
roussopoulos direct spatial search pictorial databases packed trees proc 
acm sigmod int 
conf 
management data pp 

saito takahashi 
nc machining buffer method 
comput 
graphics siggraph proc pp 
july 

mit 
phd thesis universitat des saarlandes saarbrucken germany 
thiel 
efficient collision detection moving polyhedra 
proc 
th annu 
acm sympos 
comput 
geom pp 
vancouver bc canada 
thiel 
subquadratic algorithms general collision detection problem 
abstracts th europ 
workshop computat 
geometry cg pp 
germany mar 
bibliography schwarzkopf 
ray shooting convex polytopes 
proc 
th annu 
acm sympos 
comput 
geom pp 

sellis roussopoulos faloutsos 
tree dynamic index multi dimensional objects proc 
th int 
conf 
vldb pp 
brighton england sep 
solid url www win tue nl cs tt solid 
suri hubbard hughes 
collision detection aspect scale bounded polyhedra 
proc 
th acm siam sympos 
discrete algorithms pp 
jan 
theodoridis sellis 
optimization issues tree construction 
proc 
geographic information systems vol 
lecture notes comput 
sci pp 

van hook 
real time shaded nc milling display 
comput 
graphics siggraph proc pp 

jr index multidimensional space partitioning tree 
int 
comput 
geom 
appl 
jr back face culling applied collision detection polyhedra 

comput 
animation 
wang wang 
geometric modeling swept volume moving solids 
ieee comput 
graph 
appl dec 
bibliography wang wang 
real time verification nc programs raster graphics 
ieee int 
conf 
robotics automation san francisco ca usa apr 
hooper greenberg 
improved computational methods ray tracing 
acm trans 
graph 
white jain 
similarity indexing ss tree proc 
th int 
conf 
data engineering new orleans la usa pp 
feb 
yang lee 
nc verification wire edm map 
comput 
aided design sep 
zachmann 
exact fast collision detection 
diploma thesis institut fur tu darmstadt darmstadt germany 
zachmann 
boxtree enabling real time exact collision detection arbitrary polyhedra 
proc 
st workshop simulation interaction virtual environments iowa july 

lower bound distance 
technical report university czech republic nov 
