department computer science series publications report discovery frequent episodes event sequences heikki mannila hannu toivonen verkamo university helsinki finland discovery frequent episodes event sequences heikki mannila hannu toivonen verkamo university helsinki department computer science po box fin university helsinki finland email heikki mannila hannu toivonen verkamo cs helsinki report february pages sequences events describing behavior actions users systems collected domains 
consider problem discovering frequently occurring episodes sequences 
episode de ned collection events occur relatively close partial order 
episodes known produce rules describing predicting behavior sequence 
give eoecient algorithms discovery frequent episodes class episodes extensive experimental results 
methods telecommunication alarm management 
computing reviews categories subject descriptors content analysis indexing algorithms problems learning network operations general terms algorithms experimentation additional key words phrases knowledge discovery data mining event sequences frequent episodes sequence analysis data mining machine learning techniques adapted analysis unordered collections data 
important application areas data analyzed consists sequence events 
examples data alarms telecommunication network user interface actions crimes committed person occurrences recurrent interest knowledge discovery sequential data increased see :10.1.1.79.9370
abstractly data viewed sequence events event associated time occurrence 
example event sequence represented 
event types dioeerent types alarms telecommunication network dioeerent types user actions marked time line 
basic problem analyzing sequence nd frequent episodes collections events occurring frequently 
example sequence episode followed fj occurs times sequence viewed narrow window 
episodes general partially ordered sets events 
sequence gure instance observation occur order occurs soon 
discovering episodes telecommunication network alarm log goal nd relationships alarms 
relationships line analysis incoming alarm stream better explain problems cause alarms suppress redundant alarms predict severe faults 
consider problem 
class episodes input sequence events nd episodes occur frequently event sequence 
describe framework formalize know time edf bad efc sequence events 
ledge discovery task section 
algorithms discovering frequent episodes section 
idea rst nding small frequent episodes progressively looking larger frequent episodes 
additionally algorithms simple pattern matching ideas speed recognition occurrences single episodes 
section outlines alternative way approaching problem locating minimal occurrences episodes 
experimental results approaches various data sets section 
discuss extensions review related section 
section short 
event sequences episodes goal analyze sequences events discover recurrent combinations events call frequent episodes 
rst formulate concept event sequence look episodes detail 
event sequences consider input sequence events event associated time occurrence 
set event types event pair event type integer occurrence time event 
event type contain attributes simplicity consider event type single value 
event sequence triple edf bad efc example event sequence windows width 
ordered sequence events gamma 
integers called starting time time example presents graphically event sequence observations event sequence time just time 
event occurred time interval event type time occurrence recorded 
analysis sequences interested nding frequent episodes class episodes 
considered interesting events episode occur close time 
user de nes close close giving width time window episode occur 
de ne window slice event sequence consider event sequence sequence partially overlapping windows 
addition width window user speci es windows episode occur considered frequent 
formally window event sequence event sequence consists pairs time span gamma called width window denoted width 
event sequence integer win denote win set windows width win 
de nition rst windows sequence extend outside sequence rst window contains rst time point sequence window contains time point 
de nition event close sequence observed equally windows event middle sequence 
event sequence window width win number windows win gamma win gamma 
example shows windows width sequence previous example 
window starting time shown solid line immediately window starting time depicted dashed line 
window starting time note event occurred time window 
window starting similar dioeerence rst event missing new event 
set partially overlapping windows width constitutes rst window 
event occurs windows width event 
episodes informally episode partially ordered collection events occurring 
episodes described directed acyclic graphs 
consider instance episodes ff fi fl 
episode ff serial episode occurs sequence events types occur ff fi fl episodes ff fi fl 
order sequence 
sequence events occurring 
alarm sequence instance merged sources useful episodes insensitive intervening events 
episode fi parallel episode constraints relative order 
episode fl example non serial non parallel episode occurs sequence occurrences precede occurrence constraints relative order 
consider discovery serial parallel episodes 
de ne episodes formally 
episode ff triple set nodes partial order mapping associating node event type 
interpretation episode events occur order described size ff denoted jffj jv episode ff parallel partial order trivial 
episode ff serial relation total order 
episode ff injective mapping injection event type occurs twice episode 
example consider episode ff 
set contains nodes say mapping labels nodes event types seen gure event type supposed occur event type precedes episode ff injective contain duplicate event types window ff occurs may multiple events types de ne episode relation extensively algorithms discovering frequent episodes 
episode fi ff denoted fi ff exists injective mapping 
episode ff fi fi ff 
write fi oe ff fi ff ff fi 
example see fi fl fi subgraph fl 
terms de nition mapping connects nodes labeled nodes labeled nodes fi disjoint corresponding nodes fl 
nodes episode fi ordered corresponding nodes fl need ordered 
consider means episode occurs sequence 
nodes episode need corresponding events sequence event types partial order episode respected 
episode ff occurs event sequence exists injective mapping ng nodes events example window contains events episodes fi fl occur window ff 
algorithm input set event types event sequence set episodes window width win frequency threshold minfr con dence threshold minconf 
output episode rules hold respect win minfr minconf 
method 
find frequent episodes algorithm 
compute win minfr 
generate rules 
ff win minfr 
fi oe ff 
fr ff fr fi minconf 
output rule fi ff con dence fr ff fr fi de ne frequency episode fraction windows episode occurs 
event sequence window width win frequency episode ff fr ff win win ff occurs jw win frequency threshold minfr ff frequent fr ff win minfr 
task interested discover frequent episodes class episodes 
class parallel episodes serial episodes 
denote collection frequent episodes respect win minfr win minfr 
frequent episodes known obtain rules describe connections events event sequence 
example know episode fi occurs windows fl occurs windows estimate seeing window chance follows window 
rules show connections events clearly frequent episodes 
algorithm shows rules con dences computed frequencies algorithm input set event types event sequence set episodes window width win frequency threshold minfr 
output collection win minfr frequent episodes 
method 
compute fff jffj 


database pass algorithms 
compute fff fr ff win 

candidate generation algorithm 
compute fff jffj fi fi oe ff 
jfij fi jfij 
output episodes 
note indentation algorithms specify extent loops conditional statements 
algorithms frequent episodes rule generation straightforward 
concentrate discovery task event sequence set episodes window width win frequency threshold minfr nd win minfr give rst speci cation algorithm exact methods subtasks 
call methods collectively winepi algorithm 
main algorithm algorithm computes collection win minfr frequent episodes class episodes 
algorithm performs levelwise breadth rst search episode lattice spanned relation 
search starts general episodes episodes event 
level algorithm rst computes collection candidate episodes checks frequencies event sequence database 
crucial point candidate generation immediate lemma 
lemma episode ff frequent event sequence subepisodes fi ff frequent 
collection candidates speci ed consist episodes smaller subepisodes frequent 
criterion safely prunes consideration episodes frequent 
detailed methods candidate generation database pass phases subsections 
generation candidate episodes candidate generation method detail 
method easily adapted deal classes parallel episodes serial episodes injective parallel serial episodes 
algorithm computes candidates parallel episodes 
algorithm episode ff represented lexicographically sorted array event types 
array denoted name episode items array referred square bracket notation 
example parallel episode ff events types represented array ff ff ff ff ff collections episodes represented lexicographically sorted arrays ith episode collection denoted :10.1.1.40.6984:10.1.1.40.9892
episodes episode collections sorted episodes share rst event types consecutive episode collection 
particular episodes size share rst gamma events shares algorithm input sorted array frequent parallel episodes size output sorted array candidate parallel episodes size 
method 


jf 
jf 


gamma rst event types common 
build potential candidate ff combination 
ff 
ff 
build test subepisodes fi contain ff 
gamma 
gamma fi ff 
fi ff 
fi continue line 
subepisodes store ff candidate 

ff 

output events 
maximal sequence consecutive episodes size share rst gamma events called block 
potential candidates identi ed creating combinations episodes block 
eoecient identi cation blocks store episode rst episode block 
algorithm easily modi ed generate candidate serial episodes 
events array representing episode order imposed total order instance serial episode fi events types order represented array fi fi fi fi fi replacing line algorithm generates candidates serial episodes :10.1.1.40.6984:10.1.1.40.9892
options algorithm 
desired episode class consists parallel serial injective episodes episode contain event type simply insert line continue line line 
time complexity algorithm polynomial size collection frequent episodes independent length event sequence 
theorem algorithm variations time complexity jf log jf 
proof initialization line takes time jf 
outer loop line iterated jf times inner loop line jf times 
loops potential candidate lines gamma lines built time gamma 
importantly gamma subsets need searched collection line 
sorted located binary search time log jf 
total time complexity jf jf jf gamma log jf jf log jf 
practical situations time complexity close jf log jf blocks typically small 
recognizing episodes sequences consider implementation database pass 
give algorithms recognize episodes sequences incremental fashion 
windows win win sequences events similar 
take advantage similarity recognizing episodes incremental updates data structures achieve shift window obtain algorithms start considering empty window just input sequence considering empty window just sequence 
way incremental methods need special actions 
computing frequency episodes windows correctly input sequence course considered 
parallel episodes algorithm recognizes candidate parallel episodes event sequence 
main ideas algorithm 
candidate parallel episode ff maintain counter ff indicates events ff window 
ff equal jffj indicating ff entirely included window save starting time window ff ff decreases indicating ff longer entirely window increase eld ff number windows ff remained entirely window 
ff contains total number windows ff occurs 
access candidates eoeciently indexed number events type contain episodes contain exactly events type list contains 
window shifted contents window change episodes updated 
instance event type window second comes episodes list contains updated information events type expecting 
algorithm input collection parallel episodes event sequence window width win frequency threshold minfr 
output episodes frequent respect win minfr 
method 
initialization 
ff 
ff 
count 
jffj contains 
ff 
ff 
number events type ff 
contains contains fffg 
ff 
ff 
recognition 
start gamma win 
bring new events window 
events start win gamma 
count count 
ff contains count 
ff ff count 
ff jffj ff start 
drop old events window 
events start gamma 
ff contains count 
ff jffj 
ff ff gamma ff start 
ff ff gamma count 
count count gamma 
output 
episodes ff 
ff gamma win gamma minfr output ff serial episodes serial candidate episodes recognized event sequence state automata accept candidate episodes ignore input 
idea automaton serial episode ff instances automaton time active states disjoint pre xes ff occurring window 
algorithm implements idea 
initialize new instance automaton serial episode ff time rst event ff comes window automaton removed event leaves window 
automaton ff reaches accepting state indicating ff entirely included window automata ff accepting state save starting time window ff automaton accepting state removed automata ff accepting state increase eld ff number windows ff remained entirely window 
useless multiple automata state transitions produce information 
maintain reached common state removed 
jffj automata episode ff 
automaton need know removed 
represent automata ff array size jffj value ff initialized latest initialization time automaton reached ith state 
recall ff represented array containing events array label state transitions 
access traverse automata eoeciently organized way 
event type automata accept linked list waits 
list contains entries form ff meaning episode ff waiting xth event 
event enters window shift list waits traversed 
automaton reaches common state automaton earlier entry ff initialized simply overwritten 
transitions shift window stored list transitions 
represented form ff meaning episode algorithm input collection serial episodes event sequence window width win frequency threshold minfr 
output episodes frequent respect win minfr 
method 
initialization 
ff 
jffj 
ff initialized 
waits ff 
ff 
waits ff waits ff ff 
ff 
gamma win gamma 
recognition 
start gamma win 
bring new events window 
start win gamma 
transitions 
events start win gamma 
ff waits 
jffj ff initialized ff start 

transitions transitions ff start win gamma 

transitions transitions ff ff initialized gamma 
ff initialized gamma 
ff initialized gamma ff gamma 
ff initialized gamma 
waits waits ff 
ff transitions 
ff initialized 
ff 
jffj waits ff waits ff ff 
drop old events window 
ff start gamma 
jffj ff ff gamma ff start 
waits ff waits ff ff 
ff initialized 
output 
episodes ff 
ff gamma win gamma minfr output ff ff got xth event latest initialization time pre length updates regarding old states automata done immediately updates new states done transitions identi ed order overwrite useful information 
easy removal automata go window automata initialized time stored list 
analysis time complexity simplicity suppose class event types xed assume exactly event takes place time unit 
assume candidate episodes size length sequence 
theorem time complexity algorithm jcj proof initialization takes time jcj 
consider number operations innermost loops accesses ff lines 
recognition phase shifts window 
shift new event comes window old event leaves window 
episode ff ff accessed twice shift 
cost recognition phase jcj 
practice size episodes small respect size sequence time required initialization safely neglected 
injective episodes tighter result 
theorem time complexity recognizing injective parallel episodes algorithm excluding initialization win jcj proof consider win successive shifts time unit 
sequence shifts jcj candidate episodes ff undergo changes event type count increased decreased 
due fact event type come window count win time units 
reading input takes time time bound contrasted time usage trivial non incremental method sequence pre processed windows frequent sets searched 
time requirement recognizing jcj candidate sets windows plus time required read windows size win jcj delta win larger factor win 
theorem time complexity algorithm jcj proof initialization takes time jcj win 
recognition phase shifts shift event comes window event leaves window 
shift episode ff depends number automata accessed maximum automata episode 
worst case time complexity jcj win jcj jcj note win 
worst case input sequence consists events event type candidate serial episodes consist events particular type 
shift window results update automaton 
worst case complexity close complexity trivial non incremental method jcj delta win 
practical situations time requirement considerably smaller approach savings obtained case injective parallel episodes 
theorem time complexity recognizing injective serial episodes algorithm excluding initialization jcj proof shifts automata episode event comes window state fl ffi ffi recursive composition complex episode 
transition automaton automaton removed initializing event goes window 
general partial orders far discussed serial parallel episodes 
discuss partial orders episodes 
recognition arbitrary episode reduced recognition hierarchical combination serial parallel episodes 
example episode fl serial combination episodes parallel episode ffi consisting episode ffi consisting 
occurrence episode window tested hierarchical structure see episode fl occurs window checks method serial episodes subepisodes ffi ffi occur order check occurrence ffi uses method parallel episodes verify occur 
complications take account 
necessary duplicate event node obtain decomposition serial parallel episodes 
duplication works easily injective episodes non injective episodes need complex methods 
important aspect composite events duration elementary events practical alternative handle episodes basically parallel episodes check correct partial ordering events window 
parallel episodes located eoeciently checking correct partial ordering relatively fast 
alternative approach minimal occurrences outline approach section describe alternative approach discovery episodes 
looking windows considering episode occurs window look exact occurrences episodes relationships occurrences 
advantages new approach focusing occurrences episodes allows easily nd rules window widths lefthand side rule iif occur seconds follows 
approach minimal occurrences episodes 
new rule formulation minimal occurrences gives raise new method called minepi recognition episodes input sequence 
frequent episode store information locations minimal occurrences 
recognition phase compute locations minimal occurrences candidate episode ff temporal join minimal occurrences subepisodes ff 
addition simple eoecient formulation advantage con dences frequencies rules large number dioeerent window widths obtained quickly need rerun analysis wants modify window widths 
case complicated episodes time needed recognizing occurrence episode signi cant stored minimal occurrences episodes eliminates unnecessary repetition recognition 
identify minimal occurrences time intervals way 
episode ff event sequence say interval minimal occurrence ff ff occurs window ff occur proper subwindow window width width 
set intervals minimal occurrences episode ff event sequence denoted mo ff mo ff minimal occurrence ffg example consider event sequence episodes 
parallel episode fi consisting event types minimal occurrences mo fi partially ordered episode fl minimal occurrences 
episode rule expression fi win ff win fi ff episodes fi ff win win integers 
informal interpretation rule episode fi minimal occurrence interval gamma win episode ff occurs interval gamma win formally expressed way 
win fi denote mo win fi mo fi gamma win ff interval de ne occ ff true exists minimal occurrence mo ff con dence episode rule fi win ff win jf mo win fi occ ff win gj win fi example continuing previous example rules con dences 
rule fi fl jf gj denominator jf gj numerator con dence :10.1.1.40.9892
rule fi fl con dence 
note fi ff rule right hand side ff contains information relative location event events rule right hand side required positioned events left hand side 
number possible de nitions temporal relationship intervals 
instance rules point backwards time de ned similar way 
brevity consider case 
de ned frequency episode fraction windows contain episode 
frequency nice interpretation probability randomly chosen window contains episode concept useful minimal occurrences xed window size window may contain minimal occurrences episode 
frequency concept support number minimal occurrences episode support episode ff event sequence ff frequency threshold threshold support support threshold minsup episode ff frequent ff minsup 
current episode rule discovery task stated follows 
event sequence class episodes set time bounds nd frequent episode rules form fi win ff win fi ff fi ff win win finding minimal occurrences episodes section describe informally collection minepi algorithms locate minimal occurrences frequent serial parallel episodes 
start observations basic properties episodes 
lemma holds subepisodes frequent episode frequent 
main algorithm algorithm candidate generation algorithm minepi 
results minimal occurrences episode containing minimal occurrences subepisodes 
lemma assume ff episode fi ff 
mo ff fi occurs interval mo fi lemma ff serial episode size mo ff 
subepisodes ff ff ff size gamma mo ff mo ff lemma ff parallel episode size mo ff 
subepisodes ff ff ff size gamma mo ff mo ff furthermore minft minimal occurrences candidate episode ff located way 
rst iteration main algorithm mo ff computed input sequence episodes ff size 
rest iterations minimal occurrences candidate ff located rst selecting suitable subepisodes ff ff ff computing temporal join minimal occurrences ff ff spirit lemmas 
speci serial episodes subepisodes selected ff contains events ff turn contains rst 
minimal occurrences ff speci cation mo ff mo ff mo ff parallel episodes subepisodes ff ff contain events omitted events dioeerent 
see lemma idea compute minimal occurrences ff 
minimal occurrences candidate episode ff linear pass minimal occurrences selected subepisodes ff ff time required candidate ff ff ff length event sequence 
optimize running time ff ff selected ff ff minimized 
space requirement algorithm expressed ff ff assuming minimal occurrences frequent episodes stored alternatively max ff ff current levels minimal occurrences stored 
size ff ff bounded number events input sequence event sequence minimal occurrence episode size 
second iteration event input sequence start jf minimal occurrences episodes size 
space complexity second iteration jf jn 
minimal occurrences episodes located quite eoeciently size data structures larger original database especially rst couple iterations 
practical solution pattern matching methods similar ones winepi section locate minimal occurrences 
note minepi solve task winepi 
window contains occurrence episode exactly contains minimal occurrence 
frequency episode ff computed mo ff 
finding con dences rules show information minimal occurrences frequent episodes obtain con dences various types episode rules looking data 
recall de ned episode rule expression fi win ff win fi ff episodes fi ff win win integers 
nd rules rst note rule frequent episode ff frequent 
rules form enumerated looking frequent episodes ff looking subepisodes fi ff 
evaluation con dence rule fi win ff win done pass structures mo fi mo ff follows 
mo fi gamma win locate minimal occurrence ff rst interval mo ff property 
check gamma win time complexity con dence computation episode time bounds win win fi ff 
con dences win win set time bounds table size jwj time fi ff jwj 
reasons brevity omit details 
set time bounds restrict initial search minimal occurrences episodes 
denote maximum time bound win max max 
episode rules occurrences win max time units longer episode occurrences ignored search frequent episodes 
consider support computed respect win max experiments run series experiments winepi minepi 
general performance methods eoeect various parameters scalability methods considered section 
consideration applicability methods various types data sets 
experiments run pc mhz pentium processor mb main memory linux operating system 
sequences resided text le 
performance overview experimental overview discovered episodes rules telecommunication network fault management database 
database sequence alarms covering time period weeks 
dioeerent types alarms diverse frequencies distributions 
average alarm minute 
alarms tend occur bursts extreme cases alarms second 
start looking performance winepi method described section 
performance characteristics evaluate method 
time required method number episodes rules method respect frequency threshold window width possible performance measures 
results opposite extreme cases complexity serial episodes injective parallel episodes 
tables represent performance statistics nding frequent episodes alarm database various frequency thresholds 
number frequent episodes decreases rapidly frequency threshold increases 
frequency threshold numbers serial injective parallel episodes may fairly similar frequency threshold results frequency candidates frequent iterations total threshold episodes time table performance characteristics serial episodes winepi alarm database window width frequency candidates frequent iterations total threshold episodes time table performance characteristics injective parallel episodes winepi alarm database window width serial episodes parallel episodes 
actual episodes dioeerent seen number iterations recall iteration produces episodes size frequency threshold longest frequent serial episode consists events candidates iteration infrequent longest frequent injective parallel episodes events 
number iterations equals number candidate generation phases 
number database passes equals number iterations smaller candidates iteration 
episodes window width number frequent serial solid line injective parallel dotted line episodes function window width winepi alarm database frequency threshold 
eoeect window width number frequent episodes represented 
window width considerably fewer frequent injective parallel episodes frequent serial episodes 
alarm data increase number episodes fairly window widths considered 
show may depend heavily type data 
represents number serial injective parallel episodes method total processing time required frequency threshold increases 
curves decrease steeply increasing frequency threshold 
time requirement smaller parallel episodes serial episodes threshold 
reasons 
parallel episodes considerably shorter see tables fewer database passes needed 
complexity recognizing injective parallel episodes smaller 
episodes frequency threshold number frequent serial solid line injective parallel dotted line episodes function frequency threshold winepi alarm database window width time frequency threshold processing time serial solid line injective parallel dotted line episodes function frequency threshold winepi alarm database window width quality candidate generation take closer look candidates considered frequent episodes iterations procedure 
example look happens rst iterations 
statistics rst iterations episode episodes candidates frequent match size episodes delta delta delta delta delta delta delta delta table number candidate frequent serial episodes rst iteration phases winepi alarm database frequency threshold window width run frequency threshold window width shown table 
rst iterations dominate behavior method 
phases number candidates large small fraction cent candidates turns frequent 
third phase candidate generation eoecient candidates infrequent total number iteration phases iterations involve candidates 
safely combine iteration steps reduce number database passes 
take closer look frequent episodes observe frequent episodes longer events consist repeating occurrences frequent alarms 
alarms occurs database times cent events 
support candidates frequent iterations total threshold episodes time table performance characteristics serial episodes minepi alarm database maximum time bound support candidates frequent iterations total threshold episodes time table performance characteristics parallel episodes minepi alarm database maximum time bound comparison algorithms winepi minepi tables represent performance statistics nding frequent episodes minepi method minimal occurences 
compared corresponding gures winepi tables observe general tendency rapidly decreasing number candidates episodes support threshold increases 
episodes winepi minepi necessarily 
compare cases tables approximately number frequent episodes serial episodes winepi time support threshold processing time serial solid line injective parallel dotted line episodes minepi alarm database maximum time bound minepi notice correspond episodes 
sizes longest episodes somewhat dioeerent original minimal occurrence method 
frequency threshold winepi corresponds minimum instances episode support threshold minepi 
dioeerence methods clear small episodes 
consider episode ff consisting just event winepi considers single event occur windows width minepi sees minimal occurrence 
hand successive events type result ff occuring windows number minimal occurrences doubled 
shows time requirement nding frequent episodes minepi 
processing time minepi reaches plateau size maximal episodes longer changes case support threshold 
behavior similar serial parallel episodes 
time requirements minepi directly compared winepi episodes discovered dioeerent implementation minepi works entirely main memory 
large databases varying support threshold time bounds support distinct rule gen threshold rules time varying number time bounds support threshold number rule gen time bounds rules time table number rules rule generation time minepi alarm database serial episodes support threshold maximum time bound con dence threshold 
possible rst iterations minimal occurrences need stored disk methods variants algorithms 
rules methods easily produce large amounts rules 
recall rules constructed considering frequent episodes ff right hand side subepisodes fi ff left hand side rule 
additionally minepi considers variations rules time bounds set table represents results serial episodes 
initial episode generation minepi took total number frequent episodes 
table shows number rules obtained minepi con dence threshold maximum time bound left varying support threshold rules time bounds excluded gures rule generation time obtained generating rules dioeerent time bounds 
rules threshold total number distinct rules minepi various con dence thresholds alarm database maximum time bound support threshold 
minimal occurrence method particularly useful interested nding rules dioeerent time bounds 
right side table represents performance results varying number time bounds 
time requirement increases slowly time bounds time increases number rules 
amount rules obtained time bounds may unnecessarily large ed 
remember distinct rules 
rest rules dioeerent combinations time bounds case granularity second 
cost obtain ne grained rules frequent episodes 
dioeerent criteria select interesting rules 
represents eoeect con dence threshold number distinct rules minepi 
initial number rules may quite large decreases fairly rapidly require reasonable con dence 
data set events event supp 
max conf 
freq 
rules name types thr 
time thr 
epis 
alarms www text text protein table characteristic parameter values data sets number episodes rules minepi 
results dioeerent data sets addition experiments alarm database run minepi variety dioeerent data collections get better view usefulness method 
data collections typical parameter values results table 
www data part www server log department computer science university helsinki 
log contains requests www pages department server requests www browsers host internet 
consider www page fetched event type 
number events data set covering weeks february march 
total dioeerent pages referred 
requests images excluded consideration 
suitable support thresholds vary lot depending number events distribution event types 
suitable maximum time bound device generated alarm data minute slower pace human user requires larger time bound minutes www log 
relatively small time bound reduce probability unrelated requests contributing support 
low con dence threshold www log justi ed interested fairly usual patterns usage dominating ones 
www server log long paths pages home page department pages individual courses 
behavior suggests bookmark directly home page course users quickly navigate departmental home page 
text data collections modi cations english text 
word considered event words indexed consecutively give event 
sentence causes gap indexing scheme correspond longer distance words dioeerent sentences 
text gnu man pages gnu awk manual 
size original text text words size condensed text le text noninformative words articles prepositions conjunctions stripped ooe words 
number dioeerent words original condensed text resp 

text analysis point large time bounds connection words fairly close 
clearly seen represents number episodes various window widths winepi 
gure reveals behavior distinctively dioeerent corresponding alarm database 
observe text data window widths produce practically amount serial episodes 
number episodes increase considerably larger window widths 
data interesting frequent episodes smaller episodes larger window widths noise 
phenomenon observed parallel episodes 
rules text simple analysis 
strongest rules original text involve word episodes window width number serial solid line injective parallel dotted line episodes function window width winepi compressed text data text frequency threshold 
common phrases value con dence meaning cases words ithe consecutive immediately followed preposition :10.1.1.40.6984:10.1.1.40.6984
rules condensed text prepositions articles stripped ooe 
rules condensed text contain multiple occurrences word combinations words occurring header man page 
performed scale tests fold multiples compressed text le sequences approximately events 
results show time requirement roughly linear respect length input sequence expected 
experimented protein sequences 
data prosite database www molecular biology server geneva university hospital university geneva 
prosite contains biologically signi cant dna protein patterns help time relative size database scale results serial solid line injective parallel dotted line episodes minepi compressed text data maximum time bound support threshold smallest le fold larger les 
identify family protein new sequence belongs 
purpose experiment evaluate algorithm external data collection patterns known exist nd patterns previously unknown biologists 
selected target family sequences mismatch repair proteins prosite entry ps 
sequences family known contain string symbols 
transformed data manner similar english text symbols indexed consecutively protein sequences place gap 
total length data set events alphabet event types 
method easily modi ed take sequences input compute support episode ff number input sequences contain minimal occurrence ff length maximum time bound 
parameter values protein database chosen purpose reveal pattern known database 
window width selected slightly larger length pattern looking support threshold set individual sequences original data 
data interested longest episodes length longer 
episodes episodes length 
expected contain sequence known database 
longer episodes variants pattern eighth symbol fairly near necessarily immediately subsequent pattern 
types patterns belong pattern class prosite longer patterns reported prosite database 
extensions related task discovering frequent parallel episodes stated task discovering frequent sets central phase discovering rules rule generation methods basically association rules winepi :10.1.1.40.6984
levelwise main algorithm successfully search frequent sets 
technical problems related recognition episodes researched elds 
advantage slowly changing contents group events studied arti cial intelligence similar problem spirit pattern object pattern match problem production system interpreters 
comparable strategies sliding window study locality virtual memory 
setting window queue special property know advance event leave window knowledge winepi recognition serial episodes 
minepi take advantage fact know subepisodes candidates occurred 
sequence data databases see provides inter openings database techniques processing queries sequences 
problem similar computation frequencies occurs area active databases 
triggers speci ed composite events somewhat similar episodes 
shown nite automata constructed composite events recognize trigger red 
method practical episodes deterministic automata large 
methods matching sets episodes sequence similarities algorithms string matching 
particular recognizing serial episodes sequence seen locating occurrences subsequences matches patterns variable length don care symbols length occurrences limited window width 
learning set sequences received considerable interest eld bioinformatics interesting problem discovery patterns common set related protein amino acid sequences 
classes patterns substrings xed length don care symbols 
closer patterns considered 
described algorithm nds patterns similar serial episodes patterns minimum length occurrences edit distance 
results pattern matching aspects recognizing episodes 
closely related :10.1.1.40.9892
multiple sequences searched patterns similar serial episodes extra restrictions event taxonomy 
methods extended taxonomy direct application similar extensions association rules 
methods applied analyzing variety choices de nition frequency episode set 
pattern class extended windowing extra time constraints event taxonomy :10.1.1.40.9892:10.1.1.40.9892
survey patterns sequential data see 
stochastics event sequence data called marked point process 
noted traditional methods analyzing marked point processes ill suited cases number event types large 
exists interesting combination techniques frequent episodes discovered rst phenomena describe analyzed detail methods marked point processes 
interesting similarities discovery frequent episodes done inductive logic programming see noticeable dioeerence caused sequentiality underlying data model emphasis time limited occurrences :10.1.1.35.951
similarly problem looking occurrence episode viewed constraint satisfaction problem 
class patterns discovered easily modi ed directions 
dioeerent windowing strategies considering windows starting win time units win windows starting event 
types patterns searched substrings xed length don care symbols searching episodes sequences problem 
general framework episode discovery 
episodes de ned combinations events satisfying certain user speci ed unary binary conditions 
framework discovering frequent episodes sequential data 
framework consists de ning episodes partially ordered sets events looking windows sequence 
described algorithm winepi nding episodes class episodes frequent 
algorithm discovery episodes considering episode subepisodes frequent incremental checking episode occurs window 
implementation shows method eoecient 
applied method analysis alarm aeow telecommunication networks discovered episodes embedded alarm handling software 
alternative approach minepi discovery frequent episodes minimal occurrences episodes 
approach supplies power representing connections events produces rules time bounds 
rule formalisms advantages 
rules minepi informative frequencies con dences rules winepi nice interpretations probabilities concerning randomly chosen windows 
large part algorithms similar signi cant dioeerences computation frequency support 
roughly general tendency performance winepi eoecient rst phases discovery due smaller space requirement 
iterations minepi outperform winepi clearly 
methods modi ed cross winepi nding minimal occurrences minepi counting windows large problems rule type winepi minepi mixture methods give better performance 
interesting extensions facilities rule querying compilation methods user specify episode class high level language de nition automatically compiled specialization algorithm take advantage restrictions episode class 
open problems include combination episode techniques marked point processes intensity models 
prosite database status 
nucleic acids research 
agrawal imielinski swami :10.1.1.40.6984
mining association rules sets items large databases 
proceedings acm sigmod conference management data sigmod pages may 
agrawal mannila srikant toivonen verkamo 
fast discovery association rules 
fayyad smyth uthurusamy editors advances knowledge discovery data mining pages 
aaai press menlo park ca 
agrawal srikant :10.1.1.40.9892
mining sequential patterns 
proceedings eleventh international conference data engineering icde pages taipei taiwan mar 
bettini wang jajodia 
testing complex temporal relationships involving multiple granularities application data mining 
proceedings fifteenth acm sigact symposium principles database systems pods pages montreal canada june 
das fleischer gunopulos rkk inen 
episode matching 
manuscript 
denning 
working set model program behavior 
communications acm 
ghallab 
situation recognition representation algorithms 
proceedings thirteenth international joint conference arti cial intelligence ijcai pages chambery france aug 
forgy 
rete fast algorithm pattern object pattern match problem 
arti cial intelligence 
gehani jagadish shmueli 
composite event speci cation active databases 
proceedings international conference large data bases vldb pages vancouver canada aug 
geneva university hospital university geneva switzerland 
molecular biology server 
ch 
grossi 
simple eoecient string matching mismatches 
information processing letters 
han fu 
discovery multiple level association rules large databases 
proceedings st international conference large data bases vldb pages zurich 
kersten mannila toivonen 
perspective databases data mining 
proceedings international conference knowledge discovery data mining kdd pages montreal canada aug 
collins higgins 
finding patterns unaligned protein sequences 
protein science 
prentice 
statistical analysis failure time data 
john wiley new york ny 
laird 
identifying patterns sequential data 
jantke kobayashi tomita yokomori editors algorithmic learning theory th international workshop pages berlin 
springer verlag 
mannila toivonen 
discovering generalized episodes minimal occurrences 
proceedings second international conference knowledge discovery data mining kdd pages portland oregon aug 
aaai press 
morris khatib 
algebraic formulation temporal knowledge reasoning recurring events 
proceedings international workshop temporal representation reasoning time pages fl may 
muggleton :10.1.1.35.951
inductive logic programming 
academic press london 
seshadri livny ramakrishnan 
seq design implementation sequence database system 
proceedings nd international conference large data bases vldb pages india sept 
srikant agrawal 
mining generalized association rules 
proceedings st international conference large data bases vldb pages zurich 
srikant agrawal 
mining sequential patterns generalizations performance improvements 
advances database technology th international conference extending database technology edbt pages avignon france 

wang 
chirn marr shapiro shasha zhang 
combinatorial pattern discovery scienti data preliminary results 
proceedings acm sigmod conference management data sigmod pages june 
