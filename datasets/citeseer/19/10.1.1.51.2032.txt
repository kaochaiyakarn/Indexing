debugging vliw code instruction scheduling lyle edward cool college university portland thesis submitted faculty oregon graduate institute science technology partial fulfillment requirements degree master science computer science engineering july thesis debugging vliw code instruction scheduling lyle edward cool examined approved examination committee michael wolfe thesis advisor associate professor steve otto assistant professor larry meadows portland group incorporated ii learned tremendous amount course express gratitude opportunity 
am grateful intel maintaining climate continuing education encouraged 
specifically intel tuition reimbursement program provided funding research 
help probably continued education long 
am grateful steve otto larry meadows helpful feedback 
am especially grateful michael wolfe help completing 
gave innumerable suggestions corrections comments phase project 
gave encouragement keep moving forward needed 
iii table contents iii list figures vii viii chapter 
compiler optimizations debugging 

debuggers non optimized imperative programs 
examples debug information usage 
program exception 
setting breakpoint 
starting execution user control 
reporting value program variable 
changing value program variable 
optimizations cause problems debuggers 
constant folding 
loop invariant code motion 
register variables 
instruction scheduling 
optimizations cause problems 
want able debug optimized code 
chapter 
previous 
debugging system compatible optimizing compiler warren 
symbolic debugging optimized code hennessy 
interactive source level debugging optimized programs zellweger 
recovery noncurrent variables source level debugging optimized code srivastava 
doc practical approach source level debugging globally optimized code coutant 
source level debugging optimized code detecting unexpected data values 
summary 
iv chapter 
justification 
vliw architecture 
different architectures 
advantages 
disadvantages 
reason vliw architectures 
brief history 
instruction scheduling 
compaction re ordering 
trace scheduling 
software pipelining 
hierarchical reduction 
scheduling vliw architectures problem debugging 
want able debug code 
chapter 
approach debugging vliw code instruction scheduling 

scope proposal 
enhancements conventional debug information 
conventional debug information 
re ordered code 
code map re ordered compacted code 
code map duplicated re ordered compacted code 
data map duplicated re ordered compacted code 
representing state computation 
implementation typical debugger commands 
go til 
go 
get set value 
advantages 
disadvantages 
chapter 
examples 
extended example code map usage interpretation 
architectural overview 
code listings 
lessons learned 
loop conditional branch 
chapter 
concluding remarks summary 
strengths 
weaknesses 
suggestions 
bibliography 
appendix 
author 
vi list figures 
source level debugger screen non optimized code 

source level debugger screen vliw code 

improved source level debugger screen vliw code 

source fragment control flow graph 

source fragment highlighting control flow graph 

breakpoint hit line non optimized code 

control flow graph 

source view execution 

source view breakpoint hit line multiplication 

source view breakpoint line multiplication 
vii debugging vliw code instruction scheduling lyle edward cool supervising professor michael wolfe years aimed solving problem debugging optimized code scalar architectures 
instruction scheduling vliw architectures causes additional debugging problems addressed 
additional problems include deal compaction individual operations vliw words transformations occur part software pipelining loop unrolling 
earlier debugging optimized code examined modifications proposed handle problems 
way presenting information user source level terms examined 
results indicate effective source level debugging vliw code instruction scheduling feasible 
viii chapter 
compiler optimizations debugging 
non trivial programs rarely correctly time 
cause errant behavior may simple misplaced semi colon fundamental incorrectly applied algorithm 
programs don correctly said contain bugs 
process finding bugs called debugging 
primitive kinds debugging insert statements key places program print portion state running program 
state sense means value variables particular point program 
kind debugging considered primitive reasons 
program modified re compiled re executed time user wants know state running program 
second user ordinarily control execution program specifically written may possible re execute specific portion different data skip portion conditions 
third insertion extra code effectively creates different program 
cases cause problem presence extra debugging code may cause bug manifest different manner 
fortunately software tools available process debugging effective 
called debuggers 
debuggers designed display interest programmer 
designed control execution portion program executed followed display modification items interest followed program execution 
constitutes items interest different different environments 
operating system example manages interface high level processes low level hardware 
debugger operating system able start processes examine modify state processes running 
person debugging yacc program want step parsing language statement display parse stack 
surprisingly programming language debuggers necessarily similar 
example stepping imperative language program hard imagine stepping functional language program may sense 
thesis aimed programs written imperative languages pascal fortran 

debuggers non optimized imperative programs 
programs written imperative languages consist steps required achieve purpose programmer 
steps form series statements things broadly speaking 
class statements concerned flow execution 
includes things conditional repetitive constructs statements 
main class includes statements actual computations program 
statements things get value variable multiply number store new value variable 
bugs creep program programmer inadvertently specifies wrong series statements wrong variable destination computation 
happen statements exactly right tenth result computation stored wrong variable 
debugger imperative language needs able place program user examine state see gone wrong step program watch state changes step 
allowing user control program executes step step debugger enables user find point computation goes 
capabilities needed grouped broad categories correspond closely characteristics distinguish imperative language programs ability get set current execution point ability get set value variable 
order achieve capabilities debugger get help architecture compiler 
architecture needs ability execution address 
accomplished indirectly means special breakpoint opcode causes trap debugger 
accomplished directly having ability trap debugger previously specified address reached execution 
architectures support methods 
helpful theoretically non essential able trap debugger instruction 
frequently stepping achieved 
compiler needs provide debugger information collect compilation 
compiler knows example memory location corresponds variable 
debug information created compilation typically consists maps contains mapping source statement address corresponding block object code contains mapping variable name location type 
maps assume course source statement map distinct block object code variable map single location 
help architecture controlling execution help compiler provide mappings object code source code effective debugging non optimized code readily achieved 

examples debug information usage 

program exception suppose program exception occurred hardware os left address offending instruction debugger get 
situation debugger consult code map discover block code instruction came report back corresponding statement source statement responsible exception 

setting breakpoint event user wants execution particular statement debugger consult code map find address block object code corresponding source statement save original opcode place breakpoint instruction location 
execution resume breakpoint hit program exited 
event breakpoint hit exception raised causing logic previous example followed 

starting execution user control user want start resume execution particular statement 
situation debugger consult code map find address block object corresponds statement set instruction pointer location 
useful feature debugger allows user skip source lines repeat example 
user believes cause bug source line increments variable times 
test thesis having rebuild program scratch user direct debugger skip line rest program run course 
output correct line skipped incorrect mystery solved easily fixed 
user continue search 
noted altering flow control program easily unintended consequences assumptions compiler code generated may violated 

reporting value program variable assume execution momentarily stopped due program exception division zero user wants find value variable 
situation debugger consult data map find location variable retrieve value print type 

changing value program variable user wants change value variable execution resumes 
situation debugger consult data map find location variable change desired value 
suppose user believes variable receives wrong value incorrect value causes subsequent problems program 
test thesis user directly alter value variable program continue test results 
flow control program dependent value certain variables warning issued earlier section starting execution user control relevant 
altering variable program may take unintended path 

optimizations cause problems debuggers 
optimizations cause problems debuggers optimizations violate assumptions debug information created 
code motion optimization moves evaluation expression different location conventional debug information may longer valid portion code 
register allocation portion compiler decides keep variable register equivalent source statements debug information indicates variable lives particular location memory incorrect regions program 
debugger trying invalid debug information best confuse user worst give misleading incorrect responses 
examples optimizations cause problems debuggers rely conventional debug information 

constant folding evaluation constant expression compile time called constant folding may performed minimum optimization specified 
example compiler easily determine value safely calculated statically 
words compiler essence replaced original statements user expected able step calculation run time surprised calculation happens 

loop invariant code motion loop invariant code motion optimization expression function loop iteration moved outside loop 
example assignment safely moved loop assuming aliased way 
moving loop execution time reduced expression evaluated times 
effect user wrote user trying debug original source surprised assignment happened entry loop 

register variables register promotion optimization cause problems 
consider source fragment int non optimized version code value loaded memory expression incremented stored back memory iteration loop 
debugger query value half way execution loop problem 
debug information indicate corresponding memory location debugger retrieve 
optimization phase compiler discover heavily variable decide keep register 
furthermore loop represented variable memory location get updated 
problem debugger uses conventional debug information retrieve variable value thinks current location aware memory location temporarily non current 

instruction scheduling instruction scheduling creates problems rearrangement operations statement boundaries 
sense problems similar caused code motion optimizations 
thesis fact concentrates instruction scheduling specific problems created debugging covered detail subsequently 

optimizations cause problems 
long optimization violate assumptions debug information produced create problems debuggers 
strength reduction compiler substitutes cheaper set instructions obvious suggested source code ordinarily problems 
example compiler substitute presumably cheaper equivalent means value shifted left bit position 

want able debug optimized code 
common ways dealing problem debugging optimized code turn optimizations re compile feasible debug assembly language level 
workarounds may acceptable 
regard re compiling optimizations turned bug may show presence optimizations 
situation occur compiler option perform unsafe optimizations 
example source file int int iptr source file extern int iptr main iptr program equal 
compiler performing unsafe optimizations direction user knew doing save register line old value line 
situation optimized program behave differently compiler bugs 
unfortunately true assume compiler generates correct code 
fact compiler writers obviously want able debug optimized code source level order fix compiler bugs 
possible speed space considerations debugging non optimized version impossible 
regard debugging assembly language level easily trivial programs 
ability full source level debugging optimized code desirable 
chapter 
previous 
debugging system compatible optimizing compiler warren called technical disclosure bulletin summary document really looking 
full document called design fds interactive debugging system 
far know longer available 
earliest am aware surprisingly thorough 
recognized traditional debug information maps sufficient debugging optimized code 
proposed total maps handle various situations arise debugging session sloc map module procedure statement corresponding object code 
styp map module procedure statement statement type call assignment conditional variable 
variable means variable name case assignment statement target case call statement example 
map module procedure statement variable list locations 
list needed case variable lives location 
map module procedure statement variable table optimization information consists uses deleted uses added assignments deleted assignments added liveness 
attr map module procedure variable corresponding attributes 
mean attributes needed needed address variable 
example give variable accessed address known 
map module procedure list deleted statements succ map module procedure statement list possible successors single stepping 
apparently project got past design stage information practical 
clear vast amount debug information generated compiler processed debugger real world programs 

symbolic debugging optimized code hennessy presents approach detect variables original source program current respect really happening optimized code 
dead store elimination example final store variable deleted compiler needed program variable non current point 
goes outline techniques values non current variables recovered 
recovery accomplished variables available calculate value non current variable 
benefit approach effect optimization hidden user 
words user queries debugger value variable happens non current recoverable debugger perform necessary calculations report result user variable current 

interactive source level debugging optimized programs zellweger chapters ph 
dissertation zellweger gives nice overview issues surrounding problems debugging optimized code 
covers optimizations cause problems expect debugger specific optimizations effects debugging previous attempts solve problems possible solution strategies 
main portion dissertation uses possible strategies enable real world debugger handle specific control flow optimizations procedure lining tail merging cross jumping shown 
procedure lining optimization body procedure grafted source location call procedure originally existed 
primary benefit optimization saves overhead calling returning procedure 
side course program larger 
tail merging optimization branches code may contain identical tails replaced jump remaining tail 
benefit optimization may save space possibly allowing program fit cache 
zellweger solution handling tail merging plays heavily go detail 
consider code fragment specific routine generic routine specific routine generic routine specific routine generic routine endif tail merging optimization object code resemble specific routine goto specific routine goto specific routine generic routine endif problem zellweger attacked maintain illusion lines map distinct blocks object code fact map code 
level original source problem 
level actual object code big problem literally block code enable debugger determine code executing behalf line 
words execution temporarily halted block code debugger unable report lines current line 
zellweger solution problem path determination 
examining source clear current location line control passed line current location line control passed line current location line control passed line 
said code lines path determining code identical object code executing behalf lines 
know path determining lines executed know merged lines apparently executed 
user asks debugger break region code transformed tail merging optimization debugger extra activity transparently 
hidden breakpoints set instruction path determiner merged region 
time hidden breakpoint hit time stamp global debugger variable incremented copied variable associated particular hidden breakpoint execution continues 
user breakpoint merged region hit time stamp values hidden breakpoints examined 
highest time stamp value recorded line requested user indicates executed execution halts debugger reports user breakpoint hit execution continues 
illustrate consider original source code 
assume user requests breakpoint line cause breakpoint instruction placed label 
object code time potential background activity indicated brackets specific routine break line val time stamp continue goto specific routine break line val time stamp continue goto specific routine break line val time stamp continue break due user requested breakpoint line val highest value hand control user ignore breakpoint continue generic routine endif zellweger solution activity triggered response user request 
brings major weakness solution acknowledges debugger gains control due unplanned activity exception path determination ordinarily active meaning debugger unable report source lines responsible problem 
calling path determination misnomer 
debugger telling user path taken code obtaining information limited region source order solve problem caused particular optimization 
significant part fact advocates essentially technique entire range program smaller portion user desires purpose reporting user path taken code 
go detail chapter 

recovery noncurrent variables source level debugging optimized code srivastava presents corrected improved version techniques hennessy 
addition techniques recover non current variables partial results available temporaries registers 

doc practical approach source level debugging globally optimized code coutant contains succinct explanation core problems debugging optimized code code location problem data value problem 
authors claim problems turn data value problems 
code moved eliminated main effect data values may user expects point execution program 
say instructions modify user data troublesome moved statement boundary 
code motion problems solved techniques data value problems 
optimizations primary targets global register allocation induction variable elimination instruction scheduling 
optimizations fairly standard instruction scheduling dealt specific target architecture 
purposes fill branch delay slots useful instructions avoid processor stalls memory accesses 
solution problems created optimizations depended primarily extension conventional data map encapsulated range data structure 
structure fields fields give low high value forming range instruction pointer values fields apply 
specify memory location register variable lives actual value variable location 
case occur case constant propagation example 
maintaining table maps variable name location function instruction pointer able track location variable changes program 
equally important able detect variable location inform user trying get set value variable 
instruction scheduling potential re ordering instructions regard statement boundaries original source 
case range data structure slightly different interpretation viewed range source lines user needs warned variable question early late update 
example assume user requests breakpoint statement containing variable assignment instruction scheduling moved assignment block code previous statement 
situation debugger able consult range information warn user variable assigned earlier original source indicated 
range idea important part thesis covered chapter 

source level debugging optimized code detecting unexpected data values master thesis describes method suggested possibility zellweger determine currency status variables reaching definitions 
portion 
find coverage field debugging optimized code excellent 

summary knowledge previous sought hide effects optimizations user designed issue warnings user request respect original source correspond running program 
attempted zellweger briefly mentioned possibility presentation user modified version source program accurately reflected underlying optimized program 
zellweger didn consider possibility showing original optimized view screen time 
current approaches am familiar assume user interact original source program 
chapter 
justification 
chapter overview vliw architectures code scheduling techniques vliw compilers 
cover special problems creates debugging earlier debugging optimized code inadequate handle special problems 

vliw architecture succinct definition vliw come multiflow architecture 
vliw computers fundamentally new class machine characterized single stream execution program counter control unit 
long instruction format providing control bits directly independently control action functional unit cycle 
large numbers data paths functional units control planned compile time 
bus arbiters queues hardware synchronization mechanisms cpu 

different architectures vliw processors distinct scalar processors instruction words composed operations targeted functional unit capable executing parallel functional units 
addition conventional code generation optimization techniques instruction scheduling performed attempt keep functional units busy possible preserving original source semantics 
vliw processors distinct super scalar processors multiple functional units scheduling resources handled statically 
super scalar processors hand manage resources run time means extra control logic 
course super scalar processors benefit static scheduling addition run time scheduling 

advantages advantage vliw architectures super scalar architectures hardware devoted synchronization issues 
puts extra burden compiler handle synchronization frees real estate chip faster functional units 

disadvantages disadvantage flip side advantage listed 
synchronization falls compiler handle means compiler complicated job ordinarily 
tend performance program dependent compiler compiler happens contain bugs increased complexity solution turning optimizations especially costly terms execution speed 
disadvantage potential large code size 
larger code size means fetches memory difficulty fitting cache possibly negates benefits vliw architecture 
result sections code little available parallelism fields instruction word nops said architectures allowing compact versions instructions nops take virtually space fetched 
added code size come scheduling techniques result code duplication creation 
trace scheduling example relies loop unrolling primary loop optimization 
relies creation new code compensate expected trace followed run time 

reason vliw architectures programs show parallelism source program level may fact degree parallelism machine level 
example statement involve calculation expression level fairly typical microcode require instruction fetch instruction decode operand fetches updating instruction pointer actual multiplication calculation address store result multiplication address depending actual machine involved steps conceivably happen parallel 
similarly fetch decode execution phases overlapped happen parallel 
main purpose vliw architectures exploit fine grained parallelism exists ordinary code greatest possible extent 

brief history josh fischer published ph dissertation concerning optimization horizontal microcode 
published introducing called trace scheduling targeted global microcode compaction 
proposed new architecture specifically designed trace scheduling mind 
architecture called vliw 
name vliw implies classification distinguished 
fact machines accurately described 
case terminology clear distinction 
purposes distinguish basic idea instruction word explicitly controls functional units 
floating point systems introduced fps term vliw created array processor attached host machine 
machine bit instruction word able control functional units 
single cycle perform addition multiplication data fetches code fetch computation address data code word branch instruction 
designed programmed hand 
published concerning design compiler fps computer able perform classical optimizations software pipelining loops contained straight line blocks code 
mentions compiler years 
eli project eli stands enormously long instruction yale started josh fischer meant project design compiler hardware fully explore vliw concepts 
proposed architecture bit instruction word actual hardware came effort 
multiflow computer announced commercially available machine described vliw 
called trace 
time announced trace scheduling compacting compiler 
direct outcome eli project yale 
trace architecture configured different instruction widths corresponding different hardware configurations bit word able initiate operations clock cycle bit word able initiate operations clock cycle 
interestingly multiflow designed machine general purpose computer processor scientific applications 
fact prominent mention unix ported machine 
warp systolic array came research effort carnegie mellon collaboration ge honeywell 
bit instruction word degree parallelism smallest trace configuration 
compiler warp relies software pipelining hierarchical reduction primary scheduling techniques 
lam dissertation mentions versions hardware 
collaboration carnegie mellon intel part produce single chip implementation architecture 
architecture outlined 
degree parallelism warp machine significantly smaller instruction word bits 
allowed second instruction format bits initiating single operation 
introduced 
essentially vliw machine additional hardware support overlapping loop iterations 
relies software pipelining techniques compiler take advantage special overlapped loop support 
bit instruction word capable controlling functional units 
intel introduced 
features warrant inclusion list 
dual instruction mode instructions executed time 
second special dual operation instructions manipulate adder multiplier pipelines simultaneously issued processor dual instruction mode 

instruction scheduling instruction scheduling means architectures capable overlapped execution pipelined multiple functional units kept busy possible 
similar respects problems inherent operating system design attempts find efficient utilization resources hand 
instruction scheduling scalar machines involves instruction re ordering 
recall scheduling machine mentioned doc intended fill branch delay slots avoid processor stalls memory accesses 
instruction scheduling vliw machines hand complicated 
compiler vliw machine re order operations pack operations single instructions hardware contains functional unit capable executing parallel 
example depending source code available hardware resources instruction scheduler may create single machine instructions contain code corresponding portions source lines different loop iterations 

compaction re ordering code compaction re ordering simplest kind instruction scheduling vliw architectures 
involve duplication creation additional code techniques 
effectively takes list operations comprising basic block arranges subject constraints original program semantics preserved second machine resources kept busy possible 

trace scheduling conditional branches ordinarily cause problems processors know ahead time path taken continue fetching executing path known 
processors get rearranging code put instruction branch delay slot safe execute matter branch taken 
limited fact may possible find suitable instruction 
branch exists scheduling resources continue new branch started 
trace scheduling takes different approach heuristic chooses path backwards branch possible treats entire path long basic block packs operations path instruction words 
compiler inserts compensation code branches compensate expected trace taken run time 
branches effectively removed yielding larger basic blocks fine grained parallelism exploited greater extent 
words compensation code scheduler free move operations boundary basic block 
trace scheduling assumption higher probability branch going direction 
fortunately case 
assumption certainly true loops branch back loop taken time iteration 
true error checking code error condition rarely occurs 
hand programs containing branches go direction equal probability going see benefit trace scheduling technique 
biggest disadvantages trace scheduling program execution follow trace originally predicted heuristic poorly chosen compacted code may perform poorly 
guard programmer add stage program development cycle 
program run realistic input check execution path taken run time 
data fed compiler fine tune branch predictions 
disadvantage significant code expansion 
reason compensation code necessary preserve program correctness 
problem primary technique loops unrolling followed scheduling 
effectively duplicates source lines loop bodies order achieve longer loop bodies longer basic blocks 

software pipelining software pipelining instruction scheduling technique applied loops 
observation iteration loop may start previous ones finished needed data previous iterations available require resources 
goal find best combination schedule single iteration initiation interval starting successive iterations 
ordinarily distinct portions software pipelined loop 
prolog iterations start 
essentially purpose filling software pipeline 
second steady state iterations start finish regular schedule 
loop spend time portion 
third epilog pipeline drained 
advantage software pipelining results relatively compact code size 
frequently results optimal schedule 
disadvantages may suitable loops having small body may suitable nested loops 

hierarchical reduction ordinarily simple statement prevent loop software pipelined 
certainly true software pipelining implemented compiler fps 
hierarchical reduction scheduling technique implemented lam companion software pipelining 
motivation enable loops conditional constructs software pipelined 
basic idea schedule program innermost constructs replacing construct single node scheduled surroundings 
process continued entire program reduced single node 

scheduling vliw architectures problem debugging debugging non optimized code simple characteristics code generated executes statement statement variables generally live location entire existence 
debugging optimized code big problem code longer characteristics 
debugging vliw code instruction scheduling larger problem 
instruction re ordering 
causes code different statements interleaved fashion 
regard vliw code worse typical optimized code bad 
addition instruction re ordering typically compaction phase operations packed single instruction word 
single instruction word contain code portions source lines 
transformations performed code order achieve higher performance 
take example software pipelining transform code way individual instructions contain code different loop iterations 
copies particular source line various stages execution time 
copies line execution time means copies variable existence time potentially different valid value 

want able debug code reasons wanting debug optimized code valid vliw code instruction scheduling 
reasons performance kinds machines main reason existence 
math library example exhibits bugs instruction scheduling feasible ship unoptimized unscheduled code performance may orders magnitude slower 
programmer able debug code final product 
code generation vliw machines complicated conventional machines likelihood compiler bugs increased 
compiler writers able debug source level programmers encounter compiler bugs able locate problem 
debugging assembly language level tedious conventional machines vliw machines worse 
chapter 
approach debugging vliw code instruction scheduling 
show effective debugging vliw code instruction scheduling achieved combination enhancements conventional code data debug information maps allow user expression oriented line statement oriented queries 
highlighting scheme plus modified source needed show current state computation 
way user informed graphically portions program executed 
re definition traditional debugger commands notion current location fuzzy presence instruction scheduling 

scope proposal am targeting proposal instruction scheduling techniques involve re ordering operations combined compaction operations long instruction words combined code duplication transformations loop unrolling software pipelining 
state proposal intended optimizations consider informally 
instruction scheduling techniques result creation code corresponds original source 
understanding possible trace scheduling technique 
example suppose trace scheduling compiler proceeds picked trace begun re arrange compact code trace 
operation moved trace position past conditional branch target called split trace position prior trace branch joins main trace called join compensation code consist simply copying operation trace branch executed matter branch taken run time 
code create significant problems debugging fact debugger deal object code sequences mapping source expression 
compiler moves operation trace position conditional branch compensation code potentially complicated 
undo operation event trace branch taken runtime 
problem creates debugging time operation completed happened time un done restore semantics program program semantically equivalent original 
am proposing solution techniques 

enhancements conventional debug information section want demonstrate effective debugging vliw code instruction scheduling requires code data maps sufficiently detailed able handle queries expression level opposed line statement level 
progression scenarios showing increasingly complicated instruction scheduling requires detail debug information maps 

conventional debug information code map non optimized code typically consisted mapping statement numbers blocks corresponding object code 
largely sufficient code code typically generated source statement basis really part contiguous block object code source statement 
consider source code fragment numbers left hand column line numbers int float return possible assembly language code numbers left hand column offsets code load load add store load fr load fr fr fr load fr fr fr store fr ret conventional code map appear follows line number instruction offset interpreted mean object code corresponding line example starts instruction offset continues instruction offset 
conventional data map appear follows name type location integer integer integer real ch real real interpreted mean variable listed type listed location statement boundaries 
example debugging session 
suppose user wants set breakpoint line typically interpreted mean break line executed 
event debugger consults code map finds instruction offset code line 
debugger saves original instruction replaces special breakpoint opcode starts execution 
breakpoint hit debugger returns original opcode location updates screen giving indication line 
indication typically consists highlighting source line manner 
point debugger wait user input 
input consist queries variable values example 
case debugger consults data map finds corresponding memory location retrieves value prints type 
event user wishes modify variable debugger finds location places desired value 
suppose debugging session division zero exception occurs instruction offset 
debugger consults code map discovers instruction offset object code belongs block code corresponding line source reports source line responsible error 
order determine cause problem user query debugger values program variable 
carry debugger consults data map retrieves values user wants prints 
simple scenario conventional debug maps may perfect 
happen occasions user gets control point statement begun executing completed 
example assume source statement consists operations 
exception occurs operations executed memory locations updated user queries debugger variable locations debugger retrieve print value variable previous statement boundary 
part debugging non optimized code straightforward simple maps 

re ordered code assume target architecture independent integer floating point units instruction scheduling performed 
possible result refer previous source fragment load fr load load fr load fr fr add store load fr fr fr store fr ret code longer executes statement statement basis debug information needs modified order avoid incorrect 
possible solution described doc 
associated statement marker instruction source statement 
event optimization phase moves instruction marker moved instruction block 
code effect having statement marker line associated instruction statement marker line associated instruction 
instructions come line marker treated belongs block code previous line 
perfect useful largely maintains illusion code executing statement statement basis 
code map incorporates modification 
line number instruction offset data map look 
essentially example described doc shows location variable function instruction pointer 
modification necessary re ordering code optimizations take away essential characteristic non optimized code memory locations variables date statement boundaries 
name type location ip range integer fr integer integer real fr real fr real fr part solution kind code 
typical debugger commands need re considered 
example mean tell debugger break line 
non optimized code unambiguous 
instructions re ordered statement boundaries interpreted ways 
mean break instruction belongs line instruction offset mean break instruction line line instruction offset 
note non optimized non re ordered code 
zellweger considered problem introduced terminology distinguish 
breakpoint placed instruction desired statement called semantic breakpoint placed instruction previous statement called syntactic breakpoint 
debugger kind code implement kinds breakpoints treat breakpoint requests kind 
doc debugger effect implemented breakpoint requests syntactic breakpoints 
solution bad debug information complicated non optimized useful 
perfect 
unsuspecting user confused discover setting breakpoint line resulted portion line executed 

code map re ordered compacted code assume vliw architecture multiple integer floating point units 
scenario described debug information insufficient 
order see assume start example re ordered code pack operations individual vliw instructions 
contrived example assume vliw word slots integer units branch type instructions second floating point units 
possible result number left column offset code load load load fr load fr add nop fr fr nop store nop nop nop nop nop load fr nop nop nop fr fr nop nop nop store fr nop ret code map previous section insufficient individual vliw instructions may contain code portions source lines 
sense inverse conventional code source statements map machine instructions 
sense map instructions list corresponding source expressions 
actual implementation corresponding source simply represented simple offset source file 
possible result instruction offset corresponding source expression load load load load add division assign load division assign return assuming division zero exception execution instruction offset map debugger highlight expressions entire source lines 
detail come architecture 
architecture available exception handler portion instruction caused exception debugger certainly pass information user 
additional changes need data map level instruction scheduling 
previously data map handle cases variables registers statement boundaries 

code map duplicated re ordered compacted code consider complication arises scheduling technique uses code duplication performed 
software pipelining loop unrolling followed code compaction examples 
slightly complex example derived 
chosen lends software pipelining 
notice line body loop line data dependence previous line loop iteration line loop body dependence previous iteration 
examples fortran 
subroutine micro real integer continue possible schedule iteration loop body 
taken liberties pseudo assembly language code attempt keep example clear 
example am allowing array assembly language instructions 
number left hand column instruction offset code 
load store load div store load add store load store software pipelining pseudo assembly code obtained 
previous example am quite liberties code attempt keep clear contains array 
real compiler presumably perform additional optimizations code 
example attempt take advantage values may available registers 
assume loop control registers initialized entry 
machine knows body loop runs offset 
notation exemplified instructions body loop meant indicate instruction execute values 
overlapped iterations instruction offset iteration continues iteration starts 
overlap increases steady state loop reached offset 
code continues steady state iterations loop various stages execution 
number left hand column instruction offset code load nop nop nop nop nop nop store nop nop nop load load nop nop div nop nop store store nop nop load load load nop add div nop store store store nop load load load load store add div nop store store store nop load load load nop store add div nop nop store store nop nop load load nop nop store add nop nop nop store nop nop nop load nop nop nop store nop nop nop nop modification propose code map handle situation compiler indicate debug information multiple copies source line execution 
achieved additional field compiler indicate relative iteration addition source expression machine instruction 
information debugger create user state program 
way code map constructed instruction offset corresponding source iteration comments line read overlap loop prolog line add line assign line read overlap line read line div line add line assign line assign line read overlap line read line read line add line div line add line assign line assign line assign line read overlap loop body line read line read line read line assign line add line div line add line assign line assign line assign line read overlap loop epilog line read line read line assign line add line div 
code map able deal complexity caused vliw architectures instruction scheduling code may rearranged compacted duplicated 

data map duplicated re ordered compacted code doc described useful approach tracking variable location changed course program execution 
unfortunately solution extend array 
order useful event aggressive code scheduling needs implemented instruction scheduling involves array loops 
recall case code duplication iterations loop various stages execution 
user wants know value equal example debugger able determine array elements corresponding different values may live different places 
possible solution straightforward extension original idea coutant individual array elements corresponding different values loop iteration variable result separate entries data map scalar 
data map page 
name type location ip range integer function loop control registers real register real register real register real register real register register real register register real register register real register real register register real register real register 

representing state computation interactive source level debuggers non optimized code am familiar similar look 
typically display windows variety information dominant feature usually window containing copy user source code particular source line highlighted 
highlighting meant indicate source line corresponding current instruction pointer 
words highlighted statement ordinarily execute 
setting breakpoint usually handled ways user type command command line break line method move cursor desired location hitting dedicated mouse keyboard button 
querying value particular variable handled similarly means explicit command pointing cursor hitting button 
represent user see debugging program source main func command 
source level debugger screen non optimized code user immediately know highlighted statement corresponds current instruction pointer 
due nature non optimized code user able determine great extent state computation statements executed 
turn gives user necessary information intelligent queries values program variables 
qualify previous statements somewhat existence conditional branches 
current location highlighted statement past kind branching statement difficult impossible determine branch taken encountered 
difficult means user determine value variable place condition tested infer branch taken 
impossible means value conditional test longer available 
may storage variable variable may value returned function directly conditional test 
sum user knows current location non optimized program user knows lot state computation 
contrast assumed state vliw program 
represents user see debugging session vliw code undergone instruction scheduling 
debugger highlighted expressions corresponding current vliw instruction source main func command 
source level debugger screen vliw code previous example user immediately know highlighted expressions correspond current value instruction pointer 
previous example user easy guesses statements executed user data control flow analysis fly 
sum user knows current location vliw program undergone instruction scheduling known 
rest thesis proposal remedy situation 
previous field debugging optimized code attempted convey user state computation approaches possible maintain illusion code optimized doing allow user infer current location state computation 
zellweger managed achieve procedure lining going far lined procedure appear call stack 
possible inform user appropriate means actual state program differs apparent non optimized state 
literature seen means printing message explain situation 
typified doc debugger allowed re ordering instructions statement boundaries 
instruction updated variable moved block code previous statement user requested breakpoint original statement debugger issue message effect variable early update 
propose different approach 
necessary debugger information described earlier chapter provided compiler create modified version source display side original explanation transformed source 
suggested possibility zellweger appeared overwhelm user 
purposes thesis am limiting consideration software pipelining loop unrolling examples necessary 
believe overwhelm 
second propose possibly modified source highlighted appropriately program runs indicate portions program executed 
take credit idea suggested course looking thesis topic 
way user kind information current state running program person debugging code 
represents possible implementation 
code example undergone loop unrolling followed instruction scheduling 
unrolled loop body shown right half screen 
dark highlighting indicates corresponding expression completed light highlighting indicates corresponding expression highlighting indicates expression touched 
original source modified source command 
improved source level debugger screen vliw code poses big problem debugger 
ordinarily debugger gain control breakpoints program exceptions 
supposed determine statements executed 
phrase way debugger indicate user state program debugger determine state computation 
propose raw data consisting portions program executed obtained program running path determination 
recall zellweger path determination means 
main goal show user path taken code goal unravel effects tail merging optimization debugging 
determining actual path taken tail merged region code means achieving 
proposal basic technique zellweger path determining breakpoints time stamps put different 
intent determine path taken code pass information user means highlighting possibly modified source appropriately 
think ways accomplished 
way requires additional compiler covered 
extra handled debugging session debugger debugging debugger maintains global variable initially zero incremented 
time stamp discussed 
code map received compiler create data structure collect path determiner information runtime 
fields addition ones provided compiler 
holding opcode path determining instruction 
holding value time stamp 
debugger scans entire program image memory builds control flow graph representation basic blocks 
path determining instructions located control flow graph 
predecessors target instructions predecessor need determine predecessor control passes run time 
path determining instructions copied slot code map 
breakpoint instructions copied path determining locations 
time stamp entries initialized zero 
debugger ready debugging session 
sequence events rough pseudo code repeat program exits user gets control execute program exits exception occurs 
debugger gets control due exception 
cause execution breakpoint opcode update screen described hand control user 
exception due execution breakpoint instruction debugger searches code map address instruction 
debugger checks see kind breakpoint path determining breakpoint update screen described hand control user 
path determining breakpoint increment time stamp copy new value code map 
copy real instruction location 
single step 
put breakpoint opcode back 
endif endif user gets control time update screen 
accomplished 
brute force approach sake simplicity 
code map data map control flow graph find expressions source corresponding current instruction highlight appropriately 
backwards current instruction instruction multiple predecessors encountered highlighting corresponding source expressions way 
follow path predecessor highest time stamp value 
event predecessor branch backwards loop follow path body loop touched 
continue far needed 
find variables expressions executed range include current instruction pointer highlight fashion 
give visible indication user variable available 
optionally highlight expressions corresponding instructions time stamp greater zero 
catch expressions executed point example previous iterations loop 
processing time stamps vicinity loop needs little explanation 
software pipelined loop result expressions executed iteration highlighted 
just needed 
case software pipelined loop copy source lines screen iteration overlapped 
really complicated 
starting place working backwards loop prolog value loop counter indicate copy lines modified source highlight 
starting place body loop loop steady state 
means purposes doesn matter time body loop time loop loop reached steady state 
treated time loop means just backwards loop entry backwards loop prolog highlighting appropriate 
efficient implementation take account number lines source displayed 
find corresponding range instructions give limit far back control flow graph go 
process expression screen highlighted fashion indicate possible states executed executed point past executed iteration loop time conditional branch furthermore variable screen highlighting indicate possible states touched expression executed value determined debugger expression executed value determined debugger illustrate ideas consider 
simplify example code map map source code directly control flow graph 
array code duplication scheduling involved 
function true printf endif 
source fragment control flow graph examining control flow graph see blocks multiple predecessors 
path determining breakpoints placed blocks 
time stamp entries path determining breakpoints initialized zero 
entries initialized special value indicating time stamps applicable 
user placed breakpoint line 
simplified code map appear just prior execution source line time stamp execution path determining breakpoint block hit single time block hit times 
processed described earlier user aware 
period execution user breakpoint hit leaving time stamp entries shown source line time stamp sequence actions part debugger highlight source refer expressions corresponding line highlighted indicate current location 
working backwards line highlighted 
continue backwards block 
line highlighted 
block predecessors 
highest time stamp backwards branch loop 
haven way follow 
event loop contains conditional branch cause branch taken iteration highlighted 
line highlighted 
continue backwards block 
line predecessors 
followed backwards branch time follow highest time stamp block 
line highlighted block predecessors 
highest time stamp block 
continue backwards block 
line highlighted 
continue backwards block 
line highlighted 
shows result activity control flow graph clarity 
highlighted source fragment displayed source window debugger 
function true printf endif 
source fragment highlighting control flow graph 
implementation typical debugger commands 
go til ordinary commands go til line need reconsidered 
frequently user wants computation computation may single expression source 
unfortunately instruction scheduling cause code source line intermixed code neighbors 
best solution believe expression line oriented commands 
words go til kinds commands implemented go til expression expression pointed means 
debugger consult code map find object code corresponding desired expression plant breakpoint 
breakpoint hit screen painted indicated previously show state program 

go non optimized code dangerous kind command implemented essentially simple change instruction pointer 
clearly may violate assumptions code generated contents critical registers 
user careful command yield useful results 
example skip particular source line re execute function different data change number iterations loop 
instruction scheduling true user exercise greater care 
smallest practical item skipped repeated individual machine instruction individual machine instructions may contain code source lines loop iterations additional complexity compared non optimized code possibly great 
ability highlight expressions source corresponding instruction pointer enable user exercise appropriate amount care 
example case debugger hands user rope hang 

get set value existing proposed debuggers optimized code attempt hide fact code optimized 
try give impression code executes statement statement basis 
example user led believe source lines preceding current executed completion succeeding ones touched 
user queries debugger variable apparently received value preceding statement fact debuggers tend rely possibly bewildering messages indicate fact 
range scheme plus highlighting scheme proposed achieves effect telling user variables available manner 

advantages main advantage user gets accurate indication exactly program executes getting buried avalanche messages 

disadvantages debugging session happens terms modified source may apparent translate knowledge back original source level terms fix bug 
words suppose user spends considerable amount time looking modified version source debugger 
comes time go back original source code changes necessary fix bug original source may look unfamiliar 
chapter 
examples 
extended example code map usage interpretation extended example meant illustrate ideas previous chapter applied real architecture scheduled code 
target architecture intel 
may strange choice instruction word large 
architecture embody idea having multiple execution units controlled single instructions essential element vliw architectures 
fairly wide 
importantly able portland group compiler able achieve software pipelining loops 

architectural overview programmer manual instructions grouped classes 
class consists called core instructions executed integer unit 
core instructions include integer arithmetic loads stores memory registers including floating point registers control transfer instructions 
second class instructions floating point graphics instructions executed corresponding functional units 
floating point instructions come scalar pipelined versions 
addition instructions manipulate floating point adder multiplier pipelines simultaneously yielding results clock cycle 
executed parallel instructions core unit 
notes reading code examples prefix indicates dual instruction mode floating point instruction issued parallel core instruction 
second half dual instruction indented second line 
instructions start pipelined floating point instructions 
actual instruction start calculation put result third previous pipelined addition 
instructions bla instruction execute branch delay slot 
processor dual instruction mode entire dual instruction mode instruction execute delay slot 
code includes instructions example instruction 
instruction manipulates adder multiplier pipelines simultaneously 
possible prefix dual operation instructions resulting dual operation instructions dual instruction mode dual operation instructions parallel core instructions 

code listings source code extended example 
notice line body loop dependent way previous line iteration loop dependent previous iteration 
added line numbers source instruction offsets code listings construct debug information maps 
define double main int abbreviated code listing produced compiler optimization specified 
full listing appendix lineno orh ha fst orh ha fst lineno adds st lineno ld db adds bnc lineno ld shl orh fld orh ha fld orh fadd dd fst lineno ld shl orh fld orh ha fld orh fmul dd fst lineno ld adds st lineno br db ld lineno loop iteration runs instruction offset instruction offset words clock cycles 
notice described chapter distinct block object code meaningful source line listing look lineno number examples 
means mapping source code object code straightforward 
manually constructed code map line number instruction offset notice lines involving calculations kind tend follow pattern 
look listing line example 
starts loads ors part mechanism getting bit addresses registers fadd floating point add fst floating point store 
pattern loading values registers performing calculation storing back memory 
statement boundary memory location corresponding variable date 
means mapping variable names locations simple 
manually constructed data map name type location integer stack offset array double memory array double memory actual value known run time simple maps needed debug non optimized code 
setting breakpoint line running breakpoint hit result display source define double main int command 
breakpoint hit line non optimized code user immediately know line previous lines executed completion line started 
regard querying debugger value program variables immediately obvious date assigned previous statements spurious value assigned 
consider code produced compiler highest optimization level 
includes optimizations performed compiler including software pipelining 
abbreviated listing full listing appendix added comments appropriate clarify code 
lineno orh ha fld contains constant orh ha fld contains constant orh orh contains address adds initialized lineno orh contains address fst initializes fst initializes adds adds bnc adds initialized dd initialized mov contains address mov contains address bla loop control 
manual dd lineno align dd starts dual instr 
mode nop pl dd starts plus nop db dd advances nop dd advances nop dd gets starts fst stores bla pl loop control dd advances nop pl entering body loop dd starts plus nop mm msm dd gets fst stores dd advances nop dd gets starts fst stores bla pl loop control dd advances delay slot nop pl dd gets fst stores bla pl loop control 
needed 
nop nop nop lineno case loop iteration runs instruction offset instruction offset clock cycles 
fully optimized version run close times faster non optimized 
manually constructed code map offset corresponding source iteration comments line assignment line assignment start line add loop prolog line start line mult 
start line add loop start line line start line mult 
conditional branch loop start delay slot loop line loop epilog main return caller manually constructed data map 
notice iteration variable expressed terms equation name type value ip range iteration constant register constant register integer expr array double register array element register array element register array element register array element register array double register preceding maps debugger gets compiler 
time debugger go 
thing build control flow graph representation program 
source code resulting control flow graph shown 

control flow graph numbers boxes refer instruction offsets object code listing 
apparent gaps sequence due instructions execute branch delay slot 
debugger finds path determining instructions 
example instruction offset predecessors offsets instruction offset predecessors offsets instruction offset predecessors offsets 
debugger takes information code map received compiler create means tracking execution path 
involves essence adding columns code map purpose handling breakpoints 
involves adding rows necessary handle path determining instructions entries 
debugger run time offset corresponding source iteration opcode comment line assignment line assignment conditional branch bnc start line add prolog line start line mult 
conditional branch loop start bla start line add loop start line line start line mult 
conditional branch loop start bla delay slot loop line epilog conditional branch bla main return caller shows user original source modified source main int command 
source view execution suppose user indicates multiplication line original source breakpoint 
code map indicates corresponds instructions offset 
debugger interprets request break instructions start multiplication 
user breakpoint installed offset execution begins 
path determining instruction offset hit 
transparently user debugger goes steps outlined previous chapter 
involves incrementing time stamp value copying entry instruction offset copying original instruction location single stepping putting breakpoint opcode back continuing execution 
time breakpoint offset hit 
time debugger process information order update screen user 
debugger starts instruction offset uses control flow graph backwards described previous chapter 
highlights expression variable source state started started finished 
shows user 
original source modified source main int command 
source view breakpoint hit line multiplication suppose user continues execution 
case path determining instruction offset hit 
debugger goes steps outlined previous chapter scenes 
involves incrementing time stamp value copying entry instruction offset copying original instruction location single stepping putting breakpoint opcode back continuing execution 
user breakpoint hit instruction offset 
updating source little interesting need go backwards code iterations 
debugger starts instruction offset uses control flow graph backwards instruction offset control flow graph known multiple predecessors 
debugger examines time stamps path determining instructions discovers execution passed instruction 
debugger continues path highlights expression variable source state started started finished 
shows user see point 
original source modified source main int command 
source view breakpoint line multiplication user continues execution breakpoint hit situation slightly complicated 
time instruction offset higher timestamp value offset 
body loop handled path instruction offset followed 
debugger proceed previous example explained 

lessons learned hypothetical examples previous chapters didn take account distinct instruction starting computation followed cycles instruction completed 
aware issue trying maintain ability debug statement level 
surprised see issue arise expression level code 
solution allow user specify breakpoint expression evaluated 
example showed machine instruction charged calculation original source 
originally envisioned stepping occur instruction level statement level 
presence instructions obvious relation source helpful 
stepping implemented executing expression boundary 

loop conditional branch ordinarily software pipelining limited loops containing straight line blocks code 
words function calls conditional statements loops 
lam devoted quite bit discussion hierarchical reduction 
technique scheduling proceeded innermost constructs 
construct scheduled treated just straight line block code respect scheduling surrounding construct 
enabled achieve software pipelining loops containing conditional branches example 
raises question proposal previous chapter deal situation 
sake simplicity code expressed high level language terms 
steady state loop runs offset 
recall example instructions iteration loop identical 
case iterations execution go branch statement iterations go branch 
complicates processing path determination doesn impossible 
solution maintain queue time stamps code body loop largest degree overlap iterations 
came time update screen debugger backwards code map control flow graph time go body loop layer execution represented time stamps 
way multiple copies loop body screen accurately reflect expressions executed previous iteration 
notion keeping track layer execution mentioned briefly zellweger believe require immense amount information 
chapter 
concluding remarks 
summary proposed effective debugging vliw code instruction scheduling achieved combination expression level debug information path determination highlighting source level debugger indicate state program 

strengths research believe approach strengths highlighting convey complex information regarding state program user 
solutions debugging optimized code rely messages user indicate state program 
mechanics underlying path determination screen highlighting straightforward certainly trivial implement 
hidden breakpoints debuggers purposes conditional breakpoints 
screen highlighting source level debuggers statement level 
focused instruction scheduling believe approach broad applicability conventional optimizations 
example code motion optimizations common subexpression elimination global register allocation fall right 

weaknesses weaknesses solution lines proposal require debug information non optimized code 
chapter showed going simple non optimized code debug information required vliw code software pipelining required order magnitude overhead processing debug information 
top greater amount matter finding right entry code map time hidden breakpoint hit 
didn consider means 
greater difficulty compiler generate debug information 
ordinarily compiler writers worry producing maintaining debug information code simple terms 
take getting 
comparison optimized code debugger relied informative messages indicate state program think highlighting scheme fare 
hand comparison non optimized code debugger user overwhelmed confronted sort advancing checkerboard pattern appear screen program advanced 
variable modification tricky 
example chapter showed machine cycles start computation 
ability modify program variables users non optimized code debugger take granted troublesome instruction pointer modification problem reasons previous point 

suggestions unanswered questions arose part debug information required comparison debugging optimized code solutions non optimized code 

mentioned possible ways achieve path determination 
investigation relative efficiencies various techniques useful 
difficult compiler produce information necessary 
different optimizations combinations optimizations handled 
bibliography aho sethi ullman compilers principles techniques tools addison wesley 
cohn gross lam tseng architecture compiler tradeoffs long instruction word microprocessor proceedings asplos iii pp 

nix donnell rodman vliw architecture trace scheduling compiler sigplan notices proceedings asplos ii pp 
october 
coutant doc practical approach debugging globally optimized code proceedings sigplan conference programming language design implementation pp 

hsu bratt overlapped loop support proceedings asplos iii pp 

ebcioglu design ideas vliw architecture software parallel processing proceedings ifip wg working conference parallel processing pp 
april 
ellis bulldog compiler vliw architectures mit press cambridge massachusetts 
fischer trace scheduling technique global microcode compaction transactions computers vol 
pp 
ieee july 
fischer long instruction word architectures eli proceedings th symposium computer architectures pp 
ieee june 
symbolic debug optimized code revision internal intel document february 
gibbons muchnick efficient instruction scheduling pipelined architecture sigplan notices vol 
pp 


hennessy symbolic debugging optimized code acm transactions programming languages systems vol 
pp 
july 
bit microprocessor programmer manual intel 
iyengar symbolic debugging optimized code white revision internal intel document october 
jones allan software pipelining vol 
pp 
november 
lam systolic array optimizing compiler phd thesis carnegie mellon university 
lam instruction scheduling superscalar architectures annu 
rev comput 
sci 

maier oregon graduate institute private communication 
pollock soffa high level debugging aid incremental optimizer proceedings annual hawaii international conferences systems sciences vol ii january 
warren debugging system compatible optimizing compiler ibm technical disclosure bulletin vol 
pp 
november 
symbolic debugging optimized programs internal intel document april 
srivastava recovery noncurrent variables source level debugging optimized code foundations software technology theoretical computer science sixth conference proceedings pp 

fortran compiler fps scientific computer sigplan notices vol 
pp 
june 
wall srivastava note hennessy symbolic debugging optimized code acm transactions programming languages systems vol 
pp 
january 
warren source change mode optimizing compilers ibm technical disclosure bulletin vol 
pp 
november 
warren design fds interactive debugging system ibm research report rc july 
weiss smith study scalar compilation techniques pipelined supercomputers acm transactions mathematical software vol 
pp 
september 
weiss scalar supercomputer architecture proceedings ieee vol 
pp 
december 
zellweger interactive high level debugger control flow optimized programs acm sigplan notices vol 
pp 
august zellweger interactive source level debugging optimized programs ph dissertation computer science division eecs university california berkeley ca johnson debugging optimized code expected behavior pre publication draft university illinois urbana champaign april 
appendix full code listing extended example chapter produced compiler lowest optimization level 
file rel opt text main align main rh stack stack lineno orh ha fst orh ha fst lineno adds st lineno ld db adds bnc lineno ld shl orh fld orh ha fld orh fadd dd fst lineno ld shl orh fld orh ha fld orh fmul dd fst lineno ld adds st lineno br db ld lineno lineno bri nop data align long long stack data comm comm full code listing extended example chapter produced compiler highest optimization level 
file rel opt text main align main orh stack stack st lineno orh ha fld contains constant orh ha fld contains constant orh orh contains address adds initialized lineno orh contains address fst initializes fst initializes adds adds bnc adds initialized dd initialized mov contains address mov contains address bla loop control 
manual dd lineno align dd starts dual instr 
mode nop pl dd starts plus nop db dd advances nop dd advances nop dd gets starts fst stores bla pl loop control dd advances nop pl entering body loop dd starts plus nop mm msm dd gets fst stores dd advances nop dd gets starts fst stores bla pl loop control dd advances delay slot nop pl dd gets fst stores bla pl loop control 
needed 
nop nop nop lineno lineno ld bri nop data align long long stack data comm comm author lyle edward cool born portland oregon february spent nearly eighteen years 
began lengthy college career fall 
spent unsuccessful terms university oregon received possible grade 
resumed college career months college washington 
graduated bachelor arts religion 
years jobs resumed college career time portland community college bachelor degree electrical engineering 
married carrie 
part time year full time years pcc accepted scholarship program involving years pcc university portland oregon graduate center 
summer junior senior years university portland offered summer position intel eagerly accepted 
position led subsequent full time summer employment employment school current position software engineer 
graduated cum laude bachelor science electrical engineering university portland may 
fall year began working master degree oregon graduate center 
challenging terms decided quit program pursue degree part time working full time intel 
intel willing go plan 
thomas born carrie lyle 
lyle completed time college career 
