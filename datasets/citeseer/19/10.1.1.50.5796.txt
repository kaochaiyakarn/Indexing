eoecient default reasoning ilkka niemel department computer science helsinki university technology fin espoo finland ilkka niemela hut fi decision method reiter default logic developed 
determine default theory extension formula extension default theory formula extension default theory 
method handles full propositional default logic 
implemented polynomial space theorem prover underlying propositional logic subroutine 
method divides default reasoning major subtasks search task examining alternative extensions solved backtracking search classical reasoning task implemented theorem prover underlying classical logic 
special emphasis search problem 
decision method employs new compact representation extensions reduces search space 
eoecient techniques pruning search space developed 
develop theorem proving method default logic reiter default logic known nonmonotonic logics marek truszczy ski body results indicating default logic captures large number dioeerent forms nonmonotonic reasoning 
default logic closely related logic programs deductive databases gelfond lifschitz connections established default logic autoepistemic logic mcdermott doyle style nonmonotonic modal logics konolige truszczy ski circumscription etherington diagnosis reiter abductive reasoning poole default logic knowledge represented default theory consists ordinary rst order formulae nonmonotonic inference rules default rules 
possible sets default theory de ned terms extensions default theory 
consider basic reasoning tasks extension existence default theory extension brave reasoning formula extension default theory cautious reasoning formula belongs extension default theory 
computational properties nonmonotonic reasoning received considerable attention 
research provides valuable basis developing nonmonotonic theorem proving techniques 
complexity propositional default reasoning located second level polynomial time hierarchy garey johnson extension existence brave reasoning sigma complete cautious reasoning pi complete gottlob means full propositional default logic implemented polynomial space strictly harder propositional reasoning polynomial time hierarchy collapses 
developing theorem proving techniques default logic nonmonotonic logics turned dioecult 
existing techniques quite straightforward little emphasis laid eoeciency considerations 
example approaches junker konolige risch baader hollunder automating default logic exponential space needed methods solving subtasks computationally harder original default reasoning task 
consider rst approaches reasoning problem default logic reduced problem truth maintenance problem junker konolige constraint satisfaction problem ben eliyahu dechter crucial feature reduction mappings classical deductions needed default reasoning encoded 
implies reductions computationally feasible restricted subclasses default logic 
typically reductions lead exponential increase problem size exponential number deductions encoded 
computing reduction mapping appears harder original default reasoning problem 
problem nding single deduction proof formula set formulae closely related logic abduction sigma complete eiter gottlob detailed discussion see niemel risch propose tableau method nding extensions 
approach suf problem exponential worst case space complexity 
baader hollunder approach generate extensions default theory pruning defaults top way 
eliminating defaults method uses heavily subroutine computing maximal consistent subsets sets sigma subroutine expected nd maximal subsets sigma consistent 
nding maximal subsets computationally expensive hard decision problems default logic 
example nding maximal subset containing formula closely related logic abduction 
see consider maximal subset sigma consistent gamma sigma consistent implies logical consequence sigma abductive explanation hypotheses background theory sigma 
develop decision method default logic handles important subclasses default reasoning full propositional case closed default rules decidable fragment underlying rst order logic problems exponential space requirements ii computationally dioecult subtasks part method 
basis taken decision method autoepistemic logic niemel approach satis es requirements 
autoepistemic logic default logic closely related konolige niemel approach directly applicable default logic 
room improvements 
take basic ideas niemel apply directly default logic order fully exploit special characteristics default reasoning 
organized follows 
section introduces default logic develops concise representation extensions 
representation ideas autoepistemic reasoning forms basis decision method 
section develops basic algorithm default reasoning 
provides framework integrating optimization techniques 
section presents optimizations basic algorithm section contains concluding remarks 
default logic going intuitions autoepistemic reasoning facilitate employ somewhat nonstandard notations default logic 
introduce new operator nb delta nb oe expresses formula oe oe belong extension question 
second write default rules new operator 
default rule expression form nb nb 
arbitrary rst order formulae 
just alternative notation default rule standard form delta delta delta bm default theory set default rules form 
reiter original presentation default theory contain ordinary rst order formulae addition default rules 
uniformity rst order formulae represented default rules rst order formula oe represented rule 
oe 
default rule form thought representing autoepistemic formula la delta delta delta lan lb delta delta delta lbm translation proposed truszczy ski extension default theory free part expansion translated theory niemel free part consistent expansion translated theory range nonmonotonic modal logics truszczy ski default rules form provide interesting form autoepistemic formulae 
give de nition extension default theory 
technically de nition somewhat dioeerent reiter leads class extensions 
de nition notions deductive closure nb formulae 
call nb formulae expressions form nb oe oe formula 
set formulae nb fnb oe oe sg 
gamma denote set formulae nb formulae example fa nb nb fag gamma fnb nb denote dcl sigma deductive closure set rules sigma form set formulae dcl sigma smallest set formulae contains closed sigma rst order derivations sigma fa 
nb nb 
sigma nb gamma example sigma fnb 

rg fp nb sigma 

rg dcl sigma th fp rg th denotes set rst order consequences set formulae means dcl sigma fp nb 
notice deductive closure monotonic operator respect premises dcl sigma dcl sigma 
set rules sigma set formulae delta called extension sigma ioe delta dcl sigma nb delta delta complement delta formulae delta 
develop compact characterizing condition extensions 
formulae occur inside nb delta operator play crucial role 
set rules sigma denote nant sigma negative antecedents sigma set formulae nb appears sigma 
example nant fnb 

rg fpg 
proposition role nant sigma evident 
observation deductive closure set rules nb formulae appearing rules importance dcl sigma nb delta dcl sigma nb nant sigma gamma delta 
proposition set rules sigma set formulae delta extension sigma ioe delta dcl sigma nb nant sigma gamma delta situation similar autoepistemic logic stable expansion uniquely determined modal subformulae premises niemel characterizing extensions able ideas full set characterization stable expansions niemel novelty exploit strong groundedness extensions implies ordinary formulae appearing antecedents rules prerequisites play role determining extensions nb formulae justi cations essential 
aim provide compact characterizing set extension 
characterizing sets called full sets sets nb formulae built formulae nant sigma 
de nition set rules sigma set called sigma full ioe condition holds oe nant sigma nb oe ioe oe dcl sigma 
example sigma fnb 
nb 
pg 
fnb sigma full dcl sigma fnb dcl sigma fnb sigma full dcl sigma 
turns full set extension extension corresponding full set 
theorem sigma set rules 
set sigma full dcl sigma extension sigma 
ii extension delta sigma nb nant sigma gamma delta sigma full set delta dcl sigma 
proof 
delta dcl sigma 
oe nant sigma gamma delta sigma full nb oe nb oe sigma full oe nant sigma gamma delta 
nb nant sigma gamma delta holds proposition implies dcl sigma extension sigma 
ii delta extension sigma 
proposition delta dcl sigma nb nant sigma gamma delta 
oe nant sigma 
oe dcl sigma oe delta nb oe oe dcl sigma oe delta nb oe sigma full 
theorem suggests straightforward method nding extensions 
subset nant sigma test nb sigma full 
full set dcl sigma extension sigma theorem theorem ii extension delta corresponding full set delta dcl sigma 
example straightforward method practical 
nb formulae sigma fullness tests needed single extension easily constructible set rules sigma shows 
sigma fa 
nb 

nb 
gamma 
nb 
gamma 
candidates sigma full sets sigma full set 
seen argument 
set dcl sigma implies dcl sigma 
nb belong sigma full set nb 
basic algorithm section develop basic algorithm solving default reasoning problems 
basic algorithm serves framework developing optimization methods discussed section 
algorithm ideas introduced niemel context autoepistemic reasoning 
algorithm function extensions dl skeleton decision procedures brave cautious reasoning checking existence extensions 
describing algorithm concepts 
set formulae nb formulae grounded set rules sigma dcl sigma gamma 
example fnb fb nb grounded fnb 

ag fag 
ii say set formulae agrees set formulae nb formulae formulae oe oe nb oe gamma oe example set fa bg agrees fa nb fa nb 
iii set formulae nb formulae covers formula oe oe nb oe example set fnb bg covers set formulae covered formula covered function extensions dl takes input set rules sigma sets determine common part extensions considered formula oe just passed argument function test 
aim extensions dl return true ioe extension delta sigma agreeing test delta oe returns true 
accomplished constructing sigma full sets agreeing full set corresponding extension delta dcl sigma test delta oe returns true 
represent partially constructed full set set contains nb formulae ordinary formulae 
nb formulae gamma formulae included partially constructed full set 
ordinary formula indicates corresponding nb formula nb included full set 
idea expand forms full set 
number possibilities reduced observing formula grounded rules sigma partially constructed full set gamma dcl sigma gamma nb included full set added set contains formulae nb excluded full set constructed included added groundedness condition satis ed dcl sigma gamma 
function extensions dl uses functions ffl expand expanding ffl conflict detecting ffl test testing extensions 
changing function test various decision procedures obtained 
rst functions minimal requirements implementations functions satisfy order guarantee soundness completeness decision procedures 
functions form crucial function extensions dl sigma oe expand sigma conflict sigma returns true return false nant sigma covered return test dcl sigma gamma oe return false endif take nant sigma covered extensions dl sigma fnb oe returns true return true return extensions dl sigma oe endif endif skeleton decision procedures default logic points algorithm optimization techniques applied 
section optimization methods developed 
rst introduce requirements functions expand conflict explain role guaranteeing correctness extensions dl function expand assumed ful ll conditions expand sigma 
grounded sigma grounded sigma 
extension delta sigma delta agrees delta agrees nant sigma dcl sigma gamma implies covered function conflict returns true false satis es conditions 
conflict sigma returns true nb dcl sigma gamma 
conflict sigma returns true exists extension delta sigma delta agrees function extensions dl starts expanding cautiously set order ensure correctness decision procedures insist expansion expand sigma extends way groundedness preserved extensions agreeing lost 
preserve completeness require formula nant sigma grounded covered included 
conaeict test performed 
case direct detected conaeict reported extension agreeing 
covers nb formula premises status frozen formulae examined 
included gamma full set 
corresponding extension dcl sigma gamma extensions dl returns test dcl sigma gamma oe returns 
nb formula nb premises covered belongs extension constructed 
alternatives handled backtracking 
extended nb assuming extension extensions dl sigma fnb oe returns false alternative examined frozen formula assuming extension 
extensions dl returns extensions dl sigma oe returns 
assuming functions expand conflict satisfy conditions proved induction number formulae nant sigma covered extensions dl sound returns true extension sigma agreeing function test returns true complete extension sigma agreeing test returns true extensions dl sigma oe returns true 
soundness completeness theorem 
theorem sigma set rules 
set formulae nb formulae set formulae grounded sigma 
extensions dl sigma oe returns true ioe exists extension delta sigma agrees test delta oe returns true 
theorem implies decision procedures dioeerent reasoning tasks obtained empty set common part extensions constructed ii choosing appropriate test function shown corollary 
corollary sigma set rules oe formula 

test delta oe returns true delta oe extensions dl sigma oe returns true ioe sigma extension 

test delta oe returns true ioe oe delta extensions dl sigma oe returns true ioe exists extension sigma containing oe 

test delta oe returns true ioe oe delta extensions dl sigma oe returns true ioe exists extension sigma containing oe words extensions dl sigma oe returns false ioe oe contained extension sigma 
illustrate conditions implementation expand conflict satisfying 
expand sigma return nant sigma covered dcl sigma gamma conflict sigma return true ioe exists nb dcl sigma gamma 
example minimal implementation taken directly minimal requirements resulting decision method quite powerful 
implementation decide brave reasoning 
test delta oe return true ioe oe delta 
consider set rules sigma example extension containing formula examine execution extensions dl sigma expand sigma returns fa false returned conflict sigma fa 
fa covers nant sigma fa fa sigma full set gamma corresponding extension dcl sigma 
test dcl sigma returns false extensions dl sigma returns false 
minimal implementation able determine sigma extension containing backtracking 
ii consider follows brave sense sigma fnb 
nb 

ag examine execution extensions dl sigma expand sigma returns conflict sigma returns false 
nant sigma fa bg covered choose order continue 
take extensions dl sigma fnb executed rst expand sigma fnb returns fnb bg 
conflict sigma fnb bg returns true dcl sigma fnb 
extensions dl sigma fnb returns false extensions dl sigma fag executed 
expand sigma fag returns conflict sigma fag returns false 
nant sigma covered fag choose order continue 
extensions dl sigma fnb fag executed expand sigma fnb fag returns fnb ag conflict sigma fnb ag fag returns false 
nant sigma covered fnb ag fag fnb ag extension dcl sigma gamma dcl sigma fnb sigma test dcl sigma fnb performed false returned 
extensions dl sigma fa bg executed 
expand sigma fa bg returns conflict sigma fa bg returns false 
nant sigma covered fnb ag fa bg extensions dl sigma fa bg returns false extensions dl sigma returns false 
extension sigma containing optimizations basic algorithm divides default reasoning major subtasks 
search problem examining alternatives full sets 
implemented chronological backtracking worst case algorithm search alternatives number dioeerent nb formulae premises 
classical reasoning problem deciding formula oe deductive closure set rules sigma formulae nb formulae premises oe dcl sigma holds 
membership deductive closure needed functions expand conflict 
dioecult tasks accordance results complexity default reasoning showing default reasoning complete problem respect second level polynomial time hierarchy gottlob result implies orthogonal sources complexity default reasoning 
suggests introduced additional sources computational complexity basic algorithm 
section optimization techniques lead eoecient methods solving subtasks 
quite lot research classical reasoning emphasis search problem 
moving couple remarks classical reasoning problem 
ffl notice classical reasoning problem reducible deciding logical consequence underlying rst order logic 
testing membership deductive closure set rules implemented tests logical consequence way 
construct set rules sigma 
apply rules sigma new rule res follows 
repeat fc 
sigma delta delta delta th resulting oe dcl sigma ioe oe th 
ffl second tests membership deductive closure regular pattern set premises gradually grows 
pattern exploited 
ffl third dealing large set rules important develop methods testing membership closure goal directed way relevant subset rules 
turn search problem 
potential search space exponential set rules dioeerent nb formulae size essential search space pruned 
extensions dl functions expand conflict handle pruning search space 
expanding function expand extends current common part full sets constructed 
formulae added fewer choice points backtracking left new formula included cuts remaining search space half 
implementation reduce search dramatically case example basic weakness detect formula extension 
optimized version implementation able detect simple case function expand sigma repeat foe nant sigma oe covered oe dcl sigma gamma fnb oe oe nant sigma oe covered oe dcl sigma nb nant sigma gamma return implementation expand 
sigma fa 
nb 
nb 
extension sigma nb included complicated situations covered 
example consider set rules example situation looking extension containing fag 
evident extension sigma contains nb deduced 
niemel technique determining formula extension 
attractive feature approach polynomial number logical consequence tests needed 
adopt technique idea 
upper bound formulae included extension sigma agreeing deductive closure sigma assuming excluded upper bound dcl sigma nb nant sigma gamma 
proposition shows formulae upper bound extension sigma agreeing proposition delta extension sigma agree delta 
oe delta implies oe dcl sigma nb nant sigma gamma 
proof 
oe delta 
proposition oe dcl sigma nb nant sigma gamma delta 
nant sigma gamma delta delta agrees nb nant sigma gamma delta nb nant sigma gamma implies oe dcl sigma nb nant sigma gamma 
new implementation expand including technique described 
implementation able handle complicated situations set rules sigma fag implementation returns fnb ag new set quite simple prove implementation expand satis es conditions 
critical point condition shown proposition 
proposition implementation expand satis es conditions 
detecting function conflict tries detect situations extension agreeing time conaeict part search space removed earlier conaeict detected larger part eliminated 
conaeict test implementation quite weak detecting 
consider set rules sigma fnb 

nb 
rg fnb fpg 
conaeict extension agreeing contains niemel conaeict test detects proposed 
idea exploit frozen formulae detecting 
idea exists nb oe oe dcl sigma conaeict conflict sigma return true 
strengthen conaeict test basis observation conaeict frozen formula oe belong extension premises agreeing consider set rules sigma fnb 
nb 
rg fp qg 
conaeict extension sigma agreeing contains kind detected aforementioned notion upper bound extensions 
implementation includes optimizations conaeict detection 
conflict sigma return true ioe nb oe oe dcl sigma oe oe dcl sigma nb nant sigma gamma 
proposition implementation conflict satis es conditions 
proof 
condition clearly satis ed dcl sigma gamma dcl sigma 
delta extension sigma agreeing show conflict sigma return true 
nb oe oe delta dcl sigma nb delta 
gamma nb delta dcl sigma dcl sigma nb delta 
delta dcl sigma nb delta dcl sigma nb delta 
nb oe implies oe dcl sigma 
oe oe delta proposition oe dcl sigma nb nant sigma gamma 
condition holds 
develop decision method default logic solves extension existence problem brave cautious reasoning problems 
handles full propositional case rst order subclasses default theories closed default rules decidable fragment underlying rst order logic 
method approaches junker konolige risch baader hollunder automating default logic major respects propositional case implemented polynomial space ii rely solutions subtasks appear computationally harder original default reasoning problem 
method partitions default reasoning major subtasks search problem examining alternative extensions solved backtracking search classical reasoning task implemented theorem prover underlying classical logic 
special emphasis search problem 
method employs new compact characterization extensions considering justi cations rules 
reduces search space alternatives extensions 
techniques pruning search space developed 
initial experiments indicate implementations expand conflict search space kept relatively small able handle default theories default rules 
method developed closely related niemel autoepistemic reasoning 
key dioeerence novel method uses new compact characterization extensions leads smaller initial search space 
exploit strong groundedness default extensions implies extensions determined justi cations default rules earlier approach niemel prerequisites justi cations default rules employed characterization 
optimization techniques prune search space discussed niemel technique expanding set proposed niemel conaeict detection method novel 
interesting areas research 
decision method uses heavily classical reasoning pruning search space 
implies development eoecient theorem proving techniques implementing needed classical reasoning goaldirected way important 
potential search space large needed developing new pruning techniques 
basic algorithm requirements functions expand conflict framework developing kinds optimizations 
decision method goal directed manner initializing sets accordingly 
example interested extensions containing start method fnb fpg 
interesting topic research develop goal directed techniques default reasoning task analyzed divided appropriate subtasks 
method heuristic choice new formula nant sigma covered selected 
area study development eoecient search heuristics 
baader hollunder baader hollunder 
embedding defaults terminological knowledge representation formalisms 
proceedings rd international conference principles knowledge representation reasoning pages cambridge ma usa october 
morgan kaufmann publishers 
ben eliyahu dechter ben eliyahu dechter 
default logic propositional logic constraints 
proceedings th national conference arti cial intelligence pages 
mit press july 
eiter gottlob eiter gottlob 
complexity logic abduction 
technical report cd tr christian doppler labor institut informationssysteme technische universit wien vienna austria july 
etherington etherington 
relating default logic circumscription 
proceedings th international joint conference arti cial intelligence pages milan italy august 
morgan kaufmann publishers 
garey johnson garey johnson 
computers intractability 
freeman san francisco 
gelfond lifschitz gelfond lifschitz 
logic programs classical negation 
proceedings th international conference logic programming pages jerusalem israel june 
mit press 
gottlob gottlob 
complexity results nonmonotonic logics 
journal logic computation june 
junker konolige junker konolige 
computing extensions autoepistemic default logics truth maintenance system 
proceedings th national conference arti cial intelligence pages boston ma usa july 
mit press 
konolige konolige 
relation default autoepistemic logic 
arti cial intelligence 
marek truszczy ski marek truszczy ski 
nonmonotonic logic contextdependent reasoning 
springer verlag berlin 
niemel niemel 
automatic autoepistemic reasoning 
proceedings european workshop logics arti cial intelligence jelia pages amsterdam netherlands september 
springer verlag 
niemel niemel 
unifying framework nonmonotonic reasoning 
proceedings th european conference arti cial intelligence pages vienna austria august 
john wiley 
niemel niemel 
decision method nonmonotonic reasoning autoepistemic reasoning 
proceedings th international conference principles knowledge representation reasoning pages bonn germany may 
morgan kaufmann publishers 
poole poole 
logical framework default reasoning 
arti cial intelligence 
reiter reiter 
logic default reasoning 
arti cial intelligence 
reiter reiter 
theory diagnosis rst principles 
arti cial intelligence 
risch risch 
tableau characterization theorem proving default logic 
journal automated reasoning 
truszczy ski truszczy ski 
embedding default logic modal nonmonotonic logics 
proceedings st international workshop logic programming non monotonic reasoning pages washington usa july 
mit press 
