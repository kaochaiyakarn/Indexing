program mobile robots scheme jonathan rees bruce donald computer science robotics vision laboratory cornell university ithaca ny implemented software environment permits small mobile robot programmed scheme programming language 
environment supports incremental modifications running programs interactive debugging distributed read evaluate print loop 
ensure programming environment consumes minimum robot scarce board resources separates essential board run time system development environment runs separate workstation 
development environment takes advantage workstation large address space user environment 
fully robot operate autonomously desired retrospective analysis robot behavior 
concurrent applications easier write run time library provides multitasking synchronization primitives 
tasks light weight tasks run address space 
programming environment designed particular mobile robot architecture mind principle applicable embedded systems 
lisp family programming languages long history basis rapid prototyping complex systems experimentation new programming paradigms 
polymorphism higher order procedures automatic memory management describes research done computer science robotics vision laboratory cornell university 
support robotics research provided part national science foundation 
iri iri presidential young investigator award bruce donald part air force office sponsored research mathematical sciences institute intel bell laboratories 
ity functional programming style aid development concise reliable programs 
promote application scheme dialect lisp programming mobile robot system limited resources high level language features integrated programming environment 
example gives flavor scheme system 
procedure sonar accumulate takes arguments initial state procedure combines previous state sonar reading obtain new state 
combination procedure called twelve sonar transducers supplied transducer number sensed distance 
returned value final state 
define sonar accumulate combine init loop val init val rs read sonars loop combine cdr rs combine car rs val implementation control abstraction hides fact sonar hardware allows particular transducer pairs read simultaneously 
sonar accumulate determine transducer giving smallest reading define nearest sonar sonar accumulate lambda dist previous 
dist cdr previous cons dist previous cons infinity structured follows sections describe hardware software architecture tommy mobile robot 
robot scheme implementation 
section briefly presents facilities available programmer scheme ordinarily provides 
section discusses relative success design ways different 
section describes 
appendix gives extended example 
hardware particular hardware targeted project cornell mobile robot built real world interface wheel base figures 
robot roughly cylindrical cm tall cm diameter 
enclosure contains rack mounted processor boards 
robot architecture distributed modular different sensors effectors easily added removed 
interprocessor communications serial lines 
low level handled cornell generic controller general purpose control board intel processor 
high level task control planning performed scheme programs running shelf motorola processor board mpl 
board mbyte ram mbyte mc single board computer cornell generic controller front panel speech rwi wheel base bus sonar bumper switches ir proximity detectors communications tether hardware architecture 
scheme currently uses board memory 
entire robot powered batteries wheel base 
robot draws amps idle moving 
scheme communication sensors effectors accomplished messages transmitted received cornell generic controller serial line 
relays messages various devices 
principle scheme communicate directly devices sonar prefer load device control richer capabilities 
features architecture relevant scheme ffl small physical size cm circuit board means small memory size compared workstation 
ffl low power consumption means slow processor mhz board ma 
ffl low bandwidth communications workstation 
part hardware development system workstation capable running scheme common lisp implementation text editor currently sun sparcstation similar workstation 
workstation communicates scheme robot serial line tether 
kind wireless communication nice concerned robustness dropout maintain option running autonomously 
scheme run time library scheme virtual machine byte code interpreter monitor user control program emacs graphics byte code compiler debugger scheme common lisp workstation user macros tether software architecture 
scheme system architecture scheme system consists run time environment resides robot development environment resides separate workstation 
communicate serial line 
summarizes major software components scheme system 
run time environment run time environment builds scheme virtual machine architecture 
virtual machine byte code stack oriented closely resembling target machine scheme compiler similar spirit 
vm handles memory management allocation instructions cons cause garbage collections 
virtual machine implemented interpreter garbage collector written compiled virtual machine consumes kbytes 
vm instructions corresponding scheme procedures read char write char 
instructions executed traps simple supervisor mode monitor 
access appropriate sonar control registers requires small amount virtual machine support 
scheme monitor operating system runs 
virtual machine executes user code software communication development system 
communications software standard run time library see section reside byte codes user programs downloaded workstation tether 
development environment programmer scheme system interacts development environment runs scheme implementation workstation 
scheme workstation currently running lucid common lisp mit scheme various scheme implementations 
run scheme workstation lucid mit scheme preferable speed sport optimizing native code compilers integration software workstation including existing packages graphics planning computational geometry spatial reasoning 
development environment mbyte executable image usually runs control gnu emacs 
includes command loop accepts scheme expressions evaluate commands control environment various ways load source file reset run time system development system translates scheme source code byte code instruction stream transmitted serial line scheme run time system 
development system performs preprocessing possible user code sending code run time system 
compilation process includes symbol table lookups variable names tables need reside robot 
error messages come back run time system interpreted relative symbol tables resident development system 
result policy board overhead kept minimum 
run time library includes communications software standard scheme library procedures append string number extensions described kbytes byte codes data 
tether connected possible user program robot call procedures workstation vice versa 
example program running robot initiate graphics routines display output workstation monitor 
run time library standard scheme procedures vector ref scheme comes equipped proce support sensor effector control multitasking remote procedure call 
controlling sensors effectors run time library contains set procedures obtaining information sensors issuing commands effectors 
example read sonar reads sonar unit number translate relative instructs wheel base initiate mm forward motion 
low level various devices different units coordinate systems library converts consistent units scheme programs 
sensor effector control mediated 
run time library contains routines written scheme communicate serial line 
operations consist single message exchange 
access serial lines sonar hardware synchronized prevent conflicts threads perform different operations concurrently 
lightweight threads multitasking useful writing programs simultaneously manage different input output devices sensors effectors case robot 
scheme environment supports light weight threads library routine spawn 
argument spawn procedure arguments 
call spawn returns immediately new thread started concurrently execute call procedure 
threads run address space threads may communicate writing reading shared variables data structures 
example may convenient integrator running continuously thread define loop current odometry read set 
current configuration integrate configuration current configuration set 
current odometry sleep interval loop spawn loop threads may consult integrator estimation current configuration simply consulting value current configuration 
variable assignments fact virtual machine instructions atomic particular variable yield consistent configuration triple 
implementation threads written entirely scheme level virtual machine 
possible easy existence scheme call current continuation primitive virtual machine implements efficiently 
see elegant presentation technique building operating system kernel 
thread switching uses low level continuation mechanism call current continuation interact dynamic wind described appendix 
threads ordinary scheme objects special status virtual machine garbage collected longer accessible 
currently runnable threads course accessible 
synchronization provided lock operations similar lucid common lisp lock creates new lock lock lock thunk calls thunk obtaining control lock blocking thread currently holds lock 
lock released normal exceptional return call thunk 
second form synchronization condition variables single assignment storage locations 
condition variable created condvar assigned condvar ref set condvar set 
condvar ref precedes condition variable condvar set 
blocks thread performs condvar set 
remote procedure call scheme system supports simple remote procedure call capability 
tether attached procedure may call procedure workstation vice versa 
address spaces shared mechanism transparent supported procedures host procedure procedure 

define plan path host procedure plan path 
plan path destination 
defines procedure plan path robot called initiates rpc procedure name residing host 
desirable say plan path slow large run robot 
displaying graphical output rpc robot workstation 
similarly scheme program workstation may call procedures robot procedure 
example robot sensor effector routines easily accessed workstation define read procedure read 
read 
multiple threads host robot may perform remote procedure calls concurrently 
discussion thesis combination high level language rapid turnaround changes allows experiments robot unit time 
claims software engineering difficult test objective way 
think turn true apparently true lisp scheme applied domains 
new programming robots lisp 
knowledge implementation unique providing advanced board lisp environment small robot 
implement scheme 
exist cross debuggers ways suited developing embedded systems 
ffl prefer scheme high level features polymorphism automatic memory management higher order procedures allow concise reliable programs 
ffl neutral syntax powerful macro code manipulation facilities scheme lisp historically base experimentation special purpose languages 
ffl conventional architecture programming environment requires compiling entire modules linking entire program time change program 
compiled programs sent serial line turnaround time changes unacceptably slow alternative putting compiler linker robot robot large 
possible choice general purpose robot programming language ml concurrent ml 
scheme sense educational background students researchers robot 
scheme system existed project started suited cross development adapting existing ml implementation 
real time constraints 
languages garbage collection traditionally suffered delays seconds memory reclaimed 
take approach live short delays 
essential tasks require garbage collection delays run separate processors run garbage collectors programmed 
fact memory fixed size means put upper bound amount time taken garbage collection limiting amount live data limit frequency garbage collection get absolute time bounds specific tasks run scheme programs allocate memory 
current garbage collector garbage collection full heap requires half second 
slow believe time improved tuning code switching generational collector 
choice synchronization primitives merely conventional necessarily final 
set really sufficient include easy way wait multiple events 
experimented concurrent ml primitives programs difficult debug 
construct easy implement scheme virtual machine probably inappropriate context purpose exploiting parallelism programming embedded systems 
special purpose robot control languages see review considered safer hedge bets putting effort building uncommitted general purpose infrastructure 
members cornell robotics vision laboratory scheme system prototyping variety navigation planning manipulation systems 
particular intend mobile robot testing mathematical theory sensing planning 
scheme system continues exercised opportunities improve programming infrastructure continue arise 
communications software needs robust debugging aids including trace package inspector need implemented 
imminent arrival additional robots running scheme raise interesting issues developing control programs collaboration 
possible single host environment coordinated debugging multiple robot systems 
experiment compare various programming language constructs paradigms describing robot control systems 
scheme ideal medium 
particular interest subsumption architecture alfa 
performance may problem 
interpreter virtual instruction set times slower equivalent code compiled target hardware 
interpreter turns bottleneck ll consider scheme compiler existing scheme mit scheme new 
advantages doing weighed effect lower density native code relative virtual instruction set 
important consideration current memory limitations 
acknowledgments drawing illustration 
craig becker russell brown jim jennings making robot hardware software fruitful discussions architecture scheme implementation 
norman adams richard kelsey comments draft 
richard kelsey coauthor jonathan rees scheme 
appreciate help getting scheme run robot 
virtual machine cross compiled software developed supported free software foundation 
availability source code great help making cross development environment 
harold abelson gerald jay sussman 
lisp language stratified design 
byte february pages 
rodney brooks 
robust layered control system mobile robot 
ieee ra 
william clinger jonathan rees editors 
revised report algorithmic language scheme 
lisp pointers acm 
william clinger 
scheme compiler exercise denotational semantics 
conference record acm symposium lisp functional programming pages 
mike dixon 
embedded computation semantics programs 
phd thesis stanford university 
bruce donald jim jennings 
constructive recognizability task directed robot programming 
proceedings ieee international conference robotics automation 
erann gat 
alfa language programming reactive robotics control systems 
proceedings ieee international conference robotics automation pages 
adele goldberg david robson 
smalltalk language implementation 
addisonwesley 
robert halstead 
multilisp language concurrent symbolic computation 
acm transactions programming languages systems october 
jim jennings 
modular software hardware robot construction 
unpublished manuscript 
leslie pack kaelbling stanley rosenstein 
action planning embedded agents 
designing autonomous agents theory practice biology engineering back mit press 
richard kelsey jonathan rees 
scheme progress report 
manuscript preparation 
henry lieberman carl hewitt 
real time garbage collector lifetimes objects 
communications acm 
jonathan rees 
scheme common lisp translator 
manuscript preparation 
john reppy 
cml higher order concurrent language 
proceedings sigplan conference programming language design implementation pages 
mitchell wand 
continuation multiprocessing 
conference record lisp conference pages 
lisp conference box redwood ca 
proceedings reprinted acm 
appendix appendix gives extended example robot programming scheme illustrating threads higher order procedures 
heel simple loop causes robot follow front 
rest example consists guarded servo loop modulates pulse width commanded translation rotation motors 
define heel kill motors exit lambda loop read sonar read sonar translate min target distance rotate 
sleep heel delay loop define heel delay round second define target distance kill motors exit uses dynamic wind ensure exceptional exit turn motors 
dynamic wind run time procedure scheme dialects analogous common lisp unwind protect 
arguments entry thunk body thunk exit thunk procedures arguments 
ordinarily invoked order value delivered body thunk returned 
exit thunk called exceptional exits precisely invocations externally created continuations call body thunk entry thunk called exceptional re entry unusual situation possible call current continuation 
define kill motors exit thunk dynamic wind lambda thunk lambda translate rotate servo loop higher order procedure passed particular odometer motor control constants returning procedure control motor 
control procedure produced servo loop called target velocity guard returns guard predicate returns true 
guard procedure passed current odometer reading estimated velocity power level commanded motor 
friction amount power applied order overcome static friction drag amount power required increase velocity mm sec hysteresis time required power increase unit full effect velocity 
define servo loop odometer apply power friction drag hysteresis lambda velocity guard dynamic wind lambda lambda loop odometer time pw 
velocity friction friction update time apply power pw time odometer round second guard pw 
update loop pw update velocity drag loop pw round abs hysteresis lambda apply power concurrent servo loop combinator takes synchronous servo loop returns procedure spawn server loop run asynchronously 
logic tricky servo loop running terminated new start 
define concurrent servo loop synchronous loop lock lock condvar condvar 
condvar set 
condvar idle lambda velocity guard lock lock lambda set 

condvar ref condvar set 
condvar condvar spawn lambda dynamic wind lambda set 

lambda synchronous loop velocity conjoin lambda power 
guard lambda condvar set 
condvar done constants determined experiment 
define translate concurrent servo loop servo loop translate apply translate power static friction drag hysteresis define translate dist target translate dist dist translate usual speed conjoin position guard target bumper guard impediment guard translate usual speed conjoin position guard target impediment guard define usual speed define translate translate lambda ignore define rotate concurrent servo loop servo loop rotate apply rotate power static friction drag hysteresis rotate rotate similar translate translate 
guard going past position 
define position guard pred value lambda power pred value arrived guard trying go impediment 
define impediment guard power 
abs power impediment power impediment define impediment power ca 
watts guard hitting things bumper 
define bumper guard power 
read bumpers bumper combine set guards single guard 
define conjoin guard guards null 
guards guard apply conjoin guards lambda args apply guard args apply args define apply translate power power translate power power pulse width power define apply rotate power power rotate power power pulse width power define power pulse width power pw round power battery voltage 
abs pw pulse width limit pw error commanded power high power define pulse width limit 
