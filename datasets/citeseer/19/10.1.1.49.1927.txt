monitor classification peter buhr michel dept computer science university waterloo waterloo ontario canada michael eds research development tower drive st floor troy michigan natural elegant efficient mechanisms synchronization communication especially systems shared memory monitor 
past years kinds monitors proposed implemented modern programming languages provide form monitor concurrency control 
presents taxonomy monitors encompasses extant monitors suggests literature existing programming languages 
discusses semantics performance various kinds monitors suggested taxonomy discusses programming techniques suitable 
categories subject descriptors programming techniques concurrent programming pro gramming languages language constructs features concurrent programming structures control structures operating systems process management concurrency mutual exclusion scheduling synchronization performance simulation logics meanings programs studies program constructs control primitives general terms algorithms languages performance additional key words phrases monitors classification modern software systems consist collections cooperating tasks 
systems mechanisms arranging exclusive access resources synchronizing communicating tasks needed 
mechanisms proposed including semaphores dijkstra path expressions campbell habermann various forms message passing cheriton gentleman cheriton natural elegant efficient mechanisms synchronization communication especially systems shared memory monitor 
monitors proposed brinch hansen described extended hoare programming languages example concurrent pascal brinch hansen mesa mitchell modula wirth turing holt cordy modula cardelli news gosling emerald raj buhr provide monitors explicit language constructs 
addition software entities operating system kernels device drivers monitor structure may lower level primitives semaphores locks simulate monitors 
monitors important concurrency control mechanism continue foreseeable 
different kinds monitors proposed implemented comparisons various kinds monitors published 
howard developed proof rules kinds monitors showed simulate 
andrews schneider classify monitors blocking nonblocking describe programming techniques appropriate 
andrews gives far complete comparison date discusses kinds monitors howard classification outlines proof equivalent sense simulate discusses programming techniques appropriate 
extends previous classification comparison ways 
develop taxonomy monitors includes extant monitors uncovers new ones 
second systematically compare various kinds monitors standpoint programmer 
developing proof rules kind monitor comparing complexity proof rules assessing difficulty fulfilling proof obligations 
full complete simplified monitor proof rules discussed 
investigate performance various monitors determine significant performance differences 
fl acm acm computing surveys march 
claims kind monitor efficient rest aware previous study attempted measure empirically differences performance various kinds monitors 
essence taxonomy produced monitors surveyed survey covers theoretical objective subjective aspects monitors 
believe interest designers implementors programming languages concurrent systems 
informed judgment kind monitor provide language concurrent system designers need detailed comparison possible choices 
differences expressive power efficiency considered 
believe interest educators taxonomy explains differences monitors simple systematic way 
general knowledge concurrency issues assumed discussion 
addition familiarity hoare style axiomatic semantics sequential programs assumed 
background monitors tasks ensure exclusive access resources synchronizing communicating tasks 
monitor consists set data items set routines called entry routines operate data items 
monitor data items represent resource shared multiple tasks 
resource represent shared hardware component disk drive shared software component linked list file 
general monitor data manipulated set operations defined entry routines exception read variable 
mutual exclusion enforced tasks monitor task time execute monitor entry routine 
task termed active task 
mutual exclusion enforced locking monitor execution entry routine begins unlocking active task voluntarily gives control monitor 
task invokes entry routine monitor locked task blocked monitor unlocked 
general monitors structured class concept dahl allows direct association entry routines shared data manipulate 
structure allows entry routine calls serve main point mutual exclusion established monitor data 
monitors appear languages object generators objects 
term monitor refers monitor object 
main difference object monitor mutual exclusion enforced execution object routines monitor entry routines 
monitor task interaction interaction indirect monitor created independently tasks tasks interact 
contrast direct interaction tasks synchronize communicate directly called rendezvous 
tasks communicate monitor passing arguments entry routine parameters 
approach ensures communication type safe data transferred type checked 
group tasks uses monitor mediate communication data passed indirectly monitor data items 
distributed case calls entry routines monitor remote procedure calls 
communication tasks monitors requires creation potentially large number passive monitor objects properly managed user system 
monitors best serialize access passive objects resources objects data structures files thread execution 
explicit synchronization purposes mutual exclusion provided automatically monitors needed 
necessary synchronize tasks monitor 
purpose monitors provide condition variables called event queues associated operations signal wait 
condition variable thought queue waiting tasks 
join queue active task monitor executes wait statement 
example task executes statement wait task blocked condition variable monitor unlocked allows task monitor 
task reactivated condition variable active task executes signal statement example signal define int front back location front back queue int count number elements queue int queue queue integers condition notempty condition int query void return count mutual exclusion void insert int elem count buffer full queue back elem insert element buffer back back count notempty inform tasks buffer empty int remove void int elem count notempty buffer empty elem queue front remove element buffer front front count inform tasks buffer full return elem bounded buffer explicit signal effect signal statement remove task specified condition variable task exists ready run 
question signalling task signalled task runs discussed shortly 
condition variables lists blocked tasks associated monitor implemented various data structures queues giving fifo scheduling 
gives priority task waiting longest condition 
possibility assign priority waiting task hoare wait signal operations condition variables monitor similar operations counting semaphores 
wait statement block task execution signal statement cause task unblocked 
differences 
task executes operation necessarily block semaphore counter may greater zero 
contrast task executes wait statement blocks 
task executes operation semaphore unblocks task waiting semaphore task unblock increments semaphore counter 
contrast task executes signal statement task unblock effect condition variable 
difference semaphores monitors tasks resume execution delay 
contrast tasks execute mutual exclusion monitor tasks condition variable restarted monitor unlocked 
programming monitors common associate condition variable assertion state monitor 
example bounded buffer condition variable associated assertion buffer full 
waiting condition variable correspond waiting condition satisfied buffer full 
correspondingly active task signal condition variable buffer full 
association assertion condition variable usually implicit part language 
illustrates monitor bounded buffer explicit synchronization 
exact syntactic details section define int front back location front back queue int count number elements queue int queue queue integers int query void return count mutual exclusion insert int elem count buffer full queue back elem insert element buffer back back count int remove void int elem count buffer empty elem queue front remove element buffer front front count return elem bounded buffer implicit signal implicit synchronization alternative condition variables monitor synchronization specify associated assertions directly 
automatic signal monitors proposed hoare eliminate condition variables signal statements modifying wait statement conditional expression wait conditional expression conditional expression false task blocks monitor unlocked 
waiting task unblocked implicitly expression waiting true 
programming language edison hansen hansen hansen designed brinch hansen automatic signal monitors 
automatic signalling accomplished arranging waiting tasks wake repeatedly round robin order check conditions 
lead large amount overhead tasks remain blocked long periods felt little consequence microprocessor system hansen page implementation automatic signalling discussed section 
illustrates monitor bounded buffer implicit synchronization 
monitor scheduling monitor task thread control 
monitor routines executed thread calling task 
state monitor including locked determines calling task may may continue execution 
monitor scheduling occurs monitor unlocked 
monitor unlocked task executes wait signal statement returns monitor entry routine 
monitor unlocked task monitor chosen number queues internal monitor 
shows general form monitor set tasks waiting monitor 
calling task finds monitor locked added entry queue enters monitor locks 
task executes wait statement blocked added specific condition queue monitor unlocked 
task executes signal statement blocked added signaller queue task signalled moved specified condition queue waiting queue monitor unlocked 
condition condition waiting queue signaller queue entry queue exit monitor variables active task waiting task processes waiting monitor case automatic signal monitor condition queues queue needed manage tasks false conditional expressions chose put tasks false conditional expressions waiting queue waiting task effectively eligible run monitor unlocked conditional expression 
monitor unlocked obvious task execute task entry waiting signaller queues 
depending kind monitor particular choice 
tasks wait monitor unlocked 
selection done implicitly task resume execution monitor direct user control 
monitor synchronization operation may cause monitor unlock selection task execute depends kind monitor 
main difference monitors algorithm implicit monitor scheduler select task execute monitor unlocked 
monitor classification section presents taxonomy monitors encompasses extant monitors suggests literature existing programming languages 
initially monitors divided groups signal operation explicit implicit broad categories additional sub categories developed semantics signal operation 
explicit signal monitors explicit signal monitor monitor explicit signal statement contrast automatic signal monitor signal statement 
kinds explicit signal monitors literature categorized classification scheme classification scheme exhaustive case analysis scheduling possibilities internal monitor queues entry waiting signaller queues monitor unlocked 
different kinds monitors classified relative priorities associated queues 
queue specific priority referred entry priority waiting priority signaller priority respectively 
relative orderings priorities yields different possibilities table 
case priorities equal 
gamma delta cases exactly priorities equal equal pair greater third priority gamma delta theta cases 

cases priorities different 
right column table shows traditional explicit signal monitors fall categorization scheme 
point clarification traditional monitor names 
names right column come howard classification 
andrews schneider andrews pp 
term signal continue describe howard wait notify monitor 
queue priorities confused task priorities monitor scheduler confused operating system task scheduler 
queue priorities fixed monitor scheduler uses queue priorities arbitrate tasks particular monitor 
task priorities variable scheduler arbitrate tasks system wide basis 
relative priority traditional monitor name wait notify lampson redell signal wait howard signal continue howard signal urgent wait hoare rejected rejected rejected rejected rejected rejected rejected table relative priorities internal monitor queues cases reject cases reasons 
consider cases entry queue highest priority cases table 
monitors signalled signaller task resume execution calling tasks 
property creates potential unbounded wait signalled signaller tasks inhibits concurrency preventing signalled signaller tasks getting monitor continuing execution 
example large number tasks calling monitor wait signal soon large number tasks blocked conditions inside monitor number tasks accomplishing useful correspondingly diminish 
problem occurs entry queue priority waiting queue signaller queue cases table 
entry queue priority waiting queue signalled task resumes signaller calling tasks creates potential unbounded wait signalled tasks continuous stream tasks calling monitor 
calling tasks priority signaller tasks signaller task resumes signalled calling tasks property creates potential unbounded wait signaller tasks continuous stream tasks calling monitor 
allowing entry queue priority greater internal queues significant disadvantages compensating advantages eliminated discussion 
cases table examined 
queues equal priority scheduler chooses arbitrarily 
encourages style programming signals hints lampson redell nelson approach task may signal condition true signalled task responsible checking true 
cautious approach concurrency control signalled signaller tasks assumptions order execution monitor 
immediate return monitors brinch hansen hoare discuss restricted monitor signal statement permitted return monitor entry routine 
call kind monitor immediate return monitor 
semantics immediate return signal signaller signalled tasks continue execution 
task active monitor tasks leave monitor immediately case signaller 
monitor allow task signal condition execute code signal essence signal statement acts return statement entry routine 
kind monitor suggested observed monitor programs signal statements immediately return statements brinch hansen immediate return monitors significantly expressive explicit signal monitors 
fact pointed howard andrews monitor programs written ordinary explicit signal monitors written immediate return monitors interface monitor changed 
howard proposed extended immediate return monitor allows signal immediately precede wait case signaller leave monitor 
signaller moves task condition variable signal waiting queue blocks condition variable wait unlocks monitor 
extended immediate return monitor general explicit signal monitors see section 
monitor categorization scheme applicable immediate return extended immediate return monitors signaller queue signaller task leaves monitor immediately put condition queue 
active task calling signalled task 
table shows possibilities 
case entry queue priority internal queue rejected 
relative priority traditional monitor name signal return brinch hansen rejected table relative priorities extended immediate return monitor automatic signal monitors automatic signal monitor provides wait statement form wait conditional expression 
kinds variables allowed conditional expression classify kind monitor 
monitor variables local variables monitor routine may appear conditional expression monitor called general automatic signal monitor 
monitor variables allowed conditional expression monitor called restricted automatic signal monitor 
general automatic signal monitor unlocked finding task execute expensive worst case involves re evaluating conditional expressions waiting tasks 
conditional expression potentially depend local variables task including formal parameters monitor entry routine local context task accessed evaluate conditional expression 
simplest way accomplish awaken tasks waiting queue time re evaluate conditional expression 
task evaluates condition finds condition true proceeds blocks waiting queue allows task try 
problem approach context switches may occur task proceed 
alternative implementation waiting task copy global data area local context necessary evaluate conditional expression provide pointer code conditional expression build closure point wait statement language supports closures 
data linked possibly attaching waiting queue accessed waiting task 
task check tasks execute invoking conditional expressions evaluates true list reached 
creating necessary data closure plus link field searching evaluating list complicated runtime expensive 
aware implementation takes approach 
implementation simpler described time takes find task execute determined number waiting tasks cost re evaluating conditional expressions 
restricted automatic signal monitors efficient implementation 
variables conditional expressions monitor variables depend context individual tasks conditional expressions evaluated efficiently task unlock monitor 
efficiency improved noting conditional expressions represent distinct conditions tasks waiting condition need evaluated 
proposed notation restricts conditional expressions monitor variables allows programmer specify conditional expressions represent distinct conditions 
notation moves conditional expressions wait statement monitor declarations gives name names wait statement expression example monitor var 
var monitor variables allowed expression proc 
wait wait conditional expression true monitor variables allowed conditional expression time takes find task execute determined cost re evaluating conditional expressions 
compared general automatic signal monitors potential significant execution time saving determining task execute 
drawback local entry routine information including formal parameters conditional expression restricted automatic signal wait 
drawback similar restriction ada parameters accept statement clause control accepting callers 
monitor categorization scheme applicable automatic signal monitors condition queues signaller queue 
monitor unlocked active task calling task task waiting queue waiting conditional expression evaluate true 
table shows possibilities 
case entry queue priority internal queue rejected 
relative priority traditional monitor name automatic signal hoare rejected table relative priorities automatic signal monitor simplified classification remaining useful monitors organized lines see table 
monitors divided groups priority entry queue 
division useful priority calling tasks equal signaller tasks signalled tasks may writing monitor complex 
complexity discussed sections 
groups called priority priority monitors priority monitors tasks entered monitor priority calling tasks monitors 
priority aspect monitor discussed howard andrews monitor analysis importance crucial property highly ignored explanation monitor semantic behaviour 
groups possible pair monitors aspects signal statement 
signal wait signal urgent wait monitors signaller task blocks signaller queue signalled task re enters monitor 
contrast signal continue wait notify monitors signaller task continues execution monitor signalled tasks re enter monitor monitor unlocked 
monitors table give priority signaller signalled tasks signalling task may may block 
monitors called quasi blocking 
automatic signal extended immediate return monitors form pairs 
organization easier remember understand different kinds monitors 
new names italics suggested re organization reflect categorization scheme 
notice new kinds monitors identified classification scheme 
formal semantics monitor classification section operational semantics 
experience programmers find approach easy understand 
purposes especially programming language definition formal implementation biased description preferable 
section gives hoare style signal characteristics priority priority signal urgent wait signal wait blocking priority blocking pb priority blocking npb signal continue wait notify non blocking priority non blocking pnb priority non blocking quasi blocking priority quasi blocking priority quasi blocking extended signal return immediate return priority immediate return priority immediate return automatic signal automatic signal priority automatic signal pas priority automatic signal table useful monitors proof rules monitor types described section discusses differences 
cases simplified proof rules may preferable purposes 
reason examine proof rules complexity semantics language construct related albeit somewhat loosely ease construct 
comparing axioms various kinds monitors provides indication difficult various kinds monitors 
proof methodology limitations 
assume program correctness depend specific queuing discipline fifo 
experience correctness programs usually depend specific queuing discipline choice queuing discipline may substantially affect performance 
readers writer solution section relies fifo queuing avoid problem stale readers exception 
issues termination liveness timing dealt explicitly history variables step counters precluded 
notation section assumed reader familiar standard axiomatic semantics sequential programs 
general axiomatic semantics recommend gries symbol denotes denotes implies denotes logical equivalence 
substitution predicate denoted bracketed boolean condition jqj denotes condition true 
signaller queue denoted waiting queue denoted entry queue denoted set condition variables denoted set includes condition queues signaller waiting queues 
length queue denoted jqj 
queue lengths automatically updated scheduler 
assume variables jqj condition variables jsj jwj read modified monitor 
queue lengths directly available easy arrange keep track explicitly incrementing decrementing variables 
assume length entry queue available 
purposes developing proof rules tasks waiting queue classified condition queues came 
sub queue tasks came condition queue denoted equation holds jwj jw qj default quantifications range set condition queues shorthand proof rules monitors standard hoare style proof rules sequential programs 
additional rules added monitor primitives enter signal wait return 
proof rules primitives predicates important 
predicates similar howard ffl predicate monitor invariant hold task locks unlocks monitor 
ffl predicate hold task waited condition awakened ffl predicate hold task awakened entry queue ffl predicate hold task awakened signaller queue 
predicates useful proving external internal properties monitors 
external property property visible clients monitor changing external property cause client programs malfunction 
internal property property affect correctness client programs 
monitor implements solution readers writer problem example external property mutual exclusion enforced 
example internal property read access unnecessarily delayed number active writers zero 
property rules example trivial solution readers writer problem concurrency readers allowed 
proof rules monitors authors proof rules various kinds monitors hoare howard howard intent compare various scheduling disciplines developed methodology deriving proof rules directly operational description scheduler 
main advantage method proof rules obtained various kinds monitors expressed terms predicates described section 
possible compare proof rules various kinds monitors consistent fashion 
step decompose monitor primitives signal wait return primitive operations 
signal statement decomposed signal jqj deque jqj skip fi self schedule signal operation atomic indicated angle brackets 
deque primitive removes arbitrary task appropriate queue returns 
primitive takes task parameter puts task appropriate queue 
read variable self active task 
schedule statement chooses task execute different monitors different schedulers 
guarded form alternation statement standard statement precludes nondeterminism 
capability important signal needed definition schedule 
wait statement decomposed wait self schedule return statement decomposed return schedule exit definition deque precondition deque precondition deque precondition details schedule statement depend kind monitor consideration 
schedule statement priority quasi blocking monitor fairly typical follows jsj deque jw deque jw deque jsj jwj deque fi statement guards simultaneously true case scheduler chooses eligible tasks nondeterministically 
deque primitives simple proof rules length queues actual content important 
possible simplification queuing discipline ignored 
effect queue lengths primitive equivalent statement jqj jqj similarly effect queue lengths deque equivalent jqj jqj gamma schedulers ensure deque executed empty queue 
substitutions reduce proof rules signal wait known proof rules alternation assignment 
substitutions weakest pre condition scheduler computed 
example obtain weakest pre condition priority quasi blocking scheduler expanded form jsj fi sg deque jw fi deque jw fi qn deque jsj jwj fi deque fi substitute appropriate assignments deque operations jsj fi sg jsj jsj gamma jw fi jw jw gamma jw fi qn jw jw gamma jsj jwj fi skip fi assignment dropped effect lengths queues 
standard techniques calculate weakest precondition scheduler 
case weakest precondition quite complicated jsj jw rj jsj jwj simplifies fi jsj jw rj jsj jwj weakest pre condition scheduler easy backward obtain weakest pre condition signal wait 
example wait equivalent self schedule effect lengths queues turn equivalent jqj jqj schedule weakest precondition wait fi jsj jw rj jsj jwj jqj jqj weakest precondition signal obtained similar fashion 
post conditions working forward scheduler 
strongest post condition signal strongest post condition deque scheduler exactly point signaller awakens 
priority quasi blocking monitor strongest post condition signal fi jw rj jsj jsj similarly strongest post condition wait strongest post condition deque fi jw rj jsj jw qj jw qj strongest postcondition enter strongest postcondition deque fi jsj jwj postcondition return false control reaches point return 
sections give proof rules kind useful monitor 
derivations proof rules kind monitor follow directly definition schedule priority blocking monitor npb proof rules priority blocking monitor follows ftrueg enter fi jsj fi jsj jqj gamma jqj jsj jqj jqj jsj jqj gamma jqj jsj jqj jqj jsj jqj gamma jqj jsj jqj signal fi jsj jsj fi jsj jqj jqj wait fi fi jsj return recall jqj jqj 
scheduling points scheduler chooses task jwj positive 
scheduler chooses task signaller queue entry queue queues contain tasks scheduler chooses nondeterministically 
effect queues coalesced 
implementation npb monitor combines queues 
initially jwj 
jwj incremented signal scheduler immediately decrements 
signal atomic implies length zero observable state 
variable jw qj useful dropped proof rules 
implementation takes advantage fact eliminating queue 
chief difficulty programming kind monitor predicates involving proven numerous places order conclude signal 
taken jsj proof rules simplify ftrueg enter fi fi jqj gamma jqj jqj jqj jqj gamma jqj jqj jqj jqj gamma jqj jqj signal fi fi jqj jqj wait fi fi return eliminate fundamental problem monitor unconstrained state signaller awakens 
experience incorrect signal chief source difficulty kind monitor programmers naturally think signals nonblocking unwarranted assumptions monitor state signaller awakens 
priority blocking pb proof rules priority blocking monitor follows ftrueg enter fi jsj fi jsj jqj gamma jqj jsj jqj jqj jsj jqj gamma jqj jsj jqj jqj jsj jqj gamma jqj jsj jqj signal fi sg jsj jsj fi jsj jsj jqj jqj wait fi fi jsj jsj return scheduling points priority blocking monitor hoare monitor chooses task jwj jsj variable jw qj appear proof rules reason previous section 
considerable discussion precise semantics monitor 
hoare original contains operational axiomatic description 
clear operational description especially implementation semaphores hoare intended signalling empty condition variable allowed intended waiting signallers execute new tasks entry queue 
hoare proof rules equivalent fig wait fi fi signal fig notation strong prove facts monitors features howard adams black howard strengthened proof rules hoare monitor address second point waiting signallers execute new tasks address signalling empty condition variable forbidden 
adams black propose stronger proof rules allow signalling empty condition variables 
unfortunately contained mistake applicability howard proof rules howard adams black priority blocking monitor suffers difficulties priority blocking monitor monitor relatively unconstrained state signaller awakens great deal activity may take place signaller resumes execution 
priority blocking monitor axioms proof obligations simplified setting ignoring jsj results simpler proof rules ftrueg enter fi fi jqj gamma jqj jqj jqj jqj gamma jqj jqj jqj jqj gamma jqj jqj signal fi fi jqj jqj wait fi fi return weakening proof rules setting true disregarding length assuming signal executed empty hoare original proof rules signal wait obtained 
priority nonblocking axioms priority nonblocking monitor follows ftrueg enter fi jw rj fi sg jqj gamma jqj jw qj jqj jqj jw qj signal fi sg fi jw rj jqj jqj wait fi jw rj jw qj jw qj fi jw rj return proof rules signal simplified noting signal transfers control task need meet particular precondition signalling 
leads simple proof rule signal fag jqj gamma jqj jw qj jqj jqj jw qj signal fag arbitrary predicate 
implementation takes advantage fact eliminating queue 
proof rules simplified setting true disregarding variables jqj jw qj resulting extremely simple rules ftrueg enter fig fag signal fag fig wait ig fig return may oversimplification important predicates lost 
way wait statement embedded loop wait od postcondition established regardless precondition 
coding style corresponds signals hints see section 
simplified semantics essentially ones adopted modula modula nelson point worth noting lengths queues eliminated implementation free awaken task signal 
implementation condition variables modula modula takes advantage occasionally sake efficiency awakens tasks cardelli nelson blocking monitors axiom wait simple expense complicating axiom signal 
nonblocking monitors transfer control deferred signaller unlocks monitor making axiom signal simple drawback complicated predicate proven task unlocks monitor 
experience chief practical difficulty nonblocking monitors programmers fail cope fact transfer control immediate 
example common error write monitor entry routine signals condition variable predicate satisfied negate predicate monitor 
addition priority nonblocking monitor new tasks entering monitor ensure falsify predicates expected tasks possible signal condition false ensure true monitor practice lead programs correct extremely difficult understand 
priority nonblocking pnb axioms priority nonblocking monitor follows ftrueg enter fi jwj fi sg jqj gamma jqj jw qj jqj jqj jw qj signal fi sg fi jw rj jwj jqj jqj wait fi jw rj jw qj jw qj fi jw rj jwj monitor signal results transfer control proof rule signal simplified fag jqj gamma jqj jw qj jqj jqj jw qj signal fag arbitrary predicate priority nonblocking monitor rules simplified setting true condition variables yielding simpler proof rules 
drastic way simplify proof rules priority nonblocking monitors signal statement disciplined way adopting rules ffl empty condition variables signalled ffl time pending signal ffl signal executed prior cleaning unlocking monitor 
words signal ways fi jqj gamma jw qj jw qj signal fi cleanup fi wait fi jqj gamma jw qj jw qj signal fi cleanup fi return cleanup fragment code leaves invariant 
discipline priority nonblocking monitor treated somewhat priority blocking monitor control passed directly signaller waiting task 
important differences 
rules signaller clean transferring control signalled task possible priority blocking monitor 
linear code capability useful cosmetic sense signal placed cleanup 
signal occur nested subroutine calls cleanup happening calls complete 
second important difference rule signalling task exits monitor signalled task enters contrast signaller priority blocking monitor waits signaller queue signalled tasks unlock monitor 
priority blocking monitor signaller blocked just prior executing return inhibits concurrency 
priority quasi blocking axioms priority quasi blocking monitor follows ftrueg enter fi jw rj jsj fi jw rj jsj jqj gamma jqj jw qj jqj jsj jqj jw qj signal fi jw rj jsj jsj fi jsj jw rj jqj jqj wait fi jw rj jsj jw qj jw qj fi jsj jw rj return predicates appear conjunction independent value folded simplifies proof rules somewhat ftrueg enter fi jw rj jsj fi jw rj jsj jqj gamma jqj jw qj jqj jsj jqj jw qj signal fi jw rj jsj jsj fi jsj jw rj jqj jqj wait fi jw rj jsj jw qj jw qj fi jsj jw rj return rules remain complicated 
quasi blocking monitors discussed section 
priority quasi blocking axioms priority quasi blocking monitor follows ftrueg enter fi jsj jwj fi jw rj jsj jqj gamma jqj jw qj jqj jsj jqj jw qj signal fi jw rj jsj jsj fi jsj jw rj jwj jsj jqj jqj wait fi jw rj jsj jw qj jw qj fi jsj jw rj jwj jsj return quasi blocking monitors priority priority complex proof rules 
practice complexity predicates prohibitive set true 
yields proof rules trivial ftrueg enter fig fig signal fig fig wait fig fig return corresponds signals hints wait statements embedded loops establish predicates 
advantage quasi blocking monitors scheduler allowed maximal freedom choose ready tasks semantics quasi blocking monitors interfere scheduling considerations task priority 
usefulness approach demonstrated fact operating system kernels essentially priority quasi blocking monitors monitor entry points system calls device interrupts 
operating systems variant priority scheduling choose ready tasks 
extended immediate return priority priority extended immediate return monitors proof rules identical priority nonblocking monitors respectively merely restricted forms monitors 
priority general automatic signal monitors automatic signal monitors signal statement signalling done implicitly tasks execute wait return 
predicate variable jsj appears proofs automatic signal monitors 
proof rules priority automatic signal monitor follows ftrueg enter fi fi wait fi fi return appears conjunction independent value generally folded yields extremely simple proof rules ftrueg enter fig fig wait fi fig return priority general automatic signal monitor pas proof rules priority version automatic signal monitor follows ftrueg enter fi jw fi wait fi fi return note jw means number tasks waiting proof rules considerably complex priority version automatic signal monitor 
additional complexity warranted priority version little additional expressive power priority version 
setting true dropping conjunct postcondition enter yields extremely simple proof rules 
may course performance reasons choosing priority version 
priority restricted automatic signal monitors proof rules priority restricted automatic signal monitor follows ftrueg enter fi fi jqj jqj wait fi fi return appears conjunction independent value generally folded signalling automatic variable jqj little value usually ignored 
considerations yield extremely simple proof rules ftrueg enter fig fig wait fi fig return priority restricted automatic signal monitors proof rules priority restricted automatic signal monitor follows ftrueg enter fi fi jqj jqj wait fi fi return practice predicate usually dropped jqj ignored yielding simplified proof rules priority automatic signal monitor 
wait conditions restricted automatic signal monitors depend local variables parameters monitor entries wait condition evaluated task 
restricted automatic signal monitor efficient general version 
restricted automatic signal monitors compromise general automatic signal monitors easy inefficient explicit signal monitors efficient difficult 
inability local entry routine information conditional expression precludes simple solutions certain kinds important problems certain disk schedulers 
monitor equivalence monitors equivalent weak sense monitor program written kind monitor implemented kind monitor 
way demonstrate weak equivalence note kind monitor implemented semaphores turn implement semaphores 
monitor program kind monitor mechanically translated program kind monitor compiling monitor program code synchronizes semaphore operations kind monitor implement semaphore operations 
transformation unsatisfying yields lower level program original 
kind weak equivalence language features called turing tar pit howard interested transformations preserve basic structure monitor program 
particular transformations introduce new types change monitor interface structure 
transformations amenable language translators converting kind monitor language different kind monitor language 
addition examining transformations different kinds monitors provides insight various kinds monitors achieve certain effects 
simplest program transformation identity transformation 
scheduling disciplines refinements 
scheduling point signal wait return monitor choose nondeterministically task execute 
say scheduler refinement scheduler scheduling point scheduler chooses task valid choice example priority blocking scheduler refinement priority quasi blocking scheduler priority blocking scheduler chooses task chosen priority quasi blocking scheduler 
practical effect scheduler refinement correct program written particular scheduling discipline mind correct scheduling discipline changed refinement original scheduler 
see sufficient note state refined monitor enters possible state monitor refined refined monitor enters erroneous state monitor refined done 
pointed section question termination explicitly considered 
transformations introduce liveness problems 
solid arrows monitor kinds indicate scheduler refinement 
scheduler refinement transitive property possible follow arrows refined schedulers modifying monitor program 
example program written priority quasi blocking scheduler works modification priority blocking priority nonblocking scheduler 
pas npb pb pnb refinement relationships monitor schedulers 
solid arrows indicate scheduler refinement dashed arrows indicate code refinement 
pas npb pb pnb transformations monitors 
dotted arrows represent non identity transformations 
addition identity transformations result refining scheduler additional identity transformations arise placing restrictions program code 
extended immediate return monitors restricted versions nonblocking monitors restricted automatic signal monitors restricted versions general automatic signal monitors 
program written priority extended immediate return monitor works modification priority nonblocking monitor 
dashed arrows indicate code refinement 
cases refinement relationship hold schedulers monitor programs modified correctly 
modifications done maintaining program structure 
demonstrate necessary show monitor programs written scheduler transformed execute correctly scheduler 
illustrates strategy accomplishing 
identity transformations shown solid dashed arrows 
dotted arrows represent non identity transformations 
kind monitor reached path directed graph monitor program transformed valid program kind monitor 
sections demonstrate transformations represented dotted arrows exist 
pas pb transformation relatively straightforward possible evaluate wait condition monitor entry task unlocks monitor code inserted check wait conditions signal task condition true 
strategy howard address problem waiting conditions evaluated monitor entries transformation works restricted automatic signal monitors 
transform general pas monitors explicit signals simplest approach task check wait condition 
unfortunately involves repeatedly waking waiting tasks pas operation pb operation inserted condition true enter enter wait signal wait skip fi od return signal return transforming general pas monitor pb monitor 
check conditions inefficient process 
contains details transformation 
condition variable block waiting tasks 
task unlocks monitor signalled 
task turn checks condition proceeds condition holds signals task waits 
signallers blocked signaller queue signalling stops empty point tasks awaken signaller queue wait pb transformation illustrates difficulty controlling task execution order precisely monitors 
idea transformation simple follow signal wait explicit signaller queue signal explicit signaller queue monitor 
complexity transformation shown due fact necessary record done doing 
necessary introduce variables record virtual length number signals pending condition variable 
variables updated explicitly signal wait executed 
condition pb monitor variable hqi introduced represent virtual length occurrences jqj pb monitor replaced hqi monitor 
similarly hw qi represents number tasks virtually waiting signalled 
condition introduced delay signallers condition delay entering tasks 
signalling task waits condition signals pending hwi 
variable hsi represents virtual length signaller queue including tasks blocked substituted variable jsj original program 
task enters monitor waits condition signaller queue empty hsi pending signals condition queue hwi 
proof rules pb monitor mention jw qj transformed versions original predicates mention hw qi 
note substitutions predicates mentions variables jqj jw qj queue simulate priority quasi blocking monitor priority extended immediate return monitor wait inserted signal signalling task leave monitor 
extra condition variable introduced block signallers 
condition variable signalled immediately wait return 
contains details transformation 
pnb monitor explicit signals explicit condition variables variable hw qi introduced simulate signals 
uses jw qj pnb proof outline changed hw qi wait translated waiting hw qi positive 
addition new tasks prevented jumping ahead pb operation operation condition condition hqi hw qi integer inserted condition hwi hsi integer enter enter hsi hwi wait hsi hwi skip fi signal hsi hsi hqi hqi hqi gamma hw qi hw qi hwi hwi signal hqi skip fi hwi wait hwi skip fi hsi hsi gamma wait hqi hqi hsi signal hsi jfj signal fi hw qi wait hw qi skip fi hw qi hw qi gamma return jtj signal jtj signal fi return transforming pb monitor monitor 
operation operation inserted condition enter enter signal signal wait wait signal wait return signal return transforming monitor monitor 
pnb operation operation condition hw integer hw inserted hwi integer hwi enter enter wait signal jqj jqj jqj gamma hw qi hw qi hwi hwi jqj skip fi wait wait hw qi hw qi gamma hwi hwi gamma return return transforming pnb monitor monitor 
ready tasks 
accomplished introducing condition delay entering tasks pending signals 
words hwi 
contains details transformation 
pb transformation similar signallers blocked signalled tasks unlocked monitor 
accomplished introducing explicit signaller queue block signallers number pending signals zero 
uses jsj pb monitor replaced jtj transformed monitor 
previous section queue prevent newly entering tasks jumping ahead ready tasks 
contains details transformation 
monitor performance monitor access serialized monitors inhibit concurrency potential system bottlenecks 
particularly important monitors efficient 
gain insight relative performance different kinds monitors response time various kinds monitors measured various conditions 
general structure experimental testbed general structure experimental testbed illustrated 
testbed simple queuing system servers 
number tasks system fixed 
gate keeper server exponential service time average service time gate keeper varied provide different loads monitor 
server monitor studied 
measuring average response time rm monitor varied allows draw inferences monitor 
general behaviour systems understood 
small gate keeper releases tasks quickly tasks queued gate keeper 
region rm large tasks queued waiting enter monitor 
large queue monitor short rm small 
extremes transition occurs called saturation point 
interesting quantities derived data 
example server average response time average throughput average number tasks related known formula little law particular applies monitor allows derive throughput monitor heavy load follows 
heaviest load monitor occurs small 
state nearly tasks pb operation operation condition hw integer hw inserted hwi integer hwi hwi jtj enter enter wait signal jqj jqj jqj gamma hw qi hw qi hwi hwi jqj skip fi wait wait wait hw qi hw qi gamma hwi hwi gamma return return transforming pb monitor monitor gatekeeper monitor experimental testbed waiting enter monitor nm small values xm nm rm rm known constant rm heavy load measured throughput monitor heavy load easily calculated 
language considerations programming languages typically provide kind monitor performance comparisons different monitors complicated need control inter language factors 
avoid problem monitors described restricted automatic signal monitor implemented kernighan ritchie concurrency kernel supports light weight tasks uniprocessors multiprocessors buhr monitors implemented preprocessor converts monitor statements appropriate declarations semaphores calls operations semaphores 
simulation semaphores faithful directly implemented monitors amount duration blocking identical 
direct implementation affect absolute performance relative performance monitors change duration blocking establishes differences performance 
monitors traditional design ability specify kind monitor ability determine number blocked tasks condition variable unique way marking tasks condition queues aid programming 
monitor introduced statement name kind monitor declarations monitor routines current implementation package visibility control 
programming discipline accessing monitor variables internal routines outside monitor guarantee monitor functions correctly 
kind monitor specified new monitor names table rw 
kinds routines allowed monitor routines obtain monitor lock called outside monitor routines acquire monitor lock called monitor 
type declaring condition variables arrays conditions pointers conditions supported condition queues fifo 
content condition variable private meaningful read assign condition variable initialization copy condition variable pass value parameter condition variable outside monitor declared 
forms wait statement explicit signal automatic signal monitors respectively 
statement explicit signal monitors wait condition variable 
statement automatic signal monitors wait conditional expression true 
statement monitors signal condition 
precise implementation depends kind monitor specified statement 
routine condition variable returns number tasks blocked condition variable 
turing holt provides similar capability empty routine returns true condition variable tasks waiting false 
precede condition variable name condition variables passed 
explicit signal statement allows optional value stored task condition queue 
done including value condition example condition integer expression value confused hoare argument condition priority subsequent selection task condition signalled hoare integer value accessed tasks routine condition variable returns value blocked task condition variable 
value specified default value assumed 
information provide precise information waiting task inferred presence particular condition variable 
example value front task condition examined signaller help decision condition variable signal 
facility mimicked creating managing explicit queue monitor contains values 
condition variable manages queue convenient allow users take advantage 
usefulness facility demonstrated section 
test problem chose readers writer problem moderate complexity fairly representative monitor 
readers writer problem deals controlling access resource shared multiple readers writer time sequential file 
possible solutions problem solution fair face continuous stream kind task arriving monitor 
example readers currently resource continuous stream reader tasks arriving writer task wait forever 
furthermore solution readers writer problem provide fifo execution tasks read requested write execute write reading old information 
phenomenon called stale readers problem 
solutions primitives courtois solutions fairness problem may result unbounded wait kinds tasks non fifo execution tasks 
hoare monitor solution fair kinds tasks non fifo execution 
published solutions 
additional difficulty arises comparing different kinds monitors different kinds monitors suggest different coding styles may support certain coding styles efficiently 
true case readers writers problem 
avoid bias tested solutions readers writer problem 
service readers writers fifo order fairness problem stale read problem 
solutions differ coding style prompted blocking nonblocking nature signal statement 
blocking signal tends suggest style signaller delegates responsibility clean signalling signalled task 
style suggested signalled task usually execute signalled task perform needed done 
example readers writer problem reader group readers writer leaves monitor checks front condition queue possible signals task may restart execution 
signalled task reader reader checks front queue signals reader task turn may signal appropriate 
reader delegated responsibility start reader front condition queue 
nonblocking signal tends suggest different coding style signaller takes responsibility clean signalling tasks execute 
style suggested signaller continues execution signal perform necessary signalled tasks enter monitor 
example readers writer problem task resource signals tasks appropriate front condition queue 
writer task finished resource potentially signal multiple reader tasks signalling 
coding styles suggested blocking nonblocking signal called coding styles respectively 
notice coding styles suggested required kind signal 
monitors coding style works regardless kind monitor 
coding styles worthy examination 
monitor solutions readers writer problem coding styles appear appendix monitors reading writing act controls delay tasks resource busy 
notice optional value stored waiting task distinguish reader writer tasks condition variable 
task monitor examines information task front condition queue signalling decisions 
structure experiment monitor types tested blocking nonblocking nb quasi blocking qb extended immediate return ret 
general automatic signal monitor tested execution performance comparable explicit signal monitors times slower 
poor performance need wake potentially tasks monitor conditional expression 
test coding style solutions readers writer problem coding style cs coding style cs tested 
priority priority versions monitor tested 
combinations monitor priority coding style tested leading experiments 
experiments run random order avoid possible interactions 
experiments run multiprocessor sequent symmetry timer accurate microsecond 
timer allows accurate timings short events time task enter exit monitor 
tests run stand minimal operating system processes running small amount interference occur 
interference occurred operating system preempt processors execution experimental trial period time 
fortunately interference extremely rare resulting outlying values influence results 
experiment simple simulation system illustrated 
pool worker tasks started blocks barrier controlled gate keeper 
gate keeper acts server service time exponentially distributed mean simulation phases phase brings system steady state second phase workers determine length time serviced monitor 
steady state reached gate keeper opening gate times 
value determined pilot experiment rm plotted function time different values see response times reached steady state 
gate keeper sets shared variable worker tasks start recording response times 
gate opened times shared variable reset causing workers recording readerandwriter condition ww monitor variables gk arrival time exponential calls simulation system response times 
simulation shutdown response times collected worker tasks 
may times gate opened worker enters system worker tasks may simulation system simulation closed system 
situation happens gate keeper opening gate faster service time monitor 
value chosen large get observations value small small simulation take long value large 
results pilot experiments showed different monitors saturated point monitor service time equals arrival rate range microseconds 
detailed statistical analysis done range large variance mask results side behaviour stable 
decided analyze detail data areas outside large variance region contained values small preclude accurate measurement large simulation took long 
resulted distinct analyses preand post saturation 
released gate keeper worker task randomly chooses reader writer probability rw pair calls monitor 
probabilities tested rw believe represent broad range realistic situations 
time taken calls measured 
time represents time task delayed gaining access particular kind monitor experiment 
real system additional delay monitor calls simulate actual access shared resource 
time independent kind monitor extended simulation time providing additional information 
physical processors involved executing simulation determine number processors affects phenomenon examining 
number processors tested 
values chosen representative number processors available shared memory multiprocessor computers 
trials run combination values fp rw trials mitigated small amount interference underlying operating system execution 
order trials run randomized avoid interaction operating system 
illustration behaviour different kinds monitors executing saturation points figures show graph coding style respectively tuples 
top graph complete experiment bottom graphs regions top graph 
graphs show classic transition queuing system driven saturation 
monitor longer service requests faster arriving tasks spend large amounts time waiting enter monitor 
system closed response times reached plateau maximum times average service time monitor plus constant simulation system overhead 
increasing decreasing number worker tasks simply linear effect level plateau 
combinations variables tested leading monitor type priority coding style average arrival processors percent readers complete factorial experimental design 
data analyzed analysis variance standard statistical software sas program anova 
average inter arrival time readers processors tasks pnb theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta pb npb pres average inter arrival time readers processors tasks theta theta theta theta theta theta theta average inter arrival time readers processors tasks theta theta theta theta theta theta theta coding style representative graph times microseconds average inter arrival time readers processors tasks pnb theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta pb npb pres average inter arrival time readers processors tasks theta theta theta theta theta theta theta average inter arrival time readers processors tasks theta theta theta theta theta theta theta coding style representative graph times microseconds distribution response times rm highly skewed analysis done transformed statistic ln ln 
transformation common statistical method effect transforming skewed distribution distribution nearly normal making amenable standard statistical tests 
degrees freedom error term possible detect extremely small differences groups 
considered statistical differences insignificant practical standpoint 
sources differences sections discussion effect different kinds monitors readers writer problem 
discussion applicable problem group tasks wait resource free 
tasks requesting resource designated read request write request 
tables context switches occur lines 
priority blocking signal section describes behaviour monitor coding styles blocking signal 
monitor examined priority blocking hoare monitor 
table shows particular situation arise execution monitor coding style 
scenario writer just finished resource called monitor release resource 
resource queue tasks formed monitor waiting condition variable readerandwriter exit monitor readerandwriter condition queue signaller queue 










table priority blocking signal monitor coding style priority blocking monitor context switches needed move tasks readerandwriter queue signaller queue 
time signaller tasks blocked 
wait context switches signalled exit monitor run concurrently 
primed task denotes task time context switch 
example task enters monitor exits monitor context switch allow task enter monitor 
notice reader reader group readers exits monitor readers finds writer front readerandwriter queue signal reader cause block signaller queue 
access resource fifo concurrent readers may exit arbitrary order 
problem readers writer problem noted important problems 
problem reduced concurrency reader tasks mitigated simply changing coding style 
having reader task signal reader task task resource signalling monitor coding style 
table shows scenario priority blocking monitor execution monitor coding style 
example context switches needed move tasks readerandwriter queue signaller queue waits context switches exit monitor run concurrently 
exit monitor readerandwriter condition queue signaller queue 










table priority blocking signal monitor coding style readers exit fifo order 
case concurrency delay shifted reader tasks writer task depending problem shift extremely important 
priority nonblocking signal nonblocking signal execution scenario monitor coding style shown table execution monitor coding style shown table 
exit monitor readerandwriter condition queue signalled queue 





table priority nonblocking signal monitor coding style exit monitor readerandwriter condition queue signalled queue 





table priority nonblocking signal monitor coding style notice tasks moved condition queue signalled queue context switch task appears queues time tables 
tasks moved remain blocked 
context switches needed move tasks readerandwriter queue signaller queue 
concurrency inhibited signaller fifo ordering maintained exiting readers 
priority scheduling problems priority scheduling implementation particular scheduling schemes tasks difficult 
example fifo scheduling difficult implement guarantee signalled signaller task executes monitor 
ordering important special care taken ensure arriving tasks barge monitor queue 
task scheduled ahead tasks waiting monitor referred task 
general accomplished having calling task check tasks waiting monitor 
waiting tasks calling task waits special condition subsequently signalled waiting task see section 
practise special condition variable unnecessary usually condition variable calling task wait readerandwriter condition 
order tasks arrive lost multiple condition variables possible perform operation nth arriving task marking having additional queue 
determining tasks waiting monitor non trivial tasks may waiting internal monitor queues 
normally possible examine lengths internal queues monitor keep track fact explicitly 
example task signalled readerandwriter condition signaller signalled task placed internal queues 
caller find tasks condition variables resource 
situation handled counter variable keeps track tasks internal queues tasks truly know tasks waiting monitor see section 
appendix contains modified versions monitor coding styles guarantee fifo ordering priority priority monitor priority 
fortunately addition monitors setting testing flag variable know tasks waiting monitor additional signalling waiting unnecessary 
analysis results results analysis divided regions saturation pre saturation post saturation 
important systems drive monitors saturation 
briefly results experiment follows 
fairly large differences saturation points different monitors 
statistically significant differences response times different monitors pre post saturation 
differences fairly small 
saturation range monitors saturated order blocking quasi blocking nonblocking respectively 
blocking monitors saturated approximately nonblocking monitors 
large difference results effects discussed section blocking monitors release signallers quickly nonblocking monitors 
nonblocking monitors handle faster arrival rate quasi blocking blocking monitors saturating 
result important saturation point determines maximum rate monitor process requests 
experiments nonblocking monitors handle request rates considerably higher quasi blocking blocking monitors 
pre saturation larger saturation point average queue length monitor short rm short 
variance rm moderate tasks encounter queue queue length uncommon 
decreases approaches saturation point average queue length increases 
tasks encounter short queue monitor encounter longer queues random fluctuations 
variance queue length increases variance response times 
blocking discussed section nb nonblocking monitor qb quasi blocking monitor blocking monitor 
ret non blocking monitor cs signals appear returns cs quasi blocking monitor signal occur return followed wait 
change non blocking quasi blocking seen different locations curves cs cs figures respectively 
predict smallest response times occur non blocking monitors followed quasi blocking blocking monitors respectively 
ordering lowest highest response times different kinds monitors cs nb cs ret cs nb cs ret cs qb cs cs cs qb 
follow comparisons differences means tukey post hoc comparison statistically significant groupings fcs nb cs ret cs fcs fcs qb cs cs cs correspond nonblocking quasi blocking blocking respectively 
mean response time nonblocking group quasi blocking group mean response time quasi blocking group blocking group 
quasi blocking monitors grouped blocking monitors implementation randomizes selection signaller waiting queues intervening calling tasks quasi blocking monitors behave blocking monitors cases 
coding style analysis section suggests cs response times cs response times signaller starts multiple tasks execute parallel outside monitor signaller takes responsibility signalling tasks execute 
feel full model analysis variance permitted fair test hypothesis ret monitor changed blocking quasi blocking cs cs 
separate analysis conducted ret monitor 
significant interaction cs cs trials 
mean cs monitor response time mean cs monitor response time 
priority priority monitors lower response times priority counterparts increased execution time priority monitors 
increase result extra code added priority monitor behaves priority monitor readers writer problem 
calling tasks barge monitor may prevent signalled signaller task making immediate progress 
significant interaction priority priority trials 
mean priority monitor response time mean priority monitors response time 
effects statistically significant effects appeared pre saturation 
number processors effect group readers released execute faster processors 
faster reader tasks execute faster finish response times longer slightly counter intuitive 
percentage readers rw effect writers means smaller groups readers longer waiting times writers serialized 
response times shorter percentage readers increased readers move monitor quickly 
decrease response time data reader experiments 
average arrival effect monitors completely stabilized range response times continuing decrease slightly 
instability seen detailed graphs range figures 
effect variables affect relationships monitors tested experiment possible generalize statements monitor type coding style priority variables 
post saturation region behaviour system simple 
tasks spend time monitor entry queue readerandwriter condition gate keeper releasing tasks faster monitor service time 
simulation system stable state 
blocking pre saturation predict smallest response times occur non blocking monitors followed quasi blocking blocking monitors respectively 
ordering lowest highest response times different kinds monitors cs ret cs nb cs nb cs ret cs qb cs cs qb cs follow comparisons differences means statistically significant groupings fcs ret cs nb cs fcs fcs qb cs cs qb cs bg correspond nonblocking quasi blocking blocking respectively 
mean response time nonblocking group quasi blocking group mean response time quasi blocking group blocking group 
matches predicted ordering quasi blocking monitors implementation 
coding style pre saturation predict cs response times cs response times 
significant interaction cs cs trials 
mean cs monitor response time mean cs monitor response time 
priority pre saturation predict priority monitors lower response times counterparts 
significant interaction priority priority trials 
mean priority monitor response time mean priority monitors response time 
effects number processors reader percentage effect reasons region effect average arrival worker tasks stabilized range 
summary differences outlined statistically significant small differences saturation points 
difference priority priority monitors significantly greater additional signaling waiting necessary ensure fifo ordering setting testing flag variable needed 
concurrent programs show significant performance benefit changing kind monitor programs running close saturation point hardware limitations benefit significantly changing kind monitor 
general case considerations important important choosing kind monitor concurrency system 
noteworthy nonblocking monitors execution times saturation points identical immediate return monitors impose restrictions location signal statement 
comparison summation criteria programmer programming language designer selecting particular kind monitor solve problem implement programming language 
proof rules programming language constructs simple semantics tend easier error prone complex semantics 
proof rules formal specification semantics constructs simple proof rules tend easier constructs complex proof rules 
example proof rules describe semantics statement simple compared proof rules describing general goto statement 
way compare programming language constructs compare complexity proof rules 
complexity programming language constructs consideration choosing 
important power weight ratio power expressive power construct weight cost programming complexity execution time construct 
example automatic signal monitors high degree expressive power high cost execution time 
simplicity proof rules offset cost execution time 
additional difficulty comparing proof rules programming language constructs restricted ways context certain idioms 
example programming language lacked high level looping constructs statement construct loops goto statement 
languages common practice goto statements certain stereotypical ways structured programming 
approach yields programs easier understand goto full generality 
effect proof rules goto simplified weakening 
result programs proofs correctness simplified considerably 
pointed sections proof rules signal wait simplified fashion certain kinds monitors tends simplify programs proofs 
careful draw unwarranted comparison proof rules 
drawback simplified proof rules programs execute correctly may provably correct simplified proof rules simplified proof rules may adequate verifying existing monitor programs 
priority versus priority proof rules priority monitors slightly complex monitors 
added complexity priority monitors due significantly weakening preconditions wait return easier satisfy 
experience slight additional complexity offset stringent proof obligations wait return 
condition signalled priority monitor control transfers directly indirectly task waiting condition occur condition variable empty 
case transfer allows signaller signalled tasks establish internal protocol communication monitor variables 
contrast signal priority monitor programming languages mesa modula modula act hint waiting task resume execution convenient time 
modula takes step defining signal routine wake task implies may wake task 
modelled taxonomy priority nonblocking monitor loop signal statement executes random number times 
priority monitors assertion condition signalled may longer hold time signalled task gains control monitor making internal protocols difficult impossible 
waiting task restarts determine monitor state waiting true assuming true signalled 
results wait statement enclosed loop task re check event waiting occurred done implicitly automatic signal monitor 
coding style result needless context switches tasks awake wait potentially inhibit concurrency 
lampson attempts disarm criticism saying typically tasks waiting monitor lock 
systems introduce concurrency particularly light weight tasks machines introduce processors definitely monitors heavily 
furthermore priority monitor unlocked programmer ensure monitor invariant satisfied case calling task enters monitor 
difficult implement certain scheduling schemes priority monitors calling task barge ahead tasks waiting monitor 
special care taken including extra code deal situation possible guarantee fifo scheduling may critical particular problem readers writer problem 
cases necessary simulate priority monitor prevent different simulation techniques discussed section increases execution cost 
potential unbounded waiting priority monitors 
implementation chooses randomly internal queues priority bound number tasks serviced task selected particular queue 
practise problem usually solved implementation combines queues priority tasks placed bounded number tasks ahead 
advantage priority monitor task wait long average entering monitor 
blocking versus nonblocking blocking monitors simple rules wait return complicated rules signal nonblocking monitors complicated rules wait return simple rules signal 
blocking signal guarantees control goes immediately signalled task 
direct transfer conceptually appealing guarantees control transfers task waiting particular assertion true signaller opportunity inadvertently falsify assertion true time signal 
kind signal results monitor programs signaller delegates responsibility clean signalling signalled task 
nonblocking signal leaves signaller control monitor unlocked monitor 
kind signal results monitor signaller takes responsibility clean signalling tasks execute 
suggested howard observed form blocking programmers naturally think 
nonblocking signal signaller obligated establish proper monitor state monitor unlocked monitor state time signal irrelevant 
situation signaller performs multiple signals possible signalled tasks subsequently alter monitor state signalled tasks 
similar problem exists blocking signal possible signalled task subsequently alter monitor state prior resumption signaller 
fortunately situations handled judicious manipulation monitor data signalled tasks 
main differences kinds monitors coding problems performance 
blocking monitor signal return wait involves additional runtime overhead context switch signalled task subsequently back signaller wait return occur case nonblocking monitor 
second blocking case signalled task restart signaller task condition eventually wait signaller currently signaller queue 
signalled task signals condition signaller eventually wait task restarted signal lost condition empty situation result problems signaller may restarted 
example straightforward approach communicating data tasks monitor task task msg wait signal print msg wait reply print reply signal fails blocking monitor task signal condition lost 
nonblocking case signaller blocks condition signalled task starts signalled task knows restart signaller appropriate 
opposite problem occur blocking monitor signaller stops execution signalled tasks wait queue signalled 
example extreme case signals hints signalled task wake tasks waiting condition assertion condition true signaller task waiting tasks empty signal 
wait waiting task restarts falsifies assertion signaller task loops forever waiting tasks continually put back condition variable 
nonblocking monitor signalled tasks moved waiting queue monitor eventually unlocked guarantees condition variable empty 
blocking case signal return inhibits concurrency signaller remains blocked signalled task executing monitor 
nonblocking case signaller allowed return monitor immediately execute concurrently signalled task outside monitor 
uniprocessor extra concurrency noticed decreased turn time 
multiprocessors extra concurrency noticed increased throughput 
possible mitigate problem blocking signal return having compiler optimize signal nonblocking signal changes semantic monitor 
coding style blocking nonblocking monitors suggest different coding styles place 
readers writer problem coding style signaller responsible signalling tasks produced slight performance advantage 
advantage occurred inhibiting concurrency writer task increase concurrency readers best way speed system readers writers 
possible imagine scenarios inhibiting concurrency signaller task increase delays system example signaller task controlling critical aspects system 
drawback coding style releasing readers non fifo order blocking monitor 
situation release order important subtle variation release order difficult notice 
quasi blocking versus blocking non blocking quasi blocking monitors complicated proof rules rules signal similar blocking monitors rules monitor similar nonblocking monitors worst worlds 
advantage monitor blocking signaller tasks wait signalled tasks resume execution 
signaller tasks leave monitor quickly blocked longer time 
order execution signaller signalled tasks unknown internal protocol difficult establish 
believe kind monitor particularly useful appears implicitly situations operating system kernels 
extended immediate return proof rules extended immediate return monitors identical nonblocking monitors 
standpoint proof complexity advantages disadvantages relative monitors non blocking monitors 
immediate return monitor invented optimize signal return case occurs frequently monitors cost restricting ability write certain monitor algorithms 
extended immediate return monitor allows monitor written restriction signal appear wait return statement 
system saturated extended immediate return monitor performs slightly better nonblocking monitor 
true saturation signal return case quasi blocking case 
reason monitor performed better pnb signals occur returns pnb monitor check waiting queue returning results time spent monitor 
importantly extended immediate return monitor mandates particular coding style signals waits returns may unnecessarily complicate coding monitor obscure algorithm 
automatic signal automatic signal monitors simplest proof rules experience automatic signal monitors easier explicit signal monitors 
eliminating signal eliminates common mistakes explicit signal monitor programs performing unwarranted signals performing necessary signals 
unfortunately general automatic signal monitor expensive number tasks monitor large true saturation 
restricted automatic signal monitors simple proof rules competitive explicit signal monitors especially condition variables depend number conditional expressions number tasks monitor 
restricted automatic signal monitor conditional expressions involve local variables parameters request example disk scheduling algorithm requests serviced order track number request 
class important problems handled restricted automatic signal monitor 
classification criterion semantics signal mechanism define fundamental characteristic monitor 
identifies total useful kinds monitors explicit signal implicit signal monitors categorizations priority blocking 
restricted automatic signal monitor considered variation automatic signal monitor 
howard stated conventions clearly superior 
furthermore shown kinds monitors immediate return monitor functionally equivalent things 
analysis uncovered important differences monitors 
cases priority property complicates proof rules performance worse programming difficult 
signals hints solve problems monitor idiom idiom forced gives false impression monitors general 
rejected priority monitors consideration 
proof rules performance subjective ease delay saturation programming simple pas small easy pas pb pnb pnb pnb pb pb complex large pas difficult table final results remaining kinds monitors summarized table 
table shows designing concurrency system monitors synchronization communication choices 
basis analysis conclude priority nonblocking monitor best semantics differs andrews choice priority nonblocking 
proof rules middle range terms complexity simplified coding style affecting monitor invariant signal wait exit 
second unnecessary context switches concurrency inhibited performance excellent 
particular ability handle higher loads saturating important real time systems 
necessary signaller wait signalled task execute blocking semantics easy simulate introducing additional condition variable waiting signalling appropriately 
third gives priority resuming tasks straightforward program allowing internal protocols created scheduling schemes fifo implemented extra code needed priority monitor 
reasons priority nonblocking signal adopted monitors buhr appendix readers writer problem priority monitor coding style solution suggested blocking signal 
reader group readers finished writer finished resource checks front condition queue possible signals task may restart execution 
signalled task reader checks front queue signals reader task turn may signal appropriate daisy chain effect 
rw monitor type define reader define writer int readerandwriter condition void void readerandwriter readerandwriter reader readerandwriter readerandwriter reader readerandwriter void void readerandwriter readerandwriter void void readerandwriter writer void void readerandwriter readerandwriter rw coding style solution suggested nonblocking signal 
task resource starts tasks front condition queue 
task finished resource potentially signal multiple tasks signal tasks 
rw monitor type define reader define writer int readerandwriter condition void void readerandwriter readerandwriter reader void void readerandwriter readerandwriter void void readerandwriter writer void void readerandwriter readerandwriter writer readerandwriter readerandwriter readerandwriter break readerandwriter writer break rw appendix readers write problem priority monitor solutions readers writer problem require fifo servicing extra code added ensure 
coding style solution suggested blocking signal 
reader group readers finished writer finished resource checks front condition queue possible signals task may restart execution 
signalled task reader checks front queue signals reader task turn may signal appropriate daisy chain effect 
rw monitor type define reader define writer int pending readerandwriter condition void void readerandwriter pending readerandwriter reader pending readerandwriter readerandwriter reader pending readerandwriter void void readerandwriter pending readerandwriter void void pending readerandwriter writer pending void void readerandwriter pending readerandwriter rw coding style solution suggested nonblocking signal 
task resource starts tasks front condition queue 
task finished resource potentially signal multiple tasks signal tasks 
rw monitor type define reader define writer int pending readerandwriter condition void void readerandwriter pending readerandwriter reader pending void void readerandwriter pending readerandwriter void void pending readerandwriter writer pending void void readerandwriter readerandwriter writer pending readerandwriter pending readerandwriter readerandwriter break readerandwriter writer break rw acknowledgments cathy kelley john helping build statistically valid experiment analyze results experiment 
bob jo reading commenting 
adams black 
proof rules monitors 
operating systems review apr 
adams black 
letter editor 
operating systems review jan 
andrews schneider 
concepts notations concurrent programming 
acm comput 
surv 
mar 
andrews 
concurrent programming principles practice 
benjamin cummings publishing redwood city california 
brinch hansen 
operating system principles 
prentice hall 
brinch hansen 
programming language concurrent pascal 
ieee trans 
softw 
eng 
june 
buhr 
system providing light weight concurrency sharedmemory multiprocessor computers running unix 
software practice experience sept 
buhr younger 
concurrency object oriented language 
software practice experience feb 
campbell habermann 
specification process synchronization path expressions vol 
lecture notes computer science 
springer verlag 
cardelli donahue glassman jordan kalsow nelson 
modula report 
tech 
rep systems research center lytton avenue palo alto california aug cheriton 
system multi process structuring portability 
american elsevier 
cheriton 
distributed system 
commun 
acm mar 
courtois parnas 
concurrent control readers writers 
commun 
acm oct 
dahl nygaard 
simula common base language 
norwegian computing center oslo norway 
dijkstra 
structure multiprogramming system 
commun 
acm may 

study monitors 
master thesis department computer science university waterloo waterloo ontario canada 
gentleman 
harmony operating system 
tech 
rep national research council canada ottawa canada may gosling rosenthal arden 
news book 
springer verlag 
gries 
science computer programming 
springer verlag fifth ave new york new york 
hansen 
design edison 
software practice experience apr 
hansen 
edison multiprocessor language 
software practice experience apr 
hansen 
edison programs 
software practice experience apr 
hoare 
monitors operating system structuring concept 
commun 
acm oct 
holt cordy 
turing programming language 
commun 
acm dec 
holt 
turing manual third ed 
holt software associates howard 
proving monitors 
commun 
acm may 
howard 
signalling monitors 
proceedings second international conference software engineering san francisco oct pp 

howard 
reply proof rules monitors 
operating systems review oct 
kernighan ritchie 
programming language second ed 
prentice hall software series 
prentice hall 

alternative event queues synchronization monitors 
commun 
acm july 
lampson redell 
experience processes monitors mesa 
commun 
acm feb 
mitchell maybury sweet 
mesa language manual 
tech 
rep csl xerox palo alto research center apr nelson ed 

systems programming modula 
prentice hall raj levy black hutchinson jul 
emerald general purpose programming language 
software practice experience jan 
wirth 
programming modula third corrected ed 
texts monographs computer science 
springer verlag 
