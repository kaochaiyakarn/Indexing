evolutionary algorithms swiss scientific computing center logic systems laboratory swiss federal institute technology ch lausanne switzerland mail di epfl ch 
evolutionary algorithms gaining increased attention past years versatility successfully applied different fields study 
group heading family new computing techniques rooted biological evolution solving hard problems 
chapter survey genetic algorithms genetic programming important evolutionary techniques 
discuss parallel implementations notable extensions focusing potential applications field evolvable hardware 
performance modern computers quite impressive fair say computers far better humans domains comprise powerful tool constantly changing view world 
scientific engineering number problems performance increases steadily able tackle called grand challenge problems soon parallel machines 
best chess playing programs date able beat chess masters proving worthy opponents task requiring high level symbolic processing 
tasks highly important performed average laptop 
example writing high quality documents color graphics connecting internet order obtain valuable information quite commonplace days 
despite success exists large gray area current leading computing paradigms 
children animals better computers real life tasks carried dynamic environment 
biology long served inspiration construction artifacts applied computers recognize fundamental underlying common digital structure molecular biology machines 
extrapolation holds principle impediments difficulties practice paradigm valuable far reaching collection attempts demonstrate 
problem solving methods inspired biological world evolutionary computing neural networks accepted popular addition tool case scientists engineers different areas 
relegated decades artificial intelligence groups concerned general problem solvers universal symbol manipulators considered sloppy approach describing supposed mathematical beauty hiding apparent complexity natural man systems 
computational resources available time posed serious problem methods 
symbolic approach worked quite highly idealized problem subsets theorem proving game playing 
come tasks recognizing simple patterns people soon realized approach met enormous problems scale 
difficulty stems impossibility description adapt changing conditions brittle adapt dynamic environment 
try patch system adding rules parameters computer power human expert information sooner entire structure collapses 
formal systems definitely place useful instances 
dealing dynamic environments new approaches considered 
continuous change adaptation intrinsic phenomena nature sloppy ways may turn best situations 
fact fuzziness approximation rule exception daily activities surrounding world 
chapter concentrate class methods inspired natural evolution demonstrating constitute flexible powerful metaphor problem solving 
evolutionary algorithms evolutionary algorithms search optimization procedures find origin inspiration biological world 
darwinian theory evolution emphasizing survival fittest dynamic environment generally accepted grounds evidence accumulated far earth 
evolutionary algorithms general term encompassing number related methodologies natural evolution paradigm 
genetic algorithms evolution strategies evolutionary programming historically prominent approaches genetic programming rapidly emerging years 
lack space shall concentrate genetic algorithms ga genetic programming gp widely techniques conjunction evolvable hardware 
presenting basics genetic algorithms simple example extensions refinements discussed 
introduce genetic programming approach 
evolutionary algorithms intrinsically parallel evolution takes place simultaneous interactions individuals spatially extended domains 
parallel gas generally easy implement offer increased performance low programming cost 
evolutionary methods computation ally intensive parallel gas offer promising approach furthermore suggest novel ways artificial evolution put 
shall issues section 
evolutionary algorithms applied problems diverse fields study including hard function combinatorial optimization neural network design planning scheduling industrial design management economics machine learning pattern recognition 
intention discuss particular applications evolutionary algorithms interested reader referred extended literature available artificial evolution holds promise fundamentally changing way computing machines designed 
evolutionary engineering called way fabricate systems exhibit better fault tolerance 
book dedicated discussion interdisciplinary frontier evolvable hardware 
evolutionary computing mature research field existing applications evolvable hardware steps 
important note distinction intrinsic extrinsic hardware evolution thompson kitano role limitations software simulations hardware evolutionary design mondada floreano thompson 
thompson provide interesting arguments variants evolutionary algorithms machine evolution stress continuous adaptation noisy changing fitness landscape straight optimization fixed objective 
genetic algorithms genetic algorithms invented john holland finding inspiration evolutionary process occurring nature 
main idea order population individuals collectively adapt environment behave natural system survival reproduction promoted elimination useless harmful traits rewarding useful behavior 
holland insight abstracting fundamental biological mechanisms permit system adaptation mathematically specified algorithm 
genetic algorithms essentially searching optimization problems machine learning 
unresolved question natural evolutionary process really optimization process 
evolution essentially shot experiment alternatives tried way discarded selection process start zero try 
careful discussion straight optimization right point view machine evolution domain 
optimization meaningful context constraints 
dynamics evolutionary process extremely complex unknown hypothesis concerning optimization nature scattered conference proceedings journals starting place international conference genetic algorithms icga series see 
best 
artificial evolution approach optimization viable demonstrably solutions obtained comparison approaches 
require evolutionary algorithms completely faithful nature seek find efficient solutions 
advantage artificial evolution ability simulate evolutionary processes times wish varying conditions electronic speeds 
natural world provides endless source inspiration realize freedom shape ideas pragmatic ways necessarily follow nature 
ga iterative procedure consists constant size population individuals represented finite string symbols encoding possible solution problem space 
space known search space comprises possible solutions problem hand 
symbol alphabet binary due generality advantageous mathematical properties 
standard ga works follows initial population individuals generated random heuristically 
evolutionary step called generation individuals current population decoded evaluated pre defined quality criterion referred fitness 
form new population individuals selected probability proportional relative fitness 
ensures expected number times individual chosen approximately proportional relative performance population high fitness individuals stand better chance reproducing low fitness ones disappear 
selection procedure new points search space generated genetic operators popular ones crossover mutation 
crossover recombination operator individuals called parents exchange parts forming new individuals called offspring simplest substrings exchanged randomly selected crossover point 
operator enables evolutionary process move promising regions search space 
second operator mutation essentially background noise introduced prevent premature convergence local optima randomly sampling new points search space 
carried flipping bits random small probability 
gas stochastic iterative algorithms guaranteed converge 
termination may triggered reaching maximum number generations finding acceptable solution 
general schema summarizes standard genetic algorithm produce initial population individuals evaluate fitness individuals termination condition met select fitter individuals reproduction recombine individuals mutate individuals evaluate fitness new individuals generate new population inserting new individuals discarding old bad individuals section tutorial example simple problem solved standard ga reader referred general detailed discussion gas 
terms biological analogy noted gas focus individual evolution genotypic changes operating individual coding sequences 
evolutionary algorithms evolution strategies evolutionary programming take phenotypic view evolutionary operators act individuals simply natural representations problem hand example real numbers parameter optimization problems 
comparison different forms evolutionary algorithms fogel book 
simple example section example involving function optimization demonstrating operation genetic algorithm 
gas limited domain workings probably better understood optimization setting 
problem purely illustrative value fact solved hand 
non constrained function minimization problem cast follows 
function domain find minff dg consider function see fig gamma sin problem find interval gamma minimizes symmetric studying positive portion axis suffice 
examine turn components genetic algorithm solving problem 
initial population formed randomly chosen trial points interval 
individual value real variable binary string represent values length string function required precision longer string better fig 

graph gamma 
precision 
example point represented bits different values available covering interval points gives granularity genetic algorithm able sample points apart 
strings represent respectively lower upper bounds search interval 
bit string mapped interior point 
order map binary string real number string converted decimal number corresponding real note bit strings illustrative purposes real applications finer granularities longer strings needed 
fitness sample point simply value function point 
want minimize lower value fitter strings selected reproduction function fitness 
possibilities exist shall discussed ahead 
current example delineate common methods known evaluating fitness individual generation total fitness entire population computed popsize probability assigned string cumulative probability obtained individual string adding fitness values preceding population members popsize random number uniformly distributed range drawn popsize times time th string selected gamma string selected 
process visualized spinning biased roulette wheel divided popsize slots size proportional respective individual fitness 
example suppose strings values 

random number generated individual selected individual selected roulette wheel selection fitter members reproduced strings selected 
note probability measures involved positive fitness values reason positive constant added function interval 
new population produced strings paired random recombined crossover 
techniques available popular point crossover delineated ahead 
suppose strings selected recombination crossover point selected random string length minus uniform probability 
suppose position chosen marked vertical bar substrings position swapped obtaining new strings called offspring offspring replace parents population generation 
crossover applied certain frequency called crossover rate individual takes part recombination process uniformly distributed random variable interval value common empirical value 
crossover mutation applied population members frequency common empirical value 
standard mutation process random number generated uniformly distributed bit string population bit flipped 
aforementioned values experimentally derived proving successful applications 
sophisticated gas probabilities need stay constant run 
role genetic operators 
abundant literature different variants crossover mutation relative importance 
classical ga view crossover fundamental operator mutation playing auxiliary role 
view importance crossover stems fact combines possible beneficial traits individuals parents increasing likelihood generating fitter individuals contrast mutation single individual operator 
usefulness crossover related combination called building blocks better average substrings originating different individuals see section 
mixes substrings ones proven successful previous generations 
despite advantages crossover mutation important combined effect selection crossover generation new solutions search space tend cause rapid convergence danger loosing potentially useful genetic material 
important note fact restricted relatively small populations practice entailing sampling errors 
order re introduce diversity avoid premature convergence mutation essential mutation frequencies low search tends degenerate random walk 
relative importance mutation crossover controversial evolutionary techniques evolution strategies evolutionary programming rely mainly selection sophisticated mutation techniques see ref 
equipped notions come back function minimization problem solved ga measure quality solutions record average population fitness fitness best individual generation 
example consider table showing results particular evolutionary run 
generation consists randomly generated individuals find expected average best fitness values low quality 
observe fairly rapid improvement ensues minimum generation 
average population fitness continues improve population homogenous fitness values level 
behavior fact characteristic evolutionary algorithms general 
note simple example probability getting stuck local minimum practically zero 
harder problems compromise reached exploitation regions search space local improvement exploration space order find possibly better extrema points 
final order genetic algorithms stochastic generation best average performance varies different runs random number generator seed 
average performance taken runs useful indicator behavior single run 
problem easy gas optimization method 
gas shown effective solving hard mathematical optimization problems involving multimodal functions variables 
schemata building blocks section take depth look workings standard genetic algorithm explaining gas constitute effective search procedure 
simplicity discuss binary string representation individuals symbol special wild card symbol matches 
schema template consisting string composed symbols 
example schema template matches strings 
symbol manipulated ga notational device describe sets strings 
holland idea specific string evaluated assigned fitness value gives partial information fitness schemata string belongs referred implicit parallelism confused kind parallelism discussed section 
holland analyzed influence selection crossover mutation expected number schemata evolution proceeds generation 
details analysis relatively simple scope discussion ref 

follows outline main results significance 
denote number individuals population belonging particular schema time fitness proportionate selection number time step related follows average fitness value strings belonging schema average fitness value strings population 
assumes particular schema remains average fixed amount cf number generations solution recursive equation exponential growth equation stands number individuals belonging schema time positive constant 
significance result fitness proportionate selection allocates exponentially increasing number trials average schemata 
crossover mutation enter picture 
effect crossover swapping substrings diminish exponential increase quantity depends crossover rate defining length ffi schema string length ffi gamma defining length ffi schema distance fixed non string positions 
example schema ffi gamma ffi gamma 
intuitively observe schemata short defining length broken crossover 
average schemata short defining length known building blocks sampled exponentially increasing rate 
building blocks play important role holland theory 
effect mutation straightforward describe 
bit mutation probability gamma probability bit remaining unchanged 
single bit mutations independent probability string remaining unchanged gamma string length 
fixed non positions matter number called order schema denoted minus number symbols 
example schemata respectively 
probability surviving mutation gamma approximately gamma pm combined effect selection crossover mutation comprise holland schema theorem gamma ffi gamma gamma pm essentially number average low order schemata short defining lengths grows exponentially subsequent generations genetic algorithm 
schema theorem important result obtained somewhat idealized conditions 
building block hypothesis apply cases depends representation individuals genetic operators different holland 
easy find construct examples theorem hold 
problems studied past years order find inherent limitations genetic algorithms representations operators tractable 
despite limitations theory sketched section represents firm footing workings standard genetic algorithms 
extensions variations practice plain ga shown earlier seldom 
modifications extensions simple genetic algorithm proposed especially dealing real life problems 
section discuss issues including individual representation alternatives fitness proportionate selection different forms genetic operators extensions ga paradigm 
detailed account reader referred 
representation issues usually population individuals coded binary strings 
coding general natural adequate representation 
problem binary coded unsigned integers numbers close may large hamming distances binary form 
example string represents decimal number represented strings differ bits giving hamming distance 
means difficult search point close optimum move mutation 
gray code consecutive numbers differ bit alleviate problem 
gray coded strings difficulties dealing numerical parameter optimization problems 
problem mutation high order bits causes drastic changes low order bits 
furthermore precision function number bits bit string representing individual point 
attaining sufficient precision may require bits problematic especially multidimensional problems concerned 
dealing long bit strings time consuming search spaces huge natural consider floating point representations case 
fact representations standard ones evolutionary algorithms evolution strategies 
floating point representations gas solving numerical problems shown outperform binary codings cases 
note switching floating point representation requires careful rethinking genetic operators differ bit strings 
representation issues appear dealing combinatorial optimization problems discrete variable problems particular solution finite set possible solutions 
known efficient algorithms hard combinatorial problems traveling salesman problem tsp bin packing problem graph coloring problem 
paradigmatic versions important management problems fields sequencing routing scheduling important able quickly find solutions large instances 
various kinds approximation heuristic algorithms genetic algorithms 
number partitioning problem show representation issues critical genetic algorithms 
numbers partitioned groups way differences group sums minimized 
number partitions grows decision version problem np complete solved pseudo polynomial time dynamic programming 
simplest intuitive encoding represents partition string integer numbers kg denotes partition number belongs 
encoding called group number encoding standard crossover mutation operators major drawback offspring may contain groups 
example parents crossover point position give rise offsprings 
lacks group individual obviously unacceptable represent near optimal solution 
individuals repaired penalized way 
possibility define representations genetic operators legal solutions produced 
fact shown exist better encodings partition problem 
new representations operators bear little resemblance classical ones discussed theoretical results obtained bit strings immediately applicable representations 
empirical evidence suggests specific genetic representations operators may lead efficient evolutionary solutions difficult real world problems 
detailed discussion genetic representation issues combinatorial numerical problems ref 

selection section fitness proportionate selection introduced 
selection method problems 
problem course evolution fitter individuals obtain copies differences fitness small rendering selection ineffective 
case selection pressure modified better individuals reproduce normal fitness evaluation 
problem possible existence super individual population individual unusually high fitness 
fitness proportionate reproduction individual quickly come dominate population causing premature convergence possibly local optimum 
possible partially avoid effects suitably scaling evaluation function amounts modified fitness measure 
scaling methods suggested discussed example 
approach alleviate effects selection methods allocate trials direct proportion fitness 
methods rank selection tournament selection 
rank selection individuals population ordered fitness copies assigned way best individual receives predetermined multiple number copies worst 
rank selection reduces effect super individuals need scaling time amplifies differences close fitness values increasing selection pressure convergent populations 
rank selection methods success ignore information relative fitness different individuals violate schema theorem 
tournament selection individuals selected random uniform probability best highest fitness selected winner chosen probabilistically 
process repeated popsize times 
selection pressure proportional tournament size widely value 
tournament selection advantage need global local tournaments held simultaneously spatially distributed population see section 
genetic operators crossover mutation previously described simple understand deal drawbacks practice 
consequently variants proposed 
start crossover 
shown point crossover may effective combining certain schemata 
form crossover partially alleviates problem multi point crossover 
example point crossover cut points marked vertical bars substrings swapped points crossover crossover multi point crossover fare better combining certain features strings 
widely crossover form uniform crossover 
parent strings bit offspring bit corresponding position copied randomly probability parents 
second offspring gets corresponding bit remaining parent 
example parents probability suppose series random choices stands parent second obtain offspring uniform crossover violates customary form schema theorem preserve building blocks problems results 
discussion crossover related issues see chapter ref 

mutation received attention crossover ga literature 
adaptive mutation schemes suggested partly borrowed evolution strategies rate form mutation vary ga run 
instance mutation defined way search space explored uniformly locally candidate solutions locally improved 
information sophisticated mutation techniques ref 

particular role mutation applied machine design evolution discussed 
steady state genetic algorithm standard ga population changes evaluation mutation cycle 
cycle called generation reproduction technique accordingly called generational 
generational replacement drawbacks individuals may get chance reproduce hand duplicate individuals may enter population quickly propagate copies wasting computational resources 
addition crossover mutation may modify building blocks population potentially useful genetic material 
limited population size sum effects lead situation population quickly loses diversity 
remedy elitism best individuals find way generation offspring 
elitism completely avoid premature loss useful individuals 
reasons different replacement technique called steady state proposed 
steady state gas parameter determining number new individuals created 
usually members population changed time deleting worst individuals note popsize attain generational model 
steadystate reproduction particularly effective care taken prevent duplicate individuals produced 
checking constraint represents small overhead efficient population search process 
multimodality niching gas objective functions having multiple extrema may interest find optima just global 
standard ga difficult due genetic drift individuals tend concentrate highest peak evolution proceeds 
qualitatively phenomenon caused convergence finite population selection pressure low 
methods optimizing multimodal functions gas proposed strive form maintain stable subpopulations different peaks manner analogous biological phenomenon species level called niching 
earliest methods proposed goldberg richardson 
idea ga perception fitness function modified way individuals tend concentrate high peak fitness reduced factor proportional number individuals region 
effect diminishing attractive power peak allowing parts population concentrate regions 
effective fitness individual called shared fitness original fitness called niche count 
individual quantity calculated summing sharing function values sh contributed individuals population sh ij ij distance individuals defined euclidean distance computed real parameter space phenotypic sharing sh ij gamma ij oe ff ij oe ff oe constants 
difficulty method choose adequate value oe requires prior knowledge number peaks problem space information usually readily available 
furthermore computationally intensive shared fitness distance metric calculations 
methods clustering ideas subpopulation labels proposed shown effective 
suggested method consists executing number successive ga runs 
run fitness function updated point represented best individual run way new function depression place peak decreased 
best individual recorded solution exceeds threshold 
way optima successively 
parallel ga models different regions problem space independently searched useful multimodal optimization 
coevolution customary evolutionary paradigm single population evolves selection pressure fixed fitness function plays role environment 
nature environment population comprised physical environment normally changes slowly biological populations simultaneously adapting 
interactions evolving populations omnipresent consider example prey predator host parasite relationships 
conditions best think evolution evolutionary process changes certain species population influence ones environment altered 
kind arms race develops evolutionary changes species trigger counter adaptative changes species vice versa 
observations exploited creating robust artificial evolutionary algorithms 
advantage evolutionary methods need necessarily specify global fitness function population members ranked relative fitness needed 
useful providing adequate fitness function problem difficult impossible example complex games suite test cases large 
methods evolution roughly classified competitive cooperative 
hillis successful competitive evolutionary approaches optimization problems 
problem consisted evolving sorting network integers involving minimum number exchanges 
hillis classical evolutionary approach evolutionary 
populations consisting sorting networks second sorting problems 
problems permutations integers test cases sorting networks population second population viewed opportunistic parasitic 
populations evolve evolve dimensional grid parallel selection mating carried locally 
fitness sorting networks defined sort numbers immediate neighbor parasites parasites scored capacity producing difficult problems sorting networks 
way best networks learn sort increasingly difficult sets numbers avoiding need testing 
possible permutations numbers 
evolutionary approach outperformed standard problem hillis able evolve nearly optimal sorting network exchanges best known designed solutions having exchanges 
highly parallel local evolutionary algorithm sipper evolving non uniform cellular automata perform computational tasks 
model belongs cooperative class evolutionary algorithms individual units unison attain global goal 
de jong husbands proposed related evolutionary models species cooperation competition 
methods differ implementation share notion multiple species cooperating attain common objective 
briefly describe de jong approach referring reader original papers details 
model problem solved multiple populations evolved independently standard genetic algorithm 
subpopulation evolves species individuals represent hopefully useful components solution global problem 
species combined full solutions evaluated common global task 
credit assigned species collaborate solve common problem 
way selection pressure favors cooperation competition species single species evolution competition 
results better standard ga ones reported de jong simple function optimization problems neural network evolutionary design 
note previously described niching methods distributed subpopulation approaches discussed section seen instances evolutionary algorithms evolution competition semi isolated species type 
hybrid algorithms genetic algorithms robust general purpose search procedure 
belong called weak problem solving methods require little knowledge problem solved 
principle coding convention crossover mutation operators suitable fitness function needed 
gas quickly explore huge search spaces find regions average fitness search lacks focus 
realm actual industrial optimization problems case efficient search methods problem specific representations exist 
raises question gas competitive real world applications compared specialized algorithms heuristics 
fact genetic algorithms preferred settings established methods 
answer may lie hybrid genetic algorithms 
hybrid genetic algorithms incorporating fast efficient problem specific search procedure framework evolutionary algorithm 
tend encodings genetic operators tailored problem hand 
strength hybrid algorithms lies combination different complementary search principles evolutionary part performs wide search problem space local method exploiting knowledge problem searches promising regions depth 
possible combinations principles choosing right blend art science 
efficient algorithms outperform domain specific heuristic non specialized ga devised successfully applied see footnote section 
clearly needed put empirical methods mathematical basis 
hybrid gas amenable theoretical analysis standard genetic algorithms interesting practice increasing 
davis gives convincing description motivations hybrid gas 
genetic programming genetic programming gp new evolutionary approach extends genetic model learning space programs 
major variation genetic algorithms evolving individuals computer programs fixed length strings limited alphabet symbols 
form gp principally due koza 
individual programs gp expressed principle current programming language 
syntax languages gp operators create large percentage syntactically incorrect programs 
reason koza chose syntax prefix form analogous lisp restricted language appropriate number variables constants operators defined fit problem solved 
way syntax constraints respected program search space limited 
restricted language formed user defined function set terminal set functions chosen priori believed useful problem hand terminals usually variables constants 
addition function function set able accept arguments function return value data type terminal set property called syntactic closure 
space possible programs constituted set possible compositions functions recursively formed elements example suppose dealing simple arithmetic expressions variables 
case suitable function terminal sets defined gamma fa cg legal programs 
important note gp need implemented lisp language original implementation 
language represent programs internally parse trees adequate 
gp packages today written lisp 
programs represented trees ordered branches internal nodes functions leaves terminals problem 
examples trees fig 

fig 

gp trees corresponding lisp expressions text evolution gp similar gas different individual representation genetic operators 
suitable functions terminals determined problem hand initial random population trees programs constructed 
population evolves ga fitness assigned actual execution program individual suitable set test cases genetic operators adapted tree representation 
crossover operation starts selecting random crossover point parent tree exchanging sub trees giving rise offspring trees shown 
mutation implemented randomly removing subtree selected point replacing randomly generated subtree operator seldom 
genetic programming successfully applied wide variety problems fields described 
example gruau chapter volume describes form genetic programming cellular programming language applied neural network design 
problematic step gp choice appropriate language problem 
general problem suggests reasonable set functions terminals case 
experimental evidence shown results obtained slightly different choices clear choice language directly bears hard problem solve gp 
time guideline estimating dependence 
controversial issue size gp trees 
depth trees principle increase limits influence fig 

parent individuals 
offspring 
crossover points marked cross parents 
crossover 
gp systems parameter prevents trees deep filling available memory requiring longer evaluation times 
debate practitioners field trees breed grow maximum depth edit simplify way order obtain shorter programs 
argument larger trees redundant genetic material richer set breeding possibilities may lead increased diversity successive populations 
hand mdl minimum description length principles give rise compact efficient solutions cases 
issue difficult settle due currently limited knowledge dynamics evolution program populations 
plain gp works problems complex give rise relatively short programs 
extend gp complex problems hierarchical principle introduced 
problem solving activity hierarchical considerations needed produce economically viable solutions 
true classical top design form divide conquer strategy routinely decompose problem manageable subproblems 
considerations useful working bottom artificial evolutionary methods 
observed researchers evolution subtrees appear repeatedly population parts successful individuals 
trees perform useful function identified encapsulated modules reused single units evo process 
modules considered analogous building blocks described section similarity qualitative 
methods automatically identifying extracting useful modules gp discussed koza name automatically defined functions adf angeline kinnear 
gp empirically shown quite powerful methodology 
remains seen approach extended automatically evolve programs difficult tasks general programming 
parallel evolutionary algorithms parallel computing various forms key computer technology driven increasing demand better performance productivity 
principle goals met adding processors memory interconnection network putting problem 
sharing workload hoped processor system job nearly times faster uniprocessor system allowing researchers treat larger interesting problem instances 
reality things simple overhead factors contribute significantly lower theoretical performance improvement expectations 
furthermore general parallel programming models turn difficult design due large architectural space span resistance represented current programming paradigms languages 
event parallel computing ubiquitous exist important problems sufficiently regular space time dimensions suitable 
fortunately evolutionary algorithms belong class easy parallel problems 
main reasons parallelizing evolutionary algorithm achieve time savings distributing computational effort second benefit parallel setting algorithmic point view analogy natural parallel evolution spatially distributed populations 
start describing simple useful parallel evolutionary algorithms performance improvements obtained changing general sequential algorithm schema 
real world problems calculation individual fitness far time consuming step algorithm 
case obvious approach evaluate individual fitness simultaneously different processor 
individuals processors case individuals evaluated divided evenly possible available processors 
assumed fitness evaluation takes time individual 
parts algorithm remain centralized 
informal description algorithm produce initial population individuals parallel evaluate fitness individuals parallel termination condition met select fitter individuals reproduction produce new individuals mutate individuals parallel evaluate fitness individuals parallel generate new population inserting new individuals discarding old bad individuals method consists simultaneously independently running copies algorithm available processors 
best multiple independent runs required result 
eas stochastic runs general needed anyway draw statistically significant 
method general preferred respect long single run improvements difficult stages simulated evolution 
various runs differ generation initial population possibly setting parameters crossover mutation rate 
processor computes number generations 
practice communication needed processors stopping computation processor satisfactorily solved problem allotted maximal number generations 
turn genuinely parallel approaches evolutionary algorithms 
find inspiration observation natural populations tend possess spatial structure 
result called demes appearance 
demes semi independent groups individuals subpopulations having loose coupling neighboring demes 
coupling takes form slow migration diffusion individuals deme 
number models spatial structure proposed 
important categories island grid models 
island model features geographically separated subpopulations relatively large size 
subpopulations may exchange information time time allowing individuals migrate subpopulation various patterns 
main reason approach periodically diversity converging subpopulations 
migration takes place nearest neighbor subpopulations model called stepping stone 
subpopulation standard sequential evolutionary algorithm executed migration phases 
depicts distributed model high level algorithmic description process initialize subpopulations size generation number termination condition met subpopulation parallel evaluate select individuals fitness generation number mod frequency send best individuals neighboring subpopulation receive individuals neighboring population replace individuals subpopulation produce new individuals mutate individuals parallel generation number generation number frequency number generations exchange takes place 
individual replacement policies described literature 
common migrating individuals displace worst individuals subpopulation 
noted subpopulation size frequency exchange number migrating individuals migration topology new parameters algorithm set way 
rigorous way choosing 
works empirically arrived similar topologies parameter values 
grid fine grained model individuals placed large toroidal dimensional grid individual grid location fig 

model called cellular 
fitness evaluation done simultaneously individuals selection reproduction mating take place locally small neighborhood 
time fig 

illustration island model semi isolated populations fig 

spatially extended population individuals 
possible neighborhood individual black marked gray 
semi isolated niches genetically homogeneous individuals emerge grid result slow individual diffusion 
phenomenon called isolation distance due fact probability interaction individuals fast decaying function distance 
pseudocode description grid evolutionary algorithm 
grid point parallel generate random individual parallel termination condition met grid point parallel evaluate individual select neighboring individual produce offspring assign offspring mutate probability parallel preceding description neighborhood generally formed nearest neighbors grid point see fig 

selection individual neighborhood mating central individual done various ways 
tournament selection commonly see 
full available parallelism probably appropriate biological point view 
likewise replacement original individual done ways 
example replaced best offspring offspring replace random 
model dynamical adding provisions longer range individual movement random walks having individuals interacting exclusively nearest neighbors 
island grid models implemented serial machines comprising useful variants standard globally communicating ga ideally suited parallel computers 
implementation point view coarse grained island models ratio computation communication high adapted multiprocessor systems clusters workstations 
massively parallel simd single instruction multiple data machines connection machine cm appropriate cellular models necessary local communication operations frequent efficiently implemented hardware 
furthermore noted hybrid models possible example consider island model island structured grid individuals interacting locally 
described software system called unified parallel ga system allows user select parallel ga approaches setting parameters 
general parallel evolutionary algorithms apart significantly faster help alleviating premature convergence problem effective multimodal optimization 
due larger total population size relative isolation spatial regions solutions start evolve 
factors help preserve diversity time promoting local search 
sequential case effectiveness search improved expense generality permitting hillclimbing local improvement promising search points 
spatial dimension entered picture 
take account temporal dimension observe parallel evolutionary algorithms synchronous asynchronous 
island models general synchronous spmd single program multiple data coarse grain parallelism communication phases synchronize processes 
necessary experiments carried asynchronous eas subpopulations evolve pace exchange individuals internally measured level convergence attained 
avoids constraining evolving populations swap individuals time irrespective subpopulation evolution 
fine grained parallel eas fully synchronous implemented simd machines example data parallelism 
genetic programming displays general advantages evolutionary algorithms implemented parallel architectures 
important difference individuals may widely vary size complexity 
precludes simd implementations gp amount local memory needed store individuals efficiency reasons sequential execution different branches code belonging individuals stored different processors 
coarse grain models island model parallel fitness evaluation model suitable gp 
load balancing problem solved aforementioned variability individuals gp 
refs describe different ways attaining load different processors generational synchronization altogether simple load balancing algorithm respectively 
triggered widespread availability parallel computers workstation clusters parallel distributed eas success time 
simple implement offer advantages standard sequential algorithm 
parallelism introduces new degrees freedom dealt implementer theoretical analysis difficult little known date properties 
evolutionary computation resources large amount useful information evolutionary algorithms available internet 
important ga site reached web url www aic nrl navy mil contains wealth information ga related activities conferences courses workshops technical reports source code links related sites 
accessed anonymous ftp address ftp aic nrl navy mil pub possible subscribe low noise ga list digests sent week sending message ga list request aic nrl navy mil 
useful address links interesting information encore site ftp ftp cs wayne edu pub ec welcome html colleagues logic systems laboratory participants evolvable hardware workshop stimulating atmosphere useful discussions 
special sipper carefully read manuscript helped improve style 

thompson harvey husbands unconstrained evolution hard consequences volume 

kitano morphogenesis evolvable systems volume 

mondada floreano evolution mobile autonomous robots volume 

goldberg genetic algorithms search optimization machine learning addison wesley reading ma 

michalewicz genetic algorithms data structures evolution programs springer verlag second edition berlin 

fogel evolutionary computation ieee press new york 

uhlenbein born parallel genetic algorithm function optimizer parallel comput 


syswerda uniform crossover genetic algorithms proc 
third int 
conf 
genetic algorithms schaffer editor morgan kauffman 

goldberg richardson genetic algorithms sharing multimodal function optimization proc 
second int 
conf 
genetic algorithms grefenstette editor lawrence erlbaum associates hillsdale 

yin fast genetic algorithm sharing scheme cluster analysis methods multimodal function optimization proc 
inter 
conf 
artificial neural nets genetic algorithms innsbruck austria 

spears simple subpopulation schemes proc 
evolutionary programming conference 

beasley bull martin sequential niche technique multimodal function optimization evolutionary computation 

hillis evolving parasites improve simulated evolution optimization procedure artificial life ii langton editors addisonwesley 

sipper evolving non uniform cellular automata perform computations physica appear 

potter de jong cooperative coevolutionary approach function optimization procs 
third conference parallel problem solving nature davidor 
schwefel editors lecture notes computer science vol 
springer verlag 

husbands ecosystem model integrated production planning intl 
journal computer integrated manufacturing 

potter de jong evolving neural networks collaborative species procs 
summer computer simulation conference society computer simulation ottawa canada 

davis handbook genetic algorithms van nostrand new york 

koza genetic programming mit press cambridge ma 

kinnear editor advances genetic programming mit press 

iba de garis sato genetic programming minimum description length principle 

cohoon hegde martin richards punctuated equilibria parallel genetic algorithm proc 
second int 
conf 
genetic algorithms grefenstette editor lawrence erlbaum associates 

tanese parallel genetic algorithm hypercube proc 
second int 
conf 
genetic algorithms grefenstette editor lawrence erlbaum associates 

starkweather whitley mathias optimization distributed genetic algorithms parallel problem solving nature lecture notes computer science vol 

schwefel editors springer verlag 

manderick fine grained parallel genetic algorithms proc 
third int 
conf 
genetic algorithms schaffer editor morgan kauffman 

parallel genetic cellular automata application global function optimization proceedings international conference artificial neural networks genetic algorithms springer verlag wien 

distributed genetic algorithms application portfolio selection problems proceedings int 
conf 
artificial neural nets genetic algorithms pearson steele albrecht editors springer verlag 

koza andre parallel genetic programming network transputers computer science department stanford university technical report cs tr 

learning trading models parallel genetic programming system submitted 

gruau artificial cellular development optimization compilation volume 

smith smith unified paradigm parallel genetic algorithms evolutionary computing aisb workshop fogarty editor lecture notes computer science springerverlag 
article processed macro package llncs style 
