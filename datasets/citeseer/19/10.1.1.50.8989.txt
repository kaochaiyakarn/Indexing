technical report may issn meta programming theory systems jonas dell acqua uppsala university computing science department box uppsala sweden phone gamma gamma fax gamma gamma theory system collection interdependent theories stand meta object relationship forming arbitrary number meta levels 
main thesis chapter theory systems constitute suitable formalism constructing advanced applications reasoning software engineering 
alloy language defining theory systems introduced syntax defined collection inference rules 
number problems suitable theory systems discussed program examples alloy 
current implementation issues extensions discussed 
appears chapter meta logics logic programming edited apt turini published mit press 
outline conventional logic program seen nonlogical axioms single theory 
chapter presents thesis obtain powerful tool applications artificial intelligence software engineering consider systems theories pairs theories may stand object meta relationship single theories 
proceed steps 
arguing multi level programming powerful tool advanced applications particular artificial intelligence software engineering sect 


introducing theory systems approach multi level programming sect 


defining formal syntax possible inference system language alloy theory systems programmed sect 


defining models alloy programs sect 


presenting examples problem solving theory systems expressed alloy sect 


discussing self program alloy sect 


proposing extensions supporting technologies current implementation issues sects 

notes 
general meta programming logic programming reader referred overviews hill gallagher 
artificial intelligence software engineering studies artificial intelligence general expert systems particular clear truly useful problem solvers constructed quite different way tried past 
problems current approaches 
lack robustness respect domains 

low adaptability problem solving methods 

failure capture common sense reasoning 
problems difficult believe marginal success far largely attempts addressing carried single level architectures cf 
sterling 
single level architectures mean systems provisions reasoning part beliefs procedures adapting observations 
problems mentioned approached follows 
program solves problems domain system transform program adapt domain 
program represents piece knowledge suitably represented new knowledge system create new program incorporates knowledge old program new knowledge resolving discrepancies 

subprogram carries particular form reasoning system transform similar program carries somewhat different form reasoning better adapted circumstances 

difficult problem 
mccarthy defined program having common sense automatically deduces sufficiently wide class immediate consequences told knows 
heuristics exploring interesting consequences new information finding information necessary solving problem naturally expressed meta knowledge 
heuristics need revised time turn successful 
seen level problem indicating restricted levels 
potential solutions involve writing programs capable observing parts programs ii examining programs reasoning iii creating new programs presumably starting existing programs 
reader note preceding sentence just statement advanced software engineering basic operations useful application areas 
thesis useful methodology building correct software program constructed implicitly writing meta program takes number standard programs transforming combining produce program performs desired task 
standard programs various kinds simple program pieces perform various kinds recursion example sophisticated complex programs carry computation domain program produced 
meta programs may cases simple merely composing transforming programs certain ways 
produced programs satisfy particular criteria example real time constraints meta programs may detailed analysis run generated programs step construction 
advantage outlined approach standard programs completely understood produced programs 
modifications produced programs done changing program generated lead fewer mistakes manual 
programming paradigm truly called high level programming 
main body artificial intelligence reasoning expert systems spent single level formalisms certainly observing multilevel formalism provide better tool attacking fundamental problems 
mention related formalisms chapter remainder book 
logic programming multiple theories formally theory set sentences language including logical axioms language closed inference rules language 
language fixed set sentences language defines theory obtained adding logical axioms language closing inference 
logic programming language definite clauses sld resolution logical axioms concerning herbrand equality 
program set definite clauses defining single theory 
applications involve reasoning appropriate compute theory 
example write program simulates reasoning collection agents representing beliefs agent theory employ sentential view beliefs explicitly mccarthy 
language prevents having theory program internal theories represented way data structures programmer writing ad hoc interpreter simulate inference 
large class applications reasoning software engineering areas naturally written multiple theories multiple theories ought supported directly language 
pi psi pi phi pu psi pu phi phi reflection coincidence generic theory system 
theory systems constitute useful formalism writing kinds programs theories theory system suitable representing reasoning agents parts programs manipulated programs manipulate meta object relationship theories provides inspection control facilities needed kinds applications 
theory systems propose simple structure theory systems appears adequate purposes 
theory system mapping ground theory terms theories 
theory contains theorems theories named pi delta delta delta pi distinguished function symbol write infix notation 
fact restriction theory system theory terms form pi delta delta delta theory system 
theory system thought defined convenient say theory meta theory theory identified pi pi delta delta delta pi 
conversely say theories object theories respect symbol relating theory terms sentences 
theoremhood statement pu psi says pu psi theorem mentioned theories may contain theorems theories pu psi expresses psi theorem theory pi cf 
fig 

note subset theorems form pu delta delta delta left shaded area correspondence theorems pi similarly subset right shaded area pi kind statement defining theory systems called coincidence statement 
program defining theory system fig 
contains coincidence statement pi theories pi exactly theorems 
relation denoted equivalence relation reflexive symmetric transitive 
importantly statement ensures correspondence subset right shaded area absence coincidence statement connection whatsoever theories meta theory 
particular proving pt phi order determine phi theorem requires pi representation assume theories definite clause language set terms language rich variable function predicate symbol oe unique constant oe represents names oe 
similarly formed expression ff unique ground term ff represents ff 
final requirement definite clause language theoremhood statement coincidence statement unique ground atom representing 
define precisely relationship meta theory object theory 
consider theory system pair theories identified theory terms pi meta theory second 
theoremhood reflection principle states pi seen correctness statement interaction metatheory object theory 
coincidence reflection principle states pi pi seen correctness statement coincidence internal theories 
principles valid theory system 
traditional local reflection principle single theory mathematical logic reads pr poeq oe states correspondence provability statement proved provability predicate holds encoding formula oe oe holds 
call statements reflection principles analogy state correspondences names statements statements 
implications equivalences confused inference rules referred reflection principles pi pi phi pi pt phi psi pt phi pt psi meta levels theories 
better name reflection rules linking rules cf 
discussions giunchiglia serafini simpson costantini dell acqua 
sect 
reflection rules corresponding implications theoremhood reflection principle 
fig 
depicts part theory system theory contains theorem pv phi reflection principle requires theory pi contains theorem pv phi pi pi contains phi 
illustrates theory systems may arbitrarily deep theoremhood reflection principle applies level 
example program defining simple theory system 
tim names tim tom tim pi tom tom theoremhood statements specify axioms theory tim 
theoremhood reflection principle statement says theories named tim pi delta delta delta 
theory tim pi tom coincides tom statement 
theories thought representing beliefs agents read statements saying tim believes find tim believes tom tim view tom beliefs correct respectively 
reading deduce tom finds sect 
show derive inference system 
syntax define syntax inference rules informal semantics alloy language computing theory systems 
define section seen core syntax alloy language definite clauses extended name terms name atoms theoremhood statements coincidence statements 
language stage contain negation denials introduced part proving goals usual sld resolution 
sect 
negation examples meaningful alloy extended negation 
formal syntax alloy language components system component defining theory systems theory component defining individual theories 
alphabet 
punctuation symbols part alphabet common components language consists class variables class function symbols class predicate symbols arity collectively function predicate symbols referred functors 
usual function predicate symbols arity referred constants propositional constants respectively 
class predicate symbols include binary symbols name binary symbols denoted propositional constants true false 
function symbols include binary symbol pi 
alphabet collection connectives naming symbols dot 
dot combination variables 
variable called variable dot variable dots general variable dots called dotted variable 
addition system component language binary operators 
letters stand predicate symbols stand function symbols stand variables 
theory component 
define expressions theory component 
simultaneous inductive definition terms atoms queries sentences separate subclasses refer collectively theory expressions 
definition terms atoms notion expression schema 
intuitively schema expression subexpression occurrences replaced dotted variables holes general say level schema conditions holds 


connective variable dots 
ffl letters may subscripted 
ffl jx level schema variable dots 

pdq pdq level schema simply schema mean level schema 
immediate consequence definition schema subexpression replaced variable dots dotted variable occurs nested gamma pairs 
example binary functor pg schema pg 
terms 
class terms class satisfying conditions 

variable constant term 

function symbol arity terms term 

schema functor theory expression term called name term 
letters terms 
atoms 
class atoms class satisfying conditions 

predicate symbol arity terms atom called predication 

schema term schema sentence pt psq atom called name atom 

schema term schema term pt pu atom called name atom 
letters atoms 
shorthand pt sq pt psq pt pt pu 
follows easily definitions terms atoms variable dots embedded nested levels naming 
variable dots lowest dot hole innermost pair dot pair 
demo case pt sq shorthand familiar demo pt psq 
variable called free corresponding term atom 
example free variable name term pf name term name atom said proper ground 
consider example pf zq name atom proper contains free variable occurrences different variables 
proper names tell expression name 
queries 
class queries class satisfying conditions 

atom query true called empty query 

queries query 
letters queries 
sentences 
class sentences class satisfying conditions 

atom query sentence called program clause 

query 
sentence called goal 

query shorthand false sentence called denial 
variables program clause denial universally quantified 
goal hand negation denial existentially quantified false false system component 
language system component kinds expressions theoremhood statements coincidence statements 
ffl term called theory term context sentence theoremhood statement 
ffl theory terms coincidence statement 
collectively referred system expressions 
normalized language order able handle terms conventionally want term normal form naming symbols eliminated 
call elimination process normalization result normalized term 
context gamma function mapping expressions expressions gamma required compositional order enhance expressive power language 
means compound expression expressed composition pe addition vq clearly exist different normalizations 
probably general approach binary function symbol ffi denoting composition function produces name compound expression name functor connective list names expressions 
approach notion lists needed accomplished binary function symbol ffl constant represent empty list 
cumbersome notation jx ffl ffl delta delta delta ffl delta delta delta 
alphabet assumed unique name symbol way mapping 
injective 
names terms normalization described transformations 
eq gamma 
gamma 
symbol pe gamma 
ffi pe pe pe jx pe gamma 
ffi pe pe pe take advantage restriction imposed definition schemas disallowing holes connectives modifications transformations 
connective alphabet corresponding function symbol arity case example pe gamma 
pe pe get similar transformations connectives 
example normalization normal form pf obtained follows 
pf gamma 
ffi gamma 
ffi ffi gamma 
ffi ffi ffi ffl symbol name gamma 
ffi ffi ffi ffl ffi ffl gamma 
ffi ffi ffi ffl ffi ffl ffi ffl unnecessary naming ffi ffl avoided defining transformation ffi ffl transparent respect naming gamma 
ffi gamma 
ffi pe pe ffl gamma 
ffl pe pe 
note violate injectivity naming function 
assuming modification example pf gamma 
ffi inference system equality naming unification 
normalizing language program extend theories axiom form names term 
normalizing described sect 
usual herbrand equality theory axiomatized clark 
computation naming relation ought integrated unification order delay computation names nonground terms 
correct normalizations behave way respect equality normalized expressions alternatively conceivable extend herbrand equality name expressions normalization 
inference rules 
inference system explain means possible inference system alloy fact complete 
choose inference system presentation simple complete propositional programs 
actual implementation presently developing goal oriented inference system outlined sect 

main purpose inference system able prove statements form goal 
theorem theory accomplished refutation assuming proving inconsistency proof may include refutations subproofs 
successful refutation denial ended cancelling concluding 
application rr rule described 
shall inference rules 
rule ordinary theory 
denote atom selected query rest query 
assumed predicate symbol selected atom names 
rs mgu second rule relativized raa rule allowing subproofs refutations 

rr cancel 
third fourth rules reflection rules justifiable theoremhood reflection principle sect 

meta object relationship pair theories directions theory reasons internal theory contains sentence pi contains vice versa 
td pi pi tu fifth sixth rules similar third fourth justifiable coincidence reflection principle 
express theory theorem stating internal theories coincide may infer theories coincide vice versa 
cd pi pi pi pi cu seventh rule uses coincidence theories transfer theorem 
ce inference rules derive example indirect sld resolution inference 
cq dq mgu derived inference rule justified td cq pi dq pi td pi tu rs useful derived rule indirect reasoning coinciding theories justified follows 
cd pi pi pi td pi tu ce example consider example sect 

prove statement tom tom 
tim tom rs tim names rs tim names tom nm tim true rr cancel tim tom td tim pi tom tom 
ce tom tom 
mentioned inference system incomplete 
done order increase number provable statements care proofs involve improper names 
see sect 
discussion done 
semantics set theory terms fm family arbitrary order structures language theory expressions normalization 
elements called theory structures 
system structure pair hm ji elementary equivalence relation 
order structures said elementarily equivalent set logical consequences 
alloy program set system expressions hm ji system structure 
theory structures herbrand interpretations assume loss generality ground herbrand instantiation possibly infinite underlying nonground program 
say hm ji model hold pi need restrict herbrand interpretations 
pi pi pi pi pi pi ground term names conceptually set theoremhood statements partitioned theory terms 
part identified theory term denotation model part 
coincidence statement theory terms enforces structures denote elementarily equivalent 
theoremhood coincidence reflection principles satisfied theory structures 
furthermore pi associative respect elementary equivalence denoted structures 
formulas easily deduce pi names predicate symbol denote naming relation restricted terms relates ground term name 
clear set logical consequences theory structure closed sld resolution set theorems order structure complete 
considering special case just horn clause program sentences form horn clause theory term notion system structure collapses order structure 
case conditions trivially satisfied 
extra requirement part standard definition model 
approach altered notion logical consequence done example jiang order handle meta reasoning 
introduce notion system structure closely informal semantics giving notion semantics modest extension order semantics sense basic building blocks theory structures order structures 
thorough investigation semantics alloy subject publication 
applications theory systems section shall number useful applications metaprogramming theory systems commonly known new 
shall show fragments applications programmed elegantly alloy 
ambition twofold 
firstly wish convince reader strength versatility meta programming theory systems continuing extending bowen kowalski sterling bowen brogi turini 
secondly hope illustrate programming alloy problems programmed straightforward concise way single level programming single theory meta programming 
reasoning agents forms reasoning artificial agents proposed abductive reasoning inductive reasoning non monotonic reasoning case reasoning temporal reasoning 
favourite approach philosophers researchers artificial intelligence invent new specialized logic forms reasoning 
problems approach 
clear logics combined build artificial agents capable form reasoning 
efficient implementation techniques known new logics 
sensible method employ single logic known properties implemented subset classical logic 
forms reasoning mentioned mapped straightforwardly classical logic 
argument logic reasoning agents 
fortunately partial solution 
go single level logic languages meta logic languages theory systems obtain modest extension classical logic terms semantics get substantial extension terms reasoning capabilities express various forms reasoning logic 
approach sensible recognizes forms reasoning contain substantial element meta level reasoning 
example default reasoning involves observing question decided making hypothesis recognized answer 
alloy represent agent beliefs theory internally defines system theories 
theories represent correctly incorrectly agent view agents beliefs ambitions motives cf 
fig 

theories represent agent beliefs surroundings various domains 
presumably theories encode various problem solving strategies tactics 
approach advantages 
ffl modularity 
agent mind internally structured 
ffl multiple levels 
possible represent beliefs procedures various meta levels theories synthesizing problem solving procedures specific domains represented lower theories 
ffl 
theory representing beliefs agent clearly separated theory representing agent beliefs agent beliefs formalism create mind reading confusion explicitly programmed 
pi reflection agent distorted view beliefs agent constituting theory pi driver car coming south pass crossing ffl generality 
various properties knowledge beliefs see section programmed system automatically 
example programming multiple agents reason consider traffic problem illustrated fig 

cars simultaneously approaching way crossing 
signs traffic lights rule drivers give way cars coming right side 
simple application rule obtain car pass cars wait give way car right side 
driver car reason car wait driver car see car right entering crossing give way 
driver car conclude safely pass 
purpose argue legal driver car pass argument show multiagent reasoning programmed straightforwardly alloy 
statement encodes problem driver car traffic pd south pass north east south theory traffic reasoning drivers take place 
theory traffic pi represents view beliefs driver car coming direction theory traffic pi pi represents view beliefs driver car coming direction beliefs driver car coming direction theorem pass theory delta delta delta pi mean driver question believe pass crossing sees cars listed similarly theorem wait mean believe 
clauses interesting help encode form group belief 
traffic driver traffic driver pi driver atom form driver pi delta delta delta pid theorem traffic 
example derive traffic driver south south traffic driver south pi east pi north north 
note theorem theory term encoding driver view driver view driver beliefs ultimate driver chain 
predicate driver traffic expressing believed driver driver believe drivers believe arbitrarily deep 
easy observe real drivers reason exactly way 
clauses define actual reasoning 
traffic pass crossing driver names names gives way traffic wait crossing names names pass driver names names gives way traffic pass crossing names names wait qq driver names names gives way clause says driver reason car approaching direction give way may pass 
second clause says driver reason car approaching direction give way believe driver reason pass wait 
third clause says driver reason car approaching direction give way believe driver reason wait pass anyway 
clauses traffic simply determine yield 
traffic gives way north west traffic gives way west south traffic gives way south east traffic gives way east north predicates crossing crossing list membership predicates predicates part group belief drivers alternatively placed theory traffic pi delta delta delta 
traffic crossing xj driver names traffic crossing jc crossing driver names traffic crossing driver names traffic crossing crossing driver names full proof original statement long involves proving statements 
traffic pi south pi east pi north pass north east south 
traffic pi south pi east wait north east south 
traffic pi south pass north east south 
traffic pd south pass north east south properties knowledge formalisms intended knowledge representation reasoning metareasoning konolige modal logic knowledge build various properties knowledge belief formalism 
known properties kind notation konolige bel set beliefs agent oe proposition agent believes oe saturation 
reasoners closed inference bel saturated 
knowledge 
knowledge beliefs true oe bel oe true 
consistency 
reasoners supposed consistent knowledge oe bel oe bel 
positive introspection 
reasoners believe believe believe oe bel oe bel 
negative introspection 
reasoners believe believe believe oe bel oe bel 
alloy intended things applications kind property built language 
express properties part meta programs 
possible model reasoning agents properties quite different properties 
show properties represented suitably extended version alloy 
assume theory defines internal theory system beliefs agent represented theory identified pi outside 
saturation property built alloy theories closed inference 
means alloy represent directly agents beliefs closed inference 
knowledge postulate expressed particular binary predicate theoremhood statement pb names names express postulate predicate symbol meta theory variant postulate expressed pw pb internal theory contains view world 
statement says believes believes atom atom contained beliefs world 
consistency consistency reasoner expressed integrity constraint pb pq pb pq alloy currently inference rules take integrity constraints negation account 
positive introspection straightforward pb pb qq names negative introspection alloy extended negation negative introspection easy pb pq pb qq names program composition operators brogi mancarella pedreschi turini proposed algebra operators composing logic programs 
operators union intersection encapsulation import programs respectively 
meta interpretive definition coded elegantly alloy provided choose unary binary function symbols constructing theory terms stand theories resulting operations 
theories logic program theory operators constitute theory system internal theory definition contains theoremhood statements define theorems theories named operator expressions 
represent operators function symbols respectively 
pu cq cq pu cq cq pi cq partition pe pt cq partition straightforward program uses ground representation elegant program brogi uses nonground representation 
assume ternary predicate partition defined compute partition conjunction pair possibly empty unitary conjunctions 
example consider program algebra basic theories rules public private 
alloy program clauses theories appear theoremhood statements pi rules delta delta delta pi public delta delta delta pi private delta delta delta respectively 
add coincidence statement pi rules private public order define theory subsequently queried 
query computed composed theory rules private public 
implicit programming essentially programs today written manually programmers 
programmers build past experience directly programs written past 
happens time existing program needs modification may see writing program perform computation existing program 
happen ways 
program piece reused abstraction provides exactly sought 
typically pieces existing program need systematically rewritten way example extra argument need added procedure base case replaced 
existing program needs extensive rewriting basic structure remains recursion pattern 
really done systematically useful methodology 
existing program expected small change transforms known way may confidence program resulting sequence changes computes expect 
serious problem today modifications kind outlined rarely carried 
resulting program expected expensive corrective required 
may know program error free 
suppose partly automate process programmer take program program fragment specify exactly modifications done 
requested transformation applied process continued desired program created 
collection generally useful program fragments programmer build entirely new program incorporating transforming components 
alternative discussed realm functional programming provide powerful abstractions problem coded terms high level abstractions 
approach mathematically appealing turned practical approach programming 
process outlined closer approach taken actual programmers useful reasoning exactly resulting programs 
detailed comparison approaches necessary 
example show simple program adds extra argument predicate 
transformation program theory called dq cq cq vj true true cq dq assume predicate defined compute second argument variable name occur name argument 
order program view inspected defined theories coincide actual theories wish inspect define pi pi extend likes henceforth theory exactly theory clause contains predication likes delta delta delta replaced clause predications replaced likes delta delta delta variable occur original clause 
self reader may noted avoided circular theories 
automatic mechanism gives theory access information provability 
advantages systems contain self referring theories theories really reflect views 
example paradoxes implementation simpler efficient 
disadvantage prohibiting avoiding self course reduced expressivity 
possible define agents truly introspect 
open question time serious restriction prohibit self completely clear sufficiently high tower theories meta theory theories 
close approximation single theory meta theory obtained infinite tower identical theories meta theory theories 
tower expressed alloy 
wished alloy theory pi truly self referential theory pi add equivalent statements pi pi pi pu pi program 
easy show statement model hm ji program piu pii piu pi observes theory calls really pi 
way self pi may query querying theory calls may compute clauses add contains clauses pi pq delta delta delta delta delta delta 
allow pi query add clauses adding simple equivalent ways theoremhood statement pu pi pq pu pq program 
easy show piu piu pii satisfied piu satisfied piu pii pi pi includes image pi note clause added pi order achieve effect 
rationale simply self sanctioned outside theory 
abduction abduction form reasoning purpose determine hypotheses explain observation typically context knowledge assimilation 
abductive reasoning particularly interesting combination meta reasoning 
suppose beliefs john represented theory beliefs john internally defines theory system theory beliefs mary representing john beliefs mary beliefs 
suppose beliefs john likes names names statement believe smile 
john notices mary smiling assume belief mary john appears john beliefs calling explanation 
performing abductive reasoning hypothesis mary likes mary john appears candidate inclusion beliefs john imply observation 
john assume mary believes likes 
course merely simple example area agents performing meta reasoning actions beliefs motives ambitions clearly abductive reasoning needs carried part meta reasoning 
abductive reasoning carried ways 
way add inference rules abductive reasoning obtaining new abductive proof procedures 
possible realize abductive reasoning meta level deduction suggested bowen kowalski 
achievement abductive reasoning meta reasoning topic ought explored theory systems 
implementation language extensions implementation efforts extending luther instance warren prolog machine 
idea generalized sld resolution rule essentially efficient prolog regardless number indirection levels 
possible representing clauses theories exist view theory ordinary machine code 
interesting difficulty program clause explicit axiom theory obtained computation meta theory current theory 
intend solve creating program clause directly parts program clause explicit meta theory carry computation meta theory 
example illustrate technique 
consider program fragment 
tm pi tm pto zq prove atom tm pi carry computation tm complete name clause delta delta delta delta delta delta delta delta delta delta delta delta dotted parts filled atom tm computing clause waste resources easy exemplified suppose goal atom 
unification goal atom head generated program clause fail immediately computation tm program clause worthless 
compile part code reachable clause names names ff see parts clause explicitly metalevel clause clause 
names atoms constrain variables value obtain name unified respectively 
expression ff best described call value worst case require interpreter situation value usually taken context machine code available named query 
case code care 
consider goal atom see clause fail computing part body 
mentioned style computation described realizes different inference system described sect 

system computations various theories interleaved shown example 
idea goal directed possible 
clear negation kind added language explicit negation negation failure 
incorporate negation failure alloy investigate merits monotonic version negation failure theory finitely failed proof obtained explicitly 
interesting incorporate form abductive procedure alloy natural links meta reasoning abduction pointed sect 

denials formally language function integrity constraints part program 
notes related changes definition alloy previous publication 

theory terms include expressions form delta delta delta pi delta delta delta 

addition program clauses alloy goals denials 

called tagged program clause called theoremhood statement may contain sentence 

representation statements generalized coincidence statements representation statement written pi 
allowed generalize reflection rules simplify inference system considerably 

sld resolution style inference rule inference rule program clauses 
obvious knowledgeable reader development alloy inspired kowalski reflective prolog costantini 
appeared proposals systems meta reasoning similar philosophy 
attardi simi call relativized truth obtain system quite similar 
significant difference choose duplicate inference system natural deduction system rules object level meta level 
basic axioms meta level ensures positive introspection 
preferred epistemic bias saturation 
giunchiglia defined multilevel deduction system distinct levels called mk 
theory meta level communication meta levels similar alloy 
basis reasoning part getfol system capable code introspection revision 
proposal meta programming software engineering methodology related proposal kowalski meta language assembling programs brogi theory operators building programs discussed detail sect 

bowen weinberg investigated compilation partially known clauses context similar 
sato proposes approach meta programming complete truth predicate tr valued logic 
sato definition tr self referential gives general case inconsistent definition tr valued logic paradoxical 
slight modification definition tr introduces valued complete demo predicate 
language fully amalgamated theory part alloy corresponds 
note system part theory part alloy clearly separated syntactically semantically 
main similarity approach meta programming ability reason levels possible tr making possible express tr tr nesting arbitrary depth 
furthermore naming alloy structural coding possible terms formulas parts look example codes functors 
jiang proposes ambivalent approach meta reasoning introducing language called syntactically distinction terms formulas functors 
jiang takes radically different approach defining calls herbrand semantics build standard notion logical consequence order model theory 
hard form definitive opinion proposed semantics defined understood having guess intentions 
inference system hint possible implementation proposed ideas 
noted extent captures meta programming done prolog operational semantics 
syntactically main similarity approach possibility express reasoning meta levels 
main distinction naming coding involved formulas occur directly subexpressions formulas 
program clause example expressed bel tim bel idea expression interpreted function relation determined context appears 
christiansen proposed amalgamated language levels reasoning 
operational semantics language instance predicates relating names formulas instance 
shown kowalski developed hill gallagher instance predicates meta variables replacing names subexpressions way turns operationally similar way variables represented nonground representations 
seen article alloy language development 
conclude allows direct way expressing multilevel knowledge particular recursive beliefs 
main difference alloy mainstream meta logic programming lies support arbitrary meta levels self exception rule 
may certainly doubt language claimed powerful efficiently implementable proved actual implementation way 
reason hope belief computation deduction single theory may view view theory possible support essentially efficiency ordinary prolog system 
difficulties lie meta programming specific parts fact ways piece information meta programming setting 
example program clause may deduction name may data may name name program clauses computed names holes manageable obstacle efficient computation 
research influenced valuable discussions colleagues particularly costantini gaetano andreas partners project particularly antonio brogi pat hill bob kowalski john lloyd 
research reported supported financially swedish national board technical industrial development contract esprit brp computational logic 
family continuing support 
attardi simi building proofs context turini ed proc 
meta lncs springer verlag berlin 
meta level programming compiled approach 
lassez ed proc 
th intl 
conf 
logic programming mit press cambridge mass 
metaprogramming logic technical report uppsala univ computing science dept published encyclopedia computer science technology marcel dekker new york 
dell acqua basis multilevel metalogic programming language turini ed proc 
meta lncs springer verlag berlin 
luther wam emulator tech 
rep comp 
sci 
dept uppsala univ uppsala 
bowen weinberg meta level extension prolog cohen eds proc 
symp 
logic programming ieee comp 
soc 
press washington 
bowen meta level programming knowledge representation new generation computing 
bowen kowalski amalgamating language metalanguage logic programming clark eds logic programming academic press london 
brogi mancarella pedreschi turini composition operators logic theories lloyd ed computational logic springer verlag berlin 
brogi program construction computational logic ph thesis dipartimento di informatica universit di pisa 
brogi godel meta language composing logic programs turini ed proc 
meta lncs springer verlag berlin 
brogi turini metalogic knowledge representation allen fikes sandewall eds principles knowledge representation reasoning proc 
nd intl 
conf morgan kaufmann los altos calif 
christiansen efficient complete demo predicates definite clause languages technical report dept computer science roskilde university 
clark negation failure gallaire minker eds logic data bases plenum press new york 
costantini dell acqua extending horn clause theories reflection principles pearce pereira eds logics artificial intelligence lnai springer verlag berlin 
costantini metalogic programming language levi martelli eds proc 
th intl 
conf 
logic programming mit press cambridge mass 
giunchiglia cimatti introspective metatheoretic reasoning turini ed proc 
meta lncs springer verlag berlin 
giunchiglia serafini simpson hierarchical meta logics intuitions proof theory semantics ed metaprogramming logic lncs springer verlag berlin 
hill gallagher meta programming logic programming technical report school computer studies univ leeds published handbook logic artificial intelligence logic programming vol 
oxford science publ oxford univ press 
jiang logic semantic basis metalogic programming van hentenryck ed logic programming proc 
th intl 
conf mit press cambridge mass 
kakas mancarella abductive logic programming proc 
workshop non monotonic reasoning logic programming mcc austin texas 
konolige deduction model belief pitman london 
kowalski logic problem solving north holland new york 
kowalski metalanguage assemble object level programs programs report imperial college london 
kowalski meta matters invited presentation second workshop meta programming logic 
kowalski problems promises computational logic lloyd ed computational logic springer verlag berlin 
mccarthy programs common sense minsky ed semantic information processing mit press cambridge mass 
mccarthy order theories individual concepts propositions meltzer michie eds machine intelligence edinburgh university press edinburgh 
sato meta programming truth predicate apt ed proc 
joint intl 
conf 
symp 
logic programming mit press cambridge mass 
incompleteness theorems barwise ed handbook mathematical logic north holland amsterdam 
sterling logical levels problem solving logic programming 
warren prolog instruction set sri tech 
note sri intl menlo park calif 
