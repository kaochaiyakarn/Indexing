retargetable compiler ansi christopher fraser bell laboratories mountain avenue murray hill nj david hanson department computer science princeton university princeton nj lcc new retargetable compiler ansi versions vax motorola sparc mips production princeton university bell laboratories 
exceptions little lcc unusual integrates engineered existing techniques smaller faster compilers generates code comparable quality 
lcc target independent front performs simple effective optimizations contribute code examples include simulating register declarations partitioning switch statement cases dense tables 
implements target independent function tracing expression level profiling 
reprinted sigplan notices oct 
copyright association computing machinery reprinted permission 
lcc new retargetable compiler ansi 
ported vax motorola sparc mips production princeton university bell laboratories 
compliant preprocessor library lcc passes conformance section version plum hall validation suite ansi reports describe lcc storage manager intermediate language code generator register manager 
report surveys remaining features lcc may interest readers 
chief performance aspects design support performance features debugging profiling user code 
design exceptions lcc uses established compiler techniques 
front performs lexical syntactic semantic analysis machine independent optimizations described 
lexical analyzer recursive descent parser hand written 
theoretically approach complicates changes fixing errors accommodating change important standardized language ansi lexical syntactic errors 
percent lcc code concerns parsing error rate code negligible 
despite theoretical prominence parsing relatively minor component lcc compilers semantic analysis optimization code generation major components account code errors 
target independent front target dependent back packaged single program tightly coupled compact efficient interface 
interface consists shared data structures functions operator dag language 
functions emit function define globals emit data simple 
dag language encodes executable code lcc front sample code generator available anonymous ftp princeton edu 
file readme directory pub lcc gives details 
describes current availability lcc production code generators 
generated component code rules code generator front back support vax mips sparc vax sparc symbol table emitters naive vax code generator rule compiler table number lines lcc components 
source program corresponds intermediate language compilers smaller typical intermediate languages 
describes interface 
code generators generated automatically compact rule specifications 
rules rewrite intermediate code naive assembly code 
peephole optimize result 
compiled monolithic hard coded program accepts dags annotated intermediate code generates optimizes emits code target machine 
hard coding contributes significantly lcc speed 
table shows number lines lcc components 
notation indicates lines definitions header files lines code 
back support back code shared back ends initialization register manager 
target specific files include configuration header file defines parameters widths alignments basic datatypes target specific interface functions emit function code generation rules code generators generated rule compiler written icon 
retargeting lcc requires involves writing back components vary lines existing back ends 
practice new back ends implemented writing new rules editing copies existing configuration set interface functions 
lcc production back ends technology summarized detailed 
interface front back depend technology back ends conform interface specification 
example details hand written code generator emits naive vax code 
lcc uses established techniques uses incarnations contributes lcc efficiency described 
lexical analysis design input module lexical analyzer judicious code tuning lexical analyzer contribute lcc speed 
input lexical analysis variations design described 
lexical analyzer module inspects input character design avoids extraneous character processing minimizes character movement scanning tokens directly large input buffer 
input read directly operating system character buffer depicted cp limit delimit portion buffer 
token scanned cp limit fence characters oe read cp limit fence characters oe cp fence input buffering 
advancing cp white space switching character token cp 
cp advanced token recognized 
newlines denoted occur tokens explains newline limit shown 
newline terminates scan token separate character test buffer unnecessary 
newline encountered input module function called refill input buffer necessary increment line number 
ansi stipulates maximum line length compilers insist specific limit 
tokens limited characters string literals exception handled special case 
general input buffer ends partial token 
insure entire token lies cp limit buffer moved memory locations preceding buffer cp passes fence 
doing concatenates partial token tail read shown 
testing cp passed fence done token cp advanced white space 
important consequence design input characters accessed cp moved 
identifiers excluding keywords string literals appear executable code copied buffer permanent storage 
algorithm moves partial lines partial tokens scanning newline buffer 
operation overwrites storage buffer partial line longer fixed maximum 
algorithm avoids problem token cost comparing cp fence 
cp suggested cp copied register variable rcp entry lexical analyzer rcp token recognition 
rcp assigned cp lexical analyzer returns 
rcp improves performance scanning loops compact fast white space elided map rcp blank rcp map mask classifies character suggested map blank non zero white space character newline 
lcc generates vax instructions body loop incl map rcp register 
optimizing compilers similar improvements locally potentially aliased assignments calls irrelevant functions 
keywords recognized hard coded decision tree case rcp map rcp digit letter cp rcp return rcp rcp map rcp digit letter cp rcp return int goto id int defined token codes keywords int respectively id labels code scans identifiers 
code generated automatically line program included lexical analyzer compilation 
vax code generated fragment follows rcp 
map addl cp movl ret map addl cp movl ret keyword int recognized dozen instructions executed table searched keywords perfect hashing 
compilers strings saved identifiers string literals hashed table string appears saves space 
performance variants installing strings digits strings known length 
installation strings known addresses characters accessed output 
example looking name symbol table done hashing address name string comparison unnecessary 
symbol tables fast symbol table manipulation contributes lcc speed 
took versions symbol table module arrive current 
symbols represented structures defined struct symbol char name symbol name int scope scope level 
symbol table module uses hash tables symbol tables initial version single table scopes struct entry struct symbol sym symbol struct entry link entry hash chain struct table struct entry buckets hash buckets symbols wrapped entry structures keep linkage information private symbol table module 
scope entry required code 
new symbol added head hash chain hid symbols names appeared chains 
scope exit entries current scope level indicated value level removed table tp code struct entry tp buckets sym scope level link tp buckets measurements revealed code accounted percent lcc execution time typical input 
code scanned hash buckets scopes introduce new symbols common second version symbol table module separate hash table scope level struct table struct table previous table lower scope struct entry buckets hash buckets searching symbol took number comparisons required traversal list separate tables struct symbol lookup char name struct table tp struct entry unsigned unsigned name tp buckets link name sym name return sym tp tp previous return notice symbol names compared simply comparing addresses explained previous section 
despite conventional wisdom hashing functions power gave better performance prime modulus place masking slowed lcc 
variation reduced scope exit code tp tp previous table tp 
unfortunately scope entry required allocation initialization table struct table new struct table alloc sizeof new new previous tp new buckets tp new time wasted scope exit version traded similar waste scope entry second version 
symbol table module actual avoids waste lazy allocation initialization tables 
tables include associated scope level struct table int level scope level table struct table previous table lower scope struct entry buckets hash buckets new tables allocated initialized symbol installed struct symbol install char name struct table tpp unsigned unsigned name struct table tp tpp struct entry struct entry alloc sizeof tp level level int struct table new struct table alloc sizeof new new previous tp new level level new buckets tpp tp new sym name name sym scope tp level link tp buckets tp buckets return sym scopes delimited compound statements declare new symbols lazy allocation code rarely executed entry scopes nearly free 
scope exit code check discarding table remains simple tp level level tp tp previous design simplifies access separate tables 
example table holds globals list identifier tables making value globals symbols installed directly 
initial implementation global declared nested scope inserted middle hash chain 
storage management allocation deallocation early versions lcc accounted significant portion total execution time 
replacing naive malloc free reduced total execution time percent 
detailed allocation lifetime objects allocated objects lifetime freed 
approach storage management simplified lcc code 
initially object type explicit deallocation code replicated points 
code intricate involving complex loops recursive data structure traversals 
allocation incurred obligation provide necessary deallocation code tendency algorithms avoided allocation expense time complexity flexibility 
easy forget deallocation resulting storage leaks 
current scheme eliminated nearly explicit deallocation code simplified compiler eliminated storage leaks 
importantly encouraged simple applicative algorithms rewriting trees 
replacements cost space time allocation deallocation nearly free 
contributing fast compilation visible benefit approach lcc imposes arbitrary limits input permits number cases switch statements number parameters locals block nesting depth expressions arbitrary complexity initializations arbitrary size quantities limited memory available 
optimization lcc properly called optimizing compiler global optimization se 
front perform simple target independent transformations help back ends generate local code 
front eliminates local common subexpressions folds constant expressions numerous simple transformations improve quality local code 
improvements simple tree transformations lead better addressing code 
front lays loops reduce number branches code form goto goto goto omitted initially non zero 
addition front eliminates branch chains dead branches 
selection code switch statements generated entirely front 
generates binary search dense branch tables density percentage non default branch table entries 
example default density switch statement case values vax selection code 
register holds value switch expression label statements case values default label 
movl jmp long movl jmp long movl jmp long density changed command line option yields single branch table switch statement requires branch tables fully populated 
front simulates register declarations scalar parameters locals referenced times addresses taken explicitly 
locals announced back ends explicitly declared register locals followed remaining locals order decreasing frequency 
top level occurrence identifier counts 
occurrences loop arms statement case switch statement count respectively 
values adjusted account nested control structures 
section describes estimated counts may replaced counts actual profile 
scheme simplifies register assignment back ends explicit register declarations rarely necessary 
example strcpy char char yields vax code strcpy word movl ap movl ap movb ret features lcc provides noteworthy features help users develop debug profile ansi programs 
example option causes lcc print ansi style declarations defined globals functions 
instance code adapted section typedef struct point int point typedef struct rect point pt pt rect point point return int point rect return pt pt pt pt generates declarations extern point point point extern int point rect editing output simplify conversion ansi option causes lcc issue warnings declarations casts function types prototypes 
include pointers functions easy overlook updating pre ansi code 
example char alloc updated char alloc 
debugging lcc supports standard debugger symbol tables 
options assist program debugging 
dereferencing zero pointers frequent programming error 
systems execution continues consequences cause fault unrelated actual point error 
help catch errors option causes lcc generate code test dereferencing zero pointers 
zero pointer detected offending file name line number reported standard error null pointer dereferenced foo program terminates calling standard library function abort 
languages provide built facilities tracing function calls returns 
option instructs lcc generate calls printf user specified equivalent just entry function just return 
entry code prints arguments return code prints value returned 
example calling functions shown elicit messages point point called returned point point rect pt point pt point called returned long lines folded fit page 
illustrated output messages show full details arguments including structure contents 
numbers follow function names activation numbers help locate specific call return 
debugging options implemented entirely front available lcc targets 
profiling lcc supports prof style viz 
prof command gprof style execution profiling 
profilers sample location counter periodically obtain estimate percentage total execution time spent function report number calls function 
long standing advice lcc supports frequency profiling 
option causes lcc emit counters record number times expression executed values counters written file prof program terminates 
companion program reads prof prints source code annotated execution counts 
main 
queens return 
queens int rows rows print queens rows 
execution counts enclosed angle brackets 
counts outermost braces queens give number calls 
line shows benefit associating count expression line counts reveal tested slightly third number times statement executed 
conditional expressions annotated similarly 
users report bug see line executed number times 
counts consequence way lcc lays loops eliminates test iteration described 
data prof accumulates possible execute program repeatedly display cumulative frequencies 
method particularly useful developing test data exercises parts program 
highlights untested code 
option causes lcc read prof counts compute frequency identifier estimates described previous section 
doing may reduce number uses identifiers appear loops rarely executed increase number uses appear arms executed time 
complex preprocessor macros obscure presentation 
necessarily uses source coordinates annotate pre expansion source files 
profiling code records number calls call site reconstruct dynamic call graph 
prints line edge queens main queens queens print queens output shows calls queens call character line 
kind data particularly helpful identifying hot spots caused inappropriate calls function inefficiencies function 
data help identify functions profitably replaced functions handle common case efficiently sec 

expression execution frequency profiling implemented entirely front 
machine dependency name ultimate termination function revised exit function writes prof program termination 
implementation machine independent variation method described 
front generates array counters file starts expression code increment appropriate counter 
builds parallel array holds source coordinates corresponding counter 
entry point function front generates equivalent link extern struct link prologue callee structure generated file static struct struct link unsigned unsigned counts unsigned coords struct func counts coords fields point arrays mentioned entries 
entry point code uses link field add file structure list headed revised exit function walks emit prof 
prologue accumulates dynamic call graph 
passed func structures function appear list emanating struct func struct func link struct caller struct caller link struct callsite caller unsigned count callers char name unsigned coord name coord fields give function name source coordinate respectively 
callers points list caller structures call site 
caller structure records number calls caller callsite struct callsite char file char name unsigned coord caller structures allocated execution time point callsites generated front compile time 
just call front generates assignment pointer callsite structure global variable caller 
prologue uses caller record edge dynamic call graph 
record caller exists count simply incremented 
caller structure allocated prefixed callee list callers 
prologue struct func callee static struct caller callers static int struct caller callee callers link caller caller count break sizeof callers sizeof callers callers caller caller count link callee callers callee callers caller profiling restricted files interest 
counts printed correct edges may omitted call graph 
example calls calls compiled profiling report called total number calls function correct 
performance lcc emits local code comparable emitted generally available alternatives 
table summarizes results compiling executing programs spec benchmarks compilers machines listed 
configuration details listed machine 
cc gcc denote respectively manufacturer compiler gnu compiler free software foundation 
times elapsed time seconds lowest elapsed times runs lightly loaded machines 
reported runs achieved percent utilization ratio times user system elapsed 
entries indicate compilation default optimization includes global optimizations 
lcc performs global optimizations 
gcc gcc figures gcc mips missing benchmark execute correctly compiled gcc 
lcc faster compilers 
table parallels table shows compilation time execution time 
mips times running compiler proper preprocessing assembly linking time included 
times mips manufacturer cc front consists programs translates benchmark compiler 
gcc 
espresso 
li 
eqntott vax microvax ii mb running ultrix lcc cc gcc cc gcc sun mb running sunos lcc cc gcc cc gcc mips iris mb running irix lcc cc gcc cc gcc sparc sun mb running sunos lcc cc gcc cc gcc table execution time spec benchmarks seconds 
benchmark compiler 
gcc 
espresso 
li 
eqntott vax lcc cc gcc lcc cc gcc mips lcc cc gcc sparc lcc cc gcc line counts table compilation time spec benchmarks seconds 
compiler vax mips sparc lcc cc gcc table sizes compiler executables kilobytes 
code second generates object code 
generating assembly language costs generating object code table gives times compilers 
row table lists number non blank lines total number lines benchmark preprocessing 
lcc smaller compilers 
table lists sizes compilers kilobytes 
entry sum sizes program data segments indicated compiler reported unix size command 
aho sethi ullman 
compilers principles techniques tools 
addison wesley reading ma 
american national standards institute new york 
american national standard information systems programming language ansi 
baskett 
best simple code generation technique loops 
sigplan notices apr 
bentley 
writing efficient programs 
prentice hall englewood cliffs nj 
bernstein 
producing code case statement 
software practice experience oct 
computer science division department electrical engineering computer science university california berkeley ca 
unix user manual guide virtual vax version edition mar 
fraser 
language writing code generators 
proceedings sigplan conference programming language design implementation sigplan notices july 
fraser hanson 
code generation interface ansi software practice experience sept 
fraser hanson 
simple register spilling retargetable compiler 
software practice experience jan 
graham kessler mckusick 
execution profiler modular programs 
software practice experience aug 
griswold griswold 
icon programming language 
prentice hall englewood cliffs nj second edition 
hanson 
simple code optimizations 
software practice experience aug 
hanson 
fast allocation deallocation memory object lifetimes 
software practice experience jan 
kernighan ritchie 
programming language 
prentice hall englewood cliffs nj second edition 
knuth 
empirical study fortran programs 
software practice experience apr 
sedgewick 
algorithms 
addison wesley reading ma 
sites 
programming tools statement counts procedure timings 
sigplan notices dec 
standards performance evaluation spec benchmark suite release oct 
thompson 
new compiler 
proceedings summer conference pages london july 
waite 
cost lexical analysis 
software practice experience may 
weinberger 
cheap dynamic instruction counting 
bell system technical journal oct 
