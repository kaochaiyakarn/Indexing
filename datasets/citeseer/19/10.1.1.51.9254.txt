electronic notes theoretical computer science principles maude clavel eker lincoln meseguer computer science laboratory sri international menlo park ca usa introduces basic concepts rewriting logic language maude discusses implementation 
maude wide spectrum language supporting formal specification rapid prototyping parallel programming 
maude rewriting logic paradigm includes functional object oriented paradigms sublanguages 
fact rewriting logic reflective leads novel metaprogramming capabilities greatly increase software reusability adaptability 
control rewriting computation achieved internal strategy languages defined inside logic 
maude rewrite engine designed explicit goal highly extensible supporting rapid prototyping formal methods applications semi compilation techniques allow meet goals performance 
maude logical language rewriting logic 
related rewriting logic languages cafe elan dlo 
equational language obj regarded functional sublanguage maude 
gives language interpreter implementation 
particular emphasis placed basic principles semantics 
style informal ideas illustrated simple examples facilitate comprehension 
key characteristics maude summarized follows supported nato fellowship administered royal society 
supported part office naval research contract national science foundation ccr afosr contract number 
supported office naval research contracts national science foundation ccr darpa contract information technology promotion agency japan part industrial science technology frontier program new models software architecture sponsored new energy industrial technology development organization 
fl elsevier science clavel ffl rewriting logic 
particularly suited express declarative way concurrent state changing aspects systems 
programs theories rewriting logic deduction exactly corresponds concurrent computation 
ffl wide spectrum 
rewriting logic logical semantic framework specification rapid prototyping efficient parallel distributed execution formal transformations specifications programs naturally supported 
ffl multiparadigm 
rewriting logic conservatively extends equational logic equational style functional programming naturally supported sublanguage 
declarative style concurrent object oriented programming supported simple logical semantics 
rewriting logic extends horn logic equality conservative way horn logic programming supported extended implementation basic facilities unification 
ffl reflective 
rewriting logic reflective 
design maude capitalizes fact support novel style metaprogramming powerful module combining module transforming operations surpass traditional parameterized programming greatly advance software reusability adaptability 
ffl internal strategies 
strategies controlling rewriting process defined rewrite rules reasoned inside logic 
having logic control extra logical features maude control logic 
maude implementation designed explicit goals supporting executable specification formal methods applications easily extensible supporting reflective computations 
interpreter advanced semi compilation techniques support flexibility traceability sacrificing performance 
reach rewrites second applications running mhz sun 
section explains sublanguage functional modules 
informal rewriting logic object oriented modules section 
system modules reflection internal strategies discussed section 
maude metaprogramming capabilities subject section 
section summarizes semantic foundations language section describes interpreter implementation 
conclude plans 
functional modules functional modules define data types functions means equational theories equations church rosser terminating 
mathematical model data functions provided initial algebra defined theory elements consist equivalence classes clavel ground terms modulo equations 
evaluation expression reduced form equations rewrite rules assigns equivalence class unique canonical representative 
concrete way equivalently think initial algebra consisting canonical representatives values functional expressions evaluate 
obj language maude extends functional modules parameterized functional theories parameters 
functional theories loose semantics opposed initial sense algebra satisfying equations theory acceptable model 
example parameterized list module list triv forms lists models trivial parameter theory fth triv sort elt sort elt models just sets elements 
similarly sorting module sorting poset sorts lists elements belong model poset functional theory elements partial order 
equational logic maude functional modules extension order sorted equational logic called membership equational logic discuss give details semantics functional modules section 
moment suffices say addition supporting sorts subsorts overloading function symbols functional modules support membership axioms generalization sort constraints term asserted certain sort condition consisting conjunction equations unconditional membership tests satisfied 
illustrate ideas parameterized module path graph forms paths graph 
module path concatenation operation nodes identities source target functions 
th graph sorts node edge ops edge 
node source target eth fmod path graph sorts path path 
subsorts node edge path path 
ops path 
node op path 
path 
path 
var edge var node var path vars path 
eq cmb path clavel eq eq ceq ceq ceq ceq endfm note concatenation paths path target source second 
follows inductive consequence simpler conditional membership axiom cmb path edge path 
instantiate module concrete graph corresponding automaton evaluate path expressions check valid paths automaton 
fmod automaton sorts node edge ops 
node ops 
edge ops edge 
node eq eq eq eq eq eq eq eq eq eq endfm recognizer path automaton endm rewriting logic object oriented modules type rewriting typical functional modules terminates single value outcome 
modules step rewriting step replacement equals equals find equivalent fully evaluated value 
general set rewrite rules need terminating need church rosser 
infinite chains rewriting may highly divergent rewriting paths cross rewriting 
essential idea rewriting logic semantics rewriting drastically changed fruitful way 
longer interpret term functional expression state system longer interpret rewrite rule gamma 
equality local state transition stating portion system state exhibits pattern described portion system change corresponding instance furthermore local state change take place independently clavel concurrently non overlapping local state changes 
course rewriting happen modulo structural axioms state system satisfies 
example top level distributed system state structure multiset regard system composed associative commutative state constructor 
represent rewrite theory tuple omega omega theory membership equational logic specifies states system data type set labels label rules set labeled rewrite rules axiomatizing local state transitions system 
rules may conditional 
rewriting logic logic concurrent state change 
logic rules deduction reflexivity transitivity congruence replacement allow infer complex concurrent state changes system may exhibit set rewrite rules describe elementary local changes 
natural realize reactive systems specified terminate system may evolve highly nondeterministic ways paths cross 
ideas illustrated explaining concurrent object oriented systems specified rewriting logic executed maude object oriented modules 
concurrent object oriented system concurrent state usually called configuration typically structure multiset objects messages 
view configurations built binary multiset union operator represent empty syntax subsorts object msg configuration op configuration configuration 
configuration assoc comm idr null multiset union operator declared satisfy structural laws associativity commutativity identity null 
subsort declaration subsorts object msg configuration states objects messages singleton multiset configurations complex configurations generated multiset union 
consequence abstractly represent configuration typical concurrent object oriented system equivalence class modulo structural laws associativity commutativity obeyed multiset union operator term expressing union objects messages multiset objects messages 
object state represented term ho object name identifier class names object attribute identifiers corresponding values 
clavel set attribute value pairs object state formed repeated application binary union operator obeys structural laws associativity commutativity order attribute value pairs object immaterial 
consider example concurrent system sender receiver objects communicate sending messages unreliable environment messages may received order messages lost messages duplicated 
fault tolerant connection objects accomplished numbering messages sending acknowledgments back 
receiver object may form receiver attribute name sending object queue received messages receiver counter 
maude class receiver objects specified declaration class receiver oid queue nat introduces attribute names corresponding value sorts 
concurrent local state change corresponding reception message sender receiver object described labeled rewrite rule 
rl receive receiver 

receiver push fi fi 
ack new value appended queue counter increased iff number message message discarded receiver change state case acknowledgment sent sender 
entire fault tolerant protocol sender receiver objects discussed somewhat different way chandy misra similar ways presentation alternating bit protocol lam shankar defined parameterized object oriented module 
note maude syntax object oriented modules leaves implicit understood assumptions syntax objects existence multiset union operator form configurations conventions class inheritance 
object oriented modules systematically translated ordinary rewrite theories making explicit assumptions 
understood special case system modules 
detailed account translation process 
protocol elt triv protecting queue elt clavel sort contents count subsort elt contents op 
count op count 
count op empty 
contents msg oid elt count 
msg data receiver msg ack oid count 
msg acknowledgment sender class sender rec oid queue contents count count class receiver oid queue count vars oid vars count var elt var queue var contents rl produce sender rec cons empty 
sender rec 
rl send sender rec 
sender rec 
rl rec ack sender rec 
ack 
sender rec empty fi 
rl receive receiver 

receiver push fi fi 
ack definitions generate reliable order communication mechanism clavel unreliable 
message counts ignore order messages replication count replicate messages may lost channel faulty 
fairness assumptions maude ensure send action corresponding receive actions repeated rec ack performed replication counter goes zero 
directly represent unbounded retransmission eliminating check relies strongly fairness assumption 
explained model fault modes communication channel additional rewrite rules duplicate destroy messages declared module extending 
formally letting denote initial configuration objects denote configuration resulting rewriting able deduce sentence gamma 
logical consequence rewrite rules module 
rules deduction rewriting logic support sound complete reasoning concurrent transitions possible concurrent system basic local transitions axiomatized rewrite rules 
sentence gamma 
provable logic rewrite rules axiomatize system axioms concurrent transition gamma 
possible system 
object oriented case implicit assumptions including associativity commutativity multiset union operator 
general system modules axioms varied flexible parameter specify different types concurrent systems 
way rewriting logic regarded general semantic framework concurrency encompasses wide range known models 
maude default interpreter quite adequate simulating concurrent object oriented systems 
purposes studying system depth example exploring possible rewrites state controlling possibly highly nondeterministic evolution system need object oriented need means 
system modules strategies reflection general maude modules system modules 
specify initial model rewrite theory 
initial model transition system states equivalence classes ground terms modulo equations transitions proofs ff gamma 
rewriting logic concurrent computations system described 
proofs equated modulo natural notion proof equivalence computationally corresponds true concurrency computations 
consider example system module nim specifying version game nim 
players bags pebbles draw bag remove pebbles limit bag limit number pebbles removed 
players take turns making moves game 
move player draws nonempty set pebbles exceeding limit bag 
limit bag contain number clavel pebbles double player just drew left draw bag 
game continues bags new state 
player empties draw bag wins 
intermediate move axiomatized rule mv winning move axiomatized rule win 
mod nim protecting bool sorts pebble bag state subsorts pebble bag op 
pebble op nil 
bag op bag bag 
bag assoc comm op 
bag bag 
bool op bag bag 
bag op state bag bag 
state vars bag eq nil eq nil 
true eq 
nil false eq 
true eq 
true ceq 
false nil eq 

eq 
fi crl mv state 
state 
nil crl win state 
state nil nil 
nil endm initial model described module transition system containing exactly possible game moves allowed game 
bad moves allow player win 
player avoid bad moves having winning strategy strategy move player leads success matter moves player attempts 
obviously want examples ways controlling rewriting inference process principle go undesired directions means adequate strategies 
systems example theorem provers declarative languages implementations support certain strategies nature 
strategies external languages control may constitute separate programming language external logic may part language extralogical features 
maude reflective capabilities rewriting logic strategies internal rewriting logic 
defined rewrite rules reasoned rules clavel theory 
value specifying strategies rewrite rules emphasized elan 
fact great freedom defining different strategy languages inside maude 
done completely user definable way users limited fixed closed strategy language 
users decide adopt particular strategy language features language remains fully extensible new features new strategy concepts defined top 
course languages defined disciplined way guarantees correct produce valid rewrites explain 
maude strategy language function theories assigns module module strat terms called strategy expressions specifying desired possibly quite complex set rewrite deductions original theory executing strategy expression simply rewriting rules strat 
cases executions may terminate 
expression rewritten desired rewrites theory strategy expression question supposed describe directly visible partially rewritten strategy expression 
way tame shifting ground controllable theory strat 
example strat may church rosser essentially functional module computations strategy expressions essentially deterministic 
course necessary requirement attractive possibility context sequential implementation 
briefly discuss reflection rewriting logic explain define give semantics internal strategy languages 
rewriting logic reflective 
rewrite theory finite number operations rules simulate finitely presentable rewrite theory sense terms corresponding terms hr ti hr gamma 
hr ti gamma 
hr denote class finitely rewrite theories 
internal strategy language theory transforming function strat gamma 
satisfies specific semantic requirements 
sound methodology defining languages define strategy language kernel function say meta gamma 
sends definitional extension suitable subtheory rewrite rules defining rewriting accomplished metalevel 
typical semantic definition wants meta simulates metalevel step rewriting top term rule labeled proving correctness small strategy language kernel quite easy correctness universal theory 
step define strategy language choice say strat function sending theory theory extends meta additional strategy expressions corresponding semantic rules recursive definitional extensions kernel appropriate sense clavel correctness reduced kernel 
descriptions meta strat just phrased metalevel terms described metalevel functions 
fact definable functions rewriting logic 
note theory represented term fact assuming sorted version logic terms elements sort module means effective function gamma 
mapping finitely presentable rewrite theory metalevel logic represented object level computable function module gamma 
module 
metatheorem bergstra tucker specify function finite set church rosser terminating rewrite equations suitable conservative extension details semantic definition internal strategy language logic general rewriting logic particular 
rewrite engine naturally regarded implementation key functionality universal theory maude implementation supports strategy kernel meta module 
built fashion greater efficiency 
definition concrete strategy language strat functional module extending meta appendix 
strategy expression strat initially form rew 
stands representation term object theory question example pebble bag nim representation strat nim rewriting strategy wish compute 
symbol indicates computation strategy computation proceeds gets rewritten tree solutions rewritten remaining strategy computed 
case termination idle strategy done 
language find winning strategy nim example 
strategy easily defined extending basic module strat nim 
couple mutually recursive strategies fmod nim win extending strat nim 
ops mv win 
label ops 
vars term var slt var eq rew 
rew 
apply win idle orelse dk apply mv eq rew 
mk rew 
mk clavel orelse endfm intuitively state hx game find winning move hx player sense hx hnil nili hx move eventually lead player success matter moves player attempts assuming moves player plays strategy 
particular defines strategy player state hx game try win game just move apply win create tree leaves hx allowed moves state hx dk apply mv 
try find leaf hx representing state player winning move result strategy player failure 
expected defines strategy player tree possibly empty allowed moves try select leaf hx note empty result failure 
player winning move hx prune leaf try find rest leaves winning move player winning move hx prune rest leaves select hx winning move 
run examples find winning move fail 
maude red rew state 
result sort rew state 
state idle maude red rew state 
result sort failure metaprogramming maude important new contributions maude metaprogramming methodology supports simple powerful way 
methodology integrated language semantic foundations particularly logical foundations reflection 
metaprogramming course mean capacity defining programs operate programs data case equational rewrite theories operate theories data 
observing reify theories views clavel includes traditional parameterized programming capabilities clear obj tradition particular instance 
difference tradition theories metalevel entities accessible object level logic possible explicitly reflective logical context 
reflection accomplishes open user language having fixed repertoire parameterized programming operations define wider range theory combining operations defined traditional means 
illustrated power meta module strat module constructions parameterized modules general sense 
example reification logic map psi gamma 
linear logic rewriting logic equationally defined function psi gamma 
module inside rewriting logic 
example illustrates general method rewriting logic logical framework reify effectively map logics phi gamma 
sending finitely presentable theories finitely presentable rewrite theories equationally defined function psi theory gamma 
module inside rewriting logic 
examples 
plan systematically exploit maude metaprogramming capabilities language environment easily extensible modifiable support logical framework semantic framework applications representation interoperation logics inside rewriting logic executable definition logical languages maude definition theorem proving environments tools maude languages inside rewriting logic 
summary reflection possible maude definition open extensible user definable module algebra supporting new style metaprogramming promising advantages software methodology 
semantics maude summarize semantic foundations maude functional object oriented system modules 
membership equational logic functional modules maude declarative language rewriting logic 
rewriting logic underlying equational logic parameter 
example unsorted sorted order sorted versions rewriting logic containing previous version special case 
underlying equational logic chosen maude membership equational logic conservative extension order sorted equational logic partial equational logic existence equations 
supports partiality subsorts operator overloading error specification 
signature membership equational logic triple omega sigma clavel set kinds sigma sorted better say signature fs kinded set sorts 
omega gamma algebra sigma algebra assignment sort subset intuitively elements sorts correct defined elements elements sort error undefined elements 
atomic formulas sigma equations membership assertions form term kind general sentences horn clauses atomic formulae quantified finite sets kinded variables 
conditional equations membership axioms form membership equational logic usual properties soundness completeness appropriate rules deduction initial free algebras relatively free algebras theory morphisms 
maude functional modules equational theories membership equational logic satisfying additional requirements 
semantics functional module initial algebra specified theory semantics parameterized functional module free functor associated inclusion parameter theory 
functional theories membership equational logic theories loose interpretation models theory acceptable functional theory may impose additional requirement subtheories interpreted initially 
entirely similar treatment objects theories obj 
membership equational logic conservatively extends order sorted equational logic maude functional modules extend obj modules 
maude automatic kind inference sorts declared user subsort relations 
need declare kinds explicitly 
convenience order sorted notation retained syntactic sugar 
operator declaration op push nat stack 
understood membership axiom push nat stack similarly subsort declaration stack corresponds membership axiom stack computation functional module accomplished equations rewrite rules canonical form 
equations satisfy additional requirements church rosser terminating sort decreasing 
guarantees terms equivalence clavel class modulo equations rewrite unique canonical form canonical form assigned sort smaller sorts assignable terms class 
module satisfying conditions reduction strategy reach normal form user assign operator functional evaluation strategy obj style control reduction efficiency purposes 
strategies declared bottom strategy chosen 
maude supports rewriting modulo equational theories associativity associativity commutativity say understood equational rewriting modulo axioms 
membership equational logic church rosser property terminating sort decreasing equations equivalent confluence critical pairs 
furthermore equality membership term sort decidable properties 
equality membership predicates computable functions 
metatheorem bergstra tucker conclude predicates specifiable church rosser terminating equations boolean valued functions 
pleasant consequence allowing include inequalities negations memberships conditions equations membership axioms seemingly negative predicates axiomatized inside logic positive way provided necessarily free constructors specification rosser terminating sort decreasing 
course practice explicitly axiomatized built implementation rewriting deduction efficient way 
denote membership equational logic associated rewriting logic regarding equational theory rewrite theory set rules empty defines conservative map logics gamma 
way maude functional modules regarded special case general system modules 
semantics object oriented system modules pointed logic maude membership logic variant rewriting logic system module rewrite theory 
case semantics initial model defined theory algebra rewriting computations ground terms theory 
systems perspective model describes concurrent behaviors system axiomatized exhibit 
perspective term denotes state system rewrite gamma 
denotes possibly concurrent computation 
system module contain parameter theories 
inclusion parameter module gives rise free extension functor provides semantics module 
course means compose systems putting rewrite theories clavel specified 
rewrite theory rules equations rewriting performed modulo equations 
mean maude implementation matching algorithm equational theory user specify impossible matching modulo arbitrary theory undecidable 
require theories system modules ffl equations divided set axioms matching algorithms exist maude implementation set equations church rosser terminating sort decreasing modulo equational part equivalent functional module 
ffl rules module coherent called weakly coherent section equations modulo means appropriate critical pairs exist rules equations allowing rewriting rules rewriting equations way losing rewrite computations failing perform rewrite possible equational deduction step taken 
way get effect rewriting modulo just matching algorithm particular simple strategy available circumstances reduce canonical form applying rule state system specified system module axiomatized data type equations modulo rules local rules changing state practice lefthand sides rules involve constructor patterns coherence natural byproduct specification practice 
completion methods check coherence try set rules coherent 
semantics object oriented modules entirely reducible system modules sense systematic desugaring process translating object oriented module corresponding system module 
particular ontology supported object oriented modules worth keeping exist general system modules 
example object oriented configuration objects maintain identity state changes notions fairness adequate specialized appropriate arbitrary system modules 
approach taken maude provide logical semantics concurrent object oriented programming rewriting logic foundation defining rigorous way higher level objectoriented concepts foundation 
papers provide background foundations 
talcott gives rewriting logic maude rewrite engine extensible design matching algorithms new theories added combined existing ones 
matching modulo associativity commutativity preliminary version matching modulo associativity supported 
clavel foundations actors somewhat different viewpoint 
basic ideas reflective semantics maude discussed section 
detail 
maude implementation section describes implementation maude interpreter consists main components front engine 
front module evaluation front maude interpreter built top obj front written common lisp 
maude front shares obj convenient mixfix syntax user defined symbols expressive parameterized programming mechanisms 
maude front augments additional syntax maude language constructs tracing debugging commands complete disambiguation ad hoc overloaded operators complete module flattening operation specialized pretty printer program transformation object oriented modules system modules support meta level specifications 
result users enter maude specifications powerful parameterized programming constructs mixfix syntax completely eliminated maude specification passed engine 
output engine passed back pretty printer output prefix form prints result user declared mixfix style 
timing rewriting statistics engine reported engine user front 
maude rewrite engine design objectives maude rewrite engine consistent executable specification formal method uses wish support 
system look feel interpreter capable supporting user interrupts source level tracing extensible new equational theories new built operators may require new term data representations integrated seamlessly existing term data representations 
reflective capabilities central design system support arbitrary levels meta rewriting 
sought efficient implementation meeting objectives supporting rules number performance enhancing techniques compilation native machine code compilation fixed architecture machine program transformations partial evaluation tight coupling matching replacement normalization code different equational theories code operating symbols equational theory recognizes symbols alien theories properties 
design chosen essentially highly modular semi compiler time consuming run time tasks compiled parse time sys clavel core facilities sort variable equation substitution theory interface symbol term free theory ac theory ac symbol ac ac term theory symbol term delta delta delta bool meta theory delta delta delta front attribute bison flex code utility data types vector graph digraph intset fig 

structure maude interpreter rewrite engine tem lookup tables automata interpreted run time 
early experiments useful distinct representations terms 
uses terms represented trees nodes decorated kinds information simplify parse time analysis 
subject term rewritten directed acyclic graph dag representation compact nodes 
heavy object oriented structuring techniques great care taken ensure extensibility bulk engine application independent 
structure rewrite engine shown module shown box names modules classes shown box 
solid arrows indicate classes target module derived classes source module dotted arrows indicate classes target module facilities provided source module 
modules organized layered structure inner layers knowledge dependency outer layers 
innermost layer consists modules core facilities theory interface 
theory interface consists classes basic objects clavel concrete realization differ different equational theories symbols dag nodes terms lefthand side automata matching righthand side automata constructing normalizing righthand side condition instances matching subproblems matching extension information 
classes theory interface contain concrete data function members provide useful common functionality derived classes 
core facilities module consists concrete classes basic objects independent different equational theories sorts connected components kinds variable symbols variables terms equations sort constraints rules sequences matching subproblems substitutions 
core facilities theory interface treat sort symbol equational theory special way whatsoever manipulated virtual functions classes belonging theory interface 
particular means code handles conditional equations knows maude built sort bool built constants true false 
conditional equations form complex boolean condition desired encoded equality true 
layer consists modules individual equational theories 
module layer consists concrete descendents classes theory interface provide theory specific implementation virtual functions match rewrite 
way equational theory representation objects symbols terms dag nodes matching automata 
level special sorts symbols module aware representation classes alien manipulated theory interface 
layer consists modules containing classes provide symbols non standard run time properties 
special sorts symbols classes symbols generalized nonstandard run time behavior 
class example generate manners conditional constructs including fi needed maude 
classes affect behaviour symbol attempt rewrite dag node containing 
properties matching normalization data representations inherited parent equational theory 
outermost module front contains rudimentary parser class couple minor classes 
maude specific operators fi meta apply really exist 
front dependent modules module depends 
changed replaced modifying rest engine 
final module utility data types 
contains classes class templates implementing components general utility vectors graphs tarjan union find data structure 
freely engine 
clavel performance enhancing techniques implemented current prototype include fixed size dag nodes place replacement 
ii full indexing topmost free function symbol layer patterns patterns free symbol contain free symbols equivalent matching subject patterns simultaneously 
iii greedy matching algorithms attempt generate single matching substitution fast possible patterns subpatterns simple variables satisfy certain conditions appearing condition 
greedy matching algorithm fails may able report match exists allowed report undecided case full matching algorithm 
iv binary search ac matching fast elimination ground terms previously bound variables 
specially designed sorting algorithm uses additional information speed renormalization ac terms 
vi boyer moore style algorithm matching associative function symbols 
vii compile time analysis sort information avoid needless searching associative ac matching 
viii compile time analysis non linear variables patterns order propagate constraints variables optimal way reduce search space 
ix compile time allocation fixed size data structures needed run time 
caching dynamically sized data structures created run time reuse big 
xi bit vector encoding sort information fast sort comparisons 
xii compilation sort information regularity tables fast incremental computation sorts run time 
xiii efficient handling matching extension theory independent mechanism avoids need extension variables equations 
large examples involving free theory observed speedups order times faster obj implementation reaching rewrites second mhz sun 
examples associative commutative rewriting observed typical speeds rewrites second cases orders magnitude speedup obj 
current version engine comprises classes implemented approximately lines 
clavel plans introduced main ideas basic principles maude illustrated examples 
addition continued theoretical foundations experimentation implementation lies ahead 
areas receive special attention ffl development experimentation maude reflective metaprogramming capabilities 
ffl experimentation different strategy languages development useful strategy libraries study parallel strategies 
ffl extension rewrite engine matching algorithms new equational theories 
ffl implementation unification algorithms support narrowing computations addition rewriting 
allow adequate treatment rules extra variables righthand sides supported current implementation 
ffl development theorem proving environment supporting automated reasoning specifications maude languages 
ffl implementation foreign interface modules support frequently occurring computations efficient built way 
ffl input output 
naturally specified maude concurrent object oriented concepts 
ffl compilation maude parallel distributed implementations language 
ffl applications case studies 
application areas particularly promising include logical framework applications module algebra metaprogramming methodology object oriented applications symbolic simulation real time system specification parallel programming uses maude programming language definition prototyping tool 
timothy winkler narciso mart oliet valuable contributions development maude ideas 
carolyn talcott discussions maude valuable suggestions strategy aspects 
grateful helpful discussions exchanges futatsugi claude el ene kirchner martin wirsing ulrike christian lengauer colleagues 
previous joseph goguen members obj team influenced development ideas 
jan bergstra john tucker 
characterization computable data types means finite equational specification method 
de bakker van clavel leeuwen editors automata languages programming seventh colloquium pages 
springer verlag 
lncs volume 
borovansk kirchner kirchner 
controlling rewriting rewriting 
volume 
adel jean pierre jouannaud jos meseguer 
specification proof membership equational logic 
manuscript sri international august 
rod burstall joseph goguen 
semantics clear specification language 
bjorner editor proceedings copenhagen winter school software specification pages 
springer lncs 
mani chandy misra 
parallel program design foundation 
addison wesley 
lamma mello stefanelli 
distributed logic objects fragment rewriting logic implementation 
volume 
manuel clavel jos meseguer 
reflection strategies rewriting logic 
volume 
manuel clavel jos meseguer 
axiomatizing reflective logics languages 
gregor kiczales editor proceedings reflection san francisco california april pages 
xerox parc 
steven eker 
fast matching combination regular equational theories 
volume 
futatsugi sawada 
cafe extensible specification environment 
proc 
international case symposium china november 
joseph goguen timothy winkler jos meseguer futatsugi jean pierre jouannaud 
introducing obj 
technical report sri csl sri international computer science laboratory 
appear goguen editor applications algebraic specification obj cambridge university press 
kirchner kirchner vittek 
designing constraint logic programming languages computational systems 
saraswat van editors principles practice constraint programming newport papers pages 
mit press 
patrick lincoln narciso mart oliet jos meseguer 
specification transformation programming concurrent systems rewriting logic 
blelloch chandy jagannathan editors specification parallel algorithms pages 
dimacs series vol 
american mathematical society 
narciso mart oliet jos meseguer 
rewriting logic logical semantic framework 
technical report sri csl sri international computer science laboratory august 
appear gabbay ed handbook philosophical logic kluwer academic publishers 
clavel jos meseguer 
membership algebra 
lecture dagstuhl seminar specification semantics july 
extended version preparation 
jos meseguer 
logical theory concurrent objects 
ecoop oopsla conference object oriented programming ottawa canada october pages 
acm 
jos meseguer 
rewriting unified model concurrency 
technical report sri csl sri international computer science laboratory february 
revised june 
jos meseguer 
conditional rewriting logic unified model concurrency 
theoretical computer science 
jos meseguer 
logical theory concurrent objects realization maude language 
gul agha peter wegner akinori yonezawa editors research directions concurrent object oriented programming pages 
mit press 
jos meseguer 
solving inheritance anomaly concurrent object oriented programming 
oscar nierstrasz editor proc 
ecoop pages 
springer lncs 
jos meseguer 
rewriting logic semantic framework concurrency progress report 
proceedings concur conference pisa august 
springer lncs 
jos meseguer joseph goguen 
order sorted algebra solves multiple representation coercion problems 
information computation 
jos meseguer timothy winkler 
parallel programming maude 

banatre le editors research directions high level parallel programming languages pages 
springer lncs 
technical report sri csl sri international computer science laboratory november 
talcott 
actor rewrite theory 
volume 

rewriting effective model concurrency 
editors parle proc 
sixth int 
conf 
parallel architectures languages europe athens greece july volume lncs pages 
springer verlag 
appendix fmod meta mod 
sorts varid term termlist label nat subsort varid term subsort term subsort term termlist op termlist 
term clavel op termlist termlist 
termlist assoc op error 
term meta apply built function takes meta representation term rule label natural number peano representation 
meta apply evaluated follows converted term represents 
term fully reduced equations resulting term matched rules label matches fail satisfy condition rule discarded 
successful matches discarded th match rule applied match error returned new term fully reduced equations resulting term converted meta term returned op meta apply term label nat 
term op 
nat op nat 
nat endfm just introduce specification strat mod 
needed compute reductions nim win fmod strat mod 
extending meta sorts strategy subsort term subsort subsort subsort strategy op 
op 
op 
op mk 
op 
op sols term label nat 
op failure 
op rew term strategy 
op andthen strategy 
op idle 
strategy op strategy strategy 
strategy op orelse strategy strategy strategy 
strategy op apply label 
strategy op dk apply label 
strategy op 
strategy op 
strategy op 
strategy op 
strategy clavel var nat vars term var label var slt slt var var strategy eq rew 
rew 
tg eq rew 
slt rew 
slt andthen eq rew 
slt idle andthen rew 
slt eq failure andthen failure eq rew 
slt orelse rew 
slt failure rew 
slt rew 
slt andthen fi eq rew 
apply meta apply error failure rew 
meta apply idle fi eq rew 
dk apply rew 
mk sols idle eq rew 
mk sols meta apply error failure rew 
mk sols meta apply idle fi eq rew 
mk gf rew 
mk idle eq rew 
mk gf rew 
gf idle eq rew 
gf rew 
idle endfm 
