interprocedural slicing dependence graphs susan horwitz thomas reps david binkley university wisconsin madison notion program slice originally introduced mark weiser useful program debugging automatic parallelization program integration 
slice program taken respect program point variable slice consists statements program affect value point concerns problem interprocedural slicing generating slice entire program slice crosses boundaries procedure calls 
solve problem introduce new kind graph represent programs called system dependence graph extends previous dependence representations incorporate collections procedures procedure calls just monolithic programs 
main result algorithm interprocedural slicing uses new representation 
noted concerns somewhat restricted kind slice permitting program sliced respect program point arbitrary variable slice taken respect variable defined 
chief difficulty interprocedural slicing correctly accounting calling context called procedure 
handle problem system dependence graphs include data dependence edges represent transitive dependences due effects procedure calls addition conventional direct dependence edges 
edges constructed aid auxiliary structure represents calling parameter linkage relationships 
structure takes form attribute grammar 
step computing required transitive dependence edges reduced construction subordinate characteristic graphs grammar nonterminals 
cr categories subject descriptors programming languages language constructs control structures procedures functions subroutines programming languages processors compilers optimization general terms algorithms design additional key words phrases attribute grammar control dependence data dependence data flow analysis summary information program debugging program dependence graph program integration program slicing subordinate characteristic graph 
slice program respect program point variable consists statements predicates program affect value point concept originally discussed mark weiser isolate individual computation threads program 
slicing help supported part david packard fellowship science engineering national science foundation dcr dcr ccr defense advanced research projects agency monitored office naval research contract ibm dec xerox 
authors address computer sciences department university wisconsin madison dayton st madison wi 
earlier version appeared abridged form proceedings acm sigplan conference programming language design implementation atlanta ga june acm sigplan notices july :10.1.1.50.4405
acm toplas vol january programmer understand complicated code aid debugging automatic parallelization 
program slicing algorithm automatically integrating program variants described slices compute safe approximation change behavior program modified version help determine different modifications interfere 
weiser terminology slicing criterion pair program point subset program variables 
slice consists statements predicates program affect values variables point general kind slice needed slice taken respect program point arbitrary variable interested slice taken respect variable defined value variable defined directly affected values variables loops conditionals enclose value variable directly affected assignments reach loops conditionals enclose slicing program consists single monolithic procedure call intraprocedural slicing slice determined closure directly affects relation 
ottenstein ottenstein pointed suited program dependence graphs kind slicing program represented program dependence graph slicing problem simply vertex reachability problem slices may computed linear time 
concerns problem interprocedural slicing generating slice entire program slice crosses boundaries procedure calls 
algorithm interprocedural slicing produces precise answer produced algorithm weiser 
follows example ottenstein ottenstein defining slicing algorithm terms operations dependence graph representation programs ottenstein ottenstein discuss case programs consist single monolithic procedure discuss general case slices cross procedure boundaries 
solve interprocedural slicing problem introduce new kind graph represent programs called system dependence graph extends previous dependence representations incorporate collections procedures procedure calls just monolithic programs 
main result algorithm interprocedural slicing uses new representation 
important understand distinction different related slicing problems version slice program respect program point variable consists statements predicates program affect value point version slice program respect program point variable consists reduced program computes sequence values point behavior reduced program respect variable indistinguishable original program 
intraprocedural slicing solution version provides solution version reduced program required version obtained restricting original program just statements predicates solution version 
interprocedural slicing restricting original program just statements predicates version may yield program syntactically incorrect certainly solution version 
reason phenomenon multiple calls procedure possible program elements algorithm version include acm toplas vol january call passing different subset procedure parameters 
noted imprecise weiser algorithm produces solution version 
address version interprocedural slicing problem restriction mentioned earlier slice taken respect program point variable defined 
algorithm identifies subgraph system dependence graph components affect sequence values solution version requires slice extended transformed duplicating code specialize procedure bodies particular parameter usage patterns 
weiser method interprocedural slicing described follows criterion procedure set criteria needed slice callers set criteria needed slice procedures called 
extended functions map sets criteria sets criteria 
cc set criteria 
cc cc cc cc union transitive closure defined usual way relations 
map set criteria criteria necessary complete corresponding slices calling called routines 
complete interprocedural slice criterion just union intraprocedural slices criterion 
method produce precise slice possible transitive closure operation fails account calling context called procedure 
example 
illustrate problem shortcomings weiser algorithm consider example program sums integers 
section call parameter passing discussed parameters passed value result 
program main sum call sum od procedure call add call increment return procedure add return procedure increment call add return weiser algorithm slice program respect variable return statement procedure increment obtain original program 
closer inspection reveals computations involving variable sum contribute value procedure increment particular initialization sum actual parameter call example relation includes relation 
includes call sites call procedures containing program points just procedure contains fails account calling context procedure contains acm toplas vol january procedure main call add adds current value sum included slice 
reason components included slice computed weiser algorithm follows initial slicing criterion increment mapped relation slicing criterion add 
criterion mapped relation slicing criteria corresponding sites call add criterion add increment irrelevant criterion add 
weiser algorithm produce precise slice possible transitive closure fails account calling context increment called procedure add generates spurious criterion add 
precise slice consists elements program main call od procedure call increment return procedure add return procedure increment call add return set program elements computed slicing algorithm described 
chief difficulty interprocedural slicing correctly accounting calling context called procedure 
address calling context problem system dependence graphs include edges represent transitive dependences due effects procedure calls addition conventional edges direct dependences 
presence transitive dependence edges permits interprocedural slices computed passes cast reachability problem 
cornerstone construction system dependence graph attribute grammar represent calling parameter linkage relationships procedures 
step computing required transitive dependence edges reduced construction subordinate characteristic graphs grammar nonterminals 
need express step fashion example transitive closure discussed section 
remainder organized follows section defines dependence graphs represent programs language procedure calls 
section defines operation intraprocedural slicing dependence graphs 
section extends definition dependence graphs handle language includes procedures procedure calls 
new graphs called system dependence graphs 
section presents slicing algorithm operates system dependence graphs correctly accounts calling context called procedure 
describes improve precision interprocedural slicing interprocedural summary information construction system dependence graphs handle programs aliasing slice incomplete programs compute forward slices program elements potentially affected variable point 
section discusses complexity slicing algorithm 
implemented algorithm entirety section provides analysis costs building system dependence graphs interprocedural slices presenting empirical results 
section discusses related 
exception material interprocedural data flow analysis employed section self contained terminology concepts attribute grammar theory section may appendix 
acm toplas vol january 
program dependence graphs program slices different definitions program dependence representations depending intended application variations theme introduced share common feature having explicit representation data dependences see 
program dependence graphs defined introduced additional feature explicit representation control dependences see 
definition program dependence graph differs ways 
definition covers restricted language scalar variables assignment statements conditional statements loops restricted kind output statement called statement general 
second omit certain classes data dependence edges class introduced 
despite differences structures define defined share feature explicitly representing control data dependences refer graphs program dependence graphs borrowing term 

program dependence graph program dependence graph program denoted directed graph vertices connected kinds edges 
vertices represent assignment statements control predicates occur program addition includes categories vertices distinguished vertex called entry vertex 
variable path standard control flow graph defined see vertex called initial definition vertex represents assignment initial state 
vertex labeled 
variable named statement vertex called final represents access final value computed labeled 
edges represent dependences program components 
edge represents control dependence data dependence 
control dependence edges labeled true false source control dependence edge entry vertex predicate vertex 
control dependence edge vertex vertex denoted means execution predicate represented evaluated value matches label edge program component represented eventually executed program terminates 
method determining control dependence edges arbitrary programs assuming programs include assignment conditional statements control dependence edges determined simpler fashion 
language consideration control dependences reflect program nesting structure program dependence graph contains control dependence edge vertex vertex iff holds entry vertex represents component nested loop conditional edges labeled true 
statement appear program names variables program execution terminates variables values final state variables named statement final values interest programmer 
directed graph consists set vertices set edges 
edge directed say source target edge 
acm toplas vol january represents control predicate represents component immediately nested loop conditional predicate represented predicate loop edge labeled true predicate conditional statement edge labeled true false occurs branch branch respectively 
data dependence edge vertex vertex means program computation changed relative order components represented reversed 
program dependence graphs contain kinds data dependence edges representing flow dependences def order dependences 
data dependence edges program dependence graph computed data flow analysis 
restricted language considered section necessary computations defined syntax directed manner 
program dependence graph contains flow dependence edge vertex vertex iff hold vertex defines variable 
vertex uses 
control reach execution path intervening definition path standard control flow graph program definition reaches 
initial definitions variables considered occur control flow graph final uses variables considered occur control flow graph 
flow dependence exists vertex vertex denoted flow dependences classified loop carried loop independent 
flow dependence carried loop denoted lc addition hold execution path satisfies conditions includes backedge predicate loop 
enclosed loop flow dependence loop independent denoted li addition execution path satisfies includes backedge predicate loop encloses possible lc li program dependence graph contains def order dependence edge vertex vertex iff hold define variable 
branch conditional statement encloses 
definitions control dependence edges additional edge predicate statement labeled true 
kind edge left definition necessary purposes 
complete discussion need edges comparison def order dependences anti output dependences see 
acm toplas vol january exists program component 
occurs left program syntax tree 
def order dependence witness denoted note program dependence graph multi graph may edge kind vertices 
loop carried flow dependence edge vertices labeled different loop carries dependence 
edge vertices labeled vertex flow dependent definition occurs edge source definition occurs edge target 
example 
shows example program program dependence graph 
boldface arrows represent control dependence edges solid arrows represent loop independent flow dependence edges solid arrows hash mark represent loop carried flow dependence edges dashed arrows represent def order dependence edges 

program slices single procedure programs vertex program dependence graph slice respect denoted graph containing vertices transitive flow control dependence vertices reach program main sum sum sum od sum edge key control dependence loop independent flow dependence loop carried flow dependence def order dependence entry sum sum sum sum 
example program sums integers leaves result variable sum program dependence graph 
boldface arrows represent control dependence edges solid arrows represent flow dependence edges solid arrows hash mark represent loop carried flow dependence edges dashed arrows represent def order dependence edges 
acm toplas vol january flow control edges 
extend definition set vertices follows 
gives simple worklist algorithm computing vertices slice program dependence graph 
edges graph essentially subgraph induced exception def order edge included contains vertex directly flow dependent definitions terms types edges program dependence graph define 
relationship program dependence graph slice graph addressed 
say feasible program dependence graph iff program dependence graph program feasible program dependence graph slice feasible program dependence graph corresponds program obtained restricting syntax tree just statements predicates 
example 
shows graph results slice program dependence graph respect final vertex program corresponds 
significance intraprocedural slice captures portion program behavior sense initial state program halts program slice compute sequence values element slice 
case program point may assignment statement control predicate final variable statement 
statement control predicate may reached repeatedly program computing sequence values element slice mean assignment statement sequence values assigned target variable predicate sequence boolean values procedure declare program dependence graph set vertices worklist set vertices vertices worklist worklist select remove vertex worklist mark unmarked vertex edge edge insert worklist od od 
worklist algorithm marks vertices vertex path flow control edges vertex acm toplas vol january program main od edge key control dependence loop independent flow dependence loop carried flow dependence def order dependence entry 
graph corresponding program result slicing program dependence graph respect final vertex produced final value variable produced 

system dependence graph interprocedural dependence graph representation turn definition system dependence graph 
system dependence graph extension dependence graphs defined section represents programs language includes procedures procedure calls 
definition system dependence graph models language properties complete system consists single main program collection auxiliary procedures 
procedures return statements statements defined section 
return statement include list variables 
parameters passed value result 
assumption call sites form form global variable 
restriction potential copy back conflicts 
restriction permits global variables treated additional parameters procedure discuss global variables explicitly 
clear approach tied particular language features enumerated 
modeling different features require adaptation basic approach applicable languages allow nested scopes languages different parameter passing mechanisms 
acm toplas vol january section discusses deal systems call parameter passing contain aliasing 
system dependence graph includes program dependence graph represents system main program procedure dependence graphs represent system auxiliary procedures additional edges 
additional edges sorts edges represent direct dependences call site called procedure edges represent transitive dependences due calls 
section discusses procedure calls procedure entry represented procedure dependence graphs edges representing dependences call site called procedure added connect graphs 
section defines linkage grammar attribute grammar represent call structure system 
transitive dependences due procedure calls computed linkage grammar added final step building system dependence graph 
sections procedure generic term referring main program auxiliary procedures distinction irrelevant 

procedure calls parameter passing extending definition dependence graphs handle procedure calls requires representing passing values procedures 
designing representation parameter passing goals possible build individual procedure procedure dependence graph including computation data dependences minimal knowledge system components 
system dependence graph consist straightforward connection program dependence graph procedure dependence graphs 
possible extract precise interprocedural slice efficiently traversing graph procedure analogous procedure 
goal subject section presents algorithm slicing system dependence graph 
meet goals outlined graphs model slightly non standard stage mechanism run time parameter passing procedure calls procedure values transferred means intermediate temporary variables parameter 
different set temporary variables returns transfer values back call copies values actual parameters call temporaries initializes local variables temporaries 
returning copies return values return temporaries retrieves 
model parameter passing represented procedure dependence graphs new kinds vertices 
call site represented call site vertex information transfer represented kinds parameter vertices 
calling side information transfer represented set vertices called actual actual vertices 
vertices control dependent callsite vertex represent assignment statements copy values actual parameters call temporaries return temporaries respectively 
similarly information transfer called procedure represented set vertices called formal formal vertices 
vertices control dependent procedure entry vertex represent assignment statements copy values formal parameters call temporaries return temporaries respectively 
model data dependences procedures limited dependences actual vertices formal vertices formal vertices actual vertices 
connecting procedure dependence graphs form system dependence graph straightforward involving addition acm toplas vol january new kinds edges call edge added call site vertex corresponding vertex parameter edge added actual vertex call site corresponding formal vertex called procedure parameter edge added formal vertex called procedure corresponding actual vertex call site 
call edges new kind control dependence edge parameter parameter edges new kinds data dependence edges 
advantage model flow dependences computed usual way data flow analysis procedure control flow graph 
control flow graph procedure includes nodes analogous actual actual formal formal vertices procedure dependence graph 
procedure control flow graph starts sequence assignments copy values call temporaries formal parameters ends sequence assignments copy values formal parameters return temporaries 
call statement procedure represented procedure control flow graph sequence assignments copy values actual parameters call temporaries followed sequence assignments copy values return temporaries actual parameters 
important question values transferred call site called procedure back 
point discussed section presents strategy results interprocedural data flow analysis omit parameter vertices procedure dependence graphs 
assume actual parameters copied call temporaries retrieved return temporaries 
parameter vertices associated call procedure procedure defined follows denotes procedure dependence graph subordinate call site vertex represents call actual vertex actual parameter call actual vertices labeled formal parameter name 
actual parameter variable expression actual vertex 
labeled actual parameter corresponding formal parameter parameter vertices associated entry procedure return procedure defined follows denotes procedure dependence graph formal parameter contains formal vertex formal vertex 
vertices labeled respectively 
example 
repeats example system shows corresponding program procedure dependence graphs connected parameter edges parameter edges call edges 
remaining figures def order edges shown 
edges representing control dependences shown unlabeled edges example labeled true 

linkage grammar attribute grammar models procedure call structure graph structure defined previous section interprocedural slicing defined graph reachability problem slices obtained obtained weiser slicing method 
explained weiser method produce precise slice possible fails account calling context called procedure 
acm toplas vol january program main sum call sum od sum procedure call add call increment return procedure add return procedure increment call add return enter main sum call sum sum sum enter call add call enter call add enter add edge key control loop independent flow loop carried flow call parameter parameter 
example system corresponding program procedure dependence graphs connected parameter parameter call edges 
edges representing control dependences shown unlabeled boldface edges representing intraprocedural flow dependences shown arcs parameter edges parameter edges call edges shown dashed lines 
acm toplas vol january example 
problem weiser method illustrated graph shown 
graph reachability vocabulary problem path vertex procedure main labeled sum vertex main labeled value call procedure independent value sum call 
path follows main sum add add add main source problem paths graph correspond possible execution paths path vertex sum main vertex main corresponds procedure add called procedure returning procedure increment 
overcome problem add additional kind edge system dependence graph represent transitive dependences due effects procedure calls 
presence edges permits interprocedural slices computed passes cast reachability problem 
step construction system dependence graph determine transitive dependences 
example graph shown need algorithm discover transitive dependence vertex sum main vertex sum main 
dependence exists value sum call depends value sum call impulse compute transitive dependences due calls transitive closure graph control flow parameter call edges 
technique imprecise reason transitive closure equivalently reachability imprecise interprocedural slicing paths system dependence graph correspond possible execution paths 
transitive closure compute dependence edges represent effects procedure calls put spurious edge vertex sum main vertex main 
language recursion problem eliminated separate copy procedure dependence graph call site handle language recursion powerful technique required 
technique involves defining attribute grammar called linkage grammar model call structure procedure intraprocedural transitive flow dependences procedure parameter vertices 
interprocedural transitive flow dependences system dependence graph parameter vertices determined linkage grammar standard attribute grammar construction computation subordinate characteristic graphs linkage grammar nonterminals 
section describe construction linkage grammar computation subordinate characteristic graphs 
understood linkage grammar compute transitive dependences due calls interested language defined grammar actual attribute values 
context free part linkage grammar models system procedure call structure 
grammar includes nonterminal production procedure system 
procedure summary attribute grammar terminology appendix 
acm toplas vol january contains calls right hand side production right hand side nonterminal call site example 
example system shown productions linkage grammar follows main add increment add increment add attributes linkage grammar correspond parameters procedures 
procedure inputs modeled inherited attributes procedure outputs modeled synthesized attributes 
example productions shown repeated time tree form 
nonterminal annotated attributes nonterminal inherited attributes placed left synthesized attributes placed right 
formally program linkage grammar elements procedure linkage grammar contains nonterminal 
procedure production site call procedure distinct occurrence 
actual vertex inherited attribute nonterminal 
actual vertex synthesized attribute nonterminal attribute nonterminal denoted 
dependences attributes linkage grammar production model possibly transitive intraprocedural dependences parameter vertices corresponding procedure 
dependences computed intraprocedural slices procedure procedure dependence graph described section 
grammar production attribute equations introduced represent intraprocedural dependences parameter vertices corresponding procedure dependence graph 
attribute occurrence procedure dependence graph sliced respect main add add add 
productions example linkage grammar shown tree form 
nonterminal annotated attributes nonterminal inherited attributes placed left synthesized attributes placed right 
acm toplas vol january vertex corresponds attribute equation introduced depends attribute occurrences correspond parameter vertices identified slice 
formally attribute occurrence production vertex procedure dependence graph corresponds associate attribute equation form 
arguments equation consist attribute occurrences correspond parameter vertices note actual function right hand side equation completely irrelevant attribute grammar evaluation need equation induce dependences described 
example 
shows productions grammar augmented attribute dependences 
dependences production main instance correspond equations 
entirely possible linkage grammar circular attribute grammar may attributes derivation tree grammar depend additionally grammar may formed production may equations synthesized attribute occurrences righthand side symbols 
create difficulties linkage grammar compute transitive dependences attribute evaluation 
example 
equation example attribute grammar circular formed 
equation added attribute grammar cyclic path graph shown main add add add 
productions augmented attribute dependences 
acm toplas vol january main main main call main transitive dependences call site actual vertices actual vertices computed linkage grammar constructing subordinate characteristic graphs grammar nonterminals 
algorithm give exploits special structure linkage grammars compute graphs efficiently done attribute grammars general 
general attribute grammars computing sets possible subordinate characteristic graphs grammar nonterminals may require time exponential number attributes attached nonterminal 
linkage grammar attribute grammar restricted nature nonterminal linkage grammar production left hand side 
linkage grammars restricted fashion nonterminal linkage grammar subordinate characteristic graph covers nonterminal possible subordinate characteristic graphs 
grammars possible give polynomial time algorithm constructing covering subordinate characteristic graphs 
computation performed algorithm called slight modification algorithm originally developed kastens construct approximations grammar transitive dependence relations 
covering subordinate characteristic graph nonterminal linkage grammar captured graph tds standing transitive dependences symbol attributes 
initially tds graphs empty 
construction builds involves auxiliary graph tdp standing transitive dependences production expresses dependences attributes production nonterminal occurrences 
basic operation procedure tdp argument tdp graph production second argument pair attribute occurrences carries actions edge inserted graph tdp 
additional edges needed transitively close tdp inserted tdp 
addition edge added tdp edge edge added tdp may add edge tds graphs 
particular edge added tdp form left hand side occurrence nonterminal production tds edge added tds 
edge tds graphs marked unmarked edges adds tds graphs unmarked 
tds graphs generated procedure slight modification steps kastens algorithm constructing set evaluation plans attribute grammar 
performs kind closure operation tdp tds graphs 
step algorithm loops initializes grammar tdp tds graphs loops terminate tdp graphs contain edges representing direct dependences exist grammar attribute occurrences tds graphs contain unmarked edges corresponding direct left hand side left hand side dependences linkage grammar productions 
construction attribute equations linkage grammar ensures graph direct attribute dependences transitively closed step tdp transitively closed graph 
acm toplas vol january procedure declare linkage grammar production nonterminal occurrences attributes nonterminals nonterminal step initialize tds tdp graphs nonterminal tds graph containing vertex attribute edges od production tdp graph containing vertex attribute occurrence edges attribute occurrence argument equation defines insert edge tdp nonterminal corresponding nonterminal occurrence tds insert unmarked edge tds fi ni od od od step determine sets induced transitive dependences unmarked edge tds graphs mark occurrence production tdp tdp fi od od 
computation linkage grammar sets tdp tds graphs 
step invariant loop graph tdp contains edge corresponds marked edge tds graphs induced graphs tdp 
edges tds graphs received marks effects dependences induced tdp tds graphs 
tds graphs computed guaranteed cover transitive dependences attributes exist occurrence derivation tree 
put simply nonterminal linkage grammar single production left hand side grammar derives tree 
recursive grammar infinite tree 
marked edges tds represent transitive dependences tree tds graph computed represents subordinate characteristic graph covers subordinate characteristic graph partial derivation tree derived desired 
example 
nonterminals example grammar shown annotated attributes subordinate characteristic graphs 
acm toplas vol january add 
recap construction system dependence graph system dependence graph constructed steps procedure system construct procedure dependence graph 
call site introduce call edge call site vertex corresponding vertex 
actual vertex call site introduce parameter edge corresponding formal vertex called procedure 
actual vertex call site introduce parameter edge corresponding formal vertex called procedure 
construct linkage grammar corresponding system 
compute subordinate characteristic graphs linkage grammar nonterminals 
call sites call procedure introduce flow dependence edges corresponding edges subordinate characteristic graph example 
shows complete system dependence graph example system 

interprocedural slicing section describe perform interprocedural slice system dependence graph defined section 
discuss modifications definition system dependence graph permit precise slicing extend slicing algorithm range applicability 

algorithm interprocedural slicing discussed algorithm safe precise possible 
difficult aspect interprocedural slicing keeping track calling context slice descends called procedure 
key element approach linkage grammar characteristic graph edges system dependence graph 
edges represent transitive data dependences actual vertices actual vertices due procedure calls 
presence edges permits sidestep calling context problem slicing operation move call having descend 
algorithm interprocedural slicing 
computation slice system dependence graph respect vertex set performed phases 
phases operate system dependence graph essentially method section performing intraprocedural slice graph traversed find set vertices reach set vertices certain kinds edges 
traversal phase follows flow edges control edges call acm toplas vol january enter main sum call sum sum sum enter call add call enter call add enter add edge key control intraprocedural flow loop independent intraprocedural flow loop carried interprocedural flow call parameter parameter 
example system system dependence graph 
control dependences shown unlabeled represented medium bold arrows intraprocedural flow dependences represented arcs transitive interprocedural flow dependences corresponding subordinate characteristic graph edges represented heavy bold arcs call edges parameter edges parameter edges connect program procedure dependence graphs represented dashed arrows 
acm toplas vol january procedure declare system dependence graph sets vertices phase slice descending called procedures def order parameter phase slice called procedures ascending call sites marked vertices def order parameter call procedure kinds declare system dependence graph set vertices kinds set kinds edges vertices worklist set vertices worklist worklist select remove vertex worklist mark unmarked vertex edge kind kinds insert worklist od od 
procedure marks vertices interprocedural slice auxiliary procedure marks vertices path vertex edges kinds set kinds 
edges parameter edges follow def order edges parameter edges 
traversal phase follows flow edges control edges parameter edges follow def order edges call edges parameter edges 
suppose goal slice system dependence graph respect vertex procedure phases characterized follows phase phase identifies vertices reach procedure calls directly transitively 
parameter edges followed traversal phase descend procedures called effects procedures ignored presence transitive flow dependence edges actual actual vertices subordinate characteristic graph edges permits discovery vertices reach procedure call graph traversal descend called procedure 
phase phase identifies vertices reach procedures transitively called procedures called procedures transitively call call edges parameter edges followed traversal phase ascend calling procedures transitive flow dependence edges actual actual vertices unnecessary 
acm toplas vol january figures illustrate phases interprocedural slicing algorithm 
shows vertices example system dependence graph marked phase interprocedural slicing algorithm system sliced respect formal vertex parameter procedure increment 
edges traversed phase included 
adds boldface vertices marked edges traversed phase slice 
enter main call enter call add call enter call add edge key control intraprocedural loop independent flow interprocedural flow intraprocedural loop carried flow call parameter 
example program system dependence graph sliced respect formal vertex parameter procedure increment 
vertices marked phase slicing algorithm edges traversed phase shown 
acm toplas vol january enter main call enter call add call enter call add enter add edge key control intraprocedural loop independent flow interprocedural flow intraprocedural loop carried flow call parameter parameter 
example program system dependence graph sliced respect formal vertex parameter procedure increment 
vertices marked phase slicing algorithm edges traversed phase shown boldface 
result interprocedural slice consists sets vertices identified phase phase set edges induced vertex set 
shows completed example slice excluding def order edges 
acm toplas vol january enter main call enter call add call enter call add enter add edge key control intraprocedural loop independent flow interprocedural flow intraprocedural loop carried flow call parameter parameter 
complete slice excluding def order edges example program system dependence graph sliced respect formal vertex parameter procedure increment 

interprocedural summary information build procedure dependence graphs slice shown illustrates shortcoming method constructing procedure dependence graphs described section 
problem including actual actual vertex argument procedure call affect precision interprocedural slice 
slice acm toplas vol january shown includes call vertex represents call add call fact affect value increment 
problem actual vertex argument call add included procedure dependence graph add change value achieve precise interprocedural slice results interprocedural data flow analysis constructing procedure dependence graphs order exclude vertices actual vertex argument appropriate interprocedural summary information consists sets computed procedure gmod set variables modified procedure transitively called set variables referenced procedure transitively called gmod sets determine parameter vertices included procedure dependence graphs follows procedure parameter vertices subordinate entry vertex include formal vertex variable gmod formal vertex variable gmod 
similarly site called parameter vertices subordinate call site vertex include actual vertex variable gmod actual vertex variable gmod 
necessary include actual formal vertex variable gmod may execution path modified 
case slice respect final value include initial value formal vertex corresponding vertex call 
example 
gmod sets example system procedure gmod add parameter gmod add add procedure dependence graph include formal vertex call add include corresponding actual vertex 
shows procedure dependence graph built gmod information 
actual vertex argument call add omitted flow edge vertex actual vertex replaced edge formal vertex actual vertex 
new edge traversed phase interprocedural slice omitted flow edge correctly bypassing call add procedure 
interprocedural slicing presence call parameter passing aliasing definitions system dependence graphs interprocedural slicing assumed parameters passed value result 
definitions hold call parameter passing absence aliasing presence aliasing modifications required 
section presents acm toplas vol january enter call add call 
procedure procedure dependence graph built interprocedural summary information 
vertex argument call add omitted flow edge vertex vertex replaced edge vertex vertex 
approaches dealing systems call parameter passing contain aliasing 
approach provides precise slice second approach expense time space needed convert original system alias free 
costs may worst case exponential maximum number parameters passed procedure 
second approach avoids expense making generalized notion flow dependence includes flow dependences exist possible aliasing patterns 
approach problem interprocedural slicing presence aliasing reduce problem interprocedural slicing absence aliasing 
conversion performed simulating calling behavior system usual activation tree model procedure calls discover instance procedure call exactly variables aliased instance 
recursive system activation tree infinite number different alias configurations finite finite portion activation tree needed compute aliasing information 
new copy procedure new procedure name created different alias configuration procedure names call sites similarly adjusted 
procedure variables renamed set aliased variables replaced single variable 
process may generate multiple copies vertex respect perform slice 
happens necessary slice transformed system respect occurrences slice original system obtained slice transformed system projecting elements slice transformed system back original system vertex slice original system copies slice transformed system 
example 
shows system aliasing portion system activation tree compute alias information call instance 
notation node activation tree labeled mapping variable names memory locations 
transformed alias free version system shown 
acm toplas vol january program main call procedure call fi return loc loc loc loc loc loc loc loc loc main 
program aliasing portion activation tree needed compute alias configurations 
program main call procedure call fi return procedure xy xy call xy fi xy xy return original goal slice respect statement procedure slice respect set statements xy xy 
second approach problem interprocedural slicing presence aliasing generalize definition flow dependence include dependences arise possible aliasing patterns procedure dependence graph flow dependence edge vertex vertex iff hold vertex defines variable 
vertex uses variable 
potential aliases 
control reach path control flow graph intervening definition note clause exclude definitions variables potential aliases path assignment variable path overwrites contents memory location written refer memory location 
potential alias possibility refer memory location assignment necessarily write memory location written may possible read value written acm toplas vol january notion def order edge generalized presence aliasing procedure dependence graph def order dependence edge vertex vertex iff hold define variables respectively 
potential aliases 
branch conditional statement encloses 
exists program component 
occurs left procedure syntax tree 
interprocedural slice system dependence graph containing dependence edges defined computed phase algorithm compute interprocedural slice system absence aliasing 
data dependences procedure provide safe approximation true dependences required alias configuration 
edges cover possible alias configurations resulting slice may contain unnecessary program elements 
example 
consider system shown 
possibility aliasing formal parameters procedure gives rise flow dependences actual vertices call vertex 
dependences slice respect statement main program yields entire system statement main conditional statement effect value computed approach replicating procedures determines precise slice include statement conditional statement shown program main call procedure return 
slicing partial system dependence graphs interprocedural slicing algorithm designed applied complete system dependence graph 
section discuss slice incomplete system dependence graphs 
need handle incomplete systems arises example slicing program calls library procedure available slicing programs development 
case missing components procedures called incomplete system second case missing components written procedures called incomplete system program developed top possible calling contexts program developed bottom 
case information possible effects missing calls missing calling contexts needed permit slicing 
information takes form safe approximations subordinate characteristic graphs missing called procedures superior characteristic graphs missing calling contexts 
information missing program components available subordinate characteristic graphs edge inherited attribute synthesized attribute superior characteristic graphs edge synthesized attribute attribute including synthesized attributes 
slice incomplete system include vertices included slice completed system acm toplas vol january possible provide call calling context corresponds graphs described 
library procedures possible provide precise subordinate characteristic graphs procedures provided 
programs development possible compute characteristic graphs better approximations worst case graphs specifications missing program components 

forward slicing slice program respect program point variable consists statements predicates program affect value point forward slice program respect program point variable consists statements predicates program affected value point algorithm forward interprocedural slicing defined system dependence graphs concepts employed backward interprocedural slicing 
key element linkage grammar characteristic graph edges system dependence graph represent transitive dependences actual vertices actual vertices due effects procedure calls 
algorithm forward interprocedural slicing procedure 
computation forward slice system dependence graph respect vertex set performed phases 
traversal phase follows flow edges control edges parameter edges follow call edges def order edges parameter edges 
call edges parameter edges followed traversal phase descend called procedures 
traversal phase follows flow edges control edges call edges parameter edges follow def order edges parameter edges 
parameter edges followed traversal phase ascend calling procedures 

complexity slicing algorithm section discusses complexity interprocedural slicing algorithm section 
absence aliasing cost polynomial various parameters system 
presence aliasing cost remains polynomial generalized definitions data dependences section price somewhat precision slices 
alternatively follow approach transforming system alias free precise slices obtained cost increase exponential factor reflects blow size occur due number aliasing patterns program 
measures system size associated system dependence graph created approaches 
particular approach transforming alias free system measures system size associated alias free system 

cost constructing system dependence graph cost constructing system dependence graph expressed terms parameters tables acm toplas vol january procedure declare system dependence graph sets vertices phase slice forward descending called procedures def order parameter call phase slice forward called procedures ascending call sites marked vertices def order parameter procedure kinds declare system dependence graph set vertices kinds set kinds edges vertices worklist set vertices worklist worklist select remove vertex worklist mark unmarked vertex edge kind kinds insert worklist od od 
procedure marks vertices forward interprocedural slice auxiliary procedure marks vertices path vertex edges kinds set kinds 
parameters measure size individual procedure largest number predicates assignments single procedure largest number edges single procedure dependence graph params largest number formal parameters procedure sites largest number call sites procedure parameters measure size entire system number procedures system number productions linkage grammar globals number global variables system total number call sites system interprocedural data flow analysis compute summary information side effects 
interprocedural summary information gmod determined particularly efficiently 
particular absence nested scopes gmod determined time steps algorithm described 
intraprocedural data flow analysis determine data dependences procedure dependence graphs 
structured language consideration analysis performed toplas vol january directed fashion example attribute grammar 
involves propagating sets program points set consists program points single procedure 
computation total cost 
cost constructing linkage grammar computing subordinate characteristic graphs expressed terms parameters parameters measure size linkage grammar sites largest number nonterminal occurrences single production number nonterminal occurrences linkage grammar sites globals params largest number attributes single nonterminal largest number attribute occurrences single production sites mult globals params determine dependences attribute occurrences production corresponding procedure sliced respect linkage vertices correspond attribute occurrences production 
cost slice linear size procedure dependence graph cost bounded 
consequently total cost constructing linkage grammar bounded 
remains analyze cost computing linkage grammar subordinate characteristic graphs 
edges tdp relation cost re closes single tdp relation 
cost initializing tdp relations direct dependences bounded 
inner loop step procedure called occurrence nonterminal edges graph tds nonterminal occurrences edge may induced 
edge induced marks tds edges total cost procedure bounded mult 

slicing costs interprocedural slice performed traversals system dependence graph starting initial set vertices 
cost traversal linear size system dependence graph bounded 

related recasting interprocedural slicing problem reachability problem graph example intraprocedural slicing 
reachability approach conceptually simpler data flow equation approach efficient slice desired 
recasting problem reachability problem involve loss generality permitting program sliced respect program point arbitrary variable slice taken respect variable defined slicing problems interprocedural slicing algorithm improvement weiser algorithm algorithm able produce precise slice produced weiser algorithm 
acm toplas vol january extra generality source imprecision weiser method explained section imprecision weiser method due lack mechanism keep track calling context called procedure 
initial publication interprocedural slicing algorithm different technique computing interprocedural slices hwang du chou :10.1.1.50.4405
slicing algorithm computes answer precise algorithm differs significantly handles calling context problem 
algorithm constructs sequence slices system slice sequence essentially permits additional level recursion fixedpoint reached elements appear slice uses additional level recursion 
slice sequence represents approximation final answer 
slice approximations algorithm uses stack keep track calling context called procedure 
contrast algorithm interprocedural slicing phase process propagating marks system dependence graph 
phase algorithm presence linkage grammar subordinate characteristic graph edges representing transitive dependences due effects procedure calls permits entire effect call accounted single backward step call site subordinate characteristic graph edges 
hwang du chou include analysis algorithm complexity direct comparison algorithm difficult reasons algorithm may efficient 
algorithm computes sequence slices may involve re slicing procedure multiple times contrast marks system dependence graph vertices algorithm processes vertex computation slice 
second wishes compute multiple slices system approach significant advantage 
system dependence graph subordinate characteristic graph edges need computed slicing operation graph cost slice linear size system dependence graph 
contrast approach involve finding new fixed point problem appears complexity comparable computation subordinate characteristic graphs new slice 
myers presents algorithms specific set interprocedural data flow problems require keeping track calling context myers approach handling problem differs 
myers performs data flow analysis graph representation program called super graph collection control flow graphs procedure program connected call return edges 
information maintained vertex super graph includes memory component keeps track calling context essentially name call site 
system dependence graph permits keeping track calling context propagating simple marks requiring propagation sets names 
doubt possible formulate interprocedural slicing data flow analysis problem super graph solve problem algorithm akin described myers account correctly calling context called procedure 
comparison algorithm significant advantage wishes compute multiple slices system 
system dependence graph computed slicing operation approach postulated involve solving new data flow analysis problem scratch slice 
vertex reachability approach similarities technique transform data flow analysis problems vertex reachability problems 
case data flow analysis problem solved building graph representation program performing reachability analysis graph propagating simple marks example sets variable acm toplas vol january names 
difference interprocedural slicing problem problems addressed cited interprocedural slicing demand problem goal determine information concerning specific set program points exhaustive problem goal determine information program points 
appendix attribute grammars attribute dependences attribute grammar context free grammar extended attaching attributes terminal nonterminal symbols grammar supplying attribute equations define attribute values 
production denotes occurrence grammar symbols associated symbol occurrence set attribute occurrences corresponding symbol attributes 
production set attribute equations equation defines production attribute occurrences value attribute definition function applied attribute occurrences production 
attributes symbol divided disjoint classes synthesized attributes inherited attributes 
attribute grammar formed terminal symbols grammar synthesized attributes root nonterminal grammar inherited attributes production exactly attribute equation left hand side nonterminal synthesized attribute occurrences right hand side symbols inherited attribute occurrences 
grammars arise potentially formed production may equations synthesized attribute occurrences right hand side symbols 
reason cause problems linkage grammar interprocedural slicing algorithm compute transitive dependences due calls interested language defined grammar actual attribute values 
derivation tree node instance symbol associated set attribute instances corresponding attributes attributed tree derivation tree assignment value special token null attribute instance tree 
ordinarily interested analyzing string specification 
constructs string derivation tree assignment null attribute instance evaluates attribute instances possible appropriate attribute equation assignment statement 
process termed attribute evaluation 
functional dependences attribute occurrences production attribute instances tree represented directed graph called dependence graph denoted respectively defined follows attribute occurrence instance graph contains vertex 
attribute occurrence instance appears right hand side attribute equation defines attribute occurrence instance graph contains edge attribute grammar derivation tree dependence graph contains cycle called circular attribute grammar 
grammars arise circular grammars 
node subordinate superior characteristic graphs provide convenient representation transitive dependences node attributes 
transitive dependence exists attributes related transitive closure tree attribute dependence relation equivalently connected directed path tree dependence graph 
vertices characteristic graphs node acm toplas vol january correspond attributes edges characteristic graphs correspond transitive dependences attributes 
subordinate characteristic graph projection dependences subtree rooted attributes form superior characteristic graph node imagine subtree rooted pruned derivation tree project dependence graph remaining tree attributes define characteristic graphs precisely definitions directed graph path vertex vertex sequence vertices 
directed graph set vertices projection defined exists path 
edge exists path pass elements subordinate superior characteristic graphs node denoted respectively defined formally follows node tree subtree rooted denoted attribute instances denoted subordinate superior characteristic graphs satisfy 
characteristic graph represents projection attribute dependences attributes single tree node consequently grammar graph bounded size constant 

aho sethi ullman compilers principles techniques tools addison wesley reading ma 

jazayeri method attributes data flow analysis part ii 
demand analysis acta informatica pp 
october 

badger lee weiser mark minimizing communication synchronizing parallel dataflow programs proceedings international conference parallel processing ii software pp 
penn state august 

banning efficient way find side effects procedure calls aliases variables pp 
conference record sixth acm symposium principles programming languages san antonio tx january 

callahan program summary graph flow sensitive interprocedural data flow analysis proceedings acm sigplan conference programming language design implementation atlanta ga june acm sigplan notices pp 
july 

cooper kennedy interprocedural side effect analysis linear time proceedings acm sigplan conference programming language design implementation atlanta ga june acm sigplan notices pp 
july 

ferrante ottenstein warren program dependence graph optimization acm transactions programming languages systems pp 
july 

horwitz prins reps integrating non interfering versions programs technical report department computer sciences university wisconsin madison march 

horwitz reps binkley interprocedural slicing dependence graphs proceedings sigplan conference programming language design implementation atlanta ga june acm sigplan notices pp 
july 
acm toplas vol january 
horwitz prins reps adequacy program dependence graphs representing programs pp 
conference record fifteenth acm symposium principles programming languages san diego ca january 

horwitz prins reps integrating non interfering versions programs acm transactions programming languages systems pp 
july 

hwang du chou finding program slices recursive procedures proceedings ieee compsac chicago il oct ieee computer society washington dc 

kastens ordered attribute grammars acta inf 
pp 


knuth semantics context free languages math 
syst theory pp 


kou live dead analysis global data flow problems journal acm pp 
july 

kuck muraoka chen number operations simultaneously executable fortran programs resulting speed ieee transactions computers pp 
december 

lyle weiser experiments slicing debugging tools proceedings conference empirical studies programming june ablex publishing 


myers precise inter procedural data flow algorithm pp 
conference record eighth acm symposium principles programming languages williamsburg va january 

ottenstein ottenstein program dependence graph software development environment proceedings acm sigsoft sigplan software engineering symposium practical software development environments pittsburgh pa april acm sigplan notices pp 
may 

reps yang semantics program slicing technical report department computer sciences university wisconsin madison june 

weiser reconstructing sequential behavior parallel behavior projections information processing letters pp 


weiser program slicing ieee transactions software engineering se pp 
july 
acm toplas vol january acm toplas vol january 
