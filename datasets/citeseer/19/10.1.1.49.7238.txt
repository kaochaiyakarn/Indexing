guy steele jr thinking machines street cambridge massachusetts phone fax mail gls think com evolution lisp richard gabriel lucid laurel street menlo park california phone fax mail rpg lucid com lisp world greatest programming language proponents think 
structure lisp easy extend language implement entirely new dialects starting scratch 
evolution lisp guided institutional born technical cleverness characteristic hacker culture sober assessments technical requirements 
process eventually produced programming language messy powerful technically pure dialect small powerful suitable programming language theoreticians 
pick mccarthy hopl conference left 
trace development chronologically era pdp interlisp maclisp past ascension decline special purpose lisp machines era standardization activities 
examine technical evolution representative language features including notable successes notable failures illuminate design issues distinguish lisp programming languages 
discuss lisp laboratory designing programming languages 
conclude reflections forces driven evolution lisp 
implementation projects chronology lisp pdp lisp maclisp interlisp early demise pdp lisp machines ibm lisps lisp lisp scheme prelude common lisp early common lisp lisp dialects standards development evolution specific language features treatment nil iteration macros numerical facilities notable failures lisp language laboratory permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 
second acm sigplan history programming languages conference hopl ii april cambridge massachusetts usa 
acm sigplan notices march 
fl acm lisp diverse steele gabriel evolution lisp great deal happened lisp years 
impossible treat interest coherently single linear pass subject chronologically 
projects dialects emerge split join die complicated ways careers individual people woven connections ways parallel orthogonal 
ideas leap project project person person 
chosen series slices subject matter 
organization inevitably leads redundancy presentation 
omit great deal material lack space 
choice topics necessarily reflects experiences biases 
apologize favorite corner lisp community gone 
section discusses history lisp terms projects people mccarthy left mccarthy efforts produce official standards lisp dialects ieee ansi iso 
section examines number technical themes traces separately chronological evolution emphasis flow ideas topic 
section traces lisp language laboratory implementation tool especially development ai languages particular attention paid ways feedback ai languages influenced development lisp 
section draws lisp evolved 
implementation projects chronology early thoughts language eventually lisp started john mccarthy attended dartmouth summer research project artificial intelligence 
actual implementation began fall 
mccarthy related early history language mccarthy approximately just lisp 
see mccarthy 
story mccarthy left 
lisp pdp lisp period lisp spread rapidly variety computers bootstrapping existing lisp computer new implementation 
cases lisp dialect small simple implementation straightforward 
changes original language 
early timothy hart thomas evans implemented lisp military version 
bootstrapped lisp ibm cross compiler small amount machine language code lowest levels lisp implementation hart 
robert saunders colleagues system development implemented lisp ibm built computer called simply saunders 
implementation bootstrapped ibm pdp computers stanford university 
pdp lisp stanford implemented john mccarthy steve russell 
peter deutsch time high school student implemented lisp similar lisp pdp bolt beranek newman bbn deutsch 
lisp called basic pdp lisp 
version lisp running electrical engineering department mit ibm computer running compatible time sharing system ctss 
lisp basic pdp lisp main influences pdp lisp pdp lisp implemented steele gabriel evolution lisp dec members mit tech model railroad club spring 
lisp program written pdp 
lisp ancestor maclisp lisp written run incompatible timesharing system mit pdp pdp 
bbn successor basic pdp lisp implemented pdp version patterned lisp mit ctss system implemented scientific data systems sds daniel bobrow murphy 
version written pdp alice hartley murphy lisp called bbn lisp teitelman 
long time sds acquired xerox renamed xerox data systems maintenance bbn lisp shared bbn xerox palo alto research center name lisp changed interlisp teitelman 
pdp dec pdp dec computers design especially suited lisp bit words bit addresses 
allowed cons cell pair pointers addresses stored efficiently single word 
half word instructions manipulating car cdr cons cells fast 
pdp pdp fast powerful stack instructions enabled fast function calling lisp 
implementations small hand coded assembly core compiler rest lisp written lisp compiled 
virtually lisps existence identical differed trivial ways 
precisely maclisp bbn lisp diverged came plethora lisp dialects 
period little funding language groups isolated group directed primarily serving needs local user group usually consisted handful researchers 
typical situation characterized description ai lab lisp wizard hall 
period deal experimentation implementation strategies 
little thought consolidation partly pioneering feeling laboratory embodied 
exception lisp project concerted language development effort funded arpa represented radical departure lisp 
appears hope design supersede lisp bring symbolic processing closer algol 
see section example lisp code 
lisp implemented computer achieved wide acceptance 
jean remarked contrast languages language designed implemented said lisp implementation search language 
real standard lisps maclisp interlisp deserve attention 
maclisp maclisp primary lisp dialect mit ai lab late early 
important lisp lab period included lisp machine lisp named scheme 
maclisp usually identified pdp computer maclisp ran machine honeywell multics operating system organick 
steele gabriel evolution lisp early maclisp distinguishing feature maclisp interlisp era attention production quality near production quality implementations 
period saw consolidation implementation techniques great attention detail 
key difference maclisp interlisp approach syntax 
maclisp favored pure list style eval top level 
interlisp lisp 
concatenate lists boat airplane car truck maclisp type expression eval append quote boat airplane quote car truck syntactic abbreviation quote append boat airplane car truck result course boat airplane car truck 
lisp type expression expressions append boat airplane car truck expression denotes function second list arguments 
quote name signifies implicit quoting arguments function applied 
maclisp forked eval exclusively top level interface bbn lisp interlisp accommodated input line contained complete form character second form bbn lisp finished reading second form interface interaction read exactly form eval interface interaction 
phrase quoting arguments misleading imprecise 
refers actions hypothetical preprocessor transforms input form append boat airplane car truck append quote boat airplane quote car truck evaluation performed 
similar confusion carried description socalled special form 
texts lisp find descriptions special forms speak special form quoting arguments fact special form special rule determining meaning rule involves evaluating forms pitman 
mccarthy mccarthy noted original lisp interpreter regarded universal turing machine perform computation set instructions function initial input tape arguments 
intended append boat airplane car truck regarded syntactically mutated version append quote boat airplane quote car truck function separately literal list arguments 
hindsight see top level better called apply top level making pleasantly symmetrical eval top level bbn lisp documentation brought symmetry explicitly 
steele gabriel evolution lisp identical function apply lisp differences lisp apply took third argument environment regarded nowadays mistake resulted dynamic binding lexical scoping needed faithful reflection lambda calculus capable handling special forms sort exception mccarthy 
nowadays exception referred raymond 
note maclisp apply function supported 
maclisp introduced type function takes number arguments puts stack single parameter function bound number arguments passed 
form lambda list argument symbol list signals case 
example define list function variable number arguments returns list arguments defun list answer cons arg answer zerop answer parameter bound number arguments passed 
expression arg refers th argument passed 
need compiled counterpart arose desire variable arity functions 
semantic need ary convenient programmers able write equivalent cumbersome 
simple powerful macro facility defmacro introduced maclisp mid 
see section 
major improvements lisp arrays modification simple predicates member functions return useful values prog function err allowed user code signal error 
lisp certain built functions signal errors incorrect arguments example 
signaling error normally resulted program termination invocation debugger 
lisp function useful controlled execution code cause error 
special form form evaluates form context errors terminate program enter debugger 
form cause error returns singleton list value 
execution form cause error form quietly returns nil 
maclisp added function err signals error 
err invoked dynamic context form argument err returned value form 
programmers soon began err trap signal errors general control purposes dynamic non local exits 
unfortunately quietly trapped unexpected errors making programs harder debug 
new pair primitives catch throw introduced maclisp lisp archive may item reserved intended error trapping 
lesson catch important 
designers err mind particular situation defined pair primitives address situation 
facilities provided combination useful powerful capabilities error trapping plus dynamic non local exits programmers began facilities unintended ways 
steele gabriel evolution lisp designers go back split desired functionality pieces alternative interfaces 
pattern careful design unintended redesign common evolution lisp 
phase maclisp development began developers maclisp started see large influential user group emerge project mac macsyma group 
emphasis turned satisfying needs user community doing language design implementation 
maclisp part lifecycle maclisp adopted language features lisp dialects languages novel things invented 
significant development maclisp occurred early techniques prototype fast arithmetic compiler golden incorporated maclisp compiler jon white principal maclisp maintainer developer years 
john lyle white commonly known login name pronounced rhyme donnell john ell equally stressed syllables 
took writing name jon white john white 
steele age hung mit years implemented lisp system ibm hired lisp hacker july mit group headed joel moses 
steele soon took responsibility maintaining maclisp interpreter runtime system allowing jon concentrate full time compiler improvements 
resulting new maclisp compiler moon lisp archive pitman standard lisp compilers measured terms speed running code 
inspired needs mit artificial intelligence laboratory needs covered numeric computations done vision robotics new ways representing compiling numeric code resulted numeric performance compiled maclisp near par fortran compilers fateman 
arbitrary precision integer arithmetic added circa meet needs macsyma users 
code faithful transcription algorithms knuth 
bill suggested improvements notably version gcd combined features binary gcd algorithm method speeding integer division knuth ex 

david moon led effort implement maclisp honeywell multics 
part project wrote truly comprehensive manual maclisp known moon 
richard greenblatt started mit lisp machine project greenblatt david moon richard stallman mit ai lab lisp hackers eventually joined project 
project progressed language features selectively retrofitted pdp maclisp projects cross 
complex lambda lists partly arose influence muddle called mdl galley language dynamic modeling group mit 
ran pdp located machine room ai machines 
syntax lisp quite powerful express clearly different roles arguments function 
complex lambda lists appeared solution problem widely accepted eventually terribly complicated elegant common lisp object system 
steele gabriel evolution lisp maclisp introduced notion read tables 
read table provides programmable input syntax programs data 
character input table consulted determine syntactic characteristics character putting tokens 
example table determine characters denote whitespace 
addition functions associated characters function invoked character read function read input returning value incorporated data structure read 
way built parser reprogrammed user 
powerful facility easy experiment alternative input syntaxes lisp ranging simple abbreviations quote backquote facility elaborate algol style parsers 
see section discussion experiments 
maclisp adopted small number features lisp dialects 
dozen persons attended meeting mit maclisp interlisp implementors including warren teitelman alice hartley jon white jeff golden steele 
hope finding substantial common ground meeting served illustrate great chasm separating groups implementation details design philosophy 
side depart chosen strategy probably stemmed severe resource constraints pdp megabyte mips machine 
advent mit lisp machines greater speed greater address space crowd advocated small powerful execution environment separate programming tools embraced strategy writing programming tools lisp turning lisp environment complete programming environment 
trivial exchange features resulted great maclisp interlisp summit maclisp adopted interlisp behavior car nil nil cdr nil nil interlisp adopted concept read table 
mid increasingly apparent address space limitation pdp bit words megabyte severe constraint size lisp programs grew 
maclisp time enjoyed nearly years strong acceptance somewhat small influential user community 
implementation strategy large assembly language core proved stay dialect stood intellectual pressures dialects languages language design aspirations implementors resulted new directions lisp 
period stable maclisp golden era right world lisp 
period regarded today golden era artificial intelligence 
maclisp user community decline funding macsyma long 
various funding crises ai depleted ranks ai lab lisp wizards core group wizards mit mit moved new institutions 
interlisp interlisp bbn lisp introduced radical ideas lisp programming style methodology 
visible ideas embodied programming tools spelling corrector file package structure editor 
origin ideas warren teitelman phd dissertation man computer symbiosis teitelman 
particular contains roots structure editing opposed text tape editing advice 
william described translator language english surface syntax lisp see section nearly elaborate flexible steele gabriel evolution lisp 
appear directly influenced teitelman teitelman cite cites papers collection containing berkeley 
spelling corrector designed compensate human 
symbol value function definition interlisp spelling corrector teitelman invoked symbol misspelled 
spelling corrector compared possibly misspelled symbol list known words 
user options controlling behavior system respect spelling correction 
system things correct automatically pause ask proposed correction acceptable simply signal error 
spelling corrector general control larger program called mean 
error sort detected interlisp system invoked determine appropriate action 
able correct forms parenthesis errors misspelling identifiers comprised common typographical errors users 
fit philosophy interlisp 
interlisp model emulate infinite login session 
interlisp programmer worked source code structure editor operated source code form memory resident lisp data structures 
changes code saved file served persistent repository programmer code 
changes saved 
memory resident structure considered primary representation program file merely stable backup copy 
maclisp model contrast programmer ascii files represented program character oriented editor 
file considered primary representation program 
conversational lisp mixed algol english syntax embedded normal interlisp syntax 
valid definition factorial written interlisp syntax factorial lambda factorial depended generic mechanism 
note effect rearrange tokens insert parentheses split atoms appropriate tokens 
user need put spaces infix operators 
defined useful set iteration constructs 
simple program print prime numbers range print spelling corrector recognize valid definition factorial teitelman factorial lambda interlisp eventually corrects definition valid form shown previously 
note shift left parenthesis model bit paired keyboard 
changed typewriter paired keyboards left parenthesis shift shift asterisk common 
facility finding information functions large system 
analyze body code build data base answer questions interactively 
kept track relationships functions called steele gabriel evolution lisp directly indirectly variables bound functions destructively altered certain data structures 
maclisp corresponding utility called index nearly general flexible ran batch mode producing file containing completely cross indexed report 
interlisp introduced lisp community concept block compilation multiple functions compiled single block resulted faster function calling possible interlisp 
interlisp ran pdp plural vax raymond variety specialpurpose lisp machines developed xerox bbn 
commonly available interlisp machines dolphin dorado collectively known machines 
dorado fastest commonly 
interesting different interlisp implementations different techniques handling special variables interlisp pdp shallow binding interlisp machines deep binding 
implementation techniques exhibit different performance profiles program certain run time regime take times longer 
situation unexpected performance prevalent lisp 
argue programmers produce efficient code language understand implementation 
implementation straightforward operations close correspondence machine operations von neumann architecture computer 
lisp implementation straightforward depends complex set implementation techniques choices 
programmer need familiar techniques selected performance ramifications techniques 
little wonder lisp programmers harder find programmers 
maclisp interlisp extended function calling mechanisms lisp respect arguments passed function 
interlisp function definitions specified arguments cross product attributes lambda versus spread versus 
lambda functions evaluate arguments functions evaluate arguments unevaluated argument call passed arguments 
spread functions require fixed number arguments functions accept variable number 
attributes quite orthogonal parameter bound list unevaluated argument forms parameter lambda bound number arguments passed arg function retrieve actual argument values 
close correspondence mechanisms interlisp maclisp interlisp maclisp lambda spread expr lambda spread equivalent important difference maclisp interlisp 
maclisp fixed number arguments quite rigid meaning function accepting arguments called exactly arguments 
interlisp function legitimately called number arguments excess argument forms evaluated values discarded missing argument values defaulted nil 
principal irreconcilable differences separating sides summit 
maclisp interlisp error prone interlisp fans thought steele gabriel evolution lisp maclisp awkward inflexible convenience optional arguments come maclisp optional complex lambda list syntax retrofitted late game lisp machine lisp 
innovative language extensions introduced interlisp spaghetti stack bobrow 
problem retention closures dynamic function definition environment presence special variables completely solved spaghetti stacks invented 
idea spaghetti stacks generalize structure stacks tree various branches tree subject retention pointer branch retained 
parts stack subject garbage collection policies lisp objects 
closures retained environment captures control environment binding environment 
minor interesting syntactic extensions interlisp 
right square bracket encountered read operation balances outstanding open left parentheses back outstanding left square bracket 
simple example syntax factorial lambda cond zerop times factorial sub maclisp interlisp came existence time lasted long 
differed user groups generic description groups distinguish groups researchers ai labs funded primarily arpa darpa researchers educated mit cmu stanford 
principal implementations ran machines lisp friendly environment lean mean high powered lisp 
primary differences came different philosophical approaches problem programming 
different pressures user groups maclisp users particularly group willing integrated programming environment exchange optimizing compiler having large fraction pdp address space left free 
interlisp users preferred concentrate task coding full integrated development environment 
early maclisp interlisp dominated major lisp dialects period 
similar maclisp interlisp 
widely dialects standard lisp marti portable standard lisp utah 
standard lisp defined anthony hearn martin griss students colleagues 
motivation define subset lisp lisp dialects serve medium porting lisp programs particularly symbolic algebra system reduce 
hearn colleagues discovered performance needed control environment compiler portable standard lisp psl born 
standard lisp attempted piggyback existing lisps psl complete new lisp implementation retargetable compiler griss important pioneering effort evolution lisp compilation technology 
psl ran ran dozen different types computers 
steele gabriel evolution lisp psl implemented techniques 
system implementation language called code operations raw untyped representations 
second parameterized set assembly level translation macros called macros 
portable lisp compiler plc compiled lisp code assembly language 
language converted machine dependent lap lisp assembly program format pattern matching macro descriptions instructions context 
example different machine instructions selected depending sources operands destination result operation 
half mid psl environment improved adapting editors tools 
particular emacs editor called developed allowed fairly intelligent editing passing information back forth lisp editor 
extensive version called developed martin griss colleagues hewlett packard palo alto california 
version psl commercialized hewlett packard mid 
stanford early version maclisp adapted pdp lisp called lisp 
early adaptation rewritten john allen lynn compiler improvements diffie 
lisp disappeared mid lisp era 
uci lisp bobrow extended version lisp interlisp style editor programming environment improvements 
uci lisp folks stanford early mid institutions 
mit version maclisp ported waits operating system gabriel stanford ai laboratory sail directed time john mccarthy 
demise pdp middle apparent bit address space pdp provide working space ai programs 
pdp line computers kl dec altered permit extended addressing scheme multiple bit address spaces addressed indexing relative bit base registers 
addition smooth expansion architecture far lisp implementor concerned change pointers word pointer word required complete redesign nearly internal data structures 
lisps implemented extended addressing charles rutgers psl 
response address space problem construct special purpose lisp machines see section 
response commercial computers stock hardware larger address spaces vax dec 
opportunities problems lisp implementors 
vax instruction set provided opportunities implementing low level lisp primitives efficiently required clever clever design data structures 
lisp function calls accurately modeled vax function call instructions 
vax despite theoretically large address space apparently designed small programs large ones 
page tables occupied large fraction memory paging overhead large lisp programs problem fully solved vax 
problem prior investment major lisp implementation time large assembly language base difficult port 
primary vax lisp dialects developed late vax interlisp psl ported vax franz lisp nil 
steele gabriel evolution lisp franz lisp written enable research symbolic algebra continue university california berkeley supervision richard fateman principal implementors macsyma mit 
fateman students started pdp version lisp written harvard extended maclisp lisp eventually ran virtually unix computers fact franz lisp written entirely nil burke intended successor maclisp designed jon white steele mit influence lisp machine lisp developed mit 
name cute acronym new implementation lisp caused certain amount confusion central role played lisp language atomic symbol named nil 
nil large lisp efficiency concerns paramount minds maclisp oriented implementors soon implementation centered large vax assembly language base 
gabriel steele set implement nil brooks mark iia supercomputer designed built lawrence livermore national laboratory 
close cooperation project aided fact steele room gabriel home 
lisp completely functional served testbed adapting advanced compiler techniques lisp implementation 
particular generalized numerical computation techniques maclisp compiler unified mainstream register allocation strategies brooks 
france mid patrick developed interpreter lisp called 
level base dialect interlisp introduced couple interesting concepts chronology sort dynamic environment implementing interrupts environmental functions trace step creating different incarnations evaluator 
emphasis having fast interpreter 
concept provide virtual machine transport evaluator 
virtual machine level assembly language designed easy porting efficient execution 
interpreter got significant part speed things fast function dispatch function type space distinguished number functions different arity tail recursion removal 
probably production quality lisp support general tail recursion removal 
dialects time including maclisp tail recursion removal certain situations manner guaranteed predictable 
precursor le lisp important lisp dialects france europe dialects different shared implementation techniques 
new commercial machines suitable lisp horizon appeared vax 
despite years valiant support glenn burke vax nil achieved widespread acceptance 
interlisp vax performance disaster 
generalpurpose workstations intended designed run languages lisp personal computers hadn quite appeared 
lisp implementors users commercial hardware situation looked quite 
onward research prototyping projects lisp machines decade appeared lisp machines wave 
lisp machines ideas lisp machine informally discussed peter deutsch published concrete proposal deutsch 
deutsch outlined basic vision single user class machine specially run lisp support steele gabriel evolution lisp lisp development environment 
key ideas deutsch lasting impact lisp duality load store access functions compact representation linear lists cdr coding 
lisp dialects time function car read component dotted pair nominally unrelated function write component 
deutsch proposed functions car load mode store mode 
called load mode return value called store mode new value stored location accessed load version 
deutsch indicated internal functions associated accessor function loading storing store function called function mentioned particular set special forms 
syntax suggestive proposed definition lambda car deutsch commented special form called quotes function evaluates 
name abbreviated setf lisp machine lisp 
deutsch attributed idea dual functions alan kay 
mit lisp machines richard greenblatt started mit lisp machine project proposal greenblatt cites deutsch 
project included thomas knight jack holloway pitts jarvis 
machine designed called cons design ideas xerox parc alto microprocessor dec pdp pdp extensions done cmu ideas instruction modification suggested sam fuller dec machine designed performance supporting version lisp upwards compatible maclisp augmented muddle conniver argument declaration syntax 
goals included non prohibitive cost machine single user operation common target language standardization procedure calls factor better storage efficiency pdp compiled programs hardware support type checking garbage collection largely lisp coded implementation reliance assembly language low level implementation language improved programming environment exploiting large bit mapped displays 
cons machine built subsequent improved version named cadr cadr means second lisp designed dozens built 
computational mit ai lab sensible spin machine 
disagreements principals companies formed lisp machine 
lmi symbolics 
initially manufactured cadr clones 
soon symbolics introduced line industry leader lisp machine performance years 
greenblatt paid particular care providing hardware mechanisms support fast garbage collection early mit lisp machines fact implement garbage collector quite years garbage collector appeared users preferred disable 
programming tools notably compiler program text editor designed avoid consing heap allocation explicitly reclaim temporary data structures possible lisp machine address spaces large virtual memory system user run days weeks having save running world disk restart 
copying back forth disk equivalent steele gabriel evolution lisp slow manually triggered copying garbage collector 
great deal theoretical interleaved concurrent garbage collection steele gries baker cohen continuous garbage collection universally accepted david moon invention ephemeral garbage collection implementation lisp machines moon 
ephemeral garbage collection subsequently adapted stock hardware 
early mit lisp machine lisp dialect weinreb similar maclisp 
lived stated goal supporting maclisp programs minimal porting effort 
important extensions maclisp included ffl improved programming environment consisting primarily resident compiler debugging facilities text editor 
brought lisp machine lisp closer interlisp ideal completely lisp programming environment firmly file oriented 
text editor emacs clone called eine eine emacs zwei zwei eine initially recursive acronyms course doubly version numbers german 
ffl complex lambda lists including optional key rest aux ffl provided ability point middle structure ffl defmacro convenient macro definition facility see section ffl backquote syntax constructing data structures filling template ffl stack groups provided coroutine facility ffl multiple values ability pass value back function invocation having construct list 
prior various ad hoc techniques lisp machine lisp dialect lisp provide primitives 
languages pop provided multiple values 
ffl record structure definition facility compare interlisp record package ffl closures special variables 
closures ones scheme variables captured environment explicitly listed programmer invocation closure required binding special variables saved values 
ffl flavors object oriented non hierarchical programming system multiple inheritance designed howard cannon david moon integrated parts lisp machine programming environment window system particular written flavors weinreb 
ffl setf facility generalized variables setf common lisp popular dialect lisp traced symbolics maclisp influence mit lisp machine lisp back greenblatt proposal peter deutsch alan kay 
uniform treatment access reading writing state common lisp uniform 
longer necessary remember reader function car separate writer update function remember order arguments comes dotted pair new value car 
general form read operation form write setf programmer needs know reading writing data 
common lisp object system clos idea extended methods 
method specified act reader invoked object possible define writer method invoked setf object 
steele gabriel evolution lisp clos fits idiom surprise 
alan kay inspiration idea midst early involvement smalltalk early object oriented language 
reading writing methods object support clos adaptation lisp version kay vision simple object oriented genesis idea 
xerox lisp machines alto machine developed thacker personal computing experimentation xerox interlisp languages mesa 
alto version interlisp environment went xerox parc stanford university 
alto standardly equipped bit words memory expandable words quite large single user computer half memory pdp 
machine proved large interlisp environment code density tricks discussed deutsch deutsch widely accepted users 
alto build smalltalk environment interim relatively successful 
xerox parc undertook design machine called dorado xerox ecl emitter coupled logic time fast digital logic implementation technology machine designed replace alto 
prototype available ran alto software 
redesign completed number built xerox certain experimental sites stanford university 
dorado specifically designed interpret byte codes produced compilers dorado ran alto software 
dorado basically emulation machine 
interlisp ported machine interlisp virtual machine model moore 
dorado running interlisp faster kl running single user interlisp proved nice lisp machine widely available commercially 
interlisp similarly ported smaller cheaper machine called dolphin commercially available lisp machine late 
performance dolphin better alto bad machine truly successful lisp engine 
early xerox built machine called considerably faster dolphin fast dorado 
names machines began letter collectively known machines 
xerox lisp machines count garbage collector deutsch incremental steps garbage collection process execute time storage allocated 
short bounded amount done garbage collection unit time 
late bbn built machine interlisp engine 
remained internal bbn 
comments early lisp machine history freed address space constraints previous architectures lisp machine companies produced greatly expanded lisp implementations adding graphics windowing capabilities mouse interaction capabilities programming environments 
lisp language particularly mit lisp machines grew number complexity features 
steele gabriel evolution lisp ideas originated adoption lisp community driven success lisp machines quality ideas 
users value lay ultimately software enabling hardware technology 
lisp machine companies ran difficulty late didn fully understand consequences fact 
general purpose hardware eventually support lisp lisp implementations machines began compete effectively 
ibm lisps lisp lisp lisps implemented ibm computers ibm faded lisp scene late reasons better cooperation mit dec patent dispute mit ibm 
early digital equipment discussed mit needs mit computers features added help lisp implementations 
bit word hold addresses form dotted pair pdp successor pdp address bits 
pdp instructions car cdr particularly fast easy implement 
stack instructions stack function calling instructions improved speed lisp function calls 
mit ai laboratory received second pdp lab computing engine replaced pdp 
early ibm mit disputed invented core memory ibm insisted enforcing patents mit 
mit responded declining ibm equipment extensively past 
provided impetus dec equipment particularly lisp ai 
lisp implemented ibm ibm called lisp 
ibm came lisp implementation began 
lisp called lisp vm 
lisp basically batch lisp fairly extensively teaching universities 
lisp began definition core lisp formal semantics expressed secd model landin 
definition fit pages 
lisp project direction fred blair developed secd definition ibm thomas watson research center yorktown heights new york 
members group included richard ii cyril mark wegman martin served primarily research groups scratchpad symbolic computation group ai groups yorktown 
lisp supported special binding lexical binding closures lexical special variables technique similar spaghetti stacks 
jon white spent calendar year yorktown heights working lisp returned mit experience ibm influence subsequent maclisp development nil dialect 
lisp interlisp programming environment written operate terminals ubiquitous ibm character display terminal 
interlisp model ideal developed slow terminals mind half duplex nature ibm mainframe interactions similar feel 
summer gabriel wrote version environment duplicate environment written maclisp stanford ai lab 
mark wegman colleagues yorktown extended environment include screen line interaction editing 
improvements underlying lisp system performance separation compilation runtime environments accomplished steele gabriel evolution lisp separate lisp images 
lisps appeared line computers including common lisps 
common lisp appear ibm written featuring compilation technology 
lisp constructed impact lisp world 
years lucid ported common lisp contract ibm 
ibm support lisp late favor common lisp 
scheme dialect lisp known scheme originally attempt gerald jay sussman steele autumn explicate aspects carl hewitt theory actors model computation 
hewitt model object oriented influenced smalltalk object computationally active entity capable receiving reacting messages 
objects called actors messages actors 
actor arbitrarily acquaintances know hewitt language actors send messages send acquaintances parts messages 
message passing means interaction 
functional interactions modeled continuations send actor named factorial number actor send eventually computed value presumably 
sussman steele trouble understanding consequences model hewitt papers language design decided construct toy implementation actor language order experiment 
maclisp working environment wrote tiny lisp interpreter add necessary mechanisms creating actors sending messages 
toy lisp provide necessary primitives implementing internal behavior primitive actors 
sussman just studying algol naur suggested starting lexically scoped dialect lisp 
issues necessary mechanisms explored joel moses moses 
appeared mechanism needed anyway keeping track acquaintances actors 
lexical scoping allowed actors functions created identical mechanisms 
evaluating form word lambda capture current variable lookup environment create closure evaluating form word alpha capture current environment create actor 
message passing expressed syntactically way function invocation 
difference actor function detected part interpreter traditionally known apply 
function return value actor return typically invoke continuation actor knows 
define function define factorial lambda factorial equivalent actor define alpha alpha steele gabriel evolution lisp note example values passed message invokes outer alpha expression acquaintances continuation actor created inner alpha expression 
continuation passed explicitly recursive invocation expected return value 
sussman steele pleased toy actor implementation named expectation develop ai language tradition planner conniver 
operating system character limitation file names name truncated simply scheme name stuck 
came crucial discovery illustrates value experimentation language design 
inspecting code apply got working correctly sussman steele discover codes apply function application actor invocation identical 
inspection parts interpreter code creating functions actors confirmed insight fact functions intended return values actors difference implementation 
difference lay purely primitives code bodies 
underlying primitives return values user write functions return values primitives expect continuations user write actors 
lambda alpha mechanisms identical sussman steele concluded actors closures concept 
hewitt agreed assessment noting types primitive actor theory cells modifiable state synchronizers enforce exclusive access expressed closures lexically scoped pure lisp adding equivalent primitive extensions 
sussman steele think actors model lisp having discovery scheme ai language capturing ideas floating data control structure simpler framework 
initial report scheme sussman describes spare language minimum primitive constructs concept 
take 
function constructor lambda fixpoint operator labels condition side effect aset continuation accessor catch function application variable 
assortment primitive data structures symbols lists numbers associated operations regarded practical conveniences theoretical requirements 
sussman steele wrote papers explored programming language semantics scheme framework 
lambda ultimate imperative steele demonstrated wide variety control structure ideas modeled scheme 
models drew earlier peter landin john reynolds landin reynolds friedman 
partly tutorial intent partly consolidated catalog control structures 
notable long series lambda ultimate papers running gag known lisp community considered harmful titles broader programming languages community 
lambda ultimate declarative steele concentrated nature lambda renaming construct provided extensive comparison scheme hewitt plasma see section relating objectoriented programming generally actors specifically closures 
turn suggested set techniques constructing practical compiler scheme outlined detail 
thesis proposal resulting dissertation discussed scheme compiler called rabbit steele 
mitchell wand daniel friedman doing similar indiana university wand exchanged papers sussman steele period 
steele gabriel evolution lisp subsequently steele sussman wrote revised report scheme steele title report intended tribute algol turn inspired increasingly silly series titles clinger clinger rees 
shortly wrote extended monograph title play art fugue illustrating numerous small lisp interpreters variations 
monograph finished parts zero published steele 
part zero introduced tiny order dialect lisp modeled recursion equations 
part discussed procedures data explored lexical dynamic binding 
part addressed decomposition state meaning side effects 
part covered order evaluation call value versus call name part intended cover metalanguage macro processors compilers 
parts written great loss topics soon treated adequately researchers 
art interpreter achieved scheme underground rejected acm journal 
great deal papers new main contribution bridge gap models theoreticians studying actors lambda calculus church lisp implementors users 
scheme theoretical contributions areas denotational semantics accessible lisp hackers provided usable operational platform experimentation theoreticians 
need centralized implementation group support scheme large number sites wide variety machines 
standard lisp smaller simpler scheme put top lisp system short time 
local implementations dialects sites example scheme indiana university clinger years serious attempt produce portable stand scheme system 
extensive scheme implementations carried yale mit jonathan rees norman adams 
resulted dialect scheme known name joke scheme approximately nil dialect maclisp 
goal simple dialect especially efficient implementation rees centers small core language free complicated features easy learn refrained supporting features didn feel completely right 
omissions important avoided complicated argument list syntax common lisp keyword options multiple functionality overloaded single functions 
far easier generalize implement regret 
features carefully considered stylistic purity generality 
design represented conscious break lisp tradition earlier versions scheme places steele sussman relied tradition cleaning things 
names built functions regularized 
replaced traditional suffix universal question mark number 
null null 
similarly destructive operation name exclamation point maclisp name destructive version append append 
muddle galley introduced question mark indicate predicates sussman convention years writing 
interlisp consistent system labeling destructive operations maclisp letter prefix 
initially targeted vax unix vms apollo workstations 
system written bootstrapped compiler tc 
evaluator garbage collector particular written machine language 
project steele gabriel evolution lisp started version lisp compiler brooks substantial improvements course identified bugs compiler original report rabbit steele 
lisp compiler relied heavily optimization strategies mainstream compiler literature notably wulf bliss compiler wulf 
second generation compiler called orbit kranz integrated host mainstream lisp specific optimization strategies resulting truly production quality scheme environment 
rabbit organized principle translating lisp code performing source source conversion continuation passing style cps orbit generalized extended strategy handle assignments variables 
register allocator trace scheduling optimize register usage forks joins procedure calls 
orbit supported calls procedures written languages lisp 
contemporaneous efforts cmu develop general foreign function call mechanisms common lisp 
prelude common lisp spring situation follows 
lisp machine companies mit lisp machine project lisp machine 
lmi symbolics founded principally richard greenblatt larger group including david moon 
initially cadr second mit lisp machine licensed lisp machine software mit arrangement included passing back improvements companies 
symbolics soon embarked designing building follow lisp machine 
language lisp machine lisp evolved greatly definition published acquiring variety new features notably objectoriented extension called flavors 
xerox lisp machines dolphin dorado running interlisp research laboratories located west coast 
bbn constructing interlisp machine port interlisp vax way 
mit project started define implement descendant maclisp called nil vax computers 
cmu scott fahlman colleagues students defining implementing maclisp dialect lisp called spice lisp implemented spice machine scientific personal integrated computing environment 
early common lisp consolidation lisp community point lisp died 
arpa interested funding variety needlessly competing different lisp projects 
commercial arena 
chaos maclisp april arpa called lisp community meeting implementation groups got discuss lisp 
arpa sponsored lot ai research goal see done stem tide increasingly diverse set lisp dialects research community 
day arpa meeting part interlisp community got discuss picture healthy interlisp community variety machines 
idea steele gabriel evolution lisp push view standard language interlisp standard environment existing increasing number different types computers 
day meeting interlisp community successfully coherent group goal mission 
maclisp descended groups came way best demonstrated 
group stood heading 
questions arose ill defined direction maclisp community contrast interlisp community 
scott fahlman said maclisp community state chaos 
consists welldefined groups going defined directions 
moment pause laughter steele 
gabriel attended interlisp pow wow day arpa meeting witnessed spectacle maclisp community meeting 
didn believe differences maclisp groups insurmountable began try sell idea sort cooperation groups 
approached jon white 
second gabriel white approached steele cmu affiliated spice lisp project 
associated way nil project 
months gabriel steele white fahlman william scherlis colleague gabriel cmu rodney brooks part lisp project met cmu technical details new lisp discussed 
new dialect basic features ffl lexical scoping including full closures ffl multiple values lisp machine lisp modifications single value forcing situations ffl separate value function cells lisp gabriel see section ffl ffl setf ffl fancy floating point numbers including complex rational numbers primary influence lisp ffl complex lambda list declarations similar lisp machine lisp ffl dynamic closures closures special variables dynamically bound called nil day half technical discussion group went oakland original submarine sandwich place far cmu 
lunch topic name lisp came obvious names nil spice lisp proposed rejected giving credit group non obvious names yu hsiang lisp proposed rejected 
name felt best standard lisp dialect known name 
search similar words name common lisp came 
gabriel remarked wasn name trying define elitist lisp common lisp sounded common man lisp 
names lisp 
naming discussion resumed dinner pleasure bar italian restaurant pittsburgh district luck 
mail moon referred call common lisp time great sadness better name selected 
steele gabriel evolution lisp step contact groups 
key lisp machine companies approached 
addition gabriel volunteered visit franz lisp group berkeley psl group salt lake city 
psl group fully join common lisp group franz group join 
lisp group oversight invited 
interlisp community sent observer 
arpa successfully pulled supporting effort 
people groups engaged effort large arpanet affiliated associated ai labs natural decide network electronic mail automatically archived 
fact major language standardization effort carried nearly entirely mail 
meeting symbolics lmi took place symbolics june 
steele gabriel drove pittsburgh cambridge meeting 
meeting alternated deep technical discussion dialect political discussion new dialect thing 
point view lisp machine companies action lisp machines interest dialect running places academic 
course business reasons getting dialect running places people business sense attend meeting 
lisp machine companies decided join effort common lisp group formed alan bawden richard gabriel william scherlis rodney brooks joseph richard stallman richard bryan richard greenblatt barbara steele glenn burke martin griss guy steele jr howard cannon charles william george earl killian walter van david dill john allan scott fahlman larry masinter daniel weinreb richard fateman john mccarthy jon white neal don morrison richard john david moon leonard compromise agreed worth defining family languages way program written language defined run language family 
sort subset defined wasn clear implement subset directly 
lisp machine features dropped flavors window systems multiprocessing including multitasking graphics 
summer steele worked initial common lisp manual spice lisp manual 
initial assisted brooks scherlis gabriel 
scherlis provided specific assistance type system form informal advice steele 
gabriel steele regularly discussed issues gabriel living steele home summer 
draft called swiss cheese edition full large holes partly ballot various alternatives questions proposed 
process mail discussion voting key decisions 
followed face face meeting november final decisions difficult questions settled 
led round refinement similar drafts ballots 
mail discussions form proposals discussions 
code examples existing software proposed new syntax exchanged 
mail steele gabriel evolution lisp archived line available quick review people wishing come speed go back record 
style drawbacks 
foremost possible observe reactions people example see point mean point important 
way see argument gone far little support 
meant time wasted carefully crafted written arguments required get done 
process began approach problem changed just consolidation existing dialects obvious direction take trying design right thing raymond 
people took view time rethink issues abandon goal strict maclisp compatibility important early lisp designs 
issues nil symbol cons cell generally agreed 
issue came early worth mentioning heart major attacks common lisp mounted iso lisp see section 
issue modularization aspects common lisp divided core language plus modules division called white yellow red pages 
topics appear blended discussion 
white pages refers manual proper white pages implemented lisp developers claim common lisp 
yellow pages refers implementation independent packages loaded example trace scientific subroutine packages 
red pages intended describe implementation dependent routines device drivers 
common lisp broken core language plus layers white yellow red pages division materialized 
drafts edition july laser edition november edition july mary edition november 
cute names explained subtitles holes re smaller 
laser edition supposed completely coherent mary edition practically perfect way edition recall term name wood suitable packing material 
virtually technical decisions completed early year book common lisp language available fast publishing job digital press 
declared goals common lisp group paraphrased ffl commonality common lisp originated attempt focus implementation groups constructing successor implementations maclisp different computers 
differences implementations continue force incompatibilities common lisp serve common dialect implementations 
ffl portability common lisp exclude features easily implemented broad class computers 
serve exclude features requiring microcode hardware hand features generally required stock hardware example declarations 
steele gabriel evolution lisp ffl consistency interpreter compiler exhibit semantics 
ffl expressiveness common lisp cull best experience variety dialects including maclisp interlisp 
ffl compatibility common lisp strive compatible maclisp interlisp order 
ffl efficiency possible write optimizing compiler common lisp 
ffl power common lisp system building language suitable writing interlisp user level packages provide packages 
ffl stability common lisp evolve slowly deliberation 
early common lisp definition process 
feeling things going 
interlisp group input process point wrote interlisp community bit contribution endeavor 
clear common lisp going settle languages features interlisp favor 

part problem strength lisp machine companies need common lisp group keep fold particularly strong brand power 
point people early common lisp group put sorry current version draft really gives feeling largest subset lisp machine lisp try force throat call standard 
lisp machine folks flavor argument hard contend experience large software systems realm particular solutions come right thing 
net effect common lisp grew grew 
think voices stock machine crowd write compilers common lisp objected strongest voices steele gabriel feeling ability write powerful compiler foil complexities common lisp 
heard moon sufficiently smart compiler solve particular problem 
pretty soon core group quoting ssc argument regularly 
loyal opposition term mild 
core group eventually authors steele scott fahlman gabriel david moon daniel weinreb 
group responsibility producing language specification document conducting review 
self adopted name group informally gang 
critique common lisp acm symposium lisp functional programming rod brooks gabriel broke rank delivered opening critique common lisp brooks 
gabriel brooks founders business steele gabriel evolution lisp plan premier common lisp 
fahlman hearing speech delivered gabriel called 
string critiques common lisp critiques quoted 
high points reveal series problems proved plague common lisp decade 
theme history common lisp emergence number uncommon lisps tolerance twisted 
uncommon lisp better approaches shortcomings common lisp 
examples lisp dialects officially declared uncommon lisps time lisp scheme 
clearly attempt distance perceived shortcomings common lisp clearly term attests apparent real strength common lisp primary lisp dialect 
define lisp standing contrast dialect admit dialect 
imagine ford advertising 
single phenomenon behavior demonstrates key ingredients lisp diversification extreme juvenile dialect groups 
seen lisp scheme 
european response common lisp developed lingua franca lisp europe 
primary characteristics lisp separate function variable namespaces clos style generic function type objectoriented system integrated ground built module system defined layers promote lisp small embedded hardware educational machines 
common lisp 
definition took long time started wasn implementation available interpreter nearly complete language specification 
layered definition module system object orientedness start demonstrate new lessons learned lisp world 
lisp dialects rest world stand common lisp developed common lisp focus lot attention 
lisp dialects stock hardware portable standard lisp spread vax variety mc machines cray 
environment proved appealing hewlett packard face growing common lisp presence 
franz lisp ported systems workhorse stock hardware lisp years leading general availability common lisp 
market dolphin beating performance primarily slow machine ran interlisp virtual machine 
efforts xerox aimed porting performance little attention improving dialect environment continued area 
main interlisp developers busy tuning 
interlisp vax appearance regarded failure contributing causes provided compatibility interlisp branch interlisp family doomed eventual demise pdp interlisp provided copy garbage collector particularly bad performance vax rest steele gabriel evolution lisp lisp world including interlisp world personal lisp machines vax taken seriously lisp purposes small number businesses 
france colleagues developed new dialect lisp called le lisp 
dialect reminiscent maclisp focused portability efficiency 
needed portable computer situation europe clear lisp 
lisp machines dominant lisp europe machines available prohibitively expensive 
research labs europe frequently acquired range peculiar machines perspective 
portability 
experience taught performance portability go extending techniques group able achieve goals 
dialect ran different machines demonstrated performance better franz lisp comparable alternative 
vax le lisp performed symbolics 
addition le lisp provided full fledged programming environment called 
full set debugging aids full screen multi window structure editor pretty printer object oriented programming extension called 
scheme community grew larger group characterized interest mathematical aspects programming languages 
scheme small size roots lambda calculus generally compact semantic underpinnings began popular vehicle research teaching 
particular strong groups scheme supporters developed mit indiana university rice university 
groups started mit indiana graduates joined faculty schools 
mit guidance gerry sussman hal abelson scheme adopted teaching undergraduate computing 
book structure interpretation computer programs abelson classic scheme larger community 
companies commercial implementations scheme 
cadence research systems started kent dybvig chez scheme ran various workstations 
semantic microsystems clinger anne john ulrich produced apple macintosh 
pc scheme texas instruments ran ibm pc clones ti built sold 
original revised report scheme taken model definitions scheme self selected group called scheme authors took role evolving scheme 
rule adopted features added unanimous consent 
fairly short period certain features call current continuation added rate change scheme slowed rule 
peer pressure highly intellectual group convince author change 
result widely held belief feature added scheme clearly right thing 
example late macros added language appendix partially standardized facility 
emerged series revised reports called revised revised report scheme 
late revised revised revised revised report scheme written approved called rs 
members common lisp group deep seated love scheme secret desire see lisp standard 
parts scheme common lisp communities bitter rivals part decade 
steele gabriel evolution lisp name symbolics version lisp machine lisp 
symbolics second generation lisp machine described programmed entirely lisp came require significant set capabilities seen single lisp point 
ordinary programming operating system editor compiler network server garbage collector window system programmed earlier lisp machine lisp quite tasks expanded handle 
primary addition lisp machine lisp flavors called non hierarchical objectoriented language multiple inheritance message passing system developed ideas howard cannon 
development ideas coherent system largely due david moon cannon continued play key role 
features flavors driven needs lisp machine window system long time regarded example system programming required multiple inheritance 
noteworthy additions format setf complex arrays complex optional keyword named arguments 
format mechanism producing string output conveniently basically pre determined string placeholders substituting computed values strings placeholders complex placeholders included iteration primitives producing lists results plurals exotica 
may loosely characterized fortran format statements gone 
setf discussed section factors acceptance importance acceptance lisp machines discussed section 
lisp machines particularly symbolics lisp machines popular vehicles real lisp commercial setting grow explicit belief fostered symbolics lisp machine lisp primary dialect lisp 
symbolics folks taken seriously strong political force required political ally success wider lisp standard 
early lisp machine companies primary lisp machine companies symbolics lisp machine 
lmi rivers computer renamed principal product xerox texas instruments ti 
symbolics lmi ti basically software licensed mit basis offerings 
software included lisp implementation operating system editor window system network software utilities 
arrangement software cheaply freely available long improvements passed back mit 
companies competed primarily basis hardware performance secondarily availability advances common software base software passed back common source 
companies produced proprietary extensions fortran implementations symbolics 
xerox produced machines ran interlisp 
rivers sold machine ran pascal operating system language spice lisp common lisp spice lisp 
lisp machine companies started existing software lisp machine companies licensed software university 
steele gabriel evolution lisp companies symbolics successful measured number installations pre common lisp era followed xerox ti ti possibly claimed installed machines basis large purchases 
symbolics interesting companies extreme influence symbolics direction common lisp want claim companies strong significance 
popularity apparent influence people common lisp group stemmed largely popularity 
second generation lisp machine version cadr called lm 
symbolics lmi started businesses producing essentially cadr 
symbolics business plan produce faster lisp machine enter workstation 
easy forget early workstations workstations generally computationally persons take seriously 
pdp offered vastly better performance workstations simply obvious engineers warm form large new market 
furthermore clear unix workstation necessarily winner thought applications drive market software development 
foolish symbolics business plan 
symbolics lmi founded rivals mit ai lab richard greenblatt founding lmi founding symbolics notably hackers david moon dan weinreb howard cannon tom knight 
factors adoption symbolics lisp machines fact garbage collector meant performance penalty garbage collecting large address space observed 
originally baker style incremental copy collector baker address space large ordinary programs exhaust memory days intensive ones run hours 
facility saving running image basically copy garbage collection disk image resumed 
garbage collecting fly programmer run memory exhausted start lengthy hours process disk saving restart program dinner day 
incremental garbage collector released years 
proved relatively bad performance possibly due paging problems 
moon developed ephemeral garbage collector similar ungar generation scavenger collector developed smalltalk ungar 
generation scavenging objects promoted generation copy process 
generations objects promoted long term storage 
idea object garbage soon creation look ages objects concentrate young objects get garbage small working set maintained paging performance 
ephemeral garbage collection moon similar maintains consing areas representing generations list regions memory pointers objects consing areas created regions scanned copy operation moving generation 
objects smalltalk created frequently lisp tradeoffs little different data structures different 
ephemeral garbage collector proved effective years sold effective garbage collector operational 
took users get performance differences established position firmly implanted 
steele gabriel evolution lisp entered market poorly performing machine document preparation computer 
scott fahlman involved common lisp spice lisp code nearly compliant common lisp common lisp available lisp machine 
original versions commercial impact outside pittsburgh area probably performance price performance relatively poor 
early history xerox machines discussed 
common lisp era widespread interlisp circles 
texas instruments began enter lisp machine business just published early 
began viking project relation current implementation sparc microprocessor architecture ran spice lisp motorola mc microprocessor 
decided go pure lisp machine route introduced explorer machine ran mit software 
ti joined lmi trade technology little effect business inject capital lmi prolonging existence 
explorer price performance decent absolute performance 
high favor ti held department defense resulted sales ti early common lisp era 
maclisp decline maclisp widespread spreading bit development halted early 
point maclisp ran multics tops tops waits multics various operating systems pdp 
funding maclisp development provided macsyma group primary client maclisp point view mit people macsyma macsyma consortium 
point view rest world macsyma interesting application lisp maclisp wider appeal research development tool ai particularly vision robotics 
groups flush funding event reason accept freely available maclisp mit saw fit provide 
funding maclisp funding nil vax department energy 
department energy things research development nuclear weapons addition benign projects civilian energy 
doe alternative source defense funding funded projects lisp 
general site maclisp local wizard able handle problems encountered possibly consulting jon white 
case funding available mit custom 
instance single segment version maclisp waits paid stanford ai lab done site howard cannon 
maclisp host variety language development features years including conniver scheme flavors frames extends various features 
major piece research maclisp multi program programming environment done martin frost gabriel stanford gabriel 
environment defined protocol allowed maclisp stanford display editor operating system support communicate mailbox style operating system mechanism 
mechanism code devoted editing shared users tasks timesharing mechanism underlying host computer frequently code executed purpose editing executed operating system requiring code swapped paged 
possible lisp programs control editor steele gabriel evolution lisp powerful editor macros written lisp arcane macro language 
environment similar lisp emacs environments years 
early days common lisp group funding nil vax doe macsyma consortium halted fueled belief lisp machines run macsyma fueled belief development common lisp provide common base macsyma 
time doe funding stopped symbolics started macsyma group sell lisp machine macsyma 
group remained profitable late early 
nil funding jon white joined xerox interlisp 
stranger situation difficult imagine 
white apparently clearly personality aura california lifestyle foreign accept 
second intense maclisp interlisp years prevented working 
standards development period just release common lisp language marked era unprecedented lisp popularity 
large part popularity coupled popularity ai entirely 
look ingredients ffl time commonly agreed standard lisp albeit flawed 
ffl ai rise lisp language ai 
ffl appeared burgeoning workstation market performance workstations lisp far lisp machines 
ffl venture capital community looking success companies sun awed prospects ai lot money result economy half reagan 
ffl computer scientists turning entrepreneurs spurred near instant success colleagues companies sun valid 
articles lisp written popular magazines requests common lisp streaming places cmu fahlman stanford gabriel academic people asked speak industry conferences workshops topics ai lisp regarded sages trends 
key impetus interest industry lisp ai problems hardware control beast software 
traditional methods inadequate feeling new thing radical thing thorough effect old conservative thing 
ai lisp attracted venture 
early year published companies founded common lisp 
included franz gold hill computers lucid companies fringe lisp joined lisp common lisp lisps road common lisp 
included rivers ti 
mainstream computer manufacturers joined lisp business 
included dec hp sun apollo prime ibm 
european companies joined common lisp including siemens honeywell bull 
old players began common lisp 
included lisp machine companies xerox 
new player japan kyoto common lisp kcl provided steele gabriel evolution lisp bit spoiler kcl compiler compiles compiled compiler 
lisp licensed essentially free common lisp companies suddenly surprising competitor 
surprising appeared just came implementation mary draft 
kcl notable implemented outsiders hagiya solely basis specification 
effort exposed quite number holes mistakes specification gone having participated historical development common lisp consciously unconsciously corrected mistakes went basis additional shared knowledge 
think free quality product easily beat expensive product proved false common lisp companies despite cost competitor 
turned better performance better quality commitment developers moving ahead standard better service important price tag 
common lisp companies franz business selling franz lisp maclisp lisp dialect transport version macsyma called 
franz lisp popular dialect lisp vax plausible common lisps appeared 
franz decided go common lisp market funding effort proceeds franz lisp sales 
principal founders franz fritz kunze john richard fateman 
kunze phd student fateman university california berkeley mathematics department having obtained phd fateman primary architect implementor various lisps offered franz fateman original implementors macsyma mit carried maclisp lisp torch berkeley responsible porting macsyma vax 
franz adopted direct sales strategy targeted customers sold directly 
gold hill division parent named founded carl hewitt student jerry barber 
barber spent year founding gold hill inria france wrote maclisp lisp ibm pc 
partly funded inria 
returned close common lisp hewitt barber thought capitalize wave common interest selling existing lisp lisp common lisp 
pc believed important machine ai business plan variety east coast venture invested 
gold hill lisp common lisp early years criticism false advertising worse lisp transformed common lisp quality apparently dropped 
time called ai winter hit gold hill able survive level 
abandoned venture laid just employees continues today man operation 
gold hill sold direct 
ai winter term describe unfortunate commercial fate ai 
late mid artificial intelligence important part computer business companies started abundant venture capital available high tech start ups 
clear business analysts ai experience growth ai lisp commercial concern 
ai companies started substantial financial difficulties lisp companies 
lucid founded gabriel stanford rod brooks mit eric benson utah psl scott fahlman cmu 
backed venture capital lucid adopted different strategy common lisp companies 
starting spice lisp steele gabriel evolution lisp source code lucid wrote implementation common lisp scratch adopted oem strategy 
oem idea arrangements computer hardware market sell lisp name 
lisp implemented maintained outside case lucid collects 
lucid quickly struck oem deals sun apollo prime 
possible lucid traded strength names founders fact writing common lisp scratch true common lisp 
eventually lucid ported lisp established oem arrangements ibm dec hp 
relatively small copy oem route established lucid primary stock hardware lisp 
hardware companies enthusiastic business opportunities ai lisp invested lot business 
pay large porting fee fixed price licensing fee maintenance fees 
getting sun oem key lucid survival sun workstations developed needed attract customers lisp 
sun regarded leading edge people interested leading edge ai technology headed sun 
sun employed number engineers lisp development area programming environments 
ai winter hit lucid began languages programming environments 
big companies lisps dec hp implemented lisps 
dec started spice lisp code hp psl 
believed ai take having lisp essential ingredient success ai business 
dec hp arrangements original implementors lisps hiring students worked arranging going consulting 
dec hp grew fairly large businesses lisp groups large standards lisp companies 
peak lisp quarter main players lisp business revenue symbolics ti dec hp sun lucid 
dec hp put lot effort lisp offerings primarily area environments performance lisp system 
quarter hp realized psl winner needed provide common lisp 
chose lucid provide reduced engineering staff choosing focus marketing 
ai winter just decision clear perception situation forced cut back lisp investment 
early midst ai winter dec decided abandon efforts chose lucid 
ibm number platforms suitable lisp pc mainframe rt 
ibm initially decided put common lisp rt 
ibm funded pilot program put spice lisp common lisp rt ibm real entry workstation market 
fahlman relationship lucid founder contract eventually written lucid port lisp rt ibm 
ibm workstation market rs performance lucid common lisp 
ibm eventually contracted lucid provide lisp ps running aix version unix 
xerox produced common lisp compatibility package top interlisp 
package really strong success xerox late got lisp business steele gabriel evolution lisp licensing lisp software started xerox called 
put real common lisp implementation sold interlisp environment 
went business years founded 
left venue essentially granted rights continue marketing software direct funding 
funding provided servicing xerox lisp customer base maintenance 
darpa sail mailing lists right published arpa renamed darpa took real interest common lisp 
sponsored community meeting encouraged development common lisp full development system including object oriented extension multitasking window systems graphics foreign function interfaces iteration 
darpa wished resurgence lisp willing provide funds help purpose 
meeting new mailing lists set sail discussion topics lists quiet witnessed interesting discussions 
start ansi technical committee follow meeting year december boston massachusetts apparently benign technical meeting interrupted announcement common lisp standardized darpa announced robert mathis iso working group ada programming language head effort 
reason sudden need european lisp community planning launch lisp standardization effort iso head spread common lisp 
mathis international experience darpa natural choice head response confused soon previously common lisp group think little go 
period spring spring combination political interesting lisp development 
usual impetus lisp development increase expressive power lisp 
political centered different objectives common lisp individual put mark language outside common lisp various groups tried minimize size lisp guarantee survival academic commercial 
months december meeting meeting computer business equipment manufacturers association washington 
serves secretariat accredited standard committee information processing systems operating procedures ansi american national standards institute 
better known technical committees computer graphics including programming language fortran programming language cobol programming language 
goals standardization discussed important topic pushed darpa merge scheme activities technical issues surrounded treatment macros separate namespace functions separate ordinary variables 
goals new group soon technical committee programming language common lisp discussed 
point namespaces important understanding debate lisp dialect proponents 
namespace mapping identifier string characters meaning 
common lisp number namespaces variables functions types tags blocks steele gabriel evolution lisp catch tags 
lisp separate namespaces variables functions users allowed variable names name functions evaluation rules specify namespace look meaning 
lisp single namespace user careful creating variable names avoid shadowing function name 
issue important macros effect carefully decide free variable intended mean 
namespaces lisp variable function namespaces problems lie practice issue reduces question variable names function names belong namespace separate namespaces 
referred lisp versus lisp debate 
lisp lisp functions variables namespace lisp lisp separate namespaces 
effort merge scheme common lisp communities launched fronts 
try come solution macro problem lisp causes 
problem namespace relatively easier stumble unintended name conflict leading incorrect code 
key common lisp leaders felt macro problem solved common lisp survive transition lisp lisp 
front try convince scheme community idea 
front gabriel kent pitman produced report detailing technical issues involved macros gabriel 
technical solutions appeared time promising described kohlbecker dissertation kohlbecker 
second front gabriel clinger approached scheme community soundly rejected association common lisp community 
sadly attempts bring communities serious dialog groups 
clear european lisp community eventually produce new lisp dialect informally called community intended start iso effort standardize dialect 
dialect lisp defined layers small kernel language increasingly larger ones goal common lisp sized layer 
object oriented facility modules multitasking condition system 
lisp 
condition system facility defining handling user exceptions handling system exceptions 
common lisp facility provides mechanism executing user defined code dynamic context error 
important technical development period common lisp object system clos 
groups began vie defining object oriented programming part common lisp new flavors symbolics symbolics xerox bobrow object lisp lmi drescher common objects hp 
battle group formed write standard clos new flavors 
group david moon symbolics daniel bobrow xerox gregor kiczales xerox keene symbolics writer linda demichiel lucid gabriel lucid 
certain informally group patrick ti jim hp jon white lucid 
clos specification took years specification adopted june changes 
clos features ffl multiple inheritance linearization algorithm resolve conflicts order methods 
multiple inheritance provides mechanism build new classes combining mixins classes provide structure behavior 
programming multiple inheritance enables designer combine desired behavior having select closest steele gabriel evolution lisp existing class modify start fresh single inheritance chain 
ffl generic functions methods selected classes required arguments 
contrast message passing model message sent single object class selects method invoke 
ffl method combination provides mechanism take behaviors component parts blend 
method combination important aspect multiple inheritance combined class provide part behavior needed programmer need code combining method existing methods 
ffl metaclasses instances classes control representation instances classes 
ffl meta objects control behavior clos 
clos viewed program written clos 
clos program customized clos 
ffl elaborate object creation initialization protocol provide user customization instance creation change class reinitialization class redefinition processes 
deliberations number additions common lisp iteration facility condition system better specification compilation evaluation semantics hundreds small 
process scheme process 
scheme process allowed person veto addition 
process went majority vote 
allowed great deal log rolling committee members eager put mark common lisp 
iteration facility called loop consists single macro elaborate cobol syntax 
debate facility times intense especially scott fahlman active common lisp 
non syntax remains easy 
see sections condition system developed exception handling capabilities common lisp introducing class conditions mechanisms defining conditions certain classes handled automatically human intervention 
adoption facility easier adoption clos paved way cleaner formulation basic mechanisms 
condition system completely cleaned 
example clauses appear syntactically method definitions selected class specificity treated cond clauses 
iso created working group called wg process standardizing lisp international level 
primary contenders common lisp 
political goal displace common lisp europe 
standards strong influence europe standards organization real europe iso route dictated 
intellectual goal clean commercial quality layered lisp dialect 
appears met goals consider nicer lisp definitions commercial implementations 
years managed keep progress iso committee compromise worked essentially near subset common lisp clos form basis kernel lisp dialect 
darpa called lisp meeting discuss bringing scheme common lisp communities earlier attempts failed primarily scheme steele gabriel evolution lisp community want common lisp 
attending meeting bill scherlis steve gabriel daniel bobrow gerry sussman scott fahlman 
scheme began ieee standardization process culminated ieee ansi standard ieee virtually public review period 
structure scheme standards official standard lags informal report standard corresponds gamma report report current 
non intrusive garbage collectors appeared companies lucid franz 
lucid collector ephemeral garbage collector combination ideas smalltalk generation symbolics ephemeral garbage collector sobalvarro 
appearance collectors effect increasing legitimacy stock hardware lisp companies higher level lisp machine companies 
lisp machine companies encouraged belief stock hardware lisps performance particularly garbage collection special lisps 
proven wrong lisp machine companies suffered 
report included specification hygienic macros partially standardized macro facility scheme 
progressed power general purpose workstations increased largely due development fast risc processors stock hardware lisp companies dominated forcing lisp machine companies business leadership position 
deterioration lisp market general decline economy combined enable smaller software lisp companies survive customers willing buy expensive dedicated computers spend money maintaining 
april delivered sparc authorizing body relation microprocessor architecture name draft common lisp 
time iso wg produced draft kernel lisp 
ansi draft common lisp immensely large pages 
told official sparc seeing bigger cobol 
bigger 
funny shows process increasing desire expressiveness attention getting details right details matter need individuals mark seemingly deliberate blind eye commercial realities lead unintended result large unwieldy language completely understand 
evolution specific language features section discuss evolution language features unique lisp uniquely handled lisp 
constraints space addressed topics figured prominently technical development lisp addressed unusual ways context lisp language continuations structure editors reification reflection pretty printing garbage collection program tracing debugging stack management closures lexical dynamic record structures nonlocal exits unwind protect packages modules parallel processing hash tables vs property lists object oriented programming steele gabriel evolution lisp topics story spans decades interacts development language theory programming languages 
content topics representative concerns lisp community 
treatment nil lisp symbol nil distinguished object indicates list empty list object serves false value returned predicates 
mccarthy commented decisions proved unfortunate 
furthermore earliest implementations established tradition zero address representation nil mccarthy commented encouraging pornographic programming giving special interpretation address caused difficulties subsequent implementations mccarthy 
advantage address representation nil machines jump zero instruction equivalent allowing quick compact test list 
example implementation difficulties consider pdp architecture registers accumulators addressable memory locations 
memory location register 
address nil standard representation symbols dictated right half register contain property list symbol nil left half contained address information character string name nil 
implementation tradition resulted tying register architecture registers scarce resource 
maclisp adopted interlisp convention car nil cdr nil nil register reserved halves contained value car cdr operations need special case nil 
operations symbols special case nil longer representation symbols 
led difficulties steele find place assembly language kernel maclisp mattered 
nowadays common lisp implementations complex system offset data representations avoid special cases symbols symbol represented way data symbol memory word addressed symbol pointer words word addressed 
cons cell consists addressed word cdr word car 
way pointer serves nil symbol empty list pseudo cons car cdr nil 
danger quick test list list turn improper object empty list cons cell 
interlisp split difference giving programmer choice speed safety teitelman lists terminate nil occasional list ends atom worse number string cause bizarre effects 
accordingly implementation decision functions iterate list member length mapc terminate check conventional null check safety precaution encountering data types cause infinite cdr loops italics users application requiring extreme efficiency footnote nil check executed instruction interlisp requires generate word code 
provided fast versions memb nth assoc length compile open terminate nil checks fischer black commented early difference nil matter programming style black 
quite bit discussion years steele gabriel evolution lisp tease apart roles empty list false value uninteresting symbol name nil discussion particularly intense scheme community constituents interested elegance clarity 
regard construction car car bad pun preferring explicit null car car revised revised report scheme clinger defined distinct quantities nil just symbol empty list false boolean false value true boolean true value 
interesting compromise places language tested true false values regarded false false objects true 
report comments empty list counts false historical reasons programs rely versions scheme probably away nonsense 
programmers accustomed dialects lisp beware scheme done away nonsense identifies empty list symbol nil 
revised report algorithmic language scheme rees shortened false true similar refined senses empty list counts false compatibility existing programs implementations assume case 
programmers accustomed dialects lisp beware scheme distinguishes false empty list symbol nil 
approved ieee standard scheme specifies standard false true values values count true including empty list symbols numbers strings vectors procedures ieee 
scheme community overcome long tradition completely separated notions false value empty list symbol nil 
question continues debated 
question nil debated design common lisp directly contributing implementations nil decision empty list symbol nil 
running joke nil new implementation lisp nil role empty list free serve name language 
eventually desire compatible past raymond carried day 
worth noting lisp implementors tempted identify nil number opposed internal address notable exception lisp system pdp written richard stallman number symbol nil empty list false 
compare false true apl iverson false null pointer kernighan 
languages provoked kinds comments bad programming practice mccarthy lisp 
may reader great deal discussion expend small point language design 
space taken reflects accurately proportion time energy debate expended point lisp community years 
debate expressiveness versus different notions clarity 
lisp enforce strong typing programmers prefer maintain type discipline code writing null car car 
contend excess clutter detracts clarity improving 
steele gabriel evolution lisp iteration lisp traditionally conditionals recursively defined functions principal means expressing control structure fact repeated continuing attempts introduce various syntactic devices iteration convenient 
cases driven desire emulate styles programming algol languages fact compilers optimize tail recursive calls programmer rely era scheme common lisp compilers performance issue 
simplest special iteration construct exemplified loop introduced maclisp march var init step test body means var init block test return progn body setq var step fortran loop gt 
sum sum continue expressed 
setq total total aref course lisp arrays usually origin origin setq total total aref idiomatic rendering 
old style maclisp loop means earliest iteration syntax introduced lisp mention simplest 
interlisp iterative statements earliest examples typical style reinvented sum returns sum value accumulating variable total side effect 
see section discussion algol style syntax 
macros code transformation facilities kind extension particularly easy 
effort interlisp centralized lisp dialects maclisp repeated instances local wizard fancy syntax iterative processes lisp 
usually characterized kind keywords algol languages version stanford relied steele gabriel evolution lisp extended ascii character set available home grown keyboards 
led proliferation closely related syntaxes typically led keyword loop attracted programmers turned features 
strong differing aesthetic reactions iteration syntax question include loop macro major political battle early design common lisp lisp machine crowd generally favor adoption scott fahlman opposing weakly steele 
result compromise 
definition common lisp included loop macro absolutely minimal functionality permitted special keywords expressing endless repetition sequence 
understood placeholder reserving name loop possible extension full blown iteration syntax 
ansi committee eventually agree adopt slightly cleaned version loop mit lisp machines different interlisp 
process considered approaches iteration cropped series put forward richard waters generators pavel curtis crispin waters waters waters 
example fortran loop shown rendered series collect sum choose lambda scan range start call scan range generates series integers inclusive exclusive 
notation means map function applied element series producing new series 
function choose filter collect sum returns sum elements series 
series functional style reminiscent apl definition series primitives permitted compositions cleverly constrained compiled efficient iterative code need unboundedly large intermediate data structures run time 
generators method encapsulating series cost run time state look input output streams respectively serve sources sinks successive values side effect 
generator scan range start produces object delivers successive integers repeatedly extraction function 
complete example rendered num generator scan range start gathering result collect sum loop num return result result reminds possibilities lists conniver mcdermott generators shaw know direct connection 
generators emphasize control structure functional relationships 
debate development series generators rejected standardization purposes preferring subject test time 
iteration construct deserves discussion maclisp new style loop introduced march steele gabriel evolution lisp var init step var init step 
varn test result body evaluates init forms binds corresponding variables var resulting values 
iterates sequence evaluating test form produces true value evaluate result forms return value execute body forms sequence repeat 
beauty construct allows initialization stepping multiple variables pseudo english keywords 
awful part uses multiple levels parentheses delimiters get right endure strange behavior love syntax 
arguments syntax aside said recognizing loop steps variable pretty useless programming language 
case variable generate successive values accumulate result 
loop syntax steps generating variable accumulating variable stepped manually assignment statements fortran example side effect 
multiple variable loop reflects essential symmetry generation accumulation allowing iteration expressed explicit side effects define factorial unusual loop form empty body performing real step forms 
pretty obvious translation construct terms prog setq perspicuous model free side effects labels loop lambda var var varn cond test result progn body loop step step loop init init equivalent definition adopted scheme ieee resolves outstanding ambiguity requiring variables updated binding side effect 
entire iteration process free side effects 
advent scheme compilers orbit kranz common lisp compilers compiling result side effect free translation produces exactly efficient machine language code expect prog setq model 
macros macros appear introduced lisp timothy hart short mit ai memo hart quote entirety permission steele gabriel evolution lisp lisp special forms logically separate purposes reach alist allow functions indefinite number arguments keep arguments evaluated 
new lisp interpreters easily satisfy need making alist special type type entity 
uses replaced incorporating macro instruction expander define 
am proposing expander 

property list macro definition indicator macro followed function argument form macro name value replace original form function definitions 

function macro define macros just define defines functions 

define modified macro expansions 
examples 
existing may replaced macro definition macro lambda form list quote cset list quote quote cadr form caddr form 
new macro generate form frequently prog cons form macro write form may defined macro lambda form list quote setq form list cons cadr form form 
new macros may defined terms old 
enter macro adding new entry table dotted pairs stored value program variable 
enter form macro list list cons cadr form caddr form form incidentally macros alleviate difficulty resulting lisp compiler knowing existence birth 
macro defining function macro easily defined macro macro new define little harder define expr atom eq car quote steele gabriel evolution lisp member car lambda label prog cons car cons cadr caddr get car macro get car macro maplist car 
macro select illustrates macros means allowing functions arbitrary number arguments select form macro list list lambda list cons cond maplist form null cdr list car list list eq cadr form gensym number points worth noting hart proposal 
allows macro expansion computed arbitrary user defined function relying substitution template macro processors day 
noted macros require special knowledge part compiler 
macros expanded function definition time fly function interpreted compiled 
note switching expression expression syntax 
macro equivalent push macro interlisp teitelman common lisp way lisp verb commonly 
minor bugs definition prog properly handled fails process statements prog form second cond handled specially lead mistakes variable name macro variable test part cond clause 
oversight occurred hart bad taste name different purposes 
example illustrates technique generating new name temporary binding avoid multiple evaluations argument form 
hart achieved amazing increase expressive power deceptively simple change language encouraging user exploit power lisp serve metalanguage 
hart macro language subsequently lisp system saunders 
inspection function compiler code saunders reveals error processing prog statements repaired caddr replaced 
fact may hart originally intended hart appears written hand correction letter 
typist typographical error subsequently wrong correction 
unfortunately problems variable value returned lambda expression tag head prog incorrectly recognized name macro treating body lambda prog form macro call 
nowadays try careful sort thing 
macros kind integral part design lisp 
macros accepted part lisp 
similar sort computed macro appeared mit pdp lisp macros calls expanded fly encountered compiler interpreter 
case interpreter explicitly named function function call form turned macro property property list function indicators expr subr function definition original macro call form argument expected return form evaluated place call 
example pdp lisp memo pdp lisp steele gabriel evolution lisp lambda cond null cadr list quote cons cadr cons car macro defined macro equivalent effect common lisp function list 
note define function quote single quote character omission universally customary second cond clause 
advantage scheme define functions macros define redefine macro macro call latest macro definition 
drawback interpreter constantly re expand macro call time repeated reducing speed execution 
device called displacing macros soon common maclisp users involved utility function displace defun displace old new old car new old cdr new old write lambda displace cond macro effect destructively alter original list structure macro call replace expansion 
clever trick drawbacks 
failed macro needed expand atom number variable macro writers learned produce progn foo foo 
second macro redefined call displaced subsequent executions call new definition 
third code modified code originally contained macro call display expansion original macro call 
drawback tolerable maclisp environment firmly file displacing macros modified core copy program affect master definition considered text file 
displacing macros kind intolerable interlisp 
lisp machine lisp introduced improvement displacement technique defun displace old new new list cons car old cdr old new old si displaced new defmacro si displaced old new new steele gabriel evolution lisp idea macro call displaced list si displaced macro call expansion 
macro si displaced transparently returns second argument form behaves expansion replaced macro call 
expanding call si displaced free presumably cheaper continually re expanding original macro call macro writer shouldn displace 
lisp machine pretty printer recognizes calls si displace prints original macro call 
bbn lisp teitelman kinds macro open computed substitution described 
macro definition stored property list name macro property form property value determined types macro 
originally types effective compiled code 
eventually bbn lisp interlisp teitelman hack called added types macro effective interpreted code 
interpreting function call resulted undefined function error system step 
gain control expand macro evaluate resulting expansion 
interlisp manual notes interpreted macros enabled 
contrast mit approach building macros directly interpreter compiler primitive language feature 
bbn lisp open macro simply caused macro name replaced lambda expression causing function compiled open line 
open macro definition abs lambda cond minus course exactly form function definition 
bbn lisp computed macro similar kind mit pdp lisp expander function received cdr macro call entire macro call 
computed macro list list quote cons car cdr cons quote list cdr leading name variable bound cdr macro call form 
note closing definition see section 
bbn lisp substitution macro consisted simple pattern parameter list substitution template macro call substituted occurrences template corresponding parameter names 
substitution macro abs look cond minus call abs foo expanded cond foo foo minus foo leading multiple evaluations foo unfortunate foo expensive computation side effects 
way contrast open macro call abs foo expanded lambda cond minus foo steele gabriel evolution lisp evaluate foo exactly 
despite care required avoid multiple evaluation pattern template methodology defining macros convenient visually appealing 
pattern matching template methodologies pervasive topic development languages artificial intelligence see section 
return topic macros 
muddle galley surprisingly macro facility pdp lisp slight difference 
macro expansion function called macro form argument applied cdr form 
allowed muddle complex argument list keywords come play allowing certain simple kinds pattern matching interlisp substitution macros defmac atm optional form set atm form form lval atm 

necessary laboriously construct result computed macro 
result expanding 
set 
note muddle merely abbreviation lval local value 
maclisp grew pdp lisp maclisp community diversified producing variety methodologies defining macros 
simple macros conceptually straightforward write bit cumbersome certainly clumsy muddle interlisp defun macro list setq cadr list plus cadr cond caddr note lack automatic decomposition destructuring argument forms leads uses car cdr cond code constructs result 
separate destructuring construction defun macro var cadr cond caddr list setq var list plus var macro invented reinvented locally site late comer maclisp world lisp archive retroactively absorbed pdp maclisp lisp machine lisp time defmacro complex lisp machine defun argument syntax 
best lambda expression defun macro lambda var list setq var list plus var cadr cond caddr programmers attractive 
result writing complex macros fairly difficult art wizards developed separate styles macro definition 
see easily get hand consider macro simple loop 
typical steele gabriel evolution lisp print print expand 
print print trivial syntactic transformation simple convenient defining fortran loop syntax terms slightly general old style maclisp loop see section 
maclisp early define follows defun macro cons cons cadr cons caddr cons list cadr cons list 
cadr lot write simple transformation 
eventually various maclisp sites developed dozens similar quite compatible macro defining macros 
unusual packages site sect wizard developed 
packages usually included tools destructuring argument forms constructing result forms 
tools constructing result forms fell major categories substitution pseudo quoting 
substitution techniques required separate mention certain symbols template replaced specified values 
pseudo quoting allowed code compute replacement value occur template called pseudo quoting template surrounded call operator just quote specially marked places template 
macros took major step forward lisp machine lisp consolidated various macro defining techniques standardized features adopted maclisp community eventually common lisp 
macro defining operator defmacro provided list structure destructuring arbitrary depth backquote feature provided convenient concise pseudo quoting facility 
definition macro defmacro defmacro var lower upper body cons cons var cons lower cons list var cons list 
var upper body notice name parts original form 
backquote pseudo quoting syntax copy template filling place marked comma value expression get concise easy read definition steele gabriel evolution lisp defmacro var lower upper body var lower var 
var upper body note indicate splicing 
backquote syntax particularly powerful nested 
occurred primarily macro defining macros coded primarily wizards ability write interpret nested backquote expressions soon surrounded certain 
alan bawden mit acquired particular reputation backquote early days lisp machine 
backquote defmacro big difference 
leap expressive power available standard form began new surge language extension easier define new language constructs standard portable way experimental dialects shared 
including david moon success lisp language designer kit largely due ability user define macros lisp processing language list structure program representation making easy extend language syntax semantics 
kent pitman wrote summary advantages macros defining new language syntax pitman 
macro easy express new format 
consider macro discussed 
november lisp machine defmacro destructuring quite rich handle optional argument forms defun macro var rest setq var var rest car rest optional part handled explicitly programmed conditional expressed introduced lisp machine lisp probably influence scheme macro expanded equivalent cond form 
deficiency soon noticed quickly remedied allowing defmacro accept complex lambda list syntax defun defun macro var optional setq var var occurred january lisp archive time maclisp absorbed defmacro defun keywords lisp machine lisp 
additional problem repetitive syntax kind expressed extended bnf kleene star captured framework programmed explicitly 
contemplate simple definition defmacro bindings body lambda mapcar car bindings body mapcar cadr bindings note mapcar iterative processing bindings 
difficulty tackled lisp machine lisp common lisp community defmacro keywords state art today 
common lisp generalize defmacro allow recursive nesting lambda lists 
development theory practice lisp macros carried forward primarily scheme community interested scoping issues 
macros fraught kinds scoping problems accidental name capture accompanied special variables 
problem lisp macros time hart mid macro call expands expression composed symbols attached semantics 
substituted back program macro expansion conceivably take quite surprising steele gabriel evolution lisp meaning depending local environment 
macros languages preprocessor kernighan harbison example problem operate straight substitution text tokens 
practical way avoid problems macro writer try choose names user stumble picking strange names foo surprising great minds think alike gensym hart select example shown multiple packages avoid name clashes 
techniques provides iron glad guarantee 
steele pointed careful thunks provably eliminate problem situations steele 
proponents scheme regarded arrangements flawed clumsy official adoption scheme 
result scheme diversified 
nearly implementation kind macro facility alike 
nearly agreed macro facilities invaluable principle practice looked particular instance sort family secret 
right thing 
question pressing possibility developing scheme standard 
mid new sorts proposals put forward hygienic macros syntactic closures 
approaches involve special syntactic environments ensure properly matched definitions 
related line allows programmer control expansion process explicitly passing manipulating expander functions dybvig 
intended macro facilities scheme previous methods regarded deeply flawed adoption elegant language 
hygienic macros developed eugene kohlbecker assistance daniel friedman matthias felleisen bruce duba kohlbecker 
idea label occurrences variables tag indicating appeared original source code introduced result macro expansion multiple macro expansions occur tag indicate expansion step involved 
technique renames variables variable refer binding introduced different step 
kohlbecker ph dissertation kohlbecker carried step proposing pattern matching template substitution language defining macros underlying mechanism automatically hygienic macro expansion avoid name clashes 
macro defining language rich express wide variety useful macros provided facility execution arbitrary user specified lisp code restriction thought necessary avoid subversion guarantee hygiene 
little language interesting right 
general separate matching substitution facilities defmacro backquote opportunity perform arbitrary computations allow optional repetitive forms bnf notation allows optional situations permitting multiple productions matches 
example defined extend syntax setq extend syntax var value 
body 
lambda var 
body 
value ellipsis serves kind kleene star 
note way variable value pairs implicitly rearranged separate lists expansion 
steele gabriel evolution lisp list extend syntax list keywords part macro syntax tagged possible variable 
second list mentions variables may introduced macro expansion intended interact argument forms 
example consider implementation scheme call current continuation primitive slight generalization loop attributed dahl knuth executes statements repeatedly clause fails exit 
extend syntax loop repeat exit loop repeat call cc lambda exit label foo lambda 
foo loop repeat call cc lambda exit label foo lambda 
exit 
foo example loop repeat keywords confused possible variable exit bound macro intended argument forms macro call 
name foo intended hygienic macro expander rename necessary avoid name clashes 
note try hard name available default play safe extend syntax easier safer novice macro writers 
note idiom require form clause 
syntactic closures proposed alan bawden jonathan rees bawden 
idea bears strong resemblance expansion passing technique dybvig friedman haynes dybvig general 
syntactic contexts represented automatically managed tags hygienic macro expansion environment objects may close piece code respect syntactic environment giving macro writer explicit control correspondence occurrence symbol 
syntactic closures provide great power flexibility put burden programmer properly 
william clinger indiana university joined forces rees propose grand synthesis combines benefits hygienic macros syntactic closures added advantage running linear quadratic time 
technique called appropriately macros clinger 
key insight may explained analogy reduction lambda calculus church 
rule ff conversion applied rename variables lambda calculus expression subsequent fi reduction produce name clash 
renaming necessary renaming fi reductions fi reduction copies lambda expression bind name bring binding conflict 
true macros necessary renaming macro expansion 
contribution clinger rees clarify problem provide fast complete solution 
scheme standard ieee adopted macro facility confusion officially point 
macros remain active research topic 
steele gabriel evolution lisp macros important lisp programmers 
merely syntactic convenience provide programs manipulate programs central theme lisp community 
fortran language pushes numbers language pushes characters pointers lisp language pushes programs 
data structures useful representing manipulating program text 
macro immediate example program written metalanguage 
lisp metalanguage power entire programming language brought bear task transforming program text 
comparison preprocessor completely macro language consists entirely substitution token concatenation 
conditionals may conditionally define macro macro may expand conditional 
recursion say macro invoke define macro 
lisp users find 
concerned programming process object discourse object computation insist having best possible means expression purpose 
settle full programming language 
say illustrate character lisp illustrate character 
lisp community motivated part attitude superiority competition programming language dialect lisp 
numerical facilities lisp pdp lisp lisp systems offered single word integers single word floating point numbers 
pdp lisp deutsch apparently true lisp hart 
lisp floating point mccarthy lisp saunders pdp lisp pdp lisp 
little uncertain origin data type uses variable amount storage represent arbitrarily large integer values subject total size heap stored 
appeared maclisp stanford lisp roughly time standard lisp 
needed symbolic algebra programs reduce hearn macsyma group 
nowadays handling distinguishing feature lisp absolute requirement 
scheme standard ieee common lisp require 
usually algorithms detailed knuth volume knuth knuth 
jon white wrote set primitives allow code arithmetic efficiently lisp having code thing assembly language white 
literature arithmetic 
symbolic algebra systems group lisp dialects 
lisp platform kind research having gets way boehm vuillemin 
maclisp functions introduced support macsyma arithmetic common lisp functions integer length way lisp machine lisp ldb 
developers common lisp ieee floating point standard ieee 
notable writing high level programming languages seriously ieee floating point standard 
ansi fortran rejected explicit request 
lisp usually thought numerical programming language steele gabriel evolution lisp strong influences direction macsyma project gerald sussman 
numerical lisp compiler developed macsyma group golden steele steele important users numerical code fast compact 
result lisp compiler competitive dec pdp fortran compiler fateman 
initially intended fast signal processor 
envisioned applications detection require mix numerical signal processing artificial intelligence techniques 
project received advice kahan design floating point arithmetic ended quite similar eventual ieee standard 
appropriate refine techniques maclisp compiler produce numerical code lisp brooks 
offered different floating point formats bits 
influenced lisp common lisp provides expanded system floating point data types accommodate architectural variation 
inclusion complex numbers common lisp inheritance 
sticking point scott fahlman 
running joke acceptance test nascent common lisp implementations developed steele 
parts 
type responds passes part 
second define factorial function calculate factorial factorial responds passes part 
third try 
returns complex number passes extra credit returns correct complex number 
long time common lisp implementation passed third part 
steele broke implementation trade show floor part test 
gerald sussman students including gerald matthew interested numerical applications lisp generate transform numerical programs sussman 
sussman spent fair amount time mit teaching lisp undergraduates 
sussman thought absolutely crazy tell students quotient quotient 
course nearly programming languages problem pascal jensen derivatives notable exceptions excuse lisp better things centuries mathematical precedent outweigh decades temporary aberration field computers 
sussman function defined return rationals necessary common lisp produces 
considered radical change language 
rational numbers symbolic algebra systems 
developers common lisp simply integrating language functionality frequently required clients anyway 
provoked debate maclisp descendants slash backslash remainder operator 
committee eventually decided swap roles slash backslash slash alphabetic backslash character allowing division operation written allowing rational numbers written conventional notation 
solved problems caused little known little loved lisp community operating system called unix backslash character slash file names 
major incompatible change maclisp left common lisp open quite criticism 
course left common lisp truncating integer division operation occasionally useful 
inspired rounding modes influenced turn kahan steele added versions integer division operation common lisp truncate round ceiling floor accepts steele gabriel evolution lisp arguments returns quotient remainder pascal 
common lisp provides richer set numerical primitives pays closer attention details branch cuts complex trigonometric functions fortran 
notable failures despite lisp tendency absorb new features time programming languages experiments lisp community ideas tried repeatedly various forms reason simply don catch lisp community 
notable ideas algol style syntax generalized multiple values logic programming unification variables 
algol style syntax steve russell hand coded implementation eval expressions standard notation writing programs 
lisp system years write function union computes union sets represented lists elements roughly form defun union cond null member car union cdr cons car union cdr original intention design lisp programs written expressions expression syntax intended representation data 
union function expression notation looks union null member car union cdr cons car union cdr mccarthy noted mccarthy unexpected appearance interpreter tended freeze form language project defining expressions precisely finalized completely abandoned 
just indefinite new generation programmers appeared preferred internal notation expressions fortran algol notation devised 
story 
time efforts provide lisp algol syntax 
time lisp user implementor felt lack language provided solution infrequently attracted substantial group users long run achieved acceptance 
earliest example expressions course appears language 
gives definition union steele gabriel evolution lisp define union union empty member union rest connect union rest number definition precedence union operator note parenthetical delimiters necessary connect operator means cons higher precedence 
find curious went trouble pretty printing expressions expressions examples language sort run block paragraph style seen expressions 
nowadays format program manner clarity define union union empty member union rest connect union rest formatting algol programmers day similar indentation conventions published programs 
arpa supported lisp project aimed providing lisp syntax resembling algol citing advantage algol algorithms utilized little change 
lisp code union style running example look symbol function union symbol null member car union cdr car union cdr contemporary examples lisp code emphasize loops recursion version typical intended style symbol function union symbol symbol member return course version produces result different regarded list regarded set 
steele gabriel evolution lisp el language designed ben wegbreit part ph research wegbreit 
may loosely characterized lisp algol surface syntax strong data typing 
complete programming system called ecl built el harvard early wegbreit wegbreit wegbreit 
union function el looks union expr form form form nil 
member car 
union cdr cons car union cdr note type declarations result type form pointer dotted pair 
digraphs equivalent looked better model 
block arrow 
indicates conditional return value block resulting notation reminiscent mccarthy conditional notation expressions 
lisp widely harvard center research computing technology time el ppl polymorphic programming language somewhat interactive system may harvard answer lisp time 
ecl survived longer wegbreit left harvard xerox middle project 
ecl research course harvard 
discussed teitelman conversational lisp part interlisp teitelman 
function union built interlisp defined manner union lambda elseif member union union 
unary operator meaning null 
element list means car similarly means cdr 
function member predefined infix operator union user may define desired 
angle brackets indicate construction list list indicates splicing means cons 
final indicate necessary number closing parentheses case feature proper consistent interlisp style 
algol syntax lisp implemented ibm re implemented pdp stanford lisp smith 
provided infix operators complex construct iteration various subscripting notations element dimensional array equivalent cadr caddr car vector operations concise notation mapcar destructuring assignment 
expr union version union ffl union xfi cons union xfi vaughan pratt developed algol style notation lisp called pratt 
embedding algebraic syntax expressions employed separate full blown tokenizer parser 
implemented stanford lisp pratt stanford time exchange ideas project 
pratt went mit shortly implemented version maclisp pratt 
versions parser steele gabriel evolution lisp symbolic algebra systems scratchpad ibm yorktown macsyma mit project mac fred blair developed lisp reimplementation scratchpad michael genesereth macsyma 
version union function defines infix operator numbers left right binding powers parser define union member car cdr union car cdr union assumed version implemented mit stuck standard ascii character set definition stanford extended character set define ffx fix ffx fix represents cons examples delimiter ascii character nowadays called escape indicates top level expression 
unary lisp functions unary operators including car cdr 
definition relied fact unary operators high precedence cdr union means cdr union cdr union 
carefully chose binding powers union relative expression parsed car 
cdr union 
obvious best choice chose give cons form connect higher precedence union 
pratt remarked pratt want notation don want binding powers simply expression writing lisp 
omit parentheses go wrong 
compare great cause incorrect results obtained practice incorrect precedence assigned function 
number ai languages designed provide specific programming constructs thought helpful writing programs ai applications 
embedded lisp simply inherited lisp syntax cases influenced lisp syntax see section discussion 
embedded usually syntax related algol including features lisp symbolic data structures recursive functions 
pop burstall sail feldman pascal telos travis 
idea introducing algol syntax lisp keeps popping seldom failed create enormous controversy find universal expressions technical advantage don mind admitted relative expressions numerical expressions certain algebraic syntax concise convenient natural may mean considering notations artificial 
conjecture algol style syntax really caught lisp community reasons 
special symbols go 
domain discourse limited numbers characters operations interest difficult assign special character done 
lisp richer domain discourse lisp programmer approaches application steele gabriel evolution lisp exercise language design style typically involves designing new data structures new functions operate dozens hundreds hard invent distinct symbols apl community certainly tried 
ultimately fall back general function call notation just lisp programmers don wait fail 
second important algol style syntax programs look data structures represent 
culture ability manipulate representations programs central paradigm notation distances appearance program appearance representation data received principal objections inclusion loop common lisp 
hand precisely lisp easy play program representations easy novice experiment alternative notations 
expect generations lisp programmers continue reinvent algol style syntax lisp equally confident continue initial period reject 
process regarded passage lisp hackers 
generalized multiple values lisp independently gone path 
desirable return item function 
awkward return results global variables inefficient cons list results pushing system closer garbage collection know perfectly returned machine registers pushed machine control stack 
curiously prototypical example function ought return results symbolic numerical integer division conveniently return quotient remainder 
just convenient programmer separate functions know perfectly computation produces practically free efficiency issue 
suppose primitive means producing multiple values provided 
way introduce new functions special forms 
common lisp example lisp primitive function called values result values numbers 
special form multiple value bind foo body executes body variables locally bound values returned value form foo 
ad hoc inelegant 
multiple values emerge intrinsic structure language 
suppose example body lambda expression implicit values construct returning values implicit progn returning values 
takes care producing multiple values 
suppose function calls redefined values returned just value 
write lambda quo rem 
binding quo quotient rem remainder 
takes care consuming multiple values 
simple tidy 
oops details take care 
returning lambda expressions see consistency need return values just value 
form steele gabriel evolution lisp lambda quo rem quo rem rem quo returns values 
second need sequencing forms side effects assignment 
simple solution forms setq print return zero values lambda quo rem print quo rem returns remainder printing quotient 
simple attractive stack implementation 
primitives simply push values stack 
start processing function call place marker stack processed simply search stack marker arguments function call sure remove cancel marker transferring control function 
neat tidy soon try find code harder understand maintainer compiler 
programmer discipline write cons setq returns setting compiler sure code processing 
absence fairly complete information values produced function including user defined functions compiler verify function call supply correct number arguments 
important practical check lisp programming errors impossible 
conditionals introduce problems 
shall interpretation foo bar foo returns values 
shall second value discarded treated value returned value true 
predicate required return exactly value 
remains fact return different numbers values foo return single value multiple values 
follows immediately compiler complete program deduce general values returned function call formally undecidable 
entirely spirit lisp weakly typed language types values returned functions may determinable run time cardinality 
declarations indicate number values efficiency important just type declarations assist lisp compilers 
matter fact nearly followed path point development way lies returned home fall 
independently followed line thought conversations quite people done 
published sources cite precisely eventually judged bad idea publishing 
say bad idea variation eliminate disadvantages wish merely emphasize similarity thinking independent researchers 
notable efforts produce actual implementations eventual abandonment seus pop burstall 
designers implementors seus richard weyhrauch carolyn talcott david posner ralph william scherlis len gabriel published results novel language design steele gabriel evolution lisp fast compiler microcode implementation complete programming environment 
pop regarded designers ai language produced late early variant lisp enjoyed quite popularity europe implement logic programming language mellish 
logic programming unification number attempts integrate advantages foremost ai programming language families lisp prolog single language 
efforts particularly feature software side japanese fifth generation project 
examples robinson robinson tao project takeuchi okuno 
related attempts integrate functional programming prolog 
contrasted lisp convenient language implementing prolog exemplified komorowski komorowski kahn carlsson kahn 
conjecture idea caught lisp community unification variable matching process prolog 
easily design language features lisp uses unification procedure calls 
problem unification sufficiently different nature lambda binding resulting language doesn really feel lisp 
average lisp programmer feels extension prolog extension lisp just mess fundamental procedure calls 
hand leave lisp procedure calls provide unification separate facility explicitly invoked 
just lisp library routine result doesn feel prolog 
lisp language laboratory interesting aspect lisp culture contrast surrounding programming languages toy dialects regarded fair amount respect 
lisp history language laboratory 
trivial add new functions lisp way look system provided facilities 
macros equivalent pretty easy add new control structures syntactic constructs 
fails half hour write lisp complete interpreter new dialect 
see amazing imagine starting working fortran pascal pl basic apl system write run program language access source code compiler interpreter tackling exercises 
add new arithmetic operator language similar pythagorean addition knuth language knuth computes language augmented way new operator syntactically similar language operators addition subtraction 
may apl customary awful 

add case statement language 
case statement add statement called switch just case statement language selected branch executed control falls succeeding branches special break statement dropping branch terminate execution switch statement 

add full lexically scoped functional closures language 
steele gabriel evolution lisp source code compiler interpreter projects require practically start scratch 
part point 
source code fortran compiler apl interpreter exercises difficult lisp 
lisp answer liner shown common lisp defun sqrt lisp reserve special syntax infix operators built operations user defined functions look just system defined functions caller 
second requires dozen lines code common lisp backquote syntax described discussion macros defmacro switch value rest body mapcar lambda clause gensym rest clause body switcher mapcar lambda clause clause go body block switch case value switcher break apply defmacro break return switch macros switch break cause statement switch princ break princ princ princ prints expand block switch case go go go go return switch princ return switch princ princ princ code produced compiler 
examples interpreters solve third problem lines code see steele steele 
steele gabriel evolution lisp rich tradition experimenting augmentations lisp ranging add just new feature inventing completely new languages lisp implementation language 
activity carried particularly intensively mit late institutions stanford university carnegie mellon university indiana university 
time customary set ideas programming style concrete putting forth new programming language exemplar 
true outside lisp community witness proliferation algol particularly pascal inspired languages time period 
lisp convenient try little ideas small amount overhead tackling grand requiring man months effort 
earliest lisp languages meteor bobrow version comit lisp syntax 
comit mit rle mit rle patternmatching language repeatedly matched set rules contents flat linear workspace symbolic tokens precursor snobol ancestor rule languages ops forgy 
meteor embedded mit lisp system ran ibm 
lisp code meteor little column cards whitespace 
contrast implementation comit interpreter occupied words memory assuming reflects lines assembly language code view early example effectiveness lisp high level language prototyping languages 
early pattern matching languages built lisp convert guzman 
meteor pretty straight implementation comit represented lisp data structures convert merged pattern matching features comit recursive data structures lisp allowing matching recursively defined patterns arbitrary lisp data structures 
carl hewitt designed extremely ambitious lisp language theorem proving called planner hewitt hewitt 
primary contributions consisted advances invocation automatic backtracking implementation mechanism goal directed search 
completely implemented originally envisioned spurred important developments history lisp micro planner muddle conniver 
gerald jay sussman drew mcdermott eugene charniak implemented subset planner called micro planner sussman embedded mit pdp lisp system eventually maclisp 
semantics language implemented completely formalized 
implementation techniques ad hoc correctly certain complicated cases matcher designed match patterns contain variables complete unification algorithm 
sussman learning prolog remarked steele prolog appeared correct implementation micro planner 
version planner implemented pop davies 
language muddle mdl extended version lisp ways competitor designed dynamic modeling group mit separate mit ai laboratory building technology square 
effort begun late gerald jay sussman carl hewitt chris reeve david joined bruce daniels greg pfister stu galley 
designed successor lisp candidate vehicle dynamic modeling system possible base implementation planner 
galley extent competition muddle lisp fact sussman foot camp resulted cross fertilization 
interrupt handling multiprogramming coroutining facilities muddle advanced steele gabriel evolution lisp maclisp time 
muddle complex garbage collector pdp maclisp larger library application subroutines especially graphics 
lisp time reply muddle entirely code libraries subroutines main programs 
fact substantial applications coded muddle 
muddle introduced lambda list syntax markers optional rest aux adopted conniver lisp machine lisp common lisp 
language conniver designed drew mcdermott gerald jay sussman reaction perceived limitations micro planner particular control structure 
classic better planning sussman sussman argued automatic nested backtracking merely overly complicated way express set forall loops perform exhaustive search contention backtrack control structure backbone planner hindrance solution problems help 
particular automatic backtracking encourages inefficient algorithms conceals happening user primitives having powerful names power superficial 
design conniver put flow control explicitly hands programmer 
model extreme generalization coroutines active locus control arbitrarily logical threads primitives explicitly transferring active locus 
design strongly influenced spaghetti stack model introduced daniel bobrow ben wegbreit bobrow implemented bbn lisp known interlisp 
spaghetti stacks conniver provided separate notions data environment control environment possibility creating closures 
scheme language brought point data environments control environments play symmetrical roles interpretation lisp languages steele 
conniver differed spaghetti stacks ways stemming primarily implementation considerations 
main point conniver generality ease implementation written lisp represented control data environments lisp list structures allowing lisp garbage collector handle reclamation abandoned environments 
implementation spaghetti stacks hand involved structural changes lisp system lowest level 
addressed efficiency issues allowing stack allocation deallocation behavior possible 
policy pay go don pay don programs create closures pay overhead heap management control data environments 
time carl hewitt students began develop actor model computation computational entity program data actor agent receive react messages 
table activity brought conniver explicit model message passing ran continuations 
hewitt student brian smith commented interaction number research groups time smith early planner done mit published ijcai hewitt 
group interested researchers including peter deutsch richard fikes carl hewitt jeff alan kay jim moore nils nilsson richard waldinger gathered compare notes concepts november alan kay gave seminar mit emphasized importance intentional definitions data structures passing messages done limited extent procedural data structures lambda calculus languages landin evans reynolds extensively steele gabriel evolution lisp simula 
argument data type really knows implement operation 
previously attention procedural data structures research misconception procedural data structures inefficient practical certain advantages 
kay lecture struck responsive note immediately saw idea extend principle procedural embedding knowledge data structures 
effect type data structure little plan kind request receives kay proposed language called smalltalk token stream oriented interpreter implement ideas time peter bishop carl hewitt working try obtain general solution control structure problems continued plague problem solving systems years 
sussman proposed solution oriented possibility lists felt serious weaknesses simply looking contents try cause unfortunate global side effects conniver programs hard debug understand 
token streams smalltalk side effect problem possibility lists conniver 
lecture hewitt pointed kay control structure problems involved scheme token stream oriented interpreter 
december succeeded generalizing message mechanism smalltalk simula port mechanism balzer mitchell previous call statement planner universal communication mechanism 
generalization solved control structure problems hewitt pointed kay design smalltalk 
developed actor transmission communication primitive part new language independent machine independent behavioral model computation 
development actor model computation ramifications principal original contribution area research main influences development actor model computation ffl suggestion alan kay procedural embedding extended cover data structures context previous attempts generalize church landin evans reynolds functional data structures ffl context previous attempts clean generalize coroutine control structures landin mitchell balzer reynolds sussman 
ffl influence seymour papert little man metaphor computation logo 
ffl limitations complexities capability protection schemes 
actor transmission effect inter domain call efficiently providing intrinsic protection actor machines 
ffl experience developing previous generations planner 
essentially planner language extensions implemented julian davies pop university edinburgh 
terms actor model computation control structure simply pattern passing messages actor control structure advantages conniver steele gabriel evolution lisp ffl serious problem conniver approach control structure programmer human machine think terms low level data structures activation records possibility links 
actor approach allows programmer think terms behavior objects naturally occur domain programmed ffl actor transmission entirely free side effects ffl control mechanisms conniver violate principles modularity dijkstra remarked goto associated badly structured programs 
concur judgement feel reason goto sufficiently powerful primitive 
problem goto message sent control target ffl primitive control structures conniver programs difficult write debug conniver programs prone going infinite loops reason apparent programmer 
conniver represents substantial advance micro planner increasing generality goal oriented computations easily performed 
increase generality comes price lowering level language problem solving 
forces users think low level implementation terms possibility lists links 
propose shift paradigm problem solving society individuals communicating passing messages 
quoted smith hewitt length reasons comparative analysis explicit passage illustrates connections different ideas floating ai lisp programming language communities particular point evolution ideas represented distillation soon fed back quickly evolution lisp 
perspective see hewitt 
hewitt students notably shrobe brian smith todd roger hale peter bishop marilyn russ atkinson mike ken kahn keith nishihara kathy van aki benjamin kuipers richard irene greif developed implemented maclisp new language concrete actor model computation 
language called planner name changed plasma planner system modeled actors smith hewitt 
syntax plasma lisp kinds parentheses brackets muddle special characters 
reasonable assume hewitt tempted possibilities newly available knight keyboard xerox graphics printer xgp printer 
keyboards designed tom knight mit ai lab mit equivalent extended ascii keyboards developed years earlier stanford ai laboratory 
stanford keyboards knight keyboards control meta keys soon pressed service development command set emacs text editor set graphics included exotic characters ff fi xgp dots inch possible printing exotic characters 
recursive factorial function looked plasma factorial cases 

factorial steele gabriel evolution lisp note infix arithmetic operators 
merely clever syntax clever semantics really meant message containing subtraction operator number sent number actor object named may argue lisp development mit took distinct paths 
path maclisp workhorse tool coded assembly language maximum efficiency compactness serving needs ai laboratory macsyma group 
second path consisted extended dialogue competition argument hewitt students sussman students sides drawing ideas rest world spinning 
second path characterized quest right thing new set ideas exemplified form new language usually implemented top lisp language maclisp muddle sake rapid prototyping experimentation 
round hewitt sussman dialogue course scheme discussed section hindsight observe development ended dialogue brought entire path exploration full circle 
starting lisp sought explicate issues search control structures models computation came back simply old lisp difference lexical scoping closures short needed lisp compatible lambda calculus merely syntax semantics connecting firmly various developments mathematical logic paving way lisp community interact developments functional programming 
hewitt noted actor model capture salient aspects lambda calculus scheme demonstrated lambda calculus captured nearly salient aspects excepting side effects synchronization actor model 
sussman steele began look fairly intensely semantics lisp languages new light 
scheme simpler lisp accepted overheads maintaining lexical environments closures write complete interpreter lisp single sheet line 
allowed extremely rapid experimentation language implementation ideas point sussman steele testing measuring new interpreters week 
results summarized art interpreter steele 
particular point interest comparison call name call value parameters influenced indiana university discussed cons evaluate arguments friedman 
susceptible rapid mutation scheme served implementation base rapid prototyping languages 
popular technique theoreticians formally describing meaning language give denotational semantics describes meaning construct terms parts relationships lambda calculus glue notation 
scheme showed properly designed lisp gave flexibility syntax needed managing control structure message passing solve goal development lisp ai languages automatic management goal directed search theorem proving 
scheme new lisp languages developed direction sussman students including constraint systems sussman stallman steele de kleer truth maintenance systems de kleer mcallester non monotonic logic 
technique dependency directed backtracking eliminated giant nest forall loops effect chronological backtracking 
time line research database design problem language design problem resulted feedback mainstream evolution lisp 
steele gabriel evolution lisp development languages artificial intelligence applications continued sites lisp remained vehicle choice implementing 
early alternative choice especially efficiency major concern 
improvements lisp implementation techniques particularly compilation garbage collection particular pendulum back bit 
ai boom early expert systems usually understood mean rule systems written languages superficially different meteor convert 
ops better known rule languages period xcon expert system configuring vax installations developed carnegie mellon university digital equipment premier application success story 
ops implemented lisp recoded efficiency bliss wulf cmu developed dec supported systems implementation language semantic level 
important category ai frame example knowledge representation language implemented interlisp 
line experimentation lisp area parallelism 
early developments included facilities interrupt handling multiprogramming true multiprocessing evolved availability appropriate hardware facilities cases built purpose 
lisp brooks designed multiple processors system features lisp part really worked 
important early real parallel lisp implementations multilisp butterfly psl 
multilisp halstead halstead bert halstead students mit 
scheme relied primarily notion sort laundry ticket promise deliver value computed 
multilisp provided pcall construct essentially function call evaluates arguments concurrently completely invoking function 
pcall provides certain structured discipline futures adequate purposes 
multilisp ran concert multiprocessor collection motorola processors 
descendant multilisp implemented bbn butterfly miller 
butterfly psl swanson implementation portable standard lisp griss bbn butterfly 
relied entirely futures spawning parallel processes 
gabriel goldman developed richard gabriel john mccarthy stanford 
extended common lisp number parallel control structures parallel pun intended existing common lisp control constructs notably 
computational model involved global queue processes means spawning processes controlling interaction resource consumption 
example produce kinds functions normal ones produced lambda eager ones spawn separate process created delayed ones spawn separate process invoked 
implemented alliant fx compiled parallel lisp implementation 
connection machine lisp steele dialect common lisp extended new data structure intended support fine grain data parallelism 
strange hybrid array hash table association list semantically set ordered index value pairs 
primitives language geared processing values concurrently matching values different associated indexes 
idea indexes labels virtual processors 
recapitulate lisp excellent laboratory language experimentation reasons 
choose small subset dozen primitives member class lisp languages 
easy bootstrap small language variations choice new platform 
looks promising flesh long laundry steele gabriel evolution lisp list amenities 
second particularly easy hour bootstrap new dialect existing lisp implementation 
host implementation differs fundamental ways new dialect provide primitive operations arithmetic programming language just plain convenient writing language interpreters 
live generic list structure oriented syntax field day reprogramming semantics 
get right time re engineer parser front 
lisp diverse history evolution lisp seen lisp elaborate complex history languages wider usage 
little research group version lisp appear lisps variations language concepts 
natural ask special different lisp explains 
basic reasons theoretical foundations expressiveness malleability interactive incremental nature operating system facilities people choose 
theoretical foundations 
lisp founded footing recursive function theory theory computability 
scheme aligned church lambda calculus denotational semantics 
purest form useful mathematical reasoning proof 
theoretically minded researchers adopted lisp lisp languages express ideas 
see lisp oriented papers new language constructs explained existing constructs explained properties programs proved proof techniques explored 
upshot lisp lisp languages forefront basic language research 
common practically minded theoretical researchers implement ideas lisp 
expressiveness 
lisp proved concerned expressiveness 
see observing person versed particular lisp implemented write efficient programs 
perfectly nice piece code defun matrix matrix dotimes matrix push list matrix defun add matrix length length matrix matrix dotimes matrix dotimes setf nth nth matrix nth nth nth nth expression read write cell matrix looks perfectly harmless fast 
slow nth takes time proportional value argument essentially list time called 
experienced lisp coder iterate cells list numeric indices arrays lists 
steele gabriel evolution lisp expressiveness gone 
people tend expect operations language cost small unit time complicated 
expectation false sufficiently expressive language 
primitives high level wiggle room underneath permit choice implementation strategies 
lisp implementors continue explore space strategies 
precisely lisp expressive hard write fast programs easy write pretty clear ones 
malleability 
easy lisp experiment new language features possible extend lisp way extensions indistinguishable users base language 
primarily accomplished macros part lisp hart 
lisp macros lisp computation engine compute expansions proved effective way extend language mechanisms languages 
macro extensions accepted lisp community way language communities 
furthermore lisp dialects provided mechanisms extend type system 
enables people experiment new data types 
course languages mechanism lisp data typing mechanism combines powerful macro facility functional nature language allow entirely new computing paradigms built lisp 
example seen data driven paradigms sussman possible worlds paradigms mcdermott object oriented paradigms moon bobrow implemented lisp way seams lisp new paradigms essentially invisible 
interactive incremental nature 
easy explore solutions programming problems lisp easy implement part solution test modify change design debug changes 
lengthy edit compile link cycle 
lisp useful rapid prototyping constructing large programs face incomplete possibly impossible complete plan attack 
lisp exploring territory imposing languages 
characteristic lisp attractive pioneering 
operating system facilities 
lisp implementations provide facilities reminiscent operating systems command processor automatic storage management facility file management display windows graphics mouse facilities multitasking compiler incremental re linker loader symbolic debugger performance monitoring multiprocessing 
possible operating system research lisp provide complete operating environment 
combined interactive incremental nature possible write sophisticated text editors supplant native operating system host computer 
lisp system provide operating environment provides strong portability wide variety incompatible platforms 
lisp attractive vehicle researchers lisp 
people 
course languages diversify people diversify languages 
preceding factors merely serve attract people lisp provide facilities experiment lisp 
people attracted lisp interested exploring new language alternatives lisp diversified lisp attracts people 
lisp language artificial intelligence things 
ai branch computer science directed exploring difficult exotic programming tasks mimicking understanding cognition intelligence 
recall symbolic computation field institutions originally considered branch ai 
people attracted ai generally creative bold language designers implementors follow mold ai researchers ai researchers 
steele gabriel evolution lisp lisp provides peculiar set characteristics features ones required early advances ai 
ai subject commercial concerns ai companies turn languages lisp 
attraction lisp language experts purposes means lisp language designed programmers code robust reliable software 
little compile time type checking module systems little safety discipline built language 
language languages hackers raymond 
put lisp unusual sense clearly deviates type programming language developed theoretical concepts implications lisp far transcend practical usage 
jean great advantage lisp languages ways forming compound expressions syntactic structure short time forget syntactic details language get real issues 
abelson sussman abelson xvii syntactic sugar causes cancer semicolon 
alan perlis lisp feel bits toes 
drew mcdermott mcdermott lisp simple syntax semantics parsing treated elementary task 
parsing technology plays role lisp programs construction language processors rarely impediment rate growth change large lisp systems 
alan perlis forward abelson apl beautiful diamond beautifully symmetrical 
add 
try glue diamond don get bigger diamond 
lisp ball mud 
add ball mud looks lisp 
joel moses moses 
pascal building pyramids imposing static structures built pushing heavy blocks place 
lisp building organisms alan perlis forward abelson lisp medium choice people enjoy free style flexibility 
gerald jay sussman friedman ix hey quit hacking hack lisp 
rpg final edit gabriel steele gabriel evolution lisp abelson abelson harold gerald jay sussman julie sussman 
structure interpretation computer programs 
mit press cambridge massachusetts 
isbn 
paul jeffrey barnett erwin book donna firth stanley kemeny clark weissman lowell michael levin robert saunders 
lisp programming language system 
proceedings afips fall joint computer conference volume pp 
san francisco california november 
american federation information processing societies 
spartan books washington 
acm association computing machinery 
proceedings artificial intelligence programming languages conference rochester new york august 
acm sigplan notices august 
acm sigart newsletter august 
acm lfp association computing machinery 
proceedings acm symposium lisp functional programming pittsburgh pennsylvania august 
isbn 
acm lfp association computing machinery 
proceedings acm symposium lisp functional programming austin texas august 
isbn 
acm lfp association computing machinery 
proceedings acm conference lisp functional programming cambridge massachusetts august 
isbn 
acm lfp association computing machinery 
proceedings acm conference lisp functional programming snowbird utah july 
isbn 
acm oopsla association computing machinery 
proceedings acm conference objected oriented programming systems languages applications oopsla portland oregon october 
acm sigplan notices november 
isbn 
acm pldi association computing machinery 
proceedings acm sigplan conference programming language design implementation white plains new york june 
acm sigplan notices june 
isbn 
acm association computing machinery 
proceedings acm sigsoft sigplan symposium practical software development environments pittsburgh pennsylvania april 
acm sigplan notices may acm software engineering notes may 
isbn 
backus backus john 
programming liberated von neumann style 
functional style algebra programs 
communications acm pp 
august 
acm turing award lecture 
baker baker henry jr list processing real time serial computer 
communications acm pp 
april 
david john jensen 
implementation pc scheme 
acm lfp pp 

bawden bawden alan jonathan rees 
syntactic closures 
acm lfp pp 

berkeley berkeley edmund daniel bobrow eds 
programming language lisp operation applications 
information international mit press cambridge massachusetts 
black black fischer 
styles programming lisp 
berkeley pp 

bobrow bobrow daniel meteor lisp interpreter string transformations 
berkeley pp 

bobrow bobrow robert richard burton lewis 
uci lisp manual extended stanford lisp system 
information computer science technical report university california irvine irvine california october 
steele gabriel evolution lisp bobrow bobrow daniel ben wegbreit 
model stack implementation multiple environments 
communications acm pp 
october 
bobrow bobrow daniel kenneth kahn gregor kiczales larry masinter mark stefik frank 
merging lisp object oriented programming 
acm oopsla pp 

boehm boehm hans robert cartwright mark michael donnell 
exact real arithmetic case study higher order programming 
acm lfp pp 

brooks brooks rodney richard gabriel guy steele jr common lisp implementation 
acm lfp pp 

brooks brooks rodney richard gabriel guy steele jr optimizing compiler lexically scoped lisp 
proceedings symposium compiler construction pp 
boston june 
association computing machinery 
acm sigplan notices june 
isbn 
brooks brooks rodney richard gabriel 
critique common lisp 
acm lfp pp 

burke burke eliot 
nil manual 
report mit lcs tr mit laboratory computer science cambridge massachusetts 
burstall burstall collins eds 
programming pop 
edinburgh university press 
campbell campbell ed 
implementations prolog 
ellis horwood limited chichester 
isbn 
published john wiley sons new york 
church church 
calculi lambda conversion 
annals mathematics studies 
princeton university press princeton new jersey 
reprinted klaus reprint new york 
clark clark eds 
logic programming 
academic press new york 
clinger clinger william 
scheme compiler exercise denotational semantics 
acm lfp pp 

clinger clinger william ed 
revised revised report scheme uncommon lisp 
ai memo mit artificial intelligence laboratory cambridge massachusetts august 
clinger clinger william ed 
revised revised report scheme uncommon lisp 
computer science department technical report indiana university bloomington june 
clinger clinger william anne eric ost 
implementation strategies continuations 
acm lfp pp 

clinger clinger william read floating point numbers accurately 
acm pldi pp 

clinger clinger william jonathan rees 
macros 
proceedings eighteenth annual acm symposium principles programming languages pp 
orlando florida january 
association computing machinery 
isbn 
common lisp language 
guy steele jr scott fahlman richard gabriel david moon daniel weinreb 
digital press burlington massachusetts 
isbn 
common lisp language second edition 
guy steele jr scott fahlman richard gabriel david moon daniel weinreb daniel bobrow linda demichiel keene gregor kiczales crispin kent pitman richard waters jon white 
digital press bedford massachusetts 
isbn 
steele gabriel evolution lisp cohen cohen jacques 
garbage collection linked data structures 
acm computing surveys pp 
september 
steven 
uniprocessor architecture sma 
project annual report volume chapter 
lawrence livermore laboratory livermore california 
davies davies implementation pop planner 
campbell pp 

dec digital equipment maynard massachusetts 
programmed data processor handbook 
dec digital equipment maynard massachusetts 
pdp handbook 
dec digital equipment maynard massachusetts 
vax architecture handbook 
de kleer de kleer johan jon doyle charles rich guy steele jr gerald jay sussman 
deductive procedure system 
ai memo mit artificial intelligence laboratory cambridge massachusetts january 
de kleer de kleer johan gerald jay sussman 
propagation constraints applied circuit synthesis 
ai memo mit artificial intelligence laboratory cambridge massachusetts september 
circuit theory applications pp 

deutsch deutsch peter edmund berkeley 
lisp implementation pdp computer 
berkeley pp 

deutsch deutsch peter 
lisp machine compact programs 
ijcai pp 

deutsch deutsch peter daniel bobrow 
efficient incremental automatic garbage collector 
communications acm pp 
september 
drescher drescher gary 
user manual 
lmi lisp machine cambridge massachusetts 
dybvig dybvig kent daniel friedman christopher haynes 
expansion passing style conventional macros 
acm lfp pp 

greenblatt holloway knight nelson 
manual 
ai memo mit artificial intelligence laboratory cambridge massachusetts june 
revised ai memo july 
donald status report 
ai memo mit artificial intelligence laboratory cambridge massachusetts april 
fateman fateman richard reply editorial 
acm bulletin pp 
march 
reports results test compiled maclisp floating point program faster equivalent fortran code 
numerical portion code identical maclisp faster subroutine call protocol 
feldman feldman low swinehart taylor 
developments sail 
proceedings afips fall joint computer conference volume pp 
stanford california november 
american federation information processing societies 
carol william clinger daniel friedman christopher haynes 
scheme version manual 
technical report indiana university february 

franz lisp manual 
university california berkeley california april 
forgy forgy mcdermott 
ops domain independent production system language 
proceedings fifth international joint conference artificial intelligence ijcai pp 
cambridge massachusetts august 
international joint council artificial intelligence 
steele gabriel evolution lisp friedman friedman daniel david wise 
cons evaluate arguments 
technical report indiana university november 
friedman friedman daniel matthias felleisen 
little 
trade edition 
mit press cambridge massachusetts 
isbn 
published science research associates chicago third edition 
isbn 
gabriel gabriel richard larry masinter 
performance lisp systems 
acm lfp pp 

gabriel gabriel richard martin frost 
programming environment system 
acm pp 

gabriel gabriel richard john mccarthy 
queue multiprocessing lisp 
acm lfp pp 

gabriel gabriel richard performance evaluation lisp systems 
mit press cambridge massachusetts 
isbn 
gabriel gabriel richard kent pitman 
technical issues separation function cells value cells 
lisp symbolic computation pp 
june 
issn 
gabriel gabriel richard personal communication guy steele jr november hours handing manuscript federal express 
galley galley greg pfister 
mdl language 
programming technology division document sys mit project mac cambridge massachusetts november 
charles james morris jr edwin satterthwaite 
early experience mesa 
communications acm pp 
august 
golden golden jeffrey user guide group lisp compiler interim report 
ai memo mit project mac cambridge massachusetts december 
goldman goldman ron richard gabriel 
preliminary results initial implementation 
acm lfp pp 

greenblatt greenblatt richard 
lisp machine 
working mit artificial intelligence laboratory cambridge massachusetts november 
contribution la interpr impl des 
th ese etat universit de paris vi november 
gries gries david 
exercise proving parallel programs correct 
communications acm pp 
december 
griss griss martin anthony hearn 
portable lisp compiler 
software practice experience pp 

griss griss martin eric benson gerald maguire jr psl portable lisp system 
acm lfp pp 

guzman guzman harold mcintosh 
convert 
ai memo mit project mac cambridge massachusetts june 
brent bruce 
architecture manual 
technical report stan cs department electrical engineering stanford university stanford california january 
halstead halstead robert jr implementation multilisp lisp multiprocessor 
acm lfp pp 

halstead halstead robert jr multilisp language concurrent symbolic computation 
acm transactions programming languages systems pp 
october 
steele gabriel evolution lisp harbison harbison samuel guy steele jr manual 
prentice hall englewood cliffs new jersey third edition 
isbn 
hart hart timothy macro definitions lisp 
ai memo mit artificial intelligence project rle mit computation center cambridge massachusetts october 
hart hart timothy thomas evans 
notes implementing lisp computer 
berkeley pp 

hearn hearn reduce system language algebraic manipulation 
proceedings second symposium symbolic algebraic manipulation pp 
los angeles march 
william 
auxiliary language natural expression 
berkeley pp 

hewitt hewitt carl 
planner language proving theorems robots 
proceedings international joint conference artificial intelligence ijcai pp 
washington may 
international joint council artificial intelligence 
hewitt hewitt carl 
description theoretical analysis schemata planner language proving theorems manipulating models robot 
phd thesis massachusetts institute technology cambridge massachusetts april 
mit artificial intelligence laboratory tr 
hewitt hewitt carl 
know 
proceedings fourth international joint conference artificial intelligence volume pp 
georgia ussr september 
international joint council artificial intelligence 
originally circulated working mit artificial intelligence laboratory cambridge massachusetts may 
hewitt hewitt carl jeff inman 
dai intelligent agents open systems science 
ieee transactions systems man cybernetics pp 
november december 
hieb hieb robert kent dybvig carl bruggeman 
representing control presence class continuations 
acm pldi pp 

ieee ieee new york 
ieee standard binary floating point arithmetic ansi ieee std 
american national standard 
ieee ieee computer society new york 
ieee standard scheme programming language ieee std 
ijcai international joint council artificial intelligence 
proceedings third international joint conference artificial intelligence ijcai stanford california august 
iverson iverson kenneth programming language 
wiley new york 
jensen jensen kathleen niklaus wirth 
pascal user manual report 
springer verlag new york 
kahn kahn carlsson 
implement prolog lisp machine 
campbell pp 

james warren harris roy souza alan snyder 
experience 
proceedings acm conference objected oriented programming systems languages applications oopsla pp 
orlando florida october 
association computing machinery 
acm sigplan notices december 
isbn 
kernighan kernighan brian dennis ritchie 
programming language 
prentice hall englewood cliffs new jersey 
knuth knuth donald algorithms volume art computer programming 
addison wesley reading massachusetts 
steele gabriel evolution lisp knuth knuth donald structured programming go statements 
computing surveys pp 
december 
knuth knuth donald algorithms second edition volume art computer programming 
addison wesley reading massachusetts 
isbn 
knuth knuth donald book volume computers typesetting 
addisonwesley reading massachusetts 
isbn 
kohlbecker kohlbecker eugene daniel friedman matthias felleisen bruce duba 
hygienic macro expansion 
acm lfp pp 

kohlbecker kohlbecker jr eugene syntactic extensions programming language lisp 
technical report indiana university august 
ph thesis 
komorowski komorowski programming environment prolog lisp 
clark pp 

kranz kranz david richard kelsey jonathan rees paul hudak james philbin norman adams 
orbit optimizing compiler scheme 
proceedings acm sigplan symposium compiler construction pp 
palo alto california june 
association computing machinery 
acm sigplan notices july 
isbn 
landin landin peter mechanical evaluation expressions 
computer journal 
landin landin peter correspondence algol church lambda notation 
communications acm february march 
lisp archive lisp archiv 
line archive maclisp release notes entries jon white guy steele jr howard cannon richard gabriel richard stallman eric rosen richard greenblatt robert 
lisp conference conference record lisp conference stanford california august 
republished association computing machinery 
zohar manna richard waldinger 
programming language 
acm lfp pp 

marti marti hearn griss griss 
standard lisp report 
acm sigplan notices pp 
october 
group group 
macsyma manual version 
mit laboratory computer science cambridge massachusetts 
mcallester mcallester david valued truth maintenance system 
ai memo mit artificial intelligence laboratory cambridge massachusetts may 
mccarthy mccarthy john paul daniel edwards timothy hart michael levin 
lisp programmer manual 
mit press cambridge massachusetts 
mccarthy mccarthy john 
lisp notes past 
lisp conference pp 
viii 
mccarthy mccarthy john 
history lisp 
wexelblat richard ed history programming languages acm monograph series chapter iv pp 

academic press new york 
final published version proceedings acm sigplan history programming languages conference los angeles california june 
isbn 
mcdermott mcdermott drew gerald jay sussman 
conniver manual 
ai memo mit artificial intelligence laboratory cambridge massachusetts january 
mcdermott mcdermott drew oral acm symposium artificial intelligence programming languages rochester new york august guy steele jr mcdermott mcdermott drew 
efficient environment allocation scheme interpreter lexically scoped lisp 
lisp conference pp 

steele gabriel evolution lisp mellish mellish hardy 
integrating prolog environment 
campbell pp 

miller miller james 
parallel processing system mit scheme 
phd thesis massachusetts institute technology cambridge massachusetts august 
mit rle mit research laboratory electronics 
mit press cambridge massachusetts 
comit programmers manual june 
mit rle mit research laboratory electronics 
mit press cambridge massachusetts 
comit programming june 
moon moon david maclisp manual 
mit project mac cambridge massachusetts april 
moon moon david garbage collection large lisp system 
acm lfp pp 

moon moon david object oriented programming flavors 
acm oopsla pp 

moore moore strother ii 
interlisp virtual machine specification 
technical report csl xerox palo alto research center palo alto california september 
moses moses joel 
function function lisp 
ai memo mit artificial intelligence laboratory cambridge massachusetts june 
moses 
moses joel recalled probably paraphrased guy steele jr persistent confusion literature 
reported moses said panel acm apl conference 
moses denies having particular steele heard deny 
steele equally certain moses apl conference standing doorway steele white office mit room number ne circa 
jon white personal communication steele november independently recalls having heard moses comparing apl diamond lisp ball mud separate occasions office building ne 
confusion undoubtedly persist 
naur naur peter ed revised report algorithmic language algol 
communications acm pp 
january 
okuno okuno hiroshi takeuchi yasushi watanabe 
tao fast interpreter centered lisp system lisp machine 
acm lfp pp 

organick organick elliot multics system examination structure 
mit press cambridge massachusetts 
julian desiderata standardisation lisp 
acm lfp pp 

pdp lisp pdp lisp lisp 
ai memo mit project mac cambridge massachusetts january 
revised memo april 
report bear author name jeffrey golden golden attributes jon white 
pitman pitman kent special forms lisp 
lisp conference pp 

pitman pitman kent revised maclisp manual 
mit lcs tr mit laboratory computer science cambridge massachusetts may 
pratt pratt vaughan top operator precedence 
proceedings acm symposium principles programming languages pp 
boston october 
association computing machinery 
pratt pratt vaughan alternative external representation lisp users 
ai working mit artificial intelligence laboratory cambridge massachusetts march 
steele gabriel evolution lisp lynn diffie 
stanford lisp manual 
sail operating note stanford artificial intelligence laboratory stanford california 
raymond raymond eric ed 
new hacker dictionary 
mit press cambridge massachusetts 
isbn 
rees rees jonathan norman adams iv 
dialect lisp lambda ultimate software tool 
acm lfp pp 

rees rees jonathan william clinger revised report algorithmic language scheme 
acm sigplan notices pp 
december 
reynolds reynolds john definitional interpreters higher order programming languages 
proceedings acm national conference pp 
boston august 
association computing machinery 
robinson robinson sibert 
motivation design implementation 
clark pp 

gerald 
expressing mathematical subroutines constructively 
acm lfp pp 

tape editor 
program write bbn bolt beranek newman cambridge massachusetts january 
gary model architecture independent parallel programming 
mit press cambridge massachusetts 
isbn 
jean 
programming languages history fundamentals 
prentice hall englewood cliffs new jersey 
saunders saunders robert lisp listing compiler samples 
berkeley pp 

saunders saunders robert lisp system computer 
berkeley pp 

shaw shaw mary wm 
wulf ralph london 
abstraction verification iteration generators 
shaw mary ed form content chapter pp 

springer verlag new york 
isbn 
smith smith david 

technical report aim stanford artificial intelligence project october 
smith smith david 
backtracking efficient backtracking method lisp 
ijcai pp 

smith smith brian carl hewitt 
plasma primer 
working mit artificial intelligence laboratory cambridge massachusetts october 
sobalvarro sobalvarro patrick lifetime garbage collector lisp systems generalpurpose computers 
bachelor thesis massachusetts institute technology cambridge massachusetts september 
stallman stallman richard gerald jay sussman 
forward reasoning backtracking system computer aided circuit analysis 
ai memo mit artificial intelligence laboratory cambridge massachusetts september 
artificial intelligence pp 

steele steele guy lewis jr multiprocessing garbage collection 
communications acm pp 
september 
steele steele guy lewis jr gerald jay sussman 
lambda ultimate imperative 
ai memo mit artificial intelligence laboratory cambridge massachusetts march 
steele gabriel evolution lisp steele steele guy lewis jr lambda ultimate declarative 
ai memo mit artificial intelligence laboratory cambridge massachusetts november 
steele steele guy lewis jr compiler optimization viewing lambda rename plus goto 
master thesis massachusetts institute technology may 
published steele 
steele steele guy lewis jr data representations pdp maclisp 
proceedings macsyma users conference pp 
washington july 
nasa scientific technical information office 
published ai memo mit artificial intelligence laboratory cambridge massachusetts september 
steele steele guy lewis jr fast arithmetic maclisp 
proceedings macsyma users conference pp 
washington july 
nasa scientific technical information office 
published ai memo mit artificial intelligence laboratory cambridge massachusetts september 
steele steele guy jr better spaghetti 
acm pp 

steele steele guy lewis jr expensive procedure call myth procedure call implementations considered harmful lambda ultimate goto 
proceedings acm national conference pp 
seattle october 
association computing machinery 
revised version published ai memo mit artificial intelligence laboratory cambridge massachusetts october 
steele steele guy lewis jr rabbit compiler scheme study compiler optimization technical report mit artificial intelligence laboratory may 
revised version author master thesis steele 
steele steele guy lewis jr gerald jay sussman 
art interpreter modularity complex parts zero 
ai memo mit artificial intelligence laboratory cambridge massachusetts may 
steele steele guy lewis jr gerald jay sussman 
revised report scheme dialect lisp 
ai memo mit artificial intelligence laboratory cambridge massachusetts january 
steele steele guy lewis jr gerald jay sussman 
constraints 
proceedings apl conference pp 
rochester new york june 
association computing machinery 
apl quote quad june 
published ai memo mit artificial intelligence laboratory cambridge massachusetts november 
steele steele guy lewis jr gerald jay sussman 
dream lifetime lazy variable extent mechanism 
lisp conference pp 

steele steele guy jr overview common lisp 
acm lfp pp 

steele steele guy jr daniel hillis 
connection machine lisp fine grained parallel symbolic processing 
acm lfp pp 

steele steele guy jr making asynchronous parallelism safe world 
proceedings seventeenth annual acm symposium principles programming languages pp 
san francisco january 
association computing machinery 
isbn 
steele steele guy jr jon white 
print floating point numbers accurately 
acm pldi pp 

sussman sussman gerald jay terry winograd eugene charniak 
micro planner manual 
ai memo mit artificial intelligence laboratory cambridge massachusetts december 
sussman sussman gerald jay drew vincent mcdermott 
planner conniver genetic approach 
proceedings fall joint computer conference pp 
new jersey august 
afips press 
published version sussman 
steele gabriel evolution lisp sussman sussman gerald jay drew vincent mcdermott 
better planning 
ai memo mit artificial intelligence laboratory cambridge massachusetts april 
sussman sussman gerald jay richard stallman 
heuristic techniques computer aided circuit analysis 
ai memo mit artificial intelligence laboratory cambridge massachusetts march 
sussman sussman gerald jay guy lewis steele jr scheme interpreter extended lambda calculus 
ai memo mit artificial intelligence laboratory cambridge massachusetts december 
sussman sussman gerald jay matthew 
abstraction numerical methods 
acm lfp pp 

swanson swanson mark robert kessler gary lindstrom 
implementation portable standard lisp bbn butterfly 
acm lfp pp 

swinehart swinehart sproull 
sail 
sail operating note stanford artificial intelligence laboratory stanford california 
symbolics symbolics cambridge massachusetts 
guide symbolics lisp march 
takeuchi takeuchi okuno 
tao harmonic mean lisp prolog smalltalk 
acm sigplan notices pp 
july 
teitelman teitelman warren 
pilot step man computer symbiosis 
technical report mac tr mit project mac september 
ph thesis 
teitelman teitelman bobrow hartley murphy 
bbn lisp manual 
bolt beranek newman cambridge massachusetts 
teitelman teitelman warren 
conversational lisp 
ijcai pp 

teitelman teitelman warren interlisp manual 
xerox palo alto research center palo alto california 
revision 
teitelman teitelman warren interlisp manual 
xerox palo alto research center palo alto california october 
third revision 
lawrence david smith 
lisp pattern matching system 
ijcai pp 

thacker thacker mccreight lampson sproull boggs 
alto personal computer 
siewiorek daniel gordon bell allen newell eds computer structures principles examples computer science series chapter pp 

mcgraw hill new york 
isbn 
travis travis larry honda richard leblanc stephen zeigler 
design rationale telos pascal ai language 
acm pp 

ungar david ungar 
generation scavenging non disruptive high performance storage reclamation algorithm 
acm pp 

utah utah symbolic computation group 
portable standard lisp users manual 
technical report tr department computer science university utah salt lake city january 
vuillemin vuillemin jean 
exact real computer arithmetic continued fractions 
acm lfp pp 

wand wand mitchell daniel friedman 
compiling lambda expressions continuations factorization 
technical report indiana university july 
steele gabriel evolution lisp waters waters richard loops 
proceedings eleventh annual acm symposium principles programming languages pp 
salt lake city utah january 
association computing machinery 
isbn 
waters waters richard optimization series expressions part user manual series macro package 
ai memo mit artificial intelligence laboratory cambridge massachusetts january 
waters waters richard optimization series expressions part ii overview theory implementation 
ai memo mit artificial intelligence laboratory cambridge massachusetts january 
wegbreit wegbreit ben 
studies extensible programming languages 
phd thesis harvard university cambridge massachusetts 
wegbreit wegbreit ben 
ecl programming system 
proceedings fall joint computer conference pp 
new jersey august 
afips press 
wegbreit wegbreit ben ben glenn holloway charles jay 
ecl programmer manual 
technical report harvard university center research computing technology cambridge massachusetts september 
wegbreit wegbreit ben glenn holloway jay judy 
ecl programmer manual 
technical report harvard university center research computing technology cambridge massachusetts december 
weinreb weinreb daniel david moon 
lisp machine manual preliminary version 
mit artificial intelligence laboratory cambridge massachusetts november 
weinreb weinreb daniel david moon 
lisp machine manual third edition 
mit artificial intelligence laboratory cambridge massachusetts march 
white white jon address memory management gigantic lisp environment gc considered harmful 
lisp conference pp 

white white jon reconfigurable retargetable case study efficient portable lisp system building 
acm lfp pp 

wulf wulf russell habermann 
bliss language systems programming 
communications acm pp 
december 
wulf wulf william richard johnsson charles weinstock steven hobbs charles 
design optimizing compiler volume programming language series 
american elsevier new york 
isbn 
victor computer programming comit ii 
mit press reading massachusetts 
isbn 
