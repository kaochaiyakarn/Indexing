proper tail recursion space efficiency william clinger northeastern university ccs neu edu ieee ansi standard scheme requires implementations properly tail recursive 
ensures portable code rely space efficiency continuation passing style idioms 
face proper tail recursion concerns efficiency procedure calls occur tail context 
examined closely proper tail recursion depends fact garbage collection asymptotically space efficient algol stack allocation 
proper tail recursion ad hoc tail call optimization stack languages 
proper tail recursion precludes stack allocation variables yields defined asymptotic space complexity relied portable programs 
offers formal implementation independent definition proper tail recursion scheme 
shows entire family implementations characterize related safe space properties proves asymptotic inequalities hold 
tail recursion phrase refer various syntactic notions particular techniques implementing syntactic tail recursion space efficiency techniques 
syntactically call tail call appears function body reduce call formalized section 
complete call graph seldom available tail call said tail recursive regardless occurs cycle call graph 
scheme standard ml functional languages rely heavily efficiency tail recursion 
common idioms notably continuation passing style cps quickly run stack space tail calls consume space 
ensure portable code rely idioms ieee standard scheme iee says implementations scheme required properly tail recursive ste 
allows appear proceedings acm pldi 
copyright association computing machinery see www acm org pubs copyright policy full text acm copyright notice long fit 
quote constants variable lambda expressions conditional expressions set 
assignments 
procedure calls lambda 
true false num sym vec hff number ff fi location identifier internal syntax core scheme 
execution iterative computation constant space iterative computation described syntactically recursive procedure 
standard citation refers technical report uses cps conversion explain proper tail recursion meant context scheme compiler ste 
explanation formally precise entirely clear applies implementation uses different algorithm cps conversion cps conversion 
attempts characterize proper tail recursion truly implementation independent way informal ste intuitively function calls push control stack argument evaluation pushes control stack 
style definition proposed morrisett harper mh defines set asymptotic space complexity classes characterize proper tail recursion related safe space complexity properties 
complexity classes defined terms specific implementations depending details existence implementation dependent data structures stacks heaps 
provides solid foundation reasoning asymptotic space complexity scheme programs provides implementors formal basis determining potential optimizations safe respect proper tail recursion 
program language lines calls tail calls self tail calls scheme lalr scheme lalr scheme dynamic scheme scheme nucleic scheme lcc jpeg grep static frequency tail calls 
numbers obtained instrumenting compilers lcc fh ch 
self tail calls shown scheme include tail calls known closures reason recognize self tail calls special case 
see section 
tail calls shows internal syntax core scheme 
external syntax full scheme converted internal syntax expanding macros replacing vector string list constants constant storage 
definition tail expressions program written core scheme defined inductively follows 

body lambda expression tail expression 

tail expression tail expressions 

tail expression 
extends definition syntax full scheme 
definition tail call tail expression procedure call 
shows tail calls common special case self tail calls procedure calls tail recursively 
essence proper tail recursion essence proper tail recursion procedure return performing tail call procedure including 
kind dual informal characterization quoted section 
tail call cause immediate return passes responsibility returning procedure performs tail call procedure calling 
words activation procedure extends time called time performs return tail call 
fundamentally different traditional view procedure calls activation procedure encompasses activations procedures calls 
example shows procedure definition contains tail calls self tail call 
predicate binary tree failure continuation arguments find leftmost searches leftmost leaf satisfies predicate 
leaf returned normally 
procedure returns performing tail call failure continuation 
define find leftmost predicate 
tree fail leaf 
tree predicate 
tree tree return fail tail call continuation lambda find leftmost tail call predicate 
right child tree fail find leftmost predicate 
tail call left child tree continuation example tail calls 
find leftmost uses explicit failure continuation pure example continuation passing style fourth line returns tree implicit continuation 
returning equivalent performing implicit tail call implicit continuation 
scheme perfectly feasible write large programs procedure returns calls tail calls 
pure continuation passing style 
proper tail recursion guarantees implementations bounded amount storage implement calls performed program written style 
precise need proper model space consumption 
model allow reason space needed run program independent implementation 
tractable space model take form asymptotic upper bound space consumed implementation 
proper tail recursion constrains determine space model 
obtain complete model model space consumed variables data specify roots garbage collector determine variable datum reachable 
garbage collection completes model 
reasonable garbage collector asymptotic space required variables data largest number words occupied reachable variables data point program app 
example scheme programmer tell space required find leftmost independent num compilers routinely cps scheme target language 
ber right edges tree proportional maximal number left edges occur directed path root tree leaf 
left child leaf find leftmost runs constant space matter large tree 
retention versus deletion deletion strategy reclaims storage statically determined points program retention strategy retains storage longer needed determined dynamic means garbage collection fis 
algol stack allocation important deletion strategy 
allowing lifetime variable value extend lifetime block declared created retention strategies support flexible programming styles 
known retention strategies reclaim storage sooner deletion strategy better asymptotic space efficiency 
crucial proper tail recursion 
deletion strategies interfere proper tail recursion ste cha app 
example section allocating continuation stack require space space left child leaf 
compilers scheme standard ml similar languages employ optimizations allocate variables stack ste han sf ser sis 
researchers gone far suggest static deletion strategy replace dynamic garbage collection altogether programs tt afl sis 
scheme stack allocation deletion strategies destroy property proper tail recursion 
easy determine cha sf 
easier informality proper tail recursion defined 
fairly easy define proper tail recursion formally particular implementation formalization refer structures stack 
standard ml new jersey example allocates continuation frames heap distinguish closures allocated explicit lambda expressions app 
algol implementations single stack represent distinct kinds runtime structure continuations environments store 
distinction storage allocated continuations environments store clear implementor 
formal definitions largest number machine words possibly nondeterministic implementation consume running program input described deterministic function stands real numbers 
refer space consumption function compare asymptotic behavior functions big notation defined 
real valued functions natural numbers definition equivalent usual definition knu clr 
definition asymptotic complexity set 
asymptotic upper bound complexity class defined configuration hv oei ae oei hv ae oei value unspecified undefined escape hff closure hff aei halt select ae assign hi ae push hhe hv ae call hhe ae identifier fin location oe location fin value permutation syntax configurations 
set functions 
exist real constants space consumption function sx induces asymptotic space complexity class sx 
sections describe family implementations formalize important models space efficiency 
space consumption functions stack tail sfs defined section 
induced complexity classes related proper inclusions sfs ae ae tail ae stack definition conventional space leaks implementation conventional space leak iff space consumption stack 
implementation conventional space leaks iff space consumption stack 
definition properly tail recursive implementation properly tail recursive iff space consumption tail 
implementation stack space leak iff conventional space leaks properly tail recursive 
implementation stack space leak known improperly tail recursive 
definition tail recursive safe space implementation tail recursive wan que iff space consumption 
implementation safe space complexity sense appel app iff space consumption sfs 
properties implementation proper tail recursion especially important easy construct programs run small constant space require linear space implementations properly tail recursive 
reduction rules quote ae oei hc ae oei hi ae oei hoe ae ae oei dom ae ae dom oe oe ae undefined hl ae oei hff aei ae oe ff 
unspecified ff occur ae oe ae oei ae select ae oei set 
ae oei ae assign hi ae oei ae oei ae push hhe hi ae oei reverse gamma continuation rules hv fg halt oei hv oei hv ae halt oei hv halt oei hv ae select ae oei ae oei false hfalse ae select ae oei ae oei hv ae assign hi ae oei ae oe ae 
hv ae push hhe hv ae oei ae push hhe hv ae oei hv ae push hhi hv ae oei hv ae call oei hv hv hff aei ae call vn oei ae oe lambda 
fi 
fi occur ae oe ae ae 
fi fi oe oe fi fi 
vn garbage collection rule hv ae oe fi 
hv ae oei ffi nonempty fi 
occur ae oe properly tail recursive semantics 
proper tail recursion tail expose space requirements retaining simplicity needed proofs properly tail recursive implementation expressed small step operational semantics kind known machine nn 
asymptotic space required implementation great space required reasonable implementation scheme including pure interpreters implementation non clever 
nondeterministic reflect underspecification definition scheme 
configuration semantics shown final configuration consisting value store intermediate configuration consisting expression value environment continuation store 
intermediate configuration represents state machine registers accumulator environment static link continuation dynamic link garbage collected heap 
component configuration expression accumulator acts program counter 
component value continuation register acts program counter 
initial configurations described section defines observable answer represented final configuration 
core transition rules shown 
core rules supplemented additional rules mainly primitive procedures specified 
reduction rules say ffl quoted datum evaluates datum 
ffl identifier evaluates value dom ae ae dom oe oe ae undefined transition rule applied computation stuck 
ffl lambda expression evaluates closure 
bug design scheme requires location ff allocated tag closure ram 
ffl conditional expression evaluated evaluating test continuation select alternatives 
ffl right hand side assignment evaluated continuation store value lvalue left hand side 
ffl procedure call evaluated nondeterministically choosing permutation operator operand expressions permuted expressions evaluated continuation evaluate perform call 
sources nondeterminism include choice locations allocate closure called choice garbage collection rule 
conceptual difference proper tail recursion ad hoc tail call optimization semantics 
proper tail recursion affects rule shown reduction rules continuation rules 
properly tail recursive implementation continuations created evaluate subexpressions call procedure ste 
procedure call just goto changes environment register 
notice call goto just tail calls 
continuation rule shows closures called create new continuation 
particular procedure call create pass new return address push environment ae allocate stack frame 
continuations tagged select assign push include environment restored continuation invoked 
allows test part conditional right hand side assignment operator operand expression destroy environment performing procedure call 
garbage collection rule allows unreachable storage recycled 
exists nonempty set locations reachable active store locations mentioned ae locations may removed active store available steps computation 
garbage collection rule allows require garbage collection 
prevent improper tail recursion masked garbage require garbage collection rule sufficiently 
section require garbage collection rule garbage remains collected 
real implementation garbage collector run fixed constant times space required collecting computation step app section 
usually 
improper tail recursion stack improperly tail recursive implementation obtained replacing continuation rule hff aei ae call oei ae return hae oe lambda 
fi 
fi occur ae oe ae ae 
fi fi oe oe fi fi 
vn adding continuation rule hv ae return hae oei hv ae oei creating continuation procedure call rules waste space reason ste 
look lot silly implemented deletion strategy local variables 
scheme deletion strategy create dangling pointers 
mentioned section scheme compilers deletion strategy optimization variables lifetimes statically bounded 
see happen optimizations pursued regard effect tail recursion stack semantics obtained replacing continuation rule hff aei ae call oei ae return ha ae oe lambda 
fi 
fi occur ae oe ae ae 
fi fi oe oe fi fi 
vn ffi fi ng sequence reduction steps allocates storage location garbage collection rule needed configurations component expression 
hv ae return ha ae oe hv ae oei fi occurs ae oe oe oe dom oe nondeterministic choice subsumes static analysis optimization allocates variables stack provided optimization create dangling pointers extend lifetime garbage variable algol stack allocation 
algol subset scheme possible choose ffi fi ng results space required algol stack allocation variables 
choice consumes space determines space consumption stack programs 
stack characterizes space consumed algol implementations 
tail recursion tail uses space stack wastes space needlessly 
example necessary preserve environment evaluation subexpression evaluated evaluation procedure call 
pure interpreter take advantage technique known tail recursion wan que 
denote empty environment semantics obtained tail replacing continuation rule push rules hv ae push hhe hv ae oei ae push hhe hv ae oei hv ae push hhe hv ae oei ae push hhi hv oei safe space complexity free sfs implementations described far lambda expression closed variables scope regardless variables occur free lambda expression 
typical interpretive algol implementations forces programmers write awkward code avoid space leaks 
compiled implementations close free variables improves space complexity programs 
free semantics obtained tail replacing reduction rule lambda expressions hl ae oei hff ae ae oe ff 
unspecified ff occur ae oe ae ae dom ae fv sfs semantics obtained tail replacing reduction rule lambda expressions replacing reduction rules continuation rule ae oei ae select ae oei ae ae dom ae fv fv set 
ae oei ae assign hi ae oei ae ae fig ae oei ae push hhe hi ae oei reverse gamma ae ae dom ae fv hv ae push hhe hv ae oei ae push hhe hv ae oei ae ae dom ae fv asymptotic space efficiency sfs represents space complexity sense defined appel app asymptotic space efficiency free represents weaker useful sense safe space 
equivalence implementations section proves implementations compute answers 
implementations space result requires countably infinite set locations location fff 
lemma configuration stack configuration obtained replacing continuations form return ha ae return hae hv oei hv oei 
proof induction number computation steps 
locations occur subset occur nondeterministic choices original computation computation lemmas proved similarly 
lemma configuration configuration tail obtained replacing continuations form return hae hv oei hv oei 
lemma hv oei rules tail hv oei rules definition initial configurations initial configuration configuration form ae halt oe ffl ff occurs ae oe ff dom oe ffl identifier occurs free dom ae ffl ff occurs ff ran ae definition answers observable answer represented final configuration hv oei possibly infinite sequence output tokens answer oe answer oe ans oe eof ans true oe ans oe eof ans false oe ans oe eof ans num oe ans oe eof ans sym oe ans oe eof ans vec hff oe ans hoe ff oe ans escape hff oe proc ans oe eof ans closure hff aei oe proc ans oe eof 
ans hi oe ans oe eof ans hv oe ans oe si ans eof store output lemma ffl tail free ffl sfs ffl free sfs hv oei rules exist oe answer oe answer oe hv oe rules proof step computation analogous rule nondeterministic choices differences corresponding configurations environments occur configuration restricted free variables expression evaluated environment 
final configurations differ environment components closures continuations captured part escape procedure differences observable 
definition ff convertible configurations ff convertible written ff iff exists toone function location location configuration obtained renaming locations lemma shows ff convertible configurations semantically equivalent 
lemma ff hv oei exist oe answer oe answer oe hv oe sketch proof rules treat location specially 
verified primitive operations rules omitted 
definitions lemmas establish existence canonical forms computations garbage collection maximal garbage collection 
definition gc transform configuration configuration gc transform defined follows 
ffl final configuration hv oei hv oe hv halt oe gc transform hv halt oei 
ffl garbage collection rule apply final configuration ffl unique configuration garbage collection rule garbage collection rule apply lemma gc transforms exists configuration unique ff convertibility definition gc transform computation delta delta delta computation gc transform computation computation obtained sequence follows 
erased sequence 
remain adjacent 
inserted sequence sfs free tail stack gamma gamma gamma gamma gamma gamma hierarchy space complexity classes 
theorem canonical forms delta delta delta computation gc transform pointwise ff convertible gc transform computation uses garbage collection rule 
theorem answer computed initial configuration rules sfs computed configuration rules stack proof computation sfs theorem lift structurally similar computation garbage collection rule 
gc free computation transformed computation tail ae ae rule sfs differs tail resulting computation transformed computation adding return continuations call rule inserting uses return rule computation 
resulting computation transformed computation stack adding empty set return continuation 
corollary implementations compute answers 
space consumption section gives formal definition space required configuration defines functions tail stack free sfs characterize space required run program input worst case execution sequences certain property 
functions induce hierarchy space complexity classes shown 
define space consumed implementation take inputs expressions programs expressions evaluate procedure argument 
constants program share storage constants input may share storage standard library 
easiest way ensure forbid vector string list constants 
entails loss generality constants replaced global variables initialized standard library procedures allocate new vectors strings lists 
ae oe fixed initial environment initial store contain scheme standard procedures described section iee 
program input denote set core scheme expressions contain locations free variables bound ae space hv oei space space oe space ae oei jdom aej space space oe space hv ae oei space jdom aej space space oe space oe ff oe space oe ff space true space false space sym space vec hff ff gamma space num log exact positive integer iee 
space closure hff aei jdom aej space halt space select ae jdom aej space space assign hi ae jdom aej space space push hhe emi hv ae jdom aej space space call vmi space space return hae jdom aej space space return ha ae jdom aej space space consumed configuration flat environments 
space consumed configuration defined 
definition corresponds flat copied environments purpose definition establish upper bounds lower bounds 
comparison flat environments linked shared environments see section 
definition space efficient computation finite countably infinite sequence configurations fc ffl initial configuration 
ffl sequence finite ends final configuration cn ffl gamma rules ffl garbage collection rule applicable garbage collection rule 
definition eliminates incomplete stuck computations consideration 
stuck computation represents program error case stack stack allocation creates dangling pointer 
definition supremum supremum sup upper bound upper bound 
definition space consumption space consumption function program theta input 
defined jp ig fc space efficient computation ae halt oe ig jp number nodes syntax tree theorem program input ffl tail stack ffl sfs tail ffl sfs free tail proof prove consider arbitrary space efficient computation computation pointwise ff convertible gc transform computation garbage collection rule 
gc free computation lifted proof theorem 
gc transform lifted computation space efficient computation equivalent original computation consumes space 
theorem set inclusions shown proper free incomparable 
proof show suffices give example program quote quote readability write program full scheme procedure definition 
program distinguishes tail programs consume quadratic space implementation linear 
scheme linear programs log unlimited precision arithmetic fixed precision arithmetic 
show stack define vector zero 
show tail define zero 
show tail free free sfs define define lambda vector zero 
show tail free free sfs define vector zero 
lambda flat versus linked environments definition space consumption corresponds linked environments obtained counting binding identifier location ff configuration regardless environments contain binding 
recall ae finite function viewed subset identifier theta location 
graph ae set ordered pairs 
defines space consumed configuration linked environments 
space consumed implementation uses linked environments defined terms space consumption function differs definition 
easy see analogues theorems hold linked environments implementation sense linked environments space efficient flat environments 
unfortunately free sfs linked environments general require flat environments 
free sfs practical meaning 
asymptotic relationships hold tail free sfs question practical interest 
theorem tail incomparable free sfs 
proof appel app examples show free ae tail sfs ae free appel examples establish half theorem 
half theorem established example show sfs tail 
natural number define loop thunks zero 
list ref thunks random length thunks loop cons lambda list xk thunks loop xj gamma 
pk define ek 
tail pn quote log linear fixed precision arithmetic sfs pn quote theta theorem reveals important difference formulation space complexity section formulation appel app 
appel formulation allows constants definition chosen separately program 
effectively ignores extra space consumed flat environments closures space consumed large class compiler optimizations inlining loop unrolling 
formulated space safety properties allow bounded increase space due inlining loop unrolling shared closures similar techniques bound independent source program 
appel formulation led perception flat closures free variables asymptotically space efficient linked closures close variables scope formulated asymptotic space complexities flat linked closures incomparable 
consistent intuition implementors argued sense impose stringent safe space complexity requirements bounding increases space consumption result compiler transformation program 
sanity check idea defining proper tail recursion space complexity class new intensionally informal notions proper tail recursion 
extensionally coincide consensus scheme standard ml programming communities concerning implementations properly tail recursive 
best knowledge implementations scheme standard ml properly tail recursive formal definition 
implementations reasons ffl space leaks caused bugs 
ffl space leaks caused conservative garbage collection boe 
ffl space leaks caused aggressive stack allocation optimizations 
ffl target architecture proper tail recursion difficult slow implementors deliberately sacrificed proper tail recursion speed compatibility 
space hv oei space space oe space ae oei ae bindings space space oe space hv ae oei space ae bindings space space oe 
space closure hff aei space halt space select ae space 
bindings closure hff aei graph ae bindings halt bindings select ae graph ae bindings bindings assign hi ae graph ae bindings bindings push hhe emi hv vn ae graph ae bindings bindings call vm bindings bindings return hae graph ae bindings bindings return ha ae graph ae bindings space consumed configuration linked environments 
example ch retains temporary long stack frame 
conservative garbage collection users notice bug causes rare failures proper tail recursion 
target architectures languages scheme require garbage collection anyway proper tail recursion considerably faster improper tail recursion 
unfortunately standard calling conventions machines proper tail recursion difficult inefficient implementor choose ffl improper tail recursion ffl proper tail recursion nonstandard possibly slower calling convention 
dilemma arises target architecture ansi explained bigloo user manual ser bigloo produces files 
code uses stack programs properly tail recursive 
simple tail recursions compiled stack consumption 
bigloo similar implementations fail continuation passing style find leftmost example section tail calls known procedures consume space 
implementations kind assume global variable defined top level procedure definition assigned increases percentage calls known procedures shown column 
examples include sparc powerpc 
standard calling conventions pass arguments stack frame created caller 
callee performs tail call procedure arguments require space allocated caller frame callee allocate new frame causes improper tail recursion increase size caller frame impossible powerpc slow sparc 
architectures perform properly tail recursive implementations slightly nonstandard calling conventions 
standard techniques generating properly tail recursive code allocate stack frames calls perform periodic garbage collection stack frames heap nodes bak 
definition proper tail recursion asymptotic space complexity allows technique 
knowledge formal definitions 
previous scheme invented steele sussman purpose understanding hewitt actor model heavy continuation passing style attempts formalize proper tail recursion ss 
proper tail recursion popularized steele sussman ss wf ss ste ste ste ss ss 
proper tail recursion safety properties considered chase analysis optimizations increase asymptotic space complexity programs cha 
close connection proper tail recursion garbage collection asymptotic space complexity pointed appel chapter app 
discussions proper tail recursion informal formal definitions context particular implementation ste cli app ram 
definition essentially definition proposed morrisett harper mh 
treatment garbage collection closely related morrisett felleisen harper 
implementations described related denotational semantics scheme proving answer computed denotational semantics computed implementations 
possible prove implementations properly tail recursive cli lig gw 
proofs easier proofs correctness difficult proofs sections 
possible formulate prove soundness formal system reasoning space complexity programs written scheme standard ml similar languages 
space efficiency required properly tail recursive implementations stated precise implementation independent manner 
kinds safe space properties defined similar fashion 
space complexity classes defined justify formal implementation independent reasoning space required programs 
space complexity classes defined stack tail sfs correspond models working programmers reason space required algol scheme standard ml programs respectively 
complexity classes classify space leaks created optimizations 
algol stack allocation viewed optimization usually delivers small constant improvement space required garbage collector risking asymptotic increases space required run programs 
owes electronic communications henry baker hans boehm olivier danvy matthias felleisen greg morrisett kent pitman john jeffrey mark siskind mistakes mine 
afl aiken fahndrich levien 
better static memory management improving region analysis higher order languages 
conference programming language design implementation pages san diego california june 
app andrew appel 
compiling continuations 
cambridge university press 
andrew appel zhong shao 
empirical analytic study stack vs heap cost languages closures 
journal functional programming 
hal abelson gerald jay sussman julie sussman 
structure interpretation computer programs 
mit press cambridge ma second edition 
bak henry baker 
cons cons arguments part ii cheney acm sigplan notices september 
boe hans juergen boehm 
space efficient conservative garbage collection 
proc 
acm conference programming language design implementation pages 
ch william clinger lars thomas hansen 
lambda ultimate label simple optimizing compiler scheme 
proc 
acm symposium lisp functional programming pages 
cha david chase 
safety considerations storage allocation optimizations 
proc 
acm conference programming language design implementation pages 
cli william clinger 
scheme compiler exercise denotational semantics 
proc 
acm symposium lisp functional programming pages august 
clr thomas cormen charles leiserson ronald rivest 
algorithms 
mit press mcgraw hill 
fh christopher fraser david hanson 
retargetable compiler design implementation 
benjamin cummings 
fis michael fischer 
lambda calculus schemata 
proceedings acm conference proving assertions programs pages 
acm sigplan sigplan notices vol 
sigact news january 
cormac flanagan amr sabry bruce duba matthias felleisen 
essence compiling continuations 
proc 
acm conference programming language design implementation pages 
gw joshua guttman mitchell wand editors verified implementation scheme 
kluwer boston 
originally published special double issue journal lisp symbolic computation volume issue 
han chris hanson 
efficient stack allocation languages 
proc 
acm symposium lisp functional programming 
carl hewitt 
viewing control structures patterns passing messages 
artificial intelligence 
iee ieee computer society new york 
ieee standard scheme programming language ieee standard edition 
richard kelsey william clinger jonathan rees eds 
revised report algorithmic language scheme 
ftp ftp nj nec com pub kelsey rs ps february 
david kranz richard kelsey jonathan rees paul hudak james philbin norman adams 
orbit optimizing compiler scheme 
proceedings sigplan symposium compiler construction 
sigplan notices july 
knu donald knuth 
art programming volume fundamental algorithms 
addisonwesley boston second edition 
lig software 
manual software 
scientific press 
greg morrisett matthias felleisen robert harper 
models memory management 
proc 
acm conference functional programming computer architecture pages 
mh morrisett harper 
semantics memory management polymorphic languages 
gordon pitts editors higher order operational techniques semantics publications newton institute pages 
cambridge university press 
nn hanne riis nielson flemming nielson 
semantics applications formal 
john wiley sons 
que christian queinnec 
lisp small pieces 
cambridge university press 
ram john 
scheme generation 
acm lisp pointers oct dec 
ram john 
tail recursive secd machine 
appear 
ser manuel serrano 
bigloo user manual 
part bigloo distribution available unige ch serrano bigloo html 
sf manuel serrano marc feeley 
storage analysis applications 
proc 
acm international conference functional programming pages 
sis jeffrey mark siskind 
static language implementation 
software available www neci nj nec com homepages 
ss gerald sussman guy steele jr scheme interpreter extended lambda calculus 
artificial intelligence memo massachusetts institute technology cambridge ma december 
ss guy steele jr gerald jay sussman 
lambda ultimate imperative 
artificial intelligence memo massachusetts institute technology cambridge ma march 
ss guy steele jr gerald jay sussman 
art interpreter modularity complex parts zero 
artificial intelligence memo massachusetts institute technology cambridge ma may 
ss guy steele jr gerald jay sussman 
revised report scheme 
artificial intelligence memo massachusetts institute technology cambridge ma january 
ste guy steele jr lambda ultimate declarative 
artificial intelligence memo massachusetts institute technology cambridge ma october 
ste guy lewis steele jr expensive procedure call myth 
acm national conference pages seattle october 
revised mit ai memo october 
ste guy steele jr rabbit compiler scheme 
technical report massachusetts institute technology cambridge ma may 
tt mads tofte jean pierre talpin 
implementation typed call value calculus stack regions 
proceedings st annual acm symposium principles programming languages pages 
wan mitchell wand 
continuation program transformation strategies 
journal acm 
wf mitchell wand daniel friedman 
compiling lambda expressions continuations factorizations 
journal computer languages 
