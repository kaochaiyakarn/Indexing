causal memory definitions implementation programming ahamad gil james burns prince georgia institute technology phillip git cc september revised july abstraction shared memory growing importance distributed computing systems 
traditional memory consistency ensures processes agree common order operations memory 
unfortunately providing guarantees entails access latencies prevent scaling large systems 
weakens guarantees defining causal memory abstraction ensures processes system agree relative ordering operations causally related 
causal memory weakly consistent admits executions concurrency atomic sequentially consistent memories 
provides formal definition causal memory gives implementation message passing systems 
addition describes practical class programs developed strongly consistent memory run correctly causal memory 
college computing georgia institute technology atlanta georgia supported part national science foundation ccr ccr ccr ccr 
parts appeared toueg spirakis editors proceedings fifth international workshop distributed algorithms volume lecture notes computer science pages springer verlag october 
author current address bellcore nvc newman springs road post office box red bank new jersey 
authors address college computing georgia institute technology atlanta georgia 
author address virginia avenue ne atlanta georgia 
abstraction shared memory growing importance distributed computing systems 
allows users program systems concerning details underlying message passing system 
traditionally distributed shared memories ensure processes system agree common order operations memory 
guarantees provided sequentially consistent memory atomic memory called linearizable memory 
unfortunately providing consistency guarantees entails access latencies prevent scaling large systems 
simple argument show memory provide strong consistency retain low latency systems high message passing delays 
tradeoff represents significant efficiency problem forces applications pay costs consistency highly parallel involve little synchronization 
number techniques suggested improve efficiency shared memory implementations provide partial remedies fundamental problem latency scale strongly consistent memories 
research suggests systematic weakening memory consistency reduce costs providing consistency maintaining viable target model programmers 
weakly consistent memories admit executions concurrency sequentially consistent atomic memories 
defines causal memory abstraction ensures processes system agree relative ordering operations causally related 
causal memory mentioned earlier papers careful definitions done 
provides formal definition causal memory gives implementation message passing systems 
give classes programs developed assuming sequentially consistent memory run correctly causal memory 
causal memory lamport concept potential causality 
potential causality provides natural ordering events distributed system processes communicate message passing 
introduce similar notion causality reads writes shared memory environment 
causal memory requires reads return values consistent causally related reads writes say reads respect order causally related writes 
causality orders events partially reading processes may disagree relative ordering concurrent writes 
provides independence concurrent writers reduces consistency maintenance synchronization costs 
idea synchronization required program specified explicitly necessary memory provide additional synchronization guarantees 
causal memory related isis causal broadcast notion causally ordered messages 
implementation causal memory vector timestamps isis implementation causal broadcast 
implementations non blocking process may complete operation write send waiting communication processes 
causal memory collection locations updated causal broadcasts 
memory overwrite semantics messages queuing semantics 
message recipient assured eventually receive messages sent repeated reads guarantee values written read 
hidden writes values overwritten read possible 
process may read memory locations order chooses may read value location value location write operation stores causally write message passing system behavior violate required causal ordering 
give precise characterizations classes programs run correctly causal memory 
execution program classes causal memory sequentially consistent 
program proven correct sequential consistent memory correct causal memory 
classes includes data race free programs explicit synchronization prevent problems may stem concurrent access shared memory 
far clear best kind shared memory model distributed systems 
strongly consistent memories easier program weak memories require costly blocking implementations 
weak memories may implemented cheaply practical program 
believe causal memory provides happy medium allows non blocking implementations useful model class practical programs 
shared memory systems section formally describes system underlies definitions results 
model derived herlihy wing misra 
define system finite set processes interact shared memory consists finite set locations 
fp set processes 
process interaction memory series read write operations memory 
operation acts named location associated value 
example write operation process denoted stores value location similarly denoted read operation reports stored location local execution history local history process denoted sequence read write operations 
operation precedes write say precedes program order 
execution history history hl collection local histories process 
operation said local histories comprises 
different kinds memories defined considering serializations certain sets operations 
respectively set operations history serialization linear sequence containing exactly operations read operation location returns value written preceding write location 
stated assume location initial value value returned read location preceding write 
serialization respects order operations implies precedes causal memory definitions implementation programming earlier memory models formalism developed define variety memory consistency models 
section defines lamport sequential consistency pram lipton sandberg 
section uses formalism define causal memory 
idea sequential consistency shared memory accessed processes may distributed may consist different modules processes observations memory consistent permits sequential accesses single memory 
history sequentially consistent satisfies sc serialization respects program orders values returned read operations consistent sequential ordering processes communicate shared memory tell way interactions memory accessing single memory 
memory sequentially consistent admits sequentially consistent histories 
recognizing sequential consistency costly implement lipton sandberg developed weaker form memory called pipelined ram pram 
memory requires writes process seen program order processes 
process sequence operations writes processes 
reason definition 
history process comprise operations write operations history pram satisfies pram process serialization respects program orders memory pram admits pram histories 
notice sequential consistency pram require serializations respect program order 
pram weaker sequential consistency process may perceive different serialization 
order writes process serializations processes writes different processes may appear different orders different serializations 
furthermore process serialization contain read operations processes directly aware operations 
gives example pram history sequentially consistent 
history pram serializations exist show history sequentially consistent 
suppose memory atomic linearizable history admits serialization preserves order local histories pair operations executions overlap real time 
definition memories scope 
history sequentially consistent required serialization 
inspection shows appear order inspection shows appear order gives contradiction ordered uniquely 
slow memory ahamad defined formalism processor consistency 
currently exploring formalism definition memories 
causal memory define causal memory intermediate sequential consistency pram 
definition similar pram stronger serializations required respect program order causality order 
define causality orders 
hl causality order operations determined program order writes order associates write operation read operation location initial value 
writes order analogous order message passing systems relates sending message corresponding receipt 
order message passing systems easier define message receipt unique sending event 
case shared memory systems write operations may write value location clear associate particular read operation 
misra simplified situation assuming writes location uniquely valued 
may multiple writes value location may writes order 
writes order 
relation properties ffl 
ffl operation 
ffl 
read write read initial value 
causality order induced 
partial order transitive closure union history program order order 
words cases holds causal memory definitions implementation programming history causal ffl precedes ffl 
reads value written ffl operation 
relation cyclic causality order 
operations causality order say concurrent respect 
define causal memory 
history causal causality order cm process serialization respects 
memory causal admits causal histories 
weaker sequential consistency process may perceive different serialization 
causal sequentially consistent causal serializations exist 
causality orders clear causal history pram 
pram histories causal 
gives example history pram causal 
pram serializations consistent program order exist history causal reason 
possible writes order 



causality order relations hold 

writes appear order serializations 
clear way construct respects program order writes order read returns written value location read 
clearly follow choice 
serialization read return history causal 
implementation causal memory section presents proves correct implementation causal memory message passing 
implementation uses adaptation vector timestamps 
requires reliable processes communication channels 
process maintains local data structures 
private copy shared causal memory second vector clock timestamp outgoing messages 
vector natural numbers process system 
informally number writes process aware 
vectors compared comparing components 
vector equal components equal corresponding component oe equal equal note transitive 
process maintains queues 
queue called outqueue contains information local writes memory communicated processes 
second priority queue called queue item includes vector clock value timestamp 
queue ordered timestamp items smaller timestamps appearing closer head 
queue maintained items added queue placed ahead existing items timestamps greater new item 
new item placed existing item equal incomparable timestamp show items equal timestamps need fact 
implementation process shown 
consists initialization routine basic actions 
actions local executed atomically 
read action executed read location invoked value stored returned write action executed write value location invoked process increments writes adds tuple hi ti outqueue tuple called write tuple 
note read write actions require blocking 
contrast implementations linearizable sequentially consistent memory cases shown blocking required 
information outqueue communicated processes 
done send actions may performed convenient process performed infinitely process elect perform send actions 
send action removes nonempty prefix outqueue sends processes 
message received executes receive action adds write tuples message received recall priority queue tuples timestamps 
information update process view memory 
done apply action need performed infinitely 
write tuple head applied timestamp reflects write aware 
determined comparing vector clock timestamp write write applied components timestamp jth equal vector clock jth component exactly jth component vector clock 
write applied causal memory definitions implementation programming initialization foreach outqueue hi hi read action read return add write action write add enqueue hi ti outqueue send action executed infinitely outqueue hi nonempty prefix outqueue remove outqueue send receive action receipt foreach hj si enqueue hj si apply action executed infinitely hi hj si head remove hj si add implementation causal memory process removed corresponding component vector clock updated new value written means write tuple hj si applied memory value vector clock 
facilitate proof correctness implementation introduce notation operation process timestamp denoted ts value vector clock immediately completes 
note write operation ts timestamp included corresponding write tuple 
hl history implementation ordered sequence read write operations performed process see comments 
theorem shows causal 
causality order derived writes order 
read non initial value 
latest write applied performing clear write 
lemmas proof correctness 
asserts causality order reflected vector timestamps lemma history implementation operations ts ts 
furthermore write operation ts ts ts oe ts 
proof proof induction structure order 
consider cases ffl process decrements component vector clock ts equal ts 
furthermore write operation increments local component ts ts 
ffl 
means write operation say corresponding read say note write tuple associated includes timestamp ts 
clear read applies write memory 
process apply write timestamp greater equal ts ts assigned th component clock write applied 
component timestamp decremented greater equal ts reads ts ts 
ffl operation induction implies ts ts ts 
transitivity desired result holds 
write ts ts induction 
ts ts implies ts ts ts ts 
lemma show liveness implementation causal memory definitions implementation programming lemma history implementation suppose write operation process process eventually applies memory 
proof write applied immediately remainder proof assume ts 
inspection shows executed case holds write tuple outqueue write tuple transit write tuple applied write 
performs send operations infinitely outqueue write tuple outqueue eventually sent channels reliable write tuple sent eventually received added show eventually applies write tuple added consider time adds write tuple hi si finitely write tuples ahead time 
write tuples timestamps smaller ts arrive placed ahead hi si easy see finitely write tuples 
reason assume induction point time applied write tuples placed hi si timestamps point hi si head remains applied say ready applied show applied performs apply action 
vector clock point 
show 
process equal 
th write means applies performs implies ts oe ts 
order ahead implies hi si ready applied applied applies desired 
gamma st write lemma ts ts 
order ahead applied gamma 
means applies time performs apply operation 
infinitely conclude eventually applies write 
prove correctness implementation theorem history implementation 
causal 
proof proof show process serialization respects 
recall set operations writes 
serialization obtained simply concatenating writes applied memory reads occur see comments 
lemma includes write operations serialization reads writes apply directly copy memory read reads value written 
remains seen respects 
observe partial order prove suffices observe acyclic showing implies suppose contradiction lemma means ts ts ts ts implying ts ts 
lemma implies write operation contradict equality 
occur process case precede respect program order 
loss generality assume precede operations reads write operation lemma ts oe ts ts implying ts ts contradiction 
conclude causality order cyclic 
operations show precedes lemma ts ts 
cases hold ffl operations acyclic means precedes operations appear order performed precedes ffl write process operation inspection shows set vector clock ts applies local memory 
ts ts occur application 
means precedes ffl write write process ts ts ts ts 
means execute applied apply apply applies applies precedes ffl read write process 
hard see implies write case precedes third case precedes precedes ffl writes processes suppose executed processes lemma implies ts ts apply applied assume vector clock point applied 
ts 
ts ts ts ts 
means applied point 
precedes cases precedes proof complete 
implementation shows read write operations causal memory implemented processes experiencing blocking 
consider analyses performance implementations various forms distributed shared memory 
assume local computation time negligible respect message delays assume worst case message delay 
memory implementation worst case execution time read causal memory definitions implementation programming worst case execution time write 
attiya welch showed systems process clocks perfectly synchronized uncertainty respect message delays messages may take delivered may take impossible achieve implementations linearizable memory see footnote 
lipton sandberg showed implementation sequentially consistent memory contrast implementation causal memory gives 
implementation correct long processes communication channels reliable 
normal assumption implementing distributed shared memory 
developed implementation causal memory correct systems processes may fail stopping communication channels lose messages long channel delivers infinitely messages infinitely sent 
implementation complex inefficient 
give practical implementation sacrifices non blocking property implementation 
implementation vector timestamps associates pages individual locations 
memory node treated cache subset shared pages page fault occurs accessed page cache 
results communication owner node unique page 
owner supplies page fault implementation requires writes page sent owner 
necessary nodes owner notified write operation store copy page 
causal memory consistency implemented locally invalidating pages potentially causally overwritten 
vector timestamps purpose 
implementation require nodes communicate certain read write operations completed memory operations may blocking 
shown implementation provides better performance sequentially consistent memory scientific applications 
programming causal memory previous section showed causal memory may implemented blocking process write operations complete processes learn 
strengthen case causal memory model distributed shared memory argue programmed undue difficulty 
section characterize classes programs program classes written run correctly sequentially consistent memory runs correctly system causal memory 
programs classes written assuming sequentially consistent memory system provides causal memory 
show executions programs causal memory possible sequentially consistent memory 
existence classes indicates causal memory viable model programming distributed applications rules followed programmer may assume memory sequentially consistent causal memory may 
causal memory implemented efficiently result improved performance 
section presents definitions notation necessary discussing behavior programs distributed shared memory 
section considers simple restricted class concurrent write free programs 
section considers practical class data race free programs 
section discusses done proving programs certain classes run correctly memories weaker sequential consistency 
definitions notation time execution process local state determined initial state operations performed far local history 
process runs local program pi function local states actions action form indicating value written location form indicating value read returned 
execution action operation changes process local state note operation associated read action includes value read 
tuple local programs process called program usually denoted pi 
history pi operations execution actions pi specify local states processes pass 
recall history tuple local histories process causality order say history hl prefix respect prefix operation operations precede respect proper prefix respect prefix respect concurrent write free programs major advantage causal memory normal memory accesses implemented blocking processes need synchronize performing accesses 
result programs running causal memory synchronization 
way achieve ensure writes concurrent 
history causality order 
concurrent write free respect write operations concurrent respect 
program pi concurrent write free histories pi causality orders serialization respects note implies sequentially consistent concurrent write free respect 
note concurrent write freedom program statement sequentially consistent histories 
example concurrent write free program actions confused implementation actions described 
causal memory definitions implementation programming shared variables initially local variables process process repeat process repeat concurrent write free program 
concurrent write free execution program writes global variables related follows causality order 
read relevant freedom program 
serves program data race free see 
causal history causality order proves causal suppose concurrent write free respect 
process serialization respects see section 
define strong causality order denoted follows cases holds ffl ffl read process write precedes ffl operation idea extends ordering read writes causally precede writes 
hard see concurrent write free respect associated acyclic particular furthermore operation history finitely operations precede respect 
theorem shows concurrent write free programs produce sequentially consistent executions run causal memory theorem pi concurrent write free histories pi causal memory sequentially consistent 
proof proof induction structure causal histories pi 
specifically finite causal history pi causality order proves causal 
proof infinite follows 
prove assignment shared variable indicates write action 
assignment shared variable right side indicates read action 
holds proper prefixes respect concurrent write free respect serialization respects 
show concurrent write free respect assume contradiction concurrent writes clearly executed different processes assume performed define hl letting subsequence containing operations precede respect 
appears precedes respect giving contradiction 
assume operation appears means includes operations including holds clearly proper prefix respect inductive hypothesis concurrent write free respect serialization respects 
define fj kg 
necessarily proper prefix respect execution pi 
serialization respects 
implies serialization respects 
history pi pi concurrent write free concurrent write free respect 
means concurrent respect giving desired contradiction 
show serialization respects 
noted order acyclic 
finite choose operation hold 
identical excluding proper prefix respect inductive hypothesis serialization respects 
clearly respects respect operation contradicts definition prove serialization proving sequentially consistent 
assume contradiction serialization means read operation recall causal serialization respects 
possibilities ffl write writes precede write follow respect contradicting definition latest write linearization writes value serialization write value concurrent write free respect possibilities respects means precedes contradicting definition means precede contradicting definition causal memory definitions implementation programming ffl write implies write 
serialization 
means serialization contradiction 
cases lead contradictions conclude serialization respects 
implies sequentially consistent 
theorem holds infinite causal history pi 
causality order proves causal 
prove concurrent write free respect 
writes concurrent respect 
shortest prefix includes note causal causality order proves 
easy see finite concurrent write free respect 
implies related giving desired contradiction 
strong causality order derived 
know acyclic operation finite number predecessors respect 
define infinite sequence finite prefixes respect having previous ones proper prefixes respect follows 
empty history 
includes plus operation operations precede respect appear operations chosen fairly operation appears 
construction operation follows respect 
inspection proof shows serializations prefixes respect prefix means lim defined serialization shows sequentially consistent 
data race free programs concurrent write free programs run correctly causal memory form restricted class allow little concurrency 
section define practical class data race free programs show run correctly causal memory 
alternative definitions 
history causality order 
operations compete respect access location write concurrent respect 
data race free respect contains pair operations compete respect 
history data race free respect property writes location linearly ordered respect 
program pi data race free histories pi causality orders serialization respects note implies sequentially consistent data race free respect 
note data race freedom program statement sequentially consistent histories 
previous definitions data race free programs quite different 
definitions systems normal data operations reads writes special synchronization operations 
competing operations sequentially consistent execution data race free program separated kind causality synchronization operations 
hard see definition generalization systems need synchronization operations specified semantics 
sections give ways data race free programs definition may derived 
class data race free programs confused memory models drf drf 
theorem shows data race free programs produce sequentially consistent executions run causal memory theorem pi data race free histories pi causal memory sequentially consistent 
proof proof induction structure causal histories pi 
specifically finite causal history pi causality order proves causal 
proof infinite histories follows 
prove holds proper prefixes respect data race free respect serialization respects 
show data race free respect assume contradiction operations compete respect 
assume induction operation holds compete respect holds compete respect 
reads performed process different locations compete 
assume concurrent respect write performed operation performed define hl letting subsequence containing operations precede respect 
appears related done 
assume operation appears means includes operations including holds clearly proper prefix respect inductive hypothesis data race free respect serialization respects 
define fj kg 
necessarily proper prefix respect execution pi 
serialization respects 
prove serialization respects 
data race freedom pi imply compete respect giving desired contradiction 
write operations serialization respects 
assume read assumed write 
returns value writes serialization respects 
suppose returns different value 
possible cases ffl contains write returns value written write 
case serialization respects 
causal memory definitions implementation programming ffl contains write return value written write data race free respect writes totally ordered 
respects writes precede respect 
recall causal performed serialization respects 
writes precede return value written precede respects contains operations causally precede appears consider sub cases implies concurrent respect compete respect 
means contradicts assumption operation causally preceding competes respect 
implies contradicting fact concurrent respect 
case leads contradiction 
ffl contains writes writes causally precede operation return initial value 
case serialization respects 
shown non contradictory cases lead serializations respects 
history pi pi data race free data race free respect 
means compete respect giving desired contradiction 
show serialization respects 
finite acyclic choose operation hold 
excluding proper prefix respect inductive hypothesis serialization respects 
clearly respects respect operation contradicts definition prove serialization proving sequentially consistent 
assume contradiction serialization means read operation recall causal serialization respects 
possibilities ffl write writes precede respect write competes respect contradicting data race freedom respect follows respect contradicting definition 
writes precede latest write 
linearization writes value serialization write value data race free respect related possibilities respects means precedes contradicting definition means precede contradicting definition ffl write implies write 
serialization 
means serialization contradiction 
cases lead contradictions conclude serialization respects 
implies sequentially consistent 
theorem holds infinite causal history pi 
causality order proves causal 
prove data race free respect 
operations compete respect 
shortest prefix includes note causal causality order proves 
easy see finite data race free respect 
implies compete respect giving desired contradiction 
define infinite sequence finite prefixes respect having previous ones proper prefixes respect follows 
empty history 
includes plus operation operations precede respect appear operations chosen fairly operation appears 
construction operation follows respect 
inspection proof shows serializations prefixes respect prefix means lim defined serialization shows sequentially consistent 
theorem follows independently derived result singh 
classes data race free concurrent write free programs incomparable 
example consider concurrent write free program 
data race free 
execution reads writes operations concurrent compete 
hand data race free program concurrent write free 
iteration variables may written concurrently 
despite class data race free programs contains programs practical 
subsections demonstrate ways obtaining data race free programs 
sections require kind blocking programmer specified busy waiting second augmentation causal memory semaphores 
blocking eliminate advantages gained non blocking implementation causal memory 
blocking required kind synchronization data race free programs require programmer explicit synchronization 
advantage causal memory requires blocking explicit synchronization required 
require blocking ordinary memory operations 
causal memory definitions implementation programming complete changed shared variables initially done shared variable initially false shared variables initially shared constants local variables local converged external routine evaluates convergence process done await complete complete await changed done converged changed process done gamma gamma gamma complete await complete changed await changed synchronous iterative linear solver causal memory programs await statements common way synchronize processes actions blocking process desired condition true 
capture program model allow program specify action form await process histories denote blocks process desired condition true shared variable takes value implemented simple read actions follows repeat consider await single read appears local history time invoked preceding reads values 
writes order 
relates writes values read await completes 
hard see theorem continues apply await statements added model 
singh augments usual memory operations await operations 
programs await statements synchronize access shared variables 
example effect barrier synchronization control access certain data 
example 
example synchronous iterative linear equation solver solves ax known theta matrix known vector vector contain solution 
solver operates series phases phase process computes new value solution component 
represent value ith component phase new values computed follows gamma gamma gamma 
computing requires access previous iteration 
process computes 
process tests convergence synchronizes worker twice iteration barrier technique reading various phase writing phase 
making array shared having workers read alternately eliminate synchronization 
program easily shown correct sequential consistency 
hard see data race free 
access controlled complete changed 
suppose example reads kth iteration value st iteration value 
hard see causal chain exists writes order 
st iteration complete 
complete complete 
complete accesses compete similar arguments show competing accesses execution program program data race free 
theorem implies runs correctly causal memory 
fact runs faster causal memory sequential consistency 
program requires centralized coordinator exists fully distributed solution 
solution data race free runs correctly causal memory 
programs semaphores await statements allow barrier synchronization suffice implementing kinds synchronization critical sections 
recall await statements implemented spinning read 
shown mutual exclusion necessary implementing critical sections realized causal memory cooperation example peterson algorithm mutual exclusion run correctly causal memory 
mutual exclusion implemented special synchronization primitives semaphores 
semaphore variable holding non negative integer supports operations atomically increments value atomically decrements 
semaphore value zero operation blocked semaphore positive 
possible add semaphores definition causal memory call result extended causal memory 
note operation semaphore reads writes semaphore operation reads semaphore writes causal memory definitions implementation programming incremented value 
operations semaphore causally related meaning competing accesses semaphore 
implies execution extended causal memory operations semaphore appear order processes 
implementation extended causal memory require blocking scope 
hard see theorem applies extended causal memory 
semaphores useful synchronization 
example program modified semaphores 
arrays complete changed semaphores write array element operation await statement operation 
program remains correct data race free 
semaphores implement critical sections 
critical section associated semaphore initial value 
process invokes semaphore entering critical section invokes semaphore leaving 
researchers considered different programming models correctness programs models memories weaker sequential consistency 
gibbons merritt gharachorloo considered dash system version release consistency 
mixed memory model allows programmers specify label operations weak strong 
case strong operations sequentially consistent weak operations ordered invoked relative strong operations 
program properly labeled data races weak operations 
gibbons showed run properly labeled programs admit sequentially consistent executions 
attiya showed similar result different mixed memory model called hybrid consistency 
proved sequentially consistent executions obtained writes reads labeled strong 
results contrast require memory model allows strong sequentially consistent operations section 
singh independently considered programming models purely weak consistency models causal memory 
classifies programs types executions permit weaker form memory 
differs classify programs execute sequentially consistency prove properties execution causal memory 
believe potentially productive approach easier programmers reason behavior programs sequential consistency 
sinha considered variety weaker forms memory including slow memory 
showed programs class totally asynchronous iterative algorithms run correctly slow memory causal memory note class synchronous iterative algorithms broader class programs run correctly slow memory 
programs data race free gives example run correctly causal memory 
discussion new model distributed shared memory called causal memory 
defined formally simple framework allows compared easily memory models 
exhibited message implementation causal memory 
formally characterized classes programs run correctly causal memory assuming sequential consistency 
formal analysis shows causal memory lie sequential consistency strong memory pram weak 
suggests may powerful program easily strong memories time allow inexpensive implementations weak memories 
borne results sections 
implementation causal memory non blocking process complete read write operation immediately having communicate processes 
communication take place background memory accesses 
important note implementation definition causal memory lies sequential consistency pram allows histories sequentially consistent pram histories causal 
section shows concurrent write free data race free programs run correctly causal memory 
programs data accesses controlled explicit synchronization 
synchronization necessary distributed programs designed run sequentially consistent memory 
example synchronization program necessary stronger memories program runs correctly causal memory 
requiring programmer explicitly specify synchronization needed allow form memory implemented efficiently 
facts show causal memory potential important model distributed shared memory systems 
realize potential currently exploring implementations causal memory actual distributed systems 
practical theoretically motivated implementation section basing communication entire pages single variables see discussion section 
plan benchmark implementations better compare causal memory intermediate memory models 
greatly helped development section discussions singh 
dr singh kumar provided comments earlier versions 
sarita adve mark hill 
weak ordering new definition 
proceedings seventeenth annual international symposium computer architecture pages causal memory definitions implementation programming may 
sarita adve mark hill 
unified formalization shared memory models 
ieee transactions parallel distributed systems june 
yehuda afek geoffrey brown michael merritt 
lazy caching 
acm transactions programming languages systems january 
ahamad john prince gil 
power processor consistency 
proceedings fifth symposium parallel algorithms architectures pages 
acm press june 
full version appears technical report college computing georgia institute technology 
ahamad james burns phillip gil 
causal memory 
toueg spirakis editors proceedings fifth international workshop distributed algorithms volume lecture notes computer science pages 
springer verlag october 
revised expanded version exists 
ahamad phillip john 
implementing programming causal distributed shared memory 
proceedings eleventh international conference distributed computing pages may 
ahamad gil prince james burns phillip 
causal memory definitions implementation programming 
technical report college computing georgia institute technology september 
submitted publication 
attiya soma chaudhuri roy friedman jennifer welch 
shared memory consistency conditions non sequential execution definitions programming strategies 
proceedings fifth symposium parallel algorithms architectures pages 
acm press june 
attiya roy friedman 
correctness condition high performance multiprocessors 
proceedings fourth acm symposium theory computing pages 
acm press may 
attiya jennifer welch 
sequential consistency versus linearizability 
acm transactions computer systems may 
bennett carter zwaenepoel 
adaptive software cache management distributed shared memory architectures 
proceedings seventeenth annual international symposium computer architecture may 
dimitri bertsekas john tsitsiklis 
parallel distributed computation numerical methods 
prentice hall englewood cliffs new jersey 
kenneth birman andre schiper pat stephenson 
lightweight causal atomic group multicast 
acm transactions computer systems august 
colin 
logical time distributed computing systems 
computer august 
roy friedman 
personal communication 
kourosh gharachorloo daniel lenoski james laudon phillip gibbons anoop gupta john hennessy 
memory consistency event ordering scalable shared memory multiprocessors 
proceedings seventeenth international symposium computer architecture pages may 
phillip gibbons michael merritt kourosh gharachorloo 
proving sequential consistency high performance shared memories 
proceedings third symposium parallel algorithms architectures pages 
acm press july 
james goodman 
cache consistency sequential consistency 
technical report ieee scalable coherent interface working group march 
sinha 
computing non coherent shared memory 
technical report computer science department boston university june 
maurice herlihy jeannette wing 
linearizability correctness condition concurrent objects 
acm transactions programming languages systems july 
phillip ahamad 
slow memory weakening consistency enhance concurrency distributed shared memories 
proceedings tenth international conference distributed computing systems may 
complete version appears technical report school information computer science georgia institute technology 
john 
implementing programming weakly consistent memories 
ph dissertation georgia institute technology 
john ahamad 
implementation evaluation causal memory data race free programs 
technical report college computing georgia institute technology july 
kessler livny 
analysis distributed shared memory algorithms 
proceedings ninth international conference distributed computing pages june 
prince gil ahamad 
characterization scalable shared memories 
proceedings second international conference parallel processing pages august 
leslie lamport 
time clocks ordering events distributed system 
communications acm july 
causal memory definitions implementation programming leslie lamport 
multiprocessor computer correct executes multiprocess programs 
ieee transactions computers september 
leslie lamport 
interprocess communication part basic formalism 
distributed computing 
richard lipton jonathan sandberg 
pram scalable shared memory 
technical report department computer science princeton university september 
mattern 
virtual time global states distributed systems 
michel cosnard patrice yves robert michel raynal editors proceedings international workshop parallel distributed algorithms pages 
northholland october 
dan roth 
sequential consistency linearizability read write objects 
proceedings ninth annual allerton conference communication control computing pages october 
revised version appears technical report aiken computation laboratory harvard university june title linearizable read write objects 
dan roth 
efficient strongly consistent implementations shared memory 
segall editors proceedings sixth international workshop distributed algorithms number lecture notes computer science pages 
springer verlag november 
misra 
axioms memory access asynchronous hardware systems 
acm transactions programming languages systems january 
gary peterson 
myths mutual exclusion problem 
information processing letters june 
singh 
framework programming non atomic variables 
proceedings eighth international parallel processing symposium pages 
ieee computer society press april 
