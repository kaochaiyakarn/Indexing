reflection logic functional object oriented programming short comparative study fran cois nicola demers jacques malenfant epartement informatique de recherche op universit de montr eal montr eal qu ebec canada reflection wide ranging concept studied independently different areas science general computer science particular 
sub area programming languages applied different paradigms especially logic functional objectoriented ones 
partly different past influences researchers communities scarcely talk concepts evolved separately point hard people community recognize similarities speak cross fertilization 
propose synthesis covering mainly application computation reflection programming languages 
compare different approaches try identify similar concepts hidden different names constructs 
point different emphasis different concepts 
claim completeness closeness treatment 
aim building bridges programming languages communities address aspects appear relevant 
reflection long studied philosophy formalized extent logic fef 
naturally artificial intelligence intimately linked goal reflection viewed emergent property responsible part considered intelligent behavior 
surprisingly applied area programming languages name computational reflection 
computational reflection dates brian smith seminal early smi smi 
way formalize concept reflection developed languages lisp lisp 
smith gave attention representation relation called oe computational process bears subject domain quickly famous functional community ability lisp giving program reflect computation reflective towers 
approach inspired functional programming community late probably reflection growing fertile ground 
quote construct lisp famous metalinguistic power 
allowed manipulation execution program fragments primitive authors current address centre ville montr eal qu ebec canada phone fax mail iro umontreal ca research supported fcar qu ebec nserc canada 
tation reflective concepts 
lisp interpreters widely explored debated 
lisp community long experience kind things reflection wanted enable 
quite clear order master inherent complexity fully reflective programming language structuring mechanisms badly needed 
object oriented paradigm imposed take challenge 
trend completely innocent 
subset object oriented community profoundly influenced lisp especially revolving smalltalk naturally object oriented extensions lisp common lisp object system clos 
fact persons oo community influential lisp decade 
implementation original concepts new paradigm prove different difficult relate functional ones 
unsurprisingly smalltalk reflective language object tothe bottom principle unfortunately ignoring meant reflective 
exposes object system metaobject protocol clos achieved 
quite independently logic programming community interested concepts near reflective ones especially metaprogramming 
lisp prolog included implementations mechanisms manipulation programs run time enabling metaprogramming metavariables transform term goal play role apply clauses accessible system predicate clause speak debated assert retract returns form terms inspectable system predicates arg functor 
metaprogramming quickly common prolog self respecting textbook includes called vanilla meta interpreter prolog written clauses see example ss 
series conferences devoted exclusively metaprogramming logic organized ar bru pet met 
new language godel hl designed aim making metaprogramming declarative implementing manipulation terms ground representation 
development reflective concepts independently different programming paradigms difficult understand relationship similar ones expressed different ways community community language language 
goal compare contrast reflective languages generally results coming communities 
claim address aspects comparison short build bridges communities sharing experience involved years 
don concentrate computational reflection programming languages address relevant goal 
rest organized follows 
section introduces terminology concepts computational reflection 
section presents design reflective languages paradigms logic functional object oriented programming 
section discusses formal notions associated computational reflection notion reflection coming logic attempts give formal semantics reflective programming languages 
draw 
terminology basic concepts long time terminology basic concepts heel computational reflection 
noted earlier actual implementation reflection programming languages uses lot techniques mechanisms existed long time reflection ability manipulate programs run time data ability inspect data structures run time terms prolog class entities metaprogramming past years seen tendency mix reflection techniques 
sense tools taken concept 
link certainly exists class higher order functions metaprogramming reflection stands 
reflection defined fairly general way brian smith ecoop oopsla workshop reflection entity integral ability represent operate deal self way represents operates deals primary subject matter 
programming languages incarnation definition appears follows bgw reflection ability program manipulate data representing state program execution 
aspects manipulation introspection 
introspection ability program observe reason state 
ability program modify execution state alter interpretation meaning 
aspects require mechanism encoding execution state data providing encoding called reification 
reification distinguished class entities 
entity class language means entity created run time passed actual parameters procedures returned result function stored variable 
needed provide programs values suitable data type defined language 
functional languages functions firstclass example 
means functions closures values manipulated values language 
reification goes imposing complete control value language 
particular able modify representation language 
able inspect run time 
making entity class strictly included reification opposite 
coming back reflection pattie maes gave thesis mae definitions summarize pretty notion reflection computational systems ffl computational system reasons acts part world called domain system 
ffl computational system causally connected domain 
means system domain linked way changes leads effect 
ffl meta system computational system domain computational system called 
meta system representation object system data 
program specifies metacomputation object system called meta program 
ffl reflection process reasoning acting oneself 
ffl reflective system causally connected meta system object system 
system reasoning acting speak reflective computation 
meta interpreters intensively implementation reflective systems metaprogramming reflection 
note reflection accessing metalevel representation done purpose perform task 
metaprogramming approach gives programmer access representation hand meta interpreter change perform task originally intending 
reflection goes way 
implementation pre exist access program reflection 
metaprogramming played important role implementation reflective languages practice difficult access metalevel information existing language typically implementation completely sealed 
meta interpreter interesting easier data available programs runs modifying language implementation 
maes said mae main difference metalevel architecture reflective architecture metalevel architecture provides static access representation computational system reflective architecture provides dynamic access representation 
kind change metaprogramming approach modify meta interpreter prior execution program 
reflection hand allows program change behavior execution depending current execution inputs intermediate results 
computational reflection distinction traditionally structural behavioral reflection 
concepts defined follows ffl structural reflection implies ability language provide complete reification program currently executed complete reification data types ffl behavioral reflection implies ability language provide complete reification semantics processor complete reification data uses execute current program 
language providing lists adt structural reflection calls providing programs complete reification implementation list adt internal representation operations modified 
distinction mainly simpler implement structural reflection efficiently behavioral reflection 
instance languages lisp prolog included structural reflection features years 
accordingly behavioral reflection main focus today research 
design reflective programming languages functional programming lisp quote lisp enjoyed powerful metalinguistic facility quoting mechanism 
quote introduces simple metalevel designation reified expressions data representation expression designator 
data representation returned quote quoted object time list fundamental adt lisp inspectable mutable run time usual list primitives 
quote responsible ability lisp program manipulate expressions data sure data executed quick decoding making true lisp expression quoted representation 
decoding automatically done eval function 
behavior considered anomalous mul difficult manipulate reified expressions 
smith invented computational reflection implemented lisp aware problem 
proposed lisp address issues related structural reflection representation relationship computational process subject domain 
crucial lisp clearly distinguishes levels designation metalevel data representation base level code representation 
lisp automatic decoding appears evaluation process 
primitives help mediate hierarchy mean remove quotes 
muller mul proposed lisp similar motivation 
lisp claimed simpler lisp 
lisp behavioral reflection lisp solution self complicated muller smith famous second language lisp implemented collaboration des rivi eres drs introduced computational reflection 
goal lisp give programs ability reason modify computation represented expression environment continuation 
reflective system proposed lisp described follows ffl reflective tower constructed stacking virtually infinite number meta circular interpreters executing bottom level executing user program level 
ffl reflective computations initiated calling reflective procedures procedures parameters invocation reflective procedure passed argument structure current expression invocation current environment current continuation 
reflective tower needed overcome known problem introspective overlap reflective procedure passed current environment continuation execution modifies data 
lisp solution execute reflective procedure code program code interpreter 
reflective procedure invoked level executed current arguments environment continuation level manipulated level meta interpreter meta interpreter level 
reflective procedure call reflective procedure potentially need infinite number levels reflective tower 
practice way exists formed recursions individual execution need finite number recursive calls formed reflective program need finite number tower levels runs 
worth notice smith called lisp procedurally reflective language 
smith mind word procedural reflection stands systems strict implementation relationship object system metalevel 
approach possible reflection general choice reflective languages 
metalevel data structures run object level causal connection essential reflection comes free object level metalevel representation evolve perfect synchronization 
important aspect lisp implementation avoids actual levels meta shifting level processor drs 
implementation extremely operational words friedman wand ones wf non reflective description reflective tower 
lisp followup series papers fw wf wf friedman wand undertook task implementing kind behavioral reflection offered lisp resorting reflective tower 
idea led mini language called brown featuring reflective procedures access reification program run time data structure expression environment continuation inverse operation called reflection reified data structures interpreter 
hand brown successors completely avoided representation designation issues raised lisp 
brown turned implement subset reflective capability exhibited lisp didn need resort towers 
challenged smith extend techniques tower friedman wand proposed second third denotational account reflective towers 
salient feature new brown models reflective tower unique interpreter active time property danvy called dm 
context metacontinuation thought list continuations state interpreter currently active 
brown defines reification act calling reflective procedures receives reification current arguments environment continuation actuals 
defines reflection act expression environment continuation interpreter level tower 
piece code reflect new interpreter spawn initial state state currently executing pushed metacontinuation 
interpreter invokes reflective procedure thunk built reflective procedures passed metacontinuation run level higher tower 
hand interpreter returns continuation metacontinuation restored restarted point stopped lower spawned 
brown experience gave reflection community insights computational reflection failed reach goal give denotational account reflection way explain section 
friedman wand danvy pursued proposed language blond dm 
blond similar brown specific aspects 
brown turned flawed treatment environments problem solved blond 
blond distinction calls continuations management 
languages contributed school reflection stepper ir jf black amy 
logic programming different issues earlier esp studied logic programming different names 
look new 
logic programming structural reflection introduced 
main concern time facilitate problem managing system database clauses 
predicates clause assert retract call examples procedures prolog structural reflection goals clauses treated class objects represented terms 
computational reflection studied respect conceptual basis logic programming logic programs theories execution deduction 
need ability explicitly refer theories leading structural reflection discuss derivability theories leading computational reflection 
main approach construct system object level logic system metalanguage suitable formalizing derivability relation original object language system 
resulting system expressive problem solving power original object language system 
said bow similarly amalgamation languages consists 
naming relation similar quote mechanism functional programming associates expression variable free term relation constitutes causal connection needed reflective systems 

representation derivability relation means predicate symbol demo context sentences th 
rules called reflection principles fef bow called downward upward reflection lmn respectively th demo th demo reflective system respects particularities said amalgamating language bow dem 
reflective systems created way called amalgamating systems bow reflective prolog cl different prolog languages dem systems concerned mainly representation predicate demo earlier 
amalgamating systems relatively inefficient meta programming techniques 
reason people tried create non amalgamating ones 
powerful preceding ones predicate demo entirely explicitly represented th integrate reflective mechanisms useful certains logical applications 
examples non amalgamating systems fol prolog sug cpu lmn alpes bcl 
systems tried especially resolve practically problems related logical representation goals clauses variables 
quote mechanism said earlier reflective systems quote mechanism essential 
naming relation implemented different ways different power 
natural implementation represent reflective objects logical terms language 
technique prolog implementation expects object level variables represented meta level variables 
representation said non ground 
language godel hl ground representation object level variables represented ground logical terms preferred quote mechanism completely uniform meta objects terms powerful 
quote mechanism reflective systems bowen similar language gcp chr said reflective reflective features set prolog languages 
ground representation efficient demo definition substitution procedure simulated process time space 
reason reflective languages uses quote mechanism powerful efficient example non ground representation case systems prolog uses lists meta level representation reflective objects reflective prolog cpu alpes simple prolog languages 
languages quote mechanism create explicit distinction types objectlevel terms meta level terms 
case languages prolog prolog languages 
distinction similar way godel terms statically typed considering term representing object level variables special unique 
reflective mechanism noted reflective languages explicit reflective mechanism reflective procedures 
procedures called reflective predicates prolog prolog specified explicitly program goals 
predicates said written different reflective languages different degrees reification reifies objectlevel program clauses possibly demo reifies substitutions unification reifies resolvent prolog reifies different previous structures implements infinite reflective tower lisp 
near hl efficient concurrency partial evaluation gal reflective contain definition explicit upward downward reflection specific predicates creating causal connection access reflective structures 
case languages cpu alpes 
language reflective prolog cl uses implicit reflective mechanism defining reflective operations metalevel definitions care reflective calls extended resolution procedure 
reification reflection issue important reflective languages causal connection 
logic programming mechanism implemented different ways special predicates specific parameters reflective predicates 
creates indirect causal connection direct 
indirect causal connection directions usually reflective information different time execution 
direct moment 
logical reflective languages indirect causal connection easier implement 
example cpu lmn reflection mechanism triggers computation object level meta level domain upward reflection vice versa downward reflection 
note functional world operations called reification reflection respectively fw 
usually executed time done virtually upward reflection read reflective structures execution downward reflection write back 
comparable indirect causal connection mechanisms alpes reflective prolog 
way indirect causal connection compared reflection reification mechanisms functional programming 
direct causal connection prolog different languages prolog 
works follows reflective predicates receive additional parameters containing different reflective information additional parameters represent reflective information modification reflective predicates execution 
object oriented programming major trends single history object oriented programming 
simula eiffel beta shaped software engineering modularity principles 
led typed languages characterized relatively rigid object model alien reflective concepts 
second trend born world untyped partly structurally reflective languages 
led flexible languages classes typically treated class entities 
trend smalltalk object oriented extensions lisp flavors loops clos 
second trend playing major role reflection 
structural reflection oop evolution flexible object oriented languages marked quest right metaclass class instance model led full notion structural reflection concerns object model language 
summary history stands follows 
smalltalk included idea object class 
class introduces structural reflection sense describes structure object 
smalltalk classes class entities considered instances 
including inheritance smalltalk introduced metaclasses classes classes 
note oop object class called instantiation class 
object smalltalk class instantiation class called metaclass 
smalltalk pursued idea imposed important limits metaclasses coi ffl metaclasses names treated system way hide possible user 
ffl metaclasses instances class metaclass number fixed created indefinitely loops bkk propose meta architecture similar smalltalk allows metaclasses created explicitly 
hand metaclasses distinct classes maximum number fixed 
model coi proposed unify metaclasses classes allow indefinite number created 
difference classes metaclasses instances instances classes 
model minimal classes object class 
solves potential infinite making class instance 
model applied object system written lisp applied scheme smalltalk bc object oriented extension prolog 
full reflection object bottom principle smalltalk design principle basic reflection expressed terms language 
hand smalltalk designed aim making organization manifest language people modify goal pursued reflection 
reflection obvious static description language terms classes objects necessary properly organize things enable full fledged reflective programming paradigm 
need manifest description protocols activating different objects order execute program 
metaobject protocol clos krb tries achieve exactly 
describe objects involved representation computational process exhibits protocols responsible actual execution program 
behavioral reflection oop seen behavioral reflection model allow programs intervene current execution order execute reflective code analyse modify course events 
functional programming lisp invented reflective procedures 
vantage points program reflect lisp procedure invocation 
oop procedure invocation traded message passing 
natural message passing vantage points reflect methods represent reflective code 
execution message divided phases lookup phase find method corresponds message selector apply phase executes method 
behavioral reflection oop implemented mainly giving user control message passing mechanisms 
done different ways ffl traditional oop languages smalltalk message passing mechanisms reified lookup apply method 
methods typically held meta object linked object 
message sent object transformed sequence messages lookup message sent meta object yields method apply message sent invoke 
reflective code implemented creating subclasses standard meta objects redefining lookup method creating subclasses standard class describing methods redefining apply method 
ffl oop languages notion generic function clos behavioral reflection introduced reifying generic function invocation protocol making apply generic function generic function 
reflective code implemented defining subclasses standard class describing generic functions redefining method apply generic function new classes 
comparison initiate comparison current application reflection functional logic objectoriented programming languages 
structural reflection structural reflection functional logic programming concentrated issues quoting amalgamation language metalanguage 
lisp amalgamating language sense bowen bow requires explicit representation language processor 
lisp quote construct language metalanguage uses term base language represent metalevel albeit quoted form 
smith lisp muller lisp focused non amalgamating representations distinguishing levels designation mediated explicit conversion operations 
logic programming amalgamation intimately linked problem logic variables 
amalgamation deduction metalevel fragile 
language allows terms looked prevent metalevel unifying base level variables metalevel terms result absurd deduction paradoxes see 
rule eventuality languages adopted type system prevents inappropriate mixing metalevel base level entities 
worth noticing quoting converting lisp lisp acts piece code translated metalevel representation 
metalevel representation may inspected modified translated back base level code 
time particular piece code exists representation base level metalevel 
need causal connection link different representation 
functional programming manipulation functions list abandoned long time ago 
prolog manipulation interpreted code important pragmatic impact representation time exists 
modification clause program term modifies connection actual program new clause 
oop structural reflection dominated quest complete minimal metalevel model represent instances classes metaclasses 
classes reason structure instances distinct representation instance refered metalevel 
sense oop language metalanguage 
quote construct lisp associated lists represent base level term corresponds object identity class call entity 
smalltalk having access list instance variables declared class allows program access object vector compute index instance variable send object messages put 
having representations different protocol access information standard base level usually encapsulates state object metalevel sees object vector values compared quote construct oop provides points view base meta piece information obviously causally connected 
oop languages smalltalk clos included extensive representation programs objects 
smalltalk methods represented instances class 
objects store source code bytecode representation 
source code easily accessible browser uses directly instance stores pointer source file corresponding method defined 
note change previously compiled method explicitly recompiled taken account smalltalk causal connection textual representation bytecode representation 
causal connection bytecode representation physical processor code run smalltalk different story goes 
clos follows similar patterns generic functions methods implemented clos objects 
behavioral reflection behavioral reflection divided access language processor hand access actual data run program hand 
look issues turn 
ideally reflective languages provide programs complete reification language processor 
representation processor terms language modified program adapted execution 
ideal tried languages paradigms great success mainly lack efficiency lack suitable implementation techniques render efficient 
example lisp reify processor 
functional successors essentially followed trend object oriented ones attempts reification apply methods 
logic programming hand reification derivability relation focus works 
mainly efficiency reasons 
people making language godel reifies full derivability relation hl efficient prolog partial evaluation parallel implementation techniques 
unfortunately achieved 
admittedly making language processor fully accessible formidable challenge current implementation technology 
interesting approach explored provide users open compiler introduce modifications language semantics 
approach similar properties metaprogramming approach modifications done program execution depend current inputs intermediate results 
smalltalk compiler part program run time system theoretically possible recompile part program run time obviating previous 
languages proposed powerful model behavioral reflection giving programs access processor run time data 
functional programming lisp popularized reification standard functional processor registers containing current expression argument structure environment continuation 
reflective procedure passed informations invocation 
reflective procedures weaker means modify language processors semantics viewed inserting new lines code processor 
kind approach tried successfully logic programming paradigm 
technique called earlier direct causal connection 
alternatives tried far pair opposite operations reification reflection concerned 
automatic pairing consists reflective procedure receiving run time data parameters automatically reflective procedure returns control interpreter 
technique tried paradigm logic functional programming 
alternative manual called earlier indirect causal connection 
technique logical world 
point concerns presence absence reflective towers object oriented behavioral reflection 
lisp obvious reflective towers involved forms behavioral reflection currently implemented oop languages 
interestingly des rivi eres dr shown clos mop includes fact reflective tower hidden reification generic function invocation protocol 
little malenfant mdc shown similar result languages traditional lookup reflective protocol give rise reflective towers 
reflective towers intimately linked current model behavioral reflection matter underlying programming paradigm 
methodology reflective computation ideally reflective language support methodology reflective computation giving users flexibility possible 
possible modify behavior construct execution program short period execution time 
possible modify behavior construct program subparts 
language currently proposed achieves level flexibility 
functional programming logic programming main efforts reflective procedure called point computation 
reflective computation base level restarted new state resulting reflective computation 
meta interpreters towers stay unchanged execution 
result kind reflective computation models restricted intervention execution 
prolog dem notable exception allows program specify reflective predicates called repeatedly having explicitly insert calls program code 
repeated reflective predicate called reduction prolog metalevel solver 
language reflective procedures considered kind behavior 
oop main efforts local reflection 
lookup approach lookup methods redefined locally objects apply methods redefined locally methods 
similarly reified generic function approach invocation protocol changed locally generic function way 
result kind reflective computation restricted awkward change aspect implementation objects 
open research problem decide scope change lookup apply methods reflective computation general fer 
attached individual objects classes apply instances metaclasses apply instances class instances individual messages apply call 
noted previously ideal complete reification language processor stayed reach mainly efficiency reasons 
consequently modifications spawning program execution difficult implement 
reified compiler approach possible modify semantics language construct basis 
experiences reported 
formal notions reflection discuss formal notions characterize reflection programming languages different paradigm preceded historical discussion reflection logic freely inspired bow fef cos 
historical discussion gottlieb frege developed formal quantificational logic period decades culminating 
idea universal language logic 
frege object properties may objects reasoned way basic rules notations 
frege certain comprehension axioms specifically created object notations stated sentences properties predicates equivalently rephrased properties objects 
axioms effect state relationship name names equivalently closer frege notation 
year bertrand russell showed frege system inconsistent 
russell proposed objects arranged hierarchy different notations rules avoiding possibility self led inconsistency frege system 
resulting typed analogy notion reflective tower way avoid inconsistency programming languages level notations precisely frege damaging axioms created objects properties level 
russell properties objects viewed second level objects 
reason refer order logic higher order log ics 
know significant concepts expressed levels 
original simplicity plausibility frege approach continued attract interest modern logic motivated efforts revise preserve desirable features removing inconsistency 
needed avoidance separated levels altogether concepts treated level 
fact appears reasonable allow certain number levels collapsed order logic leave rest 
desirable collapse levels order logic just causes russell paradox 
main problem addressed logic need find way collapse levels contradiction need self referential universal language 
said quotation necessarily involved point self describing language treat logical terms sort class entities 
way reflective notions ones going back famous godel incompleteness theorems mathematical logic introduced related symbolic logic sixties 
main idea concerned reflection principles mentioned earlier 
concept reflection principle introduced feferman fef intended description procedure adding set axioms certain new axioms validity follows validity axioms formally express language evident consequences assumption theorems valid 
kre different reflection principles discussed establishing complexity different axiomatic systems 
particular kreisel says turning uses reflection principles recall literature 
system recognized sound reflection principles provide systematic method constructing stronger systems 
second provide method comparing strength formal systems 
logic computation pragmatic form reflection principles different naming mechanism proposed weyhrauch bow 
discussed reflective principles 
practice approach leads explicit reflection explicit calls demo appear clauses specify goal attempted metalevel 
results remind clearly need meta programming facilities objectlevel meta level languages 
perlis theory quotation refer certain statements true false 
author concentrates importance roles truth self commonsense reasoning 
article showed modal logics ground order ones equally endowed substitutive self 
tried understand relationship self modal logic 
declarative semantics logical style attempts formalize reflection close classical horn clause language semantics llo 
cos declarative procedural semantics reflective prolog cl basis naming mechanism allows representation terms atomic formulas different languages reflection procedurally semantically 
declarative semantics defined model theoretic fashion providing model semantics definition concept reflective herbrand model theory 
reflective herbrand model characterized fixpoint suitable mapping order provide link declarative procedural semantics program 
derivation resolution extended include forms implicit reflection shift levels 
extended resolution proved sound complete respect reflective herbrand model program 
sug declarative semantics prolog discussed 
computational reflection sort procedural notion usual declarative semantics logical consequence programs adopted 
order incorporate procedural aspect reflective computation notion interpretations models extended equivalence classes syntactic objects 
prove soundness completeness refutation mechanism respect declarative semantics defined 
reflective operations prolog lead somewhat dangerous situations studied semantically 
chr declarative semantics meta programming language called gcp concerned proposed 
language say offering computational reflection structural reflection kind ground representation explicitly compared bow 
development semantics quite traditional llo herbrand interpretations defined said concerned goals 
similar analysis meta programs hl hl 
semantics functional style section friedman wand development different versions brown response lisp 
fact mentioned earlier wand friedman tried settle denotational account reflective towers fw culminated wf 
smith defended long time denotational framework right tool approach problem 
essentially argued denotational semantics forcing distinction levels designation disappear essence reflection final word came observation compositionality principle denotational semantics impaired reflection dm 
denotational semantics approach helpful understand nature reflection fully express semantics 
new approaches sought reach goal 
rewriting systems friedman mendhekar mf malenfant mdc independently applied theory rewrite systems encouraging results 
goal friedman mendhekar develop programming logic reflective languages 
introduce reflective extension calculus provide simple operational semantics reflective operations underlying rewrite systems 
get reflective language includes infinite tower model similar described smith 
equational logic semantics developped 
resulting logic shown weak reflective properties 
malenfant dony cointe formalized reflective protocol theory priority rewrite systems 
systems rewrite rule assigned priority reduction process rules applicable reduction redex higher priority effectively 
authors exhibited mapping applied message sending point transforms reflective object oriented program rewrite system shown terminating 
theory applies reflective protocol rest computation method execution complete rewriting semantics envisaged 
new promising approaches years categorical approach gained considerable acceptance especially lazy functional programming world 
originally proposed moggi convenient framework structuring semantics languages mog mog popularized wadler wad wad technique structuring functional programs :10.1.1.41.840
fact monads give semantics various computational effects state exceptions applicative programming languages 
possible give monadic semantics computational reflection filinski fil says correspondence principle embodied introspective language extension called monadic reflection analogy computational reflection operators gamma ff gamma ff gamma ff gamma ff ff reflects value effectful computation type ff 
conversely general computation ff reifies corresponding effect free value type ff 
note operators mentioned quite comparable reflection principles exposed earlier section logic programming 
lot research introduce new formal calculi categorical semantics 
mog said logical approach express new compared commun operational denotational approach gives consequence relation ax iff formula true models set formulas ax deal different programming languages functional imperative non deterministic uniform way simply changing set axioms ax possibly extending language new constants :10.1.1.41.840:10.1.1.41.840
tendency logical approach categorical notions quite promising study programming languages particularly computational reflection people hd tried reason new logical frame proposed moggi mog say lines corroborates way idea monads model computational reflection :10.1.1.41.840
moggi framework provide solid basis studying relation implicit explicit representations control relation implicit explicit representations state typed setting 
research done find right relation monadic reflection computational reflection 
cartwright felleisen cf introduce new format denotational language specifications extended direct semantics accommodates orthogonal extensions reflective mechanism language changing denotations existing phrases 
clear new approach formalize reflective languages 
research done 
described different approaches reflection major programming paradigms logic functional object oriented programming 
compared pointed similarities fundamental differences 
defined main concepts computational reflection historical development idea reflection logic attempts formalizing concept reflection 
hope comparison albeit incomplete help building bridges different research communities 
encourages share respective accomplishments order cross fertilize goal fully achieved 
amy asai matsuoka yonezawa 
duplication partial evaluation implement reflective languages 
ar abramson rogers eds 
metaprogramming logic programming 
mit press 
bawden 
reification evaluation 
proc 
acm fp pages 
bc 
briot cointe 
explicit metaclasses smalltalk 
proc 
oopsla acm sigplan oct 
bcl lamma mello russo 
flexibility efficiency prolog programming environment exploiting metaprogramming partial evaluation 
proc 
th esprit conf brussels 
bgw bobrow gabriel white 
clos context shape design space 
paepcke editor object oriented programming clos perspective chapter 
mit press 
bkk bobrow kahn kiczales masinter stefik 
merging lisp object oriented programming 
proc 
oopsla acm sigplan nov 
bow bowen 
logic programming chapter amalgamating language metalanguage logic programming 
academic press 
bow bowen 
meta level programming knowledge representation 
new generation computing 
bru bruynooghe editor 
proceedings second workshop meta programming logic 
leuven department comp 
sc april 
cf cartwright felleisen 
extensible denotational language 
proc 
tacs vol 

springer verlag april 
chr christiansen 
declarative semantics metaprogramming language 
bru pages april 
cl costantini 
metalogic programming language 
proc 
th int 
conference logic prog 
workshop 
coi cointe 
metaclasses class model 
proc 
oopsla acm sigplan dec 
cos costantini 
semantics metalogic programming language 
int 
journal foundations computer science 
dem 
demers 
de comportement evaluation en prolog 
master thesis de montr eal 
tech 
report 
dm danvy 
intensions extensions reflective tower 
proc 
acm fp pages 
dr des rivi eres 
secret tower clos 

drs des rivi eres smith 
implementation procedurally reflective languages 
proc 
acm fp pages 
fef feferman 
transfinite recursive progressions axiomatic theories 
journal symbolic logic 
fer ferber 
computational reflection class object oriented languages 
proc 
oopsla acm sigplan oct 
fil filinski 
representing monads 
proc 
acm popl pages 
fw friedman wand 
reification reflection metaphysics 
proc 
acm fp pages 
gal gallagher 
tutorial specialisation logic programs 
proc 
pepm pages june 
gabriel white bobrow 
clos integrating object oriented functional programming 
comm 
acm 
hd hatcliff danvy 
generic account continuation passing styles 
proc 
acm popl pages 
hl hill lloyd 
analysis metaprograms 
ar 
hl hill lloyd 
godel programming language 
mit press 
jf jefferson friedman 
simple reflective interpreter 
ys pages 
krb kiczales des rivi eres bobrow 
art metaobject protocol 
mit press 
kre kreisel 
reflection principles establishing complexity axiomatic systems 
zeitschrift fur mathematische logik und grundlagen der mathematik vol 
pages 

lamping kiczales rodriguez ruf 
architecture open compiler 
ys pages 
llo lloyd 
foundations logic programming nd edition 
springer verlag 
lmn lamma mello 
reflection mechanisms combining prolog databases 
software practice experience pages 
mae maes 
computational reflection 
phd thesis vrije universiteit brussel 
mdc malenfant dony cointe 
semantics introspection reflective prototype language 
appear lisp symbolic computation 
met proc 
fourth workshop meta programming logic 
springer verlag lncs 
mf mendhekar friedman 
theory reflective programming languages 

malenfant lapalme 
metaclasses logic 
proc 
ecoop pages 
cambridge press july 
malenfant lapalme 
metaclasses metaprogramming logic 
bru pages april 
mn maes nardi editors 
meta level architectures reflection 
north holland 
mog moggi :10.1.1.41.840
notions computation monads 
information computation 
mog moggi 
computational lambda calculus monads 
proc 
lics 
mul muller 
lisp representation independent dialect lisp reduction semantics 
acm toplas oct 
perlis 
languages self foundations order logic 
artificial intelligence 
perlis 
languages self ii knowledge belief modality 
artificial intelligence 
pet editor 
proceedings third workshop meta programming logic 
springerverlag lncs april 
smi smith 
reflection semantics procedural language 
tech 
report mit 
smi smith 
reflection semantics lisp 
proc 
acm popl pages 
ss sterling shapiro 
art prolog 
mit press 
sug 
meta reflective computation logic programs semantics 
bru 
wad wadler 
comprehending monads 
proc 
acm fp pages 
wad wadler 
essence functional programming 
proc 
acm popl pages 
weyhrauch 
prolegomena theory mechanized formal reasoning 
artificial intelligence 
wf wand friedman 
mystery tower revealed non reflective description reflective tower 
proc 
acm fp 
wf wand friedman 
mystery tower revealed description reflective tower 
lisp symbolic computation 
proc 
workshop reflection metalevel architectures object oriented programming oopsla ecoop oct 
proc 
second workshop reflection metalevel architectures object oriented programming oopsla oct 
proc 
third workshop reflection metalevel architectures object oriented programming oopsla oct 
ys yonezawa smith editors 
proc 
international workshop new models software architecture reflection meta level architecture nov 
