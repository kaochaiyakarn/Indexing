data categories barry jay school computing sciences university technology sydney box broadway nsw australia cbj socs uts edu au data categories functors strong natural transformations provide universe model parametric polymorphism 
data functors distinguished decomposable shape data represent types store data 
strong transformation uniform algorithm may represent polymorphic term 
data functors closed composition finite products sums exponentiation object final algebras initial algebras 
collection strong natural transformations representable object 
covariant type system supports parametric polymorphism data types modelled data category 
category sets data category follows parametric polymorphism set theoretic model 
keywords data categories covariance parametric polymorphism 
introduces data functors data categories live establishes ability model large class data types occur computing 
particular give simple account parametricity set theoretic account polymorphic types 
various attempts represent data type constructors functors polymorphic terms represented natural transformations 
example just fx gx types built type variable ff fx gx polymorphic term 
modelled functors ff modelled natural transformation type morphism ff fa ga morphism diagram commutes proceedings cats computing australasian theory symposium melbourne australia january january 
fa ff ga fb ff ff gb gf commutativity asserts action ff unaffected substitutions act arguments functor 
various difficulties simple account 
type variable appears negative positions say domain function type functors contravariant covariant arguments simple notion naturality inadequate dinatural transformations required bring difficulties 
put problem aside 
second functors covariant naturality general weaker concept parametricity uniformity 
way describing parametricity polymorphic term ff require algorithm choice type example algorithm appending lists typically parametric addition integers reals 
certainly true parametric terms yield natural transformations 
problem natural transformations parametric sense 
particular may proper class natural transformations collection algorithms surely small 
question arises natural transformations uniform 
date am unaware adequate answer 
difficulties underly fundamental results semantics polymorphism second order polymorphic lambda calculus set theoretic models 
modifies question ask functors represent data types 
answer course data functors 
model generous class data types key property discovered eugenio moggi natural transformation pair data functors uniform algorithm 
original question answered construction algorithm transformation particularly simple may yield new insights nature parametricity 
data functors defined ideas shape theory 
data functor argument unary values type fa decomposed shape type data partial function object positions determined represents possible positions data may 
choice actual positions determined shape 
example positions matrix indexed theta tree branches labelled node positions paths root specified lists lq 
proved natural transformations ff data functors act filling positions shape data specified positions shape 
proces parametrized shape argument natural transformation determined morphism gp data categories cartesian closed represent natural transformations decidable sub object function object gp note object independent data parametric description algorithm ff 
earlier versions theory stored data lists 
adequate order shapely types approach handle higher order types position functors lists closed exponentials 
data categories defined provide setting study data functors 
examples data categories include sets pos 
category complete partial orders eff effective topos 
structure categories list objects model shapely type constructors add cartesian closure higher order structure 
bulk devoted defining terms establishing result showing data functors closed usual constructions desired data types 
data functors construct semantics polymorphic type system covariant type system introduced companion 
covariant types correspond subsystem second order polymorphic lambdacalculus strong model usual polymorphism inductive types lists trees higher order polymorphism lost 
category sets data category follows constructed set theoretic model polymorphism result kind 
previous models polymorphism built computational concepts structure semantics cost greater complexity reduced explanatory power 
current approach captures uniformity purely semantic way structure functors enforces uniformity transformations 
sections cartesian closed position functors unary data functors general data functors semantics covariant types 
cartesian closed section provides brief overview shape theory develops additional logical power derived interaction cartesian closure finite limits 
details undefined list notation 
typical examples cartesian closed sets toposes list objects eff pos 
extensive category finite limits list objects defined initial algebras linear polynomial functors fx theta list functor example shapely functor 
strength la theta theta preserves pullbacks 
examples coproduct functor exponential gamma object shapely types characterised semantically property values decomposed pair consisting shape data 
typically data type represented finite list type la shape type arity natural number pair satisfy constraint arity shape equals length data list 
shapely types fa pullbacks form fa data la arity follows functor data cartesian natural transformation lists 
functors inherit various properties list functor particular shapely 
closed composition products sums formation initial algebras making suitable modelling data types order language 
object play role booleans true false coproduct inclusions inl inr respectively 
existence finite limits means predicate defines decidable subobject true pullback true combine predicates classical boolean connectives 
presence cartesian closure means quantify predicates follows 
object define result currying 
theta 
predicate theta define subobject pullback curry existence quantification considerable increase expressive power 
note obtained pullbacks exponentials usually decidable equality 
general complement 
position functors position functors store data role dominated list functor earlier 
consider function 
pull back coproduct inclusions obtain coproduct decomposition oe inl oe inr partial function decidable domain define 
right inclusion represents undefined value 
expression abbreviation boolean test inr 
define function restricts domain functions rest inr thought boolean 
object define position functor functor maps object obvious action morphisms 
called object positions 
lemma position functors shapely 
proof composite shapely functors gamma gamma 
theorem position functor cartesian closed final algebra 
proof final algebra consists trees countable paths branches node labelled distinct elements elements need 
finite path root tree finite list positions 
tree described predicate lp determines path defines node tree 
predicate define tree provided empty path defines node nil true long path defines node shorter path implies append 
desired collection predicates pullback lp lp nil nil final boolean implication 
algebra action inverse node constructor trees 
factoring lp cons consider arbitrary algebra algebra morphism ffi satisfy nil true cons tail recursive construction defines uniquely 
monomorphism shows exactly algebra homomorphism status initial algebras clear finite 
cartesian lists initial algebra constructed existing techniques 
consequently find necessary assume existence 
unary data functors data functors defined cartesian transformations position functors store data 
strictly generalises earlier data storage lists data functors closed exponentiation model higher order types 
unary data functor data functor equipped cartesian transformation data position functor 
called object positions 
various list functors arise unary data functors natural numbers object object positions 
example data la maps list function maps nth entry list 
exceeds length list function defined 
infinite lists lists arbitrary length appear way 
matrices positions pairs numbers general arrays handled similarly 
view fa representing dependent sum sigma domain partial function data 
base category sets unary data functors exactly representable functors family shapes yields family representable functors 
cartesian transformations compose follows functor cartesian lists unary data functor object positions lemma unary data functors closed composition identities exponentiation object 
proof unary data functors objects positions gf unary data functor object positions theta identity functor terminal object object positions 
data data functor object functor fa obvious action morphisms data functor object positions theta exponentials preserve pullbacks theta uncurrying data obtain natural transformation entry fa theta picks datum fa position define operation mark fp marks positions shape names 
defined data mark id rest id fp data data lemma data data functor entry mark satisfy equations 
ffi mark id 
entry ffi mark theta id entry inr 
ffi ffi mark ffi id theta fb theta dual strength 
proof straightforward reasoning pullbacks 
consider natural transformation ff position functors 
ff natural respect partial morphisms yoneda lemma implies partial morphism require ff natural respect total morphisms complicates picture slightly 
theorem objects corresponding object transformations pullback morphism determines natural transformation 
proof way interpret pullback ff determined morphism ff called finder 
possible domain partial morphism represented picks partial morphism just yoneda lemma 
conversely morphism ff determines natural transformation decidable subobject characterised morphism range ff lies ff define oe ff ff rest idp easy exercise see oe ff 
conversely morphism ff define natural transformation ff ff comp ffi hid ff ffi comp composition partial functions 
note replace ff ff rest id ffi ff takes value 
ff satisfies test 
supplies canonical representatives equivalence classes morphisms yield transformation 
oe ff ff rest idp comp ffi hid ff ffi rest idp rest idp ffi ff ff ff 
conversely define fi oe ff comp ffi hid oe ff ffi comp ffi hid ff rest idp prove fi ff 
consider global element subobject morphism fi ffi ff id id ff second equations naturality ff respect total morphisms 
middle equation follows id ffi id id argument completes proof categories sets pos morphisms determined action global elements 
general case consider arbitrary element universal property partial function object corresponds global element theta reduces problem earlier form 
corollary natural transformation position functors canonical strength 
proof transformations induced morphisms automatically strong 
remains consider initial algebras final algebras 
theorem unary data functors final coalgebras 
proof data unary data functor 
final algebra trees nodes property labelled branch position domain data 
paths trees list positions 
assigned list node labels encountered way 
words data describe tree function lp ls 
path ps length describes node resulting list ps length root shape plus branch path 

branch arity node shape condition fails 
entry ps entry ps data true data pn qs path take qs take ps ps qs 
equations represented test lp ls lp theta lp theta final algebra pullback lp ls lp theta lp theta proof finality similar theorem 
unfortunately clear unary data functors initial algebras arbitrary cartesian closed 
expect define sub algebras corresponding final coalgebras problem open 
return issue section 
consider natural transformations position functors 
general may proper class natural transformations pair functors sets sets covariant power set functor constant functor problem arise position functors 
order precise specify universal property object natural transformations 
functors object define theta product functor constantly object natural transformations universal property theta natural transformations theta natural bijection morphisms object instantiate transformations insta fa ga obtained applying bijection identity currying 
general data functors general data functor may require kind data 
example leaves nodes tree may take data different types 
functor data functor object called position objects cartesian transformation data pi generally functor data functor projections 
lemma data functors closed composition 
binary product sum functors data functors 
data functors theta proof argument composition simple generalisation unary data functors 
binary product sum functors objects positions data different case 
define data sub category cat consisting finite powers data functors natural transformations 
just position functors establish object natural transformations attendant consequences 
theorem pair data functors data data object exists 
proof object transformations pullbacks gp curry ffi ffi 
see observe ff gp defines natural transformation fa partial natural transformation ff ffi ffi hid ff ffi total iff ff passes test 
conversely ff define oe ff ff ffi mark prove oe inverses 
structure proof theorem 
direction easy 
starting ff gp obtain ffi ffi hid ff ffi ffi mark ffi ffi ff entry ffi mark theta id ffi ffi hid ff entry inr ffi ffi hid ff ffi ffi hid ff ff third equations hold lemma 
fourth holds ff satisfies test 
standard manipulations strengths 
consider natural transformation ff prove fi oe ff ff 
clearly effect shapes suffices prove data ffi ff data ffi fi may assume 
case ffi comp ffi data theta id morphisms fa theta fi comp ffi hff ffi mark ffi consider morphism fa 
determined ffi data ffi decidable subobject total 
mark ffi fm ffi fp fi ffi ffi ff ffi mark ffi ffi ff ffi fm ffi ffi ffi ff ffi ffi ff ffi ff ffi ff ffi ff ffi fg ffi mark ffi ff ffi equations exploit naturality ff id ffi id monomorphism lemma 
general case requires consider morphism fa apply yoneda lemma 
corresponds morphism data functor object positions theta follows previous argument ff fi ff fi 
note proof uses fact data functor 
suffices assume strong provided restrict attention strong natural transformations 
known weakening general case 
corollary natural transformation data functors canonical strength 
proof transformations ff induced morphisms gp automatically strong 
assumption strength longer required hypothesis 
data functors data data define functor maps object gamma corresponding action morphisms 
theorem pair data functors functor structure data functor 
proof loss generality may assume 
objects positions required data gamma 
gamma 
theta composite cartesian transformations 
theorem theta data functor 
canonical functor maps final algebra gamma data functor 
proof objects positions define ga final algebra gamma 
position functor objects positions lq theta locate data node specified path lq 
mentioned status initial algebras position data functors resolved 
assume existence 
definition data category cartesian closed data functors initial algebras 
examples include sets pos eff theorem data category initial algebras data functors data functors 
proof algebra homomorphisms initial algebras final algebras form cartesian transformations commuting square containing parallel pair isomorphisms pullback 
initial algebras form data functors position functors final algebras 
semantics covariant types covariant types theta constructions represent transformation types products sums recursive types 
transformations parametric functions 
parametricity reflected fact transformation types type variables bound consequently free type variables appear strictly positive positions types modelled covariant functors 
type contexts delta lists repetition type variables 
details type judgements delta term calculus 
categorical semantics derived type judgement delta data functor length delta 
interpretations standard 
enlarging context modelled projection swapping type variables type context modelled swapping arguments functor 
axiom modelled identity functor 
rest assuming type context theta theta denotes functor strong natural transformations defined section initial algebra respect argument denoted covariant terms modelled natural transformations interpretations types 
sketched proof theorem covariant type system modelled data category sets 
established data functors closed fundamental constructions category theory type theory 
particular generalisation yoneda lemma shows natural transformation data functors uniform description 
allows model higher order types data functors construct simple set theoretic models polymorphic type system 
dybjer moggi streicher wadler members shape project suggestions comments 
carboni johnstone 
connected limits representability glueing 
appear mscs 
carboni lack walters 
extensive distributive categories 
journal pure applied algebra volume pages 
cockett 
list distributive categories 
journal pure applied algebra volume pages 
hyland 
effective topos 
troelstra van dalen editors brouwer symposium 
north holland 
jay 
finite objects 
mathematical structures computer science 
appear 
jay 
covariant types 
technical report university technology sydney 
jay 
semantics shape 
science computer programming 
press 
pitts 
polymorphism set theoretic constructively 
proceedings conference category theory computer science edinburgh uk sept volume lecture notes computer science 
springer verlag 
reynolds 
polymorphism settheoretic 
kahn mcqueen plotkin editors symposium semantics data types volume lecture notes computer science 
springer verlag 
smith plotkin 
solution recursive domain equations 
siam journal computing volume 
