rc computer science ibm research report assessing effects flow sensitivity pointer alias analyses extended version michael hind anthony ibm research division watson research center yorktown heights new york department mathematics computer science state university new york new paltz new paltz ny limited distribution notice report submitted publication outside ibm probably copyrighted accepted publication 
issued research report early dissemination contents 
view transfer copyright outside publisher distribution outside ibm prior publication limited peer communications specific requests 
outside publication requests filled reprints legally obtained copies article payment 
ibm research division almaden delta watson delta tokyo delta zurich assessing effects flow sensitivity pointer alias analyses extended version michael hind anthony state university new york new paltz ibm thomas watson research center describes empirical comparison contextinsensitive pointer alias analysis algorithms varying degrees flow sensitivity flow insensitive algorithm tracks variables taken stored algorithm computes solution function variant algorithm uses precomputed kill information flow sensitive algorithm 
addition contrasting precision efficiency analyses describe implementation techniques quantify speed 
lastly illustrates object oriented approach design system provides natural example multiple inheritance 
effectively analyze programs written extensive pointers java form knowledge pointer behavior required 
knowledge conservative pointer values resulting precise data flow information adversely affect effectiveness analyses tools depend information 
increase precision program analysis developed ambitious analyses focus analyzing program procedure isolation 
main drawback approaches cost 
pointer alias analysis compile time analysis program point attempts determine pointer point 
analysis general undecidable approximation methods developed 
algorithms provide trade offs efficiency analysis precision computed solution 
goal quantify flow sensitivity affects precision efficiency 
supported part national science foundation ccr ibm research suny new paltz research creative project awards 
email mcs edu url www mcs edu hind www net extension :10.1.1.52.8863
researchers provided empirical results techniques comparisons algorithms difficult differing program representations benchmark suites metrics 
holding factors constant focus efficacy algorithms manner results obtained 
contributions ffl empirical results measure precision efficiency pointer alias analysis algorithms varying degrees flow sensitivity ffl empirical evidence various implementation enhancements significantly improved analysis time flow sensitive analysis ffl overview object oriented design system includes significant multiple virtual inheritance providing natural argument features 
addition flow sensitivity factors affect cost precision trade offs pointer alias analyses include context sensitivity manner aggregates arrays structs heap modeled 
experiments hold factors constant results reflect usage flow sensitivity 
section highlights algorithms implementations 
section describes empirical study algorithms analyzes results contrasts related results researchers 
section overviews performance improving enhancements implementation quantifies analysis time speedup 
section describes related 
section states 
analyses implementation manner classifying interprocedural data flow analyses consider control flow information analysis 
flow sensitive analysis considers control flow information procedure analysis procedure 
flow insensitive analysis consider control flow information analysis efficient precise 
see full discussion definitions 
algorithms consider listed order increasing precision flow insensitive algorithm computes solution set entire program contains named objects address taken stored fi flow insensitive algorithm computes solution set function fik flow insensitive algorithm computes solution set function attempts improve precision precomputed flow sensitive kill information fs flow sensitive algorithm computes solution set program point :10.1.1.49.2704
sections provide information analyses implementation 
algorithms program represented program call multi graph pcg node corresponds function directed edge represents call target function 
function body represented control flow graph cfg 
graph build simplified sparse evaluation graph seg discussed section 
address taken analysis computes solution making single pass functions program adding global set variables addresses assigned variable 
include actual parameters addresses stored corresponding formal 
examples statements new foo simple expression statements address stored 
efficient linear size program uses single solution set imprecise 
provided base case comparison algorithms 
general manner analyses compute solutions 
nested fixed point computation outer nest corresponds computing solutions function pcg 
function computation triggers computation local solution program points distinguished particular analysis 
flow sensitive fs analysis local solution corresponds cfg node function 
flow insensitive analyses fi fik local solution corresponds set conservatively represents hold function 
general framework potential calls occur due function pointers virtual methods called function known run time 
pcg include functions called 
iterative algorithm fig 
described 
extension handle virtual methods described 
section reports improvements due worklist implementation 
fs fi fik analyses utilize compact representation represent alias relations 
representation shares property points representation captures edge information alias relations :10.1.1.25.6013
example variable points turn points compact representation records alias set fha bi hb cig inferred ci bi aliases 
analyses context insensitive merge information flowing different calls function may suffer unrealizable path problem potentially propagate back wrong caller aliases called function 
sections discuss potential imprecision 
context sensitive analyses suffer problem may increase time space costs :10.1.1.25.6013
analyses considered represent possibly objects allocated calls new malloc creating named object cfg node number allocation statement 
objects referred cfg node number allocation statement 
names unique entire program 
precise heap modeling schemes improve precision may increase time space costs :10.1.1.152.183
quantifying effects context sensitivity various scope 
consider simple program fig 

analysis computes set objects assumes pointers may point 
set contain objects heaps heaps heaps heaps appear referenced 
fi analysis intraprocedural control flow information 
conservatively computes hold function function uses alias set represent may hold cfg node fig 
fi analysis assumes hp heaps hp heaps flow results fhp heaps hp heaps hp heaps hp heaps hq heaps ig results objects heaps heaps heaps heaps potentially referenced 
fik analysis attempts improve precision flow insensitive analysis precomputing kill information pointers uses information flow insensitive analysis call sites 
example precomputation determine alias relations involving see discussion precision trade offs representation explicit representation contain alias pairs 
final intraprocedural flow sensitive pass improve precision pass implemented 
kill information single flow sensitive cfg 
call site compute sets set pointers definitely killed paths entry set pointers definitely killed paths exit :10.1.1.49.2704
set example 
build initial pcg foreach procedure pcg loop initialize interprocedural alias sets fg loop repeat foreach procedure pcg loop interprocedural alias sets entry call sites compute intraprocedural alias sets intraprocedural alias sets update interprocedural alias sets representing effect procedure calls called loop new function pointer aliases update pcg initializing interprocedural alias sets new functions fg interprocedural alias sets pcg converge high level description general algorithm void main void new new void void new new new void void example program entry killed call 
contain alias relations generated propagated fhp heaps hp heaps hq heaps ig 
results objects heaps heaps potentially referenced 
fs analysis associates alias set inn cfg node example outs fhp heaps ig heaps refer storage 
entry function fs analysis compute ins fhp heaps ig precise solution simple example 
example illustrates theoretical precision levels analyses fs precise precise analysis efficient analysis linear uses set 
fi analysis efficient fik analysis kill information uses analysis 
expect fs analysis efficient needs distinguish solutions point program 
theoretical spectrum exists terms precision efficiency analysis precise efficient side fs analysis precise efficient side fi fik analyses middle 
studied flow insensitive analyses alias set program limit number alias relations grouping distinct variables named object 
analysis fall fi theoretical precision spectrum 
implementation analyses implemented system experimental program analysis system written 
system uses multiple virtual inheritance provide extensible framework data flow analyses 
prototype version ibm visualage compiler front 
syntax tree constructed front transformed pcg cfg function serve input alias analyses 
cfg built library functions 
model call library function semantics providing benefits context sensitive analysis calls 
library calls affect value pointer treated identity transfer function 
alias set class implements compact representation represent alias relations 
fs fi fik analyses implemented worklists 
section discusses earlier iterative implementation 
analyses incorporate function pointer analysis pointer alias analysis described :10.1.1.49.2704
currently array elements field distinguished setjmp longjmp statements supported 
implementation assumes pointer values exist pointer variables pointer arithmetic result pointer go program benchmark suite anagram syntactically contain call longjmp code unreachable 
ing array boundaries 
stated section heap objects named allocation site 
model values passed argc argv main function dummy main function added called benchmark main function simulating effects argc argv 
function initialized iob array standard added function similar added ruf landi 
initializations global variables automatically modeled assignment statements dummy main function 
results section provides empirical evidence precision efficiency algorithms discussed section address taken flow insensitive fi flow insensitive kill fik flow sensitive fs 
benchmarks benchmark suite contains programs provided researchers cint benchmarks :10.1.1.25.6013
table describes characteristics suite 
third column contains number lines source header files reported unix utility wc 
fourth column reports number user defined functions nodes pcg include function 
columns give number call sites distinguished user library function calls 
columns report cumulative statistics cfg edges 
figures include nodes edges created initialization globals 
column computes ratio cfg edges nodes 
column reports percentage cfg nodes considered pointer assignment nodes 
current analysis treats assignment variable involved pointer expression left side assignment declared pointer 
columns report number recursive functions functions pcg cycles heap allocation sites program 
row table reports average edge node ratio average pointer assignment node percentage computed averaging corresponding values benchmarks 
programs syntactically modified satisfy stricter type checking semantics 
program names different reported ruf 
spec cint program alvinn named backprop todd austin benchmark suite 
ruf referred ks part ft span 
conservative considering statements left side expression pointer 
statements field treated pointer assignments matter type field declared 
accurate categorization affect precision analysis improve efficiency reducing number nodes considered analysis discussed section 
call sites cfg ptr asgn rec allocation name source loc user lib nodes edges edges nodes nodes sites allroots landi alvinn spec mccat trie mccat bisect mccat mccat anagram austin lex landi ks austin eks mccat main mccat vor mccat loader landi compress spec ft austin football landi compiler landi assembler landi yacr austin simulator landi go spec average table static characteristics benchmark suite description experiment section presents precision efficiency results 
benchmark analysis report analysis time maximum memory average number objects analysis computes dereferenced pointer point 
precision results fik analysis exactly fi analysis benchmarks 
explicitly include analysis precision data 
experiment performed rs powerpc mb ram mb paging space running aix 
executable built ibm compiler option 
analysis time reported seconds include time build pcg cfgs include analysis specific preprocessing building seg cfg 
information displayed top left chart fig 

top right chart reports high water mark memory usage analysis process 
memory usage includes intermediate representation alias information statistics related data 
information obtained ps command aix 
collect precision information system traverses representation visiting expression containing pointer dereference computed alias information reports named objects aliased pointer expression 
report average number dereferences reads writes 
pointer expression multiple dereferences counted multiple dereference expressions dereference 
intermediate dereferences percent formal global local reads writes classification dereferenced pointer types programs counted reads 
dereference counted read write depending context expression 
statements increment treated read write consider pointer dereferenced variable declared pointer array formal parameter operators variable 
formal parameter arrays included corresponding actual parameter pointer 
count operator arrays formal parameters resulting pointer array name constant counting may skew results 
classifies type pointer dereferenced averaged programs 
appendix contains table information benchmarks 
analysis time secs allroots alvinn trie bisect anagram lex ks eks main vor loader compress ft football compiler assembler yacr simulator go max memory usage mb allroots alvinn trie bisect anagram lex ks eks main vor loader compress ft football compiler assembler yacr simulator go flow sensitive flow insensitive kill flow insensitive address taken reads precision num objects allroots alvinn trie bisect anagram lex ks eks main vor loader compress ft football compiler assembler yacr simulator go writes precision num objects allroots alvinn trie bisect anagram lex ks eks main vor loader compress ft football compiler assembler yacr simulator go flow sensitive flow insensitive address taken analysis time memory usage precision results manner heap modeled considered evaluating precision results 
example model uses names objects heap may precise compared model uses fewer names 
mentioned distinguish heap objects allocation site 
similarly analyses represent invisible objects objects lexically visible current procedure aliased formal parameter address passed corresponding actual parameter single object may report fewer objects 
analyses technique 
assuming correct input program pointer dereference correspond object run time serves lower bound average 
precision result close demonstrates analysis precise modulo heap invisible object naming larger number reflect imprecise algorithm limitation static analysis pointer dereference corresponds different memory locations program execution 
bottom charts fig 
provide graphical layout precision information reads writes 
fig 
refines information fs fi analyses providing breakdown type object pointed 
fig 
provides similar information averaged programs 
charts fig 
report percentage dereferenced pointers resolve exactly object model 
object named variable opposed heap object pointer dereference replaced variable 
table appendix elaborates information 
discussion expected results analysis speed chart fig 
indicate analysis efficient takes seconds programs 
fi analysis twice fast fs analysis faster fs analysis program 
expect memory usage fs analysis orders magnitude larger fi analysis fs analysis alias sets 
initial implementation property storage saving schemes discussed section significantly reduced storage requirements analysis time fs analysis 
remains seen techniques keep storage requirements fs comparable fi larger programs analyzed 
precision analysis leaves desired 
fig 
reports average objects reads objects writes set 
expect set increase size program precision modeling technique increase possibility strong updates 
fs analysis potentially alias sets cfg node program plus alias sets function 
fi analysis uses alias sets function 
numbers differ weighted number reads writes pointer program programs larger number reads pointer writes pointer contribute read average 
analysis worsen larger programs 
results suggest precision simple analysis acceptable 
results indicate fik analysis beneficial 
benchmark suite precise fi analysis occasions requires analysis time fs analysis 
explanation precision result may alias relation created simulate parameter formal points actual typically killed called routine formal parameter modified access passed actual 
programs containing alias relations benefit precomputed kill information 
believe analysis time improved optimizations spirit described section 
surprising result precision fi analysis 
benchmarks fi analysis precise fs analysis 
suggest added precision obtained fs analysis considering control flow function significant benchmarks pointers dereferenced 
offer possible explanations 
pointer variables assigned distinguished object function 
distinguishing program points function key difference fs fi analyses result increase precision 
seen exceptions function ks benchmark function main benchmark 
list pointer list creating loops 
tmp pointer traverse list create new list 
list creation code pointer dereferenced initialize created node 
fs analysis reports heap object just created fi analysis reports possible nodes tmp pointer pointed earlier list traversal 
accounts precision differences write dereferences main benchmark 
main cause differences read dereferences main peculiar code main function function draw called variable pointer object passed parameter 
previous statement variable assigned value variable null 
null passed call 
call function fs analysis determine draw functions calls passing parameter null value pointer 
variable earlier main point object points objects 
call draw fi analysis benefit killing definition reports point objects null 
fik analysis suffers imprecision killing flow sensitive reads allroots alvinn trie bisect anagram lex ks eks main vor loader compress ft football compiler assembler yacr simulator go flow sensitive writes allroots alvinn trie bisect anagram lex ks eks main vor loader compress ft football compiler assembler yacr simulator go flow insensitive reads allroots alvinn trie bisect anagram lex ks eks main vor loader compress ft football compiler assembler yacr simulator go flow insensitive writes allroots alvinn trie bisect anagram lex ks eks main vor loader compress ft football compiler assembler yacr simulator go heap formal parameter global local local bars go truncated 
object type breakdown fs fi formal local local global parameter heap reads writes breakdown average object type pointed dereferenced pointer total precision reads fs fi avg num objects fs fi total precision writes avg num objects fs fi avg num objects fs fi heap formal parameter global local local charts provide average precision benchmarks reads writes 
charts include analysis allow difference fs fi analyses visible 
reads writes fs fi fs fi heap formal parameter global local local percentage dereferenced pointers resolve object model 
function call main precision fi analysis closer fs analysis 

large number alias relations created call sites actual formal parameter bindings 
lack substantial precision difference fs fi analyses may algorithms rely context insensitive mapping mechanism call sites 
considering charts fig 
fi precise fs pointers directed locals formal parameters 
fs employed focus pointers directed heap global variables 
precision results go merit discussion 
average objects returned reads writes respectively maximum 
program contains small list processing functions cursor implementation accept pointer head list parameter 
functions called times passing address different actuals list header resulting aliases formal parameter 
lifetime formal limited function call function relations propagated function 
relations suffer effects unrealizable path problem mentioned section 
results analysis time function program size depends formation computes removes aliases involving coming entry set main exist adds aliases generated main 
amount alias relation propagation pcg 
table illustrates point fs analysis 
example go despite largest program having pointer aliased objects analyzed fastest rates loc second cfg nodes second relations propagated program 
suggested shapiro horwitz diwan precise time consuming alias analysis may inefficient may appear time required obtain increased precision may reduce time required subsequent analyses utilize mod information pointer alias information input :10.1.1.11.3368
previous paragraph suggests true pointer alias analysis utilizes pointer alias information analysis 
comparison results landi report precision results computation mod problem flow sensitive pointer alias algorithm limited context sensitive information 
metrics report number deref assigns corresponds write metrics reported fig 

results include compiler introduced temporaries deref count direct comparison possible 
stocks metric including temporaries flow sensitive context sensitive analysis landi ryder 
report average number cfg fs program loc nodes time loc sec nodes sec allroots alvinn trie bisect anagram lex ks eks main vor loader compress ft football compiler assembler yacr simulator go average table flow sensitive analysis speed computed dividing size program measured loc cfg nodes analysis time 
objects ranges common benchmarks allroots lex loader compress football compiler assembler simulator 
benchmarks flow sensitive context insensitive analysis ranges 
possible explanations slightly precise results algorithm uses context sensitivity underlying representation identical pointer dereferences may counted manner cases 
example statements tp located allroots treated modifying structure deallocated pointer dereference 
fact programs analysis reports close number writes allroots lex simulator precision identical reported 
relative precision flow insensitive analysis compared flow sensitive analysis contrast study stocks compares flow sensitive analysis landi ryder flow insensitive analysis described 
common benchmarks algorithm ranges objects average write dereference compared approximately flow insensitive analysis studied 
analysis described shares property steensgaard analysis groups objects pointed variable equivalence class 
lead spurious alias relations fi analysis allow linear time algorithm shown fast practice 
emami report precision results flow sensitive context sensitive algorithm 
results range indirect accesses heap naming scheme represents heap objects name 
unable obtain benchmarks suite study direct comparison results possible 
ruf reports read write totals flow sensitive context insensitive analysis 
analysis counts operator arrays formal parameters dereference 
array point place average number objects improved 
benchmarks common ruf reports read write average respectively 
facilitate comparisons counted manner 
results common benchmarks averages fs analysis fi analysis 
results complete benchmark suite contained tables appendix 
attribute slight differences fs analysis difference representations 
ruf states vdg intermediate representation coalesces series structure array operations single memory write 
coalescing skew results direction 
shapiro horwitz empirical comparison flow insensitive algorithms :10.1.1.11.3368
successive algorithm precise efficient 
ffl address taken analysis included ffl linear time algorithm steensgaard ffl algorithm shapiro horwitz ffl algorithm andersen :10.1.1.109.6502
algorithm differs flow insensitive algorithm studied uses alias set program set function 
algorithm algorithm 
remaining algorithms precise efficient algorithms studied 
authors measure precision analyses implementing dataflow analyses gmod live variables truly live variables interprocedural slicing algorithm 
addition alias analysis clients authors report direct precision alias analysis algorithms terms total number points relations 
agree best illustration go large number array low number pointer dereferences :10.1.1.25.6013
program average changed reads writes uses operator counted 
common benchmarks allroots alvinn anagram lex ks loader compress compiler assembler yacr simulator 
reports results ft name span version benchmark substantially larger ruf analyzed comparable 
theory fi analysis precise andersen algorithm considers function scopes cost alias set 
algorithms offer similar precision practice distinguishing case probably uncommon 
meaningful metric measure points information pointer dereferenced 
pointer analyses conclude ffl precise flow insensitive analysis generally leads increased precision subsequent analyses information varying magnitudes ffl metrics measuring alias analysis precision tend predictors precision subsequent analyses alias information ffl precise flow insensitive analysis improve efficiency subsequent analyses information 
efficiency improvements section describes performance improving enhancements implementation quantifies effects analysis time speed flow sensitive algorithm 
novelty claimed efficacy technique shown 
table provides program characteristics contribute complexity pointer alias analysis benchmark 
back column percentage cfg nodes incoming back edge loop header nodes 
merge column percentage cfg nodes predecessor includes nodes counted back column switch nodes 
pointer assignment statements broken types affect gen kill components transfer functions 
column marked constant gen kill set 
examples statements new 
column marked constant kill set nonconstant gen set 
statement contains pointer variable left side right side value determined inspection 
examples statements 
column marked constant kill gen set 
statement contains dereference left side 
examples statements 
figures include effects assignments actuals formals order simulate call semantics 
column labeled call percentage call nodes 
sharing alias sets described section flow sensitive analysis computes solutions node cfg 
result storing redundant information 
example node fig 
affect pointer value set equal set 
likewise distinguish structure elements considered ignoring type 
result overestimate number type statements 
node predecessor set value set equal value 
example nodes fig 

nodes alias sets shared 
term shared literal way set shared set object analysis 
done shallow copy alias set data structures 
precompute sharing sites separate forward pass cfg performing alias analysis 
node set call deep set dubbed seg sparse evaluation graph node 
nodes list seg predecessors seg successors analysis 
alias set allocation strategy node summarized follows inn outp pred share sets deep set ae inn identity transfer function deep set current implementation treats call nodes seg nodes 
table reports number alias sets optimization applied percentage reduction 
addition saving storage average fewer alias sets allocated method saves visits actual analysis nodes affect pointer aliasing 
allocate fewer alias sets real benefit technique seen analysis 
visit propagate alias relations extraneous cfg nodes simply fewer alias relations stored copied cfg node 
affects analysis time space significant way 
table shows effects efficiency improving ideas flow sensitive analysis 
run times collected section function clock gives cpu time elapsed time 
metric chosen eliminates effects system load amount ram vs paging space elapsed time program approximately times cpu time 
headings column read vertically example second column shows analysis time seconds sharing alias sets enhancements described section 
third column reports analysis time resulting speed sharing technique 
effectiveness technique related percentage cfg nodes affect pointer percentage call nodes higher percentages lower potential method described conservative approximation seg similar 
sharing version column table number alias sets allocated twice sum nodes functions expected eks 
fs analysis allocates alias sets cfg nodes visit enclosing function 
benchmarks unreachable functions allocate alias sets nodes function cfg accounting discrepancy 
cfg nodes pct pct ptr assign type pct benchmark total back merge total pct call allroots alvinn trie bisect anagram lex ks eks main vor loader compress ft football compiler assembler yacr simulator go averages table benchmark characteristics 
back column cfg nodes incoming back edge loop header nodes 
merge column cfg nodes predecessor includes nodes counted back column adds switch nodes 
char exit entry 

example cfg left procedure right 
note global locals cfg formal parameter possible topological numbers ignoring back edge appear node 
sharing gamma 
benchmark gamma 
gamma 
name unsorted sorted speed forward bind filter gamma 
filter allroots loc alvinn loc loc trie loc bisect loc loc anagram loc lex loc ks loc eks loc main loc vor loc loader loc compress loc ft loc football loc compiler loc assembler loc yacr loc simulator loc go loc averages table flow sensitive analysis run time seconds 
numbers parentheses speed previous version left 
num 
alias sets benchmark sharing sharing pct saved allroots alvinn trie bisect anagram lex ks eks main vor loader compress ft football compiler assembler yacr simulator go average table effectiveness sharing alias sets benefit 
benchmarks averages respectively 
vor high averages categories lowest effectiveness technique yacr lower average percentages resulted higher speed 
benchmarks technique results significant speed average 
largest benchmark go analysis run due insufficient memory applied optimization 
worklists initial implementation analyses iterative algorithm simplicity 
correctness verified worklist implementation improve efficiency 
types worklists seg node worklists function worklists 
function worklist seg nodes 
pcg worklists functions current 
motivation worklists described section nested empty loops worklists outer loop visiting functions inner loop visiting seg nodes 
worklist functions initially contains functions 
visit function initialize function seg node worklist seg nodes function 
seg node set changes seg successors placed function seg node worklist 
function entry set changes placed function worklist 
exit set function changes calling functions placed function worklist percentage merge nodes plays smaller role 
calling call node placed respective function seg node worklist 
analysis runs worklists empty 
column table shows improvement worklist implementation iterating version shared alias sets 
result average speedup iterating version produced average speed nonshared iterating version 
sorted worklists worklist implementation improved analysis time discovered improved 
iterating analysis forward data flow problem natural process nodes topological order 
enhancement priority queues topological order seg function worklists 
consider case loop body generates aliasing information 
best process loop body moving loop exit 
topological order give property may process loop exit loop body 
occur fig 
node numbers topological order 
construction cfg nodes loop bodies created nodes loop body 
node created node nodes assigned numbers created performed topological order presence gotos nodes creation number priority ensures loop bodies processed 
result single priority worklist functions calling functions visited called functions 
seg nodes aliases propagated directions pcg edge 
optimal order function visits apparent 
benchmark suite single priority worklist functions provided marginal improvement iterating version 
increase efficiency function worklists current 
visiting functions current worklist place functions worklist 
effect set functions worklist visiting order fixed topological order 
current worklist empty swap current worklists continue analysis 
fifth column table reports analysis time sorted worklists seg nodes functions previous enhancements 
enhancement resulted average speed previous version worklists shared alias sets 
filtering function analysis propagates alias relations call nodes entry set called functions 
needed creates alias relations formals topological order cyclic graph obtained depthfirst search graph classified back edges 
actuals called function entry set unions call node set called function entry set 
consider alias relations changed called function example relation hl ai fig 
propagated called function reach exit set function 
relations propagated back call node set 
effect called function acts identity transfer function relations relevant called function 
correct inefficient 
enhancement propagate call node alias relations reached called function 
compute set alias relations reachable called function call propagates alias relations entry set described 
view alias relations directed graph remove graph vertices distinguished objects associated edges alias relations reached global formal removed edges alias relations simply unioned call node set directly 
help limit propagation effects unrealizable path problem 
column table reports effectiveness optimization 
provided dramatic speed average previous implementation enhancements 
programs particular football assembler higher average speed resulting filtering 
programs shared common characteristics single function unusually high amount pointer affecting statements high number called functions 
shows effects optimizations dramatic way loader benchmark 
collected data graph repeatedly executing ps command aix fs analyses running 
recorded size column gives virtual size data section process capture heap allocated memory usage analysis 
axis chart simply marked samples sample single call ps 
majority heap allocations represent alias relations resulting memory usage interpreted number alias relations stored analysis running 
sharing version shows characteristic curve grows quickly early levels analysis reaches fixed point 
difference sharing sharing versions shows large reduction number alias sets reduced number alias relations stored 
cumulative effect optimizations average speed 
illustrates benefits obtained limiting propagation extraneous alias relations number visits functions nodes 
similarly shaped graphs 
node sample inheritance pattern system overview design program representation called dakota designed enable various intra interprocedural data flow analyses extensibility important goal 
designing classes analyses recurring inheritance pattern emerged 
illustrates pattern class hierarchy graph 
class node base class represents cfg node includes list predecessor successor nodes 
class virtually inherits node adds assignment statement information expression trees left right side assignment 
similar classes exist types cfg nodes 
classes represent generic cfg specific data flow analysis 
implement flow sensitive analysis define class virtually inherits node adds set set data members needed flow sensitive analysis 
addition implements default meet method compute set flow sensitive nodes 
class inherits sets assignment statement information 
computes set applying transfer function set assignment statement information 
similar inheritance pattern implementation flow sensitive analysis types nodes expressions functions flow insensitive analyses 
inheritance pattern generalized simultaneous data flow analysis 
features system include ffl dakota extensive factory factory method patterns give analysis clients convenient mechanism constructing appropriate objects 
ffl analysis front independence 
representation provides basic methods needed data flow analyses cfg nodes lists successors predecessors 
meet method needs list cfg predecessors natural inherit information node 
samples loader sharing sharing worklists priority queues filtering memory usage time loader benchmark 
ffl persistent storage 
entire program representation saved restored ascii files 
gives dakota platform independence 
related section describes related mentioned section 
ruf presents empirical study algorithms flow sensitive algorithm similar implemented context sensitive version algorithm 
results showed context sensitive algorithm improve precision pointers dereferenced cautioned may characteristic benchmark suite analyzed 
wilson lam algorithm performing context sensitive analysis avoids redundant analyses functions similar calling contexts 
ghiya hendren empirical data showing points connection analyses improve traditional transformations array program understanding :10.1.1.40.9725
ruf describes program partitioning technique flow sensitive points analysis achieving storage savings existing methods :10.1.1.52.5364
diwan provide static dynamic measurements effectiveness flow insensitive analyses type safe language modula 
exception algorithms precise versions studied 
zhang report effectiveness applying different pointer aliasing algorithms different parts program 
hasti horwitz pessimistic algorithm attempts increase precision flow insensitive analysis iterating flow insensitive analysis ssa construction :10.1.1.100.6361
empirical results reported 
horwitz defines precise flow insensitive alias analysis proves absence dynamic memory allocation computing np hard 
choi describes flow sensitive algorithm implemented provides high level description flow insensitive algorithms 
detailed description flow insensitive algorithms :10.1.1.49.2704
algorithms pointer aliasing techniques described 
vortex suif compilers provide infrastructures interprocedural analyses 
efficiency reasons multiple inheritance scheme outlined section provide possibility augmenting equivalent cfg node list analysis specific methods apply node 
described empirical study pointer alias analysis algorithms varying degrees flow sensitivity 
ffl address efficient provide sufficient precision ffl flow insensitive analysis kill beneficial ffl precision flow insensitive analysis identical flow sensitive analysis programs benchmark suite ffl published implementations flow sensitive pointer analysis equivalent precision 
flow sensitive analysis efficiently analyzed program order locs benchmarks needed see property generalizes 
empirically demonstrated various implementation strategies result significant analysis time speed 
described design system offers example multiple inheritance 
michael burke michael lee support 
todd austin bill landi rakesh ghiya making benchmarks available 
bill landi laurie hendren erik ruf barbara ryder bob wilson provided useful details concerning implementations 
michael burke paul carini jong deok choi provided useful algorithms described 
discussions manuel fahndrich led reporting intermediate read dereferences considered 
srinivasan implemented initial dakota control flow graph builder important early system component 
group members robert lynne lap chung lam mark nicosia joseph keith sanders truong vu ming wu assisted implementation testing system 
david bacon helped initial design program call graph representation 
michael burke jong deok choi john field ramalingam srinivasan sas program committee provided useful comments earlier drafts 
aho sethi ullman 
compilers principles techniques tools 
addison wesley reading ma 
lars ole andersen 
program analysis specialization programming language 
phd thesis diku university copenhagen may 
available ftp diku dk pub diku semantics papers dvi todd austin 
pointer intensive benchmark suite version 
www cs wisc edu austin ptr dist html 
walter bays 
spec announces new benchmark suites cint cfp 
technical report systems performance evaluation cooperative march 
spec newsletter 
michael burke paul carini jong deok choi michael hind :10.1.1.49.2704
flow insensitive interprocedural alias analysis presence pointers 
pingali banerjee gelernter nicolau padua editors lecture notes computer science pages 
springer verlag 
proceedings th workshop languages compilers parallel computing 
extended version published research report rc ibm watson research center september 
michael burke paul carini jong deok choi michael hind 
interprocedural pointer alias analysis 
research report rc ibm watson research center december 
paul carini michael hind srinivasan 
interprocedural type analysis 
research report rc ibm watson research center november 
craig chambers jeffrey dean david grove 
frameworks intra interprocedural dataflow analysis 
technical report uw cse department computer science engineering university washington november 
david chase mark wegman kenneth zadeck 
analysis pointers structures 
sigplan conference programming language design implementation pages june 
sigplan notices 
jong deok choi michael burke paul carini 
efficient flow sensitive interprocedural computation pointer induced aliases side effects 
th annual acm sigact sigplan symposium principles pages january 
jong deok choi ron cytron jeanne ferrante 
automatic construction sparse data flow evaluation graphs 
th annual acm symposium principles programming languages pages january 
ron cytron jeanne ferrante barry rosen mark wegman kenneth zadeck :10.1.1.100.6361
efficiently computing static single assignment form control dependence graph 
acm transactions programming languages systems pages october 
jeffrey dean greg defouw david grove litvinov craig chambers 
vortex optimizing compiler object oriented languages 
acm conference object oriented programming systems languages applications 
alain deutsch 
interprocedural may alias analysis pointers limiting 
sigplan conference programming language design implementation pages june 
sigplan notices 
amer diwan 
personal communication august 
amer diwan kathryn mckinley elliot moss 
type alias analysis 
sigplan conference programming language design implementation pages june 
sigplan notices 
emami rakesh ghiya laurie hendren 
context sensitive interprocedural points analysis presence function pointers 
sigplan conference programming language design implementation pages june 
sigplan notices 
erich gamma richard helm ralph johnson john vlissides 
design patterns elements reusable object oriented software 
addison wesley 
rakesh ghiya laurie hendren 
connection analysis practical interprocedural heap analysis international journal parallel programming 
rakesh ghiya laurie hendren 
tree dag cyclic graph 
shape analysis heap directed pointers rd annual acm sigact sigplan symposium principles programming languages pages january 
rakesh ghiya laurie hendren :10.1.1.40.9725
putting pointer analysis 
th annual acm symposium principles programming languages pages january 
rebecca hasti susan horwitz 
static single assignment form improve flow insensitive pointer analysis 
sigplan conferenceon programming language design implementation pages june 
sigplan notices 
laurie hendren alexandru nicolau 
parallelizing programs recursive data structures 
ieee transactions parallel distributed systems january 
michael hind anthony 
empirical comparison interprocedural pointer alias analyses 
research report rc ibm watson research center december 
available suny new paltz technical report 
michael hind anthony :10.1.1.52.8863
assessing effects flow sensitivity pointer alias analyses 
lecture notes computer science 
springer verlag 
proceedings th international static analysis symposium 
horwitz pfeiffer reps dependence analysis pointer variables 
sigplan conference programming language design implementation pages june 
sigplan notices 
susan horwitz 
precise flow insensitive may alias analysis np hard 
acm transactions programming languages systems january 
john kam jeffrey ullman 
global data flow analysis iterative algorithms 
journal acm january 
william landi 
undecidability static analysis 
acm letters programming languages systems december 
william landi 
personal communication october 
william landi barbara ryder 
safe approximate algorithm interprocedural pointer aliasing 
sigplan conference programming language design implementation pages june 
sigplan notices 
william landi barbara ryder sean zhang 
interprocedural modification side effect analysis pointer aliasing 
sigplan conference programming language design implementation pages june 
sigplan notices 
james larus paul hilfinger 
detecting conflicts structure accesses 
sigplan conference programming language design implementation pages 
sigplan notices 
thomas marlowe william landi barbara ryder choi michael burke paul carini 
aliasing clarification 
sigplan notices september 
thomas marlowe barbara ryder michael burke 
defining flow sensitivity data flow problems 
technical report rc ibm watson research center july 
lee 
incremental 
dr journal pages december 
anthony 
conditional pointer aliasing constant propagation 
master thesis suny new paltz 
preparation 
ramalingam 
undecidability aliasing 
acm transactions programming languages systems november 
ramalingam 
sparse evaluation representations 
pascal van hentenryck editor lecture notes computer science pages 
springer verlag 
proceedings th international static analysis symposium 
erik ruf 
context insensitive alias analysis reconsidered 
sigplan conferenceon programming language design implementation pages june 
sigplan notices 
erik ruf :10.1.1.52.5364
partitioning dataflow analyses types 
th annual acm sigact sigplan symposium principles programming languages pages january 
erik ruf 
personal communication october 
mooly sagiv thomas reps reinhard wilhelm 
solving shape analysis problems languages destructive updating 
rd annual acm symposium principles programming languages pages january 
mooly sagiv thomas reps reinhard wilhelm 
solving shape analysis problems languages destructive updating 
acm transactions programming systems january 
marc shapiro susan horwitz :10.1.1.11.3368
effects precision pointer analysis 
pascal van hentenryck editor lecture notes computer science pages 
springer verlag 
proceedings th international static analysis symposium 
marc shapiro susan horwitz 
fast accurate flow insensitive point analysis 
th annual acm sigact sigplan symposium principles programming languages pages january 
barton streeter 
extension mechanisms montana 
th ieee israeli conference software systems pages june 
spec 
spec cpu version 
standard performance evaluation www org august 
bjarne steensgaard 
points analysis linear time 
rd annual acm sigact sigplan symposium principles programming languages pages january 
philip stocks barbara ryder william landi sean zhang 
comparing flow context sensitivity modifications side effects problem 
international symposium software testing analysis pages march 
robert wilson 
efficient context sensitive pointer analysis programs 
phd thesis stanford university december 
robert wilson robert french christopher wilson saman amarasinghe jennifer anderson steve tjiang shih wei liao chau wen tseng mary hall monica lam john hennessy 
suif infrastructure research parallelizing optimizing compilers 
sigplan notices 
robert wilson monica lam 
efficient contextsensitive pointer analysis programs 
sigplan conference programming language design implementation pages june 
sigplan notices 
sean zhang barbara ryder william landi 
program decomposition pointer aliasing step practical analyses 
th symposium foundations software engineering pages october 
sean zhang barbara ryder william landi 
experiments combined analysis pointer aliasing 
acm sigplan sigsoft workshop program analysis software tools engineering pages june 
appendix tables similar table fig 

benchmark analysis report analysis time average number objects analysis computes dereferenced pointer point 
mark benchmarks difference fs fi analyses 
precision results fik analysis exactly fi analysis benchmarks report fik analysis times fi analysis times parenthesis 
tables provide alias relation characteristics dereferenced pointers similar table 
set columns local fp classifies type variable dereferenced providing detailed information fig 

example allroots places dereferenced pointer read dereferenced variable formal parameter 
second half table classifies average number objects analysis returns 
example reads dereferenced pointers allroots analyses report average heap object global objects 
column labelled local corresponds locals function dereference occurred 
column labelled nv corresponds local variables function dereference occurred 
number heap objects may vary alternative heap naming scheme 
column tables correspond avg column tables 
main pointer dereferences tables report precision results similar manner tables 
difference tables count uses gamma dereferences done 
precision numbers flow insensitive analysis kill identical version kill omitted 
executed dereference null pointer 
fs analysis determines fact 
tables dereferences averaged pointing zero objects fs analysis 
second half tables objects classified type 
type associated object include dereferences average fs analysis resulting higher average 
pointers file struct returned fopen treated global 
total num objects program analysis time type avg max med allroots fs read write functions fi read write loc read write alvinn fs read write functions fi read write loc read write fs read write functions fi read write loc read write trie fs read write functions fi read write loc read write bisect fs read write functions fi read write loc read write fs read write functions fi read write loc read write anagram fs read write functions fi read write loc read write lex fs read write functions fi read write loc read write ks fs read write functions fi read write loc read write eks fs read write functions fi read write loc read write main fs read write functions fi read write loc read write table part efficiency precision measurements numbers fik analysis times 
entry indicates increase precision flow sensitive analysis 
tot num objects program analysis time type avg max med vor fs read write functions fi read write loc read write loader fs read write functions fi read write loc read write compress fs read write functions fi read write loc read write ft fs read write functions fi read write loc read write football fs read write functions fi read write loc read write compiler fs read write functions fi read write loc read write assembler fs read write functions fi read write loc read write yacr fs read write functions fi read write loc read write simulator fs read write functions fi read write loc read write go fs read write functions fi read write loc read write total fs read write fi read write read write table part efficiency precision measurements numbers fik analysis times 
entry indicates increase precision flow sensitive analysis 
dereferenced pointer type average object type program type local global fp total analysis local nv global fp heap total allroots read fs fi heap object write fs fi alvinn read fs fi heap objects write fs fi read fs fi heap objects write fs fi trie read fs fi heap objects write fs fi bisect read fs fi heap objects write fs fi read fs fi heap object write fs fi anagram read fs fi heap objects write fs fi lex read fs fi heap objects write fs fi ks read fs fi heap objects write fs fi eks read fs fi heap objects write fs fi main read fs fi heap objects write fs fi table dereferenced pointer characteristics fp formal parameter nv local dereferenced pointer type average object type program type local global fp total analysis local nv global fp heap total vor read fs fi heap objects write fs fi loader read fs fi heap objects write fs fi compress read fs fi heap objects write fs fi ft read fs fi heap objects write fs fi football read fs fi heap objects write fs fi compiler read fs fi heap objects write fs fi assembler read fs fi heap objects write fs fi yacr read fs fi heap objects write fs fi simulator read fs fi heap objects write fs fi go read fs fi heap objects write fs fi total read fs fi write fs fi table dereferenced pointer characteristics fp formal parameter nv local tot num objects program analysis type avg max med allroots fs read write functions fi read write loc read write alvinn fs read write functions fi read write loc read write fs read write functions fi read write loc read write trie fs read write functions fi read write loc read write bisect fs read write functions fi read write loc read write fs read write functions fi read write loc read write anagram fs read write functions fi read write loc read write lex fs read write functions fi read write loc read write ks fs read write functions fi read write loc read write eks fs read write functions fi read write loc read write main fs read write functions fi read write loc read write table part precision measurements counting uses gamma 
entry indicates increase precision flow sensitive analysis 
tot num objects program analysis type avg max med vor fs read write functions fi read write loc read write loader fs read write functions fi read write loc read write compress fs read write functions fi read write loc read write ft fs read write functions fi read write loc read write football fs read write functions fi read write loc read write compiler fs read write functions fi read write loc read write assembler fs read write functions fi read write loc read write yacr fs read write functions fi read write loc read write simulator fs read write functions fi read write loc read write go fs read write functions fi read write loc read write total fs read write fi read write read write table part precision measurements counting uses gamma 
entry indicates increase precision flow sensitive analysis 
