expressive power programming languages matthias felleisen department computer science rice university houston tx literature programming languages contains abundance informal claims relative expressive power programming languages framework formalizing statements deriving interesting consequences 
step direction develop formal notion expressiveness investigate properties 
validate theory analyze widely held beliefs expressive power extensions functional languages 
results believe system correctly captures informal ideas expressiveness constitutes foundation research direction 
comparing programming languages literature programming languages contains abundance informal claims expressive power programming languages 
arguments contexts typically assert expressibility non expressibility programming constructs relative language 
unfortunately programming language theory provide formal framework specifying verifying statements 
comparing set computable functions language represent useless languages question usually universal measures exist 
lack comparison relation impossible draw firm expressiveness claims objective decision programming language 
supported part nsf ccr darpa nsf ccr 
landin propose development formal framework comparing programming languages 
studied relationship programming languages constructs began classify essential syntactic sugar 
typical example inessential construct landin sense expression functional language class procedures 
declares initializes new lexically scoped variable evaluating expression 
absent inconsequential programmer expressible apply procedure similarly programmers consider loss goto free algol language repeat construct 
repeat expressible notably reynolds steele sussman followed landin example 
introduced informal notion core language studied expressiveness imperative extensions higher order functional languages 
steele sussman summarized crucial idea kind classification language features number programming constructs expressible applicative notation syntactically local structure behavior preserving translations notably control statements assignments involve complex reformulations large fractions programs 
realm logic kleene anticipated idea expressible eliminable syntactic symbols study formal systems 
troelstra resumed introduced refinements extensions 
roughly additional symbols conservative extension core logic eliminable translation extended logic core satisfies number conditions 
important purposes 
mapping identity formulae core language homomorphic logical connectors 
second formula provable extension translation core 
clearly conditions imply translation preserves structure formulae removes symbols local basis 
adapting ideas relationship formal systems programming languages obtain relation determines programming language express programming construct 
precisely universal programming languages differ set programming constructs fc 
relation holds additional constructs larger language expressive smaller 
expressive means translation program occurrences constructs smaller language requires global reorganization entire program 
analysis shows measure expressiveness supports informal judgements literature 
discover increase expressive power comes expense intuitive semantic equivalence relations 
discuss attempts generalizing measure comparison relation arbitrary programming languages 
section briefly reviews logical notions eliminable symbols definitional extensions 
subsequent sections propose formal model expressibility expressiveness lines logical expressiveness investigate properties analyze expressive powers extensions functional languages 
specifically introduce formal framework expressiveness notion expressibility 
demonstrate concepts proving sample theorems calculus languages number meta theorems 
study expressiveness idealized version scheme verify informal expressiveness philosophy design 
analysis briefly speculate expressive language increases programming convenience 
compare ideas related address open questions 
eliminable symbols definitional extensions theory comparing formal systems peripheral topic logical studies finds little space textbooks 
short overview summarizes adapts troelstra descriptions kleene 
formal system triple sets expressions formulae theorems 
second subset third subset second 
expressions freely generated sense term algebra number non logical logical operators set formulae recursive subset set expressions satisfies certain formedness criteria 
set theorems subset formulae formal system defines true 
formal system exp set expressions fm set formulae thm set theorems means theorem conservative extension formal system formal system expressions superset expressions generated richer set operators formulae theorems restricted expressions formulae theorems fm exp fm thm exp thm 
conservative extension definitional extension mapping exp exp satisfies conditions fm fm fm homomorphic logical operators 
kleene referred symbols generate additional expressions extended formal system eliminable 
weak expressibility 
kleene original definition contains weaker version condition 
condition possible show definitions equivalent assuming usual axioms 
shall discuss remarks case context programming languages 
condition leads different related notion language expressiveness 
formal theory expressiveness step formal theory expressiveness programming languages adapt logical theory eliminable symbols programming language context 
develop idea programming language formal system reinterpret concepts conservative extension accordingly 
examples landin reynolds steele sussman preserve global structure program local structure transformed phrases consider stricter notion second step 
refer second notion macro expressibility 
satisfies additional constraint transformation eliminated phrases compositional 
subsections respective topics prove theorems non programming constructs apply simplistic prototype language calculus 
notions expressibility suggest natural comparative measures expressive power programming languages third subsection 
expressibility formal system programming language system subsets general language 
precisely programming language set phrases subset programs semantics determines aspects behavior programs 
definition 
programming language programming language consists ffl set phrases set freely generated syntax trees terms possibly infinite number function symbols 
arities ffl set programs non empty recursive subset set phrases ffl semantics eval recursively enumerable predicate set programs 
eval holds program program terminates 
function symbols referred programming constructs programming facilities 
definition abstraction typical specifications realistic programming languages 
languages context free syntax enforce additional context sensitive constraints recursive decision procedures 
examples constraints scoping typing rules ensure names occur certain pieces text range restricted set values 
avoid restrictive assumptions set programming languages definition requires semantics observe termination behavior programs 
omitting characteristics results possible consider programming languages observable data 
programming languages simple output data constants opaque representations procedures definition cases equivalent definition refers observable output program 
consideration languages infinite output imperative output statements potentially infinite lists definition needs adjustments 
definition programming language shows certain sense programming language formal system 
set phrases corresponds expressions formal system set programs plays role set formulae set terminating programs analog set theorems 
terminology universal algebra set expressions universe free term algebra relying typical algebraic assume structure infinite set constructors specifying decidability predicates recursiveness translations set phrases 
examples obviously case 
notable exception scheme defined standard report recursively enumerable set programs expression scheme program result possible evaluation orders applications 
consider unfortunate aberration interesting extension definition 
languages impose lexical scoping definition accounts fact recursive selection programs set phrases 
explicit inclusion lexical scoping structure church encoding language typed lambda calculus feasible interesting alternative probably lead slightly different definition expressibility expressiveness 
phrases ee expressions values programs program fv fv set free variables semantics eval holds gamma 
evaluation contexts ff ee reduction steps gamma 
fi gamma 
fi capture free free programming language approach equational restrictions definition uses arbitrary recursive predicates filtering interesting subset programs 
logic programming language world know ubiquitous constructs logical connectors 
prototypical example programming language derivative language pure calculus 
summarizes concrete syntax semantics 
order compare expressiveness call value call name procedures section extend new constructor rename specifically phrases generated set variables ary constructors fx families unary constructors variable term gamma 
term call value abstraction term gamma 
term call name abstraction binary constructor delta term theta term gamma 
term juxtaposition 
denote sets constructors 
readability concrete syntax terms adopt traditional calculus conventions 
constructors bind variable term arguments 
set free variables expression fv set variables bound 
variables term bound term closed set programs set closed phrases recursive constraint distinguishes programs arbitrary phrases 
operational semantics reflects semantics realistic programming languages iswim ml scheme 
specification semantics follows style extensible operational semantics easily adaptable imperative extensions section 
evaluation sequence reduction steps programs normal order strategy 
program value abstraction evaluation stops 
reduction function uniquely decomposes program evaluation context term hole ff redex contents hole 
redex application call name abstraction arbitrary expression fi application call byvalue abstraction value fi 
case reduction function replaces redex new version procedure body 
evaluation process starts 
summarizing standard reduction process predicate programs yields operational semantics useful examples phrases call name call value fixed point operators facilitate recursive definition functions xx xx fx gg gg simple diverging programs omega omega xy xy 
illustrate impact syntactic constraints programs define typed variant set phrases uses type checking algorithm filtering valid programs 
program closed typable integer higher order functional integers type inference system 
easily follows milner initial polymorphism typability recursive predicate semantics programs untyped counterparts 
typical example monomorphic language occurrences bound variable type 
typing constraints exclude typical programs xx phrases xx programs 
operator defining recursive functions typed explicitly pass type rules 
interpretation programming language formal system easy define notion conservative programming language extension 
definition 
conservative extension restriction programming language conservative extension language ffl constructors subset constructors difference ff 
constructors usual operational semantics remote connections equational theory calculus 
programs program closed types gamma 
type assertion variables gamma ffi types finite functions functional update type inference gamma 
gamma 
ee gamma 
gamma 
gamma 
gamma 
gamma 
gamma 
gamma 
ffl set phrases full subset phrases contain constructs ff 
ffl set programs full subset programs contain constructs ff 
ffl semantics eval restriction semantics programs eval holds eval holds 
conversely conservative restriction emphasize constructors restriction extension differ write ff 
ff 
notation denote natural restriction extension result subtracting adding facilities syntax provided respective languages case semantic specification exist 
running example restricted language abstractions call name abstractions restriction evaluation process phrases yields call byvalue call name semantics respectively 
corresponding sublanguages defined similarly 
enrich set examples add construct binary constructor variable term theta term gamma 
term 
binds variable second subexpression 
concrete syntax semantics short requires additional clause specification evaluation contexts 
additional clause reduction function gamma 
definition semantic predicate stays 
trivial check conservative extension extension additionally requires type inference rule new construct 
greater flexibility new rule requires occurrence abstracted variable named subexpression typable type polymorphic spirit ml 
bound variables bound variables types 
example xx conceptually assumes different types gamma 
gamma 
gamma 
gamma 
expression legal program despite self application variable 
easy see extension conservative respect re interpretation logical notion need flexible 
non existence ubiquitous programming language features sense logical connectors raises question mapping extended language core homomorphic set features 
point recall mentioned desire translations idea homomorphic character translation naturally corresponds property 
preserve structure programs possible require translations homomorphic programming facilities core language 
definition 
expressible programming constructs programming language ff 
subset constructors 
conservative restriction 
programming facilities 

eliminable recursive mapping phrases phrases satisfies conditions program programs 

facilities homomorphic constructs eval holds eval holds programs say express facilities 

respect omit qualification language universe clear context 
abuse notation write gamma 
condition definition implies mapping identity language corresponds conditions logical notion 
interpretation programming language formal system interpretation condition section requires translation terminating program extended language terminating program restricted language 
precisely contents condition 
condition logical notion counterpart programming language context lack ubiquitous programming construct 
weak expressibility 
adaptation kleene original condition see previous section third condition preceding definition get weak notion expressibility 
revised condition takes shape eval holds eval holds intuition definition translated phrase capabilities original 
terminology reflects belief differences behavior noted failure complete expressibility 
terminology consistent fact expressibility implies weak expressibility 
alternative understanding definition translation maps phrases constructed eliminated symbols observationally indistinguishable phrases smaller language 
words replacing original phrase translation affect termination behavior surrounding programs 
relation phrases programming languages widely studied semantics known operational observational equivalence 
developing formal definition operational equivalence characterize sufficient conditions programming constructs 
formal definition operational equivalence relation relies auxiliary notion program context 
definition 
contexts program contexts ary context ff 
ff freely generated tree constructors additional ary constructors ff 
ff called meta variables 
subtrees ff 
ff ary contexts 
ff 
ff context 
phrases instance 
phrase ff 
ff occurrences ff contains phrase ffl ff 
ff ff 
ffl ff 
ff ff 
ff 
ff 
ff arity 




program context phrase unary context ff program 
context ff xy ff omega program context expressions free variables semantic predicate programming language tests program termination behavior definition operational equivalence compares termination behavior programs 
definition 
operational equivalence programming language eval operational semantics 
phrases operationally equivalent contexts program contexts contexts ff eval holds eval holds 
program context possible example differentiate phrases omega diverges xy omega terminates xy omega diverges 
contains sequent calculus operational equivalence proposition proof system similar riecke typed version 
calculus proves equations language premisses gamma finite sets equations 
sound incomplete vice versa 
weak expressibility 
replacement condition simple condition yields notion operational approximation plays role weak expressibility operational equivalence expressibility 
specifically term operationally approximates program contexts ff eval holds eval holds 
conjunction context program context ff yx ff omega shows approximate 
cases definition equivalent traditional definition compares termination behavior programs results provided set observable data 
gamma gamma omega omega gamma omega omega gamma gamma fv gamma gamma gamma ee gamma gamma gamma gamma omega omega gamma gamma fv gamma gamma fe gamma fe omega gamma fe vg gamma gamma gamma gamma gamma gamma gamma calculus operational equivalence place formalize idea connection eliminable programming constructs translations 
theorem shows extent elimination expressible programming constructs program local process keeps program structure intact 
theorem ff 
conservative extension gamma 
homomorphic facilities preserves program ness 

expressions 
express facilities 

proof 
suffices show condition definition holds 
assume program eval holds 
construction context ff 
ff 

finite number outermost occurrences phrases constructed facilities 

ff 
program context follows theorem assumption eval 
holds eval 
holds repeating step times proves eval 
holds eval 
holds contain facilities 


conservatively extends eval holds eval holds completes proof 
weak expressibility 
theorem holds weak expressibility replace operational equivalence operational approximation 



weakly eliminable 
application theorem shows example eliminable construct 
typed setting provides precise formalization folk theorem ml style polymorphism expressible monomorphic language 
examples reveal striking difference typed untyped language variant 
untyped expression simply abbreviates application illustrated typed counterpart maps version body occurrence abstracted variable substituted copy named expression 
reason difference typed case translation preserve semantics typability order preserve program ness 
proposition constructor eliminable call value languages 
express respect 
ii express respect 
proof 
set 
show phrases operationally equivalent proceed induction number subexpression 
base case proceeds follows 
homomorphism constraint laws omega omega values alternative approach formalization folk theorem due wand 
induction step proceeds line 
ii set occur free verify translation maps programs programs suffices prove translation preserves implicit type assignment 
proceed induction number expressions program show fixed set type assumptions type assume free consider typing instance setup inference system assumption rest follows easily gamma 
induction step requires lemma proves type type proof preserves semantics typed programs follows pattern part 
observe omega omega omega rest obvious 
converse theorem hold 
facilities 

may expressible translation maps eliminable phrase observably distinct element 
reason set programs may contain element 
occurs context restricted language case irrelevant mapping translates phrase 
imposing appropriate condition get theorem non expressibility programming constructs 
theorem ff 
conservative extension mappings gamma 
homomorphic facilities 

expressions 

context ff witnesses inequality express facilities 

proof 
gamma 
arbitrary mapping homomorphic facilities suppose 
ff context observes operational difference 

homomorphic 

assumption eval 
holds eval eval hold vice versa 
implies mapping homomorphic possibly satisfy condition definition antecedent theorem holds consequently programming constructs 

eliminable 
non expressibility theorem prove call name express call value abstractions vice versa 
proposition extends 
express respect 
ii express respect proof 
semantics application abstraction argument proceed manners 
may uniformly diverge arguments gamma 
gamma 

may uniformly converge value arguments including omega expressions value gamma 

may activate argument time gamma 
ee 

proof auxiliary claim simple induction length reduction sequence 
easy check gamma 
gamma 

abstraction converges application values 
specifically assume value gamma 
claim ff ff context looking order apply theorem 
assume gamma 
structure preserving translation 
reduces value value 
original abstraction terminates application value translation application terminate 
diverge uniformly 
hand pre image diverges application omega implies improved carolyn talcott 
translation converge uniformly 

expressions gamma 
gamma 

setting omega satisfy original trivial see program diverges 
reduction continues 
gamma 
omega gamma omega gamma 

gamma 
omega 
gamma omega 
gamma 
converges diverges 
preceding theorem shown claim 
ii part simpler 
take ff ff omega assume structure preserving translation 
clearly eval holds diverges 
structure preserving translation preserve operational equivalence proves claim 
weak expressibility 
weakly express immediate corollary theorem phrase eliminable symbol operationally indistinguishable expression restricted language restricted language expressive full language 
corollary full theorem section 
corollary ff 
conservative extension 
program context 
express facilities 

macro expressibility definition eliminable programming construct satisfactory step better understanding formal structure programming languages completely account idealized notion syntactic sugar landin discussed 
cases elimination syntactic sugar constructs preserves global program structure structure subexpressions phrases built eliminable constructs 
recall examples 
functional language class functions expression simply abbreviation immediate application anonymous procedure argument expressible apply procedure 
goto free algol language repeat expressible examples translation composite phrase fixed composition translation subphrases 
technically translation phrase evaluation term sense universal algebra restricted language translations subphrases 
mentioned terms correspond contexts framework clarity refer contexts syntactic abstractions relation definition uses 
definition 
macro macro expressibility programming language ff 
subset constructors ff 
conservative restriction 
programming facilities 

macro eliminable eliminable eliminating mapping satisfies additional condition ary construct ff 
exists ary syntactic abstraction 

say macro express facilities 

respect weak expressibility 
facilities weakly expressible satisfy additional condition call weakly macro expressible 
macro expressibility restriction simple expressibility theorem constructs requires adaptation 
theorem ff 
conservative extension gamma 
homomorphic facilities preserves program ness syntactic abstraction 



expressions 
macro express facilities 

lisp languages syntactic abstractions realized macros logical frameworks know notational abbreviations 
terminology equational algebraic specifications refers syntactic abstractions derived operators 
proof 
easy see additional condition antecedent precisely needed adapt proof theorem stronger 
additional condition permits simplification theorem corollary longer translating map 
corollary section 
corollary ff 
conservative extension syntactic abstraction 



expressions 
macro express facilities 

proposition express 
simple check proof reveals translation languages satisfies antecedent corollary macro expressible 
importantly additional condition definition leads stronger meta theorem non expressibility facilities 
new theorem shows new programming constructs add expressive power language addition affects existing operational equivalences 
theorem ff 
conservative extension operational equivalence relations respectively 
operational equivalence relation restricted expressions equal operational equivalence relation jl macro express facilities 

ii converse hold 
cases express facilities 
operational equivalence relation restricted identical operational equivalence relation jl 
proof 
eval eval respective evaluation predicates 
difference restricted operational equivalence relation implies phrases case ff context differentiate phrases say loss generality eval holds assume contrary claim theorem express facilities 

mapping gamma 
satisfies conditions extension equivalence relation larger language called conservative restriction old syntax yields original equivalence relation 
avoid confusion terminology 
definitions 
conditions programs counterparts termination behavior eval holds eval holds eval hold eval hold 
conditions programs differ finite number occurrences words program context ff proof see translation lemma 
assumption follows termination behavior eval holds eval holds contradicts fact converges diverges concludes case 
second case assume assumption implies contexts complete programs 
context ff eval holds eval 
conservative extension eval holds eval contrary assumption assume contrary claim theorem express additional facilities appropriate translation gamma 
operationally equivalent context ff eval eval 
assumption eval eval 
translation lemma translated programs instances program context ff 
fact context exist arrived contradiction 
concludes second case claim 
finish proof claim show homomorphic function preserves structure program 
translation lemma 
gamma 
translation satisfies conditions definitions 
ff context context ff 
proof 
proof induction structure ff 
interesting case 
say ff ff 
ff 





fixed syntactic abstraction condition 
inductive hypothesis contexts ff 
ff ff 
ff context corresponding ff 
cases similar easier 
lemma proof translation lemma finishes proof case 
ii sketch construction example proves claim ii 
example interesting fits smoothly see subsection control structure idealized scheme 
base language take simply typed calculus fixed point operator types base types arrow types 
type system impossible define typical cons car cdr functions pairs values arbitrary types 
simply typed language express functions 
hand due type system language new functions bound free variables phrases sublanguage implies additional functions pairs distinctly typed components distinguish phrases simply typed language 
follows pairing functions selectors increase expressive power destroying operational equivalences underlying language 
theorem show sublanguage strong macro express call name abstraction strong macro express call value abstraction 
proofs utilize half proof claim 
proposition extends 
macro express respect 
ii macro express respect proof 
claims obviously consequences proposition 
direct proof claim derived theorem ong thm 
preceding meta theorem 
consider phrases yk omega yk yk omega gamma yk 
equivalent adequate model operationally equivalent yk omega yk yk omega gamma yk operational reasoning verification equivalence follows 
matter argument procedure evaluates expression yk eventually appears hole evaluation context leads immediate termination program evaluation 
gordon plotkin pointed abramsky ong lazy calculus corrected mistake early draft 
full language analysis longer holds call value procedures evaluate discard expression yk way affect rest program 
context ff ff distinguish phrases yk omega yk terminates yk omega gamma yk diverges 
theorem express 
ii consider expressions omega omega gamma pure call value setting operationally equivalent omega omega abstractions values application arbitrary value diverge 
formal proof straightforward proof rules 
extended language differentiate context ff ff context applies phrase function returns value argument absorbing second argument evaluating 
omega gamma terminates omega gamma diverges proves extension preserve operational equivalence relation 
theorem expressible 
weak expressibility 
proof proposition show theorem carry weak expressibility weakly macro express case language extension preserve operational equivalence approximation relation restricted language may able express new facilities weak sense 
second application theorem show polymorphic construct macro expressible hand lemma confirms folk knowledge polymorphic adds expressive power typed programming language 
contradict proposition shows polymorphic expressible monomorphic language 
hand lemma provides example interesting facility expressible macro expressible relative language 
proof relies second part claim meta theorem 
proposition macro express respect 
proof 
consider expressions gx ff gx ff gx 
contain self application variable program context expressions programs operationally equivalent gx ff gx ff gx dynamic behavior 
difference programs second computes application twice throwing away result vacuous abstraction gx omega gx ff omega gamma ff omega gx ff omega gx ff gx values gx gx ff ff gx ff gx ff gx extended language variable bound appropriate context program fragments equivalent gx ff gx ff gx inequality proves proposition 
propositions provide examples pairs universal programming languages differentiate expressiveness criterion 
full language provides example language express come point formally distinguish expressive power programming languages 
expressiveness notions expressibility simple comparison relations languages conservative extensions 
comparison arbitrary programming languages relations weak 
solution conceive programming languages signatures types sense universal algebra classes real programming languages 
possible compare languages comparing signatures signature happens conservative extension 
appealing glance idea relaxes syntactic constraints languages syntax 
alternative solution consider common language universe conservative extension programming languages 
common universe fixes meaning number interesting programming constructs natural extension notion expressibility notion relative expressive power 
intuitively programming language expressive express facilities express language universe 
definition 
macro expressiveness conservative language restrictions macro expressive respect contains macro express set constructs contains macro express additional facilities 
expressiveness relation obviously pre order sublanguages language framework monotonic third argument provided extension universe conservative 
theorem conservative restrictions conservative restriction 
expressive respect 
ii expressive respect expressive respect expressive respect 
iii expressive respect expressive respect proof 
proof easy calculation verifying conditions definitions 
uniform change languages change expressiveness relations 
theorem expressiveness relationships invariant uniform extensions languages 
proof 
simple example consider recall sublanguages incomparable propositions 
prove claim uniformly add construct evaluates expressions sequence discards value 
formal specification requires extension set evaluation contexts 
additional reduction clause gamma 
macro express add power macro expressible xy extended setting expressive 
claim valid new facility language universe 
take example add xy abramsky convergence tester sub languages equivalent adding 
example preceding theorem formalizes algol definition call byvalue abbreviation call name procedure preceded additional block statement pure call name subset algol define call value extension thereof includes strict facility 
theorem shows dangerous informal claims call name express call value claims tend true specific language universes specific conservative language restrictions validity contexts 
syntax gamma gamma 
numerals 
gamma gamma numeric functions constants lambda 
abstractions values variables 
applications semantics eval holds iff gamma 
evaluation contexts ff 

reduction steps fv gamma 
ffi ffi 
defined lambda 

gamma 

constant interpretation ffi ffi gamma gamma ffi ffi gamma gamma ffi lambda ffi lambda pure scheme structure idealized scheme pure scheme simple functional programming language 
multi ary call byvalue procedures algebraic constants 
basic constants functional constants 
plotkin assume existence partial function ffi functional constants closed values closed values specifies behavior constants pure scheme extensions 
typically constants include integers characters booleans appropriate functions contains appropriate definition ffi 
order gain complete understanding idealized scheme pure scheme contains integers minimal set functions integers elements expressible calculus language contains complete specification pure scheme reduction semantics style previous section 
scheme programs satisfy contextsensitive definitions closed expressions contain lambda abstractions repeated parameter names 
predicate eval holds program program reduces answer values case pure scheme 
eval hold program program infinite loop reduction process stuck 
pure scheme evaluation stuck application constant symbol expression application numeral value application constant function value ffi undefined application lambda abstraction wrong number arguments 
reduction rules pure scheme constitute basis proof systems operational equivalence relation spirit 
brevity shall carry proofs section informal setting clear proofs formalize various steps 
subsections ps denotes operational equivalence relation pure scheme indexes correspond extensions pure scheme self explanatory 
main characteristic idealized scheme extension functional core language pure scheme type predicates local branching constructs imperative facilities ffl branching expressions local manipulation control ffl predicate constants determining type value ffl control operators non local manipulation control ffl assignment statements manipulation state variables 
extensions reflect belief constructs increase expressive power language 
section demonstrate formulate beliefs formal macro expressiveness framework 
subsection simultaneously deals local control type predicates sets constructs closely related 
second subsection study different control operators stopping execution program handling general flow control 
third subsection shows imperative assignments add expressive power core language 
common practice semantic considerations realistic specification consider error mechanism 
error mechanism introduces additional expressive power reason consider separately 
subsection addresses unrelated issue pure scheme relates called lazy functional languages precisely call value languages callby name data constructors 
hope reconcile proposition call name abstractions pure scheme widespread belief lazy data constructions available higher order value languages 
local control dynamic types programming language world knows types local branching statements boolean value construct distinguishing values lisp style construct distinguishing special value 
semantics relies presence distinct values false true 
assuming extension set evaluation contexts 
bif additional reduction rules characterize behavior truth value bif bif gamma 
bif true bif gamma 
bif false test value bif expression evaluation program undefined equivalently bif expression operationally indistinguishable diverging expression 
extension obviously conservative refer ps bif 
clearly pure scheme express simple bif 
proposition pure scheme macro express bif 
proof sketch 
proposition follows corollary basically due landin burge realized vacuous lambda abstractions suspend computations 
consider syntactic abstraction bif ff ff ff lambda thn els 
gamma thn 
els lambda omega gamma ff lambda ff lambda ff easy show abstraction operationally equivalent bif 
replacement ff expressions diverge 
expressions select replacements ff ff eliminates 
right hand side accomplishes suspending expressions ary procedures invoking selection 
weak expressibility 
extension pure scheme bif distinct new values true false macro eliminable 
map true term pure scheme implies programs bif true bif map image fixed syntactic abstraction impossible translation preserves program behavior program terminates second diverges 
clearly bif weakly expressible translation force programs terminate 
typed version pure scheme problem disappear 
type system admit program ill typed bif expression 
put differently typed version pure scheme admits fewer programs expressiveness propositions stronger 
lisp style assumes distinct value false lisp usually called nil values represent true 
serving false reduction rules differ accordingly bif true bif false lif gamma 
lif lif gamma 
lif nil proposition pure scheme macro express lif 
proof sketch 
readability carry proof ps bif 
bif macro expressible proposition operational equivalences terms hold pure scheme expanding bif expressions 
proposition consequence theorem 
interesting operational equivalence context ff bif lambda omega gamma bif ff omega gamma pure scheme evaluation instance context reach replacement ff 
bound procedure evaluation process diverges invocation lambda omega gamma assume replaced procedure 
rest proof proceeds case analysis property procedures procedure argument may ignore argument return constant result apply constant function symbol argument argument procedure position application 
evaluation ff reach ff procedure return different results lambda omega gamma 
consider alternatives 
hand applies functional constant pure scheme argument application lambda omega gamma diverges 
uses argument procedure evaluation diverges test position 
short evaluation diverges test position procedure produces result independent argument 
cases imply evaluation reduce redex replacement ff 
follows inconsequential ff represents 
ps omega gamma larger setting ps lif preceding analysis hold 
context ps lif bind variable procedure lambda lif distinguish arguments lambda omega gamma correct manner lif omega gamma alternative addition lif dynamically typed languages generally include type predicates 
extending pure scheme predicate symbol int suffices extend interpretation function ffi clauses ffi int lambda ffi int lambda 
lambda extension ps int clearly conservative 
int programs extended language effectively test type value int 
express lif 
follows int 
expressible pure scheme 
proposition pure scheme express int 
ii ps int 
express lif 
proof sketch 
proof illustrates reduction proofs framework expressiveness 
ps int 
macro express lif lif ff ff ff bif cand int 
ff 
gamma ff ff ff cand ff ff bif ff ff bif expressed proposition 
second ps int 
express lif stronger pure scheme preceding proposition 
converse hold lisp style lif distinguish values arbitrary integer class procedures 
proposition ps lif macro express int 
proof sketch 
proof proceeds lines proof proposition 
applying procedure variable modified context invokes ff bif lambda omega gamma bif ff omega gamma analysis uses reasoning proposition exception procedure argument may appear test position lif expression 
evaluation instance reach replacement ff procedure may invoke argument may submit constant function test lif expression 
irrelevant lambda omega gamma cause lif expression take branch 
lif omega gamma int 
language longer case int 
omega gamma putting see pure scheme handle types local branching decisions 
simple boolean valued construct expressible 
typical lisp style adds expressive power distinguish integer value values domain predicate int 
permits distinction integer value class values 
additional syntax 
call cc continuation captures abort program stops additional reduction steps call cc gamma 
lambda abort abort gamma 
pure scheme control non local control interesting expressiveness constellation arises context non local control abstractions 
idealized scheme operations abort call cc 
facility abandons current evaluation context realizing simplistic form error handling 
applies subexpression abstraction current control state permitting arbitrary manipulations flow control 
name stands call current continuation scheme terminology refers abstraction control state continuation analogy denotational semantics 
specifies syntax simple reduction semantics pure scheme control operators 
refer entire extension ps control denotes operational equivalence 
interesting conservative restrictions ps control ps abort pure scheme abort ps call cc pure scheme call cc respective operational equivalences 
semantics trivial verify extensions conservative pure scheme 
semantics forms basis simple equational calculus abort call cc permits simple algebra reasoning programs control operations 
languages expressive pure scheme 
proposition pure scheme macro express non local control constructs pure scheme macro express abort call cc relative ps abort ps call cc ps control 
proof sketch 
proof relies theorem addition abort call cc invalidate operational equivalences pure scheme 
typical example operational equivalence lambda omega gamma ps lambda omega gamma argued proof proposition procedures equivalent functional setting diverge applied value 
easy check argument holds pure scheme 
abort call cc contexts invalidate equivalence 
examples ff lambda abort call cc ff 
composition expression contexts evaluates second expression diverges contexts lambda omega gamma lambda omega gamma ranging natural question control operations related provide distinct facilities 
proposition shows idealized scheme independent enhancements expressive power core language 
example folk theorem example theoretical continuation community meyer riecke argue continuations 
non expressibility abort appears artifact modeling scheme 
realistic model scheme systems opposed scheme semantics include interactive loop provides delimiter control actions 
including appropriate version delimiter ps control abort macro expressible combination call cc control delimiter 
put differently interactive programming systems add expressive power programming language 
peter lee personal communication pointed example phenomenon addition read eval print loop introduces true non eliminable polymorphism language providing top level declarations open ended body expression 
fact interactive programming environments add power underlying languages suggests specified part language standards 
proposition control constructs abort call cc express ps abort macro express call cc respect ps control 
ii ps call cc macro express abort respect ps control 
proof sketch 
proof claim shows call cc destroys operational equivalences ps abort 
typical example omega gamma ff bif lambda omega gamma bif lambda ff omega gamma omega gamma terms differ procedure invokes argument invocation return result 
ps abort impossible expressions produce value diverge abort 
body argument lambda omega gamma aborts diverges certainly return value 
adding call cc context binds lambda call cc distinguish term omega gamma omega gamma ii second claim consequence corollary program abort expression impossible find operationally equivalent call cc 
program lambda omega gamma abort composition context lambda omega gamma ff ps call cc abort expression 
absence operationally equivalent expression abort ps call cc follows property expressions restricted language eliminate evaluation context 
technically program ps control occurrences abort expressions form abort gamma 
omega gamma proof auxiliary claim routine induction statement gamma 
value contains stuck redex gamma 
satisfies condition 
expression ps call cc contain abort expression vacuously satisfies antecedent auxiliary claim 
diverges returns value interchanged abort expression effect behavior ps control program 
existence program contains abort non existence operationally equivalent expression follows ps call cc express abort ps control 
preceding proposition establishes formal expressiveness relationship control operators idealized scheme provides concrete example second claim theorem 
theorem restated ff 
conservative restriction operational equivalence relations respectively 
ii converse hold 
cases express facilities 
operational equivalence relation restricted identical operational equivalence relation jl 
proof 
preceding proposition know ps call cc express abort 
finish proof need prove operational equivalence relation ps call cc subset operational equivalence relation ps control call cc direction obvious 
assume prove suppose context distinguish ps control 
context context ps call cc result immediate 
contains number abort expressions exists context ff ff 
ff ff ff abort 
abort variable occur context defined follows ff call cc lambda lambda ff lambda 
lambda show eval holds eval holds 
program evaluates intermediate program administrative steps gamma 
lambda abort lambda 
lambda abort lambda second generalized version call value fi axiom lambda abort lambda abort lambda abort lambda 
lambda abort lambda terminates abort 
abort terminates 
analysis holds program shown context ff distinguishes summary shown ps control extends ps abort ps call cc respect expressive power individually extend pure scheme 
interesting point extension ps abort ps control qualitatively different extension ps call cc ps control 
expect point topic investigations 
assignments final addition pure scheme set construct scheme form assignment statement 
traditional algol programming language set expression destructively alters binding identifier value 
simple reduction semantics ps state pure scheme set 
letrec recursive declarations variables initial values 
clearly ps state conservative extension pure scheme new semantics basis equational calculus reasoning operational equivalences ps state 
proposition pure scheme express set 
letrec 
proof sketch 
consider expression lambda contains subexpression twice 
functional language pure scheme subexpressions return value value subexpression discarded expression operationally equivalent lambda ps verification equivalence proof system straightforward 
extended language longer true 
consider context ff letrec lambda set 
lambda omega gamma ff transformation homomorphic translation changes top level structure program 
translation encode program integer interpreter function integers restricted language computable functions express feature allowed global changes programs 
additional syntax 
set 
assignments letrec 
recursive definitions extended semantics eval holds iff gamma 
letrec gamma 
letrec 
additional evaluation contexts 
set 
additional reduction steps letrec 
fv gamma 
letrec 
ffi provided ffi 
defined letrec 
lambda 
gamma 
letrec 


assignable 
assignable letrec 

gamma 
letrec 

letrec 

set 
gamma 
letrec 

letrec 
letrec 
gamma 
letrec 

pure scheme state declares procedure application procedure modifies declaration second invocation leads divergence 
consequently expression single function converges expression uses diverges lambda set 
surprisingly assignments increase expressive power idealized scheme 
proof add scheme form assignment equivalent cells destructive update operation domain predicate 
non evaluating constructors functional languages call name parameter passing protocol pure scheme call value technique 
alternatively languages offer data constructors say cons evaluate arguments 
widely held belief provisions superfluous presence higher order procedural abstractions 
evaluation contexts ff 

additional reduction steps cons gamma 
cons gamma 
pure scheme cons shown previous section call value languages express callby name abstractions 
result holds extended framework pure scheme 
non evaluating data constructors bit subtle 
study issue thoroughly consider different conservative extensions pure scheme incorporates different form callby name constructor 
extension ps lazy provides constructor class function 
cons call name cons cons lazy values simplicity lazy values functions serve selector arguments 
contains corresponding extension reduction relation 
equivalent full call name abstractions addition single call name primitive introduces new semantic capabilities 
proof statement easily derivable proposition 
second extension ps delayed restriction 
non evaluating constructor longer class function available order form 
cons lazy values reduction relation remains 
restricted extension expressible pure scheme 
proposition pure scheme macro express cons relative ps delayed 
proof 
desired syntactic abstraction cons ff ff lambda bif 
gamma ff bif 
gamma gamma ff omega gamma easy check corresponding translation satisfies reduction clauses original functions 
result follows corollary 
weak expressibility 
extended language contained selector functions lazy values new values weakly expressible reason bif true false weakly expressible see 
conciseness conjecture programming language represent computable functions integers contains functionally equivalent counterpart program expressive language 
raises question advantages programming expressive language equivalent programs simpler language exist 
definition expressible construct programs expressive language generally globally different structure functionally equivalent programs expressive language 
really say programming expressive languages 
studying number examples come programs expressive languages exhibit repeated occurrences programming patterns pattern oriented style detrimental programming process 
illustrate point presenting examples 
example compares equivalent programs variants full scheme scheme assignment 
consider program fragment 
lambda counter 
set 
add body 

program binds variable procedure handles transactions simultaneously counts transactions performs 
procedure accomplishes counting allocating local variable private scope initial value 
subsequent proper transaction comparison part folklore expressiveness discussion particular example adapted previous equational semantics assignments 
procedure uses assignment increase 
special transaction appropriate type check number past transactions 
program pure scheme functional language assignments realize counting transactions different way 
example program fragment rewritten code 
lambda counter 
cons add body 
result car result cdr result 
functional version program declares variable transaction counting scope transaction manager procedure takes current value counter additional argument 
completion transaction returns pair component increased counter value second component proper result transaction 
calls pass current value extra argument 
call site additional code disassemble result desired way 
functional version offers opportunities code simplifications 
specifically call site transaction procedure immediately update counter transaction proper transaction return value counter transaction causes check number previous calls 
lambda body 
add 
simplifying functional version possible contains large number repeated occurrences add expressions call site distributed program 
second example concerns control operators 
imagine large functional program consisting modules 
interfaces modules fully formal specifications form variants parameter descriptions 
suppose extension program requirements modules needs capability execution revised program 
functional setting task accomplished converting relevant parts program simplified continuation passing style 
specifically function transitively uses critical module passes functional abstraction rest computation critical module call sites position return needs done 
critical module continue execution rest program 
necessary module discards additional argument invokes argument intermediate result 
programming style requires fundamental changes original non program 
interface critical module indicate possibility module abort program execution 
second importantly code call site function connections critical module satisfy special conditions 
example alternatives lack non expressible facility time abort operation causes occurrence programming patterns entire program 
examples similar flavor come believe major negative consequence lack expressiveness abundance programming patterns missing non expressible constructs 
clearly specific conjecture issue address question programs benefit additional expressive power larger languages 
relatively naive answer improved programs non expressible constructs sensible observable manner 
example scheme program assignments sensibly function assignment statement occurs procedure entry affects parameter 
formal approach notion observable manner idea program sensible additional feature context witness operational distinctions phrases restricted language 
despite lack definition sensible uses constructs programming patterns venture formulate conjecture expressive programming languages 
conciseness conjecture 
programs expressive programming languages additional facilities sensible manner contain fewer programming patterns equivalent programs expressive languages 
disturbing consequence programming patterns obstacle understanding programs human readers programs 
example global program analysis verify add expressions really count number transactions 
worse distinct explanations continuation passing style subprogram call name functional setting may implement sophisticated control structure may implement call value protocol 
thorough analysis details continuation passing program fragment reveal true purpose occurrence programming patterns 
main benefit expressive languages ability programming patterns simple statements state purpose program possible manner 
related earliest attempt defining comparing expressive power programming languages comparative chandra hewitt manna paterson early mid seventies 
studies programming languages simple set control constructs loop programs recursion equations uninterpreted constant function symbols 
predicate logic arithmetic possible decide certain questions uninterpreted program schemas 
languages universal sense compare set functions computable different sets control constructs interpretation subset function symbols operations data structures stacks arrays queues 
presence full arithmetic representations integers addition multiplication function approach longer compare expressive power programming languages encoded functions computable 
second approach due fortune 
basic observation statically typed languages facilities constructing diverging programs encode subset total computable functions 
example simply typed calculus language define elementary recursive functions second order version calculus comprises ffl elementary recursive functions 
approach crucially relies fact languages consideration universal 
approaches illuminate issues expressiveness data type structures applicability programming languages impossible equating expressiveness computational power uninteresting programmer perspective 
hoare proposed classifying programming languages equational inequational laws programming constructs satisfy 
illustrates idea collection examples 
laws denotational semantics generally sound respect operational equivalences 
theorems connect expressiveness validity operational equivalences programming languages approach related attempt formalizing comparing expressiveness languages 
williams looks spectrum formalization techniques semantic conventions formal systems particular programming languages 
starts ideas applicative definitional extensions formal systems considers techniques relevant computational settings compilation interpretation 
goal williams research comparison formalization techniques study expressiveness programming languages 
results may relevant extensions 
secondary piece related study full abstraction property mathematical models representability functions calculi 
cases natural denotational model programming language contains elements operationally equivalent phrases different mathematical meanings 
relatively easy reverse engineer programming language model equality relation models full abstraction property directly corresponds operational equivalence conservative extension 
consequence models naturally lead discovery non expressible programming constructs 
framework calculus languages facilities multiple argument functions require values arguments determine result 
study full abstraction provide true insight expressive power languages 
hand discovery new facilities directly depends choice model 
example direct model requires mentioned facility exploiting deterministic parallelism continuation model leads operations continuations restrictions operations 
hand theorem know change operational equivalence relation sufficient necessary condition programming construct 
short research full abstraction valuable contribution replacement study expressiveness see proposition 
formal programming language design space preceding sections developed ideas formal framework comparing expressive power programming languages 
informal claims literature argued ffl key programming language comparisons restriction set admissible translations programming languages 
specifically proposed ffl translations languages preserve program structure possible 
application principle conservative language extensions produced number criteria deciding additional operators increase expressive power 
concrete example considered language extensions pure scheme simple functional programming language formal expressiveness results close intuitive ideas literature 
important criterion comparing programming languages showed increase expressive power may destroy semantic properties core language programmers may accustomed theorem 
things invalidation operational laws language extensions implies distinctions considered semantic analyses expressions core language 
hand expressive languages facilitate programming process making programs concise conciseness conjecture 
put result says ffl increase expressive power related decrease set natural mathematically appealing operational equivalences 
interesting challenge find expressive extensions languages additional facilities invalidate operational laws 
current framework step formal programming language design space 
hand investigate comparison relation arbitrary languages depth judge general usefulness 
hand set restrictions language translations clearly interesting basis comparing programming languages 
entire spectrum feasible restrictions yield alternative notions expressiveness alternatives deserve exploration 
tackled problem deriving properties expressiveness claims expect 
long run hope theory language expressiveness develops formal theory programming language design space theory help programmer selecting right set constructs solving problem 

dan friedman directed attention idea expressiveness insisting understanding new programming constructs terms procedures macro implementations superior implementation interpreters 
conversations bruce duba mitchell wand provided motivation direction 
bob harper pointed relationship logic ultimately led current formalization 
tim griffin original approach focused macro expressiveness redirected efforts broader framework expressiveness section 
hans boehm robert confused compiler annotations preserve operational equivalences increase expressive power language futures indicating opportunities parallel evaluations single threaded destructive updates functional languages 
cartwright dan friedman robert hieb john lamping scott smith rebecca carolyn talcott mitchell wand numerous patient seminar students suggested improvements presentation material 
due carl gunter university pennsylvania peter lee carnegie mellon university carolyn talcott stanford university giving opportunities expose ideas wider audience writing form 
comments members popl committee anonymous referees esop special issue science computer programming exposed weaknesses early drafts 

abramsky lazy calculus 
declarative programming turner ed 
addison wesley 

baker hewitt 
incremental garbage collection processes 
proceedings symposium artificial intelligence programming languages 
sigplan notices 

barendregt lambda calculus syntax semantics 
revised edition 
studies logic foundations mathematics 
northholland amsterdam 

berry de evaluation des expressions 
proc 
rd international colloquium programming 


course universal algebra 
springer verlag berlin 

chandra manna 
power programming features 
journal computer languages pergamon press 

church formulation simple theory types 
journal symbolic logic 

felleisen calculi lambda cs conversion syntactic theory control state imperative higher order programming languages 
ph dissertation indiana university 

felleisen theory practice class prompts 
proc 
th acm symposium principles programming languages 

felleisen friedman 
control operators secd machine calculus 
formal description programming concepts iii edited wirsing 
elsevier science publishers 
north holland amsterdam 

felleisen friedman 
syntactic theory sequential state 
theor 
comput 
sci 

preliminary version proc 
th acm symposium principles programming languages 

felleisen hieb 
revised report syntactic theories sequential control state 
technical report rice university june 
accepted tcs 
felleisen friedman kohlbecker duba 
syntactic theory sequential control 
theor 
comput 
sci 

preliminary version proc 
symposium logic computer science 

fortune leivant donnell 
expressiveness simple second order type structures 
acm 

friedman wise 
cons evaluate arguments 
automata languages programming michaelson milner eds 
edinburgh univ press 

goguen thatcher wagner 
initial algebra approach specification correctness implementation data types 
current trends programming methodology iv edited yeh 
prentice hall englewood cliffs new jersey 

griffin notational definition formal account 
proc 
symposium logic computer science 

guzm hudak 
single threaded polymorphic lambda calculus 
proc 
symposium logic computer science 

halstead multilisp language concurrent symbolic 
acm trans 
program 
lang 
syst 


hoare varieties programming languages 
proc 
international joint conference theory software development 
lecture notes computer science springer verlag berlin 

kleene metamathematics van nostrand new york 

kohlbecker syntactic extensions programming language lisp 
ph dissertation indiana university 

landin calculus approach 
advances programming computation edited fox 
pergamon press new york 

landin programming languages 
commun 
acm 

meyer semantical paradigms 
proc 
symposium logic computer science 

meyer riecke 
continuations may unreasonable 
proc 
conference lisp functional programming 

milner theory type polymorphism programming 
comput 
syst 
sci 


milner tofte harper 
definition standard ml 
mit press cambridge massachusetts london england 

morris lambda calculus models programming languages 
ph dissertation mit 

naur 
ed 
revised report algorithmic language algol 
commun 
acm 

ong 
fully models lazy lambda calculus 
proc 
th symposium foundation computer science 

paterson hewitt 
comparative 
conf 
rec 
acm conference concurrent systems parallel computation 

plotkin lcf considered programming language 
theor 
comput 
sci 


plotkin call name call value calculus 
theor 
comput 
sci 


rees clinger eds 
revised report algorithmic language scheme 
sigplan notices 

reynolds simple typeless language principle completeness concept 
commun 
acm 

reynolds essence algol 
algorithmic languages edited de bakker van vliet 
north holland amsterdam 

riecke complete decidable proof system call value equalities 
proc 
th international conference automata languages programming 
lecture notes computer science 
springer verlag berlin 

sitaram felleisen 
reasoning continuations ii full abstraction models control 
proc 
acm conference lisp functional programming 

steele jr sussman 
lambda ultimate imperative 
memo mit ai lab 

sussman steele jr scheme interpreter extended lambda calculus 
memo mit ai lab 

troelstra metamathematical investigation intuitionistic arithmetic analysis 
lecture notes mathematics 
springer verlag berlin 

wand complete type inference simple objects 
proc 
symposium logic computer science 

wand types sets semantics milner style polymorphism 
proc 
th symposium principles programming languages 

williams formalization semantic conventions 
draft version september 
appear journal symbolic logic 
