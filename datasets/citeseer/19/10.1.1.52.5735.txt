journal artificial intelligence research submitted published provably bounded optimal agents stuart russell russell cs berkeley edu computer science division 
university california berkeley ca usa subramanian cs cornell edu computer science department cornell university ithaca ny usa inception artificial intelligence relied theoretical foundation centred perfect rationality desired property intelligent systems 
argue done foundation inadequate imposes fundamentally unsatisfiable requirements 
result arisen wide gap theory practice ai hindering progress field 
propose property called bounded optimality 
roughly speaking agent bounded optimal program solution constrained optimization problem architecture task environment 
show construct agents property simple class machine architectures broad class real time environments 
illustrate results simple model automated mail sorting facility 
define weaker property asymptotic bounded optimality abo generalizes notion optimality classical complexity theory 
construct universal abo programs programs abo matter real time constraints applied 
universal abo programs building blocks complex systems 
conclude discussion prospects bounded optimality theoretical basis ai relate similar trends philosophy economics game theory 

artificial intelligence philosophers control theorists economists looked satisfactory definition rational behaviour 
needed underpin theories ethics inductive learning reasoning optimal control decision making economic modelling 
doyle proposed ai defined computational study rational behaviour effectively equating rational behaviour intelligence 
role definitions ai ensure theory practice correctly aligned 
define property hope able design system provably possesses property theory meets practice systems exhibit reality 
furthermore exhibit reality care 
sense choice study determines nature field 
number possible choices ffl perfect rationality classical notion rationality economics philosophy 
perfectly rational agent acts instant way maximize expected utility information acquired environment 
action selection requires computation computation takes time perfectly rational agents exist non trivial environments 
fl ai access foundation morgan kaufmann publishers 
rights reserved 
russell subramanian ffl rationality notion rationality studied ai 
rational agent eventually returns rational choice deliberation 
exist systems influence diagram evaluators exhibit property decision theoretic definition rational choice systems nonlinear planners exhibit logical definition rational choice 
assumed interesting property system exhibit constitutes principle capacity right thing 
rationality limited value practice actual behaviour exhibited systems far rational example rational chess program choose right move may take times long 
result ai ignore theoretical developments forced rely trial error engineering achieve goals 
simple domains chess little theory designing analysing high performance programs 
ffl metalevel rationality natural response problems rationality 
metalevel rational system optimizes object level computations performed service selecting actions 
words decision finds optimal combination computation sequence plus action constraint action selected computation 
full metalevel rationality seldom useful metalevel computations take time metalevel decision problem difficult object level problem 
simple approximations metalevel rationality proved useful practice example metalevel policies limit lookahead chess programs engineering merely serve illustrate lack theoretical basis agent design 
ffl bounded optimality bounded optimal agent behaves possible computational resources 
bounded optimality specifies optimal programs optimal actions optimal computation sequences 
approach avoid placing constraints intelligent agents met program 
actions computations generated programs programs designers control 
claims 
system exhibits bounded optimality desirable reality 

possible construct provably bounded optimal programs 

artificial intelligence usefully characterized study bounded optimality particularly context complex task environments reasonably powerful computing devices 
claim controversial 
supports second claim detail 
third claim may may stand test time 
section necessarily brief discussion relationship bounded optimality earlier notions rationality 
note particular important distinctions missed precise definitions terms 
section provide formal definitions agents programs behaviour rationality 
provably bounded optimal agents formal descriptions task environments elements allow prove agent exhibits bounded optimality 
section examines class agent architectures problem generating bounded optimal configurations efficiently soluble 
solution involves class interesting practically relevant optimization problems appear addressed scheduling literature 
illustrate results showing throughput automated mail sorting facility improved 
section initiates discussion bounded optimal configurations learned experience environment 
section define weaker property asymptotic bounded optimality abo may robust tractable strict version bounded optimality 
particular construct universal abo programs 
program universally abo abo regardless specific form time dependence utility function 
universal abo programs building blocks complex systems 
conclude assessment prospects development approach artificial intelligence 

historical perspective classical idea perfect rationality developed aristotle theories ethics arnauld choice uncertainty mill put formal footing decision theory ramsey 
stipulates rational agent act maximize expected utility 
expectation taken agent beliefs perfect rationality require omniscience 
artificial intelligence logical definition rationality known philosophy practical syllogism put forward mccarthy reiterated strongly newell 
definition agent take action believes guaranteed achieve goals 
ai said theoretical foundation definition rationality provided 
mccarthy believed probably correctly early stages field important concentrate epistemological adequacy heuristic adequacy capability principle practice 
methodology resulted involves designing programs exhibit rationality various speedup techniques approximations hope getting close possible perfect rationality 
belief albeit unproven simple agent designs fulfill specification rationality may provide starting points approach bounded optimality 
theoretical foundation rationality provide necessary guidance search 
clear ai embarked quest rationality operating days formal intractability results discovered 
response complexity rule bounds 
levesque brachman suggest limiting complexity environment perfect rationality coincide 
doyle patil argue strongly position 

usage term universal derives scheduling randomized algorithms luby sinclair zuckerman 
russell subramanian economists perfect rationality model economic entities purposes economic forecasting designing market mechanisms 
possible prove simple theorems properties markets equilibrium 
unfortunately simon pointed real economic entities limited time limited powers deliberation 
proposed study bounded rationality investigating shape system effectiveness computation important weapons survival 
simon focussed mainly satisficing designs deliberate reaching solution satisfying preset aspiration level 
results descriptive value modelling various actual entities policies general prescriptive framework bounded rationality developed 
proved possible calculate optimal aspiration levels certain problems structural variation allowed agent design 
theory games bounds complexity players topic intense interest 
example troubling fact defection equilibrium strategy unbounded agents playing fixed number rounds prisoners dilemma game 
neyman theorem proved papadimitriou yannakakis shows essentially cooperative equilibrium exists agent finite automaton number states exponential number rounds 
essentially bounded optimality result bound space speed computation 
type result possible shift problem selecting actions problem selecting programs 
distinguished perfect type rationality metalevel type ii rationality 
defines maximization expected utility account deliberation costs 
simon says global optimization problem find cost best return decision net computational costs 
type ii rationality step right direction entirely clear precise way respects desirable intuition computation important 
try interpretation may 
key issue space maximization optimization occurs 
simon referring space possible deliberations associated particular decision 
conceptually object level machine executes sequence computations control meta level machine 
outcome sequence selection external action 
agent exhibits type ii rationality deliberation subsequent action utility maximized compared possible deliberate act pairs engaged 
example discusses possible application type ii rationality chess programs 
case object level steps node expansions game tree followed backing leaf node evaluations show best move 
simplicity assume move time limit 
type ii rational agent execute whichever sequence node expansions chooses best move finish 
example conceivable simon really intended refer finding agent design minimizes deliberation costs general 
discussions couched terms finding right deliberation decision 
type ii metalevel rationality coincides bounded optimality bounded optimal agent designed single decision single situation 
provably bounded optimal agents time limit 
unfortunately computations required metalevel machine select object level deliberation may extremely expensive 
proposes fairly simple nearly practical metalevel decision procedure chess far optimal 
hard see type ii rational agent justify executing suboptimal object level computation sequence limit scope optimization problem single decision 
difficulty resolved thinking design agent program generates unbounded set possible deliberations response unbounded set circumstances may arise life agent 
philosophy seen gradual evolution definition rationality 
shift consideration act rationality individual acts rule rationality general policies acting 
shift caused difficulties individual versus societal rationality consideration difficulty computing rational acts 
consideration tractability general moral policies view making understandable usable persons average intelligence brandt 
suggested definition minimal rationality specifying lower bounds reasoning powers rational agent upper bounds 
philosophical proposal generally consistent notion bounded optimality dennett moral aid manual 
dennett explicitly discusses idea reaching equilibrium space decision procedures 
uses example phd admissions procedure philosophy department 
concludes best procedure may elegant illuminating 
existence procedure process reaching main points interest 
researchers ai discussed worked problem designing agents limited computational resources 
aaai symposium ai limited rationality russell contains interesting variety topic :10.1.1.52.1027
concerned metalevel rationality 
metareasoning reasoning reasoning important technique area enables agent control deliberations costs benefits 
combined idea anytime dean boddy flexible algorithms horvitz return better results time goes simple form metareasoning allows agent behave real time environment 
simple example provided iterative deepening algorithms game playing 
breese apply similar ideas controlling multiple decision procedures 
russell wefald give general method certain aspects metareasoning system efficiently estimate effects individual computations intentions giving fine grained control reasoning 
techniques seen approximating metalevel rationality provide useful insights general problem control reasoning reason suppose approximations optimal sense 
intuitive notion bounded optimality current ai community mid 
horvitz uses term bounded optimality refer optimization computational utility set assumptions expected 
imagine cases move selected move selected type agent sense accidental deliberation cause program abandon 
russell subramanian problems constraints reasoning resources 
russell wefald say agent exhibits bounded optimality task environment program solution constrained optimization problem architecture 
etzioni russell zilberstein seen optimizing welldefined set agent designs making notion bounded optimality precise 
section build suitable set general definitions ground demonstrate examples provably bounded optimal agents 

agents architectures programs intuitively agent just physical entity wish view terms perceptions actions 
counts instance necessarily thinks thinks 
initial refusal consider constraints internal workings agent reason logically example helps ways allows view cognitive faculties planning reasoning occurring service finding right thing second room agre chapman brooks take position systems right thing cognitive faculties third allows freedom consider various specifications boundaries interconnections subsystems 
defining agents environments terms actions percepts exchange sequence states go 
agent described agent function percept sequences actions 
treatment fairly standard see genesereth nilsson 
go inside agent look agent program generates actions define implementation relationship program corresponding agent function 
consider performance measures agents problem designing agents optimize performance measure 
specifying agents environments agent described abstractly mapping agent function percept sequences actions 
set percepts agent receive instant set possible actions agent carry external world 
interested behaviour agent time introduce set time points instants set totally ordered relation unique element 
loss generality set non negative integers 
percept history agent sequence percepts indexed time 
define set percept histories fo og 
prefix history till time denoted projection 
define set percept history prefixes fo similarly define set action histories fa ag 
set action history prefixes defined set projections histories definition agent function mapping provably bounded optimal agents note agent function entirely entity agent program implements 
note output agent function percept sequence may null action example agent thinking 
agent function specifies agent time step 
crucial distinction perfect rationality rationality 
agents live environments 
states environment drawn set set possible state trajectories defined fx xg 
agent necessarily full access current state percept received agent depend current state perceptual filtering function effects agent actions represented environment transition function specifies state current state agent action 
environment defined follows definition environment set states distinguished initial state transition function perceptual filter function state history determined environment agent function 
notation effects denote state history generated agent function operating environment notation denote state history generated applying action sequence starting initial state environment notice environment discrete deterministic formulation 
extend definitions cover non deterministic continuous environments cost additional complexity exposition 
results depend significant way discreteness determinism 
specifying agent implementations consider physical agent consisting architecture program 
architecture responsible interfacing program environment running program 
architecture associate finite programming language lm just set programs runnable architecture 
agent program program lm takes percept input internal state drawn set initial state 
initial internal state depends program usually suppress argument 
set possible internal state histories fi ig 
prefix internal state history till time denoted projection 
russell subramanian definition architecture fixed interpreter agent program runs program single time step updating internal state generating action lm theta theta theta hi architecture generates stream actions dictates program 
physical properties architecture running program single time step results execution finite number instructions 
program may fail reach decision time step result action produced architecture may null previous action depending program design 
relating agent specifications implementations relate agent programs corresponding agent functions 
say agent program running machine implements agent function agent 
agent function constructed definition specifying action sequences produced running possible percept sequences 
note importance markovian construction internal state agent ensure actions past 
definition program running implements agent function agent defined follows 
environment hi program induces corresponding agent function agent action follows percept necessarily agent response percept delay incurred deliberation may reflect percepts occurring earlier sequence 
furthermore possible map agent function implementation lm define subset set agent functions implementable architecture language lm ff lm agent feasibility related clearly distinct notion computability 
computability refers existence program eventually returns output specified function feasibility refers production output appropriate point time 
set feasible agent functions smaller set computable agent functions 
provably bounded optimal agents performance measures agents evaluate agent performance world define real valued utility function state histories utility function seen external agent environment 
defines problem solved designer agent 
agent designs may incorporate explicit representation utility function means required 
term task environment denote combination environment utility function 
recall agent actions drive environment particular sequence states accordance function effects 
define value agent function environment utility state history generates effects designer set environments probability distribution single environment value agent defined expected value elements slight abuse notation assign value program executed architecture environment simply looking effect agent function implemented program agent effects agent extend set possible environments follows perfect rationality bounded optimality discussed section perfectly rational agent selects action maximizes expected utility percepts far 
framework amounts agent function maximizes possible agent functions 
definition perfectly rational agent set environments agent function opt opt argmax definition persuasive specification optimal agent function set environments underlies current projects intelligent agent design dean wellman doyle hansson mayer 
direct implementation specification ignores delay incurred deliberation yield reasonable russell subramanian solution problem calculation expected utilities takes time real agent 
terms simple formal description agents introduced easy see difficulty arisen 
designing agent program decision theorists concentrated specifying optimal agent function opt order guarantee selection best action history 
function opt independent architecture unfortunately real program lm implements function non trivial environment optimal actions usually computed percept arrives 
quite frequently opt 
suppose environment consists games chess tournament rules population human suppose standard personal computer 
opt describes agent plays way maximize total expected points opposition maximization moves 
claim possible program play way 
quite possible depth alpha beta search termination execute program chooses say optimal minimax move situation agent function induced program opt particular ignores percepts dropping flag indicating loss time 
trouble perfect rationality definition arose unconstrained optimization space determination opt regard feasibility 
similarly metalevel rationality assumes unconstrained optimization space deliberations 
escape propose machine dependent standard rationality maximize implementable set agent functions 
impose optimality constraints programs agent functions deliberations 
definition bounded optimal agent architecture set environments agent program opt opt argmax lm see immediately specification avoids obvious problems type type ii rationality 
consider chess example suppose computer total program memory megabytes 
possible programs represented machine smaller number play legal chess 
tournament conditions programs best expected performance 
suitable candidate opt bounded optimality definition feasible specification program achieves highly desirable 
ready announce identity opt chess megabyte pc restricted problem 

provably bounded optimal agents order construct provably bounded optimal agent carry steps ffl specify properties environment actions taken utility function behaviours 
provably bounded optimal agents ffl specify class machines programs run 
ffl propose construction method 
ffl prove construction method succeeds building bounded optimal agents 
methodology similar formal analysis field optimal control studies design controllers agents plants environments 
optimal control theory controller viewed essentially instantaneous implementation optimal agent function 
contrast focus computation time required agent relation computation time dynamics environment 
episodic real time task environments section consider restricted class task environments call episodic environments 
episodic task environment state history generated actions agent considered divided series episodes terminated action 

distinguished set actions terminate episode 
utility complete history sum utilities episode determined turn state sequence 

environment resets state chosen random stationary probability distribution init order include effects choice utility episode divide environment state configuration part value part configuration part determines state transitions value part determines utility state sequence 
actions 
reset configuration part value recorded value part 
restrictions mean episode treated separate decision problem translate property agent program higher expected utility individual episodes agent higher expected utility corresponding episodic task environment 
real time task environment utility action depends time executed 
usually dependence sufficiently strong rationality unacceptably bad approximation perfect rationality 
automated mail sorter provides illustrative example episodic task environment see 
machine scans handwritten printed addresses mail pieces dispatches appropriate bins 
episode starts arrival new mail piece terminates execution physical action recommended sorter routing piece specific bin 
configuration part environment corresponds letter feeder side provides new randomly selected letter previous letter sorted 
value part state corresponds state receiving bins determines utility process 
aim maximize accuracy sorting minimizing reject percentage avoiding jams 
jam occurs current piece routed appropriate bin rejected arrival piece 
provide formal definitions varieties real time task environments fixed deadlines fixed time cost stochastic deadlines 

see sackinger boser details actual system 
application suggested bernhard boser early presentation nec symposium 
russell subramanian sacks mail camera reject zipcode buckets automated mail sorting facility provides simple example episodic real time task environment 
fixed deadlines simplest commonly studied kind real time task environment contains deadline known time 
real time systems deadlines described informally systems built meet deadline 
need formal specification order connect description deadline properties agents running deadline task environments 
think deadlines part environment description fact mainly realized constraints utility function 
see considering opposite deadline starter 
distinguished differing constraints utilities acting specific time 
definition fixed deadline task environment ui fixed deadline time conditions hold 
ffl action 
time deadline results utility gamma delta delta denotes sequence concatenation 
gamma gamma contain action 
ffl actions taken effect utility fixed time cost task environments approximately fixed time cost common 
examples include consultations lawyers keeping taxi waiting dithering invest money 
define task environment fixed time cost comparing utilities actions taken different times 
provably bounded optimal agents definition fixed time cost task environment ui fixed time cost action history prefixes satisfying 
gamma gamma contain action 
utilities differ difference time cost gamma gamma strictly speaking task environments fixed time cost 
utility values finite range continue incurring time costs indefinitely 
reasonably short times reasonably small costs linear utility penalty useful approximation 
stochastic deadlines fixed deadline fixed cost task environments occur frequently design real time systems uncertainty time dependence utility function common 
turns interesting see 
stochastic deadline represented uncertainty concerning time occurrence fixed deadline 
words agent probability distribution deadline time assume deadline come eventually 
define cumulative deadline distribution deadline occur known time need distinguish cases ffl agent receives percept called herald dean boddy announces impending deadline 
model distinguished percept agent responds immediately meets deadline ffl percept available case agent walking blindfolded utility cliff 
agent risks missing deadline may improve decision quality 
example familiar readers deciding publish current form risk 
treat case current 
formally stochastic deadline case similar fixed deadline case drawn distribution utility executing action history prefix expectation utilities state history prefix possible deadline times 
definition stochastic deadline task environment class ui fixed deadline task environments stochastic deadline distributed action history prefix ui task environment ui fixed deadline russell subramanian mail sorter example described stochastic deadline 
time arrival mail pieces image processing station distributed density function usually poisson 
agent programs agent architecture consider simple agent programs episodic task environments constructed elements set fr decision procedures rules 
decision procedure recommends execute action 
agent program fixed sequence decision procedures 
purposes decision procedure black box parameters ffl run time integer represents time taken procedure compute action 
ffl quality real number 
gives expected reward resulting executing action start episode mj denote agent architecture executes decision procedures language denote maximum runtime decision procedures accommodated example runtime feedforward neural network proportional size runtime largest neural network fits architecture executes agent program running decision procedure turn providing input obtained initial percept 
deadline arrives fixed time percept entire sequence completed agent selects action recommended highest quality procedure executed hi action hi action hi action updates agent internal state history action action recommended completed decision procedure highest quality 
action executed internal state agent re initialized agent design works task environment categories described 
derive value agent program environment running real time regimes show construct bounded optimal agents task environments 
bounded optimality fixed deadlines equation know agent picks action 
recommended decision procedure highest quality executed deadline arrives 
provably bounded optimal agents longest prefix program definition equation follows expression value agent program easily show theorem arg max singleton sequence bounded optimal program episodic task environment known deadline best program single decision procedure maximum quality runtime deadline 
bounded optimality fixed time cost equation know agent picks action 
recommended best decision procedure sequence runs entire sequence deadline 
definition equation qm gamma expression value agent program easily show theorem arg max gamma ct singleton sequence bounded optimal program episodic task environment fixed time cost optimal program single decision procedure quality net time cost highest 
bounded optimality stochastic deadlines stochastic deadline distributed value agent program expectation 
definition calculate ui task environment fixed deadline substituting equation expression simplifies summation procedures sequence probability interruption th procedure sequence multiplied quality best completed decision procedure gamma gamma dt simple example serves illustrate value function 
consider fr rule quality needs seconds run represent 
rules 
deadline distribution function uniform distribution seconds 
value sequence gamma gamma gamma geometric intuition notion performance profile shown 
russell subramanian performance profile superimposed 
definition performance profile sequence performance profile gives quality action returned agent interrupted tg uniform deadline density function value sequence proportional area performance profile possible interrupt time 
note height profile interval length rule running quality best previous rules 
definition obvious property lemma performance profile sequence monotonically nondecreasing 
case sequence higher quality decisions times better sequence lemma 
case say dominates idea performance profiles establish useful properties optimal sequences 
lemma exists optimal sequence sorted increasing order 
lemma 
possible sequences consider 
ordering constraint eliminates sequences 
means proofs properties sequences need consider ordered sequences 
addition replace equation lemma establishes sequence improved addition better rule lemma sequence sorted increasing order quality single step sm sz 
provably bounded optimal agents corollary exists optimal sequence highest quality rule lemma reflects obvious intuition get better result time point spending time get worse result lemma exists optimal sequence rules nondecreasing order apply preparatory results derive algorithms construct bounded optimal programs various deadline distributions 
general distributions general deadline distribution dynamic programming method obtain optimal sequence decision rules pseudo polynomial time 
construct optimal sequence definition equation 
optimal sequences generated methods ordered accordance lemma 
construct table entry table highest value sequence ends rule time assume rule indices arranged increasing order quality ranges start time time update rule max gamma gamma gamma gamma boundary condition rule time corollary read best sequence highest value row matrix theorem dp algorithm computes optimal sequence time number decision procedures dependence time complexity dp algorithm means algorithm polynomial input size 
standard rounding scaling methods fully polynomial approximation scheme constructed 
hardness proof problem john binder shown deadline distribution constant time oracle finding values algorithm require exponential number calls oracle worst case 
long uniform distributions deadline uniformly distributed time interval greater sum running times rules call distribution long uniform distribution 
consider rule sequence drawn rule set long uniform distribution probability deadline arrives rule sequence independent time starts 
permits simpler form equation gamma gamma russell subramanian derive optimal sequence long uniform distribution obtain recursive specification value sequence sequence gamma mp allows define dynamic programming scheme calculating optimal sequence state function denoting highest value rule sequence starts rule ends rule lemma equation update rule max kj gamma boundary condition gamma corollary know optimal sequence long uniform distribution ends rule highest quality need examine entry requires computation entries compute 
optimal sequence long uniform case calculated 
theorem optimal sequence decision procedures long uniform deadline distribution determined time number decision procedures short uniform distributions uniform deadline distribution call short 
means sequences longer possible deadline time rules sequences possibility executing deadline 
sequences equation calculate 
sequence truncated removing rules complete execution possible deadline 
value sequence unaffected truncation truncated sequences equation justified 
furthermore optimal sequence truncated sequence 
update rule correctly computes truncated sequences short uniform distributions provided add check ensure sequences considered truncated 
long uniform case identity rule optimal sequence unknown need compute entries table 
entry computation takes time time compute optimal sequence 
theorem optimal sequence decision procedures short uniform deadline distribution determined time number decision procedures provably bounded optimal agents exponential distributions exponential distribution gammae exponential distributions allow optimal sequence computed polynomial time 
stand probability rule interrupted assuming starts 
gamma exponential distribution simplifies gamma pi gamma pi gamma yields simple recursive specification value sequence begins rule gamma gamma state function represents highest value rule sequence starting max kj gamma gamma boundary condition gamma 
calculated 
corollary know optimal sequence element highest valued rule theorem optimal sequence decision procedures exponentially distributed stochastic deadline determined time number decision procedures proof similar long uniform distribution case 
simulation results mail sorter preceding results provide set algorithms optimizing construction agent program variety general task environment classes 
section illustrate results possible gains realized specific task environment simulated mail sorter 
precise utility function episodes 
possible outcomes utility outcome 
zipcode successfully read letter sent correct bin delivery 

zipcode letter goes wrong bin 

letter sent reject bin 

letter arrives recognizer finished jam 
letter arrival jams occur machine architecture equation 
russell subramanian accuracy computation time sec lambda time sec mu accuracy profile gamma gammax 
poisson arrival distribution mean sec loss generality set 
probability rule recommending correct destination bin gamma assume threshold probability letter sent reject bin 
include rule set rule reject zero runtime recommends rejection 
sequence construction algorithm automatically exclude rules quality lower reject utility episode chosen linear combination quality sorting probability rejection rejection rate runtime non reject rule executed speed sorting measured arrival time mean 
agent program boser uses single neural network chip 
show variety conditions optimized sequence networks significantly better single network terms throughput accuracy 
examine experimental conditions ffl assume network executes time recognition accuracy depends consider gammae gammat particular choice irrelevant scale chosen arbitrary 
choose convenience 
include reject reject reject 
ffl consider arrival time distributions poisson varying means 
shows example distributions means seconds 
ffl create optimized sequences sets networks execution times taken equal intervals 
ffl compare bo sequence bounded optimal sequence best singleton best single rule rule rule execution time mean distribution complete cases provably bounded optimal agents mean arrival time bo sequence best singleton rule rule graph showing achievable utility second function average time letter program types 

rule rule execution time guarantees complete cases 
cases add reject initial step bo sequence include automatically 
ffl measure utility second function mean arrival rate 
shows optimal setting sorting machinery letters minute inter arrival time seconds bounded optimal program fixed 
ffl investigate effect variance arrival time relative performance program types 
purpose uniform distribution centered seconds different widths vary variance affecting mean 
notice interesting things results ffl policy choosing rule probability completion performs poorly rapid arrival rates catches performance best single rule slower arrival rates 
artifact exponential accuracy profile difference quality rules run times greater seconds quite small 
ffl policy choosing rule probability completion fares best single rule high arrival rates rapidly diverges performing far worse arrival time means greater seconds 
russell subramanian variance arrival time bo sequence best singleton rule rule graphs showing utility gain second function arrival time variance program types uniform distribution mean seconds 
ffl best sequence best single rule give best performance arrival rate letters minute 
performance advantage optimal sequence best single rule arrival rate 
noted significant performance advantage obtainable extra computational resources 
slower arrival rates difference performance best rule best sequence arises decreased rejection rate best sequence 
exponential accuracy profile advantage running rule shorter completion time ahead longer rule ability reduce probability rejecting letter 
high arrival rates inter arrival times seconds useful short rules longer single rule 
ffl shows best sequence performs better best single rule variance arrival time increases 
performance optimal sequence appears largely unaffected variance 
exactly behaviour expect observe ability run sequence rules committing single gives robustness face increasing variance 
realistic environments involve unexpected demands kinds possession variety default behaviours graded sophistication optimal design choice bounded agent 

performance rule flat uniform distributions experiment fixed mean symmetric rule rule runs seconds 
rule changes variance curve exhibits discretization effects 
eliminated finer grained set rules 
provably bounded optimal agents 
learning approximately bounded optimal programs derivations assume suitable rule set available ab initio correct qualities runtimes deadline distribution known 
section study ways information learned implications bounded optimality resulting system 
concentrate learning rules qualities leaving runtimes deadline distributions 
basic idea learning algorithms converge time set optimal components accurate rules accurate quality estimates 
happens value agent constructed rules quality estimates converges value opt sources suboptimality learned agent ffl rules may best possible rules may recommend actions lower utility recommended rules 
ffl may errors estimating expected utility rule 
cause algorithms construct suboptimal sequences best rules available 
notional method constructing bounded optimal agents learns sets individual decision procedures episodic interactions arranges sequence algorithms described earlier performance agent sequence agent 
assume parameterized learning algorithm learn rule possible runtime need include rules runtime obviates need consider entire rule language optimization process 
setting places somewhat unusual requirements learning algorithm 
learning algorithms works observing collection training episodes including utility obtained episode 
assumptions form correct decision rule 
assumptions hypotheses come finite language set programs complexity setting called agnostic learning setting kearns schapire sellie assumptions environment 
shown theorems kearns schapire sellie languages error learned approximation bounded ffl best rule fits examples probability gamma ffi 
sample size needed guarantee bounds polynomial complexity parameter ffl ffi addition constructing decision procedures outputs estimates quality standard chernoff hoeffding bounds limit error quality estimate ffl probability gamma ffi sample size estimation quality polynomial ffl ffi error agnostically learned rule bounded ffl best rule complexity class probability gamma ffi 
error quality estimation rules bounded ffl probability gamma ffi bounds calculate bound utility deficit agent program construct comparison opt russell subramanian theorem assume architecture mj executes sequences decision procedures agnostically learnable language runtimes range 
real time task environments fixed time cost fixed deadline stochastic deadline construct program opt gamma ffl ffl probability greater gamma ffi ffi number decision procedures opt proof prove theorem stochastic deadline regime bounded optimal program sequence decision procedures 
proofs fixed cost fixed deadline regimes bounded optimal program singleton follow special case 
best decision procedures set fr opt optimal sequence constructed fr set decision procedures returned learning algorithm 
probability greater gamma gamma ffl refers true quality error estimated quality decision procedure bounded probability greater gamma jq gamma ffl rules come runtime classes rules equation opt gamma ffl error weighted average errors individual similarly gamma ffl suppose sequence construction algorithm applied produces sequence definition sequence appears optimal estimated value function bound error estimated value gamma ffl combining inequalities opt gamma ffl ffl theorem practical applications mainly intended illustration learning procedure converge bounded optimal configuration 
additional general error bounds derived case rule execution times real time utility variation time cost fixed deadline deadline distribution estimated training episodes 
obtain error bounds case rule language divided smaller number coarser runtime classes potentially huge number currently 
provably bounded optimal agents 
asymptotic bounded optimality strict notion bounded optimality may useful philosophical landmark explore artificial intelligence may strong allow interesting general results obtained 
observation ordinary complexity theory absolute efficiency aim asymptotic efficiency game 
sorting algorithm log considered significant replacing multiply shift left bit considered real advance 
slack allowed definitions complexity classes essential building earlier results obtaining robust results restricted specific implementations analysing complexity algorithms algorithms subroutines 
section reviewing classical complexity 
propose definitions asymptotic bounded optimality advantages show classical optimality special case asymptotic bounded optimality 
lastly report preliminary investigations asymptotic bounded optimality theoretical tool constructing universal real time systems 
classical complexity problem classical sense defined pair predicates oe output solution input oe hold 
problem instance input satisfying oe algorithm problem class terminates output satisfying input satisfying oe 
asymptotic complexity describes growth rate worst case runtime algorithm function input size 
define formally follows 
runtime algorithm input maximum runtime input size algorithm complexity kf intuitively classically optimal algorithm lowest possible complexity 
purposes constructing asymptotic notion bounded optimality useful definition classical optimality mention complexity directly 
done follows definition classically optimal algorithm algorithm classically optimal kt relate classical complexity framework need define special case task environments traditional programs appropriate 
task environments input provided program initial percept utility function environment histories obeys constraint definition classical task environment ui classical task environment problem ep outputs correct solution russell subramanian running time universal turing machine positive decreasing function 
notion problem class classical complexity theory corresponds class classical task environments unbounded complexity 
example traveling salesperson problem contains instances arbitrarily large numbers cities 
varieties asymptotic bounded optimality thing need complexity measure environments 
suitable measure complexity environment 
assume existence environment classes unbounded complexity 
analogy definition classical optimality define worst case notion asymptotic bounded optimality abo 
letting minimum value complexity definition worst case asymptotic bounded optimality agent program worst case asymptotically bounded optimal iff km km denotes version machine speeded factor times memory 
english means program basically right lines just needs faster larger machine worst case behaviour program environments 
probability distribution associated environment class expected value define average case notion abo definition average case asymptotic bounded optimality agent program average case asymptotically bounded optimal iff km worst case average case definitions abo happy program abo nontrivial environment nontrivial architecture enormous 
rest worst case definition abo 
identical results obtained average case definition 
observation abo programs classically optimal programs special case abo programs 
classical definitions allow optimality constant factor runtime algorithms 
wonder chose constant factor expand machine capabilities increase time available program 
context ordinary complexity theory alternatives exactly equivalent context general time dependent utilities appropriate 
possible simply run times longer programs wish consider control execution time trading solution quality 
imagine slowing entire environment factor merely realistic version propose 

connection suggested bart selman 
provably bounded optimal agents theorem program classically optimal problem worst case abo corresponding classical task environment class ui 
observation follows directly definitions 
summary notion abo provide degree theoretical robustness machine independence study bounded systems asymptotic complexity classical programs 
having set basic framework exercise definitions 
universal asymptotic bounded optimality asymptotic bounded optimality defined respect specific value function constructing real time systems prefer certain degree independence temporal variation value function 
achieve defining family value functions differing temporal variation 
mean value function preserves preference ordering external actions time value functions family having preference ordering 
example fixed cost regime vary time cost generate family value functions stochastic deadline case vary deadline distribution generate family 
regimes uses quality measure actions union corresponding families family 
show single program call universal program asymptotically bounded optimal regardless value function chosen particular family 
definition universal asymptotic bounded optimality agent program environment class family value functions iff abo program compete abo programs individual value function family 
program universal real time solution task 
programs exist 
construct 
turns scheduling construction russell zilberstein design programs 
construction designed reduce task environments unknown interrupt times case known deadlines insight applies 
construction requires architecture provide program concatenation lisp prog construct conditional return construct null program universal program form concatenation individual programs increasing runtime appropriate termination test 
written delta delta delta delta delta delta delta consists program termination test 
program part program lm abo value function corresponds fixed deadline ffl ffl time increment smaller execution time non null program lm 
value function separable russell wefald preservation rank order allows separate time cost defined 
see chapter keeney raiffa thorough discussion time dependent utility 
russell subramanian opt performance profiles running opt running proceeding statement look example 
consider simple sequential machine architecture described earlier 
suppose select rules rule set 
shortest runtime rules seconds ffl 
look optimal programs fixed deadline task environments 
sequence programs 
consider task environment class value function specifies stochastic deadline uniformly distributed range 
class opt bounded optimal sequence 
turns higher utility opt provided run machine times faster 
see plotting performance profiles qu opt opt qu dominates opt shown 
establish construction yields programs general need define notion worst case performance profile 
minimum value obtained interrupting complexity know satisfies constants aim prove km definition worst case performance profile fairly easy show lemma proof essentially identical proof theorem russell zilberstein 
notice simple model output quality rule depends execution time input complexity 
means worst case average case behaviour 
provably bounded optimal agents mean arrival time bo sequence abo sequence throughput accuracy improvement opt function mean arrival time poisson arrivals 
lemma universal program abo km dominates max max lemma establishes small constant penalty ignore specific realtime nature task environment constructing bounded optimal programs 
need deal issue termination 
possible general terminate appropriate time access information concerning utility function 
example fixed time cost task environment appropriate termination time depends value time cost general case deterministic time dependence help supplying aspiration level time acts 
terminates completed 
construction happen lemma 
theorem task environments deterministic time dependence suitable aspiration level deadline termination test somewhat simpler require additional input theorem task environment stochastic deadlines terminates herald arrives 
returning mail sorting example fairly easy see consists sequence networks optimal programs stochastic deadline case abo fixed deadline regime 
obvious abo particular russell subramanian stochastic deadline case recall regimes considered single family 
programmed constructor function universal programs applied mail sorter environment class 
varying letter arrival distribution gives different value functions shows higher throughput accuracy opt entire range arrival distributions 
existence programs possible consider behaviour compositions thereof 
simplest form composition functional composition output program input 
complex nested compositional structures entertained including loops conditionals zilberstein 
main issue constructing compositions allocate time components 
provided solve time allocation problem know total runtime allowed construction technique generate composite programs optimality possible compositions components 
zilberstein russell shown allocation problem solved linear time size composite system provided composition tree bounded degree 

examined possible formal bases artificial intelligence concluded bounded optimality provides appropriate goal constructing intelligent systems 
noted similar notions arisen philosophy game theory reason mismatch classically optimal actions called feasible behaviours generated agent program running computing device finite speed size 
showed careful specification task environment computing device design provably bounded optimal agents 
exhibited simple agents bounded optimality strict sense difficult goal achieve larger space agent programs considered 
relaxed notions asymptotic bounded optimality abo may provide theoretically robust tools progress 
particular abo promises yield useful results composite agent designs allowing separate problem designing complex abo agents discrete structural problem continuous temporal optimization problem tractable cases 
reason optimistic artificial intelligence usefully characterized study bounded optimality 
may speculate provided computing device small small changes speed size cause significant changes optimal program design powerful classically optimal decisions computed feasibly abo designs stable reasonably wide variations machine speed size environmental complexity 
details optimal designs may arcane learning processes play large part discovery expect focus type research questions convergence optimality various structural classes result 
important implication conceptual foundations field research bounded optimality applies design practice artificial intelligence way idealized infinite resource models may 
provably bounded optimal agents way illustrating definition bounded optimal agent design simple system consisting sequences decision procedures provably better program class 
theorem exhibits bounded optimal design translates definition agent actual behaviour desirable 
appear plenty worthwhile directions continue exploration bounded optimality 
foundational point view interesting questions concept applies agents incorporate learning component 
note section learning algorithm external agent 
case necessarily largely stable bounded optimal configuration agent program large agent adapt shorter term horizon rewrite obsolete 
results preservation abo composition start examine interesting architectures simple production system studied 
example look optimal search algorithms algorithm constrained apply metalevel decision procedure step decide node expand russell wefald 
extend asymptotic bounded optimality provide utility analogue big notation describing performance agent designs including suboptimal 
context computational learning theory obvious stationarity requirement environment necessary satisfy preconditions pac results restrictive 
fact agent learns may effect distribution episodes little known learning cases aldous vazirani 
relax deterministic episodic requirement allow non immediate rewards making connections current research reinforcement learning 
computation scheduling problem examined interesting appear studied operations research combinatorial optimization literature 
scheduling algorithms usually deal physical computational tasks objective function usually involves summation outputs picking best 
resolve formal question tractability general case look cases solution qualities individual processes interdependent results 
practical extensions include computation scheduling parallel machines multiple agents scheduling combinations computational physical job shop flow shop processes objective functions combination summation maximization 
extension broadens scope applications considerably 
industrial process designing manufacturing car consists computational steps design logistics factory scheduling inspection physical processes stamping assembling painting 
easily imagine applications real time financial industrial military contexts 
may turn bounded optimality wanting theoretical framework 
case hope refuted interesting way better framework created process 
russell subramanian appendix additional proofs appendix contains formal proofs subsidiary lemmata main body 
lemma exists optimal sequence sorted increasing order 
proof suppose case optimal sequence 
adjacent rules see 
removal rule yields sequence lemma fact lemma optimal 
repeat removal process ordered proving theorem reductio ad lemma sequence sorted increasing order quality single step sm sz 
proof calculate sz gamma equation show non negative sz gamma gamma gamma gamma gamma gamma non negative proof ordering lower dotted line indicates original profile upper dotted line indicates profile removal rule 
lemma exists optimal sequence rules nondecreasing order proof suppose case optimal sequence 
adjacent rules see 
removal rule yields sequence lemma 
lemma optimal 
repeat removal process ordered proving theorem reductio ad provably bounded optimal agents proof ordering dotted line indicates profile removal rule acknowledge stimulating discussions michael michael genesereth russ greiner eric horvitz henry kautz daphne koller bart selman subject bounded optimality hochbaum nimrod megiddo kevin subject dynamic programming scheduling problems nick littlestone michael kearns subject agnostic learning 
reviewers constructive suggestions 
early ideas arose discussions late eric wefald 
ron parr uniform distribution case extending results exponential distribution patrick help implementing dynamic programming algorithm 
author supported nsf iri iri iri visiting fellowship serc sabbatical uk nec research institute 
second author supported nsf iri 
agre chapman 

pengi implementation theory activity 
proc 
th national conference artificial intelligence seattle wa 
kaufmann 
aldous vazirani 

markovian extension valiant learning model 
proc 
st annual symposium foundations computer science st louis mo ieee comput 
soc 
press 
binder 

complexity deliberation scheduling stochastic deadlines 
boser sackinger bromley lecun 

hardware requirements neural network pattern classifiers case study implementation 
ieee micro 
brandt 

search credible form rule 

eds morality language conduct 
russell subramanian breese 

control problem solving principles architecture 
shachter levitt kanal lemmer 
eds uncertainty artificial intelligence 
north holland amsterdam 
brooks 

robust layered control system mobile robot 
ieee journal robotics automation 


minimal rationality 
mit press cambridge 
dean boddy 

analysis time dependent planning 
proc 
aaai pp 

dean wellman 

planning control 
morgan kaufmann san mateo ca 
dennett 

moral aid manual 
tanner lectures human values university michigan 
doyle 

rational psychology 
modern mental philosophy 
ai magazine 
doyle 

artificial intelligence rational self government 
tech 
rep 
technical report cmu cs 
doyle patil 

theses knowledge representation language restrictions taxonomic classification utility representation services 
artificial intelligence 
etzioni 

tractable decision analytic control 
proc 
st international conference knowledge representation reasoning pp 

russell 

proceedings aaai spring symposium limited rationality 
aaai 
genesereth nilsson 

logical foundations artificial intelligence 
morgan kaufmann mateo ca 


principles rationality 

eds foundations statistical inference pp 

holt rinehart winston 
toronto 
hansson mayer 

heuristic search evidential reasoning 
proceedings fifth workshop uncertainty artificial intelligence windsor ontario 
horvitz 

reasoning beliefs actions computational resource constraints 
levitt lemmer kanal 
eds uncertainty artificial intelligence 
north holland amsterdam 
kearns schapire sellie 

efficient agnostic learning 
proc 
th ann 
workshop computational learning theory pittsburgh pa morgan kaufmann 
provably bounded optimal agents keeney raiffa 

decisions multiple objectives preferences value tradeoffs 
wiley new york 
levesque brachman 

expressiveness tractability knowledge representation reasoning 
computational intelligence 
luby sinclair zuckerman 

optimal speedup las vegas algorithms 
information processing letters 
mccarthy 

programs common sense 
proceedings symposium mechanization thought processes england 
newell 

knowledge level 
ai magazine 
neyman 

bounded complexity justifies cooperation finitely repeated prisoners dilemma 
economics letters 
papadimitriou yannakakis 

complexity bounded rationality 
proc 
acm symposium theory computation 
ramsey 

truth probability 

ed foundations mathematics logical essays 
harcourt brace jovanovich new york 
russell wefald 

optimal game tree search rational metareasoning 
proc 
ijcai 
russell wefald 

principles metareasoning 
proc 
kr 
russell wefald 

right thing studies limited rationality 
mit press cambridge ma 
russell zilberstein 

composing real time systems 
proc 
ijcai sydney 
sackinger boser bromley lecun 

application anna neural network chip high speed character recognition 
ieee transactions neural networks 
simon 

decide 
models bounded rationality volume 
simon 

models bounded rationality volume 
mit press cambridge 
von neumann morgenstern 

theory games economic behavior 
princeton university press princeton 
zilberstein 

operational rationality compilation anytime algorithms 
ph thesis computer science division university california berkeley 
zilberstein russell 

optimal composition real time systems 
submitted artificial intelligence 
