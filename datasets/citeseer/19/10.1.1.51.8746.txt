means plan recognition theory reactive recognition june technical note anand rao australian artificial intelligence institute research supported cooperative research centre intelligent decision systems australian government cooperative research centres program 
appears proceedings fourth international conference principles knowledge representation reasoning kr bonn germany may draws inspiration current reactive planning guide plan recognition plans recipes 
plan recognition process guided library plans called means plan recognition 
extension dynamic logic called dynamic agent logic introduced provide formal semantics means plan recognition counterpart means plan execution 
operational semantics algorithms means plan recognition related provability formulas dynamic agent logic 
establishes relative soundness completeness algorithms respect library plans 
restrictive assumptions underlying means plan recognition relaxed provide theory reactive recognition allows changes external world recognition process 
reactive recognition embedded mental attitudes belief desire intention leads powerful theory integrated reactive planning recognition 
primary contribution laying foundations integrated theory 
classical planning plan recognition received great deal attention artificial intelligence ai community 
classical planning deals reaching desired state affairs current state chaining set plan operators 
plan recognition usually treated reverse process planning concerned inferring operators observations 
past decade focus research planning shifted classical planning reactive situated planning reactive planning premises environment agent situated continuously changing agents situated environments limited resources 
led development various architectures techniques guiding agent decision making process making agents commit decisions late possible committed stay committed long possible rational bounds 
research reactive planning led re definition notion plans 
plans different contexts plans structures recipes achieving certain states world plans complex mental attitudes intertwined complex web relationships mental attitudes belief desire plans recipes guide resource bounded agent decision making process short circuiting time consuming search possible space solutions done classical planning 
plans mental attitudes constrain agent decision making committing previously decisions 
called intentions 
noted renaissance planning little impact plan recognition 
majority plan recognition addressing general problem unconstrained plan recognition 
approaches background knowledge terms event hierarchies plans heuristics guide general recognition problem attempted plans sense guide constrain recognition process resource bounded agents dynamic world 
plans recipes mental attitudes guide constrain recognition process respectively called reactive recognition 
reactive recognition applicable broad class problems agents limited resources environment may change agents doing recognition 
important assumptions recognizing agent complete knowledge plans agents trying recognize situation recognizing agent small set plans hypotheses trying recognize 
address part reactive recognition process plans recipes guide recognition process call means plan recognition addition assumptions reactive recognition means recognition assumptions occurrence events external world synchronous recognition events agent agent wait event occur memory past events occurred world changing agent performing recognition 
due restrictive assumptions means plan recognition limited applicability 
lays foundation build theory reactive recognition 
simple algorithms means plan recognition plans similar reactive planning systems determine means observed pollack writes research plan recognition taken place isolation ai planning renaissance 
marriage research projects bear fruit 
analogously shall refer usage plans guide planning process means plan execution 
order recognize certain ends 
introduce dynamic agent logic provides logical semantics means plan recognition means plan execution 
predominantly concerned theoretical principles means plan recognition relationship algorithmic operational semantics 
envisage means plan recognition practical applications see important step reactive plan recognition 
extensions means plan recognition algorithms reactive recognition spite initial skepticism reactive planning approach quite successful compared classical planning 
due fact substantial class problem domains road traffic management space shuttle diagnosis air traffic management air combat modelling execution actions decision making tasks analyzed codified plans relatively simple manner 
plans effectively agent react dynamic domains resource constraints 
need reactive recognition motivated fact plan recognition domains simpler general problem 
particular agent domains attempting recognize arbitrary plan knows attempting recognize small set plans 
result believe substantial class problems addressed reactive planning amenable techniques reactive recognition 
means plan recognition section illustrate informally approach processes plan execution plan recognition known example literature shows number plans different levels granularity types pasta dish 
bnf syntax plans simplified form described procedural reasoning system prs 
plan name invocation condition trigger plan precondition needs true plan body started postcondition true plan body finished successfully body plan acyclic graph edges labelled certain plan expressions 
furthermore assume plans non recursive 
bnf syntax node represented gamma label 
node label 
proposition ff expression 
ff means achieve recognize achievement state world ff true 
expression means execute observe primitive plan action consider process plan execution agent initially wants kitchen wants achieve state pasta dish 
achieve agent perform means reasoning determine plans pasta dish pasta dish applicable 
agent adopts plan want achieve state ordinary pasta 
achieve adopt ordinary pasta resulting agent wanting achieve state 
process continues till making pasta dish completed execution fails agent unable complete steps successfully 
consider process means plan execution conjunction means recognition 
executing agent executes primitive plan observer agent observes execution primitive plan 
executing agent choose applicable plan succeeds observing agent attempt displayed graphically edges node shown arrows edges shown arrows arc connecting arrows 
plan entity execution recognition success condition execute observe succeeds ff sequentially run parallel run succeeds node parallel run parallel run succeeds node parallel run parallel run succeeds table comparison execution recognition recognize applicable plans simultaneously 
executing observing agents performing identical operations 
correspondence execution recognition conditions succeed shown table 
table refer plans achieve ff refer labels appearing outgoing edges node node 
operational semantics run example observer executing agents having library plans kitchen 
assume executing agent wants pasta dish observer agent wants recognize 
executing agent fulfill desire adopting plan pasta dish plan pasta dish 
observer agent order recognize adopt plans recognition 
result observer wanting recognize ordinary pasta spaghetti 
turn result observer adopting plans ordinary pasta spaghetti recognition mode 
adoption ordinary pasta result observer agent wanting recognize making turn adoption plans spaghetti recognition mode 
assume executing agent adopts plan ordinary pasta making executes action 
recognition plans spaghetti pasta dish observer agent fail 
observer agent observes primitive action making recognizes results achievement desire 
observer knows executing agent making ordinary pasta spaghetti step sauce 
observer decides recognize making sauce adopts plans recognizing making alfredo sauce making sauce 
process continues till entire pasta dish plan recognized 
algorithms section algorithms means plan execution recognition 
simplified propositional versions algorithms account mental attitudes beliefs desires intentions agents 
extend algorithms reactive planning recognition embed bdi interpreter algorithm means recognition see takes input plan library set propositions expression primitive plan achievement expression 
algorithm returns success failure result set propositions true recognition 
expression trying recognize primitive plan action invoke function observe 
expression achievement expression set applicable plans soap computed plan library plan said applicable invocation condition matches incoming expression precondition contained set plan set applicable plans recognized parallel running recognize plan succeeds 
union postcondition plan succeeded final state succeeding plan set propositions algorithm means execution similar algorithm means recognition observe recognize plan replaced execute execute plan respectively 
furthermore applicable plans run sequentially succeeds 
fail execution process said failed 
functions observe execute primitives return success failure depending successful failed observation execution event respectively 
assumption observation events happen synchronously execution actions agents built function observe 
words event occurs agent runs observe event observed 
algorithm recognize plan see plan body repeatedly recognizes nodes nodes plan body node reached nodes fails 
initial state gets continuously updated recognition nodes nodes 
node algorithm recognizing node performs means recognition parallel plan expressions labelling going arcs node see 
soon recognitions successful returns node recognize 
algorithm recognizing node performs means recognition parallel going arc see 
recognitions fail algorithm returns failure 
recognitions succeed algorithm returns union output sets algorithm executing plan similar recognitions nodes replaced execution nodes nodes 
algorithms executing nodes nodes similar algorithms recognizing nodes means execution replaces means recognition 
go back example considered earlier 
assume observing agent wants recognize making pasta dish 
corresponds means recognition algorithm called expression 
pasta dish 
results plans pasta dish pasta dish added soap 
instances algorithm recognize plan plan bodies pasta dish pasta dish set parallel 
plan recognizing pasta dish results means recognition algorithm invoked expression 
ordinary pasta 
calling various algorithms drawn graphically shown shows state agent just observation events 
agent observes observe function succeeds event nodes marked spaghetti spaghetti spaghetti fail 
expression 
succeed sufficient plans succeed achievement expression succeed 
result step plan ordinary pasta invoked resulting achievement expression 
sauce 
result plans sauce alfredo called resulting calls observe alfredo 
spaghetti spaghetti failed expression 
spaghetti plan pasta dish fail 
result observing agent inferring agent making spaghetti possibly making alfredo 
agent subsequently observes alfredo act boil conclude agent plan pasta dish ordinary pasta alfredo 
dynamic agent logic main approaches reasoning programs modal logics theoretical computer science literature exogenous endogenous approaches dynamic logic exogenous logic explicitly represents programs language 
opposed endogenous logics computation tree logic ctl ctl represent programs explicitly consider part structure logic interpreted 
theoretical computer science dynamic logic essentially superseded endogenous logics particularly ctl number variants 
chosen exogenous logic dynamic logic represent plans agent fits naturally compositional nature plans 
reasons mental state agent execution recognition plan endogenous logic appropriate 
developed endogenous logics ctl bdi ctl bdi represent mental state agent captures agent beliefs desires intentions 
rational agents deal mental states plans combination exogenous endogenous logics ideal purposes 
mu calculus generalization ctl dynamic logic serve purpose 
dynamic logic dl providing semantics programming languages basis logic action extend dynamic logic ways 
provide semantics plans internal agent viewpoint external observer viewpoint usually done dynamic logic 
second introduce notion recognition class entity 
result agents choice execute action choice observe action 
third allow indirect call plans facilitating means reasoning notion central means plan execution recognition 
agents capable reasoning achievement certain states world ends necessarily reasoning programs means achieve states world 
extend dynamic logic explicitly introducing agents providing semantics internal agent viewpoint 
logic called dynamic agent logic dal better suited reasoning plans dynamic logic 
syntax consider language set primitive propositions set primitive plans actions lans set agents propositional operators form propositions denoted ff ff fi fi 
plan operators sequence non deterministic parallel form plan expressions denoted 
mixed operator 
achieve convert propositions plan expressions 
mixed operators hi exists execution executions hhii exists recognition recognitions form dynamic propositions denoted oe oe 
set formed propositions plan expressions dynamic propositions defined bnf notation ff ff ff ff ff 
oe ff oe ioe oe oe oe hh oe oe notation primitive proposition action agent 
section saw plan involved name invocation condition precondition postcondition body graph edges graph labelled simple plan expressions 
formally define plan tuple form ff ff fi ff invocation condition ff precondition body plan expressed plan expression fi postcondition 
semantics semantics dynamic logic defined terms set states say state transition function maps programs primitive non primitive set pairs states oe theta truth assignment function say formula ioe satisfiable state iff exists oe true treating program plan semantics reasonable matter process executes program result 
case plans notion agency agent executes plan important difference 
plans may identical capabilities agents may vary significantly leading different results 
semantics dynamic logic introduce subjective view world adopting possible worlds semantics 
view multiple worlds consisting set states 
actions executed agent world particular state choice relation 
composition choice relations results execution plan agent 
actions observable agent world particular state observe relation 
composition observe relations results recognition plan agent 
formally define possible worlds structure tuple wg fc fo set worlds set plans set agents world sw set states world agent primitive plan choice observe relation sw theta sw lw truth assignment function assigns state set propositional formulas lw sw rop associated world plan define derived relations ew sw theta sw rw sw theta sw transition relations correspond executions recognitions composition various choice observe relations respectively 
preliminaries position define semantics dal 
define semantics execution recognition formulas 
semantics propositional formulas straightforward 
oe ioe iff oe exists sw te oe oe hh iff oe ioe oe exists sw trw formula oe ioe variants similar hoare triples merely syntactic sugar testing truth oe followed ioe normal dynamic logics 
convenience shall abbreviate ioe ioe oe oe view important discuss mental attitudes agents performing executions recognitions see section 
oe oe iff oe sw te oe dynamic logic oe usually defined oe 
result ioe oe imply terminates 
avoid complication defining independently requiring computations terminate 
recognition plan take place executing plan world devoid event occurrences observe recognize 
needs agent observing events recognition take place 
semantic definition oe hh captures conditions 
formula oe oe defined analogously 
semantics various plan expressions defining transition relations ew rw primitive plans actions transition relations directly choice observe functions 
plan expressions form ff look plans invocation condition ff 
transition relations ff set transitions precondition plan satisfied initial state transition body plan expression transition postcondition satisfied 
transition relation sequences concatenation transition relations individual plan expressions 
transition relation non deterministic union transition relations individual plan expressions 
transition relation parallel operator intersection transition relations individual plan expressions intersection non null undefined 
formally definitions transition relations 
definitions tw stands ew rw ew primitive plan rw primitive plan tw ff ff ff ffi fi ff exists sw st ffi fi tw tw exists sw st exists sw tt tw tw tw 
tw tw tw tw tw model theoretic semantics execution recognition identical primitive plans 
primitive plans difference way plans agent 
semantics reflect operational semantics algorithms nodes nodes 
note success condition nodes identical execution recognition similarly nodes 
axiomatization dal modal operator denoting hhii hi 
oe oe oe oe oe 
oe oe oe axiom inference rules minimal set included theorems system axioms purposes clarity 

oe oe 
oe oe oe 
oe oe oe 
oe oe 
oe oe oe oe hh 
oe oe oe oe ioe 
oe oe oe oe oe 
oe hh oe oe ioe 
modus ponens 

modal generalization oe infer oe 

achievement plans set plans infer ff ff ff ffi fi ff ffi fi similarly 

achievement plans set plans infer hh ffii ff ff ffi fi ff hhffi similarly hi 
axioms inference rule modal generalization common modal operators 
axioms similar dynamic logic 
dynamic logic operator 
dynamic logic test operator 
iteration operator omitted simplicity 
axioms multi modal axioms link various execution recognition operators 
inference rules achievement states connects achievement expression plan achieves state 
case recognitions executions require plans achieve state recognized executed case single recognition execution just require plans achieve state recognized 
note associated agency respect agent actions primitive plans 
extending syntax semantics associate notion agency plans trivial actions performed agent 
extending choice plans involve actions agents non trivial task 
clear means agent choice executing plan involves agent executing action 
possible interpretation agent send message execute action wait successful completion action 
operational semantics lines discussed giving formal account theory involve extending dynamic logic message passing paradigm csp scope 
introducing iteration operator allow permit cyclic recursive graphs plan bodies 
iteration operator nondeterministically chosen finite number iterations infinite loops plan 
relationship algorithms logic consider relationship algorithms plan execution recognition introduced section dynamic agent logic 
particular want establish relationship successful running algorithm means recognition provability recognition formulas dynamic agent logic 
corollary get corresponding relationship means plan execution 
convert plan graphs discussed section dal expressions 
primitive plan equivalent agent executing observing plan fragment adjacent arcs labelled equivalent labels outgoing edges node equivalent similarly labels outgoing edges node equivalent basic transformations easily convert body plan single plan expression ffi plan invocation condition ff precondition ff postcondition fi body equivalent plan expression ffi treated formal plan ff ff ffi fi 
example plan ordinary pasta formally equivalent 
ordinary pasta true 

sauce boil true 
having converted plan executions recognitions equivalent dal formulas examine successful running algorithms provability certain formulas 
consider simple case means recognition algorithm agent set plans pi set propositions gamma expression form primitive plan 
algorithm returns successfully set propositions reasonable assume equivalent recognition expression eii valid dynamic agent logic fl conjunctions propositions gamma note successful run algorithm corresponds recognition path recognition paths observed 
fact stronger recognition formula fl valid dynamic agent logic state means recognition algorithm succeed input set propositions gamma output set propositions formally proposition proposition means recognition pi gamma returns success agent eii 
fl means recognition pi gamma returns success agent cases fl conjunction propositions gamma respectively 
proposition show similar results hold executions 
consider expressions form 
oe 
want show recognition algorithm called set plans pi set input propositions gamma expression 
oe succeeds output set propositions corresponding recognition formula 
provable respect set plans pi 
step proof involves transforming plan plan library formal equivalent detailed 
step converts body plans equivalent plan expression 
need show step algorithm observing actions recognizing plans recognizing nodes recognizing nodes corresponds axioms semantic definitions dal observing primitive actions proposition axiom inference rule ff axiom axiom respectively 
formally state theorem theorem running means recognition pi gamma 
ff agent returns success pi 
ffii fl conjunctions propositions gamma respectively 
proof proof involves case case analysis algorithms 
means recognition input expression achievement expression form ff algorithm computes set applicable plans 
invocation condition plans set ff precondition plans contained input set formulas gamma 
equivalent stating pi fl oe ff till pi fl oe ff ff ff preconditions formal plans invocation ff 
algorithm calls recognize plan plan bodies set applicable plans 
plan expressions corresponding plan bodies ffi ffi entire means recognition algorithm succeeds premise theorem plan bodies say ffi succeed 
assuming recognizing plan body equivalent ii conjunction recognizing plan pi fl oe ff oe hhffi ii note written fl oe ff oe precondition satisfied plan body run 
step adds postcondition plan results pi fi continuing previous paragraph pi fl oe ff oe hhffi ii fi 
inference rule achievement plans pi hh ffii ff oe hhffi pi fl ffii 
equivalent pi ffii 
prove assumption recognizing plan body equivalent ii recognize plan plan expression corresponding plan body ffi sequence ffi ffi ij plan expressions ffi ffi ffi ij ffi im corresponds plan expression equivalent labelling outgoing arcs node node node node 
assume recognizing node node equivalent pi oe im hhffi im im oe im state world recognizing ffi im oe im state world recognition 
step plan fl oe assumption pi oe hhffi node node corresponding ffi succeeds 
go loop recognize plan second time oe assumption pi oe hhffi combining pi oe hhffi oe hhffi axiom hhii propositional axioms pi oe hhffi axiom sequencing axiom pi oe hhffi ffi process continued steps loop number nodes plan 
pi oe hhffi ffi ij ij sequence ffi ffi ij equivalent ffi pi oe hhffi ij equivalences fl oe oe ij pi ii prove recognizing node equivalent pi oe im hhffi im im oe im state world recognizing ffi im oe im state world recognition 
recognize node plan expression ffi im ffi im ffi number outgoing arcs node ffi im ffi primitive action achievement formula form ff 
call means recognition results checking provability oe im hhffi im oe im hhffi algorithm recognize node succeeds arcs say ffi succeed 
ffi proposition pi oe im oe oe im ffi ff invoking current theorem ff results pi oe im hh ff oe oe im case pi oe im hhffi replace oe oe oe oe add disjuncts plan expressions obtain pi oe im hhffi im ii oe oe oe im hhffi ii oe oe oe im hhffi ii oe oe 
axiom non deterministic recognition ax pi oe im hhffi im ffi im oe im oe oe equivalent pi oe im hhffi im im recognize node reasoning node proceeds similar manner recognize node going arcs node succeed 
pi oe im hhffi im pi oe im hhffi axiom hhii propositional axioms write pi oe im oe hhffi im ii oe hhffi ii oe 
propositional rearrangement equivalent pi oe im oe hhffi im ii oe oe hhffi ii oe oe 
axiom recognition axiom pi oe im oe hhffi im ii oe oe 
replacing ffi im axiom hhii axiom pi oe im hhffi im im oe im oe oe converse theorem false recognition paths fail recognize ff set formulas gamma 
strengthening consequent theorem state provable pi 
ff succeeds recognition paths means recognition return success 
formally theorem theorem pi fl 
ff running means recognition pi gamma 
ff agent return success fl conjunctions propositions gamma respectively 
proof proof theorem similar theorem major differences ffl axioms hhii ffl proof proceeds bottom fashion show pi fl ffi im ffi im plan expression parallel operators node labelled expression succeed correct input output arguments 
progressively recognizing nodes recognizing plan means reasoner 
theorems establish strong relationship means recognition algorithm recognition formulas dal 
provide relative soundness completeness means recognition algorithms respect set plans pi 
corollaries theorems obtain similar relationships running algorithm means execution execution formulas dal 
going back example consider state world executing agent just executed primitive plan 
means recognition observer succeed 
corresponding recognition formula true dal 
inference rule achievement plans set plans pi making recognizing know way achieving 
agent recognize achievement formula ii true dal 
independent algorithms means recognition theorems prove axioms inference rules dal set plans set observations includes dynamic formula set propositions gamma includes kitchen prove dal hh ii 
words gamma hh ii 
reactive recognition discussed earlier means plan recognition restrictive assumptions world change recognition occurrence events external world synchronous recognition events agent 
discuss modifications required algorithms removing assumptions 
notice changes occurring environment process recognition recognition algorithm return control main loop step plan 
main loop decide new information environment rational proceed plan currently running change focus invoke new plan 
done run state plan captured step plan interrupts environment 
capturing state plan partially run continuing run long significant change environment introduces notion commitment plan 
commitment agent plan called intention 
agent invokes plan satisfy certain desire invocation condition plan 
precondition plan agent believe true running plan 
belief desire intention short mental state interpretation plan execution 
mental state interpretation reactive plan execution known community provide analogous mental state interpretation reactive plan recognition agent acquires desire recognize achievement certain state world adopts plans intends recognize plans intending recognize plan result agent adopting desire recognize arc body plan turn result agent adopting intentions plans recognize desire 
point time current recognition trace enable agent infer beliefs desires intentions agents 
having inferred mental state agents agent base executions recognitions inferred mental states 
words write plans precondition involves beliefs desires intentions agents inferred process 
leads powerful model interleaved reactive plan execution recognition 
modify syntax semantics plans invocation condition captures achievement recognition achievement certain states explicitly 
similarly plan expressions labelling edges explicitly capture execution observation primitive plans execution recognition achievement certain states 
provide resource bounded agent balance observation acts recognition desires execution acts executional desires 
words agent deliberate sense act long sense acting long act sensing 
get rid assumption synchronized occurrence events external world observation events making agents wait indefinitely observe event suspending corresponding intention 
models agent blind commitment recognition desires 
reasonable model agent open minded single minded commitment 
commitment commitment observing agent recognitions observing agent may need assume better recognize type commitment adopted executing agents 
leads interesting possibilities terms agents trying recognize agents attempting recognize actions 
information lead agents trying deceive agents opponents adversarial domains believing fulfilling certain desires fact attempting thwart recognition desires agents 
comparison regular context free languages known propositional dynamic logic pdl program viewed regular expression denoting set computation sequences simplest form plans introduced viewed likewise 
presence preconditions postconditions indirect call plans done achievement operator plans regular expression 
reactive recognition preconditions complex modal formulas beliefs desires intentions plans longer viewed simple grammars regular languages 
allowing recursive calls plans results context free grammar 
correspond context free pdl complex preconditions plans longer equivalent context free grammars 
plan recognition early allen perrault litman allen treat plan recognition reverse process planning classical sense 
litman allen plan library rich hierarchical structure 
theory outlined plans bottom fashion construct explanation observed behaviour basis observed actions running plans top fashion done 
kautz presents formal approach plan recognition event hierarchy guide recognition process 
explanation entailment constructed observation event hierarchy 
different possible explanations combined selecting covering models minimize number events 
done circumscription 
kautz provides graph algorithms plan recognition 
kautz approach proceeds bottom creating explanation observation merging explanations means plan recognition proceeds top requiring agent specify top level states world expecting recognize constructing explanation incrementally guided plans observation events 
example approach agent needs invoke means recognition algorithm expression pasta dish making pasta dish agent able recognize making pasta dish plan 
case kautz approach 
kautz deals powerful underlying interval temporal logic compared state dynamic logic 
observation match function observe expecting observe recognition plan fails 
extraneous events events associated current input expression occur means recognition fail recognize plan kautz algorithm robust infer plans 
reactive recognition algorithm discussed recognize plans 
spite differences approach gives result kautz limited cases provided assumptions true events observed order specified plan extraneous events agent chooses subset plans plan library recognize final recognized plans fall subset 
reactive recognition assumption required 
assumption results loss generality increases efficiency making approach feasible resource bounded agents situated dynamic worlds 
means plan recognition fairly constrained compared general plan recognition 
embedded mental attitudes agent combined reactive planning leads powerful theory 
lays foundation integrated theory reactive planning recognition providing theoretical principles means recognition analyzing relationship means execution 
discusses principles embodied existing reactive planning systems 
number issues remain addressed form reactive recognition subject feel approach shows promise large number application domains reactive planning successfully summary primary thrust shift partially focus attention plan recognition community reactive recognition 
mike georgeff valuable comments earlier drafts anonymous reviewers useful suggestions 
research supported cooperative research centre intelligent decision systems australian government cooperative research centres program 
allen perrault 
analyzing intention utterances 
artificial intelligence 
bratman israel pollack 
plans resource bounded practical reasoning 
computational intelligence 
burmeister 
cooperative problem solving guided intentions perception 
werner demazeau editors decentralized proceedings third european workshop modelling autonomous agents multi agent worlds amsterdam netherlands 
elsevier science publishers 
emerson 
temporal modal logic 
van leeuwen editor handbook theoretical computer science volume formal models semantics pages 
elsevier science publishers mit press amsterdam cambridge ma 
georgeff lansky 
procedural knowledge 
proceedings ieee special issue knowledge representation volume pages 
georgeff 
planning 
annual reviews palo alto california 
hoare 
communicating sequential processes 
prentice hall englewood cliffs nj 
ingrand georgeff rao 
architecture real time reasoning system control 
ieee expert 
kautz 
circumscriptive theory plan recognition 
cohen morgan pollack editors intentions communication 
mit press cambridge ma 
david kinny magnus ljungberg anand rao elizabeth sonenberg gil tidhar eric werner 
planned team activity 
proceedings fourth european workshop modelling autonomous agents multi agent world maamaw italy 
appears australian artificial intelligence institute technical note melbourne australia 
kozen 
results propositional mu calculus 
theoretical computer science 
kozen tiuryn 
logics programs 
van leeuwen editor handbook theoretical computer science volume formal models semantics pages 
elsevier science publishers mit press amsterdam cambridge ma 
litman allen 
discourse processing commonsense plans 
cohen morgan pollack editors intentions communication 
mit press cambridge ma 
magnus ljungberg andrew lucas 
oasis air traffic management system 
proceedings second pacific rim international conference artificial intelligence pricai seoul korea 
pollack 
plans complex mental attitudes 
cohen morgan pollack editors intentions communication 
mit press cambridge ma 
pollack 
uses plans 
artificial intelligence 
pratt 
semantical considerations floyd hoare logic 
proceedings th annual symposium foundations computer science pages 
rao morley murray 
representation selection execution team tactics air combat modelling 
proceedings australian joint conference artificial intelligence ai 
rao 
reactive plan recognition 
technical report australian artificial intelligence institute carlton australia 
rao georgeff 
modeling rational agents bdi architecture 
allen fikes sandewall editors proceedings second international conference principles knowledge representation reasoning 
morgan kaufmann publishers san mateo ca 
rao georgeff 
architecture rational agents 
rich swartout nebel editors proceedings third international conference principles knowledge representation reasoning 
morgan kaufmann publishers san mateo ca 
rao georgeff 
model theoretic approach verification situated reasoning systems 
proceedings thirteenth international joint conference artificial intelligence ijcai france 
segerberg 
getting started beginnings logic action 
studia logica 
shoham 
agent simple agent language interpreter 
proceedings ninth national conference artificial intelligence aaai pages 
invocation condition plan body 
ordinary pasta 
pasta dish pasta dish body 
spaghetti invocation condition plan body 

ordinary pasta ordinary pasta body 
sauce boil spaghetti invocation condition plan 
spaghetti spaghetti invocation condition plan 
pasta dish pasta dish invocation condition plan body 
sauce sauce invocation condition plan body 
invocation condition plan body spaghetti 
spaghetti invocation condition plan body alfredo 
sauce alfredo sauce precondition kitchen postcondition meal prepared precondition kitchen postcondition meal prepared plan library making plan 
name 
invocation 
precond 

body 
name 
string invocation 
ff precond 
ff body 
node 
gamma label 
body 
node 
label 
body 
node 
label 
ff node 
symbol fag stands 
bnf syntax plans procedure means recognition case type primitive action result observe return result achievement soap fg invocation condition precondition soap soap parallel soap result recognize plan body result success postcondition return success return failure 
algorithm means recognition procedure recognize plan plan body start node plan body node case type result recognize node result recognize node result success node return failure return success 
algorithm recognizing plan body procedure recognize node parallel arcs arcs result means recognition label result success dest node return success return failure 
algorithm recognizing nodes procedure recognize node parallel arcs arcs result means recognition label result failure return failure dest node return failure 
algorithms recognizing nodes pasta dish pasta dish ordinary pasta spaghetti pasta dish ordinary pasta spaghetti spaghetti spaghetti call graph making just observation 
