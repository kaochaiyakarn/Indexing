reasoning functions effects carolyn talcott department computer science stanford university clt sail stanford edu www formal stanford edu clt home html important advantage claimed functional programming elegant equational theory ability reason programs simply replacing equals equals 
higher order functions provide ability define high level abstractions simplify programming 
hand real programs effects concise express computation effects 
best worlds functions effects 
methods described allow expressive power functions effects develop rich equational theories languages 
extend previous semantics imperative functional languages talcott mason talcott honsell mason smith talcott treating combination control memory effects developing semantic theory setting better capture essential features program equivalence 
adopt view proposed landin programming language consists expressions lambda calculus augmented primitive operations 
call languages languages 
primitive operations mind include basic constants branching algebraic operations arithmetic pairing operations manipulate computation state store continuation environment sending messages creating processes 
presence higher order objects languages defining reasoning program equivalence complicated order case effects 
methods results described arose desire treat wide range languages unified manner 
consider sequential languages key ideas extend primitives concurrency agha mason smith talcott 
talcott overview take operational approach defining semantics languages 
small step semantics computation state represented syntactic entities expressions contexts 
single reduction rule operation 
care taken reduction rule operation changed new operations new pieces state added 
computation uniform sense reduction steps performed states missing parts missing information filled 
syntactic reduction system combined advantages simple transition system semantics symbolic reasoning reduction calculus 
details computations defining notions operational approximation equivalence expressions 
intuitively expressions operationally equivalent called contextually equivalent literature program context distinguish 
precisely operational equivalence equivalence naturally associated operational approximation pre order 
expression operationally approximates expression placed closing program context resulting program undefined resulting programs defined 
laws program equivalence including laws axiomatize operations effects hold general nature languages considering 
laws robust sense invalidated addition new primitive operations language subject minimal constraints semantics 
include laws computational lambda calculus moggi program calculi developed felleisen felleisen hieb scheme languages :10.1.1.26.2787
laws typically simple computational justifications 
example expressions equivalent reduce common expression having effect computation state 
example expressions equivalent correspond placing third expression computationally equivalent contexts 
laws change order evaluation need careful formulation sensitive particular choice primitive operations 
order get better understanding observations identify properties operational semantics language structure computation states reduction rules allow establish computational laws quite general setting 
properties hold say language uniform semantics 
allows build equational core holds languages uniform semantics investigate specialized laws framework 
key result languages uniform semantics alternate characterization operational approximation relation reduces number contexts considered establish laws approximation equivalence 
particular show need consider contexts reasoning functions effects correspond computation states hole corresponds program counter expression evaluated 
call ciu theorem contexts considered correspond closed instantiations uses expressions tested 
rudimentary characterization turns quite useful 
method establishing correctness alternative characterization relies notion uniform computation underlies definition uniform semantics 
uniform computation allows computation steps carried states missing information 
property computing commutes filling missing information 
ciu consequences uniform semantics establish general principles proving program equivalence capture computational intuitions 
ideas concrete give uniform semantics derive equivalence laws algebraic control memory operations combined form kernel scheme untyped ml language 
related previous talcott mason felleisen moggi establishes mathematical foundation studying notions program equivalence programming languages function control abstractions operating objects memory 
builds landin reynolds morris plotkin 
landin reynolds describe high level machines defining language semantics 
morris defines extensional equivalence relation classical lambda calculus 
plotkin extends ideas call value lambda calculus introduces operational equivalence relation 
talcott mason talcott mason talcott develop various operational methods studying operational approximation equivalence subsets language function control abstractions objects memory 
agha mason smith talcott extend methods develop operational semantics language primitives actor computation distributed object computation 
felleisen studies reduction calculi extending call value lambda calculus languages control assignment abstractions 
calculi simplified extended felleisen hieb 
notion computational monad framework axiomatizing features programming languages introduced moggi 
reduction calculi operational equivalence provide sound basis purely equational reasoning programs 
calculi advantage reduction relations inductively generated primitive reductions beta conversion closure operations transitive closure congruence closure 
equations proved calculus continue hold calculus extended treat additional language constructs 
talcott operational equivalence definition sensitive set language constructs basic data available 
pure reduction calculi adequate prove basic equivalences languages effects 
example felleisen necessary extend reduction calculus meta principles cf 
safety rule felleisen thm 
operational approximation express prove properties non termination computation induction existence fixed points expressed reduction calculi 
uniform semantics framework provides extensibility reduction calculi wide range languages 
operations semantics reduction rules modified new features added language 
kind modularity spirit action semantics mosses 
objective action semantics support modular compositional specification semantics language allowing feature specified independently allowing new features added modifying specification original language 
accomplished splitting computation state orthogonal facets defining set action combinators denotations 
action semantics treats wider range languages provides number generic tools 
development equational theories derived action semantics begun lassen see 
fact syntactic reduction system imperative calculi discovered independently talcott mason talcott felleisen hieb 
conceptually elegant provided necessary tools key results proofs 
addition eliminating messy isomorphism considerations deal arbitrary choice names newly allocated structures key step leading formulation ciu theorem mason talcott 
mason realized provided ideal notion normal form symbolic evaluation needed completeness result mason talcott 
syntactic reduction systems provided basis elegant revision imperative calculi felleisen published felleisen hieb 
successful uses technique include type soundness proof subject reduction imperative ml type system felleisen wright analysis parameter passing algol crank felleisen weeks felleisen analysis reduction calculi scheme languages sabry felleisen fields sabry 
done develop methods reasoning operational approximation equivalence abramsky bloom honsell ronchi della rocca howe gordon lassen mason mason talcott jim meyer milner ong pitts stark ritter pitts pitts smith sullivan talcott reasoning functions effects 
methods developed reasoning operational approximation equivalence include general schemes establishing equivalence context lemmas alternative characterizations reduce number contexts considered bi simulation relations alternative characterizations approximations inductively defined relations 
early example milner context lemma milner greatly simplifies proof operational equivalence case typed lambda calculus reducing contexts considered simple chain applications 
talcott studies general notions equivalence languages call value lambda calculus develops schemes establishing properties relations 
howe develops schema proving congruence class languages particular style operational semantics 
schema succeeds capturing simple functional programming language features 
building howe uses approach similar idea uniform computation define structured evaluation systems form evaluation rules guarantees bi simulation relations congruences 
form rules specified meta variables arities higher order substitutions 
syntax enrichment similar notions place holder filling specify uniform semantics 
idea meta terms specify classes rules giving rise reduction relations special properties aczel prove general church rosser theorem klop develop theory combinatory reduction systems 
meta terms describing unification procedure higher order patterns nipkow 
discussed mason talcott introduced ciu characterization operational equivalence form context lemma imperative languages 
uniform computation method prove ciu adapted develop computational path transformation methods proving equivalence actor programs agha mason smith talcott 
ritter pitts operational techniques establish correctness translation imperative subset standard ml simply typed lambda calculus types 
applicative bisimulation defined shown sound operational equivalence 
relation adequate establishing correctness translations question weaker operational equivalence 
finding bisimulation relation coincides operational equivalence case imperative higher order languages scheme ml remains open problem author knowledge 
pitts proves context lemma higher order language assignable variables store order values 
proof uses logical relations defined terms operational semantics 
logical relation mechanism combined context lemma provide useful method establishing program equivalence 
pitts stark extend ideas language richer types 
challenging problem apply logical relations approach un talcott typed languages 
sullivan takes mixed operational denotational approach 
metalanguage pcf extended dynamic store primitives defined operationally 
context lemma language proved proving applicative simulation relation precongruence 
reason programs imperative features giving compositional denotations metalanguage 
promising blend operational denotational semantics providing better approximation operational equivalence existing denotational approaches 
gordon uses standard process algebra techniques derive bisimulation relations labelled transition systems operational semantics 
case typed functional languages pcf streams bisimulations coincide operational equivalence 
interesting see approach defining bisimulations extended imperative languages develop useful complete reasoning tools 
lassen presents approach developing general framework reasoning program equivalence action semantics mosses 
operational pre orderings defined portion action notation adequate functional languages 
imperative effects action semantics allows non deterministic primitives interest multiple pre orders 
simulation relations essentially complete defined pre orders verify properties untyped pcf language giving language action semantics 
stage effort consider actions support imperative primitives 
induction rule establishing operational equivalence language cells captures reasoning mason talcott papers computation induction ciu theorem suggested lassen 
plan remainder organized follows 

develop general framework studying equivalence programs languages 
basic syntactic notions introduced semantic notions definedness equivalence defined relative details filled specific languages notion uniform semantics introduced key properties languages uniform semantics stated 

give semantics representative collection functional primitives discuss equational laws functional primitives valid language uniform semantics 
consider properties specific functional language 

give semantics typical control primitive discuss equational theory 

give semantics collection primitives allocating accessing updating ml cells discuss equational theory operations 

combine primitives previous section full scheme language discuss reasoning functions effects ramifications individual equational theories 

introduce place holder machinery needed fill details definition uniform semantics languages 
show languages defined previous sections uniform semantics 

uniform computation techniques establish ciu theorem languages uniform semantics 
establish results provide basis developing core equational theory valid languages 

contains concluding remarks 
way give simple programming proving examples provide basic intuitions various program primitives reasoning principles 
examples programming proving functions control memory burge talcott felleisen mason mason talcott 
examples include higher order functionals generic program modules manipulating mutable lists stream processing routines objects functions lambda abstractions state 
notation conclude summary notation conventions 
sets 
specify meta variable conventions form range read meta variable decorated variants 
range set fmap set finite maps write dom domain function rng range 
function ffx 
function dom dom fxg dom 
fdx restriction function dom dom dom 
set natural numbers range defining equations various syntactic classes notational conventions pointwise lifting syntax operations syntax classes einstein summation convention phrase form abbreviates 
example omega ranked set operator symbols terms omega defined inductively solution equation omega omega omega 
equation reads omega omega omega ng general framework section general framework studying semantics languages set 
syntactic entities semantic notions languages defined properties required uniform semantics stated 
talcott results including ciu theorem valid language uniform semantics 
simplify reasoning effects restrict attention call value semantics see problem adapting basic ideas evaluation strategies 
expression syntax language fix countably infinite set variables basic syntax language determined giving countable set atoms family operation symbols fo ng set ary operation symbols sets pairwise disjoint 
assume contains binary operation app lambda application 
example obtain expressions pure call value lambda calculus definition set expressions set abstractions defined sets satisfying equations range range range range elements called lambda abstractions briefly lambdas 
binding operator free bound variables expressions defined usual 
expressions considered equal renaming bound variables 
fv set free variables write fv fv fv 
closed expression expression free variables 
substitution fx free occurrences defined usual renaming bound variables needed avoid capture free variables common abbreviations notation conventions 
app app app app app ffi fv sequencing fv yv app app app app call value recursion combinator reasoning functions effects operational semantics overview small step operational semantics obtained defining notion state single step reduction relation states 
states consist expression state context 
state context describes dynamically created entities memory cells arrays files form state contexts needed depends choice primitive operations 
empty state context state associated expression representing state 
value expressions subset set expressions represent semantic values 
include variables atoms lambdas 
expression component state value state value state reduction steps possible 
expression decomposes uniquely redex placed reduction context 
call value redex primitive operator applied list values 
reduction rule primitive operator single step reduction relation states determined reduction rule redex operator 
course may happen redex ill formed runtime error reduction step possible 
state defined just reduces finite number steps value state 
basic notions define operational approximation equivalence relations usual way 
basic semantic framework independent choice primitive operations 
framework define notion uniform semantics develop tools proving laws approximation equivalence languages uniform semantics 
particular choice operations remains define ffl structure state contexts including specifying empty state context map giving expression associated state ffl reduction rule primitive operation operational semantics details precise concepts discussed 
pointed features fully defined relative obey certain constraints may vary depending particular choice language 
distinguish situations header definition signal definitions uniformly defined features header specification signal constraints language dependent features 
concepts context value expression value substitution needed state definitions definedness operational equivalence 
sufficient state requirement uniform semantics unif global uniformity 
introduce additional notions talcott reduction context redex 
allows describe form computation rules state informally second requirement uniform semantics unif stepwise uniformity 
state ciu theorem consequences formalize principles underlying computational laws equivalence 
definition contexts contexts expressions holes 
ffl denote hole 
set contexts defined ffflg range denotes result replacing hole free variables may bound process 
example free occurrences bound expression placed hole ffl ffl traps set lambda variables hole scope variables trapped holes filled 
example traps ffl fxg 
note renaming bound variables context allowed changes meaning context 
example ffl contexts interest property holes scope contexts renaming bound variables valid extend application substitutions contexts defining ffl fx ffl 
specification value expressions value substitutions set value expressions contains variables atoms lambdas 
may addition contain expressions form 
value substitutions finite maps variables value expressions 
closed application value substitutions 
precisely require fmap range oe range oe result simultaneous substitution free occurrences dom oe oe care trap variables 
write fx 
ng value substitution oe domain fx ng oe operators produce value expressions called constructors 
languages considered binary pairing operation pr serve prototypical constructor 
specification state contexts subset consisting set state contexts ranges pi empty state context 
oe result replacing free occurrences dom oe gamma traps oe 
variables fv oe traps may bound process 
full determination pi oe language part defining semantics 
languages considered reasoning functions effects state context context single hole 
context surrounding hole thought canonical form describing state expression placed hole evaluated 
variables trapped hole state context provide means naming dynamically created values 
example operators effects pi ffl pig 
language primitive operation aref constructs cells atoms aref aref aref ffl state context representing state cells referred initially contains initially contains see 
slightly complex contexts needed represent memory may contain cycles 
states languages considered decomposed trapping done allocation describes state allocated structures effects 
case define oe oe dom oe traps 
continuing example cells atoms assume atom nil assignment operation assigns cell atom 
refine state contexts aref aref aref aref aref nil aref nil ffl aref ffl 
specification computation states cs cs set computation states 
range cs state state context expression map associating state representing expression 
restrict attention case mapping defined hole filling 
state closed just corresponding expression closed 
application value substitutions states defined oe oe oe dom oe traps 
specification reduction gamma gamma gamma 
single step reduction relation states gamma reflexive transitive closure gamma 
example single step reduction relation relation ffl app gamma 
ffl fx vg ffl gamma 
ffl ffl app gamma 
ffl app ffl gamma 
ffl ffl app gamma 
ffl app see define rule app arbitrary language 
notice restrict reduction relation closed states 
definition definedness states definedness approximation equi definedness computation length defined states js defined gamma talcott js reduces value state steps 
set requirements uniform semantics stated 
require single step reduction essentially deterministic reduction preserved value substitution state associated expression started empty state context equi defined state reduces states equi defined reduct shorter computation length defined 
definition global uniformity unif language satisfies unif hold 
unicity gamma 
gamma 
gamma 
oe gamma 
oe dom oe traps traps rep pi red gamma 
js js languages consider unicity holds non determinism reduction step choice names state context 
rep holds reduction pi essentially state context 
red says state defined reduction progress 
clearly reduct state defined original state defined 
easy see satisfies properties 
hard part show value substitution beta reduction commute standard result 
approximation equivalence define operational approximation equivalence lay ground studying properties relations 
definition approximation equivalence fv pi pi easy see operational approximation congruence 
similarly operational equivalence 
simple examples stated lv fv lv app app app reasoning functions effects lv example expression placed computationally equivalent contexts 
precise 
lv holds expression defined context approximates expression 
see establish results arbitrary language uniform semantics 
define reduction rules state additional properties reduction equivalence introduce notions redex reduction context 
evaluation call value redex simply non constructor operator applied appropriate number value expressions 
redexes value expressions disjoint account fact expressions form may value expressions 
example app redex language pr redex language operations contain binary pairing constructor pr 
definition redexes set redexes defined gamma reduction contexts called evaluation contexts literature identify subexpression expression reduction value occur 
correspond left call value reduction strategy plotkin introduced felleisen friedman 
definition reduction contexts set reduction contexts subset defined ffflg om range app ffl reduction context app ffl reduction context app app ffl app ffl reduction contexts 
hole reduction context scope bound variables free variables trapped filling hole reduction context 
particular application value substitutions extends reduction contexts 
easy check expression value expression decomposes uniquely redex placed reduction context proof mason talcott 
lemma decomposition written uniquely reduction context languages considered single step reduction relation defined giving reduction rule operation 
ideally give rule operation independent language subject constraints ensuring state contexts adequate support operation 
difficult task 
approximate solution define reduction rules minimal information context surrounding redex 
detail 
simple example rule talcott application operation app expressed language independent way follows app gamma 
fx vg consider remaining requirements uniform semantics unif 
objective formalize requirement reduction rule uniform form parameters 
reduction step may depend kind construction redex argument information subparts 
enriching syntax languages include place holders various syntactic sorts 

give details syntax enrichment show reduction rules lifted states enriched syntax 
introduce just notation aide reading stepwise requirement 
decorate metavariables signify enriched forms 
expression enriched syntax 


result filling expression place holders similar notation filling place holders sorts entities sorts 
definition uniform reduction unif language satisfies unif single step reduction relation lifted states enriched syntax 
gamma 


gamma 


sort place holders 



gamma 
touches hole form place holder gamma 



definition uniform semantics language uniform semantics satisfies unif unif 
key result languages uniform semantics ciu theorem 
theorem reduces number contexts need considered establishing operational approximation equivalence 
ciu form context lemma milner 
typically context lemmas characterize equivalence applicative contexts contexts form ffl app observing termination equality observable values booleans numbers 
context lemma uses arbitrary reduction contexts observing termination 
state ciu theorem introduce ciu approximation relation holds just closed instantiation expression approximates state closed instantiation second expression 
definition ciu approximation ciu ciu oe oe closed oe oe reasoning functions effects theorem ciu language uniform semantics operational approximation ciu approximation coincide ciu proof theorem uniform computation machinery developed 
approximation lv easy consequence ciu 
consequence 
corollary substitutivity language uniform semantics operational approximation preserved substitution oe oe similarly operational equivalence 
state theorems underlying computational equivalences general setting introduce notion context independent ci redex 
definition context independent reduction ci gamma redex ci interpretation independent context reduction possible state redex replaced reduct expression state 
exactly holds 
gamma 

gamma 
ci redex examines modifies context state reduction 
example redex operator app ci 
write ci gamma gamma sequence ci steps intuition expressions equivalent common reduct justified equi reduct 
similarly reasoning expressions equivalent result placing third expression computationally equivalent reduction contexts justified equi rcx 
theorem equi reduct language uniform semantics ci gamma proof assume ci gamma 
ciu symmetry show need show ciu pick closing oe assume oe 
assumption unif oe ci gamma oe 
unif oe oe 
equi theorem equi rcx language uniform semantics fresh ci gamma proof theorem establish result general setting uniform computation machinery 
fact prove talcott stronger version conveniently stated enriched syntax 
equivalence lv direct consequence equi rcx 
global variant equi reduct applies reduction holds strengthen final clause unif 
definition strongly uniform semantics language strongly uniform semantics satisfies properties unif unif unif specification obtained adding clause gamma 
implies oe oe closing oe requirement strong fact easy show languages considered 
corollary language strongly uniform semantics reduction preserves operational equivalence gamma 

language uniform semantics reduction steps states free variable uniform assumption precise unif 
theorem lambda uniformity unif working language uniform semantics state free variable fp gamma 
form app fp gamma 
fp similarly multiple free variables assumed lambdas 
easy verify unif place holder uniform computation machinery place 
unif gives simulation method establishing equivalence lambdas 
intuitively see lambda approximates terminating computation containing occurrences substitution instances transformed terminating computation containing corresponding occurrences substitution instances second 
states variables mark corresponding occurrences lambda instances 
lambda uniformity lets reduce establishing correspondence considering case marked lambda occurrence applied 
corollary unif sim language uniform semantics show suffices show list instantiations free variables oe closes instantiated lambdas may free variables fp find list additional instantiations oe reasoning functions effects 
app gamma 
steps 
fp 
kg app fp 
ing proof assume conditions hold 
ciu show suffices show fp 
ing fp 
ing list instantiations closing free variables fp ng 
assume left hand state defined show induction computation length right hand state define 
unif cases consider 
fp ing value done 
gamma 
assuming fp ng lambdas 
unif smaller computation length computation induction done 
form app 
assumption 
find extend list instantiations app fp 
ing gamma fp 
kg steps fp 
kg computation induction assumption 
done 
illustrate unif sim prove yv fixed point combinator 
theorem fix form yv fixed point fix yv yv yv proof yv yv ff yv 
notation convention reduces lambda write lambda 
particular rule app yv gamma yv yv gamma yv 
convention equi red 
rule app yv gamma yv 
prove fix notation unif sim take ff yv vg easy see conditions hold directions approximation 
prove assume 
fresh 
yv gamma fp yv see conditions unif sim hold done 
talcott functional primitives example languages considered assume contains distinct atoms playing role booleans true nil false atoms playing role natural numbers denote 
functional language operations includes lambda application app arity branching br arity equality atoms eq arity pairing pr fst snd arities arithmetic operations iszero 
arities 
definition value expressions completed specifying pr branching primitive strict due call value semantics 
usual conditional defined follows 
app br nil fv functional case state information state context initial context represent empty context pi ffl 
write ffl states notationally distinguished expressions self representing expression representing state ffl want specify rules functional primitives manner language containing primitives 
allow free variables redexes reduce testing operations br eq variable argument necessary know variable bound state context complex states information binding may needed 
define reduction rules terms satisfaction relation phi state contexts assertions phi 
allows specialize reduction rule operation particular language completing specification satisfaction relation state contexts language 
languages considered assertions membership non membership sets values binary relations values 
definition assertions range sets values range binary relations values 
assertions forms define satisfaction empty context language 
state constraints satisfaction 
definition satisfaction pi phi ag reasoning functions effects pi iff fa pi iff pi iff gamma fa pi iff theta gamma note general state context provides partial information need satisfy membership assertion corresponding assertion 
example pi pi holds variable require assertion holds empty context holds context 
satisfaction preserved value substitution 
specification satisfaction phi pi phi phi phi oe phi oe dom oe traps static assertions defined case phi gamma 
implies phi don official requirement 
state context reduction context changed reducing functional redex define local reduction relation 
lift states obvious manner 
examples local functional reduction rules give rule application aka beta rule rules branching projection tests pairs equality 
definition functional rules app app 
fx vg br br 
ae fst fst pr 

ae nil eq eq 
ae nil gamma 

easy see form rules unif holds addition properties computation lemma fred unif gamma 
gamma 
gamma talcott sampling equational laws functional operations 
laws correspond laws computational lambda calculus moggi :10.1.1.26.2787
theorem functional laws language uniform semantics extending app fx vg dist fv dist proj fst pr snd pr nil proof proj follow equi red equated expressions common reduct 
dist dist follow equi rcx stronger form needed dist equated expressions result placing common expression equivalent reduction contexts 
functional laws functional computation effects computations results permuted 
lemma perm fv fv law relies strongly fred property fails various ways shall see presence effects 
programming examples undefined functions ciu easy see undefined expressions equivalent 
abstracting unif lambdas undefined equivalent 
classic example undefined lambda bot app app app example undefined lambda forever loop 
yv recursive definition lambda value gamma reasoning functions effects gamma undefined 
case computation undefined redex undefined 
case computation reduces go 
argument undefinedness bot relies app rule valid uniform semantics 
contrast argument undefinedness relies fred property functional streams illustrate unif sim computation reason streams represented functions accessed applied return pair consisting stream element function representing remainder stream 
gordon shown bisimulation methods suited reasoning equivalence functional streams 
see unif sim generalizes nicely reasoning objects private memory 
nums stream numbers increasing order odds stream odd numbers starting 
alt stream obtained removing element nums yv nums pr nums alt yv alt nil snd xs nil pr fst xs alt snd ys odds yv odds pr odds lemma odds odds alt nums 
proof odds alt nums 
computation rules odds alt nums gamma pr fp easy see unif sim conditions hold directions approximation 
odds control effects introduce control effects adding new primitive operator ncc note current continuation 
language control facilities operations 
talcott roughly speaking ncc captures current reduction context continuation applies continuation top level 
ncc called felleisen friedman felleisen 
ncc differs scheme call cc primitive steele sussman rees clinger call cc evaluates application captured continuation context continuation discarding 
call cc defined ncc follows 
call cc ncc ncc define abort primitive 
call top represent top level computation 
top simply returns argument top level 
top ncc functional case state context initial context pi top ffl 
state form pi expression associated state defined pi top 
state context keep explicit notation emphasize distinction top level presence control primitives simple functional case 
reduction rules functional operations apply directly states satisfaction pi language 
need supply reduction rule ncc 
definition ncc reduction ncc ncc gamma 
app top ffi convention lambda appear abbreviates fv 
functional primitives specified rule ncc manner defines rule language containing ncc operation 
say language ncc control ncc operations language reduction rule ncc language reduction rules manipulate reduction context 
particular rules primitives ncc form gamma 

introduce notion ncc control characterize class languages basic ncc laws hold 
see permitting control primitives invalidate laws 
lemma top rule derived reduction rule top top top gamma proof computation rules top ncc reasoning functions effects gamma 
ncc fv gamma 
app top ffi gamma 
top rule provide intuition computation ncc introduce useful abbreviation note derive computation rule 
note binds current continuation arranges evaluated discarding current continuation 
note call cc note ncc app lemma note rule note note gamma app top ffi fc proof note ncc gamma 
app top ffi gamma 
app top ffi fc note rule easy see unif holds functional reduction properties fred fail 
see note top non empty value top reduces 
lemma useful dealing top level 
lemma top elim language uniform semantics ncc control top ffi top top closed proof show unif noting top rule app gamma ftop ffi 
done top rule 
computation leading invoke ncc rule ncc control assumption states undefined lead value state 
suppose gamma ncc steps involving ncc 
gamma app top ffi top gamma app top ffi top ffi 
functional laws top top ffi top done 
top elim talcott top elim establishing number basic ncc laws 
see fail presence control primitives consider adding fcc defined rule fcc gamma 
app 
continuation captured fcc composes escaping surrounding context applied 
fcc bot 
top gamma gamma bot undefined 
sampling laws axiomatizing ncc 
theorem ncc laws ncc language uniform semantics ncc control ncc ncc ncc app top ncc ncc app ffi fv ncc ncc top ffi ncc ncc top ffi note fv note note fv fv note note note fv proof general idea establishing ncc 
show ciu suffices show oe oe closing oe 
proceed follows follows direct calculation 

find oe gamma 
show top ffi top ffi oe 
top top elim top top ffi dist condition 
done 
example carry process ncc 
case note note fv fv 
pick closing oe top ffi fc ffl note reasoning functions effects note rule unif easy check conditions 

hold 
ncc laws somewhat non intuitive equivalence holds languages ncc control top top simply expresses fact values returned top observed program 
refined notion equivalence equation holds value expressions equivalent ncc laws valid studied talcott 
note bot fails reason ability escape loop 
distinguishing context note iszero gamma app ffl 
perm fails permutation order expression evaluation change termination properties 
counterexample ncc bot ncc bot gamma bot ncc gamma app ncc gamma forever lemma shows call cc note inter definable ncc definable call cc top 
lemma control call cc note note call cc ncc call cc top proof follow expanding definitions possibly 
requires application ncc 
memory effects consider memory effects 
language operations fmk get set intuitively mk allocates new cell containing returns cell get returns contents cell set sets contents cell tests cell 
talcott state context memory context form mk nil mk nil set set ffl allocate new cells named sets assign contents 
value put cell refer newly created cell set omitted value expression argument corresponding mk 
general separation allocation assignment needed order represent stores cycles 
example consider creating cell contains 
described memory context mk nil set ffl 
context mk ffl case argument mk bound outside context distinct created memory contexts syntactic representation stores traditional semantics finite maps locations storable values 
define analogs finite map operations memory contexts 
dom fz write fz 
mk kg notation intentionally ambiguous order allocation cells assigning values cells 
care finite map represented ambiguity difference 
empty state context empty context ffl map associating states expressions defined 
define reduction relation new operations new assertions cell cell needed 
definition satisfaction state contexts completed follows 
definition satisfaction memory contexts cell iff dom cell iff dom dom fa definition memory rules ae cell nil cell mk mk gamma 
fz 
mk dom fv get get gamma 
set set gamma 
fz 
mk nil dom reasoning functions effects recall 
local reduction lifts rule gamma 
note rule get expressed local rule get dom mv hand rules mk set formulated local rules 
easy verify unif holds unicity property explicit fact model arbitrary choice cell allocation phenomenon arbitrary choice names bound variables 
analog fred holds lemma mred unif gamma 
gamma 
dom fv dom gamma simple consequences computation rules memory contexts may pulled reduction contexts computation uniform unreferenced memory 
lemma ffl gamma fv dom 
gamma 
gamma 
dom dom gamma 
gamma 
dom fv dom note clause implies dom dom 
example computation mutable analog nums 
value object script private cell accessible initial contents queried returns contents increments contents generating stream numbers 
mk get set computation rules lemma 
lemma rules dom fv gamma fz 
mk numa fz 
mk gamma fz 
mk talcott proof ffl ffl mk definition gamma 
ffl mk app gamma 
fz 
mk mk app fz 
mk gamma 
fz 
mk get set app gamma fz 
mk set get app gamma fz 
mk set app mred unif done 
equivalences sampling laws axiomatizing memory operations 
extends definition eq cells 
taken primitive defined shown mason 
derived computation rule ceq dom ceq iff ceq pi ceq iff dom gamma ceq ae ceq nil ceq theorem memory laws mem get mk mk mk nil mk set mk fv set get set set set set set set fv dom proof memory laws established general argument formalizes intuition expressions equivalent reduce expression effects memory ignoring inaccessible memory garbage 
show ciu pick arbitrary closing oe show oe oe reasoning functions effects 
show common reduct result common effects garbage dom dom fv oe gamma 
mred unif oe gamma 
states 
done 
example argument consider memory law oe 
get mk fz 
mk oe ffl oe 
simplify presentation rules equational theory memory operations generalized wide class languages identifying conditions prevent interference memory operations done theory ncc 
perm law fails simple counterexample obtained set set get 
mem allocation memory permuted evaluation expressions access memory 
key law reasoning programs manipulate memory see mason talcott examples 
lemma delay fv fv mk mk delay fairly easy consequence ciu mred 
proof appears mason talcott 
example memory delay laws show mk mk nil mk mk mk mk dist twice mk mk delay mk mk nil mem nil mem talcott stream object equivalence example uniform computation techniques show equivalence stream objects built mutable analogs alto nums alt odds 
defined 
mk get set alto app nil app nil lemma mutable stream alto proof proof indicates generalize unif sim objects 
objects private memory done bit care 
ciu need show alto unif derived computation rules defined objects need show fz 
mk fz 
mk alto defining notion similar states showing computation induction similar states equi defined 
similar states states form fz 
mk fo fz 
mk fo alto dom fv fv fog 
show equi definedness assume 
done 
unif gamma 
assuming done smaller computations form form app 
case gamma fz 
mk fo gamma fz 
mk fo alto desired smaller computations form 
examples proof principles proofs reasoning mutable streams forms object including simulation induction principle abstracts generalizes argument mason talcott 
reasoning functions effects control memory effects combine control memory operations obtain scheme language operations union operations state contexts combine memory context top marker form top ffl 
write mt state expression state context top ffl 
usual expression associated state defined mt top 
reduction relation obtained combining rules operations works adding top marker change satisfaction operation ncc uniform state context 
definition reduction rules mt gamma 
mt pi gamma 
pi mt gamma 
gamma 
note top top state contexts form top changing induced approximation equivalence relations 
properties memory computation persist semantics uniform 
functional ncc memory laws hold top elim property holds mred fail reasons fred fails pointed felleisen delay fails expression evaluation permuted memory allocation control effects 
example failure obtained ncc set get get 
see problem ffl set get mk ncc ffl mk set get ncc eq ffl bot pi pi 
semantically expression control free computation context evaluation instance expression uses control rules 
syntactically ensure requiring ncc appear expression imported definitions get appear control effects dynamically imported applications form app functions control effects imported environment 
example app get import control talcott effects contents app import control effects value determined program context 
lemma delay fv fv control free mk mk note argument establish delay works mred holds computations allowed uniform computation section develop machinery necessary state precisely unif property uniform semantics 
enrich language syntax include place holders expressions reduction contexts 
stating unif requirement show contained languages uniform semantics lifting reduction rules enriched states manner meets unif requirements 
motivate definition enriched syntax consider adding place holders closed expressions case state contexts trivial states simply expressions 
holes traditional contexts defined kind place holder expressions 
keep uses separate introduce fi place holders 
add fi clause defining expressions just added ffl obtain standard contexts 
enriched versions remaining syntactic sorts generated replacing expressions enriched expressions definitions 
signify entities enriched syntax sorts decorating metavariables 
fi replaced closed expressions extend substitution enriched syntax defining fi oe fi 
filling place holders closed expression substitution fi simple enrichment adequate closed expressions 
doesn provide adequate notion uniform reduction arbitrary expressions 
see consider app app fi fi 
lift reduction rules definition substitution gamma fi fi 
app gamma app app 
clearly need keep track substitutions occurrences fi 
try decorating fi substitution carried place holder filled extend substitution enriched syntax composing place holders 
starting empty substitution decorating occurrences fi app app fi fi gamma 
app fi fi fy xg notice continue computation decorating substitutions allowed values enriched syntax range 
reasoning functions effects solution problem appropriate notion place holder idea decorating holes substitutions accomplishes things 
provides means defining substitution expressions enriched place holders way filling substitution commute 
key lifting computation rules enriched states 
separates mechanism trapping free variables filling expression mechanism binding free variables filled expression 
province decorating substitution trapped variables domain 
province usual propagated filling expression binding free variables range decorating substitution 
consequence separation alpha conversion valid lambda variables place holders scope 
presentation adapted agha mason smith talcott uniform computation methods developed establish equational laws actor computations 
turn theory binding structures talcott 
add holes filled expressions summands defining equation expressions holes filled reduction contexts summands defining equation reduction contexts 
add holes redex hole filled summands defining equation expressions 
specifications remaining syntactic classes correspondingly modified refer enriched syntax 
adopt convention extended syntactic class indicated mark metavariables ranging classes indicated mark prefix names classes er 
er expressions ranges er reduction contexts ranges consider syntactic entities enriched kind place holder 
read er prefix mark ffi hole enriched syntax prefix mark pi hole enriched syntax 
speak expressions ffi ranges ffi expressions pi ranges pi simplicity give definitions languages additional values pairs 
definition ffi pi pr fmap ffl om pi gamma binding operator free variables er expressions defined follows talcott definition free variables fv fv oe fv ffi oe fv oe fv pi oe fv oe fv fv fxg fv fv gamma fzg fv fv fv fv oe dom oe fv oe variables domain occurrence oe free bound 
renaming bound variables substitution free variables act range substitution associated hole domain 
definition substitution oe oe oe fi oe substitution extended er expressions follows ffi oe oe ffi oe pi oe oe pi oe oe oe ae dom oe oe dom oe oe oed dom oe fv oed dom oe gamma fzg oe oe oe ffl oe ffl pi oe oe pi oe oe oe fi oe dom oe oe oe defined substitution partial operation 
renaming substitutions bijections variables rename bound variables usual way 
consider er expressions entities containing equal differ renaming bound variables 
substitution choose variant substitution defined 
recall renaming possible case traditional contexts 
operations filling holes ffi 
filling pi 
defined induction structure substitution rename bound variables avoid capture free variables lambda binding 
expression placed hole reduction context place hole filled decorating substitution applied filler 
similarly filling holes er reduction contexts 
definition ffi 
ffi oe ffi 
oe ffi reasoning functions effects pi oe ffi 
pi oe ffi ffi 
ffi 
ffi 
ffi 
ffi 
ffi 
ffi 
fv oe ffi 
dom oe oe ffi 
consider simple example 
ffi ffi 
ffi ffi 
ffi ffi 
ffi ffi 
ffi ffi 
example shows things precise domain substitution decorating hole important 
contrast substitutions viewed maps expressions oe map 
xg dom oe 
definition pi 
ffi oe pi 
ffi oe pi pi oe pi 
oe pi pi 
pi 
pi 
pi 
pi 
pi 
pi 
fv oe pi 
dom oe oe pi 
example hole filling pi fx xg pi 
app ffl app easy tedious check hole hole filling commute 
lemma er hole filling ffi 
pi 
pi 
ffi 
lemma key developing notion uniform computation 
proof agha mason smith talcott 
lemma fil subst hole filling substitution commute 
ffi ffi oe ffi 
ffi ffi 
ffi oe ffi dom ffi oe fv pi pi oe pi 
pi pi 
pi oe pi dom pi oe fv note er reduction contexts possess types holes decorated holes traditional holes 
process filling redex hole ffl talcott expression ffi remains unchanged continue denote ffi ffi 
defining ffl ffi 
ffl pi 
ffl see filling decorated holes commutes 
lemma er hole fill ffi 
ffi 
pi 
pi 
example commuting pi fx xg ffl pi 
app ffl pi fx xg ffl pi 
app ffl app ordinary context corresponding expression ffi 
obtained decorating hole occurrence binding substitution fx 
xg set lambda variables having hole occurrence scope 
example expression corresponding ffl ffi decomposition lemma er expressions new cases hole hole appears redex position 
proofs easy induction syntax structure 
lemma expression decomposition er expression exactly holds 

oe ffi oe 
oe pi oe ffl 
er states composed er state context er expression 
contexts formed just state contexts replacing value expressions er value expressions constructions 
particular continue ordinary holes hole filling represent state contexts conversion expressions 

er state expression decomposes case said touch hole 
filling er states defined ffi 
ffi 
ffi 

cases considered hole filling er state contexts defined decomposition states constant allocation part effects part 
example case memory contexts fz 
mk ffi ng ffi 
fz 
mk ffi ffi 
ng similarly hole filling 
reasoning functions effects property required er computation uniform semantics stated er state reduces uniformly hangs uniformly touches hole 
definition uniform reduction unif language satisfies unif property reduction rules extended states 
gamma 
ffi 
gamma 
ffi 
pi 
gamma 
pi 

ffi 
gamma 
pi 
gamma 
touches hole form form ffi oe pi oe gamma 
show lift reduction rules languages considered previous sections 
place holders occur value expressions inside lambda presence change definition satisfaction relation state contexts 
reduction rules various operations extended er redexes er states simply annotating metavariables 
examples give local rules app br eq 
local lifting rule rules ncc set 
definition reduction rules lifted app app 
fx 
vg br br 
ae eq eq 
ae nil gamma 

ncc ncc gamma 
app top ffi set set gamma 

mk nil dom theorem uniformity languages uniform semantics 
proof ciu theorem consequences proof ciu proofs ciu theorem literature 
proof mason talcott uses uniform computation technique talcott details fully spelled 
honsell mason smith talcott proof observation suffices show ciu congruence 
recall statement theorem 
ciu approximation relation defined ciu oe oe closed oe oe want show language uniform semantics ciu iff implies ciu direct definitions 
relies fact oe pi oe pi oe oe expands parallel substitution oe suitable sequence care sequentialization cause substitution range oe 
fact follows unif 
need show assumption ciu representation contexts expressions suffices show ffi ffi ffi 
ffi ffi ffi 
state ffi ffi sides closed 
induction computation length 
assume ffi ffi ffi 

consider case value expression 
ffi ffi ffi ffi ffi 
value state 
show ffi ffi ffi 
need find ffi ffi 
ffi ffi ffi 
gamma ffi ffi ffi 
steps 
ffi ffi ffi 
implies ffi ffi ffi 


induction hypothesis imply ffi ffi ffi 

ffi ffi gamma 
ffi ffi done 
unif ffi form ffi ffi ffi oe 
value holes ffi oe appear inside lambdas case ffi oe form ffi ffi 
unif ffi ffi ffi ffi ffi oe gamma 
ffi ffi clearly ffi ffi satisfies condition 
see satisfies condition 
note ffi ffi ffi oe ffi 
gamma 
ffi ffi ffi 
ciu hypothesis ffi ffi ffi oe ffi 
ffi ffi ffi oe ffi 
case value expression prove lemma shows filling finite number holes ffi obtain reasoning functions effects expression ffi ffi value ffi ffi reduces giving ffi ffi satisfying condition 
holes filled appear redex positions may apply ciu assumption show 
holds 
lemma 
lemma ffi ffi ffi 
find ffi ffi ffi ffi oe ffi ffi ffi ffi ffi ffi oe ffi ffi ffi oe ffi value ffi ffi ffi ffi ffi ffi reduces 
proof ffi ffi required 
decomposition lemma unif ffi form ffi ffi ffi oe 
case ffi ffi ffi oe continue process 
step reduces number holes scope lambda terminate 
ffi ffi ffi ffi oe note ffi ffi 
ffi ffi 
prove induction gamma ffi ffi ffi 
argument case non value 
assume ffi ffi ffi 
construction ffi ffi 
ffi ffi oe ffi 
ciu hypothesis ffi ffi ffi oe ffi 
completes value case 
ciu leave proof unif reader note reduces assuming reformulated replacing free occurrences ffi fx xg proof equi rcx ciu combined uniform computation establish equi rcx 
readers convenience recall statement theorem 
theorem equi rcx language uniform semantics fresh ci gamma talcott establishing equi rcx fairly straightforward application ciu combination fred mred 
fairly easy 
establish result general setting requires bit 
hole uniformity uniform semantics 
prove general result 
theorem equi rcx language uniform semantics show suffices show pi pi pi oe fresh pi closes pi pi oe find pi pi pi pi oe gamma pi pi easy see uniformity properties equi rcx 
implies equi rcx 
proceed proof general result 
proof equi rcx assume equi rcx hypothesis 
ciu need show oe oe closing oe 
claim closing pi pi pi pi pi 
pi pi pi 

pi pi pi oe oe done 
prove claim pick closing pi pi pi pi pi 

pi value pi pi steps uniformly done 
decomposition property pi form pi pi pi oe pi 
assumption find pi pi pi pi oe pi gamma pi pi pi pi pi 
gamma pi pi pi 
gamma steps pi pi steps uniformly pi pi pi 
computation induction done 
similarly pi pi done 
uniformity may assume pi pi pi oe pi form pi pi pi oe pi apply argument pi pi pi fewer pi scope lambda process terminate proof ciu done 
equi 
unified earlier semantics imperative functional programs general setting 
defined notion uniform semantics languages developed general principles reasoning program equivalence languages uniform reasoning functions effects semantics 
particular shown ciu theorem holds language uniform semantics 
languages combined benefits reduction calculi modular axiomatization operational equivalence equations 
small step usable methodology developing equational semantics higher order languages effects number directions 
useful refinement identify form rules guarantees uniform semantics generalizing ideas howe functional languages effects 
extension develop denotational tools setting generalizing mason smith talcott 
direction treat wider range languages 
particular interest extending uniform framework incorporate actor concurrency primitives 
mentioned earlier notion uniform computation key developing methods reasoning program equivalence language actor primitives 
actor world termination interesting property infinite fair computations interest 
appealing computation induction uniform computation transform computation paths preserving fairness 
general setting facilitate extending programming logic honsell mason smith talcott wider range program primitives 
builds done collaboration ian mason contributed important ideas insights 
author ian mason lassen scott smith jos meseguer ian stark numerous helpful criticisms pointing errors earlier draft 
editors volume andrew gordon andrew pitts encouragement patience writing 
research partially supported arpa navy onr nsf ccr nsf ccr 
abramsky 

lazy lambda calculus 
turner ed research topics functional programming 
addison wesley 
abramsky 

domain theory logical form 
annals pure applied logic 
talcott aczel 
july 
generalized church rosser theorem 
agha mason smith talcott august 
theory actor computation 
third international conference concurrency theory concur volume lecture notes computer science pp 

springer verlag 
agha mason smith talcott 
foundation actor computation 
journal functional programming appear 
bloom 

lcf 
information computation 
burge 

stream processing functions 
ibm journal research development 
crank felleisen 
parameter passing lambda calculus 
proceedings th acm symposium principles programming languages pp 

honsell ronchi della rocca 
operational denotational logical descriptions case study 
fundamenta informaticae 
felleisen 

calculi lambda cs conversion syntactic theory control state imperative higher order programming languages 
ph 
thesis indiana university 
felleisen 

cs extended calculus scheme 
acm conference lisp functional programming volume pp 

felleisen 

personal communication 
felleisen friedman 
control operators secd machine calculus 
wirsing ed formal description programming concepts iii pp 

north holland 
felleisen hieb 
revised report syntactic theories sequential control state 
technical report comp tr rice university 
felleisen hieb 
revised report syntactic theories sequential control state 
theoretical computer science 
felleisen wright 
syntactic approach type soundness 
technical report rice comp tr rice university computer science department 
appear information computation 
fields sabry 
reasoning explicit implicit representations state 
acm sigplan workshop state programming languages 
yaleu dcs rr 
gordon 
july 
bisimilarity theory functional programming mini course 
technical report ns brics department computer science aarhus university 
honsell mason smith talcott 
variable typed logic effects 
information computation 
reasoning functions effects howe 

equality lazy lambda calculus 
fourth annual symposium logic computer science 
ieee 
howe 

proving congruence bisimulation functional programming languages 
information computation 
jim meyer 
full abstraction context lemma 
theoretical aspects computer science volume lecture notes computer science pp 

springer verlag 
klop 

combinatory reduction systems 
number mathematical centre tracts 
mathematisch centrum amsterdam 
landin 

mechanical evaluation expressions 
computer journal 
landin 

programming languages 
comm 
acm 
lassen 

private communication oct 
lassen 
december 
action semantics reasoning functional programs 
technical report ns brics department computer science aarhus university 
mason 

semantics destructive lisp 
ph 
thesis stanford university 
available csli lecture notes center study language information stanford university 
mason 

verification programs destructively manipulate data 
science computer programming 
mason smith talcott 
operational semantics domain theory 
information computation appear 
mason talcott 
programming transforming proving function abstractions memories 
proceedings th eatcs colloquium automata languages programming volume lecture notes computer science pp 

springer verlag 
mason talcott 
reasoning programs effects 
programming language implementation logic programming plilp volume lecture notes computer science pp 

springerverlag 
mason talcott 
equivalence functional languages effects 
journal functional programming 
mason talcott 
program transformation configuring components 
acm ifip symposium partial evaluation semantics program manipulation 
mason talcott 
inferring equivalence functional programs mutate data 
theoretical computer science 
mason talcott 
program transformation contextual assertions 
jones hagiya sato eds logic language talcott computation festschrift honor satoru number lecture notes computer science pp 

springer verlag 
mason talcott 
reasoning object systems 
submitted international journal foundations computer science 
milner 

fully models typed calculi 
theoretical computer science 
moggi 

computational lambda calculus monads 
technical report ecs lfcs university edinburgh 
moggi 

computational lambda calculus monads 
fourth annual symposium logic computer science 
ieee 
moggi 

view programming languages 
technical report ecs lfcs laboratory foundations computer science university edinburgh 
morris 

lambda calculus models programming languages 
ph 
thesis massachusetts institute technology 
mosses 

action semantics 
number cambridge tracts theoretical computer science 
cambridge university press 
nipkow 

higher order critical pairs 
sixth annual symposium logic computer science 
ieee 
ong 

lazy lambda calculus investigation foundations functional programming 
ph 
thesis imperial college university london 
pitts 

reasoning local variables operationally logical relations 
eleventh annual symposium logic computer science 
ieee 
pitts stark 
observable properties higher order functions dynamically create local names 
acm sigplan workshop state programming languages 
yaleu dcs rr 
pitts stark 
operational reasoning functions local state 
higher order operational techniques semantics 
plotkin 

call name call value lambda calculus 
theoretical computer science 
rees clinger 
revised report algorithmic language scheme 
sigplan notices 
reynolds 

definitional interpreters higher order programming languages 
proceedings acm national convention pp 

ritter pitts 
fully translation calculus types standard ml 
proceedings tlca edinburgh 
sabry felleisen 
reasoning programs continuationpassing style 
lisp symbolic computation 
reasoning functions effects smith 

operational denotational semantics 
mfps volume lecture notes computer science pp 

springerverlag 
steele sussman 
scheme interpreter extended lambda calculus 
technical report technical report massachusetts institute technology artificial intelligence laboratory 
sullivan 

extensional metalanguage dynamic store 
ph 
thesis northeastern university 
preparation 
talcott 

essence rum theory intensional extensional aspects lisp type computation 
ph 
thesis stanford university 
talcott 

programming proving function control abstractions 
technical report stan cs stanford university computer science department 
talcott 

binding structures 
lifschitz ed artificial intelligence mathematical theory computation 
academic press 
talcott 

theory program data type specification 
theoretical computer science 
talcott 

theory binding structures applications rewriting 
theoretical computer science 
weeks felleisen 
orthogonality assignments procedures algol 
proceedings th acm symposium principles programming languages pp 

