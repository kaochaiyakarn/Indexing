signals timers continuations multithreaded user level protocols juan carlos gomez james pollard vernon rego department computer sciences purdue university west lafayette usa april precise timing asynchronous appealing features applications 
unix kernels provide features process basis signals communicate asynchronous events applications 
process signals timers grossly inadequate complex multithreaded applications require signals timers operate finer granularities 
respond need scheme integrates asynchronous unix signals userlevel threads ariadne system platform 
done view support portable multithreaded distributed applications viz 
clam connectionless lightweight multiway communications library 
context propose continuations efficient mechanism reducing thread context switching busy wait overheads multithreaded protocols 
proposal integrating timers signal handling mechanisms solves problems related race conditions offers efficient flexible interface timing signalling threads 
precise timing mechanisms asynchronous invaluable features complex software applications 
implementation user level protocols example accurate timing asynchronous help enhance performance increasing bandwidth utilization reducing network input polling overheads 
unix kernels provide features process basis signals inform applications asynchronous events 
interoperability user level threads process level signals weak best 
process signals timers grossly inadequate complex multithreaded applications require signals timers efficiently operate thread granularities 
view efficient thread operations scheme integrates asynchronous unix signals user level threads describe portable efficient integration scheme ariadne system 
presentation context support portable multithreaded distributed applications viz 
clam connectionless lightweight multiway communications library 
framework propose continuations efficient mechanism reducing thread context switch busy wait overheads multithreaded protocols 
proposal integrating timers signal handling mechanisms solves problems related race conditions offers efficient flexible interface timing signalling threads 
timers essential variety complex software applications particular critical implementing communication protocols real time applications 
sender initiated protocols timers schedule packet retransmissions receiver initiated protocols timers schedule requests missing packets protocols credit flow control timers schedule transmissions window probe packets reliable multicast protocols timers schedule periodic transmission heartbeat packets 
polling protocol implementations rate flow control schemes employ timers scheduling message retrieval message transmission respectively 
general timers lie heart failure recovery schemes fundamental mechanisms schedule access limited resources coordination periodic control transfers time slicing distinct threads processes 
significance precise timing capability performance user level protocols accepted issues timing raised addressed researchers implementation reliable uni multi cast user space protocols 
timers key performance fairness scheduling witnessed experiences clam connectionless lightweight multiway communications environment offers distributed threads single address space 
clam demands timers portable flexible precise efficient 
timers portable flexible facilitate rapid ports coding protocol libraries user applications 
timers precise support efficient implementations protocols high speed networks real time applications 
timers efficient intensively protocol modules 
implementation portable flexible precise efficient timer subsystem integration user level threads system depends solution specific problem problem integrating asynchronous process signals user level threads 
apart providing asynchronous timing information signals asynchronous network input type asynchronous communication initiated kernel 
signal handling functionality advantage applications including multithreaded user level protocols asynchronous network input key factor delivery low latency messages 
user level multithreaded applications require flexible thread signal handlers capable executing threads 
operating systems user level threads libraries lack important functionality provide restricted subset 
main hurdles overcome provision flexibility efficient delivery asynchronous signals coordination threads currently executing critical sections 
focus coordination interface precise timing rapid signal handling 
features implemented ariadne significantly improve performance clam user level multithreaded protocols 
presents extensions ariadne threads system intended enhance efficiency flexibility context multithreaded user level protocols 
extension described sections consists cost effective solution challenge integrating asynchronous signals user level threads 
enhancement ariadne alongside flexible extended interface handling asynchronous timed events signal activated threads 
second extension detailed section addresses various uses possible implementations continuations mechanism meant improve efficiency multithreaded applications threads packages interface extensions described section 
section results set experiments conducted evaluate precision timed events ariadne system 
conclude briefly section 
timers multithreaded environments enhance software portability ariadne timers known unix signals 
principle appropriate multiplex unix timing signals delivery process enable different functions execute scheduled times 
functions simple run quickly accessing shared data structures invoking thread primitives async unsafe functions 
functions little practice method practical 
useful functions useful lend smooth asynchronous interoperability ongoing computations 
timed functions able freely invoke thread primitives yield control new threads effect context switch general invoke async unsafe functions restriction 
consider example kind flexibility required timed functions building real time protocol threads 
sending host may schedule timed async unsafe functions non reentrant functions involve internal state stored global variables 
functions run deallocate messages transmission deadlines expired 
functions return buffer space occupied messages shared pool buffers reuse transmitter threads 
distinct active entities access shared pool asynchronous manner thread lock guard uncontrolled updates maintain consistency buffer state 
timed functions able exploit thread locks 
example timed function requirements protocols built threads consider implementation reliable protocol 
message retransmissions handled timed functions capable invoking thread operations may potentially block 
block may occur thread involved retransmission needs access shared data structure connection record congestion flow control mechanisms 
respond requirements described mentioned examples threads system offer efficient form protection signals 
specifically threads system ensure signal delivered host process current thread running critical section general async unsafe function 
guarantee signal handlers timed functions free invoke thread primitive async unsafe function 
freedom significantly enhances thread system flexibility ability respond timely manner 
requirement stringent observe signal handler allowed initiate thread reschedule operation invocations async unsafe functions protected originate signal handler 
protection new thread scheduled signal handler may potentially invoke async unsafe function executed interrupted thread blocked thread 
signal masks simplest way ensure required protection mask signals threads system critical section async unsafe function 
solution comes high cost involves interaction system kernel system calls 
unix system calls async unsafe invocation shielded explicit signal masking operations turn add significant overhead 
reschedule function typically critical section threads system thread rescheduling operations need shielded explicit signal masking 
result cost context switching user level threads climb value comparable cost kernel level threads cost increase come advantages kernel level threads 
apparent high cost chose pursue solution signal masks 
global flags timed events ensure necessary protection signals alternative exploit global flags 
global flag signal handler informed thread interrupted executing unsafe code 
signal handler determines interrupted thread executing unsafe region may delay execution unsafe code thread exits unsafe region may defer execution interrupted thread voluntarily yields control 
call solution active delay approach second solution passive delay delay context switch approach 
passive delay variant timing timed functions precise cost effective sacrifices accuracy favor efficiency 
postponing execution asynchronous timed function context switch introduces random delay eliminates overhead incurred active delay scheme repeated scan pending timed functions time threads system exits critical section 
basic comparison motivated leading design considerations portability efficiency flexibility built timed function timed event subsystem global flags integrated subsystem ariadne threads system 
subsystem provides active delays passive delays default 
method timed events occur timed functions run immediately unix timer timing loaded short time shortens potentially large delay event occur thread context switch timer expires whichever occurs 
small enhancement improves execution time accuracy reducing effects unix coarse grained process oriented timers applications high context switching rates 
determine events expired finer granularity provided unix process timer timers read increase accuracy comes cost timer handling overhead 
compare performance global flag signal mask methods handling signals simple measurements costs system calls implementations 
cost reloading unix timer mhz sun sparcstation system call required global flag implementation approximately corresponding cost system call required signal mask implementation approximately considering rate system calls method global flag implementation shows clear advantages 
signal mask method system call shield ariadne thread primitives particular henceforth term unsafe code identify async unsafe functions critical sections 
methods scheduling time global flag scheme may incur cost extra calls function events run expiration time 
clam signals timers kernel ariadne user space threads os signal os process timers signals ariadne rescheduling routine signals delivered run 
system call invoked frequently independently number events scheduled 
contrast expense extra timer reload global flag method incurred signal delivery encounters threads system critical section 
likelihood event small relative potential invocations cost global flag method bound smaller 
implementation issues timing signal handling functionality supports clam library implemented module ariadne structure shown 
tight integration module rest threads system pivotal ariadne ability flexible deliver precise efficient timing signal handling 
design enables users develop timer signal activated routines free invoke thread primitives 
furthermore design facilitates low cost precisely synchronized timer signal activated executions concert threads 
timing signal handling capability implemented outside threads library cost crossing additional interface scheme unattractive 
enhance portability implemented ariadne timers wellknown unix signals 
signals sharing cpu time different runnable threads time slicing timed bound scheduling functions threads 
ariadne timers effectively multiplex process level timing signals obtain efficient thread level timing facility 
ariadne embedded signal handling code captures smoothly integrates unix implicit signal asynchrony threads system manner promotes timing efficiency prevents race conditions 
ariadne event scheduled run time represented function pointer parameter flag specifying type expiration time 
timed events stored heap data structure delta queue timers expire 
event timer expires associated function invoked thread function depending flag held event record 
number event heaps held process may high number process timers 
heap bound timed unix timer 
event handlers execute functions efficient restricted sense invoke thread primitives invocation lead awkward results ariadne currently support 
example consider thread waits semaphore just yield control thread 
assume waiting thread interrupted timed event run function wait semaphore interrupted thread waits 
event run stack waiting interrupted thread possible single thread simultaneously queued semaphore 
ariadne currently support extra handling overheads 
contrast event handlers may execute independent threads unrestricted access thread primitives 
gives considerable flexibility expense scheduling overhead little higher function invocation 
optimistic event handler oeh model execution model ariadne timed events 
model concept optimistic active messages oam 
intention free user having decide events handled functions events handled threads 
optimistic event handlers execute functions point cause reschedule 
point new thread automatically created resume rest rescheduled event computation 
handlers tend reduce scheduling overheads events invoke threads primitives seldom block cause rescheduling operations naturally wasteful create new threads events general 
ariadne current implementation timed events may described follows 
unix timer linked heap contains events times await expiry 
event scheduled time expires unix timer linked loaded expiration time event heap expiry time 
timers switched pending events 
timing signals processed single handler 
signal handler determines threads system currently executing unsafe code global flag identifies condition set 
case processing event time just expired postponed actual delay depends variant global mask solution employed 
threads system critical section event time expires event processed immediately manner depends function thread optimistic handler 
ariadne supports types timed events thread time slicing events thread resumption events functions thread bound delay sensitive events delay tolerant events 
thread time slicing event causes preemption currently running thread reschedule operation runs runnable thread highest priority 
runnable thread priority equal higher preempted thread exist preempted thread allowed resume 
event causes preemption currently running thread insertion previously suspended thread back ready queue reschedule operation reschedule causes highest priority runnable thread run 
function timer expires runs stack currently executing thread 
thread bound event function execute thread stack 
class events specifically designed support scheduling functions may invoke thread primitives run completion quickly justify overhead thread creation 
ariadne threads system maintains internal linked list idle threads exclusively purpose executing thread bound events 
new threads added dynamically list order meet increasing concurrency levels required application 
thread bound event timer expires thread extracted linked list serve host 
event execution complete thread returned linked list idle threads free new events 
set thread bound events strict deadlines hosted single thread events expire time 
support enables thread bound events run simultaneously additional overhead scheduling distinct threads event 
limit number events may hosted single thread helps prevent unbounded delays event executions 
thread bound events strict deadlines assigned individual threads ensuring run unpredictable delays 
ariadne timed events offer efficiency flexibility scheduling precision depends accuracy underlying unix process timers 
current implementation reduce dependency scanning expired events thread context switch 
technique generally improves timing precision applications high rates thread context switching little improve precision timing applications exhibit low context switching rates 
fortunately applications clam threads intensively high rate thread witness precise timing capability 
precision limitations addressed efficiency ariadne timers falls number pending events event queue large 
direct result cost event insertion delta queue data structure implementation 
heap provide log cost insertion time delta queue simple insertion time controlled pattern seen way timers 
doubly linked delta queue offers constant cost deletion compared log cost deletion heap 
clam employs techniques achieve efficient timing doubly linked delta queue 
minimizes number waiting events controlling number events scheduled simultaneously 
second exploits information expiration time events scheduled enable perform efficient insertions delta queue 
clam uses ariadne timers events require precise timing occur simultaneously large numbers 
reduce insertion time delta queue ascertain sequence expiration times set events currently scheduled increasing decreasing sequence 
sequence increasing set insertion point determined searching queue starting tail queue element largest expiration time 
sequence decreasing search starts head queue queue element smallest expiration time 
scheduling events require precise timing may potentially occur simultaneously large numbers handled clam library level hosted single timed thread 
enables reduction number pending events ariadne delta queue ensure reasonable precision efficiency timing 
suspension period timed thread manages clam events set match minimum timing granularity required events hosts 
implementation operations performed threads system involve timers low cost operations 
scan expired events thread context switch incurs small constant cost operation require function call event expired 
reload unix timers incurs small constant cost 
cost event insertion delta queue small constant event expiration time sequences increasing decreasing 
total factors combine yield excellent performance precision functionality 
signal thread activation ariadne threads library offers important feature signal thread activation 
functionality crucial provision efficient support implementation multithreaded communication protocols 
signal handling primitives especially tailored implementation multiple user level protocols single address space 
ariadne provides interface similar feature offered posix threads semantic differences 
interface ariadne threads may wait specific signals promptly activated signals delivered 
illustration consider uses thread activated signal offers efficient clean mechanism capturing state changes child processes multithreaded application similarly activated receive thread offers efficient low latency mechanism receiving messages arrive unpredictable times 
indicated section handling signals multithreaded systems complicated task potential race conditions 
possible resort simple solutions prevent race conditions may involve significant overheads 
current implementation signal thread activations trade efficiency precision signal delivery obtain design similar design timed event support 
ariadne signal wait functionality differs functionality provided posix threads occurrence signal awakens waiting threads single thread shown 
semantic implemented special purpose respond need asynchronous thread activation environments 
multiple receive threads useful exploit concurrency inherent multiple protocols run address space 
demonstrate functionality environments consider situation multiple receive threads protocol thread operating distinct socket 
assume socket signal enabled 
best scenario receive threads awaken handle protocols messages arrive 
posix semantic thread allowed resume way ensure thread corresponds protocol messages arrived 
unfortunately unix signals help obtaining selectivity fail provide information necessary differentiate signals generated different sockets 
remaining alternative awaken sleeping receive threads determine received messages 
posix signal wait semantic permit direct implementation solution thread signal 
ariadne semantic allows threads waiting signal resume execution delivery signal 
non blocking receive calls thread determine supposed retrieve input generated signal 
solution effective terms functionality necessarily entails scheduling overhead due activation receive threads related protocols potentially incoming messages 
feel reasonable portable mechanism multiplexed signal especially number simultaneously running protocols large 
continuations multithreaded protocols continuation useful abstraction exploited reduce memory context switching overheads multithreaded environments 
thread discard low level execution state stack block preserving posix semantic ariadne semantic signal signal tn thread waiting signal signal wait semantic posix vs ariadne crucial state information continuation record 
general abstraction uses little memory manipulated application yield enhanced efficiency flexibility 
continuation implemented function set parameters runs just thread time context switch 
threads system effects reschedule operation yield control continuation system need run usual save restore procedures required switching control threads 
continuation runs executes stack thread yielded control eliminating overhead thread context save context restore operation 
continuations previously studied context kernel implementations 
framework user level threads libraries multiprocessors intent reduce locking effects resulting implementation register save restore operations critical sections threads system 
knowledge attempt exploiting continuations support multithreaded user level protocols 
focus application continuations protocols 
appealing continuation involves ability store execution context part thread code 
continuation may run part code causes thread potentially block wait busy cycle 
way remaining thread code free continue execution continuation independently waits blocking condition clear 
particular continuations enhances concurrency simultaneously eliminating context switching overheads incurred thread blocks 
similarly continuations reduce overheads unnecessary busy waits locks enable execution progress allowing remaining thread code run comes cost additional reschedule operations 
may tempting continuations potentially blocking sections thread code workable order thread continuations executed conflict remaining thread code 
despite limitation occurrence thread blocks busy waits implementations frequent continuations offer potential high savings 
consider illustration continuations help efficiency multithreaded protocol implementations 
buffer handling thread completes usage message buffer typically buffer reuse returning shared pool 
shared pool buffers protected lock semaphore keep state consistent 
crucial thread requests buffer obtain buffer continuing execution crucial thread releasing buffer wait buffer placed shared pool 
initiating buffer release thread may continue tasks buffer returned shared pool 
situation offers ideal opportunity continuation implementation buffer release performance improves circumvents unnecessary thread blocks busy waits 
implement current thread initiates buffer release finds access shared pool locked thread immediately posts continuation complete task 
continuation run time stack thread gives control appropriate implement continuation function runs acquire lock quickly returns buffer shared pool releases lock terminates 
example continuations implementations reliable protocols built threads 
instance receive thread may post messages receive queue concurrently accessed application level threads 
access receive queue protected lock state kept consistent 
receive thread spins busy wait blocks thread accesses receive queue network utilization falls context switching costs rise 
solution continuations follows 
receive thread finds locked thread creates continuation post message lock eventually released 
way receive thread may process incoming messages rapidly having block spin waiting post messages upper protocol layers 
continuation solution receive thread continue run interruption service burst packet arrivals 
true receive queue locked thread currently suspended 
addition eliminating busy waits unnecessary context switches continuations offer improved cache locality receive thread code 
continuations offer mechanism performance enhancement limited situations sections thread code run independently sections 
consider example situation 
implementing sender initiated reliable protocol module receive thread may need update connection record protected lock sending acknowledgment sending thread 
connection record update delayed acknowledgment sent receive thread may carrying obsolete duplicate information leads poor network bandwidth equally poor synchronization sender receiver 
programming interface section programming interface ariadne timed events signal activated threads 
interface provides user primitives schedule cancel timed events different forms include timed functions timed timed thread bound functions time sliced events 
section contains description mechanisms set clear activate ariadne signal handlers primitive enables threads wait specific signals calls enable pre post execution actions specific threads 
terms implementation mechanism resembles signal delivery unix set user level threads framework 
post execution actions operations small duration scheduled occur immediately specific thread yields control 
useful flexible functionality comes adverse affects performance incorporated basic threads system 
timed events ariadne provides special support types timed events type event time slicing timed thread resumptions 
primitives handle time slice events 
enable disable initialize respectively time slicing threads priority level 
thread activated scheduling policy indicates run time slice event posted flag time slice expiry 
event occurs thread time quantum causes new thread possibly new time slice event scheduled 
thread run time slice yields cpu control time quantum expires time slice event cancelled control transferred thread 
ariadne primitive defines priority levels time slicing enabled indicates specific timer 
primitive cancel previously scheduled pending time slice event 
primitive initialize time slice events 
prototypes calls handle time slicing void void void int int long long parameter specifies type timer signalling time slice expiry possible values parameter include real real timer exec virtual timer 
parameter assume valid ariadne priority level constant value 
defines priority levels time slicing mode operation thread scheduling 
constant indicates mode applies priority levels 
inputs specify time slice length quantum seconds microseconds respectively 
primitive sleep schedule timed thread resumptions suspending threads specific periods time 
invoking sleep thread creates event record schedules wake event record 
specified time elapses wake event occurs event action returns thread ready queue effects reschedule operation 
call flexible application may select particular timer signal thread suspension interval 
prototype sleep primitive void sleep long long int parameters specify suspension time seconds microseconds respectively 
parameter specifies timer signal thread resumption event possible values parameter real real timer exec virtual timer 
timed thread bound events timed functions manipulated help primitives set language macros rt vt rt vt rt vt prototype call void void fn void void struct fl primitive schedules function specified parameter fn invoked argument specified time particular timer real virtual event manner time parameter interpreted relative absolute manner event executed specified single parameter fl 
parameter combination flags applicable priority event execute priority value located upper half fl parameter 
constants specify parameter absolute time time relative current time respectively 
flag set delay sensitive thread bound events cleared timed functions delay tolerant thread bound events 
flag set delay tolerant thread bound events cleared timed functions delay sensitive events 
flags specify event scheduled real timer queue virtual timer queue respectively 
successful invocation primitive returns pointer event structure created 
invocation primitive pointer returned may cancel event potential occurrence 
prototype function void void invoked function cancels event occur 
parameter pointer event structure returned event scheduled 
event occurred function returns null value 
nonzero return value indicates event successfully cancelled occurrence 
primitives mentioned relation language macros play supporting role 
rt macro defined define pr pr 
macro schedules delay sensitive thread bound event relative timing 
scheduled event timed real timer 
priority event host thread run specified parameter pr 
priority valid integer priority ariadne threads integer 
macro vt defined define pr pr 
macro schedules delay sensitive thread bound event relative timing 
scheduled event timed virtual timer hosted thread runs priority level pr 
macro rt defined define pr pr 
macro schedules delay sensitive thread bound event absolute timing 
scheduled event timed real timer hosted thread runs priority level pr 
macro vt defined define pr pr 
macro schedules delay sensitive thread bound event absolute timing 
event timed virtual timer hosted thread runs priority level pr 
event pending may identified cancelled potential parameter value parameter described previously 
macro rt defined define rt macro examines events real time queue cancels event parameter value macro vt cancel events defined define vt macro similar rt examines virtual time event queue event cancellation 
events parameter value event earliest scheduled time occurrence cancelled 
macros event cancellation return null value event cancelled queue 
cancellation successful non null pointer event record returned 
handling signals ariadne signals processed application level handlers ariadne global signal handlers may installed subset unix signals 
handlers enable threads wait specific signals 
ariadne internal handlers installed call removed call 
internal handler specific signal installed thread may wait signal invoking primitive 
thread may activate threads block calling invoking primitive 
call equivalent delivering signal process expense crossing kernel boundary 
prototypes signal related primitives ariadne void int sig void int sig void int sig void int sig parameter sig defines unix signal ariadne internal handler installed removed 
case sig parameter indicates unix signal raised 
case call sig parameter indicates unix signal thread wait unix signals currently supported 
signals may readily incorporated necessary minor modifications threads library 
current implementation support distinct signal types major modifications 
pre post execution actions ariadne thread may preempted time event thread higher priority 
situations useful application able run piece code immediately particular thread runs immediately voluntarily yields control preempted 
provide flexibility ariadne places pointers functions parameters thread record 
default setting pointers null 
thread created application set function pointers point specific code invoking primitives 
primitive specifies thread pre exec function set 
function run immediately thread runs time thread control 
pre exec function runs stack thread yields control thread pre execution function set 
prototype primitive struct tca void void void parameters specify thread pre exec function set pointer pre exec function parameter passed function 
invoked primitive sets pointer function run thread yields control preempted 
prototype primitive struct tca void void void parameter specifies thread post exec function set 
parameter defines function run thread yields control preempted 
parameter passed post exec function run time function entered 
contrast pre exec function post exec function runs stack thread function set 
functionality clam library support time sliced thread executions deadline scheduling 
example assume set threads currently sharing cpu round robin fashion thread obtaining maximum length slice cpu time 
addition assume number threads set may change dynamically threads particular receive thread real time execution deadline 
receive thread rescheduled execution time interval yields control preempted 
thread may consume entire allocated time slice context switching size set threads changes dynamically difficult guarantee particular thread run deadline 
way enabling thread meet deadline break static round robin scheduling cycle give control thread deadline constraint 
ariadne primitives described enable thread real time deadline schedule high priority event occurrence breaks round robin cycle thread schedules immediately yields control thread deadline 
clam uses idea scheduling receive threads interrupt driven scheduled run round robin fashion threads 
approach enables clam control message latencies guarantee reasonable level communication service polling protocols including situations large number threads 
experimental results results set experiments designed compare precision ariadne timers precision regular unix process timers 
comparison done different processor loads 
experiments conducted sparcstation mhz mb memory sunos solaris 
measured actual time interval defined timers call provided sunos solaris 
processor loading applications observed negligible time experiments 
stated processes scheduled priority level default priority assigned os regular non privileged users 
processes scheduled time sharing scheduling class stated 
experiment real time timer precision compare timing precision ran processes measured ariadne timing precision measured unix timing precision 
case timers repeatedly set expire fixed length time interval ms milliseconds time timer expiry requested 
granularity underlying system scans timer expiry actual elapsed measured time timer expiry differs requested time 
measure timing offset computed recorded samples actual elapsed time timer expiry 
ariadne unix sampled values displayed 
ariadne process measurement consists thread invokes sleep measures actual suspension time call 
process employing unix timers directly pause system calls suspend time interval 
process measured actual suspension time 
results shown bring important points 
measurements obtained unix timer exhibit large timing offset order ms samples 
timing error due clock tick granularity configured workstation testbed 
environment tick parameter set frequency ticks sec equivalently interval ms consecutive ticks 
finer tick granularity precise unix timers 
performance penalty unix kernel pay exchange finer clock tick granularity finer tick granularity higher corresponding process timer management overhead 
reason common configure tick rate reasonable level usually order milliseconds 
second important detail worth noting markedly high variability exhibited unix timer measurements relative low variance measurements ariadne timers 
believe due blocking process hosts unix timing test blocks kernel pause system call process hosts ariadne timing test simply continues run ready thread suspension interval 
results shown consistent mea application perspective time error system responds time different time application requested 
time sample ms sample ariadne real time timer precision detailed view ms time sample ms sample unix real time timer precision detailed view ms ariadne vs unix timers detailed view different timer values shown 
graphs corresponding different timer values overlaid single frame visualized compared scale 
graph represented vertically shifted function gamma equation represents original set measurements average measurements integer constant interval 
timing offset roughly ms observed set unix timer results shown observed experimental measurements resulted 
timing offset roughly magnitude ms timer settings experimented 
comparison ariadne timers precise consistently exhibiting offset order roughly microseconds actual time requested worst case average timing offset roughly experiment load effects study timers may affected processor loads repeated experiments described various load conditions 
generated controllable external load creating processes run continuously infinite loop 
processor load units shown axes figures represent number load generating processes system corresponding timer measurement 
processor load collected samples timer measurements actual detection timer expiry sample averages displayed axes shifted time sample sample ariadne real time timer precision ms ms ms ms ms shifted time sample sample unix real time timer precision ms ms ms ms ms ariadne vs unix timers graphs 
average displayed confidence interval student distribution 
case figures load generating processes ran priority process ran timing code 
results shown graphs suggest ariadne timers precise timer quality negatively effected increasing process loads competing processes run priority measuring process see 
contrast unix timer see appears remain stable presence increasing process loads 
observe unix timer measurements exhibit significant timing offset ms respect actual values timer set ms ms respectively 
explain significant differences ariadne timing behavior unix timing behavior follows 
ariadne load generating processes measuring process ran priority types processes cpu bound 
unix scheduler gives processes equal treatment allocates cpu round robin fashion 
higher number load generating processes longer period measuring process gets displaced cpu 
result average measured elapsed time increases linearly number load generating processes measured timing offset increases linearly length roundrobin scheduling cycle 
case unix timer measurements measuring process cpu bound see 
process goes blocked wait mode invokes pause system call blocking kernel signal arrives 
result unix scheduler gives higher priority load generating average time ms processor load ariadne real time timer precision vs processor load priority load ms ms average time ms processor load ariadne real time timer precision vs processor load low priority load ms ms ariadne timers precision vs load cpu bound processes 
higher priority measuring process scheduled preference load generating processes preempts processes timer expires 
able eliminate relatively large timing offsets 
priority measuring process ariadne timer test increased respect priority load generating processes achieve effect witnessed unix timer case 
words ariadne timer experience increasing amount independence load generators measuring process priority increases 
effect seen results obtained load generators running nice level units higher nice level process doing ariadne timer measurements 
effectively increases priority measuring process respect processes yields accurate actual elapsed times 
ariadne processes block useful blocking result poor performance load low 
see results similar experiment measuring process unix timer measurement forced cpu bound 
pause system call wait timer expiry process spin cycle receives timing signal 
case witness effect unix timer similar effects shown ariadne timer 
important difference unix timer exhibits timing offset roughly ms measurements involving low load conditions 
quality timer deteriorates precisely reasons discussion results average time ms processor load unix real time timer precision vs processor load block wait version ms ms average time ms processor load unix real time timer precision vs processor load busy wait version ms ms unix timers precision vs load shown 
load generators measuring process unix timer measurements cpu bound run priority scheduled round robin fashion 
elapsed times greater time quantum allocated measuring process incur timing offset corresponds sum quanta load generators system 
measuring process unix timer measurement scheduled real time scheduling class timing measurements cease susceptible variations load generated processes scheduled scheduling classes 
effect shown 
note timing offset roughly ms depends clock tick rate system configuration persists 
feature requires special system privileges 
processor load unix real time timer precision vs processor load real time scheduling priority ms ms unix timers precision vs load real time scheduling priority goal delivering efficient mechanism incorporating asynchronous signals threads system managed arrive efficient implementation precise timers ariadne user level threads library 
situations low processor loads proposed timing scheme precise 
high processor loads ariadne timing scheme degrades processes priority ariadne timing process compete cpu attention occurs ariadne process supporting user level threads runs mercy os scheduler 
increasing ariadne process priority may effect improvement timer accuracy viable solution operating systems ariadne processes run super user privileges 
application domain includes threads user level protocols heterogeneous distributed computing acquisition super user privileges widely distributed systems typically management different administration domains unrealistic 
reasonable expect solution increasing process priority distributed applications clam exploits hosts located different administration domains 
addition timer design experimentation described extended flexible user interface ariadne timer subsystem signal activated threads 
interface requirements specified clam system 
ariadne timer interface extensively support failure recovery clam 
signal activated threads play key role implementing asynchronous network clam embedded protocol modules 
interface clam process management module purpose monitoring process state multiple processes created host 
explore continuations improve protocol performance clam may shorten critical sections ariadne 
expect performance improvements area increase efficiency clam user space protocols making competitive respect kernel protocols 
gomez rego sunderam 
efficient multithreaded user space transport network computing design test trap protocol 
journal parallel distributed computing january 
gomez rego 
clam approach multithreaded communication shared memory multiprocessors design experiments 
ieee transactions parallel distributed systems january 
rego 
ariadne architecture portable threads system supporting thread migration 
software practice experience march 
gomez rego sunderam 
clam connectionless lightweight multiway communication support distributed computing 
lecture notes computer science communication architectural support network parallel computing springer verlag pages 
subramaniam shankar 
tcp instrumentation evaluating round trip time estimators 
internetworking research experience may 
varghese 
hashed hierarchical timing wheels data structures efficient implementation timer facility 
acm sigops operating systems review 
karn partridge 
improving round trip time estimates reliable transport protocols 
acm sigcomm august 
jacobson 
congestion avoidance control 
acm sigcomm pages 
jacobson floyd estrin sharma 
scalable timers soft state protocols 
ieee infocom 
zhang 
tcp timers don 
acm sigcomm august 
holbrook singhal cheriton 
log receiver reliable multicast distributed interactive simulation 
acm sigcomm october 
jain 
congestion control computer networks issues trends 
ieee network magazine pages may 
paul 
reliable multicast continuous data streams 
bell labs technical journal 
sanjoy paul 
rmtp reliable multicast transport protocol 
ieee infocom 
gomez sunderam rego 
scheduling communication multithreaded programs experimental results 
submitted publication 
kleiman shah 
programming threads 
sunsoft press prentice hall 
anderson bershad lazowska levy 
scheduler activations effective kernel support user level management parallelism 
acm transaction computer systems february 
rego 
migrant threads process farms parallel programming ariadne 
technical report csd tr purdue university 
appear concurrency practice experience 
wallach hsieh johnson kaashoek weihl 
optimistic active messages mechanism scheduling communication computation 
proceedings fifth symposium principles practices parallel programming pages july 
draves bershad rashid dean 
continuations implement thread management communication operating systems 
proceedings thirteenth symposium operating systems principles october 
carnegie mellon university technical report cmu cs 
dean 
continuations build user level threads library 
proceedings rd usenix symposium mach os pages april 
