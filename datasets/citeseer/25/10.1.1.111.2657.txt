finding common error patterns mining software revision histories benjamin livshits computer science department stanford university stanford usa livshits cs stanford edu great deal attention lately addressing software bugs errors operating system drivers security bugs 
lesser known errors individual applications apis violations applicationspecific coding rules responsible multitude errors 
propose tool analyzes source code check ins find highly correlated method calls common bug fixes order automatically discover application specific coding patterns 
potential patterns discovered mining passed dynamic analysis tool validation results dynamic analysis user 
combination revision history mining dynamic analysis techniques leveraged proves effective discovering new application specific patterns finding errors applied large applications man years development debugging effort 
analyzed eclipse jedit widely mature highly extensible applications consisting lines code combined 
mining revision histories discovered previously unknown highly application specific patterns 
dynamically confirmed valid patterns total pattern violations 
categories subject descriptors testing debugging tracing distribution maintenance enhancement version control database applications data mining general terms management measurement reliability keywords error patterns coding patterns software bugs data mining revision histories dynamic analysis line check ins 

great deal attention lately addressing application specific software bugs errors operating system drivers security errors errors embedded software domains avionics :10.1.1.114.3285
represent critical errors widely software tend get fixed relatively quickly 
variety static dynamic analysis tools developed address bugs 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
esec fse september lisbon portugal 
copyright acm 
thomas zimmermann computer science department saarland university saarbr cken germany cs uni sb de errors specific individual applications platforms 
violations application specific coding rules referred error patterns responsible multitude errors 
error patterns tend re introduced code multiple developers working project common source software defects 
pattern may responsible bugs project snapshot taken project lifetime detrimental effect error patterns quite serious hardly ignored long term software quality expected 
finding error patterns look particular static dynamic analysis tool difficult especially comes legacy code error patterns recoded comments code documented :10.1.1.134.9305
aware certain types behavior causes application crash publicized types bugs buffer overruns programmers difficulty formalizing expressing api invariants 
propose automatic way extract error patterns mining software revision histories 
looking incremental changes revisions opposed complete snapshots source allows better focus mining strategy obtain precise results 
approach uses revision history information infer error patterns 
experimentally evaluate patterns extracted checking dynamically 
performed experiments eclipse jedit large widely open source java applications 
eclipse jedit man years software development collaborative effort hundreds people different locations targets revision history mining 
mining cvs identified high probability patterns eclipse jedit apis previously unknown 
dynamically confirmed valid patterns pattern violations 
contributions contributions tool discovering usage patterns detecting violations large software systems 
steps involved mining running instrumented application accessible user eclipse plugin automates task collecting preprocessing revision history entries mining common patterns 
patterns user review runtime instrumentation generated patterns name comes combination dynamic analysis mining revision histories 
file revision added method calls foo java bar java system println baz java list iterator iter hasnext iter java method calls added different revisions 
user deems relevant 
results dynamic analysis user eclipse view 
propose data mining strategy detects common usage patterns large software systems analyzing software revision histories 
strategy classic apriori data mining algorithm augment number ways scalable reduce amount noise provide new effective ranking resulting patterns 
categorization patterns large modern object oriented systems 
experience large java projects leads believe similar pattern categories systems similar size complexity 
propose dynamic analysis approach validating usage patterns finding violations 
currently utilizes line approach allows match wider category patterns 
supplies default handlers analyzing common categories patterns 
detailed experimental study techniques applied finding errors large mature open source java applications years development 
identified patterns pattern violations dynamic analysis approach 
furthermore patterns experimentally confirmed valid 
organization rest organized follows 
section provides informal description pattern mining error detection tool 
section describes revision history mining approach 
section describes dynamic analysis approach 
section summarizes experimental results revision history mining dynamic checking patterns 
sections related conclude 

overview great deal research done area checking enforcing specific coding rules violation leads known types errors 
rules easy come time effort spent researchers looking worthwhile rules check best efforts error detection come people intimately familiar application domain :10.1.1.114.3285
result lesser known types bugs applications remain virtually unexplored error detection research 
better approach needed want attack unfamiliar applications error detection tools 
proposes set techniques automate step applicationspecific pattern discovery revision history mining 
motivation revision history mining approach mining revision histories hinges observation observation 
multiple software components api usually common errors specific api 
fact research done bug detection far thought focusing specific classes bugs pertaining particular apis studies operating system bugs provide synthesized lists api violations specific operating system drivers resulting rules call interrupt disabling function cli twice row :10.1.1.114.3285
order locate common errors mine frequent usage patterns revision histories justified observation 
observation 
method calls frequently added source code simultaneously represent pattern 
looking incremental changes revisions opposed full snapshots sources allows better focus mining strategy 
important notice pattern mined considering revision histories actual usage pattern 
lists sample method calls added revisions files foo java bar java baz java java 
files contain usage pattern says methods precisely matched 
mining revisions yields additional patterns println iterator definitely usage patterns 
furthermore take account fact reality patterns may inserted incompletely mistake fix previous error 
occurs file java inserted independently revisions 
observation follows gives rise effective ranking strategy 
observation 
small changes repository additions represent bug fixes 
observation supported part anecdotal evidence research nature software changes discussed section 
discussion rest section concrete categories patterns discovered mining approach 
matching method pairs represent method calls precisely matched paths program 
state machines patterns involve calling methods object captured finite automaton 
complex patterns patterns fall outside categories involve multiple related objects 
categories patterns listed order frequency high likelihood pattern experiments 
rest section describes error pattern categories detail 
motivation dynamic analysis technique mining patterns software repositories independently variety bug finding tools 
approach look pattern violations runtime opposed static analysis technique 
justified considerations outlined 
scalability 
original motivation able analyze eclipse largest java applications created 
code base eclipse comprised lines code classes 

cvs histories instrumented program extract mine patterns revisions revision revision db database patterns run instrumented program load dynamic results eclipse eclipse dynamic results view review eclipse pattern view confirmed patterns pattern violations architecture tool 
row represents revision history mining 
second row represents dynamic analysis 
patterns interested spread multiple methods need interprocedural approach analyze 
substantial size application analysis precise program flow sensitive static analysis expensive 
static call graph construction presents challenge applications dynamic class loading 
contrast dynamic analysis require call graph information 
validating discovered patterns 
benefit dynamic analysis able validate patterns discover cvs history mining real usage patterns observing times occur runtime 
patterns matched large number times violations represent patterns errors 
advantage validated patterns increase degree assurance quality mined results 
false positives 
runtime analysis suffer false positives pattern violations detected system happen significantly simplifies process error reporting 
believe dynamic analysis appropriate static analysis problem hand serious shortcoming dynamic analysis lack coverage 
fact dynamic experiments managed find runtime cases mined patterns 
concern workload selection may significantly influence patterns classified 
experiments eclipse jedit careful exercise common functions applications represent hot paths code contain errors may manifest runtime 
may missed error patterns occur exception paths hit runtime 
system overview conclude section summarizing various stages processing applied new application 
steps involved mining dynamic program testing accessible user custom eclipse views 
diagram representing architecture shown 
pre process revision history compute methods calls inserted store information database 

mine revision database usage error patterns 

mining results user eclipse plugin assessment 

generate instrumentation patterns deemed relevant selected user eclipse plugin 

run instrumented program dynamic data collected post processed dynamic checkers 

dynamic pattern violation statistics collected user eclipse 
steps performed loop dynamic information patterns obtained user may decide augment patterns re instrument application 

mining usage patterns section describe mining approach start providing terms discussion mining 
lay general algorithmic approach apriori algorithm commonly data mining applications market basket analysis :10.1.1.40.6757:10.1.1.40.2201
algorithm uses set transactions store item purchases input produces output frequent purchasing patterns items purchased strong association rules person bought item buy item 
classical apriori algorithm serious drawback 
algorithm runtime exponential number items 
items names individual methods program 
eclipse contain different methods calls inserted scalability real concern 
improve scalability approach reduce amount noise employ number filtering strategies described section reduce number viable patterns apriori consider 
furthermore apriori rank patterns returns 
filtering number patterns returned quite high apply ranking strategies described section patterns mine 
start discussion mining approach defining terminology algorithm description 
definition usage pattern defined set methods specification defines methods invoked 
static usage pattern source calls methods located source invoked manner consistent usage pattern program execution sequence calls methods accordance specification term specification intentionally open ended want allow variety pattern types defined 
revision histories record method calls inserted shall data mine method sets fact methods correlated define nature correlation 
exact pattern may obvious method names involved generally quite difficult automatically determine specification considering revision history data human input required 
definition source file revision transaction set methods calls inserted 
definition support count usage pattern number transactions contains methods example support count 
changes java contribute support count pattern distributed revisions 
definition association rule pattern consists non empty sets pattern exist possible association rules 
association rule interpreted follows programmer inserts calls methods 
insert calls methods obviously rules true 
probabilistic meaning 
definition confidence association rule defined conditional probability programmer inserts calls inserted calls confidence indicates strength rule 
interested patterns association rules 
rank patterns confidence values association rules 
basic mining algorithm classical approach computing patterns association rules apriori algorithm :10.1.1.40.6757:10.1.1.40.2201
algorithm takes minimum support count minimum confidence parameters 
call pattern frequent support minimum support count value 
call association rule strong confidence minimum confidence value 
apriori computes set frequent patterns set strong association rules phases 
algorithm iterates set transactions forms patterns method calls occur transaction 
pattern frequent subsets frequent patterns expanded iteration 
iteration continues fixed point reached final set frequent patterns produced 

algorithm computes association rules patterns pattern method set algorithm creates association rule form rules pattern support count different confidence values 
strong association rules added final set rules sections describe adapt classic apriori approach improve scalability provide ranking results 
pattern filtering running time apriori greatly influenced number patterns consider 
algorithm uses thresholds limit number patterns outputs employ filtering strategies specific problem revision history mining 
problem thresholds adequate keeping amount noise 
filtering strategies described greatly reduce running time mining algorithm significantly reduce amount noise produces 
considering subset method calls strategy deal complexity frequent pattern mining ignore method calls lead usage patterns lead obvious ones hasnext 
ignoring initial revisions 
treat initial revisions files additions 
contain usage patterns initial check ins account introduces incidental patterns noise patterns useful 
call sequence 
call sequence cn included part repository change take final call cn consideration 
due fact java code sequence accessor methods common typically call mutates program environment 
calls log rest denote set difference 
method number method number name additions name additions equals tostring add getname append size iterator get length frequently inserted method calls 
eclipse quite common intermediate portions call account contribute noise form associating intermediate getter calls 
patterns relevant purposes studied best mined snapshot repository history 
ignoring common calls 
reduce amount noise ignore common method calls ones listed practice ignore method calls added times 
methods tend get intermingled real usage patterns essentially causing noisy ones formed 
considering small patterns generally patterns consist large number methods created due noise 
way reduce complexity amount noise reduce scope mining small patterns 
employ combination strategies 
fine grained transactions 
mentioned section apriori relies transactions group related items 
generally choice coarse grained fine grained transactions 
coarse grained transactions consist method calls added single revision 
fine grained transactions additionally group calls access path 
coarse grained transaction corresponding revision baz java subdivided fine grained transactions objects list iter 
advantage fine grained transactions smaller mining efficient 
reason runtime heavily depends size number frequent patterns restricted size transactions 
fine grained transactions tend reduce noise processing restricted common prefix 
may patterns containing calls different prefixes pattern iterator hasnext 
mining method pairs 
reduce complexity mine revision repository method pairs patterns arbitrary size 
technique frequently applied software evolution analysis proved successful finding evolutionary coupling :10.1.1.112.1518
common method pairs express relatively simple usage patterns 
pattern ranking filtering applied apriori algorithm yields frequent patterns 
turn usage patterns practice 
ranking schemes presenting patterns discovered user review 
standard ranking approaches mining literature provides number standard techniques pattern ranking 
pattern support count confidence strength strength pattern defined 
definition strength pattern number strong association rules form frequent patterns 
experiments rank patterns lexicographically strength support count 
matching method pairs product confidence values conf conf strength continuous nature product gives fine grained ranking strength strength takes values pairs 
advantage products sums pairs confidence values high favored 
rest refer ranking follows classical data mining techniques regular ranking 
corrective ranking ranking schemes generally applied data mining problem come measure pattern importance specific mining revision histories 
observation basis metric describe 
check may add parts usage pattern repository 
generally problem classic apriori algorithm prefers patterns parts seen 
leverage incomplete patterns realize represent bug fixes 
study dynamic small repository changes large software systems performed sheds new light subject 
points repository changes small involving lines code 
line changes cause error 
furthermore line changes perfective changes add functionality corrective changes correct previous errors 
numbers imply strong correlation line changes bug corrections fixes 
observation develop corrective ranking extends ranking classical data mining 
identify line fixes mark method calls added 
addition measures regular ranking additionally rank number fixed methods calls lexicographic category 
discussed section patterns high corrective rank result dynamic violations patterns high regular rank 
locating added method calls order speed mining process pre process revision history extracted cvs store information general purpose database techniques described zimmermann 
database stores method calls inserted revision 
determine calls inserted revisions build syntax trees asts compute set calls respectively traversing asts 
set inserted calls 
williams hollingsworth approach build snapshots system 
point interactions build environment compilers makefiles extremely difficult handle result high computational costs 
analyze differences single revisions 
result preprocessing cheap platform drawback types resolved file investigated 
order avoid noise caused additionally identify methods count arguments 

checking patterns runtime section describe dynamic approach checking patterns discovered revision history mining 
pattern selection instrumentation aid task choosing relevant patterns user list mined patterns eclipse view 
list patterns may sorted filtered various ranking criteria described section better target user efforts 
human involvement stage optional user may decide dynamically check patterns discovered revision history mining 
user selects patterns interest list relevant methods patterns generated passed instrumenter 
jboss aop aspect oriented framework insert additional bookkeeping code method calls relevant patterns 
task pointcut selection simplified user graphical interface 
addition method called place code call occurs values actual parameters recorded 
post processing dynamic traces trace produced course dynamic run produce final statistics number times pattern followed number times violated 
decided favor line post processing patterns difficult impossible match fully online approach 
order facilitate task post processing practice equipped checkers look matching method pairs state machines 
users wish create checkers complex patterns java api exposed allows easy access runtime events 
dynamically obtained results matching pairs state machines exported back eclipse review 
user browse results ascertain patterns thought hold hold runtime 
examining dynamic output allows user correct initial pattern re instrument 
dynamic interpretation patterns may intuitively obvious coding pattern means kind dynamic behavior valid may open interpretation illustrated example 
consider matching method pair dynamic call sequence seq 
obviously dynamic execution consisting sequence calls follows pattern 
execution sequence seq probably represents pattern violation 
declaring seq violation may appear quite reasonable surface consider implementation method starts calling super 
dynamic call sequence results static call followed call comes static call second comes call super 
case seq may completely reasonable interpretation coding pattern 
example shows generally obvious mapping coding pattern dynamic sequence events 
result number dynamic pattern matches mismatches interpretation dependent 
errors runtime considered respect particular dynamic lines source java cvs method calls methods called developers cvs history application code files classes revisions inserted inserts checking eclipse may nd jedit jan th patterns 
violations applicationspecific patterns approach represent bugs claimed definite bugs carefully studying effect violation system 
implementation calculate number times pattern validated violated match unqualified names methods applied dynamic object 
fortunately complete information object involved available runtime making sort matching possible 
patterns involve object consider method arguments performing match goal dynamic matcher automatic possible type pattern possible automatically determine arguments match method pair 
complex patterns involve object require user defined checkers trace data saved contains information allows relevant call arguments matched 
dynamic vs static counts single pattern violation runtime involves objects 
obtain dynamic count counting object combinations participated particular pattern violation program execution 
dynamic counts highly dependent program runtime easily influenced example recompiling project eclipse multiple times 
dynamic error counts representative developer fix error dynamic violations caused error code 
provide better metric number errors application code compute static count 
done mapping method participating pattern static call site counting number unique call site combinations seen runtime 
static counts computed validated violated patterns 
pattern classification runtime information times pattern validated times violated classify patterns 
number validated instances pattern number violations 
constants classification strategy obtained empirically match intuition patterns categorized 
clearly potential classification approaches 
define error threshold min 
value patterns classified categories usage patterns patterns sufficiently high support validated relatively errors 
error patterns patterns significant number validated cases large number violations 
patterns patterns validated cases cause errors usage patterns 
summary information benchmark applications 

experimental results section discuss practical experience applying real software systems 
section describes experimental setup section evaluates results patterns mining dynamic analysis approaches 
experimental setup chosen perform experiments eclipse jedit large open source java applications fact eclipse largest java projects created 
summary information benchmarks 
application number lines code source files classes shown column 
addition standard metrics reflect size benchmarks show number revisions cvs repository column number inserted calls column number distinct methods called column 
projects significant number individual developers working evidenced numbers column 
date revision column 
mining setup performed pre processing eclipse jedit took days fetch revisions internet complete revision data gb size cvs protocol suited retrieving large volumes history data 
computing inserted methods analyzing asts storing information database takes day ghz dual processor machine gb memory 
pre processing step complete performed actual data mining 
optimizations described sections mining step complete case jedit mention eclipse 
optimizations apply biggest time improvement noise reduction achieved disregarding common method calls equals length optimizations applied mining orders magnitude faster usually minutes 
dynamic setup incremental cost checking additional patterns runtime generally low reviewing patterns eclipse inclusion dynamic experiments fairly liberal selection 
usually just look method names involved pattern briefly examine usage cases 
believe strategy realistic expect user spend hours pouring patterns 
obtain dynamic results ran application minutes pentium machine running linux typically resulted dynamic events generated 
discussion results patterns hit runtime 
furthermore patterns turned usage error patterns 
fact thirds dynamically encountered patterns patterns demonstrates power mining approach 
section discuss categories patterns briefly described section detail 
method pair confidence support dynamic static type method method conf conf ab conf ba count corrective ranking eclipse newrgn pairs done usage suspend resume error register error malloc free error usage error start error usage jedit pairs error start start error error init save pairs corrective ranking scheme regular ranking eclipse pairs usage usage usage jedit usage pairs parse usage addto usage usage undo redo pairs regular ranking scheme pairs totals matching method pairs discovered cvs history mining 
support count count confidence conf ab conf ba pairs ordered conf conf ab conf ba column usage error patterns abbreviated respectively 
empty cells represent patterns observed runtime 
matching method pairs simplest common kind pattern detected mining approach different methods class supposed match precisely execution 
known error patterns literature fopen fclose lock unlock fall category function calls require exact matching failing call second function pair calling functions twice row error 
lists matching pairs methods discovered mining technique 
methods pair listed order supposed executed executed brevity list names method full method names include package names easy obtain 
quick glance table reveals pairs follow specific naming strategy pre post add remove enter exit 
pairs discovered simply pattern matching method names 
looking method pairs prefixes suffixes obvious extension technique 
significant number pairs obvious names look including pairs difficult recognize matching method pairs require detailed study api confirm suspend resume summarizes dynamic results matching pairs 
table provides dynamic static counts validated violated patterns classification usage error patterns 
summarize observations data 
half method pair patterns selected filtered mined results confirmed patterns usage patterns error patterns 
potentially interesting matching pairs available consider lower support counts experiments considered patterns support 
characteristic pairs described 
locking pairs jedit excellent usage patterns violations 
pattern despite method names method triggered text added editor window second text removed 
clearly reason methods match 
method pair perfectly matched support sufficient declare usage pattern 
somewhat unusual kind matching methods thought caused noise data consists constructor call followed method call pair sort pattern indicates objects type consumed passing method 
violations pattern may lead resource memory leaks serious problem long running java programs 
corrective ranking significantly effective regular ranking schemes product confidence values 
top half table addresses patterns obtained corrective ranking contains matching method pairs second half deals patterns obtained regular ranking contains pairs 
looking ranking scheme reveals static validating instances vs regular ranking static error instances vs regular ranking 
pairs corrective ranking dynamically confirmed error usage patterns vs regular ranking 
confirms belief corrective ranking effective 
state machines cases order methods supposed called object easily captured finite state machine 
typically state machines followed precisely omitting repeating method call sign error 
fact state machines encountered surprising state machines simplest formalism describing object life cycle 
matching method pairs specific case state machines prominent cases involve methods focus section 
example state machine usage comes class org eclipse jdt internal formatter scribe eclipse responsible pretty printing java source code 
method supposed match earlier call preserve consistency 
typically method tries resolve exception caused current placed catch block executed optionally exception raised 
regular expression 
summarizes methods class supposed called object type scribe 
dynamic experiments pattern matched times dynamic violations correspond static violations excellent usage pattern 
interesting state machine mining jedit 
methods group editing operations text buffer try monitor null policy int depth try workspace null monitor workspace true depth workspace return policy monitor policy prepend main label subtask catch workspace return status cancel status depth workspace depth workspace null false policy monitor policy catch return monitor done example workspace operations locking discipline usage class eclipse 
undo redo actions applied 
insert 
remove dynamic study pattern reveals methods perfectly matched cases calls insert remove compound edit cases pairs insert remove operations 
compound edit established reason shows regular expression fully describe life cycle buffer object 
detailed study code reveals methods may compound edit 
subsequently adding methods pattern re instrumenting jedit led new pattern fully describes buffer object life cycle 
precisely order methods invoked common interfaces represented functions manipulate files sockets :10.1.1.114.3285
dependency call order common java occurs programs low level access os data structures 
instance methods declared org eclipse swt os eclipse expose low level memory context management routines java jni wrappers 
methods supposed called order described regular expression os os os os 
os lines mandatory pattern middle line optional 
unfortunately pattern exhibits runtime certain platforms unable confirm dynamically 
complex patterns complicated patterns concerned behavior object patterns finite state machine expressive quite widespread code base considered 
notice approaches restrictive model pattern matching function calls able find complex patterns :10.1.1.134.9305
due space restrictions describe complex pattern detail motivated code snippet 
lines relevant pattern highlighted bold 
object workspace runtime representation eclipse workspace large complex object specialized transaction scheme needs modified 
particular supposed start transaction requires workspace access call finish 
calls object obtained workspace indicate unlocked operations workspace releases workspace lock held default second re acquires obtained workspace calling workspace 
unlocking operations precisely matched error occurs case exception raised method called current workspace 
seen code pattern involves error handling may quite tricky get right 
come pattern observing pairs highly correlated code 
pattern easily described context free language allows nested matching brackets grammar shown 
strong usage patterns eclipse cases seen obeying grammar 
nesting workspace operations usually levels deep practice 

related space limitations prohibit reviewing vast body literature bug finding techniques 
engler point need extracting rules bug finding tools :10.1.1.134.9305
employ static analysis approach statistical techniques find instantiations pattern templates matching function calls 
mining technique priori limited particular set pattern templates comes patterns added repository revision 
projects focus application specific error patterns including deals ee patterns metal addresses bugs os code 
certain categories patterns gleaned literature tend deal high level architectural concerns low level coding issues 
rest section review literature pertinent revision history mining software model extraction 
revision history mining frequently techniques revision history mining change 
basic idea items grammar start symbol represent copies preceding non terminal indicates preceding non terminal optional 
changed related 
items granularity past change applied changes modules files classes functions 
research improves change applying data mining techniques revision histories 
data mining source code programming libraries detect reuse patterns revision histories single snapshots 
apply change data mining method calls 
fischer combine bug databases dynamic analysis combines mining revision histories dynamic analysis 
closely related williams hollingsworth 
combine program analysis revision history mining 
proposes error ranking improvements static return value checker information fixes obtained revision histories 
differs theirs important ways focus prioritizing improving existing error patterns checkers concentrate discovering new ones 
furthermore dynamic analysis face high false positive rates tool suffers 
williams hollingsworth turned mining function usage patterns revision histories 
contrast focus pairs patterns detect violations 
model extraction automatically inferring state models components software systems done dynamic analysis techniques 
strauss system uses machine learning techniques infer state machine representing proper sequence function calls interface 
trace call sequences correlate sequence patterns test failures 
whaley restricted model paradigm probable models object oriented interfaces easily automatically extracted 
alur generalize automatically produce small expressive finite state machines respect certain predicates object 
lam type system approach statically extract interfaces 
concerned high level system structure low level life cycle constraints 
daikon able validate correlations values runtime able validate patterns :10.1.1.137.4260
weimer exception control flow paths guide discovery temporal error patterns considerable success provide comparison existing specification mining 

cross projects areas revision history mining bug detection 
see potential extensions listed patterns discovered variety bug finding tools 
program static analysis expensive applying lightweight intraprocedural static approach patterns confirmed dynamic analysis discover interesting errors rarely executed exceptional paths 
extends set patterns discovered simple textual matching 
example known strong pattern pairs form patterns check 
approaches pattern discovery ample opportunities programmer assistant tools 
example developer types java code editor call suggested automatically inserted editor 

tool learning common usage patterns revision histories large software systems 
method learn simple complicated patterns scales millions lines code find pattern violations 
mining approach effective finding coding patterns thirds dynamically encountered patterns turned patterns 
tool combines revision history information dynamic analysis purpose finding software errors 
tool largely automates mining dynamic execution steps results steps accessible presenting discovered patterns results dynamic checking user custom eclipse views 
optimization filtering strategies developed allowed reduce mining time orders magnitude find high quality patterns millions lines code matter minutes 
ranking strategy favored patterns previous bug fixes proved effective finding error patterns 
contrast classical ranking schemes data mining locate usage patterns 
dynamic analysis proved invaluable establishing trust patterns finding violations 

wes weimer ted chris christian lindig anonymous reviewers providing useful feedback improve 
especially grateful michael martin assistance dynamic instrumentation minute proofreading 
author supported national science foundation 
second author supported part deutsche forschungsgemeinschaft ze 

agrawal srikant 
fast algorithms mining association rules 
proceedings th large data bases conference pages 
morgan kaufmann 
alur ern nam 
synthesis interface specifications java classes 
proceedings nd acm principles programming languages pages 
ammons bodik larus 
mining specifications 
proceedings th acm symposium principles programming languages pages 
ball cook levin rajamani 
slam static driver verifier technology transfer formal methods inside microsoft 
technical report msr tr microsoft 
whitehead 
identification software instabilities 
proceedings working conference reverse engineering pages nov 
bieman andrews yang 
understanding change proneness oo software visualization 
proceedings th international workshop program comprehension pages may 
blanchet cousot cousot feret min rival 
static analyzer large safety critical software 
proceedings acm conference programming language design implementation pages june 
brat 
precise scalable static program analysis nasa flight software 
proceedings ieee aerospace conference 
burke brock 
aspect oriented programming jboss 
www com pub aop jboss html 
carlson 
eclipse distilled 
addison wesley professional 
lindig zeller 
lightweight defect localization java 
proceedings th european conference object oriented programming july 

ee 
wiley 
engler chelf chou hallem :10.1.1.114.3285
checking system rules system specific programmer written compiler extensions 
proceedings fourth symposium operating systems design pages 
engler chen chou :10.1.1.134.9305
bugs deviant behavior general approach inferring errors systems code 
symposium operating systems principles pages 
ernst cockrell griswold notkin :10.1.1.137.4260
dynamically discovering program invariants support program evolution 
ieee transactions software engineering 
fischer gall 
analyzing relating bug report data feature tracking 
proceedings working conference reverse engineering pages nov 
gall hajek jazayeri 
detection logical coupling product release history 
proceedings international conference software maintenance pages nov 
gall jazayeri 
cvs release history data detecting logical couplings 
proceedings international workshop principles software evolution pages sept 
hallem chelf xie engler 
system language building system specific static analyses 
proceedings conference programming language design implementation pages 

huang yu hang 
tsai 
lee 
kuo 
securing web application code static analysis runtime protection 
proceedings th conference world wide web pages may 
lam rinard 
type system analysis automatic extraction enforcement design information 
proceedings th european conference object oriented programming pages july 
mannila toivonen verkamo 
efficient algorithms discovering association rules 
proceedings aaai workshop knowledge discovery databases pages july 
:10.1.1.14.2994
data mining library reuse patterns user selected applications 
proceedings th international conference automated software engineering pages oct 

data mining library reuse patterns generalized association rules 
proceedings international conference software engineering pages june 

jedit user guide 
www jedit org 
perry 
understanding rhetoric small changes 
proceedings international workshop mining software repositories pages may 
reimer schonberg srinivas srinivasan alpern johnson 
smart analysis error reduction 
proceedings international symposium software testing analysis pages july 
demeyer 
mining version control systems facs frequently applied changes 
proceedings international workshop mining software repositories pages may 
schach 
object oriented classical software engineering 
mcgraw hill science engineering math 
shankar talwar foster wagner 
detecting format string vulnerabilities type qualifiers 
proceedings usenix security conference pages 
tate clark lee 
bitter ejb 
manning publications 
wagner foster brewer aiken 
step automated detection buffer overrun vulnerabilities 
proceedings network distributed systems security symposium pages feb 
weimer necula 
mining temporal specifications error detection 
proceedings th international conference tools algorithms construction analysis systems pages apr 
whaley martin lam 
automatic extraction object oriented component interfaces 
proceedings international symposium software testing analysis pages july 
williams hollingsworth 
automatic mining source code repositories improve bug finding techniques 
ieee transactions software engineering june 
williams hollingsworth 
recovering system specific rules software repositories 
proceedings international workshop mining software repositories pages may 
ying murphy ng chu carroll 
predicting source code changes mining change history 
ieee transactions software engineering sept 
zimmermann diehl zeller 
history justifies system architecture 
proceedings international workshop principles software evolution pages sept 
zimmermann wei gerber 
preprocessing cvs data fine grained analysis 
proceedings international workshop mining software repositories pages may 
zimmermann wei gerber diehl zeller 
mining version histories guide software changes 
proceedings th international conference software engineering pages may 
