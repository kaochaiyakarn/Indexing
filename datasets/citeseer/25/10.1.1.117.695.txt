computing surveys vol pp december understanding types data abstraction polymorphism luca cardelli bell laboratories murray hill nj current address dec src lytton ave palo alto ca peter wegner dept computer science brown university providence ri objective understand notion type programming languages model typed polymorphic programming languages reflects research type theory examine relevance research design practical programming languages 
object oriented languages provide framework motivation exploring interaction concepts type data abstraction polymorphism extend notion type data abstraction type inheritance important form polymorphism 
develop calculus model type systems allows explore interactions simple setting unencumbered complexities production programming languages 
evolution languages untyped universes monomorphic polymorphic type systems reviewed 
mechanisms polymorphism overloading coercion subtyping parameterization examined 
unifying framework polymorphic type systems developed terms typed calculus augmented include binding types quantification binding values abstraction 
typed calculus augmented universal quantification model generic functions type parameters existential quantification packaging information hiding model data types bounded quantification model subtypes type inheritance 
way obtain simple precise characterization powerful type system includes data types parametric polymorphism multiple inheritance single consistent framework 
mechanisms type checking augmented calculus discussed 
augmented typed calculus programming language variety illustrative examples 
language fun fun functional abstraction keyword pleasant deal 
fun mathematically simple serve basis design implementation real programming languages type facilities powerful expressive existing programming languages 
particular provides basis design strongly typed object oriented languages 
contents 
untyped typed universes 
organizing untyped universes 
static strong typing 
kinds polymorphism 
evolution types programming languages 
type expression sublanguages 
preview fun 
calculus 
untyped calculus 
typed calculus 
basic types structured types recursion 
types sets values 
universal quantification 
universal quantification generic functions 
parametric types 
existential quantification 
existential quantification information hiding 
packages data types 
combining universal existential quantification 
quantification modules 
modules class values 
bounded quantification 
type inclusion subranges inheritance 
bounded universal quantification subtyping 
comparison subtyping mechanisms 
bounded existential quantification partial abstraction 
type checking type inference 
hierarchical classification type systems 
appendix type inference rules 
untyped typed universes 
organizing untyped universes asking question type 
ask types needed programming languages 
answer question look types arise domains computer science mathematics 
road untyped typed universes followed times different fields largely reasons 
consider example untyped universes bit strings computer memory expressions pure lisp expressions calculus sets set theory concrete universe bit strings computer memory 
untyped means type type memory word bit string fixed size 
universe untyped ultimately represented bit strings characters numbers pointers structured data programs looking piece raw memory generally way telling represented 
meaning piece memory critically determined external interpretation contents 
lisp expressions form untyped universe usually built top previous bitstring universe 
programs data distinguished ultimately expression kind 
type expressions somewhat structured atoms cons cells distinguished better properties bit strings 
calculus meant represent function 
numbers data structures bit strings represented appropriate functions 
type type functions values values values functions type 
set theory element set elements sets 
understand untyped universe remember mathematics full extremely rich complex structures represented set theory sets structural complexity reflects complexity structures represented 
example integers generally represented sets sets sets level nesting represents cardinality integer functions represented possibly infinite sets ordered pairs unique components 
soon start working untyped universe organize different ways different purposes 
types arise informally domain categorize objects usage behavior 
classification objects terms purposes eventually results defined type system 
types arise naturally starting untyped universes 
computer memory distinguish characters operations represented bit strings 
lisp expressions called lists form legal programs 
calculus functions chosen represent boolean values represent integers 
set theory sets chosen denote ordered pairs sets ordered pairs called functions 
untyped universes computational objects decompose naturally subsets uniform behavior 
sets objects uniform behavior may named referred types 
example integers exhibit uniform behavior having set applicable operations 
functions integers integers behave uniformly apply objects type produce values type 
valiant organization effort may start thinking untyped universes typed 
just illusion easy violate type distinctions just created 
computer memory bit wise boolean character machine operation 
lisp effect treating arbitrary expression program 
calculus effect conditional non boolean value 
set theory set union function successor function predecessor 
questions unfortunate consequence organizing untyped universes going way typed systems meaningful ask arbitrary representations higher level concepts interactions 

static strong typing type system major purpose avoid embarrassing questions representations forbid situations questions come 
mathematics programming types impose constraints help enforce correctness 
untyped universes naive set theory logically inconsistent typed versions proposed eliminate inconsistencies 
typed versions set theory just typed programming languages impose constraints object interaction prevent objects case sets inconsistent interaction objects 
type may viewed set clothes suit armor protects underlying untyped representation arbitrary unintended 
provides protective covering hides underlying representation constrains way objects may interact objects 
untyped system untyped objects naked underlying representation exposed see 
violating type system involves removing protective set clothing operating directly naked representation 
objects type representation respects expected properties data type 
representation chosen easy perform expected operations data objects 
example positional notation favored numbers allows arithmetic operations easily defined 
possible alternatives choosing data representations 
breaking type system allows data representation manipulated ways intended potentially disastrous results 
example integer pointer cause arbitrary modifications programs data 
prevent type violations generally impose static type structure programs 
types associated constants operators variables function symbols 
type inference system infer types expressions little type information explicitly 
languages pascal ada type variables function symbols defined redundant declarations compiler check consistency definition 
languages ml explicit declarations avoided possible system may infer type expressions local context establishing consistent usage 
programming languages type expression determined static program analysis said statically typed 
static typing useful property requirement variables expressions bound type compile time restrictive 
may replaced weaker requirement expressions guaranteed type consistent type may statically unknown generally done introducing run time type checking 
languages expressions type consistent called strongly typed languages 
language strongly typed compiler guarantee programs accepts execute type errors 
general strive strong typing adopt static typing possible 
note statically typed language strongly typed converse necessarily true 
static typing allows type inconsistencies discovered compile time guarantees executed programs type consistent 
facilitates early detection type errors allows greater execution time efficiency 
enforces programming discipline programmer programs structured easier read 
static typing may lead loss flexibility expressive power prematurely constraining behavior objects associated particular type 
traditional statically typed systems exclude programming techniques sound incompatible early binding program objects specific type 
example exclude generic procedures sorting capture structure algorithm uniformly applicable range types 

kinds polymorphism conventional typed languages pascal idea functions procedures operands unique type 
languages said monomorphic sense value variable interpreted type 
monomorphic programming languages may contrasted polymorphic languages values variables may type 
polymorphic functions functions operands actual parameters type 
polymorphic types types operations applicable values type 
polymorphism universal ad hoc varieties polymorphism 
parametric inclusion overloading coercion strachey strachey distinguished informally major kinds polymorphism 
parametric polymorphism obtained function works uniformly range types types normally exhibit common structure 
ad hoc polymorphism obtained function works appears different types may exhibit common structure may behave unrelated ways type 
classification polymorphism refines strachey introducing new form polymorphism called inclusion polymorphism model subtypes inheritance 
parametric inclusion polymorphism classified major subcategories universal polymorphism contrasted ad hoc polymorphism 
reflects strachey view polymorphism adds inclusion polymorphism model object oriented programming 
parametric polymorphism called uniformity type structure normally achieved type parameters uniformity achieved different ways general concept called universal polymorphism 
universally polymorphic functions normally infinite number types types having common structure ad hoc polymorphic function finite set different potentially unrelated types 
case universal polymorphism assert confidence values polymorphic functions types ad hoc polymorphism difficult maintain may take position ad hoc polymorphic function really small set monomorphic functions 
terms implementation universally polymorphic function execute code arguments admissible type ad hoc polymorphic function may execute different code type argument 
major kinds universal polymorphism major ways value types 
parametric polymorphism polymorphic function implicit explicit type parameter determines type argument application function 
inclusion polymorphism object viewed belonging different classes need disjoint may inclusion classes 
views universal polymorphism unrelated sufficiently distinct theory practice deserve different names 
functions exhibit parametric polymorphism called generic functions 
example length function lists arbitrary type integers called generic length function 
generic function arguments types generally doing kind independently argument type 
consider generic function single value functional types polymorphic 
ada generic functions special case concept generic 
major kinds ad hoc polymorphism 
overloading variable name denote different functions context decide function denoted particular instance name 
may imagine preprocessing program eliminate overloading giving different names different functions sense overloading just convenient syntactic abbreviation 
coercion semantic operation needed convert argument type expected function situation result type error 
coercions provided statically automatically inserting arguments functions compile time may determined dynamically run time tests arguments 
distinction overloading coercion blurs situations 
particularly true considering untyped languages interpreted languages 
static compiled languages may confusion forms ad hoc polymorphism illustrated example 
ad hoc polymorphism explained ways operator overloaded meanings combinations argument types 
operator overloaded meanings corresponding integer real addition 
argument type integer type real integer argument coerced type real 
operator defined real addition integer arguments coerced corresponding reals 
example may consider expression exhibiting overloading coercion changing meaning depending implementation decision 
definition polymorphism applicable languages clear notion type value 
particular clear distinction inherent type object apparent type syntactic representations languages permit overloading coercion 
issues discussed 
view type partially specifying behavior intended usage associated values monomorphic type systems constrain objects just behavior polymorphic type systems allow values associated behavior 
strictly monomorphic languages restrictive expressive power allow values syntactic symbols denote values exhibit different behavior different contexts 
languages pascal ada ways relaxing strict monomorphism polymorphism exception rule say monomorphic 
real apparent exceptions monomorphic typing rule conventional languages include overloading integer constants may type integer real 
operators applicable integer real arguments 
coercion integer value real expected vice versa 
subtyping elements subrange type belong types 
value sharing nil pascal constant shared pointer types 
examples may language instances radically different ways extending monomorphic type system 
see fit previous description different kinds polymorphism 
overloading purely syntactic way name different semantic objects compiler resolve ambiguity compile time proceed usual 
coercion allows user omit semantically necessary type conversions 
required type conversions determined system inserted program compiler generate required type conversion code 
coercions essentially form abbreviation may reduce program size improve program readability may cause subtle dangerous system errors 
need run time coercions usually detected compile time languages impure lisp plenty coercions detected performed run time 
subtyping instance inclusion polymorphism 
idea type subtype type useful subranges ordered types integers complex structures type representing subtype general type vehicles 
object subtype supertype context sense toyota vehicle operated operations applicable vehicles 
value sharing special case parametric polymorphism 
think symbol nil heavily overloaded strange kind open ended overloading nil valid element infinite collection types haven declared 
uses nil denote value common case overloading 
think different nil type nil representation identified 
fact object having types uniformly represented types characteristic parametric polymorphism 
relaxed forms typing relate polymorphism 
implicit choice names universal polymorphism considered true polymorphism ad hoc polymorphism kind apparent polymorphism polymorphic character disappears close range 
overloading true polymorphism value having types allow symbol types values denoted symbol distinct possibly incompatible types 
similarly coercions achieve true polymorphism operator may appear accept values types values converted representation operator operator really works type 
output type longer dependent input type case parametric polymorphism 
contrast overloading coercion subtyping example true polymorphism objects subtype uniformly manipulated belonging supertypes 
implementation representations chosen carefully coercions necessary object subtype place object supertype 
sense object types example simula member subclass may longer memory segment member superclass initial segment structure member superclass 
similarly operations careful interpret representations uniformly uniformly elements subtypes supertypes 
parametric polymorphism purest form polymorphism object function uniformly different type contexts changes coercions kind run time tests special encodings representations 
noted uniformity behavior requires data represented dealt uniformly pointers 
ways relaxing monomorphic typing discussed far powerful interesting consider connection operators functions procedures 
look additional examples 
symbol overloaded denote time integer sum real sum string concatenation 
symbol operations reflects approximate similarity algebraic structure violates requirements monomorphism 
ambiguity usually resolved type immediate operands overloaded operator may 
example overloaded denote integer real ambiguous resolvable larger context assignment typed variable 
set possibilities explode allow user defined overloaded operators 
algol known baroque coercion scheme 
problems solved similar overloading addition coercions run time effects 
dimensional array row coerced vector vector component coerced scalar 
conditions performing coercion may detected run time may arise programming errors planning 
algol experience suggests coercions generally explicit view taken language designs 
inclusion polymorphism common languages simula earliest example 
simula classes user defined types organized simple inclusion inheritance hierarchy class unique immediate superclass 
simula objects procedures polymorphic object subclass appear object superclasses required 
smalltalk goldberg untyped language popularized view polymorphism 
lisp flavors weinreb untyped extended style polymorphism multiple immediate superclasses amber typed cardelli extends higher order functions 
paradigmatic language parametric polymorphism ml milner entirely built style typing 
ml possible write polymorphic identity function works type argument length function maps list arbitrary element type integer length 
possible write generic sorting package works type ordering relation 
languages helped develop ideas include clu liskov russell demers hook hope burstall ponder fairbairn poly matthews 
mention generic procedures kind ada parametrized templates instantiated actual parameter values 
polymorphism ada generic procedures similar parametric polymorphism languages ml specialized particular kinds parameters 
parameters may type parameters procedure parameters value parameters 
generic procedures type parameters polymorphic sense formal type parameters take different actual types different instantiations 
generic type polymorphism ada syntactic generic instantiation performed compile time actual type values determinable manifest compile time 
semantics generic procedures macro expansion driven type arguments 
generic procedures considered abbreviations sets monomorphic procedures 
respect polymorphism advantage specialized optimal code generated different forms inputs 
hand true polymorphic systems code generated generic procedure 

evolution types programming languages early programming languages computation identified numerical computation values viewed having single arithmetic type 
early fortran convenient distinguish integers floating point numbers part differences hardware representation integer computation economical part integers iteration array computation logically different floating point numbers numerical computation 
fortran distinguished integer floating point variables letter names 
algol distinction explicit introducing redundant identifier declarations integer real boolean variables 
algol significant language explicit notion type associated requirements compile time type checking 
block structure requirements allowed type scope visibility variables checked compile time 
algol notion type extended richer classes values 
numerous typed languages developed period pl pascal algol simula noteworthy contributions evolution concept type 
pl attempts combine features fortran algol cobol lisp 
types include typed arrays records pointers 
numerous type loopholes requiring type values pointed pointer variables specified weaken effectiveness compile time type checking 
pascal provides cleaner extension types arrays records pointers user defined types 
pascal define type equivalence question type expressions denote type implementation dependent 
problems type granularity 
example pascal notion array type includes array bounds part type restrictive procedures operate uniformly arrays different dimensions defined 
pascal leaves loopholes strong type specification requiring full type procedures passed parameters specified allowing tag field variant records independently manipulated 
ambiguities pascal type system discussed welsh 
algol rigorous notion type pascal defined notion type equivalence structural equivalence 
notion type mode algol extended include procedures class values 
primitive modes include int real char bool string bits bytes format file mode constructors type constructors include array struct proc union ref respectively constructing array types record types procedure types union variant types pointer types 
algol carefully defined rules coercion dereferencing widening uniting transform values type required computation 
type checking algol decidable type checking algorithm complex questions type equivalence coercion checked user 
complexity felt flaw resulting reaction complex type systems 
languages ada simpler notion type equivalence severely restricted coercion 
simula object oriented language 
notion type includes classes instances may assigned values class valued variables may persist execution procedures contain 
procedures data declarations class constitute interface accessible users 
subclasses inherit declared entities interface superclasses may define additional operations data specialize behavior subclass 
instances class data abstractions having declarative interface state persists invocation operations lack information hiding mechanism data abstractions 
subsequent object oriented languages smalltalk loops combine class concept derived simula stronger notion information hiding 
modula wirth widespread language modularization major structuring principle ideas developed mesa 
typed interfaces specify types operations available module types interface opaque achieve data abstraction 
interface specified separately implementation separating specification implementation tasks 
scoping preserved modules abandoned global level favor flexible intermodule visibility rules achieved import export lists 
module interfaces similar class declarations mentioned scoping rules class instances module instances class values 
linking phase necessary interconnect module instances execution phase specified module interfaces external language 
ml introduced notion parametric polymorphism languages 
ml types contain type variables instantiated different types different contexts 
possible partially specify type information write programs partially specified types instances types 
way partially specifying types just omit type declarations general specific types fit situation automatically inferred 
historical framework provides basis deeper discussion relations types data abstraction polymorphism real programming languages 
consider untyped data abstractions packages ada indicate impact methodology requiring data abstractions type inheritance discuss interpretation inheritance subtype polymorphism examine relation subtype polymorphism smalltalk parametric polymorphism ml 
ada rich variety modules including subprograms support procedure oriented programming packages support data abstractions tasks support concurrent programming 
relatively weak notion type excluding procedures packages domain typed objects including task types relatively late design process afterthought 
choice name equivalence type equivalence weaker notion structural equivalence algol 
severe restriction implicit coercion weakens ability provide polymorphic operations applicable operands types 
packages ada interface specification named components may simple variables procedures exceptions types 
may hide local state private data type package body 
packages record instances having user interface named components 
ada packages differ records record components typed values package components may procedures exceptions types named entities 
packages types parameters components structures values pointer variables wegner 
packages ada second class objects class instances simula objects object oriented languages class objects 
differences behavior packages records ada avoided object oriented languages extending notion type procedures data abstractions 
context discussion useful define object oriented languages extensions procedure oriented languages support typed data abstractions inheritance 
say language object oriented iff satisfies requirements supports objects data abstractions interface named operations hidden local state objects associated object type types may inherit attributes supertypes requirements may summarized object oriented data abstractions object types type inheritance usefulness definition may illustrated considering impact requirements methodology 
data abstraction provides way organizing data associated operations differs considerably traditional methodology procedure oriented programming 
realization data abstraction methodology primary objectives ada methodology described length ada literature publications booch 
ada satisfies requirements object oriented programming interesting examine impact object types inheritance data abstraction methodology hendler 
requirement objects type allows objects class values managed data structures language computation 
requirement type inheritance allows relations types specified 
inheritance may viewed type composition mechanism allows properties types reused definition new type 
specification inherits may viewed abbreviation mechanism avoids redefining attributes type definition type inheritance shorthand imposes structure collection related types greatly reduce conceptual complexity system specification 
illustrated smalltalk object hierarchy goldberg 
smalltalk object hierarchy description smalltalk programming environment smalltalk 
conceptually similar lisp apply function describes lisp language interpreter lisp great deal complex 
describes collection related system object types inheritance hierarchy 
object types include numerical structured input output concurrent display objects 
object hierarchy carefully factors properties common numeric objects supertype number 
factors properties common different kinds structured objects supertype collection 
factors properties common numbers collections kinds objects supertype object 
doing collection object types comprise smalltalk environment described relatively simple structured hierarchy object types 
shorthand provided object hierarchy reusing superclasses attributes shared subclasses clearly incidental conceptual parsimony achieved imposing coherent structure collection object types 
smalltalk object hierarchy significant illustration power polymorphism 
may characterize polymorphic function function applicable values type inclusion polymorphism relation types allows operations applied object different types related inclusion 
objects seen collections polymorphic operations attributes 
view emphasizes sharing operations operands types primary feature polymorphism 
smalltalk object hierarchy realizes polymorphism sense factoring attributes common collection subtypes supertype 
attributes common numerical types factored supertype number 
attributes common structured types factored supertype collection 
attributes common types factored supertype object 
polymorphism intimately related notion inheritance say expressive power object oriented type systems due large measure polymorphism facilitate 
order complete discussion evolution types programming languages examine type mechanisms ml milner 
ml interactive functional programming language type specifications omitted user may reintroduced type inference user enters system responds int computing value expression inferring operands value type int 
user enters function declaration fun system responds int int defining function value inferring type int int 
ml supports type inference traditional types parametric polymorphic types length function lists 
fun rec length nil length tail entered ml infer length function lists arbitrary element type integers length list int 
user enters length applying length list integers system infers length specialized type int list int applies specialized function list integers 
say parametric function applicable lists arbitrary type really mean may specialized implicitly explicitly providing type parameter specialized function may applied specialized operands 
important distinction parametric function length lists arbitrary type specialized function lists type int 
functions length applicable lists arbitrary type uniform parametric representation allows specialized supplying type parameter 
distinction parametric function specialized versions blurred languages ml type parameters omitted user automatically reintroduced type inference mechanism 
supertypes object oriented languages may viewed parametric types parameter omitted user 
order understand similarity parametric types supertypes useful introduce notation supertype parameters explicitly supplied specializing supertype subtype 
shall see fun explicit type parameters parametric types supertypes order provide uniform model parametric subtype polymorphism 
results uniform treatment type inference parameters omitted parametric types supertypes 

type expression sublanguages set types programming language richer set definable types infinite useful define set types type expression sublanguage 
set type expressions current strongly typed programming languages generally simple sublanguage complete language altogether trivial 
type expression sublanguages generally include basic types integer boolean composite types arrays records procedures constructed basic types 
type int bool 
array type type type 
type expression sublanguage sufficiently rich support types values wish compute sufficiently tractable permit decidable efficient type checking 
purposes examine tradeoffs richness tractability type expression sublanguages strongly typed languages 
type expression sublanguage generally specified context free grammar 
interested syntax type expression sublanguage semantics 
interested types denote relations type expressions 
basic relation type expressions type equivalence 
interested similarity relations types weaker equivalence inclusion related subtypes 
similarity relations type expressions permit type expression denote type compatible types referred polymorphism 
usefulness type system lies set types represented kinds relationships types expressed 
ability express relations types involves ability perform computations types determine satisfy desired relationship 
computations principle powerful computations values 
concerned simple easily computable relationships express uniform behavior shared collections types 
reader interested discussion type expression languages type checking algorithms languages pascal referred chapter aho considers type checking overloading coercion parametric polymorphism 
fun adds data types set basic types adds subtype inheritance forms polymorphism supported 

preview fun fun calculus language enriches order typed calculus second order features designed model polymorphism object oriented languages 
section reviews untyped typed calculus develops order features fun type expression sublanguage 
fun basic types bool int real string constructed types record variant function recursive types 
set order types base introducing parametric types data types type inheritance means second order language features subsequent sections 
section briefly reviews theoretical models types related features fun especially models view types sets values 
viewing types sets allows define parametric polymorphism terms set intersection associated types inheritance polymorphism terms subsets associated types 
data abstraction may defined terms set operations case unions associated types 
sections respectively augment order calculus universal quantification realizing parameterized types existential quantification realizing data abstraction bounded quantification realizing type inheritance 
syntactic extensions type expression sublanguage determined features may summarized follows type 
type universal quantification type existential quantification type 
type type 
type bounded quantification universal quantification enriches order calculus parameterized types may specialized substituting actual type parameters universally quantified parameters 
universally quantified types class types may actual parameters substitution 
existential quantification enriches order features allowing data types hidden representation 
interaction universal existential quantification illustrated section case stacks universally quantified element type existentially quantified hidden data representation 
fun supports information hiding existential quantification construct facilitates hiding local variables module body 
hiding means referred order hiding involves hiding local identifiers associated values hiding means existential quantifiers referred second order hiding involves hiding type representations 
relation forms hiding illustrated section contrasting hiding package bodies hiding private parts ada packages 
bounded quantification enriches order calculus providing explicit subtype parameters 
inheritance subtypes supertypes modeled explicit parametric specialization supertypes subtype operations executed 
object oriented languages type potentially supertype subsequently defined subtypes modelled bounded quantified type 
bounded quantification provides explanatory mechanism object oriented polymorphism cumbersome explicitly useful illuminating relation parametric inherited polymorphism 
section briefly reviews type checking type inheritance fun 
supplemented appendix listing type inference rules 
section provides hierarchical classification object oriented type systems 
fun represents topmost general type system classification 
relation fun general systems associated ml galileo amber languages interesting type systems reviewed 
hoped readers fun reading fun authors writing 

calculus 
untyped calculus evolution untyped typed universes may illustrated calculus initially developed untyped notation capture essence functional application operators operands 
expressions calculus syntax fun traditional bring correspondence programming language notations variable expression fun functional abstraction operator applied operand identity function successor function may specified calculus follows syntactic sugar explained 
keyword value introduce new name bound value function value id fun identity function value succ fun successor function integers identity function may applied arbitrary expression yields expression 
order define addition integers pure calculus pick representation integers define addition operation effect expressions representing integers produce expression represents successor function applied expressions represent integers suggests notion typing 
infix notation abbreviation functional notation 
symbols turn viewed abbreviations pure calculus expression number addition 
correctness integer addition requires assumptions happens expression representing addition applied expressions represent integers 
want notation error checking properties desirable define effect addition arguments integers error 
accomplished typed programming languages type checking eliminates time possibility operations objects incorrect type 
type checking calculus just conventional programming languages effect large classes expressions legal untyped calculus illegal 
class illegally typed expressions depends type system adopts undesirable may depend particular typechecking algorithm 
idea expressions operating functions produce functions illustrated function twice form value twice fun fun twice function application twice successor function yields expression computes successor successor 
twice succ fun succ succ twice fun fun fun fun discussion illustrates types arise specialize untyped notation calculus perform particular kinds computation integer arithmetic 
section introduce explicit types calculus 
resulting notation similar functional notation traditional typed programming languages 

typed calculus typed calculus calculus variable explicitly typed introduced bound variable 
successor function typed calculus form value succ fun int function twice integers integers parameter type int int type functions integers integers may written follows value twice fun int int fun int notation approximates functional specification typed programming languages omits specification result type 
may denote result type returns keyword follows value succ fun int returns int type result determined form function body 
shall omit result type specifications interests brevity 
type inference mechanisms allow information recovered compilation discussed section 
type declarations introduced keyword type 
type names upper case letters value function names lower case letters 
type int int type int int type declarations introduce names abbreviations type expressions create new types sense 
expressed saying structural equivalence types name equivalence types equivalent structure regardless names abbreviations 
fact value type indicated 
succ need introduce variables type declarations form var type variable may determined form assigned value 
example fact type determined fact type int int declared equivalent 
value want indicate type variable part initialization notation value var value 
value value succ int int fun int local variables declared construct introduces new initialized variable local scope expression 
value construct value expression 
yields want specify types write int construct defined terms basic fun expressions fun 
basic types structured types recursion typed calculus usually augmented various kinds basic structured types 
basic types shall unit trivial type element bool operation int arithmetic comparison operations real arithmetic comparison operations string string concatenation infix structured types built basic types means type constructors 
type constructors language include function spaces cartesian products record types called labeled cartesian products variant types called labeled disjoint sums 
pair element cartesian product type value true int bool operations pairs selectors second components fst yields snd yields true record unordered set labeled values 
type may specified indicating type associated labels 
record type denoted sequence labeled types separated commas enclosed curly braces type int bool string record type may created initializing record labels value required type 
written sequence labeled values separated commas enclosed curly braces value true abcd labels unique record record type 
operation records field selection denoted usual dot notation yields true functions class values records may general function components 
type int int real real value succ sin record type defined terms existing record types operator concatenates record types type bool bool intended abbreviation writing fields explicitly 
valid record types duplicated labels involved 
data structure local private collection functions declarations 
records function components particularly convenient way achieving private counter variable shared increment total function value counter count ref increment fun int count count total fun count counter increment counter total yields example involves side effects main private variables update privately 
primitive ref returns updateable object assignments restricted 
common form information hiding allows updating local state static scoping restrict visibility 
variant type formed unordered set labeled types enclosed brackets type int bool string element type integer labeled boolean labeled string labeled value value true value abcd operation variants case selection 
case statement variant type form case variant variable type int action case variable type bool action case variable type string action case case new variable introduced bound respective contents variant 
variable respective action 
function element type returns string value fun case integer boolean string error contents variant object bound identifiers depending case 
untyped calculus possible express recursion operators define recursive functions 
computations expressible typed calculus terminate roughly type function strictly complex type result number applications function obtain basic type non terminating primitives 
recursive definitions introduced new primitive concept 
factorial function expressed rec value fact fun int fact simplicity assume values recursively defined functions 
introduce recursive type definitions 
allows example define type integer lists record variant types rec type intlist nil unit cons head int tail intlist integer list nil represented nil cons integer integer list represented cons head tail nil 

types sets values adequate notion type account polymorphism abstraction parametrization 
previous sections started describe particular type system giving informal typing rules linguistic constructs 
rules characterize type system intuitive level easily formalized type inference system 
rules sound stand discovered justified studying particular semantics types developed hindley milner damas macqueen mitchell 
need discuss semantic theory types detail may useful explain basic intuitions 
intuitions turn useful understanding typing rules particularly regarding concept subtypes introduced 
universe values containing simple values integers data structures pairs records variants functions 
complete partial order built scott techniques scott approximation think just large set possible computable values 
type set elements subsets legal types obey technical properties 
subsets obeying properties called ideals 
types programming languages ideals sense don worry subsets ideals 
type ideal set values 
set types ideals ordered set inclusion forms lattice 
top lattice type top set values 
bottom lattice essentially empty set singleton set containing element 
phrase having type interpreted membership appropriate set 
ideals may overlap value types 
set types programming language generally small subset set ideals example subset integers determines ideal type set pairs element equal 
generality welcome allows accommodate different type systems framework 
decide exactly ideals considered interesting context particular language 
particular type system collection ideals usually identified giving language type expressions mapping type expressions ideals 
ideals collection elevated rank types particular language 
example choose integers integer pairs integer integer functions type system 
different languages different type systems type systems built top domain provided rich start techniques 
monomorphic type system value belongs type element definition ideal belongs types 
types sets value may belong types 
polymorphic type system large interesting collections values belong types 
grey area monomorphic polymorphic systems definitions left imprecise important point basic model ideals explain degrees polymorphism 
types sets subtypes simply correspond subsets 
semantic assertion subtype corresponds mathematical condition type lattice 
gives simple interpretation subrange types inheritance shall see sections 
take type system consisting single set type free system values type 
express typed untyped languages semantic domain compare 
type lattice contains points named type language 
fact includes uncountable number points includes subset integers 
objective language talking types allow programmer name types correspond interesting kinds behavior 
order language contains type constructors including function type constructors type constructing function type domain range types 
constructors allow unbound number interesting types constructed finite set primitive types 
may useful types type lattice denoted constructors 
remaining sections introduce powerful type constructors allow talk types corresponding infinite unions intersections type lattice 
particular universal quantification allow name types lattice points infinite intersections types existential quantification allow name types corresponding infinite unions 
reason introducing universal existential quantification importance resulting types increasing expressive power typed programming languages 
fortunate concepts mathematically simple correspond known mathematical constructions 
ideal model model types studied 
respect denotational models advantage explaining simple polymorphic types intuitive way sets values allowing natural treatment inheritance 
satisfactory treatment type parametrization indirect types values treatment type operators involves getting model considering functions ideals 
view intuitive appeal chosen ideal model underlying view types discussion carried improved chose refer models 
idea types parameters fully developed second order calculus bruce 
known denotational models second order calculus retract models scott 
types sets objects special functions called retracts interpreted identifying sets objects objects 
property types objects retract models naturally explain explicit type parameters ideal models naturally explain implicit type parameters 

universal quantification 
universal quantification generic functions typed calculus sufficient express monomorphic functions 
adequately model polymorphic functions 
example requires previously defined function twice unnecessarily restricted functions integers integers liked define polymorphically functions arbitrary type 
identity function similarly defined specific types integers fun int capture fact form depend specific type 
express idea functional form variety types explicitly bind variables values specific type time binding may premature 
fact functional form types may expressed universal quantification 
particular identity function may expressed follows value id fun definition id type variable provides type abstraction id identity types 
order apply identity function argument specific type supply type parameter argument type id int convention type parameters enclosed square brackets typed arguments enclosed parentheses 
refer functions id require type parameter applied functions specific type generic functions 
id generic identity function 
note binding operator just fun requires matching actual parameter supplied function application 
serves bind type fun serves bind variable possibly generic type 
types applied implication types manipulated values types values distinct type abstractions application serve type checking purposes runtime implications 
fact may decide omit type information square brackets value id fun free type variable id type checking algorithm task recognizing free type variable original int information 
part polymorphic type checker ml language 
fact ml goes allows programmer omit remaining type information value id fun id ml type inference mechanism allows system infer types monomorphic polymorphic expressions type specifications omitted programmer reintroduced system 
advantage programmer shorthand untyped calculus system translate untyped input fully typed expressions 
known fully automatic type inference algorithms powerful type systems going consider 
order clarify happening depend current state type checking technology shall write type information type checking task trivial 
going back fully explicit language extend notation type polymorphic function explicitly talked 
denote type generic function arbitrary type type id example function parameter universally quantified type 
function inst takes function type returns instances specialized integers booleans value inst fun int bool value fst inst id int int value snd inst id bool bool general function parameters universally quantified types useful different types body single function list length function passed parameter lists different types 
order show freedom defining polymorphic functions write versions twice differ way type parameters passed 
version twice function parameter universal type 
specification fun body function specifies type function parameter generic admit functions type type 
applied instances body twice formal type parameter require actual type supplied applying twice 
full specification twice requires binding type parameter universally quantified type binding value twice fun fun twice bound variables actual parameters supplied function application 
requires actual parameter type fun requires function type fun requires argument type substituted application twice type int function id argument specified follows twice int id note third argument type int argument second argument id universally quantified type 
note twice int succ legal succ type function twice differs twice type argument universally quantified 
need apply body twice value twice fun fun twice int yields fun int int fun int possible compute twice succ twice int succ yields fun int succ succ twice int succ yields twice receives type parameter int serves specialize function int int receives function succ type receives specific element type int function succ applied twice 
extra type application required twice id specialized int twice int id int note abstraction function abstraction universal quantification generic type abstraction binding operators require formal parameters replaced actual parameters 
separation types values achieved having different binding operations types values different parenthesis syntax actual parameters supplied 
extension calculus support different kinds binding mechanism types variables practically useful modeling parametric polymorphism mathematically interesting generalizing calculus model qualitatively different kinds abstraction mathematical model 
sections introduce third kind abstraction associated binding mechanism introduce notion parametric types 
fun types values rigorously distinguished values objects types sets need distinct binding mechanisms fun 
kinds bindings unified type models types values achieving economy concepts unification fit underlying semantics 
models possible unify parametric type binding mechanism described section fun 

parametric types type definitions similar structure example type bool bool type int int may want factor common structure single parametric definition parametric type defining types type pair type pair bool type pair int type definition simply introduces new name type expression equivalent type expression context 
type definition introduce new type 
type int int definition 
parametric type definition introduces new type operator 
pair type operator mapping type type pair int type int int follows type pair int 
type operators types operate types 
particular confuse notations type type type operator applied type gives type functions type identity function applied types 
type operators recursive definitions definition generic lists 
note think list item abbreviation macro expanded obtain real definition cause infinite expansion 
think list new type operator recursively defined maps type lists type rec type list item nil unit cons head item tail list item generic empty list defined specialized value nil item 
nil value nil int value nil bool nil type list item item matches definition list item 
types generic nil specializations nil item 
list item list int list bool similarly define generic cons function list operations value cons item 
item list item list item item 
fun item list item cons head tail note cons build homogeneous lists way arguments result related item type 
mention problems deciding general parametric recursive type definitions represent type 
solomon describes problem reasonable solution involves restricting form parametric type definitions 

existential quantification type specifications variables universally quantified type form type expression id analogy universal quantification try give meaning existentially quantified types 
general type expression property example type type int case int int second 
see constant satisfy different existential types 
warning didactic purposes assign existential types ordinary values 
conceptually correct sections disallowed type checking purposes shall require particular constructs obtain objects existential type 
value type value exists type value type 
type denotes set values shall call top biggest type type top type value whatsoever set ordered pairs may denoted existential type 
type pair whatsoever type pair type take type type take type type type object integer valued operation applied may denoted existential type 
int pair succ type take int 
similarly pair length type take list int 
set types includes simple types universal types type top existentially quantified types properties may appear counterintuitive 
type simply type pairs equal type expect 
fact true type 
know true type top type top true type pairs whatsoever similarly function whatsoever type take top 
int forces relation type object type associated integer valued function 
example length type consider having type top show length type top int know length list maps integer lists integers assume arbitrary object type top mapped integer 
existential types turn useful 
example unknown object type absolutely way manipulating passing information 
unknown object type assume pair apply fst snd stuck information existentially typed objects useful sufficiently structured 
example int provides sufficient structure allow compute 
execute snd fst obtain integer 
useful existential types hide structure objects represent show structure allow manipulations objects operations objects provide 
existential types example forming apparently heterogeneous lists succ length list int extract element list manipulate may know particular element exact type course form totally heterogeneous lists type list quite unusable 

existential quantification information hiding real usefulness existential types apparent realize int simple example type packaged set operations 
variable type hides representation 
representation int list int previous examples 
int set operators type constant type operator type int 
operators unnamed named version record types cartesian products const op int op const know representation really know assumptions users unable take advantage particular implementation announced earlier bit liberal applying various operators directly objects existential types op 
disallowed purpose making formalism easier type check 
shall explicit language constructs creating manipulating objects existential types just type abstractions type applications exp creating objects universal types 
ordinary object succ may converted object having type int packaging structure hidden 
operation pack encapsulates object succ user knows object type int exists knowing actual object 
natural think resulting object having existential type int 
value pack int int succ int packaged objects called packages 
value succ referred content package 
type int interface determines structure specification contents corresponds specification part data abstraction 
binding int type representation binds data type particular representation int corresponds hidden data type associated data abstraction 
general form operation pack follows pack interface contents operation pack mechanism creating objects existential type 
variable existential type declared declaration int take values created pack operation 
package opened open snd fst opening package introduces name contents package scope 
structure specified labeled components components opened package may referred name value pack int arg op int succ open op arg may need refer unknown type hidden package 
example suppose wanted apply second component value type supplied external argument 
case unknown type explicitly referred form open fun snd 
type name associated hidden representation type scope 
type expression contain prevent escaping scope 
function open bind names representation types help type checker verifying type constraints 
situations may want abbreviate open going avoid abbreviations prevent confusion perfectly admissible 
pack open run time effect data 
smart type checker omit constructs revert notation previous section 

packages data types order illustrate applicability notation real programming languages indicate records function components may model ada packages existential quantification may model data abstraction ada 
consider type point creating geometric points globally defined type point pairs real numbers selecting coordinates points 
type point real real type point real real point coord point real coord point real values type point created initializing function names type point functions required type 
value point point fun real real coord fun point fst coord fun point snd ada package point coord coord functions may specified follows package point function real real return point function coord point return real function coord point return real point package specification type specification part value specification 
order complete value specification ada supply package body form package body point function real real return point implementation function coord point return real implementation coord function coord point return real implementation coord point package body supplies function bodies function types package specification 
contrast notation allows different function bodies associated different values type ada allow packages types directly defines function body function type package body 
packages allow definition groups related functions share local hidden data structure 
example package local data structure point form package body point point shared global variable coord coord procedure real function coord return real function coord return real hidden local variables realized notation construct value point ref fun real real coord fun fst coord fun snd ada concept package type notion package template properties type 
package templates introduced keyword generic 
generic package point function real real return point function coord point return real function coord point return real point values point point generic package template point introduced follows package point new point package point new point package values associated generic package template package body 
specification ada package statically associated body prior execution typed values record types dynamically associated function bodies value creation command executed 
components package values created generic package accessed record notation 
type point point packages record values allowing components accessed notation selection record components 
packages class values ada 
passed parameters procedures components arrays record data structures assigned values package variables 
generic package templates types types allowing instances created 
effect ada similar subtly different language mechanisms handling record structures handling data records associated record types handling packages associated generic templates 
contrasting mechanisms ada record types generic packages single mechanism notation gain appreciation insight advantages uniformly extending types records function components 
ada packages simply encapsulate set operations publicly defined datatype need fancy type operators 
modelled notation simple typed calculus existential quantification 
hide type representation private data types existential quantification needed 
construct previous example realize information hiding 
call order information hiding achieved restricting scoping value level 
contrasted second order information hiding realized existential quantifiers restrict scoping type level 
ada point package point private type point may defined follows package point type point private function real real return point function coord point return real function coord point return real private hidden local definition type point point private type point may modelled existential quantification type point point 
real real point coord point real coord point real convenient view type specifications existentially quantified type parametric function hidden type parameter 
example may define point wrt point follows type point wrt point real real point coord point real coord point real notation wrt point wrt point read respect underlines fact type specification relative type parameter 
value point existential type point may created pack operation 
value point point pack point real real point wrt point point pack operation hides representation real real point existentially parametrized type point wrt point specification part provides hidden body previously defined value point implements operations data representation 
note point wrt point represents parameterized type expression supplied actual type parameter real determines type case record type components 
relation kind parameterization kinds parameterization introduced far illustrated table 
function abstraction fun type value expr 
parameter value result substituting actual parameter formal parameter determines value 

quantification value expr 
parameter type result substituting actual type formal parameter determines value 

type abstraction type expr 
parameter type result substituting actual type formal parameter type 
actual type parameters restricted types actual value parameters may arbitrarily complex values 
class types enriched include universally existentially quantified types enriches arguments may substituted formal type parameters 
existential quantification model private types ada 
general data abstraction facility ada shown examples 

combining universal existential quantification section give example demonstrates interaction universal existential quantification 
universal quantification yields generic types existential quantification yields data types 
notions combined obtain parametric data abstractions 
stacks ideal example illustrate interaction generic types data abstraction 
simplest form stack specific element type integer specific data structure implementation list array 
generic stacks parameterize element type abstraction data representation may accomplished creating package existential data type 
stack parameterized element type hidden data representation realized combining universal quantification realize parameterization existential quantification realize data abstraction 
operations lists arrays nil list cons 
list list hd list tl list list null list bool array int array index 
array int update 
array int unit start concrete type integer elements list data representation 
concrete type implemented tuple operations quantification 
type list int push int list int list int pop list int list int top list int int instance stack type components initialized specific function values may defined follows value nil int push fun int list int cons int pop fun list int tl int top fun list int hd int stack integers implemented pairs consisting array top stack index array concrete stack may implemented tuple quantification 
type array int int push int array int int array int int pop array int int array int int top array int int int instance instance tuple type operation fields initialized operations array stack representation 
value array int push fun int array int int update int fst snd fst snd pop fun array int int fst snd top fun array int int index int fst snd concrete stacks may generalized making element type generic hiding stack data representation 
example illustrates generic element type may realized universal quantification 
define type universally quantified type type item 
list item push item list item list item pop list item list item top list item item instance universal type may created universal quantification record instance fields initialized operations parameterized generic universally quantified parameter 
value item nil item push fun item list item cons item pop fun list item tl item top fun list item hd item name implies concrete list implementation stack data structure 
alternative type concrete array implementation stack data structure may similarly defined type value 
data representation stacks irrelevant user hide stack interface independent hidden stack data representation 
single type implemented generic list stack generic array stack 
users know implementation 
need existential types 
item type exist implementation stack provides stack operations 
results type defined terms universally quantified parameter item existentially quantified parameter stack follows type item 
stack 
item stack parameter type item stack may turn defined tuple doubly parameterized operations type item stack stack push item stack stack pop stack stack top stack item note definition distinguish le parameters item stack 
definition parameter item universally quantified indicating represents generic type parameter stack existentially quantified indicating represents hidden data type 
packages packages type value item pack stack list item item stack item value item pack stack array item item item stack item type differ merely form hidden data representation 
functions knowledge implementation value fun open int top push implementation parameter definition type stack largely unrelated item intention implementation stack stacks collections items weak dependency stack item order quantifiers 
possible build objects type stacks items obey properties pop push limitation corrected powerful type systems macqueen burstall possible type operators list just types list int directly express representations stack item expressive type systems possible fake stack packages obey stack properties 

quantification modules ready major example geometric points 
introduce type operations new point real numbers coord coord extract coordinates point type point pointrep 
real real pointrep coord pointrep real coord pointrep real purpose define values type hide representation pointrep implementation operations coord coord respect representation 
order accomplish define type operations parametric type point representation pointrep parameter 
type name emphasizes operations defined respect particular representation contrast datatype point representation independent 
type pointrep real real pointrep coord pointrep real coord pointrep real existential type point may defined terms existential abstraction respect pointrep type point pointrep 
pointrep relationship representation dependent point operations associated datatype clearer illustrate abstraction process specific point representations 
define cartesian point package point representation pairs reals operations coord coord follows value fun real real coord fun real real fst coord fun real real snd package point representation real real implementations point operations content specified follows value pack pointrep real real pointrep similarly polar point package point representation real real cartesian point package content different polar coordinate implementation operations value pack pointrep real real pointrep fun real real 
coord fun real real 
coord fun real real 
examples illustrate package realizes data abstraction hiding data representation implementation operations 
cartesian polar packages existential type point parametric type pointrep specify structure point operations type real real data representation 
differ content package determines function implementations 
general existential type forces packages type structure operations 
type internal data representation value implementation operations may differ different realizations data type 
data type packaged operators point simple example module 
general modules import known modules parameterized respect unknown modules 
parametric modules treated functions existential types 
way extending point package operation add 
doing extension particular point package write procedure extension point package unknown representation point 
recall record type concatenation operator type pointrep pointrep add pointrep pointrep pointrep type pointrep 
pointrep value fun point open pointrep pack pointrep pointrep pointrep add fun pointrep pointrep coord coord coord coord value value go back point module show modules built top 
particular build modules circle rectangle top point define module picture uses circle rectangle 
different instances point may different data representations sure circles rectangles representation point want interact 
circle package provides operations create circle point center real radius operations extract center radius circle 
operation diff circle difference distance centers circles defined 
parameters diff circles implementation point 
circle package provides point package allow access point operations working representation point circle package 
type pointrep pointrep pointrep real center pointrep radius real diff real type pointrep 
pointrep type circle pointrep 
pointrep type pointrep 
pointrep pointrep value pointrep fun pointrep pack pointrep real pointrep fun pointrep real center fun pointrep real fst radius fun pointrep real snd diff fun pointrep real pointrep real fst fst sqrt coord coord coord coord build particular circle packages applying various point packages 
define different versions different representations circle applied different point packages obtain circle packages 
apply obtain cartesian polar circle packages 
value open rep pack pointrep rep pointrep rep value open rep pack pointrep rep pointrep rep circle package open 
open twice note type circle double existential quantification bind pointrep point circle representations package 
abbreviated form open equivalent consecutive opens open pointrep 
rectangle determined points upper left bottom right corner 
definition rectangle module similar circle module 
addition sure points determining rectangle representation point 
type pointrep pointrep pointrep pointrep pointrep pointrep type pointrep 
pointrep type rect pointrep 
pointrep type pointrep 
pointrep pointrep value pointrep fun pointrep pack pointrep pointrep pointrep fun tl pointrep br pointrep tl br fun pointrep pointrep fst fun pointrep pointrep snd put module figures uses circles rectangles implementation point defines operation returns smallest rectangle containing circle 
type pointrep pointrep pointrep type pointrep 

pointrep type figures pointrep 
pointrep type figures pointrep 
pointrep pointrep value pointrep fun pointrep pack pointrep pointrep pointrep open pointrep open pointrep fun center 

modules class values previous section shown packages modules class citizens legal values passed returned functions stored data structures 
example possible write programs depending conditions produce package existential type implementing interface return construction larger packages 
process linking modules expressed done previous example produced linking 
process building systems modules expressed language program modules full power language applied linking phase 
shown express parametric modules linking mechanisms claim convenient notation 
purpose show concepts captured relatively simple framework 
done prevent notation getting hand 
major problem aware dependency graph modules creating new module instances linking done hand new instance 
problems particularly addressed standard ml module mechanism macqueen 

bounded quantification 
type inclusion subranges inheritance say type included subtype type values type values type exactly considered set values subset general notion inclusion specializes different inclusion rules different type constructors 
section discuss inclusions subranges records variants function types 
inclusions universally existentially quantified types discussed sections 
inclusions record types simple theory inclusions integer subrange types 
denote subtype type int associated subrange extremes included known integers 
type inclusion relations hold integer subrange types iff left type inclusion right equal 
subrange types may occur type specifications expressions value fun constant type type supertype including type 
legal argument similarly legal value fun type subtype domain actual parameter application subtype corresponding formal parameter 
consider function type 
considered function type maps integers integers 
note domain shrinks codomain expands 
general formulate inclusion rules functions follows iff note accidental similarity rule rule subranges inclusion domain swapped 
interesting point inclusion rules higher functional types 
example value fun applied inclusion rules subranges arrows application 
line reasoning applies record types 
suppose types type car age int speed int fuel string type vehicle age int speed int claim cars vehicles car subtype vehicle 
achieve need inclusion rule record types 


iff record type subtype record type attributes fields possibly types common attributes respectively subtype relation 
meaning type vehicle set records integer field age integer field speed possibly 
car set set cars subset set vehicles 
subtypes subsets 
subtyping record types corresponds concept inheritance subclasses languages especially records allowed functional components 
class instance record functions local variables subclass instance record functions variables possibly 
fact express multiple inheritance 
add type definitions type object age int type machine age int fuel string car subtype inherits properties vehicle machine subtypes object 
inheritance records extends higher functional types case subranges inclusion rule function spaces maintained 
case variant types inclusion rule 


iff example bright color color type red unit green unit blue unit type color red unit green unit blue unit gray unit brown unit function working colors able accept bright color 
detailed examples kind inheritance half cardelli 

bounded universal quantification subtyping come problem mix subtyping parametric polymorphism 
seen usefulness concepts separate applications shall show useful necessary merge 
take simple function records component value fun int applied records true 
polymorphic value fun records form type records true 
notation allows express notion type variable ranges types allow designate type variables range subset set types 
general facility specifying variables range arbitrary subsets types realized quantification type sets defined specified predicates 
need generality satisfied specifying just particular class subsets set subtypes type 
may accomplished bounded quantification 
type variable ranging set subtypes type may specified bounded quantification follows ranges subtypes scope function accepts record having integer component extracts contents value int fun int bool true note little difference done move constraint argument subtype int fun parameter parameter 
ways expressing inclusion constraints implicitly function parameters explicitly bounded quantifiers 
bounded quantifiers remove mechanism requiring exact matching types parameter passing shall leave convenience 
express type need introduce bounded quantification type expressions int 
int way expressing inheritance parametric polymorphism 
new version int type value fun int int bool true abbreviation top new function expressed parametric polymorphism inheritance separately 
combination achieved bounded quantifiers allows write 
far bounded quantifiers shown extra power rephrase allow type inclusion parameter passing 
bounded quantifiers expressive shown example 
need bounded quantification arises frequently object oriented programming 
suppose types functions type point int int value fun point dx int dx value point fun dx int dx typical type free object oriented programming reuse functions objects type known defined 
define type tile int int hor int ver int may want move tiles just points 
simpler function sound assume result point parameter tile allow inclusion function arguments 
lose type information passing tile function example extract hor component result 
bounded quantification allows better express input output dependencies result type argument type subtype point happens 
apply tile get tile back losing type information tile hor ver hor shows bounded quantification useful absence proper parametric polymorphism express adequately subtyping relations 
earlier saw parametric polymorphism explicit quantifiers implicit having free type variables implicitly quantified 
similar situation inheritance explicit bounded quantifiers left implicit inclusion rules parameter passing 
object oriented languages subtype parameters generally implicit 
may consider languages abbreviated version languages bounded quantification 
bounded quantification useful increase expressive power explicit parameter mechanisms inheritance achieved 

comparison subtyping mechanisms inheritance mechanisms compare simula smalltalk lisp flavors 
uses inheritance correspondence exact obtained paraphrases 
uses inheritance simulated especially essential dynamic typing 
hand things done bounded quantification impossible object oriented languages 
record types model classes subclasses 
record types matched structure multiple inheritance relations implicit names types record components 
simula smalltalk classes matched name inheritance relations explicit single inheritance allowed 
lisp flavors allow form multiple inheritance 
smalltalk metaclasses emulated framework 
records model class instances 
records constructed explicitly create new instance class primitive specifying construction time values components 
different records record type different components gives degree flexibility shared simula smalltalk 
simula distinguishes functional components operations shared instances class non functional components variables belong instances 
simula virtual procedures way introducing functional components may change different instances class uniform subclasses class 
smalltalk distinguishes methods shared instances class instance variables local instances 
simula variables declared classes smalltalk instance variables private directly accessed 
behavior easily obtained framework limiting visibility local variables static scoping techniques 
functional record components model methods 
remarked previous paragraph record components conceptually bound individual records record types implementations optimize 
simula smalltalk possible subclass automatically inherit methods superclass redefine 
considering multiple inheritance automatic way inheriting methods creates problems case superclass defines method inherited 
avoid problem having create records explicitly 
record creation time choose explicitly field values particular record inherit predefined function value allocation records redefine new function value 
allowed long type constraints respected 
record field selection model message passing 
message sent object parameters translates selection functional component record application parameters 
similar simula smalltalk goes complex name binding procedure associate message names actual methods 
simula compute statically precise location variable operation instance 
smalltalk dynamic search optimized caching methods 
field selections intermediate complexity multiple inheritance possible determine statically precise location field record caching achieve constant time access fields average achieves exactly constant time programs single inheritance 
smalltalk concept self corresponding simula class instance referring methods variables simulated introducing special construct 
done defining record recursively ordinary variable called self different name refers record recursively 
smalltalk concept super class instance referring methods immediate superclass similar constructs simula qua flavors simulated imply explicit class hierarchy 
simula special construct called inspect essentially case statement class object 
way emulating directly turns inspect simula variant types 
variant types simula obtained declaring variant cases subclasses dummy class doing inspect objects class 
variants just rephrase relevant simula classes subclasses variants ordinary case discrimination 
smalltalk lisp flavors idioms reproduced essentially impossible type check statically 
example flavors ask object supports message may possible paraphrase situations variant types 
generally freedom type free languages hard match shown previous sections polymorphism go long way achieving flexibility bounded quantification extend flexibility inheritance situations 

bounded existential quantification partial abstraction done universal quantifiers modify existential type quantifiers restricting existential variable subtype type retain notation abbreviation top 
bounded existentials allow express partially types know subtype type know types subtype relation 
see example version pack construct modified bounded existentials pack suppose types point tile want interact 
suppose want tile subtype point want know inclusion holds want abstractly 
satisfy requirements definition type tile type point type tile subtype supports tile operations 
precisely type int int int int origin hor int ver int type type tile tile package created follows concrete representations points tiles previous sections type pointrep int int type int int hor int ver int pack pointrep pack pointrep fun int int hor int ver int hor hor ver ver origin fun hor fun hor ver fun ver note origin returns pointrep expected tiles considered points 
function tiles treat points tiles points represented tiles subtypes points unknown fun tile open pointrep fun pointrep tile languages type inheritance types natural able extend inheritance types having reveal representation types 
just seen bounded existential quantifiers explain situations achieve full integration inheritance abstraction 

type checking type inference conventional typed languages compiler assigns type expression subexpression 
programmer specify type subexpression expression type information need placed critical points program rest deduced context 
deduction process called type inference 
typically type information local variables function arguments results 
type expressions statements inferred type variables basic constants known 
type inference usually done bottom expression trees 
type leaves variables constants type rules ways combining expressions bigger expressions possible deduce type expressions 
sufficient declare type newly introduced variables 
note may necessary declare return type function type initialized variables 
fun int ml language introduced sophisticated way doing type inference 
ml necessary specify type newly introduced variables simply write fun type inference algorithm works bottom 
type variable initially taken unknown 
initially type new type variable new type variable introduced program variable 
int operator retroactively force equivalent int 
instantiation type variables done robinson unification algorithm robinson takes care propagating information instances variable incompatible uses variable detected 
introductory exposition polymorphic type inference cardelli 
inference algorithm limited polymorphic languages 
added monomorphic typed language restriction type checking type variables disappear 
expressions fun ambiguous write fun int example disambiguate 
best type inference algorithm known ml similar languages 
amounts saying best know type inference type systems little existential quantification subtyping limited quite powerful form universal quantification 
extensions ml type system type checking problem shown undecidable 
type inference reduces type checking type information program type inference task trivial 
precisely talk type checking type expressions involved checking program explicitly contained program text need generate new type expressions compilation match existing type expressions 
probably hope find fully automatic type inference algorithms type system 
type checking problem system turns quite easy amount type information supplied program 
probably single important property type system expressive posing major type checking problem 
problem shared polymorphic languages type checking side effects 
restrictions imposed prevent violating type system storing fetching polymorphic objects memory locations 
examples gordon albano 
known practical solutions problem damas milner trade flexibility complexity type checker 

hierarchical classification type systems type systems classified terms type operators admit 
partial diagram type systems ordered generality 
box diagram denotes particularly type system type systems may fall 
bottom box enumerate type operators type system going bottom show new operators 
top box name type system middle set features model going bottom list new features 
diagram symmetrical reflect structure existing classes languages precisely 
classification type systems languages 
particular language may fall particular point diagram features position different degrees different points diagram 
existing language type systems seldom fall exactly points highlighted combination features positions highlighted points 
bottom simple order type systems cartesian products disjoint sums firstorder function spaces model records variants order procedures respectively 
sign indicates incomplete general type operator 
order type systems evolved higher order type systems left inheritance type systems right 
left side find algol higher order monomorphic language 
right side find simula single inheritance language multiple inheritance languages higher allocations clear cut 
classes type systems dominated higherorder inheritance systems amber cardelli 
bounded universal universal polymorphism universal parametric polymorphism simple universal ml polymorphism higher order monomorphism bounded quantifiers flexible interfaces quantifiers modules functional subtypes inclusion polymorphism order records variants procedures classification typ systems 
subtypes multiple inheritance simple subtypes single inheritance bounded existential subtypes existential types higher order languages developed parametric polymorphic languages 
restricted top level universal quantification milner type system milner roots curry curry hindley hindley general universal quantification girard reynolds type system girard reynolds 
right type systems type abstraction characterized existential quantification 
joining universal existential quantifiers obtain sol mitchell type system explain basic module features 
remaining points top inclusion 
shown bounded universal quantifiers needed model object oriented programming bounded existential quantifiers needed mix inheritance data abstraction 
powerful concepts inclusion universal existential quantification sufficient explain programming features 
full generality go existing languages 
careful maintain ability type check features easily 
picture 
interesting type systems lie diagram reynolds 
include coquand huet theory constructions coquand martin dependent types martin burstall lampson language pebble burstall macqueen language dl macqueen 
benefits going higher pebble dl general treatment parametric modules dependent types unlimited expressive power 
extra complications unfortunately reflect pragmatically complexity type checking 
topmost point diagram reasonable place gain experience consider willing accept extra complications order achieve extra power 

augmented calculus supports type systems rich type structure functional framework 
model type systems rich richer real programming languages 
sufficiently expressive model data abstractions ada classes object oriented languages 
ability express computations types strictly weaker ability express computations values 
modeling type module structures real programming languages augmented calculus gain understanding properties independent idiosyncrasies programming languages may embedded 
conversely may view type module structures real programming languages syntactically sugared versions augmented calculus 
started typed calculus augmented primitive types int bool string type constructors pairs records variants 
universal quantification introduced model parametric polymorphism existential quantification introduced model data abstraction 
practical application existential quantification demonstrated modeling ada packages private data types 
usefulness combining universal existential abstraction demonstrated generic stack example universal quantification model generic type parameter existential quantification model hidden data structure 
universal existential quantification interesting restrict domain variation quantified variable 
bounded universal quantification allows sensitive parameterization restricting parameters set subtypes type 
bounded existential quantification allows sensitive data abstraction allowing specification subtyping relations types 
insight subrange types integers subtypes defined type inheritance type inclusion polymorphisms extends applicability bounded quantification cases 
case record subtypes particularly interesting connection 
allows assert record type obtained adding fields record type subtype record type 
types cars may modeled record types fields set data attributes applicable cars 
subtypes may modeled record types include fields car records plus additional fields operations applicable 
multiple inheritance may generally modeled record subtypes 
records functional components powerful mechanism module definitions especially combined information hiding realized existential types 
type inclusion records provides paradigm type inheritance may basis design strongly typed object oriented languages multiple inheritance 
unified language fun language design practical programming language 
language design important issues solved concerning readability easy directly attacked 
fun provides framework classify compare existing languages design new languages 
propose programming language may clumsy areas basis 
appendix type inference rules type system discussed formalized set type inference rules prescribes establish type expression type subexpressions 
rules intended specification typechecking algorithm 
acceptable algorithm partially agrees rules sense computes type type derivable rules 
inference rules groups group deducing types inclusion relation second group deducing expression type group process 
type expressions denoted type variables type constants int expressions variables labels identify type expressions differ names bound type variables 
rules type inclusion set inclusion constraints type variables 
set extended constraint type variable subtype type assertion meaning infer horizontal bar logic implication infer infer 
note set rules complete respect semantic models valid rules omitted typechecking easier 
top top var bas bas arrow 
recd 






forall free exists free trans typing rules expressions set type assumptions free program variables 
set extended assumption variable type means set constraints set assumptions infer type top top var abs fun appl 
recd 


sel 


case case 
gen free spec pack pack open free open defn type definition trans research peter wegner supported part ibm yorktown heights part office naval research contract 

due dave macqueen countless discussions john mitchell insights 
doug mcilroy malcolm atkinson thorough reading manuscript nikhil albert meyer useful comments 
aho aho sethi ullman compilers 
principles techniques tools addison wesley 
albano albano cardelli orsini galileo strongly typed interactive conceptual language transactions database systems june pp 

booch booch software engineering ada benjamin cummings 
bruce bruce meyer semantics second order polymorphic lambda calculus data types kahn macqueen plotkin ed 
lecture notes computer science springer verlag 
burstall burstall macqueen sannella hope experimental applicative language conference record lisp conference stanford august pp 

burstall burstall lampson kernel language data types modules data types kahn macqueen plotkin ed 
lecture notes computer science springer verlag 
cardelli cardelli basic polymorphic typechecking bell laboratories computing science technical report 
polymorphism newsletters ii jan 
cardelli cardelli semantics multiple inheritance data types kahn macqueen plotkin ed 
lecture notes computer science springer verlag 
cardelli cardelli amber combinators functional programming languages proc 
th summer school le val france may 
coquand coquand huet constructions higher order proof system mechanizing mathematics technical report inria may 
curry curry feys combinatory logic north holland amsterdam 
damas damas milner principal type schemes functional programs proc 
popl pp 
damas phd thesis dept computer science university edinburgh scotland 
demers demers donahue revised report russell tr computer science department cornell university 
department defense ada manual ansi mis std jan 
fairbairn fairbairn ponder type system technical report nov university cambridge computer laboratory 
girard girard une extension de interpr tation de del analyse son application des coupures dans analyse la th orie des types proceedings second scandinavian logic symposium fenstad ed 
pp 
north holland 
goldberg goldberg robson smalltalk 
language implementation addison wesley 
gordon gordon milner wadsworth 
edinburgh lcf lecture notes computer science springer verlag 
hendler hendler wegner viewing object oriented programming enhancement data abstraction methodology hawaii conference system sciences january 
hook hook understanding russell attempt data types kahn macqueen plotkin ed 
lecture notes computer science pp 
springer verlag 
hindley hindley principal type scheme object combinatory logic transactions american mathematical society vol 
dec pp 

liskov liskov clu manual lecture notes computer science springer verlag 
mccracken mccracken typechecking programs implicit type structure semantics data types lecture notes computer science pp 
springer verlag 
macqueen macqueen plotkin sethi ideal model recursive polymorphic types proc 
popl 
appear information control 
macqueen macqueen modules standard ml proc 
symposium lisp functional programming austin texas august pp 
acm new york 
macqueen macqueen dependent types express modular structure proc 
popl 
martin martin intuitionistic type theory notes giovanni sambin series lectures university padova italy june 
matthews matthews poly manual technical report university cambridge computer laboratory 
milner milner theory type polymorphism programming journal computer system science pp 

milner milner proposal standard ml proc 
symposium lisp functional programming austin texas august pp 

acm new york 
mitchell mitchell maybury sweet mesa language manual xerox parc csl april 
mitchell mitchell type inference type containment semantics data types lecture notes computer science springer verlag 
mitchell mitchell plotkin types existential type proc 
popl 
reynolds reynolds theory type structure colloquium sur la programmation pp 
springer verlag lecture notes computer science 
reynolds reynolds approaches type structure mathematical foundations software development lecture notes computer science springer verlag berlin pp 

robinson robinson machine oriented logic resolution principle journal acm vol 
jan pp 

schmidt schmidt controlling large software development distributed environment xerox parc csl dec 
scott scott data types lattices siam journal computing vol september pp 

solomon solomon type definitions parameters proc 
popl tucson arizona 
strachey strachey fundamental concepts programming languages lecture notes international summer school computer programming copenhagen august 
welsh welsh hoare ambiguities pascal software practice experience november 
wegner wegner unification data program abstraction ada proc popl 
weinreb weinreb moon lisp machine manual fourth edition chapter objects message passing flavors symbolics 
wirth wirth programming modula springer verlag 
