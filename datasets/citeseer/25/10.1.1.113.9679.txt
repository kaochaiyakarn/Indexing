generative communication linda david gelernter yale university generative communication basis new distributed programming langauge intended systems programming distributed settings generally integrated network computers particular 
differs previous interprocess communication models specifying messages added tuple structured form computation environment exist named independent entities process chooses receive 
generative communication results number distinguishing properties new language linda built 
linda fully distributed space distributed time allows distributed sharing continuation passing structured naming 
discuss properties implications give series examples 
linda presents novel implementation problems discuss part ii 
particularly concerned implementation dynamic global name space generative communication model requires 
categories subject descriptors computer communication networks network ar chitecture design network communications computer communication networks distributed systems network operating systems programming languages language constructs structures operating systems communication man agement message sending 
general terms languages additional key words phrases distributed programming languages 
distributed programming language sr andrews writes basic kinds mechanisms corresponding models concurrent programming monitors shared variables message passing remote op erations 
introduce generative communication argue sufficiently different constitute fourth model 
new technique closest message passing differences significant similarities 
communication incorporated programming language 
central question 
question grown interest hardware cheaper networks connecting large numbers inexpensive processors cor material supported nsf mcs 
author address dept computer science yale university new haven ct 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 
acm 
acm transactions programming languages systems vol 
january pages 
generative communication linda important 
networks fall main classes local area nets connecting autonomous personal workstations network computers purely experimental large numbers processors simultaneously single problem 
sorts network call construction programs run processors 
local area nets programs mainly network operating system utility routines file mail servers 
network computers include operating system applications amenable parallel solutions 
applications studied context include numerical algorithms simulation sorting parallel artificial intelligence programs rapidly growing interest 
see example erman 
network operating systems parallel applications may written con languages augmented systems calls interprocess communica tion 
broad agreement distributed programming distributed language language communication sic principle satisfactory 
distributed language look 
particular deal interprocess communication 
concurrent systems languages dijkstra hoare brinch hansen example brinch hansen concurrent pascal wirth modula generally taken starting points 
programs concurrent distributed languages may consist concurrent processes language categories differ types inter process communication may incorporate 
multiple processes concurrent language program multiplexed machine distributed accordingly need execute wholly disjoint address spaces may shared variables generalization conventional parameter passing monitor call communicate 
usual assumption distributed languages hand concurrent processes execute separate machines disjoint address spaces 
may communicate sending receiving messages carried address spaces runtime communication system 
generative communication basis new distributed programming language called linda developed originally network computer ll 
distributed distributable programming languages proposed csp dp ada sr examples discuss 
need 
argue irrespective strengths weaknesses proposals linda unusual features language suggestive interesting right 
distributed languages partially distributed space time linda fully distributed space distributed time discuss 
second linda appears cases simpler expressive existing proposals application domains interest 
linda attempts combination simplicity power distributed domain systems language achieves sequential 
linda design encompasses model computation implications distribution communication 
concerned communication exclusively 
introduce aspects acm transactions programming languages systems vol 
january 
gelernter linda design communication issues necessary brief outline 
part deals generative communication linda 
part ii briefly discusses implementation generative communication networks particularly network computers 
final point attempt place linda context comparing distributed languages noted 
large number designs relevant way discussed 
chosen concentrate proposals closest conception differences cases obvious 
reports discuss linda relationship shapiro concurrent prolog ai languages 
omit discussion formal semantics semantics issues discussed 

part generative communication linda program collection ordered tuples 
tuples incorporate executing executable code collections passive data values 
interested passive tuples 
computation environment called tuple space basis linda model communication 
executing linda program regarded occupying environment called tuple space ts 
concurrent processes distributed program encompassed ts 
consider communicating processes send data generates tuples adds ts withdraws 
figures 
communication model said generative explicitly withdrawn tuple generated independent existence ts 
tuple ts equally accessible processes ts bound 
remainder concerns operations defined ts adds tuple ts withdraws read reads withdrawing 
sections define read simplest forms generalize introducing structured names 
discuss basic properties inherent definitions distinguish linda set apart distributed programming languages 
series examples 
simple read preliminary type name 
type specifier name refers character string acting identifier 
name valued variables constants attached identification tags tuples discuss 
definitions read 
statement appears 
pp 
pj list parameters may actual formal actual parameter type name 
assume time pi actual parameters 
execution statement results insertion tuple pp 
pj ts executing process continues immediately 
acm transactions programming languages systems vol 
january 
generative communication linda ts ei tuple ccl statement appears 
fig 

send generates tuple 
fig 

withdraws 
pp 
pj list parameters may actual formal actual parameter type name 
assume time pi formal parameters 
statement executed type consonant tuple component exists ts tuple withdrawn ts values actuals statement formals expression executing statement continues 
matching tuple available ts suspends available proceeds 
read statement read pz 

identical statement matching tuple assignment actuals formals tuple remains ts 
nondeterminism inherent definitions 

statements may execute simultaneously suspend portions distributed program 
execution 
un er circumstances single copy output tuple available 
suspended statement receive logically 
holds iv 
read 
statement executes subsequent stored tuple matched 
definitions require tuples inserted withdrawn ts atomically 
statements contend tuple gets acm transactions programming languages systems vol 
january 
gelernter split 
note read statement statement contend tuple statements served arbitrary order 
read statement served may subsequently withdraw tuple 
served removes tuple read block available 
tuple names global program ts 
tuple added ts may removed statement occurring program 
structured naming refer tuple added ts statement 
designates parameter list read statement may legally receive tuple hst 
fk cited read statement need formals 
components list may fact actuals 
actual parameters appearing tuple including initial name valued actual collectively constitute structured name 
statement integer boolean requests tuple name 
possible write boolean case tuple structured name requested 
statements integer false false possible 
case structured name false false 
actual components list matched identi cally corresponding components tuple order matching occur 
structured naming similar principle select operation relational database systems may said ts content addressable 
resembles rudimentary significant way pattern matching features part ai logic languages particularly prolog 
statement prolog assertion deal tuples unspecified components formals may inferred arbitrary specified subset values 
just components may actuals component tuple initial name valued actual may formal 
false represents simplest form statement integer false possible 
tuple integer false may received ino statement specifies component component false middle component actual type integer 
tuple may general received acm transactions programming languages systems vol 
january 
generative communication linda statement identical actual tuple actual type consonant actual tuple formal 
formals match formals 
formals statements referred inverse structured naming 
note 
formal declared statement parameter list defined immediately enclosing lexical block exactly declared local block 
variables declared conventionally parameter lists may formals statements lexically visible 
context prefixed var interpreted actuals part structured name 
sequence integer var integer variable serves statement formal 
sequence integer value component structured name note formals declared statements include explicit type designators 
statement integer requests tuple structured name declare formals type integer 
formal declared tuple defined tuple 
context formals tuples serve place holders names unimportant 
distinguishing properties generative communication defined read funda mental characteristics give rise series distinguishing properties 
fundamental characteristic communication orthogonality 
ordinarily case execution arbitrary distributed programming language receive statement presupposes knowledge process execute matching send statements fact usually case analogy procedures subroutines sequential languages may receive input number sending processes procedure may invoked number points sequential program 
send statements name receiver explicitly fashion analogy procedure invocation statement invariably names invoked procedure 
linda hand communication orthogonal sense just receiver prior knowledge sender sender receiver 
communication orthogonality important consequences space uncoupling referred distributed naming time uncoupling 
third property distributed sharing consequence 
pl space uncoupling distributed naming 
distributed naming refers fact tuple ts tagged may input number address space disjoint processes 
particular processes executing distinct network nodes may accept tuples tagged name 
distributed naming means linda fully distributed space 
distributed programming languages ordinarily noted allow receive statement accept data originating acm transactions programming languages systems vol 
january 
gelernter fig 

distributed naming 
tuple input may originated address spaces tuple output may received address spaces 
distinct address spaces 
linda allows sender direct data distinct address spaces 

time uncoupling 
tuple added ts remains ts removed 
removed remain ts forever 
practice tuples added ts distributed program removed program processes terminated pro grammer indicates explicitly contrary 
despite practical tions linda allows programs distributed time insofar process statement appears may run completion process corresponding appears loaded 
distributed program ming languages ordinarily allow communication processes space disjoint linda allows communication time disjoint processes 
third effect results space time distribution 
distributed sharing 
linda allows address space disjoint processes share variable depositing ts 
ts operator definitions ensure maintained atomically 
necessary languages shared variable implemented process module 
refer second generative communication fundamental prop erties free naming 
expository purposes introduced type name acm transactions programming languages systems vol 
january 
space time generative communication linda fig 

distribution time 
space disjoint processes communicate ts time disjoint processes terminates starts likewise communicate ts 
idea structured naming subsequently 
fact existence type name logical consequence structured naming 
distributed program ming languages distinguish name specified statement list parameters 
linda distinction eliminated name specified statement definition sequence actual parameters appear statement parameter list 
actuals simply values appear parameter list 
follows statement specifies single actual definition single actual appear list single actual value 
values types say type value serving statement single actual name 
facts linda collectively designated free naming result properties 

support continuation passing 
values type name variables type name 
names may passed tuple acm transactions programming languages systems vol 
january 
gelernter components assigned formals stored arbitrary data structures just values type may continuation passing refer specifically process sending data blocking expectation reply continued ultimately third nth process 
linda supports continuation passing simple flexible way allowing name type values tuple components stored arbitrary data structures way values type 

structured naming 
structured names allow read statements restrict statements widen focus 
allow name generate family 
examples illustrate properties basic program structures linda induces 
incumbent designers language linda maximizes power flexibility broad solution space simplicity convenience narrowly constrained provide macro library routine specification simplicity con wanted 
macro definition facility introduced discussed course examples 
examples refer distributed distributable programming language proposals mentioned purposes comparison 
sections preliminary definitions group exam ples simple structured names group structured names final group structured names read 
preparatory examples outline expression structure linda 
order give examples need consider briefly structure linda expressions 
linda expressions consist simple statements composed statements 
term expression appropriate collection statements statements values concern 
simple statements include assignments procedure calls control statements 
tant context mainly identical simple statements composed statements hand germane determine program structure 
linda composed statements sequence statements statements statements star statements 
aj simple statement composed statement enclosed square brackets 
sequence statement takes form sz 
specifies sl 
aj executed sequentially linda terminology sequential lifetimes 
statement ed 
ed specifies sl 
sj concurrent lifetimes 
pair statement constituents executable statements execute concurrently statement variable declaration declared variable exists long statement executes accessible constituents statement declared 
statement provides acm transactions programming languages systems vol 
january 
generative communication linda variable declaration concurrency 
statement terminates constituents terminated defined 
variables quiescent 
variables may declared statements 
special notation 
integer 
simply integer 
var 

rules unconventional justification implications lie scope reader asked suspend judgment 
statement basis linda called symmetric structure allows richer collection assignment statement forms binding environment specifications algol languages ordinarily provide 
issues discussed length 
statement sl specifies sl 
sj mutually exclusive lifetimes 
single enabled constituent statement chosen execution choice nondeterministically runtime 
constituent enabled execution suspends purposes statement constituent enabled consists begins statement matching tuple statement available ts 
star statement executes times 
begins statement intended case executes matching tuple available ts matching tuples available star statement 
ordinarily quiescent star statement terminates immediately prevented terminating statement component components state ment active 
quiescent star statement appearance new matching tuple ts terminates components encompassing statement terminated 
star statements form statement referred blocks common convenient introduce shorthand notation examples simple bus communication structures 
may implement message passing obvious way 
remote procedures implemented combining remote procedure call formals acm transactions programming languages systems vol 
january 
gelernter remote procedure name formals body procedure distinguished name replaced compiler name uniquely designates process appears process sequentially executing code block distributed program may encompass processes 
structure referred remote procedure may equivalently referred active procedure procedure block executed thread control associated caller 
active procedure reentrant recursively callable 
linda ordinarily com ponent statement components processes 
disappears definitions statements star statements encompassing statement terminates 
note linda resembles sr language fragment described kahn providing asynchronous output operation 
semaphores communication orthogonality 
single element tuple functionally equivalent semaphore 
sem functionally equivalent semaphore operation sem sem sem 
semaphore sem initial ized value repetitions em 
semaphore nature result communication orthogonality linda 
space time uncoupling properties mean singleton sem tuples exist independently processes generate outlive processes necessary 
distributed naming means semaphores defined fact distributed semaphores discussed example schneider semaphores defined arbitrarily disjoint address spaces 
expression distributed sharing processes may share semaphores directly ts executable code block need programmed implement requests 
semaphores primitive indicative linda simplicity flexibility 
languages level higher semaphores rely conceptually high level constructs tasks processes implement low level objects 
linda differs surveyed systems csp making commu nication orthogonal 
linda csp orthogonal opposite senses 
csp communicating processes name explicitly data transferred synchronously sender receiver system provided buffering 
communication csp space coupled naming rules time coupled synchronous transfer 
distributed naming 
consider maximally simple idle node allocation procedure network computer 
idle nodes execute idle job description execute job 
fork new asynchronous task processes execute idle 
acm transactions programming languages systems vol 
january 
generative communication linda tuples tagged idle may input network node distributed naming 
note statement executes idle node network executing idle 
statement idle tuple remains buffered ts node idle picks 
result time uncoupling 
example ethernet worm programs users need communicate worm segment 
segment worm whereabouts unknown runtime 
linda worm segments execute request execute request users request execute worm segment 
languages discussion supports distributed naming 
allows name referenced processes confined guardian physical node 

synchronized message exchange calling routine structures macro definitions 
csp provides noted synchronizing message exchange operators 
receive operation suspends matching send executed send suspends matching receive 
implement operations sufficient sender transmit soon reaches send statement suspend execution receiver forwards acknowledgment 
message buffering provided sender transmit receiver suspended receive statement 
presenting implementation operations linda occasion macro facility 
programs synchronous com munication specify include macro def synch send tuple get got def synch recv tuple get got 
synchronously process executes synch send mes sage andb executes synch recv message type note im plementation requires singleton tuple get buffered ts require message text buffered 
macro definitions satisfactory single pair processes ts names get got ambiguous 
general definitions structured names discussed 
conventional languages called routines procedures functions subroutines may arbitrarily elaborate calling routines protocol followed process passing data necessary retrieving results ordinarily consist single invocation statement 
linda allows programming calling routines may general elaborate called routine 
synch send example calling routine follow 
resource servers continuation passing property filter active monitor structures 
continuation passing communication acm transactions programming languages systems vol 
january 
gelernter allow resource servers programmed familiar feeder driver paradigm input guards common distributed program ming languages 
case request queues maintained kernel directly accessible server 
constructed maintained entirely server 
include examples solutions included preliminary ada rationale 
ada solutions represent input guard programming style usefully compared linda feeder driver style 
disk head scheduler 
ada example assumes client processes communicate disk head scheduler passing parameters type track type data assumption 
logical structure linda disk server shown 
user passes name filter blocks name continues request filled server 
requests accepted filter passed server directly server free accumulate filter filter passes onward order appropriate problem 
existence filter transparent user 
filter structure may programmed linda result continuation passing property 
users call disk executing calling routine track data def disk service track data 
server takes form disk filter disk disk def disk ask filter request get receive request name track data perform physical ijo transfer tell user continue disk active procedure repeatedly asks filter request performs notifies user service complete 
disk filter active monitor structure general takes form shared variables 
ri routines access shared variables mutual exclusion 
active monitor resembles hoare monitor active monitor routines executed thread control associated monitor user ada accept block 
acm transactions programming vol 
january 
disk filter takes form generative communication linda fig 

filter server paradigm 
def declarations disk idle boolean true declarations required building maintaining requests queue queue frames fields type name track data def disk enqueue name track data accept disk request disk idle send request directly false request queue desired ordering discipline def disk dequeue accept disk request request get name track data local variables request queue empty disk answered eventually disk enqueue disk idle true head entry request queue ii disk head scheduler considerably complex ada 
user calls procedure calls entry behalf entry registers user request user suspends entry call time family entries 
background task repeatedly calls entry determine request serve ultimately continues user accepting entry call suspended 
elevator algorithm service requests intrinsic tasking communication structure ada example 
need linda example 
controller problem stated ada rationale users requesting subset resources set designated 
users request resource group passing server parameter group type resource set return group passing parameter type 
example simpler disk head scheduler 
requires active monitor additional driver process 
acm transactions programming languages systems vol 
january 
gelernter linda solution takes form declarations include ada example function try returns true resource set passed free allocated requestor variable type resource set records resources able 
resource sets bit vectors assume ada bit wise logical opera tions 
request queue built frames containing field type name field asked type resource set 
mrc enqueue mrc dequeue def mrc enqueue mrc request name asked resource set try asked assign group requestor asked append asked request queue def mrc release released resource set released frame request queue try asked award requested group blocked requestor asked remove request queue request resource set users execute request resources release release resources def request resources resource set mrc request def release resources resource set mrc release 
note linda example depends continuation passing 
rationale ada solution considerably complex logically 
request queue consists calls single entry 
access queue server accepts waiting entry call request represents satisfied instructs requestor reenter queue entry call 
entire queue inspected entire queue cycled back server address space request request 
note maintaining queue useful order keeping pointers queue impossible 
discussion 
linda example strongly suggests csp easy imagine csp solution nearly linda version 
acm transactions programming languages systems vol 
january 
generative communication linda protection filter queuing filter fig 

protection filter place 
case csp lacks linda free naming property support continuations general way 
linda solution depends requestor passing name mrc enqueue passes queue mrc dequeue 
csp names passed parameters way requestor identify mrc enqueue passing index process array parameter allows server pick statically encoded list possibilities 
note extensions csp introduce ports allow port names passed parameters see kieburtz silberschatz example allow kind solution 
systems surveyed csp dp ada allow general continuation passing 
evidently 
sr argue la formalisms considerably complex linda 
conclude section considering briefly question access tuple names 
single distributed program encompasses processes share single name space single ts 
different distributed programs say user program operating system run network defines name space constituent processes program ordinarily access tuples generated second 
prefixing internal representation tuple names program id kernel protects program set tuples augmentation deletion program 
clearly times user program access names system user name space possible import external names receive parameters 
programs may specify kernel enforce limitations uses exported names may put 
example system export name disk request statements kernel traps disk request 
read 
statements occur outside system 
system free protect installing protection filters front servers 
name disk request example exported statement di sk quest 
appear protection filter checks identity requestor access list local protection filter 
requestor access rights public name disk request stripped request tuple forwarded private name queueing filter 
exception generated bad status returned 
examples structured names conversational continuity structured naming 
conversational continu ity described liskov refers systems programming problem identical instances server 
user may start conversation instance having chosen converse acm transactions programming languages systems vol 
january 
gelernter exclusively duration conversation 
multiplicity servers process selecting obligation stick transparent users 
linda solution servers execute initially server name start user accept start request duration conversation server request user accept request start users execute initially server start duration conversation server request 
node allocation inverse structured naming 
refinement simple idle node allocation scheme discussed task generators may need direct tasks specific nodes cases idle node 
network node executes idle job execute job 
direct task specifically node idle direct task idle node idle integer 
reminder messages time uncoupling inverse structured naming 
consider routine def reminder current date time tick increment current time msg string print string reminder started assume component statement components need initialized current date time 
assume encoded single integer maximum simplicity presentation 
date time represented separate fields updated appropriately 
reminder waits ticks 
singleton tuple tick appears ts withdrawn value incremented 
incrementation reminder looks tuple ts component msg second component current date time 
tuple withdrawn third component printed 
acm transactions programming languages systems vol 
january 
generative communication linda statement tick executed response logical equivalent hardware clock interrupt 
reminder representative interrupt han 
correct realtime response depends course scheduling policies implemented kernel 
useful allow hardware determined priorities associated statements associated device modules concurrent language modula discuss 
reminder basis reminder message system works follows 
want reminded date time execute msg 
example msg june pm faculty meeting minutes 
beat function translates date time specifying string equivalent internal representation single integer 
needs able read current time order discuss read current time section june pm reminder fish tuple ts print specified message 
note ts acts case content addressable file system 
discuss implications section suppose date time represented internally single integer series fields year month date hour minute set ms case msg june pm faculty meeting minutes 
beat equivalent msg faculty meeting minutes 
beat 
note allow function return tuple 
reminder withdraw print message user logged june 
suppose message appear time june precisely 
case write msg anytime june faculty meeting today anytime produce translation msg int int int int faculty meeting today 
acm transactions programming languages systems vol 
january 
gelernter includes specialized form restricted input statement 
sr includes restricted input statement general linda statement actuals allowing arbitrary boolean expressions enforced input parameters general sr allow distributed naming restricted input statement steer parameters certain nodes away 
languages surveyed allows equivalent inverse structured naming 
larger example time uncoupling continuation passing structured names appendix 
examples read global variables distributed sharing 
checkers playing program imple mented network computer contains multiple processes search tree game states parallel 
parallel processes processes stopped known exploring consequences move 
process notify 
allowed shared variables processes value best move far put global location 
lacking global memory arrived different solution 
lo linda allows simple solution programmed directly 
read value best move read best move move 
change value best move best move old move move best move new move 
code required distributed game playing program considerably complex 
delay statement structured names distributed sharing 
global clock stored ts form clock time value tuple 
assume time values integers tick increments clock 
read clock processes execute read clock integer 
write clock clock process executes clock integer clock 
processes find delay statement useful delay delays executing process time units 
conventional implementation delay service send delay requests central server stores wake time ordered queue 
solution simple implement simpler solutions request queue distributed acm transactions programming languages systems vol 
january 
ts 
delay calling routine def delay integer delay ticks read clock integer delay generative communication linda clock tick wake server increments clock awakens processes delayed tick update clock clock integer clock awaken processes delayed time delay name circumstances simpler def delay integer read clock integer read clock read statement consults clock assigns current time 
second specifies structured name match clock tuple cause read statement continue time reaches tick wake server simply increments clock 
solution correctly clock period long relative amount time takes execute followed 
clock process may remove tuple oc ts read oc statements chance see case read statements seen stuck forever 
time uncoupling tuple persistence file systems space distributed computing innovation investigation barely begun 
time distributed programming languages linda sense likewise unfamiliar time distributed computing new 
communication time disjoint programs long provided file systems 
linguistic model time distributed communication routine retains state time disjoint invocations coroutines generators proce algol variables monitor routines access permanent monitor variables 
linda extension linguistic model fully space distributed computing results extension time distributed computing linguistic aegis covers certain filing functions traditionally extra linguistic 
generative communication logically encompasses tuple structured content addressable file system 
extent desirable practical incorporate filing functions linda clear 
assume processes distributed program completed tuples generated program remain ts deleted exceptions acm transactions programming languages systems vol 
january 
gelernter tuples names system name space tuples names appear save list specified programmer 
summary noted start generative communication results number properties distinguish linda languages 
summarize reiterate 
distributed naming 
surveyed languages supports distributed naming 
multiple identical space disjoint servers exist network client processes refer different name send requests process sends onward distributed servers 
note scheme imposes centralization distributed environment linguistic grounds 
time uncoupling 
surveyed languages supports time pling linda sense 
communication time disjoint processes sup ported systems file system interprocess communication mechanisms 
distributed sharing 
surveyed systems supports distributed sharing 
variables shared disjoint processes implemented proc modules 
continuation passing 
linda sr support continuation passing 
continuation passing style contrasted systems domain input guard style 
input guard languages admit server address space requests may served immediately 
blocked requests consequently blocked processes blocked process queues domain kernel inaccessible programmer 
note sr resembles languages providing input guards relying examples resource server implementation 
strategy programming request queue problems clear 
structured names 
surveyed systems supports structured naming linda sense sr include restricted input statements 
linda weaknesses stem strengths programmers required implement structures calling routines queue managing filters pro vided languages 
properties distributed naming sharing linda inherently secure languages care taken prevent unauthorized access stored tuples 
linda presents difficult novel implementation problems particularly distributed envi ronment 
central problem dominates implementation question ts implemented absence shared memory 
address question part ii 
important topics omitted survey mention briefly 
modularization important construction large distributed programs linda supports necessary mechanisms discussed 
type checking particularly important building large systems 
definitions require name acm transactions programming languages systems vol 
january 
generative communication linda type tuple statements false may legitimately appear program 
flexibility useful runtime type checking impossible 
process executes integer meant say char danger hanging forever 
easy allow user programs desire run type checked mode kernel signals exception tuple blocked statement specify name match type 
dynamic process creation capability generative communication operators discussed 
briefly side effect free expression may appear generated tuple tuples added ts unevaluated form 
soon tuple enters ts evaluation unevaluated components begins simultaneously 
statement generates new process name executes returns integer result tuple may removed ts statement integer 
evaluation blocks evaluation complete 
dynamic process creation powerful tool entails difficult implementation problems discussed 

part ii virtual linda machine network computer concerned aspects implementation linda networks particularly network computers 
initial assumption target machine nodes essentially equal power 
study linda implementation problem leads top fashion class interconnection topologies communication architectures suited linda supporting network computer 
techniques described designed partially implemented network computer 
discuss implementation principles 
general outline full treatment appears 
virtual linda machine propose think read primitive instructions virtual linda machine implemented hardware network communication kernel compiler cooperation 
communication kernel program resident network node implements internode communication 
implementing relatively high level computation operators virtual machine primitives established technique implementing com munication operators analogous fashion requires 
communication operators usually regarded tools provided system 
intend write operating systems linda 
implementation linda communication operators underlie system provided hardware communication kernel 
constructing distributed central problem noted implement ts absence shared memory 
question resolves subproblems find tuples major issue keep 
acm transactions programming languages systems vol 
january 
find tuples dynamic global name space name space global modules distributed linda program impossible resolve global name statically runtime 
suppose distributed program running network nodes executed time 
recall read statement parameter list tuple legally received read statement 
time processes suspended statements possibly empty subset nodes occupied program impossible determine identity compile load time 
method provided matching tuples statements runtime words implementing dynamic global name space 
providing name space important additional benefit unnecessary far name resolution goes assign modules distributed program statically network nodes 
allowing network computer operating system maximal freedom locate relocate distributed jobs network fact important goal 
static mapping modules nodes requires distributed programs relinked time run rules possibility new modules generated dynamically ing programs making impossible system reposition modules network response hardware failure changing resource requirements changing network environment 
enforcement static mapping policy requires facto significant portion network computer potential power flexibility loss roughly comparable engendered conventional system requiring object modules reside fixed absolute addresses 
requirement provide dynamic global name space 
runtime resolution name may handled general ways 
name node mapping information may concentrated central directory nodes may distributed network wide example means network wide broadcast 
maintenance central directory lead congestion bility furthermore inappropriate kernel function 
ideally kernel small simple program basically identical node 
distinguishing certain kernels directory servers requiring submit service requests involves kernel undesirable degree complexity special ization 
kernel implement global name space linda supported directly kernel distributed storage name node mapping information attractive approach 
combined weight design decisions mapping logical physical addresses function virtual machine 
program modules names define may mapped nodes moved nodes freely pages may moved page frames paged memory system 
support flexibility paged machine translates virtual physical addresses hardware basis 
analogous function translation kernel tuple names network addresses basis 
acm transactions programming languages systems vol 
january 
generative communication linda potential benefits flexible architecture balanced cost complexity implementing internode communication runtime resolution name 
power realized communica tion kernel implemented efficiently 
address specifically issue efficient name resolution remainder section 
define method network state storage called uniformly distributed network state collection data descriptive particular node may interest network generally 
fact tuple name currently required statement node instance state datum 
informally network state storage scheme uniformly distributed node stores current state node 
uniformly distributed state storage schemes fall discrete spectrum 
spectrum state data broadcast node node maintains complete copy state entire system 
state information remains local node originates 
case discover current state node broadcast query entire network nodes respond broadcast query information extracted local states 
state data read frequently written clearly scheme efficient terms total communication processor bandwidth expended reads writes 
scheme writing expensive broadcast required reading cheap 
writes frequent reads second scheme efficient 
hand reads writes occur roughly equal frequency third scheme intermediate efficient 
roughly equal precise definition node net roughly equal means equal factor discussed general treatment 
intermediate scheme assuming node network writing network state consists broadcasting state data set nodes called write set 
reading state consists broadcasting query different set nodes called read set 
read set chosen correctly nodes store entire network state 
condition assured node read set non null intersection node write set 
consider problem implementing 
definition operation add network state datum available node words executed node instance accordingly desired 
operation consult network state return identity node executed instance accordingly needed 
node request remain outstanding node return node identity 
note internal communication kernel 
part linda 
abstractly node kernel may implement operation follows send node acm transactions programming languages systems vol 
january 
gelernter executed node implemented await receipt note level implementation atomic 
result instances may sent node case second instance reinserted global buffer 
state refer data write sets pertaining whereabouts tuples statements network 
executed roughly equal frequency reasonable assumption complicating factors discuss net state read written roughly equal frequency 
state stored uniformly distributed fashion accordingly best implemented intermediate node broadcast technique 
basic tools implementing write state 
may implemented state storage scheme type network large small 
node broadcast technique particular suggests class network topologies 
network com puter designers generally free specify interconnection topology design ers larger networks 
remainder discussion applies specifically network computers 
describe class topology mind wd wrap hypercubes wrap refers dimension network connected ring broadcast bus nodes interface network way edge nodes 
linda developed noted network computer dimensional represent ative class 
linked torus square grid row column loops back node nearest neighbors 
describe linda implementation designed 
applicable square grid appropriate simple tions dimension wd wrap hypercube 
node write set row read set column 
executes node kernel executes sending nodes row message reading tuple labelled needed node 
process referred constructing thread 
note deal point simple names 
structured names discussed 
executes node kernel sends nodes column message reading tuple labelled available node process called constructing thread 
thread inter cepts intercepted thread node notification message generated node sent node instructing send tuple 
node tuple delivered accepted acknowledged thread thread removed 

tuple may hand arrive node node 
node tuple accepted thread remains place 
figures 
acm transactions programming languages systems vol 
january 
generative communication linda hread di 
fig 


executes 
executed thread looks thread 
fig 


executes 
executed thread looks thread 
note thread registers data nodes read set just thread write set 
data recorded thread treated persistent state query part network state 
described implementation technique ino optimal equally frequent factor iv 
technique requires thread constructed time executes thread constructed time executes 
overhead con acm transactions programming languages systems vol 
january 
gelernter threads may substantially reduced ways 
node determined tuple needed node associates name address cache sends subsequent tuples directly bypassing thread construction rejects tuple 
scheme analogous runtime conversion logical physical addresses virtual memory system 
related factor decreases thread construction 
discussed part active procedures basic structure linda programs 
active procedures headed state ments execution returns repeatedly 
threads associated statements need repeatedly torn reconstructed may left place long associated procedure block remains invocable 
read statements implemented precisely statements far threads go 
regarding associated threads possibilities 
suppose read executes node executed node execution read cause copy transported leaving original hand original transported case subsequent read find words node origin node case thread remains origin thread torn construct new origin 
clearly second scheme involves greater thread construction head desirable property distributing tuples network sites needed leaving forever creation sites 
node stores collection tuples referenced points network potential bottleneck 
note scheme effect queries updates state increasing thread construction updates relative thread construction queries 
scheme implemented significant imbalance anticipated size read write sets may adjusted described order maintain performance uniform distri bution 
threads described perform simple name matching ensuring tuple delivered statement component matches tuple statement may fact specify structured name arriving tuple fails match fields structured name identically rejected retransmitted candidate statement 
efficient implementation requires propagation just names structured names threads 
structured name propagated list fields tuple match order acceptable statement threads continue propagate simple names 
notification messages generated threads intersect contain copy structured name list associated thread tuple fails match structured name transmitted 
buffering close brief discussion second questions raised start part ii tuples ts stored 
acm transactions programming languages systems vol 
january 
generative communication linda required simulate linda infinite global buffer 
system buffer space expand needed buffer space provided undelivered tuples 
requirements satisfied making allocation buffer space largely function compiler generated code 
allocation buffers arriving tuples principle simple extension allocation activation frames implementation sequential languages 
executes buffer actuals allocated execution stack process executing referred buffer arriving tuple stored buffer match delivery occurred 
outbound tuples stored process heaps maintained compiler generated code removed ts 
header information required communi cation system dealing length tuple logical address basic control characteristics prefixed buffered outgoing tuple compiler generated code 
process terminates undelivered tuples responsibility buffers stored kernel buffers deallocated contents delivered 
processes distributed user job terminated job undelivered tuples may erased tuples names appear save list imported system name space mentioned earlier 
hardware failures semantics linda presence hardware failures implemen tation ts robust way important issues study 
include introductory comments 
reliable message delivery se issue linda linda undertake deliver messages 
works correctly subsequent execution inserted ts 
fails node executed crashes handed safely kernel node 
may subsequently lost destroyed represents failure ts bad status failure exception reported process executed 
similarly fails instance exists ts 
instance exist lost ts failed 
chances inserted safely delivered 
system guarantee delivery promise highly probable delivery 
system reliable delivery critical may implement linda handshake protocols allow reliable communication unreliable channels 
anticipate linda programs 
usable implementation ts failures rare taken account course normal program development sense system failures file crashes take place impede normal program development useful conventional installation 
maintaining ts reliably central issue subproblems remembering tuples remembering tuples selves 
note broadcast scheme remembering tuple whereabouts general substantial redundancy potential basis highly acm transactions programming languages systems vol 
january 
gelernter reliable system 
node scheme stores data whereabouts tuples data identical data stored nodes grid data data stored nodes side 
node fails rebooted restore correct tuple whereabouts state appropriate queries neighbors node threads routed 
general entire row column fail tuple whereabouts data lost 
broadcast scheme redundant respect tuple whereabouts data described values tuples 
stored statement seeks node associated executed 
node fails tuple lost 
currently investigating ramifications scheme equally redundant respect tuples tuple whereabouts tuple added ts broadcast node executing node read set node executing node column grid 
assure atomic character requests directed node executed tuple keeper node authorized satisfy requests request satisfied deleted node read set 
tuple keeper tails node read set may tuple keeper stead 
node read set fail tuple lost 
scheme heavy space communication bandwidth demands network presents complex implementation problems 
hand highly desirable respect reliability major advantages 
increases efficiency read copies tuple available network reading purposes 
second increases efficiency implementing structured names structured name check node read set determine matches need go unique tuple keeper find 

discussed generative communication technique implement ing network computers 
technique developed attractive prop erties relative possibilities demonstrated needless say acceptably efficient absolute terms 
generative communication place unacceptable burdens network communication systems 
evi dence contrary available implementation projects progress advanced 
find linda worth pursuing 
thinking uses plentiful basic resources short haul com munication bandwidth communication processor power contemporary system design fundamental problem 
willing bet mistake long term allow thinking preconceptions implementable 
mistaken optimism examined interesting problems fresh light 
insist dispute claim languages interesting implement 
implementation problems interesting new languages worthy study 
acm transactions programming languages systems vol 
january 
generative communication linda thread addressing packet switched communication kernel support linda implemented part node prototype network computer stony brook 
unsophisticated hardware proved unsatisfactory project quiescent 
linda runs apollo workstation yale uniprocessor implementation test language utility expressivity study runtime behavior distributed programs 
joint project involving yale linda group researchers bell labs linda implemented network computer designed built bell 
results project tell great deal generative communication efficiently 
appendix 
deadlock detection phase locking time uncoupling continuation passing structured names discuss example short fairly simple trivial 
require brief phase locking subject report 
include illustrate way linda encourages simple solutions harder express correspondingly occur languages 
consider set database transaction processes set data locks 
processes set clear locks phase locking protocol 
access graph system directed bipartite graph vi vz 
nodes vi correspond transaction processes nodes locks see kohler 
vi 
edge means transaction currently requesting lock 
means lock currently assigned transaction deadlock exists system iff cycle access graph 
linda solution detects deadlock turning set transaction processes lock processes life size transaction graph 
process acts node graph processes exchange tokens order detect cycles 
solution depends fact time transaction node may incoming edge outgoing edge transaction may locks unfilled lock request outstanding ii lock node may likewise incoming edge outgoing edge transactions may requesting lock transaction owns 
solution works generally follows transactions execute currently owned locks unique currently requested lock 
locks execute currently requesting transactions ou unique current owner transaction 
transaction requests lock sending name manager lock requesting 
waits statement expecting name return 
receives rz ok owns lock may continue 
ok reserved name indicates awarding lock transaction may named ok 
hand receives deadlock system name travelled cyclic path graph acm transactions programming languages systems vol 
january 
gelernter returned node origin 
point corrective action taken concerned receives ok forwards manager unique lock currently requesting statement 
transaction execute acquire lock lock exists deadlock free lock unlock 
lock calling routine returns value just called routine def lock name name name get enter request name lock done boolean false await word var done ok done forward done val value lock value comparison def unlock name free lock manager lock executes lock decl def lock decl free boolean true name declarations request queue frames type name def name get requestor name accept lock request name free award lock requestor owner requestor free false ok prepare notify new owner add requestor request queue pass blocked requestor name current owner requestor owner def lock forward name forward name owner acm transactions programming languages systems vol 
january 
def lock dequeue name free head name request queue empty free true head head request queue head ok notify new owner owner head delete request queue head example illustrates properties 
generative communication linda time uncoupling 
lock forward may execute owner ascertaining owner 
statement executed 
continuation passing 
continuation passing extended example chain length bounded number nodes transaction graph 
structured naming 
structured names allow family names get forward free generated 
languages surveyed allows generation multiple related names linda sense 
acknowledgments professor arthur bernstein directed thesis linda described referees particularly useful lucid comments 
mauricio central linda implementa tion project stony brook 
enthusiasm expertise described accomplished 
nick carrier plays similarly pivotal role implementation yale 
suresh todd morgan stony brook brian weston yale 
technical assistance jane backus contribution decisive 

andrews synchronizing resources 
acm trans 
program 
lung 
syst 
oct 

brinch hansen programming language concurrent pascal 
ieee trans 
softw 
eng 
se june 

brinch hansen distributed processes concurrent programming concept 
commun 
acm nov 

cook mod language distributed programming 
proceedings st international conference distributed computing systems oct 

experience multiprocessor algorithms 
ieee trans 
comput 
apr 

dept defense 
manual ada programming language 
july 

eswaran gray lorie traiger notions consistency predicate locks database system 
commun 
acm nov 

erman report rd annual workshop distributed artificial intelligence 
acm 
apr 

feldman high level programming distributed computing 
commun 
acm june 
acm transactions programming languages systems vol 
january 
gelernter 
finkel solomon distributed operating system 
tech 
rep univ wisconsin madison computer science dept july 

gelernter bernstein distributed communication global buffer 
proceed ings acm symposium principles distributed computing aug 

gelernter integrated microcomputer network experiments distributed program ming 
ph dissertation suny stony brook dept computer science oct 

gelernter distributed programming language 
tech 
rep yale univ dept computer science aug 

gelernter note systems programming concurrent prolog 
proceedings international symposium programming feb 

gelernter symmetric programming languages 
tech 
rep yale univ dept computer science july 

gel nter global name spaces network computers 
proceedings international conference parallel processing aug 

hoare communicating sequential processes 
commun 
acm aug 

rationale design ada programming language 

part june 

kahn semantics simple language parallel processing 
proceedings congress 


kernighan ritchie programming language 
prentice hall englewood cliffs 

kieburtz comments communicating sequential processes 
acm trans 
program 
lang 
syst 
oct 

kohler overview synchronization recovery problems distributed databases 
proceedings fall compcon 

liskov primitives distributed computing 
proceedings th symposium operating system principles dec 

schneider synchronization distributed programs 
acm trans 
program 
lang 
syst 
apr 

worm program early experience distributed computa tion 
commun 
acm mar 

warren pereira prolog language implementation compared lisp 
proceedings acm symposium artificial intelligence programming languages aug 

wirth modula language modular multiprogramming 
softw 
pratt 
exper 

received april revised july accepted july acm transactions programming languages systems vol 
january 
