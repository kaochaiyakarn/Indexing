originally published proceedings usenix annual technical conference new orleans louisiana june dynamic classes lightweight mechanism update code running program sli hj lmt labs research robert gray dartmouth college information usenix association contact 
phone 
fax 
email office usenix org 
www url www usenix org dynamic classes lightweight mechanism update code running program techniques dynamically adding new code running program exist various operating systems programming languages runtime environments 
systems way common require programmer retraining invalidate previous software investments 
addition systems high level performance critical applications 
presents implementation dynamic classes language 
dynamic classes allow run time updates executing program class level 
implementation lightweight proxy class exploits common features compiled modern compilers 
proxy supports version updates existing classes new classes 
language choice proxy implementation targeted performance critical applications low level networking widespread 

sli hj lmt labs research park avenue florham park nj research att com modern organization software systems critical mission operate continuously 
network provider example loses revenue customer switches service controllers temporarily unavailable 
need continuous operation planned downtime hard schedule unplanned downtime effects 
new service security threat changes unavoidable changes designed minimize downtime reducing system maintenance patching 
patching breaks program data abstractions encapsulation reduces modularity increases coupling 
time ignoring needed maintenance development leads outdated system eventually obstacle organizational development 
complicating situation network computing robert gray thayer school engineering dartmouth college hanover nh cs dartmouth edu transformed industries continuous change just important continuous operation 
rapid new functionality dynamic adaptation volatile needs essential 
systems particularly telecommunications systems customized fine time scale due user demand load usage fluctuations 
effective way allow continuous operation continuous change dynamic code updates 
new code added running program halting program introducing new functionality avoiding downtime 
idea adding new code running program dates back earliest electronic computers dynamic linking available nearly operating systems programming languages 
languages directly support creation dynamically loadable modules preserving program level abstractions dynamic linking interface difficult 
particular current dynamic linkers break type safety oriented functions types classes 
new environments languages designed dynamically download execute programs 
particular java extremely popular widespread 
java class loader lazily load classes application knowledge class versions load class 
addition relatively poor performance java impractical low level applications 
propose dynamic classes 
dynamic classes allow new functionality introduced exe done labs research 
recognize type secure programmer break type abstraction explicit casts 
current dynamic linkers break type abstractions programmer perform explicit casting 
program sacrificing type safety performance object oriented paradigm 
replacing entire class individual functions honors semantic integrity program minimizes interference update ongoing computation 
comparable techniques exist interpreted languages agent environments objective mechanisms telecommunication systems performance primary concern 
outline proxy implementation requires existing features language usable complete compiler 
section presents related 
section introduces dynamic classes 
section describes proxy implementation 
section examines system performance 
section presents applications dynamic classes 
sections consider 
appendix contains proxy class 
discussed section 
related idea adding new code running program dates back earliest electronic computers structured approach rudimentary dynamic linking multics system 
form dynamic linking way wide range programming languages distributed computing environments kernels 
targeting language consider various ways add code executing program examine approaches languages environments 
incremental linking runtime linking code available compile time linker achieves lazy loading code avoids resource allocation code segments 
conceptually incremental linking identical traditional compile time linking 
dynamic linking runtime linking code available compile time linker truly supports new functionality running program 
language directly support creation dynamically loadable modules making difficult preserve program level abstractions dynamic interface 
particular current dynamic linkers break type safety oriented functions classes 
example create instance previously unknown derived class program search shared library desired constructor tedious interface systems cast resulting function pointer constructor type 
addition dynamic linkers allow previously loaded code module replaced call module tedious interface 
dynamic linker allows relinking described support replacing module having multiple versions module coexist program 
dorward extend dynamic linking preserves type safety works class level 
solution allows new derived class known base class dynamically loaded program 
shared library contains implementation new class dynamically linked program 
standard factory mechanism call library create instance new class preprocessor automatically generates necessary factory routines 
instance cast type base class instance base class expected 
calls base class type checked statically base class constrains derived class function signatures type safety preserved program invoking operations derived class 
implementation uses mechanism achieve type safety extends dorward implementation allowing replacement previously loaded class new version allowing multiple versions class coexist program 
words implementation adds versioning 
techniques hamilton goldstein sloan allow multiple versions class coexist program :10.1.1.40.1741
hamilton approach program recompiled take advantage new version stopped restarted 
goldstein sloan hand allow new version dynamically added running program solution meant distributed systems programs communicate passing objects 
libraries programs upgraded different times program receive object contain corresponding library version 
happens program dynamically loads appropriate library version directs accesses received object library 
solution intended completely transparent provide application level control active version extended provide control 
addition solution requires nontrivial compiler support allow instance old class version passed code compiled newer class version 
languages environments java particular interest due widespread popularity availability 
java object oriented language syntactically similar 
java program classes 
load class java virtual machine program startup class loader dynamically loads class time 
built class loader knowledge class versions load class possible write custom class loader took versioning account 
custom class loader need help java interfaces cleanly separate interface implementation preprocessor enforce version naming scheme proxy class 
java simply provide sufficient performance low level applications interest 
worthwhile reconsider java effective just time compilation brings performance closer 
java attractive choice target applications dynamic class mechanism reimplemented java 
limbo language part inferno system lucent technologies intended type distributed applications java 
limbo program consists modules 
module consists public interface private implementation 
public interface include functions variables data types constants 
modules dynamically loaded unloaded reloaded runtime 
versioning support need added higher level dynamic loading capability play large role dynamic class implementation limbo 
java limbo widespread applications question provide desired performance 
languages eiffel lisp perl python scheme smalltalk standard ml tcl support form dynamic linking loading 
depending language dynamic update small single procedure single class single compilation unit 
unfortunately languages interpreted inefficient performance critical systems 
directly provide necessary versioning support 
importantly widespread application environment 
agent environments include mo bile code systems cooperative processes intelligent interfaces allow dynamic removal individual process entities agents :10.1.1.40.1741
little support replacing existing agent preserving ongoing agent conversations 
addition agent systems interpreted languages efficient low level processing 
due communication overhead current agent systems application implemented large agents small agents 
large agents coarse replacement unit applications 
distributed programming systems corba argus allow dynamic removal individual processing entities 
corba entity single process 
argus entity collection objects processes called guardian 
systems provide limited support replacement 
agent case process guardian coarse replacement unit applications particularly guardian unavailable replacement process ongoing conversations blocked 
bloom notable contribution analyzing safe replace implementation guardian analysis applied directly dynamic classes 
microsoft component object model com allows programmer define components interface separate implementation 
implementation changes existing components continue old implementation new components new implementation 
approach quite close approach dynamic classes 
addition com efficient components class level 
hand com additional features need longer learning curve simple proxy widely non windows applications 
java com worth revisiting evolves 

dynamic classes dynamic class class implementation dynamically changed program execution allowing new functionality class level 
course main program able communicate invoke methods new im see dynamic classes implement agent replacement systems agent replacement sufficient 
plementation 
implementation interface known main program compile time 
new implementation updates existing class new version introduces new class new type uses known interface 
version update semantics basic problem updating existing dynamic class existing objects 
approaches shown 
approach raise barrier blocking object creation existing objects older versions expired 
new version takes object creation resumes 
approach conceptually equivalent halting modifying restarting system 
approach recreate existing objects new version 
approach retains crucial property raising barrier time objects particular class version 
hand different class versions different internal data structures copying object state requires understanding object semantics 
approach take action 
new objects created new version existing objects continue current versions 
existing objects finish tasks destroyed new version 
adopt solution basic sufficient cases considered implemented efficiently 
include method object determine version version allowing programmer explicitly migrate objects particular class 
programmer need write state capture restoration routines class version 
routines produce accept version independent representations object state 
interface semantics allow hot updates interface monitor screens message passes dynamic class interfaces 
monitor conceptually class proxy 
dynamic class monitor maintains map associates class name current implementation version location external storage 
dynamic class invalid running program contain implementation version class 
dynamic classes start invalid 
message sent invalid class monitor locates version barrier version version version version version approaches version updating loads current implementation version updating internal map needed 
monitor passes message newly loaded version 
interface monitor provides methods manipulate current version activate invalidate activate invalidate 
activate method registers new version current version 
objects older versions remain existence 
old objects expired normally older versions removed system 
activate invalidate method registers new version current version invalidates destroys objects older versions 
conversations objects engaged broken 
surviving participants recover retry 
invalidate method invalidates destroys objects version 
invalidating current version error 
semantics methods maintain invariant dynamic class unique current version 

implementation design goals implementation dynamic classes efficiently find invoke correct version method hide dynamic class mechanism possible programmer standard features 
implementation require special preprocessor compiler support depend compiler specific details 
design goals led proxy classes 
section proxy class implementation discuss tradeoffs involved 
term conversation sequence message exchanges method invocations objects 
implementation objects dynamic invalidated object receive exception attempts invoke invalidated object methods 
object perform application specific recovery constructing new object class invalidated 
clearly programmer think carefully invalidation 
core implementation generic template class 
template shown appendix uses standard features compiled complete compiler 
template serves proxy smart pointer dynamic class 
proxy program creates dynamic class instance creating proxy instance 
dynamic class written separate parts interface class known program compile time implementation classes inherit interface class 
implementation class version dynamic class 
interface class specifies public operations remain constant versions dynamic class 
operations defined pure virtual functions derived implementation class forced provide 
addition implementation class additional methods data members needs perform task operations defined interface class called program modules 
sense program module dependent particular version dynamic class 
implementation class compiled separate shared library 
dynamic class template instantiated interface class 
run time template locates shared library contains implementation class loads library program address space 
template calls library create instance implementation class casts instance type interface class 
public interface operations accessed template standard pointer redirection 
template provides static methods implement active invalidate activate invalidate 
software systems provide external interface administrator developer automated management tool invoke methods 
example consider dynamic class job receive packets sent network connection 
simplicity dynamic class interface provides single operation 
class receiver public virtual packet void programmer write implementation classes normal production version discovery unexpected problem debugging version contains new debugging code 
class public receiver public packet void class public receiver public packet void implementation classes compiled shared library say imp respectively 
dynamic class straightforward dynamic name proxy template shown appendix 
normal program operation create normal packet receivers dynamic receiver activate imp dynamic receiver receiver packet packet receiver switch debugging mode response external event library name included external event dynamic receiver activate new packet receivers contain debugging code dynamic receiver new debugging functionality introduced stopping running program 
addition bug identified developer create third version receiver contains necessary fix 
fixed version activated stopping running programming 
course intend suggest bugs fixed stopping program bugs 
example receiver simply particular kind packet 
implementation details construction invocation 
multiple versions dynamic class program multiple implementations method program address space 
correct implementation called method invoked particular object 
problem method invocation version dependent resolved compile time compiler oblivious versioning access interface class 
solution level indirect method resolution runtime 
level version dependent mapping implement inside dynamic class proxy second level method mapping version achieve standard virtual methods associated 
approach version object remains unchanged lifetime object 
version mapping resolved object creation stored instance proxy 
fact object created needed mapping just single pointer new object object pointer appears template definition appendix 
method mapping achieved defining methods interface class virtual 
adds vtable derived implementation class resolves method calls 
illustrates level mapping 
proxy contains pointer object object contains pointer vtable vtable contains pointers methods object implementation version 
vtable invoking constructor problem construct object remains 
implementation class constructors possibly different size normal constructor syntax 
standard factory pattern require class version provide static method proxy calls constructor 
side effect approach dynamic class essentially constructor chooses invoke 
additional initialization done methods 
external map 
version dynamic class compiled shared library 
runtime activate activate invalidate methods able locate correct library symbolic name desired class version 
ways accomplish mapping easiest approach programmer simply library name path symbolic name 
methods search known library directories library 
course library name need known program compile time passed program runtime version update process 
extended proxy symbolic name arbitrary url support network applications web technology storage dynamic class libraries 
url refers library local machine library immediately loaded program address space 
url refers library remote machine library downloaded local machine 
description network support scope 
relevant issues include caching libraries local machine handling different machine architectures library directories specified platform dependent 
unix machines library directories listed environment variable ld library path 
proxy object table vars mn mn program code method invocation checking security credentials downloader imposing consistent meaningful naming scheme 
template versions 
dynamic class system provides versions proxy template 
version restricted functionality high performance full functionality slightly lower performance third falls functionality performance 
full functionality version allows different dynamic classes share interface class allows new dynamic classes system 
example programmer write interface class write dynamic classes interface 
multiple versions 
version template provides mappings 
dynamic class list class versions currently inside program interface class table associates dynamic class name correct version list 
full functionality version template shown appendix 
note activate invalidate activate invalidate take parameters name dynamic class name library contains desired version class 
note activate activate invalidate return unique handle dynamic class passed template constructor identify desired dynamic class 
handles constructor faster looking handle efficient looking class name 
medium functionality template requires dy namic class interface class supports version updates 
template maintains version list dynamic class eliminates class name version list mapping avoiding string lookup activate invalidate activate invalidate methods handle lookup constructor 
template methods take library name parameter constructor takes arguments 
class name needed invoke constructor obtained special function shared library static function returns class name const char 
medium functionality template commonly template 
performance discussed section 
low functionality template support invalidate activate invalidate methods 
new versions introduced old versions invalidated 
version remains valid long objects version exist redirection operator need check invalid versions 
importantly redirection operator longer throws exceptions allows compilers inline operator eliminate function call 
things method invocation faster seen section 
versions template freely program 
implementation tradeoffs chose proxy approach ability standard development environments primary design goal 
willing sacrifice goal implementation choices notably custom preprocessor 
sufficiently complex preprocessor dynamic classes look normal classes multiple constructors dynamic class method access selection 
just provide better performance 
careful analysis tradeoffs indicates preprocessor advantages great appear justify additional complexity development time 
performance 
proxy approach involves overheads 
proxy constructor find invoke correct factory method 
factory method invokes real constructor 
second method accesses go proxy dereference operator involves extra function call absence inlining boolean comparison verify class version invalidated 
custom preprocessor support eliminate entire overhead mapping object version eliminate levels indirection 
worth considering typical dynamic class finest grained class system 
programmer need dynamic point class point simply coordinate dimensional space 
programmer need dynamic renderer class draws set points 
methods renderer significant processing extra time needed just invoke methods insignificant 
expectation dynamic classes fall category renderer perform nontrivial processing methods 
application far confirms view 
reason feel performance issues minor justify custom preprocessor compiler support 
expectations wrong programmers start featherweight classes dynamic need re examine proxy approach 
say performance section 
technique involve custom support re map vtable associated particular dynamic class version response certain events 
example invalidate operation entry vtable point dummy method throws exception 
dereference operator need check class version valid 
proxy necessary proxy provides additional functionality scenes 
example proxy maintains count objects particular version version code removed program address space soon objects destroyed 
proxy necessary working introduce compiler dependencies performance penalties re mapping small believe vtable re mapping provide sufficient benefits worthwhile 
abstraction hiding 
proxy approach means program programmer explicitly know dynamic classes level 
addition proxy approach prevents usage standard constructs 
notably dynamic class single constructor method access take place dereference operator 
proxy implementation allows programmer obtain direct embedded object atypical dereference operator 
programmer access removal occurs version longer active version 
passing dynamic class fine method access involves dereference operator 
object going proxy class 
preprocessor compiler support address problems 
simple programming task write wrapper class contains embedded instance dynamic class proxy 
wrapper class hide existence proxy rest program provide multiple constructors support normal access syntax prevent client code obtaining direct actual versioned object 
example wrapper receiver class assuming interface extended initialize method 
class private dynamic receiver receiver public void receiver new dynamic receiver int receiver new dynamic receiver receiver initialize packet void return receiver wrapper class looks normal class rest program 
exception program module accepts versioning instructions external sources passes instructions appropriate proxies 
ease wrapper classes written felt custom preprocessor compiler support justified 
course fact wrapper class written mean written 
programmer free bypass proxy methods breaking dynamic class abstraction 
hard imagine programmer accidentally programmer done accidentally far 
content provide flexible mechanism enforcing usage requirements 
similar vein existing programs dynamic classes modification 
large software system modifications confined particular subsystem hidden appropriate class 
addition difficult imagine existing program dynamic class implementation modification 
preprocessor compiler essentially classes dynamic add syntactic markup recompile 
behavior static methods interface currently undefined 
mainly implementation detail 
static methods compiled main program shared libraries 
static method invocations directed code want methods sense perform version independent processing 
compiling static methods main program require special support preprocessor support help programmer avoid mistakes 
inheritance 
proxy approach complicates inheritance ways 
proxy approach demands clean separation interface implementation class simply interface implementation separate classes 
unfortunately clean separation seen existing programs 
hand dynamic class implementation require separation dynamic class version independent interface 
client code quickly dependent particular versions 
second proxy restricts dynamic classes inherited 
general interface classes inherit interface classes implementation class inherits implementation classes normal class wants extend functionality dynamic class contains instance appropriate proxy 
preprocessor compiler support certainly relax strict separation 
light issues questionable relaxation allowed 
imagine example dynamic class inherits particular version dynamic class 
system constructs instance subclass identify correct version superclass superclass superclass 
programmers keep resulting dependencies straight inheritance effect achieved cleanly easily separate interface implementation hierarchies complex compiler preprocessor support 
third proxy undesirable consequences interface polymorphism 
interface inherits proxy class instantiated derived interface related proxy class instantiated base interface 
contrary intent interface inheritance proxy derived interface proxy base interface expected 
solution provide template function performs explicit cast template function succeeds compile time respective interfaces related inheritance 
solution sufficient simple preprocessor support useful 
full implementation superclasses compiled library dynamic class version ensure superclass resolved correctly compile time 
means superclass code appear multiple libraries simplifies implementation significantly involves minimal extra programmer 
preprocessor support useful 
summary 
contrast preprocessor compiler approach proxy solution simpler lower performance fully hide dynamic class abstraction restricts inheritance 
performance penalty small relative processing dynamic classes performing proxy hidden completely straightforward wrapper class implementation restrict inheritance inheritance remains understandable 

performance evaluation time complexity ran tests measuring time construct destroy object class data elements constructor arguments measuring time invoke object method method arguments return value 
test involved cases standard stack allocated class virtual methods standard heap allocated class virtual methods dynamic class created template 
considered case dynamic class involves virtual functions heap allocation 
test compiled sgi compiler performed times run runs sgi indy 
constructor empty construction overhead dynamic classes versus class versus stack allocated class 
constructor zeroes byte block static memory overheads drop respectively 
multi threaded environment time acquire lock prevent corruption version lists dominates construction process overheads increase empty nonempty constructor versus heap allocated class versus stack allocated class 
method empty invocation overhead dynamic classes versus heap allocated class versus stack allocated class 
method defines local variables increments value variables performs integer comparisons evaluate false overheads drop respectively 
addition invalidation required low functionality tem plate medium functionality template 
low functionality template better performance redirection operator throw exception inlined compiler 
template overheads empty non empty method versus heap allocated class versus stack allocated class 
performance penalty making existing class dynamic high methods nearly empty 
penalty quite low methods nontrivial processing 
dynamic class implementation appropriate low level class point point computationally trivial method little single assignment small allocate stack 
addition points system created destroyed constantly leading severe performance penalty proxy constructor takes longer simple point constructor 
dynamic class implementation appropriate higher level classes renderer especially class objects allocated heap anyway created destroyed infrequently nontrivial processing constructors methods 
discussed expect dynamic classes high level classes anyway 
implementation provides excellent performance classes 
applications implemented example dynamic class methods far processing test cases section overheads insignificant 
space complexity space requirements dynamic classes low 
class proxy maintains version list pointer active version search list construction synchronization lock multi threaded environment 
version list entry version 
entry contains associated class library names flag indicates version active version count number objects version 
object proxy maintains pointers actual object object version information inside version list 
addition dynamic class virtual functions actual implementation object pointer appropriate vtable 
object space overhead dynamic classes pointers including vtable pointer dy compilers inline method throw exception 
namic classes overhead acceptable 
point class overhead probably unacceptable pointers take space point actual data 
renderer class overhead probably acceptable 
applications discuss pointers total object size 

applications main motivation network control service management applications demand high performance operate continuously 
dynamic classes applications mobile agents demand connection management 
application building block control ondemand application demonstrates viability native code heterogeneous environment 
control demand application uses agents inject application specific control policies router 
connection management application uses dynamic classes inject handlers new connection types running connection manager 
mobile agents mobile agent executing program migrate times choosing machine machine heterogeneous network 
mobile agents attracting growing attention means easily realize complex distributed applications prototype applications 
implemented efficient mobile agent system top mechanism 
agent version dynamic class 
interface class defines operations common agents notably migrate run 
dynamic classes interface class implements migrate operation 
agent implements 
dynamic classes agent compiled shared library 
mobile agent starts executing bootstrap program loads agent class mechanism calls run method 
run method performs agent task 
run method decides agent migrate machine calls migrate method 
migrate method calls method package agent current state transmits state image url agent shared library server target machine 
server downloads shared library loads agent dynamic class mechanism calls method restore agent state fi nally calls run method 
run method continues agent task checking agent current state decide 
control demand control demand flow oriented active networking 
applications inject customized control policies flow network routers 
policies exploit strategic positioning local network knowledge application semantics improve performance perceived quality flow 
may act control plane data plane 
supports connectivity control floor management teleconference advanced group management multicast 
applications include stream thinning branch point multicast discarding important packets congestion discarding frames protect frames mpeg stream monitoring packet loss retransmitting lost packets inside network 
shows control demand network node 
major parts forwarding engine meta control interface forwarding engine data path controllers separated opaque interface 
meta controller accepts installs runs new controllers demand dynamic classes way mobile agents 
service connection management control demand node supporting control demand experiment dynamic classes applications built prototype connection manager 
transmitting application issues connection request connection manager 
manager creates connection instance performing admission control book keeping process 
disconnect instance destroyed resources allocated connection released 
connection active instance responsible ensuring service quality 
different machine architectures shared library agent pre compiled machine architectures find 
machine inserts architecture name url downloading library 
naming scheme issues security fault tolerance scope 
static part connection manager main program recognizes general interface connection objects 
type specific implementations interface introduced dynamically version dynamic classes 
depicts hierarchy connection types dynamically constructed execution connection manager 
manager event processor handles events form connection type name data initial state code url 
connection type known code introduced new type 
type known code changed code introduced new implementation version 
case new code retrieved installed dynamic class mechanism 

area add security mechanisms dynamic class implementation program verify origin dynamic classes instructed load 
second area handle case dynamic classes undergo version update atomic unit 
potential solutions include simple transaction mechanism constraint definition language new versions loaded time active constraints met 
working groups identify additional applications dynamic classes 
plan provide dynamic class implementation java 
java unsuited low level control software implement higherlevel components telecommunications systems 

dynamic classes provide powerful support maintenance extension mission critical long running applications 
new implementations class dynamically added removed running program eliminating need bring program fixing bugs enhancing performance extending functionality 
implementation discussed provides easy library language 
implementation preserves type safety class abstraction 
require special compiler support efficient low level software 
dynamic classes application part larger effort 
experience dynamic classes efficient easy sufficient tasks 

availability dynamic class implementation available irix solaris windows nt 
known compile irix release compiler solaris release sun compiler windows nt release microsoft compiler 
porting platform simple long platform compiler exception template support facilities comparable irix 
interested readers contact second author 

acknowledgments anonymous reviewers shepherd benjamin zorn excellent feedback programmers put implementation 
appendix connection phone ip ip phone ip atm bitstream ipv cbr ubr hierarchy connection types code simplified version full functionality template 
discussed template allows different dynamic classes share interface class 
templates support version updates achieve higher performance eliminating table lookup 
template methods throw exceptions error 
typedef list typedef int handle template class class dynamic actual object version information class handle object handle public constructors dynamic handle handle dynamic const dynamic proxy dynamic dynamic operator const dynamic proxy smart pointer operator void activate version static handle activate const char const char classname null invalidate version static void invalidate const char handle handle activate invalidate static handle activate invalidate const char const char classname null private static data shared versions classes implementing interface 
map handles version list static 
map handles active version static overview multics system proceedings afips fall join computer conference pp 

lee dang weeks 
shared libraries sunos proceedings usenix summer conference pp 

james peter kessler cross address space dynamic linking technical report tr sun microsystems laboratories mountain view california 
wilson ho ronald olsson 
approach genuine dynamic linking software practice experience volume number april pp 

donn 
shared libraries objects 
usenix summer conference proceedings pp 

march 
issues shared library design usenix summer conference proceedings pp 

michael franz 
dynamic linking software components ieee computer volume number march pp 

sean dorward ravi sethi jonathan 
adding new code running program proceedings usenix conference pages 
java language white sun microsystems white sun microsystems 
inferno la lucent technologies white lucent technologies 
mary kathy 
java tutorial object oriented programming internet addison wesley 
bjarne stroustrup 
programming language rd edition addison wesley 
goguen incremental loading subroutines runtime technical report bell laboratories murray hill new jersey 
quong design implementation incremental linker technical report csl tr computer systems laboratory stanford university 
david keppel stephen russell 
faster dynamic linking sparc system technical report university washington 
erich gamma richard helm ralph johnson john vlissides 
design patterns elements reusable object oriented software 
addison wesley reading massachusetts 
hamilton :10.1.1.40.1741
interface inheritance address problems system software evolution proceedings acm workshop interface definition languages 
theodore goldstein alan sloane 
object binary interface objects evolvable shared class libraries technical report tr sun microsystems laboratories mountain view california 
mark lutz 
programming python 
reilly 
goldberg 
smalltalk interactive programming environment 
addison wesley reading massachusetts 
john ousterhout 
tcl tk toolkit 
addison wesley reading massachusetts 
james white 
telescript technology foundation electronic marketplace general magic white general magic 
robert gray 
agent tcl flexible secure mobile agent system mark mark roseman editors proceedings th annual tcl tk workshop monterey california july 
michael genesereth steven ketchpel 
software agents communications acm july pages 
lashkari max metral pattie maes 
collaborative interface agents proceedings aaai jon siegel corba fundamentals programming wiley 
isbn 
toby bloom 
dynamic module replacement distributed system ph thesis laboratory computer science massachusetts institute technology 
component object model com technical overview microsoft white microsoft 
sli hj lmt bhattacharjee 
control demand customizing control application technical memorandum 
