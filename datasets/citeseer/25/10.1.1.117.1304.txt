typeful programming luca cardelli digital equipment systems research center lytton avenue palo alto ca exists identifiable programming style widespread type information handled mechanical typechecking techniques 
typeful programming style sense independent language embedded adapts equally functional imperative object oriented algebraic programming incompatible relational concurrent programming 
main purpose show typeful programming best supported sophisticated type systems systems help clarifying programming issues adding power regularity languages 
start notions types subtypes polymorphism 
introduce general framework derived part constructive logic known type systems accommodated extended 
main part shows framework adapted systematically cope actual programming constructs 
concreteness describe particular programming language advanced features emphasis combination subtyping polymorphism 
discuss typing concepts apply large programs collections modules large programs collections large programs 
sketch typing applies system programming area nature escapes rigid typing 
summary compare common programming styles suggesting compatible benefit typeful discipline 
appears formal description programming concepts neuhold paul eds springer verlag 
src research report may 
revised january 
digital equipment 
may copied reproduced part commercial purpose 
permission copy part payment fee granted nonprofit educational research purposes provided partial copies include notice copying permission systems research center digital equipment palo alto california acknowledgment authors individuals contributors applicable portions copyright notice 
copying reproducing republishing purpose shall require license payment fee systems research center 
rights reserved 
page contents 

record variant types 
typeful languages 
higher order subtypes 
relevant concepts 
bounded universal quantifiers 
theory practice 
bounded existential quantifiers 
types 

auto subtypes 
subtypes 

mutable subtypes 
polymorphism 

recursive subtypes 
quantifiers subtypes 
large programs 
kinds types values 
interfaces modules 
signatures bindings 
manifest types kinds 
quest language 
diamond import 
kind types 
huge programs 

open systems 
basic built types 
closed systems 
function types 
sealed systems 
tuple types 
system programs 
option types 
dynamic types 
auto types 
stack allocation 
recursive types 
type violations 
mutable types 

exception types 
style 
operator kinds 
styles 
type operators 
acknowledgments 
recursive type operators 
appendix 
power kinds 
syntax 
tuple subtypes 
type rules 
option subtypes 
library interfaces 
exists identifiable programming style widespread type information relies mechanical transparent typechecking techniques handle information 
typeful programming style sense independent language embedded adapts equally functional imperative object oriented algebraic programming incompatible relational concurrent programming 
sense discuss programming style way relatively independent particular flow control paradigms ones just mentioned 
see precisely typeful programming 
widespread type information intended partial specification program 
sense say typeful programming just special case program specification read type synonym specification typechecking synonym verification discussion 
view fits types propositions paradigm axiomatic semantics propositions types paradigm intuitionistic logic 
typeful programming distinct program specification fundamental ways 
noted mechanical way verifying type constraints respected programs 
slogan laws enforceable unchecked constraining information useful documentation purposes relied hard keep consistent large software systems 
general systems exhibit constraints actively enforced earliest possible moment 
case typechecking earliest moment compile time checks may deferred run time 
contrast specifications typechecked deferred run time require general verifying property constant function 
emphasis transparent typing 
easy programmer predict reliably programs going typecheck 
words program fails typecheck reason apparent 
automatic program verification may hard general understand program failed verify current state art may need deep understanding inner workings verifier order correct problem 
scope typeful programming defined limited 
typechecking merge program verification requires mechanical checking undecidable 
may attempt reduce gap hand integrating specifications extensions type systems hand increasing sophistication type systems 
intend show road lead quite far expressing program characteristics 
scope typeful programming major limitation required programs completely statically typed 
statically typed language turing complete able express type embedded eval function important areas just symptom similar problems occurring compiler bootstrapping handling persistent data interesting ways statically checked languages extended cover eval functions similar situations 
flavor typeful programming preserved extensions involve run time type checks dynamic checks relationship corresponding static checks 
typeful programming advocates static typing possible dynamic typing necessary strict techniques leads strong typing intended absence unchecked run time type errors 
main purpose show typeful programming best supported sophisticated type systems systems help clarifying programming issues adding power regularity languages 
minor extent purpose motivate typing programming done subsections fact take granted benefits simple type systems 
page go explaining justifying sophisticated type systems 
expository approach involve listing comparing different language design problems solutions led increasingly powerful notions typing 
approach may produce fragmented description field reveal information gathered language manuals survey articles 
comparisons existing languages may help designing new languages may equally easily help existing design deficiencies 
expository approach rigorously describe formal system underlying powerful forms typeful programming 
fact systems fifteen years partial impact programming 
ideas rediscovered different contexts translated languages order understandable general computer science audience 
problem easy extract practical languages formal systems 
formal expositions tend highlight hard theoretical properties small formalisms engineering properties large languages interacting features 
approach take consists underlining basic concepts concrete context single programming language 
advances semantics type theory revealed hidden unity features practical languages features constitute special cases restricted versions engineering compromises combinations misunderstandings fundamental notions 
example language attempts cover integrate features typeful languages providing direct mapping basic concepts 
inevitably common notions left exposition particular language style syntax 
hopefully readers see thin disguise basic concepts easily formal system series existing languages 
start general typeful languages switch single concrete language 
central part form language manual motivating examples 
final sections return general look properties uses typeful languages 

typeful languages section discuss properties typeful languages justify type systems software methodology point view 

relevant concepts shall try cover unified type theoretical framework number concepts emerged various programming languages 
emphasis language constructs developed writing large structured programs 
higher order functions functions take return functions important structuring tool help abstracting program behavior enhancing abstraction power ordinary functions 
common languages severely limited 
languages prevent declared functions languages forbid returned functions 
higher order functions form essence calculus barendregt 
programming language define correctly iswim landin today major language implement correctly standard ml milner 
weaker forms considered essential structuring tool areas system programming operating systems 
types come desire hide irrelevant program information protect internal program invariants unwanted external intervention 
type ordinary type set operations structure type hidden provided operations ones authorized manipulate objects type 
notion embedded clu liskov liskov guttag formed basis page development modular programming languages 
notion abstraction restrictive general notion algebraic types futatsugi goguen jouannaud meseguer 
polymorphism ability function handle objects types strachey 
ad hoc polymorphism function behave arbitrarily different ways objects different types 
shall ignore view consider generic polymorphism function behaves uniform way relevant types 
forms generic polymorphism parametric polymorphism uniform behavior embodied type parameter subtype polymorphism uniform behavior embodied subtype hierarchy 
prototypical language parametric polymorphism ml mechanisms adopt closely related russell demers donahue pebble burstall lampson 
notion subtype polymorphism consider appeared simula dahl nygaard single inheritance closely related amber cardelli multiple inheritance 
major aim unify parametric subtype polymorphism single type system 
subtyping relation types similar relation containment sets 
subtype object type object type words object properties object statement close definition inheritance object oriented languages inheritance strictly related behavior typing 
subtyping record types emulate properties inheritance subtyping notion applies types involve built notion methods 
modules interfaces introduced mesa mitchell maybury sweet perfected modula wirth 
standard ml embodies today advanced module system 
modules major structuring concept functions modern languages 
similar types add notion imported identifiers declared interfaces evading strict block structure statically scoped languages 
interfaces contain names types operations defined module names types 
modules interfaces self contained units refer external identifiers interfaces units compilation 

theory practice conceptual framework typeful programming various theories typed calculi reynolds martin particular inspired girard system girard theory constructions coquand huet hyland pitts 
collection theories generically referred type theory studies expressive type structures framework constructive logic 
theoretical structures direct correspondence programming constructs accidental computing seen branch constructive logic 
similar identical type structures programming constructs discovered independently 
extrapolate correspondence turn predictive tool concept type theory absent programming vice versa fruitful areas investigate see corresponding concept context 
theoretical understanding greatly contribute precision simplicity language constructs 
programming language just formal system 
practical considerations factored design language perfect compromise theory practice rarely achieved 
theorists want nice properties 
engineers want useful build systems time 
language nice properties useful easy build systems time 
list practical considerations enter mind language designer 
enforcement considerations may cause practical languages theoretical background 
page notation 
notation important help express meaning program hide cryptic symbols useless clutter 
notation easy read look time spent reading programs writing 
distant second notation easy write notation harder read order easier write environment tools writing convenient 
large programs easy read human easy parse computer vice versa lisp 
scale 
worry organization large programs terms notation terms language constructs 
large programs important small programs small programs examples 
programs go unused large programs 
important scale considerations reuse parts large program easily extend large program having modify 
surprisingly common mistake consists designing languages assumption small programs written example languages function parameters proper notions scoping modules type systems 
widely languages eventually suffer conceptual collapses weight ad hoc extensions 
typechecking 
language typable typechecking feasible 
addition typechecking relatively efficient errors easy understand 
possible typechecking decidable predictable heuristics exist 
translation machine language 
possible languages interpreted 
translation process relatively efficient produced code simple relationship source program 
efficiency 
translated code efficient avoid language constructs hard implement efficiently require excessive cleverness part compiler 
clever optimizations rarely implemented don compose easily 
generality 
useful language called real language able support building wide variety systems 
theoretically complete practically complete 
condition expressed turing completeness ability language express computable function 
condition harder quantify criteria language real 
practical completeness ability language conveniently express interpreter translator run time support garbage collector operating system 
course classification subjective case person claiming classification system willing personal resulting system 
language describe falls mainly category shall discuss extend category 

types 
different reasons having types discussed literature review see cardelli wegner 
focus particular reason relevant practical design considerations described previous section 
types motivated software methodology point view page types essential ordered evolution large software systems 
large software systems created day evolve long periods time may involve programmers 
problem evolving software systems unfortunately correct people keep finding fixing bugs process introduce new ones 
course goal system correct soon achieved immediately notices system system slow uses space 
course goal system efficient requires new changes back previous point 
eventually system clean evolution considered system may require restructuring better maintenance introduce new bugs inefficiencies 
system correct efficient structured ideal moment introduce new functionality systems functional new features added cycle begins 
event goals achieved system usually obsolete 
evolution normal situation large software systems 
picture evolving software suggests mildly paradoxical concept software reliability 
normally says program correct incorrect works 
complex organism large software system transitional situation things things fewer things immediately extensive change 
analogy say hardware reliable break extensively spite wear 
software say evolving system reliable break extensively spite change 
software reliability sense major concern construction large systems main concern 
type systems come 
types provide way controlling evolution partially verifying programs stage 
typechecking mechanical guarantee designed language certain classes errors arise execution giving minimal degree confidence change 
elimination entire classes errors helpful identifying problems detected typechecking 
types typechecking increase reliability evolving software systems 

subtypes 
previous section look subtypes software methodology point view subtypes essential ordered extension large software systems 
software system produced usually users want extend functionality way 
done asking original developers modify system seen causes unreliability 
modifications carried directly users worse users little familiarity internals system 
changes users system incompatible releases system original developers 
various degrees built systems extended outside 
example procedural behavior system extended allowing users supply procedures invoked particular situations 
subtypes provide flexible extension mechanism allows users extend data structures operations provided system 
system provides type users may create subtype specialized operations 
advantage old system recognize new subtypes instances old types able operate 
subtypes increase reliability systems provide way increasing functionality having change original system 
subtyping guarantee new extensions preserve system internal invariants 
extended system reliable compatible releases base system abstraction base system building page extended system 
important subtyping abstraction features language interact nicely 
construction type hierarchies subtyping provides way organizing data benefits structuring large systems independently reliability considerations 

polymorphism 
seen types important construction large systems type systems constraining 
imagine type system set constraints imposed underlying untyped language 
type system imposes discipline increases reliability hand restricts class correct programs written 
type system providing static checking impose excessive constraints 
describe simple untyped language discuss kinds untyped flexibility may want preserve typed language 
variables constants labels terms page construct elimination variable constant function fun tuple tuple column shows ways creating instances construct elimination column shows ways construct 
programming features classified way 
flexible language untyped 
problem features elimination column may fail application fails function tuple selection fails tuple tuple field labeled failure points exactly software unreliable occur unpredictably untyped language 
purpose type system prevent happening statically analyzing programs 
special kinds flexible behavior want preserve type system 
untyped language apply function elements different types situations cause failures example applying pairing function fun tuple second fun tuple second true type system preserving flexibility said support parametric polymorphism achieved passing types parameters shall see regarding interesting examples 
different kind flexibility exhibited functions operating tuples function accepts tuple failing accepts extended version tuple just ignores additional tuple components fun tuple fun tuple true type system preserving kind flexibility said support subtype polymorphism achieved shall see defining subtype relation tuples 
type system eliminate failure points preserving kinds flexibility 

quantifiers subtypes section introducing particular type system characterized level structure entities 
structure driven design decisions language called quest sections illustrate basic advanced typing concepts 

kinds types values ordinary languages distinguish values types 
say case levels entities values inhabit level types inhabit level 
shall looking language quest adds third level types called level kinds level 
kinds types types collections types just types collections values 
collection types kind type type 
say value type say type kind kinds level types level values level type type type power int type pair type fun type fun pair int operators fun type page common languages levels sufficient type level relatively simple 
types generated ground types integers operators function space cartesian product 
normally implicit kind kind types general notion kinds necessary 
types quest language richer structure including type variables type operators notion type computation 
fact quest type level expressive calculus opposed simple algebra type operators 
calculus typed types kinds level higher normal 
clearer section 
level structure adopt shown level diagram 
values level 
level types intended sets values type operators intended functions mapping types types list type operator function mapping type int type lists integer 
level kinds types types operators intuitively kinds sets types sets operators 
detail value level basic values higher order functions fun polymorphic functions fun type fun pairs values pair true packages types values pair int 
note value level types intimately mixed values just specifications value components polymorphic functions take types arguments packages types components 
mean types class entities play role value computations mean types neatly separated values expect 
type level find types values 
basic types int function types functions usually written polymorphic types type pair types pair int bool types pair type 
type level find operators functions types types operators operators types 
example fun type operator type returns type example parametric list operator type int produces type list int integer lists 
kind level kind types type kinds operators type type kind list 
right hand side level diagram illustrates subtyping 
type level subtyping relation written subtype value type type kind level power kinds subtyping type power kind subtypes particular power 
power identify notions 
relation written programs power power power type means collection subtypes contained collection types 
structure level diagram characterized quantifiers incorporates 
deeply related quantifiers logic martin shall discuss connection 
quantifier intended type construction binds variables 
possible universal quantifiers classifying function objects possible existential quantifiers classifying pair objects 
basic quantifiers binary involve variable ranging type kind scope second type kind 
number comes possible type kind combinations binary operators examples clear 
level structure universal quantifiers flavors plus existential quantifiers flavors pair appears diagram page type functions values values types 
variable appear special circumstances normally equivalent function space sample element fun int type functions types values kind type may occur sample element fun type fun kind functions types types kinds may occur sample element fun type pair type pairs values values types 
variable appear special circumstances normally equivalent cartesian product sample element pair true 
pair type pairs types values kind type may occur sample element pair int 
symmetry add third existential quantifier pair kind turns useful 
specific reasons admitting possible quantifiers kind functions values types kind pairs values types types may depend values unrestricted forms pair may occur quantifiers compilation problematic deliberately omitted 
proceeding summarize clarify notation 
notation lower case identifiers internal capitalization compound names level capitalized identifiers level caps level 
example introduces values introduces types def introduces kinds 
courier font programs courier bold program keywords courier italic program metavariables 
particular range value variables range value terms range type operator variables range type operator terms range kind variables range kind terms 
note apply program non meta variables example roman type variable 
say value type say type kind say subtype say conventions implicitly section heavily 
page 
signatures bindings quantifiers examined previous section binary compose types kinds produce new type kind 
programming languages convenient ary quantifiers easily express functions arguments tuples components 
ary quantifiers achieved notions signatures bindings burstall lampson 
signature possibly empty ordered association kinds type variables types value variables variables distinct names 
example type int signature declaring type variable value variable type value variable denoting function objects type integer 
note signatures introduce variables left right variables mentioned 
binding possibly empty ordered association types type variables values value variables variables distinct names example type int int fun int binding associating type int values fun int appropriate variables 
bindings introduce variables left right example body cases desirable omit variables related type information binding reduces int fun int colon front int tell parser human type follow 
convert binary quantifiers ary quantifiers follows signature type pairs tuples ary universals ary existentials tuple page notation metavariable ranging signatures metavariable ranging bindings 
abbreviations extensively components signatures bindings signatures kind type value signatures bindings fun fun fun fun signatures bindings different places language syntax uniform 
positions signatures bindings appear surrounding context shown underlined note abbreviations just introduced signatures bindings type int int signatures formal parameters type int int int 
signatures types type int tuple type int tuple signatures interfaces interface import export type int bindings top level type int int int fun int bindings actual parameters type int int int fun int bindings tuples tuple type int int tuple int fun int tuple bindings modules module import export type int int interfaces modules discussed 

quest language design principles ideas discussed far discussed incorporated programming language called quest quasi acronym quantifiers subtypes 
language illustrates fundamental concepts typeful programming concretely embedded integrated single page language 
language described detail sections provide basis discussions examples 
example language speculative parts boundary solid tentative features detected looking formal syntax appendix 
features syntax implemented relatively thought 
features described regarded suspicion 
quest rest 
major sections follow deal kind types including basic types various structured types polymorphism types recursive types dynamic types mutable types exception types kinds operators including parametric recursive higher order type operators kinds subtypes including inheritance bounded quantification 
follow sections programming modules interfaces seen values types respectively section system programming point view typing violations 
main unifying concepts quest type quantification subtypes 
number important type constructions fall neatly classes mutable type exceptions types added side 
important point perturb existing structure 
brief general overview quest characteristics gradual begins section 
quest levels entities values types operators kinds 
types classify values kinds classify types type operators 
kinds needed type level unusually rich 
explicit type quantification universal existential encompasses parametric polymorphism types 
quantification possible just types ordinary polymorphic languages type operators subtypes type 
subtyping defined inductively type constructions including higher order functions types 
subtyping tuple types components ordered provides form single inheritance allowing tuple viewed truncated version fewer final components 
subtyping record types components unordered provides form multiple inheritance allowing record viewed smaller version arbitrary subset components 
user definable higher order type operators computations type level 
typechecker includes normal order typed calculus evaluator types kinds 
generalized correspondence principle adopted notions signatures bindings 
landin proposed correspondence declarations formal parameters 
burstall lampson proposed correspondence interfaces declarations parametric modules functions burstall lampson 
quest correspondence declarations formal parameters interfaces common syntax definitions actual parameters modules common syntax 
evaluation deterministic left right applicative order 
functions evaluated arguments arguments evaluated left right function bodies evaluated arguments 
records tuples components evaluated left right conditionals cases loops evaluate determined particular flow control 
entities explicitly initialized 
general flavor language interactive compiled strongly typed applicative order expression language class higher order functions imperative features 
type annotations heavily line existing programming large languages 
viewing signatures bindings terms quantifiers natural expect alpha conversion renaming bound variables hold 
alpha conversion allow signatures match independently names components routine signatures functions strange signatures tuples create accidental matches large software systems 
quest signatures page bindings match component name course component order type 
negative aspects choice avoided allowing component names signatures bindings omitted omitted names match name purpose typechecking provide weak form alpha conversion 
conclude section notes quest syntax 
comments enclosed nested 
comment lexically equivalent blank 
quotes enclose character literals double quotes enclose string literals 
curly brackets grouping value type kind expressions force operator precedence 
parentheses formal actual parameter lists function declarations definitions applications 
syntax virtually commas semicolons 
commas lists identifiers semicolons terminate top level sentences modules 
blank space 
indentation required disambiguation greatly improves readability absence normal separators 
resulting syntax easy parse widespread initial final keywords 
lexical classes identifiers alphanumeric letters numerals starting letter symbolic built 
reserved keywords belonging lexical class considered identifiers 
alphanumeric identifiers infix position 
symbolic identifiers infix prefix stand 
new infix operators declared freely int int 
declaration infix status 
needed strict lexical conventions 
declaration infix precedence 
infix operators including built ones precedence right associative 
decision difficult specify relative precedence operators meaningful way equally difficult remember guess relative precedence operators new infixes introduced 
overloading literals operators built ones 
example integer real integer plus real real plus obtained built interface 
style conventions adopt follows 
value identifiers including function names module names lower case internal capitalization compound names 
type identifiers including interface names capitalized 
kind identifiers caps 
keywords capitalized roughly way tuple tuple type tuple tuple value 
flow control keywords lower case 
keywords pretty printed boldface comments italics 
infix sign means type 
infix sign means kind 
infix sign means subtype 
sign associate identifiers values types kinds 
sign boolean test equality constructs isnot 
sign assignment operator 

kind types kind types kind supported ordinary programming languages pascal 
section include familiar programming constructs 
find relatively unusual programming features polymorphism types full generality 
quest language introduced previous section 
basic types provide new insights describe patiently essential examples 
function types general notion signatures universally quantified represent explicit polymorphism 
tuple types similarly general signatures existentially quantified represent types 
page quantifier summation signatures finite set accounts familiar disjoint union types 
infinite summation signatures types corresponds dynamic typechecking supports persistent data 
recursive types allow construction lists trees 
mutable types assignable variables fields arrays handled carefully maintain type soundness 
exception types take care exceptions 

quest interactive compiled language 
user inputs phrase evaluate expression establish binding system produces answer 
level interaction called top level system 
notation illustrate top level interaction user input preceded sign system output preceded sign italicized shown smaller font 
output portions occasionally omitted obvious 
page int int recall introducing values introducing types forms bindings explained arise 
concepts modules interfaces basic 
interfaces organize user programs organize basic system 
routines normally considered primitives collected built interfaces interfaces implementation provided basic system 
include features complex input output features basic ascii conversions 
convention interface dedicated implementing single type main type type simple name qualified module name normally expressive list 

basic built types basic types ok bool char string int real array exception 
language modules principle need basic types new basic types introduced external interfaces may known compiler implemented efficiently 
nice direct syntactic support commonly constants operators real reason having special types designated basic need eliminated language supported syntactic extensions 
types basic defined interfaces known compiler called built 
respective modules interfaces called built 
examples built interfaces reader writer dynamic described appendix 
built interfaces defined needed implementations 
ok ok type single constant ok operations 
type called void unit languages expression languages type expressions really meant value assignment statements 
bool bool type constants true false 
boolean operations infix function evaluate arguments 
equality inequality values forms isnot return boolean 
ness predicate defined ordinary equality ok bool char int real memory location types including string 
types define equality operation interface 
basic programming construct booleans conditional true int conditional take forms 
may may branches missing branches type ok additional elsif branches cascaded 
conditional constructs provided false true useful express complex boolean conditions evaluated 
example assuming defined isnot elsif ok ok conditional causes division zero 
char char type ascii characters syntactically enclosed single quotes operations characters provided built module ascii built interface ascii written ascii ascii 
incidentally example organize basic operations interfaces order clutter language forget char ascii operation confuse variable function seeing ascii char meaning obvious 
string string type strings ascii characters abc enclosed double quotes operations strings provided built module string predefined infix operator string concatenation concat string concat string concatenate string backslash insert special characters character quotes newline tab backspace form feed single quote backslash backslash followed character equivalent character 
characters backslash insert special characters string quotes newline tab backspace form feed double quote backslash backslash followed character equivalent character 
page example illustrates simultaneous bindings separated 
library module conv conv contains routines converting various quantities strings useful printing 
int int type integer numbers 
negative numbers prefixed tilde 
integer operators infix modulo 
real real type floating point numbers 
real constants formed integer dot positive integer optionally exponent part 
avoid overloading integer operations real operators infix exponent 
page real conversions operations provided built modules real trig trig 
arrays exceptions readers writers dynamics discussed sections appendix 

function types function types normally realized implicitly explicitly arrow operator requiring domain range type 
adopt operator quantifier requiring domain signature general signature may introduce type variables occur range type 
function type form type functions parameters signature result type fun abbreviated fun depending form functions simple higher order contain function types polymorphic introduces type variables 
simple functions simple function declaration succ fun int int succ int int fun succ int discussed earlier declarations usually abbreviated follows succ int int succ int int fun function arguments applied take simple arguments binding correct form plus int int int plus int int int fun plus int plus int recursive functions defined rec binding rec fact int int fact fact int int fun simultaneous recursion achieved rec followed multiple bindings separated 
entities recursive definition syntactically constructors functions tuples explicit data structures function applications tuple selections operations 
higher order functions say higher order functions allowed double int int int int double int int int int fun succ double succ succ int int fun succ int note function body may contain non local identifiers body double identifiers retrieved appropriate statically determined scope 
polymorphic functions polymorphic functions functions types parameters instantiated specific types 
polymorphic identity function id type id type fun id int int identity function instantiated interesting ways 
instantiated simple type int obtain integer identity page page id int int int fun applied integer identity providing type integer endomorphism type int int type int int id fun int int applied providing type endo type endo type type id endo id fun type polymorphic functions curried type parameter done far conveniently instantiated 
requirement define polymorphic identity follows id type id type fun id int int slightly interesting polymorphic function twice double effect function including twice type twice type fun succ twice succ succ int int fun type systems allow polymorphic functions applied types called impredicative 
semantics systems delicate paradox necessarily involved 

tuple types tuple types normally intended iterated applications cartesian product operator 
tuple types formed signatures general signatures introduce type variables may occur signature components 
tuple types interpreted iterated existential quantifiers 
tuple type form tuple type tuples containing bindings signature tuple depending form simple tuple type type introduces type variables 
simple tuples simple tuple ordered collection values 
values provided names tuple tuple tuple int int string way extract values pass tuple function provides names components input signature 
frequently tuple components named tuple int string tuple tuple int string tuple tuple components extracted name dot notation string note tuple may contain arbitrary binding including function definitions recursive definitions empty tuple type ok type empty tuple ok tuples type obtained tuple type contains type set constants operations type 
tuple type int type tuple type int type implemented providing type value type operation type int tuple type int int tuple type unknown unknown int fun page types values printed order maintain privacy implicit notion type abstraction 
functions printed compiled source code easily available 
type implemented different ways implementation page tuple type bool false int tuple type unknown unknown int fun type 
abstraction produced rule extracting types values tuples identity type revealed values type shown type unknown type match representation type error subtype int representation type remain unknown possible perform useful computations int attempts mix different implementations type produce errors type error subtype fails determined implementation fact example really different implementations interaction meaningless 
type implemented tuple type int tuple type unknown unknown int fun instance impredicativity value type contain type component 

option types option types model usual disjoint union variant record types unusual features 
option type represents choice finite set signatures objects having option type come tag indicating choice represent 
precisely option type ordered named collection signatures names distinct 
object option type option tuple consisting tag binding 
option tag binding option type provided tag associated signature binding signature option bool string option option true option choices option type ordered operator ordinal returning ordinal number option determined tag note tag component option modified 
option tag tested operator see examples 
option contents extracted operator 
may fail run time wrong tag specified 
successful result tuple component ordinal option 
true bool false bool exception error tuple true tuple int bool true bool structured way inspecting options case construct discriminates option tag may bind identifier option contents case arm arm true false conversely option created ordinal number option ordinal 
determined run time form allowed branches option type signature 
page page arm arm arm true string clause may list options equivalent occurrences right hand side receive type 
option type starts directly clause means components clause common branches 
types equivalent option option bool bool bool bool bool values types behave slightly differently case common components extracted directly dot notation coercing label 
option types discussed conjunction subtypes 

auto types situations programming necessary delay typechecking run time 
situations captured new form quantification infinite union signatures indexed types requires dynamic typechecking 
quantifier resembles option types types 
option type union run time discrimination union infinite 
type collection types related values types dynamically inspected 
values auto values short values capable describing contain type determine rest shape 
related types auto types consist type variable signature depending represent union signatures varies types shall see subtypes type 
auto type fst snd auto bool false true auto bool false true restriction type component auto value closed type contain free type variables 
possible discriminate type component object construct similar case named inspect construct simula shall see discriminate subtypes type 
inspect bool arm arm fst arm snd int arm arm fst arm snd isnot true bool types clauses inspect closed types 
branch selected execution branch type auto value subtype type branch 
branch added construct 
types discussed conjunction subtypes dynamic types 

recursive types recursive types useful defining lists trees inductive data structures 
parametric types discussed section type operators 
discuss curious fact recursive types allow reproduce normally called type free programming framework typed language 
expressive power sense lost typed language recursive types 
shows sufficiently sophisticated type system remove restrictions normally associated static typing 
expressions lisp fundamental data structures 
described follows simplicity consider atoms rec sexp type option nil cons car cdr sexp rec sexp type option nil cons car cdr sexp usual lisp primitives defined terms operations options tuples left exercise 
interesting recursive type universal type untyped functions rec type rec type define universal untyped combinators fun pure lisp primitives 
define see section 
page page fun note quest call value language exercise define call name version definitions encode non strict conditional expression 
hint rec type interesting notice recursive types imply presence general recursive functions 
exercise define fixpoint combinator call name call value versions rec 
recursive types equivalent infinite expansions obtained unfolding recursion form equivalent infinite trees 
recursive type definitions describe finite graphs type operators nodes possible test condition finite time generating infinite structures amadio cardelli 

mutable types imperative programming notion mutable global store constructs sequencing operations affecting store 
mutability interacts nicely quantifiers including polymorphism showing functional style approach suggested type theory prevent design imperative languages 
var types mutable store supported type operators var type mutable identifiers data components type type write parameters type 
operators fact class sense values type var firstclass values types var var produced 
discussing type rules useful think var ordinary operators restrictions efficiency reasons typing reasons 
identifier declared mutable prefixing var keyword binding signature receives var type 
var var int answer var int read meaning type var int 
evaluating expression type var automatic coercion applied obtain value type int sign assignment operator requires destination type var source type returns ok performing side effect problems encountered ml gordon milner wadsworth page avoided explicit polymorphism 
take precautions subtyping explained 
ok ok int functions refer directly global variables var type passed parameters embedded data structures accessed indirectly 
restriction facilitates implementation higher order functions 
example functions sharing private variable accessible called variable tuple int tuple var tuple int int tuple int int tuple fun fun int int data structure components mutable var notation variables tuple var tuple var int ok ok sequencing iteration syntactic construct called block execute expressions sequentially return value 
block just binding declare local variables restriction component result value value expression 
type block type expression 
value variables declared block may appear free tuple variables type extracted escape scope 
explicit block construct blocks implicit places value expected example branches conditional 
iteration provided loop 
exit 
construct evaluates body binding repeatedly syntactically enclosed exit encountered 
exit construct type thought exception raise exit inferred 
loop construct returns ok terminates type ok addition constructs provided abbreviations loop exit forms 
example usage blocks iteration page page gcd int int var vn var vm vn isnot vm vn vm vn vn vm vn vm vm vm vn vn gcd int int fun gcd int types formal parameters functions may declared type prefixing keyword 
write copy parameters 
passing argument corresponding parameter explicit coercion type 
provided keyword applied mutable var entity meant suggestive passing location entity value 
int int ok int convenience possible convert non mutable value parameter creating location fly var abbreviated var 
words entity obtained var entity ordinary value var 
description operational deeper relations var type rules passing var parameters explained section subtyping 
polymorphism parameters combined define function assign type ok var assign int effect assignment operation 
array types array types array describe arrays elements type indexed non negative integers 
array types carry size information array values dynamically allocated 
individual arrays created size changes 
array values created size initial value elements explicit list values 
indexed updated usual square bracket notation extent operator provided extract size 
array int array array bool array false array listed elements 
array defined elements initialized false 
syntax enumeration values enclosed size init pair enclosed 
array basic construct additional functions defined 
interpreted abbreviations 
array 
array need get function define ordinary function array parameter sum array int int var total upto extent total total total sum array int int fun sum int sum int complete set operations arrays provided built module 
interesting examine polymorphic signatures operations 

exception types exceptions wisely important structuring tool embedded systems anomalous conditions control programmer handling deferred clients 
notice exceptions control flow mechanism greatly affect type system 
fact exceptions propagated typed entity sense typechecked 
primitive operations produce exceptions applied certain arguments division zero 
userdefined exceptions available language 
exceptions quest treated differently languages explicit notion exception value created exception construct bound variable passed function eventually raised 
exc exception int exception int exc exception string exception string exception construct generates new unique exception value evaluated 
identifier printing exception messages type type value accompany exception 
exceptions raised value appropriated type raise construct page page raise exc exception int exceptions caught try construct attempts evaluating expression 
exception generated evaluation matched set exceptions optionally binding identifier exception value 
exception ones considered try construct branch exception propagated 
try raise exc exc exc int exceptions propagate dynamic call chain 

operator kinds operators functions types types evaluated compile time 
higher order operators map types operators types operators 
languages built operators function spaces cartesian products languages allow new operators defined restrict order types types 
higher order operators embody surprising expressive power define largest known classes total functions girard free algebra total operations booleans integers lists trees uniformly representable hm berarducci see example booleans 
believe turn useful parametrization carrying compile time computations 
operator form fun signature introducing type variables type 
kind operator form kind 

type operators simplest operator identity operator takes type returns defined normal abbreviated ways 
id type type fun type id type type id type type id int int type id int int function space cartesian product infix operators take types return type type type type type tuple fst snd int int int fun int int fst snd note omitted identifier typings fun legal identifier allowing typecheck 
omitted identifiers alpha conversion briefly discussed section quest language 
optional operator data components may may opt type type option operator applications evaluated call name important computations operator level terminate 
recursive operators 
interesting functional programs written operator level def introduces kind def bool type type true bool fun type false bool fun type cond bool type type convince cond really conditional type level 

recursive type operators recursive type operators order guarantee computations type level terminate 
recursive types achieve effect 
example expect define parametric lists recursive operator follows invalid recursive definition rec list type type option nil cons head tail list page page define list ordinary operator returns recursive type list type type rec type option nil cons head tail list type type rec type option nil cons head tail recursive type constructor rec restriction kind type power kind see section 
basic list constructors nil type list option nil list cons type head tail list list option cons list head tail basic list operations left exercise 

power kinds quantifier operator structure described far derives girard system fw girard 
main new fundamental notion quest integration subtyping type quantification 
allows express directly wider range programming situations programming language features introduce new ones 
section define subtyping relation types written type type intuition subtyping ordinary set inclusion 
subtyping defined type constructions normally holds types constructor 
non trivial subtype relations basic types possible add machine representations related types compatible 
talk collection subtypes type forms kind call power power kind power meaning taken actual primitive considered abbreviation 
subtyping induces relation written kinds basically power power power type type say signature subsignature signature number components names position component types kinds subtypes corresponding components 
say extended subsignature prefix subsignature 
formal subtyping rules simplified quest language appendix 
notion subtyping emulate characteristics commonly understood inheritance object oriented languages 
keep mind inheritance fuzzy word unequivocally established definition subtyping technical meaning case subtyping component full treatment inheritance 
try keep notions distinct avoid confusion 
familiar subtyping relation tuple types idea comes object oriented programming class subclass class attributes methods instance variables 
interpret object tuple method functional component tuple public instance variable modifiable value component tuple private instance variable modifiable variable methods appearing tuple class function generating objects methods instance variables class signature tuple type 
discuss interpretation self interesting complex topic cook hill canning subclass said inherit object oriented programming usually means objects inherit methods functional fields sharing method code inherit instance variables data fields allocating space 
framework signatures sense inherited object components 
inheritance methods achieved manually code sharing 
sharing enforced language acquire flexibility class signature implemented classes different instances class signature different methods 
confers dynamic aspect method binding requiring run time search class hierarchy method access 

tuple subtypes subtyping rule tuples follows 
tuple type subtype tuple type signature extended subsignature signature remember fields tuple tuple type ordered tuple subtyping emulates single inheritance hierarchies hierarchical structure forms tree forest 
simple tuples example subtyping hierarchy tuple types object tuple age int vehicle tuple age int speed int machine tuple age int fuel string produces subtyping diagram couple actual objects object tuple age vehicle machine object page page vehicle tuple age speed vehicle vehicle object object called subsumption rule 
functions expecting objects accept vehicles age object object int object age age int example illustrates flexibility inherent subtypes 
note inheritance subtyping automatic depends structure types declared 
note age function defined vehicle type vehicles soon defined 
tuples tuples may form types immediately get notion subtypes subtyping types 
example point tuple type new int int colorpoint tuple type new int int paint color ok color color new color point starts default color painted color 
colorpoint point program working points accept color points subsumption 

option subtypes subtyping rule option types follows option type subtype option type tagged components names positions possibly component signatures extended corresponding component signatures components option type ordered 
example define enumeration types day option mon tue wed thu fri sat sun weekday option mon tue wed thu fri weekday day important notice enumeration types pascal freely extend existing enumeration additional elements preserving type compatibility old enumeration 
similarly defining tree data type options add new kinds nodes affecting programs old definition 
course old programs recognize new options code reused deal old options 

record variant types components tuple option types ordered advantage tuple selection performed constant time typically machine instruction case discrimination performed constant time branch table 
interesting examine versions tuple option types unordered called record variant types respectively 
record selection variant discrimination performed quite efficiently difference practice small constant interesting properties 
records named collections values names distinct 
tuples record components unordered named introduce types record 
type record containing permutation required named components record 
example record type function operating 
field selection achieved dot notation tuples record int bool type record int bool int int fun record true int tuples record type subtype record type components names component types subtypes corresponding component types record types unordered subtyping hierarchies built record types form arbitrary directed acyclic graphs trees emulating multiple inheritance class signatures 
note record types unordered typechecking blow combinatorially record types sorted label name matching record types linear process 
applies variant types 
adapting previous example object record age int types tuple useful create dependencies order 
page page vehicle record age int speed int machine record age int fuel string car record age int speed int fuel string produces subtyping diagram vehicle car object machine multiple inheritance possible compute statically displacement field name arbitrary record 
form run time lookup required 
implemented efficiently caching techniques remember name record time full lookup fails 
scheme majority accesses done constant time machine instructions gentle degradation type hierarchies complex cache hits tend decrease cardelli 
variant type unordered named collection types names distinct 
variant tagged value value matching proper branch relevant variant type 
variant 
variant variants variant types similar options option types operators case construct variant type subtype variant type components names component types subtypes corresponding component types components variant type unordered 
example define enumeration types day variant mon tue wed thu fri sat sun ok weekday variant mon tue wed thu fri ok weekend variant sat sun ok ordinal operator provided variants 
weekday weekend lack order possible compile exact branch table case statement 
efficient caching techniques remember variant dispatched time case statement linear search case branches fails 
degrades gracefully precautions taken sorting case branches compilation 

higher order subtypes ordinary mathematics function considered function subset subset 
called contravariance argument function space operator 
programming sense rule form object oriented languages sound type system 
asserts function working objects type objects subtype type function returning object type regarded returning object supertype type 
subtyping rule function spaces asserts assuming 
adopting rule functions take ground subtyping data structure level lift higher function spaces 
object oriented programming ground subtyping functional programming higher order functions say rule unifies functional object oriented programming type level 

bounded universal quantifiers subtyping increases flexibility typing subsumption mechanism cause loss type information 
consider identity function objects applied car returns object day objectid object object object object objectid mycar record age object unfortunately forgotten mycar car just passing identity function 
problem solved providing type information page page objectid object object object objectid car mycar record age speed fuel gas car note signature object objectid polymorphic function polymorphic type polymorphic subtypes object 
takes type subtype object value type returns value type 
signature object called bounded universal quantifier fact new kind signature interpreted abbreviation power object 
bounded universal quantifiers effect integrating polymorphism subtyping provide expressive power notion taken separately 

bounded existential quantifiers bounded quantifiers tuple types called bounded existential quantifiers 
provide weaker form type abstraction called partial type abstraction example type completely known object tuple object int implemented subtype object case implemented vehicle 
tuple object vehicle int speed interaction type abstraction inheritance delicate topic languages inheritance violates type abstraction providing access implementation details superclasses 
mechanisms smoothly integrate types subtyping partially types subtypes seen previous section 

auto subtypes auto type subtype auto type respective components matching names order subtype relation 
component auto type type possible form sum restricted class types auto object auto car mycar inspect construct discriminate run time subtypes type case subtypes object 
operation widely object oriented languages simula modula oberon 

mutable subtypes best way explain relations var types take primitive operator consider var defined type conjunction reynolds var intended means var type locations type type 
intended type locations read type locations write var type read write locations 
type conjunction subtyping properties may derive reflexivity transitivity writing conversions trivial performed variable declarations variable access subtyping rule 
simplicity quest identify types take conversions implicit 
amounts assuming 
types interesting 
note assume amount 
fundamental subtyping rule suggested reasoning subtyping place write place write means contravariant nice consequence parameters appear contravariant positions left function arrows parameters behave covariantly really function results 
contravariant rule effect contravariant rule functions 
subtyping rules far easily infer var var general forms page page var var putting var var var conversion implicit automatic special needed fetch contents mutable location 
rule says structure updated regarded structure updated passed function update 
var possible pass mutable location parameter explicit conversions var required prevent automatic fetching mutable locations described var int int ok int int ok var dummy location initially conversions precise typing var var example types var int int int int var var int int int var int var parameters addition parameters flexible subtyping point view 
simplicity left language example shows relaxing rule var var semantically unsound tuple var tuple tuple var tuple ok tuple conversions required making programs easier read algorithmic necessity 
note implicit conversion var problematic natural implementation parameters pairs 
typechecks 
crash 
invocation removes field inside maintains old type 
crash occurs attempting extract note typechecks weaker subtyping rule var 
subtyping rule arrays considering purpose subtyping functions integers mutable locations array regarded int tuple var obtain rule array array requires array operator covariant contravariant 

recursive subtypes type equivalence recursive types subtype relation infinite expansions subtype relation 
condition tested finite time 
produce hierarchies recursively defined types 
example involves subtyping rules var types defined previous section 
list type type rec list type option nil cons head tail list varlist type type rec varlist type option nil cons var head var tail varlist obtain example varlist int list int non trivial var rule 
note varlist list sense subtyping defined types operators 

large programs usefulness necessity typeful programming apparent construction large systems 
serious programming involves construction large programs property single person understand remember details time written single person 
page large programs split modules allow compilers deal piece time allow people understand piece time 
fact idea split relatively small programs modules 
rule thumb module exceed lines code small desired 
lot experience required understand module boundaries located parnas 
principle part program conceivably reused form module 
collection routines maintain internal invariant violated careless form module 
user defined data type collection closely related data types form module relevant operations 
module boundaries located information hidden information needed modules information misused modules 

interfaces modules module boundaries called interfaces 
interfaces declare types kinds identifiers supplied modules describe modules may plug form systems 
interfaces provide data types related operations case define consistent complete set operations hidden types 
interfaces may just collection related routines collection types modules 
interfaces carefully documented units abstraction understand order understand larger system 
interfaces modules may import interfaces modules export set identifiers 
module satisfies implements interface provides identifiers required interface module may define additional identifiers internal purposes 
quest interfaces modules entered top level normally separate files 
interface say implemented modules say module specifies interface implements written module headings page interface module import 
import 
export export 
interfaces modules may explicitly import interfaces modules headings interface implemented module implicitly imported module 
line imports interfaces module implementing modules implementing import imported modules just tuples values types extracted usual dot notation 
imported interfaces just tuple types 
modules tuples class possible pass modules store variables choose dynamically different implementations interface 
main pragmatic goals modules interfaces provide separate compilation 
interface evaluated corresponding file written containing compiled version interface 
similarly module evaluated file written containing compiled version module 
interfaces modules evaluated imported interfaces compiled imported modules 
import dependencies modules interfaces form directed acyclic graph mutually recursive imports allowed guarantee linking process deterministic 
modules linked importing top level import 
point interfaces modules imported directly recursively imports compiled 
result definition top level tuple type values types extracted usual fashion 
compiled module function closure evaluated 
link time contents compiled modules evaluated context imports 
linking process single copy module evaluated may imported times 
evaluation happens depth import chains order modules appear import lists 
version checking performed linking sure compiled interfaces modules consistent 

manifest types kinds programming modules convenient define type interface modules interfaces refer definition 
far shown way doing types defined bindings module bodies accessible modules signatures interfaces contain specifications types separate mechanism provided introduce type kind definitions signatures types kinds called manifest 
seen just convenience types kinds expanded points 
particular manifest entities appearing signatures bindings conceptually removed expanded typechecking 
augment syntactic classes follows signatures contain manifest kinds types introduced def def keywords respectively 
identifiers introduced mentioned signature 
definitions particularly useful signatures forming tuple types interfaces definitions extracted tuple type 
def manifest kind definition 
def manifest type definition 
similarly def rec 
kinds type identifier bound tuple type interface kind variable introduced def tuple type kind 
view dynamic linking nicer introduce import new form binding restricted top level 
fact write specification partially type interface making publicly available subtype known type signature matching rules implementation interface implement probably just duplicating possibly complex definition 
page types denotes tuple type type variable declare def tuple type page type 
dot notation extract types values binding structures underscore notation extract manifest kinds types signature structures 

diamond import module systems admit multiple implementations interface way telling implementations interface imported different paths implementation macqueen 
called diamond import problem 
module imports modules import module types flowing different import paths interact words match know statically value implementation interface 
quest context parametric modules solved assuming global name space externally compiled modules matches precisely identifier 
interface module export export type type int new int new int int int int int interface module import import export export new interface module import import export export int int int interface module export import int export note application module typechecks imported imported implementation interface global external name 
illustrate correspondence interfaces signatures modules bindings rephrase diamond import example follows 
type tuple tuple type type int new int new int int int int int type tuple tuple new type tuple tuple int int int type tuple tuple int case typechecks types refer variable lexically scope 
huge programs programs started large composed hundreds procedures necessary process chunks practical implementation considerations better structuring 
eventually trend led modules interfaces 
today programs starting huge composed hundreds interfaces problems level 
modules interfaces considered far flat structure hard organization system 
importantly group interfaces may intended private subsystem accessible subsystems 
clearly desirable able group interfaces systems grouped larger systems 
just syntactically nest modules interfaces hope solve problem separate compilation prevented 
remember flat structure modules advantage escapes strict block scoping rules 
section examine way describing systems interfaces remaining compatible previous notions modules interfaces 
main goals able reorganize structure subsystem including inner interfaces affecting subsystems similar separate compilation criterion modules 
classify systems open closed sealed 
analogy hardware open system hardware box cover anybody plug wires 
closed system hardware box cover expansion slots plug wires outside connectors add new piece hardware related external connectors internal access box 
sealed system provided connectors 
page 
open systems consider system organization illustrated diagram 
system composed sub systems system composed interfaces imports corresponding modules system composed single exported interface imports page express arrangement notation system system system interface interface interface import export export export interface import export interface import interfaces directly mentioning systems belong necessary facilitate system 
new interface join system just claiming belong 
reason systems open restrictions regarding membership visibility 
structure reorganized easily just changing membership claims affecting unrelated parts flexibility important large evolving systems 
time membership claims provide degree structuring 

closed systems step restrict visibility system boundaries system may declare interfaces module exported preventing importing similarly system may declare interface available outside general interface imports interface closed system barriers barriers exported 
system system export export interface import export closed system prevent interfaces spontaneously joining 
allow interfaces members multiple systems 
interface counteract closure system claiming belong able import interface import export point closing system allowing interfaces join 
idea joining system explicitly declares intention depending internal structure simply importing interface provided system declares intention depending implementation details system 
note single name space interfaces modules 
doubtful feature way interfaces modules moved system programmer having modify clients 

sealed systems final step prevent unauthorized membership system 
seal system line added explicitly lists interfaces modules allowed belong case modules 
point cut prevented access added component list desired system components export sealed system provides solution problem implementing large data types 
ordinary module systems implementation type spans modules say representation public interface say imported 
way type ceases everybody see interface solution add new interface exporting real type operations implementation realizes imported implements operations importing 
wrapped sealed system exports page page interface module export export def interface module import import export export interface module import import export export interface module export import type export 
system components export process closing system may reveal unintentional dependencies may accumulated development 
process sealing system may reveal deficiencies system interface fixed 
expected evolution software system start open facilitate initial development 
closed relatively stable interfaces developed system ready released clients 
stage developers may want easy access closed system joining 
system quite stable sealed effectively forming large structured type example operating system file system interface 

system programs mentioned language considered real allows form lowlevel programming example real language able express compiler including runtime system memory allocation garbage collection 
interesting systems point get bit level 
arrange parts system written language unsatisfactory 
better solution allow low level parts written variation subset special extensions language hand clearly marked 
extreme situation infamous assembly language insert find better solutions relatively completely provide checking localize responsibility unpredicted behavior results 
mechanisms considered section 

dynamic types static typechecking cover situations 
problem giving type eval function generic print function 
common problem handling type sound way data lives longer activation compiler atkinson bailey chisholm cockshott morrison 
problems solved dynamic types realized built module dynamic dynamic see appendix 
objects type dynamic imagined pairs type object type 
fact dynamic defined type auto type relevant operations defined terms operations auto types 
particular type component dynamic object closed type tested run time inspect 
construct dynamic objects follows dynamic dynamic new int dynamic auto int objects narrowed closed type dynamic operation 
type matches type contained dynamic value contained dynamic returned 
exception raised narrowing just special case inspect dynamic int int dynamic bool exception matching rules narrowing inspecting static typechecking check happens run time 
object type dynamic self describing saved file read back narrowed separate programming session wr writer file dyn dynamic extern wr write file writer close wr rd reader file dyn dynamic intern rd read file operations extern intern preserve sharing circularities single dynamic object different objects 
values dynamics including functions dynamics 
dynamic values readers writers general meaningful extern objects bound input output devices 

stack allocation memory allocation quest dynamic variables kept stack normally refer data structures tuples functions heap memory reclaimed garbage collection 
language dynamic storage allocation garbage collection write garbage collector 
solution involves identifying allocation free subset language writing garbage collector subset 
words distinguish stack allocation storage easily reclaimed heap allocation requires collection 
page ordinary languages distinction memory structures pointers memory structures 
structure denoted variable stack allocated structure denoted pointer stack heap allocated 
allows fine control goes requires programmers conscious distinction heap allocated 
situation default speak stack allocation explicit actions required achieve heap allocation 
quest takes opposite default 
normally object pointer dynamically allocated structure 
leads transparent programs symbolic manipulation situations 
system programming distinction reintroduced 
quest requires explicit actions 
mechanism adopt superficially similar var types variables declared types 
values type values type allocated flat additional pointer referring part structure stack tuple heap stack allocated variable declared keyword page tuple int type tuple int tuple tuple variables types passed alias seen var types int int fun int restrictions imposed legal types 
global variables functions types 
create dangling 
functions expressions return objects type 
create dangling 
objects types source target assignment components 
assignment different semantics ordinary assignment cause problems polymorphic functions know size objects 
objects type compared isnot 
reason assignment 
objects types string array initialized compile time known sizes 
reason declare variables types int integers allocated flat anyway forbidden 
subtyping rule important property mechanism removing annotations change semantics program annotations seen optimization suggestions compiler 
garbage collector written types basic types asked compiler check really need heap allocation module 
property true module true module body modules imports 
var var var var allowed 
low level garbage collector may require additional tricks discussed section 

type violations system programming languages allow arbitrary type violations indiscriminately restricted parts program 
operations involve type violations called unsound 
type violations fall classes basic value coercions 
include conversions integers booleans characters sets need type violations built interfaces provided carry coercions type sound way 
bit word operations 
involve operations bit field operations bit wise boolean operations unsigned arithmetic comparisons operations provided sound built word interface 
address arithmetic 
necessary built unsound interface providing adequate operations addresses type conversions 
various situations involve pointers heap dangerous relocating collectors pointers stack pointers static areas pointers address spaces 
array indexing replace address arithmetic 
memory mapping 
involves looking area memory unstructured array contains structured data 
typical memory allocators collectors 
metalevel operations 
fundamental type violations 
incremental compiler compiled piece code compiler jump execute 
way type sound way soundness operation depends correctness entire compiler 
execution returned value value printed static type information requires unsound operations 
returned value dynamic printed accordingly validity dynamic value depends correctness typechecker 
appendix suggest particular type violation mechanism built interface value manipulates raw words memory 
type violation mechanisms need controlled lest compromise reliability entire language 
cedar mesa modula idea 
unsound operations may violate run time system invariants called unsafe 
unsafe operations modules explicitly declared unsafe 
module declared safe compiler checks body contains unsafe operations imports unsafe interfaces 
adopt essentially scheme keyword unsound unsound modules may advertise unsound interface 
unsound modules ordinary interfaces 
case programmer unsound module guarantees proves trusts module unsound external point view internally uses unsound operations 
way low level facilities added system requiring users facilities declare modules unsound just import 
soundness property proves show type system permit type violations 
word unsafe slightly different meaning languages unsound operations considered safe violate runtime invariants 
page unsound operations quest provided built unsound interfaces value 
unsound modules import implementations unsound interfaces may unsound sound interfaces 
sound modules import implementations sound interfaces 
implementations may unsound 
sound interfaces allowed import implementations unsound interfaces soundness compromised operations types 
top level implicitly sound 
main advantage scheme goes wrong responsibility restricted unsound modules 

illustrated style programming rich type systems 
new general particularly rich type system described type quantifiers subtypes extends state art 
rich type structure account functional imperative algebraic object oriented programming unified framework extends programming large care system programming 

style typeful programming notion statically checkable properties program 
properties considered currently know best implement static checks involving type properties 
furthermore know properties statically checked undecidability problems 
know practice properties easily definable programmers predict programs legal 
combination facts tells consider arbitrarily complex static properties relatively simple ones 
type systems powerful ones relatively simple understand implement relatively predictable 
provide best known practical compromise typeless programming full program verification 

styles focused particular programming style 
programming styles compatible briefly analyze relation typeful programming 
typeless programming 
truly typeless languages include assemblers bcpl minor extent languages regard raw memory fundamental data structure 
large systems programmed style hard debug maintain dismiss languages obsolete unreliable 
relatively rich notion typing type enforcement weak lead predictably robust systems 
type free programming 
concerns languages notion run time typing including strong typing static typing lisp apl smalltalk 
previous category large systems built way easily debugged 
practice lead robustness reliability maintainability 
bugs easily fixed easily prevented systems easily restructured 
systems rapidly incomprehensible size weinreb moon static structure imposed 
type free programming advocated beginners kemeny kurtz languages ml miranda turner demonstrated powerful type systems desired completely unobtrusive type inferencing techniques help trap mistakes beginners 
functional programming 
languages functional programming traditionally untyped ones typed turner 
higher order function types account style programming 
page imperative programming 
virtually imperative languages main exceptions assemblers basic form typing 
see modula wirth modern highly structured type system 
types normally involved controlling side effects see lucassen gifford proposes interesting way quantifiers purpose 
object oriented programming 
original object oriented language simula dahl nygaard typed 
smalltalk krasner abandoned typing object oriented languages typed stroustrup cardelli donahue glassman jordan kalsow nelson schaffert cooper kilian wirth 
notion subtyping necessary capture fundamental notions object oriented programming 
relational programming 
reason principle languages prolog kowalski typed 
fact languages manipulate highly structured data typed natural way 
efforts direction mycroft keefe open problem 
algebraic programming 
programming style data abstraction considered fundamental objectoriented programming aspect 
notion types described fundamentally clu liskov strong relations obj futatsugi goguen jouannaud meseguer handle free algebras equations 
idea existential quantifiers accurately model types comes mitchell plotkin 
virtually algebraic programming conducted case naturally typed 
concurrent programming 
different flavor concurrent programming fits programming styles concurrency sense orthogonal style 
question types interact concurrency interesting 
hand little relation concurrency flow control type systems normally avoid flow control questions 
hand attempts type information control concurrency strom yemini andrews schneider 
areas shared memory concurrency static checks badly needed order build reliable systems 
type systems provide open problem 
programming large 
programming discipline organizing large software systems notions modules interfaces mitchell maybury sweet wirth 
large systems kept consistent checking interfaces fit done typechecking plus version checking 
interface basically type module described modules interfaces correspond tuples tuple types 
system programming 
programming discipline forms type violations necessary 
common system programming languages notion typing harbison steele mitchell maybury sweet wirth 
especially area unchecked programs errors extremely difficult track typing quasi typing necessary maintain sanity 
database programming 
quest dynamic types provide rudimentary form data persistence atkinson bailey chisholm cockshott morrison 
interestingly set relation types defined buneman ohori integrated quest type system cardelli interact nicely subtyping 
relational algebra operators generalized higher order introduced 
conclude need typing characteristic serious form programming particular programming style 

acknowledgments various discussions roberto amadio rules recursive types pierre louis curien typechecking algorithms longo models subtyping benjamin pierce dynamic types 
page 
appendix 
syntax id ranges non terminal identifiers range syntactic expressions 
page id non terminal identifier id defined id non terminal symbol terminal symbol empty input ide alphanumeric identifier token initial letter infix infix symbolic identifier token 
char character token escapes string string token abc escapes int integer token real real token means followed binds strongest means means means means program interface module linkage binding interface unsound interface ide import import export signature module unsound module ide ide import import export binding linkage import import import ide kind ide type power type kind ide ide kind type ide ide ok bool char string int real array type exception signature type tuple signature option auto ide signature record variant fun type rec ide type type type infix type type ide type value ide ok true false char string integer real binding binding elsif binding binding binding binding loop binding exit binding binding ide binding upto downto binding binding fun signature type value value binding value infix isnot value tuple binding auto ide type binding option ide ordinal value type binding record variant var ide type value value ide case binding array value binding binding value value value inspect binding exception ide type raise value value type try binding value signature var hastype def def rec typedecl var hastype signature signature binding def def rec typedecl rec typedecl rec kind type var value value value type var ide value ide kind page typedecl ide type typedecl typedecl var ide hastype value signature type ide type binding binding type type binding binding binding ide type binding binding hastype type type var type type kind ide ide operators ok bool char string int real ok true false prefix monadic extent ordinal infix isnot keywords def power type array auto def exception fun option rec record tuple var variant array auto case downto elsif exception exit export fun import inspect interface loop module option raise rec record try tuple unsound upto var variant 
notes keywords appear actual parameter bindings 
bindings evaluated single result value component modulo manifest declarations 
bindings construct may type type array elements contain values 
recursive value bindings contain constructors functions tuples page 
type rules complete semantics quest take pages think written structural operational semantics plotkin techniques developed abadi cardelli pierce plotkin dynamic types 
see harper milner tofte full formal language definition style 
section contains type rules miniature quest language scaled notions values types kinds bindings signatures presents essential concepts 
syntax signatures types operators type identifiers tuple fun bindings rec type values value identifiers fun kinds tuple bind type rec power construct bind binds components tuple identifiers scope 
full quest notation extract types values tuple denoted identifier 
program fragment 

corresponds bind 



type rule bind prevents type identifiers occurring type result 
similarly full quest types allowed escape scope 
formal relation bind studied cardelli leroy 
judgments sig signature signature kind kind kind type type type type subsignature equivalent signatures equivalent kinds subtype equivalent types power notation concatenation iterated extension 
signatures bindings ordered sequences freely notation dom type defined dom value defined 
similarly bindings 
page denote substitution type variable type variable value expression sort 
binding defined follows 
indicates subexpression expression denotes substitution particular occurrence expressions sort 
type contractive free type variable macqueen plotkin sethi written type variable different function tuple type operator application reduced form contractive recursive type body contractive body legal recursive type contractive recursion variable 
type recursion bodies contractive recursion variables construct formed regular infinite tree 
equivalence page kind congruence inclusion kind sig subsumption conversion fun sig kind sig kind sig rec type type rec type rec type signatures apple sig bindings kinds sig apple apple sig type kind types operators values sig kind dom sig fun sig tuple tuple kind kind kind type type fun subtypes type dom sig type power kind sig tuple type tuple type bind type power type sig tuple tuple rec type type rec type type type rec type rec type type type rec type type rec power power page 
library interfaces list supplied modules interface specification follows 
modules pre linked top level explicitly imported module uses 
page array operations ascii ascii ascii conversions conv conv string conversions dynamic dynamic dynamically typed values int integer number operations list list polymorphic lists reader reader input operations real real number operations trig trig defined string string operations value value arbitrary value operations 
unsound 
writer writer output operations interface export error exception ok raised operation carried 
new type size int init array create new array size initialized init 
size type array array int return size array size array predefined 
get type array array index int extract array element array index 
set type array array index int item ok update array element array index item 
interface ascii export error exception ok raised operation carried 
char int char return character ascii encoding raise error 
val char int return ascii encoding character interface conv export okay string return string ok 
bool bool string return true true false 
int int string return string representation integer preceded negative 
real real string return string representation real preceded negative 
char char string return string containing character single quotes backslash encoding necessary 
string string string return string containing string double quotes backslash encoding necessary 
interface dynamic import reader reader writer writer export def auto type pair arbitrary object type 
error exception ok raised operation carried 
new type package object type object type type object generated object type return raise error 
copy complete copy dynamic object 
extern wr writer ok write representation dynamic object writer 
intern rd reader read dynamic object reader 
interface export error exception ok raised operation carried 
maxint int negative positive representable integers 
abs int int absolute value 
min max int int min max 
interface list export type type list list implementation interface list list items type error exception ok raised operation carried 
nil type cons type null type bool head type tail type length type int enum type array list enum returns list elements 
page interface reader export type reader source characters 
error exception ok raised operation carried 
input standard input reader 
file name string reader file file name 
reader bool test characters read 
ready reader int counts number characters read blocking stream marker counts 
blocks 
getchar reader char read character reader 
reader size int string read string size reader 
reader string string start size int ok read string size reader store string position 
close reader ok close reader operations fail 
interface export error exception ok raised operation carried 
real negative positive representable reals 
real positive representable negative real negative representable positive real 
real int int real floor round real int abs log real real min max real real interface export error exception ok raised operation carried 
new size int init char string create new string give size initialized init 
isempty string string bool test string empty 
length string string int return length string 
getchar string string index int char extract character string 
string string index int char char ok replace character string 
source string start size int string extract substring string 
page dest string int source string int ok replace substring string 
cat string string string string concatenate strings 
string string start size int string string start size int string concatenate substrings 
equal string string string bool true strings size contents 
string string start size int string string start size int bool true substrings size contents 
precedes string string string bool true strings equal lexicographic order 
string string start size int string string start size int bool true substrings equal lexicographic order 
unsound interface value export type type arbitrary value 
error exception ok raised operation carried 
length int implementation dependent size value implementation dependent units 
new type convert value 
type convert value 
unsound 
fetch addr int fetch value location addr memory 
store addr int ok store value location addr memory 
unsound 
interface writer export type writer sink characters 
error exception ok raised operation carried 
output standard output writer 
file name string writer file file name 
flush writer ok flush buffered characters final destination 
putchar writer char char ok write character writer 
writer string string ok write string writer 
writer string string start size int ok write substring string writer 
page close writer ok close writer operations fail 
page abadi cardelli pierce plotkin abadi cardelli pierce plotkin dynamic typing statically typed language proc 
popl 
amadio cardelli amadio cardelli subtyping recursive types dec src report appear 
andrews schneider andrews schneider concepts notations concurrent programming computer surveys vol 
march 
atkinson bailey chisholm cockshott morrison atkinson bailey chisholm cockshott morrison approach persistent programming computer journal november 
barendregt barendregt lambda calculus syntax semantics north holland 
hm berarducci hm berarducci automatic synthesis typed programs term algebras theoretical computer science pp 

buneman ohori buneman ohori powerdomains generalize relational databases submitted publication 
burstall lampson burstall lampson kernel language data types modules semantics data types lecture notes computer science springer verlag 
cardelli cardelli amber combinators functional programming languages proc 
th summer school le val france may 
lecture notes computer science springer verlag 
cardelli cardelli types data oriented languages proceedings conference extending database technology venice italy march 
cardelli donahue glassman jordan kalsow nelson cardelli donahue glassman jordan kalsow nelson modula report revised report dec systems research center november 
cardelli leroy cardelli leroy types dot notation proceedings ifip tc working conference programming concepts methods april 
cardelli longo cardelli longo semantic basis quest proceedings th acm lisp functional programming conference nice france june 
cardelli wegner cardelli wegner understanding types data abstraction polymorphism computing surveys vol pp december 
coquand huet coquand huet constructions higher order proof system mechanizing mathematics technical report inria may 
cook hill canning cook hill canning inheritance subtyping proc 
popl 
courcelle courcelle fundamental properties infinite trees theoretical computer science pp 

dahl nygaard dahl nygaard simula algol simulation language comm 
acm vol pp 

demers donahue demers donahue revised report russell tr computer science department cornell university 
futatsugi goguen jouannaud meseguer futatsugi goguen jouannaud meseguer principles obj proc 
popl 
page girard girard une extension de interpr tation de del analyse son application des coupures dans analyse la th orie des types proceedings second scandinavian logic symposium fenstad ed 
pp 
north holland 
gordon milner wadsworth gordon milner wadsworth edinburgh lcf springer verlag lecture notes computer science 
harbison steele harbison steele jr manual prentice hall 
harper milner tofte harper milner tofte definition standard ml version report lfcs dept computer science university edinburgh 
hyland pitts hyland pitts theory constructions categorical semantics models categories computer science logic proc 
boulder contemporary math amer 
math 
soc providence ri 
kemeny kurtz kemeny kurtz basic programming john wiley sons 
kowalski kowalski logic problem solving north holland 
krasner krasner ed smalltalk 
bits history words advice addison wesley 
landin landin programming languages comm acm vol 
pp 

liskov liskov abstraction mechanisms clu comm acm 
liskov guttag liskov guttag abstraction specification program development mit press cambridge ma 
lucassen gifford lucassen gifford polymorphic effect systems proc 
popl 
macqueen macqueen modules standard ml proc 
symposium lisp functional programming austin texas august pp 
acm new york 
macqueen plotkin sethi macqueen plotkin sethi ideal model recursive polymorphic types information control pp 

martin martin intuitionistic type theory notes giovanni sambin series lectures university padova italy june 
milner milner proposal standard ml proc 
symposium lisp functional programming austin texas august pp 

acm new york 
mitchell plotkin mitchell plotkin types existential type proc 
popl 
mitchell maybury sweet mitchell maybury sweet mesa language manual xerox parc csl april 
mycroft keefe mycroft keefe polymorphic type system prolog artificial intelligence pp 
north holland 
parnas parnas criteria decomposing systems modules communications acm vol 
pp 
december 
plotkin plotkin structural approach operational semantics report daimi fn computer science department aarhus university 
reynolds reynolds theory type structure colloquium sur la programmation pp 
springer verlag lecture notes computer science 
reynolds reynolds preliminary design programming language forsythe report cmu cs carnegie mellon university 
page schaffert cooper kilian schaffert cooper kilian trellis owl proc 
oopsla 
strachey strachey fundamental concepts programming languages lecture notes international summer school computer programming copenhagen august 
strom yemini strom yemini nil integrated language system distributed programming proc 
sigplan symposium programming language issues software systems 
stroustrup stroustrup programming language addison wesley 
turner turner miranda non strict functional language polymorphic types functional programming languages computer architecture lecture notes computer science springer verlag 
weinreb moon weinreb moon lisp machine manual symbolics 
wirth wirth programming modula texts monographs computer science springer verlag 
wirth wirth modula oberon programming language oberon report institut informatik eth rich 
page 
