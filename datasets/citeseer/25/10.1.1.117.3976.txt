simple fast practical non blocking blocking concurrent queue algorithms drawing ideas previous authors new non blocking concurrent queue algorithm new queue algorithm enqueue dequeue proceed concurrently 
algorithms simple fast practical surprised find literature 
experiments node sgi challenge multiprocessor indicate new non blocking queue consistently outperforms best known alternatives clear algorithm choice machines provide universal atomic primitive compare swap load linked store conditional 
lock concurrent queue outperforms single lock processes competing simultaneously access appears algorithm choice busy queues machines non universal atomic primitives test set 
motivation non blocking algorithms rooted immunity large unpredictable delays process execution report experimental results systems dedicated processors systems processes multiprogrammed processor 
keywords concurrent queue lock free non blocking compare swap multiprogramming 
supported part nsf nos 
cda ccr onr research 
conjunction darpa research information science technology high performance computing software science technology program arpa order 
michael michael scott department computer science university rochester rochester ny cs rochester edu concurrent fifo queues widely parallel applications operating systems 
ensure correctness concurrent access shared queues synchronized 
generally algorithms concurrent data structures including fifo queues fall categories blocking non blocking 
blocking algorithms allow slow delayed process prevent faster processes completing operations shared data structure indefinitely 
nonblocking algorithms guarantee active processes trying perform operations shared data structure operation complete finite number time steps 
asynchronous especially multiprogrammed multiprocessor systems blocking algorithms suffer significant performance degradation process halted delayed moment 
possible sources delay include processor scheduling preemption page faults cache misses 
non blocking algorithms robust face events 
researchers proposed lock free algorithms concurrent fifo queues 
hwang briggs sites stone lock free algorithms swap 
algorithms incompletely specified omit details handling empty single item queues concurrent enqueues dequeues 
lamport presents wait free algorithm restricts concurrency single single 
gottlieb mellor crummey algorithms lock free non blocking locking mechanisms allow slow process delay faster processes indefinitely 
compare swap introduced ibm system takes arguments address shared memory location expected value new value 
shared location currently holds expected value assigned new value atomically 
boolean return value indicates replacement occurred 
wait free algorithm non blocking starvation free guarantees active process progress bounded number time steps 
treiber presents algorithm non blocking inefficient dequeue operation takes time proportional number elements queue 
herlihy prakash lee johnson turek shasha prakash barnes propose general methodologies generating non blocking versions sequential concurrent lock algorithms 
resulting implementations generally inefficient compared specialized algorithms 
massalin pu lock free algorithms double compare swap primitive operates arbitrary memory locations simultaneously available members motorola family processors 
herlihy wing array algorithm requires infinite arrays 
valois presents array algorithm requires swap supported architecture motorola double compare swap :10.1.1.53.8674
stone presents queue lock free non blocking 
non linearizable slow may cause faster process enqueue item subsequently observe empty queue enqueued item dequeued 
non blocking slow enqueue delay dequeues processes indefinitely 
experiments revealed race condition certain interleaving slow dequeue faster enqueues dequeues process es cause enqueued item lost permanently 
stone presents non blocking queue circular singly linked list 
algorithm uses anchor pointer manage queue usual head tail 
experiments revealed race condition slow cause enqueued item lost permanently 
prakash lee johnson linearizable non blocking algorithm requires enqueuing dequeuing processes take snapshot queue order determine state prior updating 
algorithm achieves non allowing faster processes complete operations slower processes waiting 
valois presents list non blocking algorithm avoids contention caused snapshots prakash algorithm allows concurrency keeping dummy node head dequeue singly linked list simplifying special cases associated empty single item queues technique suggested sites :10.1.1.53.8674
unfortunately algorithm allows tail pointer lag head pointer preventing dequeuing processes safely freeing re implementation data structure linearizable give external observer observing data structure operations illusion operations takes effect instantaneously point invocation response 
dequeued nodes 
tail pointer lags process frees dequeued node linked list broken subsequently enqueued items lost 
memory limited resource prohibiting memory reuse acceptable option 
valois proposes special mechanism free allocate memory 
mechanism associates counter node 
time process creates pointer node increments node counter atomically 
intend access node accessed decrements associated counter atomically 
addition temporary links process local variables counter reflects number links data structure point node question 
queue head tail pointers linked list links 
node freed pointers data structure temporary variables point 
discovered corrected race conditions memory management mechanism associated nonblocking queue algorithm 
memory management mechanism queue employs impractical finite memory guarantee satisfy memory requirements algorithm time 
problems occur process reads pointer node incrementing counter delayed 
running processes enqueue dequeue arbitrary number additional nodes 
pointer held delayed process node referenced pointer successors freed 
possible run memory number items queue bounded constant 
experiments queue maximum length items ran memory times runs enqueues dequeues free list initialized nodes 
algorithms mentioned compare swap deal aba problem process reads value shared location computes new value attempts swap operation swap may succeed read compare swap process es change back 
common solution associate modification counter pointer access counter pointer compare swap sequence increment swap 
solution guarantee aba problem occur extremely 
implement solution employ double word compare swap array indices pointers may share single word counter 
valois counting technique guarantees preventing aba problem need modification counters double word compare swap 
mellor crummey lock free queue requires special precautions avoid aba problem swap fetch store modify swap sequence usual read modify compare swap sequence 
feature algorithm blocking 
section new concurrent fifo queue algorithms inspired ideas described 
algorithms simple practical 
non blocking uses pair locks 
correctness algorithms discussed section 
experimental results section 
node sgi challenge multiprocessor compare new algorithms straightforward single lock queue mellor crummey blocking algorithm non blocking algorithms prakash valois dedicated multiprogrammed workloads 
results confirm value non multiprogrammed systems 
show consistently superior performance part new lock free algorithm multiprogramming 
new lock algorithm compete non blocking alternatives multiprogrammed system outperforms single lock processes compete access simultaneously 
section summarizes 
algorithms presents commented pseudo code nonblocking queue data structure operations 
algorithm implements queue singly linked list head tail pointers 
valois algorithm head points dummy node node list 
tail points second node list 
algorithm swap modification counters avoid aba problem 
allow dequeuing processes free dequeued nodes dequeue operation ensures tail point dequeued node predecessors 
means dequeued nodes may safely re 
obtain consistent values various pointers rely sequences reads re check earlier values sure haven changed 
sequences reads similar simpler snapshots prakash 
need check shared variable 
similar technique prevent race condition stone blocking algorithm 
treiber simple efficient non blocking stack algorithm implement non blocking free list 
presents commented pseudo code queue data structure operations 
algorithm employs separate head tail locks allow complete concurrency enqueues dequeues 
non blocking queue keep dummy node list 
dummy node access head access tail avoiding potential deadlock problems arise processes trying acquire locks different orders 
correctness safety algorithms safe satisfy properties 
linked list connected 

nodes inserted node linked list 

nodes deleted linked list 

head points node linked list 

tail points node linked list 
initially properties hold 
induction show continue hold assuming aba problem occurs 

linked list connected node inserted pointer set null freed node freed deleted list property 

lock free algorithm nodes inserted linked list linked tail pointer points node linked list property inserted node linked node null pointer node linked list property 
lock algorithm nodes inserted linked list inserted node pointed tail algorithm tail points node linked list protected tail lock 

nodes deleted list deleted pointed head head points node list property 

head points node list changes value node atomically head lock swap 
happens node point considered deleted list 
new value head null node linked list dequeue operation returns deleting nodes 
structure pointer pointer node count unsigned structure node data type pointer tg structure queue fhead pointer tail pointer tg initialize pointer queue node new node allocate free node node ptr null node linked list head tail node head tail point enqueue pointer queue value data type node new node allocate new node free list node value value copy enqueued value node node ptr null set pointer node null loop keep trying enqueue done tail tail read tail ptr tail count tail ptr read ptr count fields tail tail tail consistent 
ptr null tail pointing node 
cas tail ptr node count try link node linked list break enqueue done 
exit loop endif tail pointing node cas tail tail ptr tail count try swing tail node endif endif endloop cas tail tail node tail count enqueue done 
try swing tail inserted node dequeue pointer queue pointer data type boolean loop keep trying dequeue done head head read head tail tail read tail head read head ptr head head head tail consistent 
head ptr tail ptr queue empty tail falling 
ptr null queue empty 
return false queue empty couldn dequeue endif cas tail tail ptr tail count tail falling 
try advance need deal tail read value cas dequeue free node ptr value cas head head ptr head count try swing head node break dequeue done 
exit loop endif endif endif endloop free head ptr safe free old dummy node return true queue empty dequeue succeeded structure operation non blocking concurrent queue 
structure node data type pointer node tg structure queue fhead pointer node tail pointer node lock lock type lock lock typeg initialize pointer queue node new node allocate free node node ptr null node linked list head tail node head tail point lock lock free locks initially free enqueue pointer queue value data type node new node allocate new node free list node value value copy enqueued value node node ptr null set pointer node null lock lock acquire lock order access tail tail node link node linked list tail node swing tail node unlock lock release lock dequeue pointer queue pointer data type boolean lock lock acquire lock order access head node head read head new head node read pointer new head null queue empty 
unlock lock release lock return return false queue empty endif new head value queue empty 
read value release head new head swing head node unlock lock release lock free node free node return true queue empty dequeue succeeded structure operation lock concurrent queue 

tail points node linked list lags head point deleted node 
tail changes value swings node list tries change value pointer null 
linearizability algorithms linearizable specific point operation considered take effect 
enqueue takes effect allocated node linked node linked list 
dequeue takes effect head swings node 
shown previous subsection properties queue variables reflect state queue enter transient state state queue mistaken non empty queue appears empty 
liveness lock free algorithm non blocking lock free algorithm non non delayed processes attempting perform operations queue operation guaranteed complete finite time 
enqueue operation loops condition line fails condition line fails compare swap line fails 
dequeue operation loops condition line fails condition line holds queue empty compare swap line fails 
show algorithm non blocking showing process loops finite number times process completes operation queue 
condition line fails tail written intervening process executing line 
tail points second node linked list modified follows pointer node points 
condition line fails process succeeded completing enqueue operation 
condition line fails tail pointing second node linked list 
compare swap line tail point node list process succeeded enqueuing new item 
condition line fails process succeeded completing enqueue operation 
swap line fails process succeeded enqueuing new item queue 
condition line compare swap line fail head written process 
head written process succeeds dequeuing item 
condition line succeeds queue empty tail points second node linked list case node 
compare swap line tail point node list process succeeded enqueuing new item 
condition line succeeds process succeeded completing enqueue operation process succeeded dequeuing item 
lock algorithm livelock free lock algorithm contain loops 
mutual exclusion lock locking unlocking head tail locks livelock free livelock free 
mutual exclusion algorithms livelock free 
performance processor silicon graphics challenge multiprocessor compare performance new algorithms single lock algorithm algorithm prakash valois algorithm corrections memory management mechanism mellor crummey algorithm 
include algorithm prakash appears best known non blocking alternatives 
mellor crummey algorithm represents non lock blocking alternatives simpler code prakash expected display lower constant overhead absence unpredictable process delays degenerate multiprogrammed system 
include valois demonstrate multiprogrammed systems comparatively inefficient non blocking algorithm outperform blocking algorithms 
lock algorithms test set locks bounded exponential backoff 
backoff appropriate non lock algorithms 
performance sensitive exact choice backoff parameters programs modest amount queue operations 
emulate test set atomic operations required algorithms compare swap fetch increment fetch decrement mips load linked conditional instructions 
ensure accuracy experimental results multiprocessor exclusively prevented users accessing experiments 
evaluate performance algorithms different levels multiprogramming feature challenge multiprocessor allows programmers associate processes certain processors 
example represent dedicated system multiprogramming permitted created processes number processors wanted locked process different processor 
order represent system multiprogramming level created twice processes number processors wanted locked pair processes individual processor 
code tested algorithms obtained ftp cs rochester edu pub packages sched conscious synch concurrent queues 
algorithms compiled highest optimization level carefully 
tested algorithms hours long executions various numbers processors 
process discovered race conditions mentioned section 
experiments employ initially empty queue processes perform series enqueue dequeue operations 
process enqueues item dequeues item repeats 
processes process executes loop pc pe times total dequeues 
consists approximately sof empty loop serves experiments realistic preventing long runs queue operations process overly optimistic performance due unrealistically low cache rate 
subtracted time required processor com plete total time reported figures 
shows net elapsed time seconds enqueue dequeue pairs 
roughly speaking corresponds time microseconds enqueue dequeue pair 
precisely processors graph shows time processor spends performing enqueue dequeue pairs plus amount critical path pairs performed processors exceeds time spent processor loop overhead 
second term zero 
increases term shrinks zero second term approaches critical path length computation times serial portion enqueue dequeue pair 
exactly execution overlap different processors depends choice algorithm number processors length queue operations 
processor memory loop iteration hit cache completion times low 
processors active contention head tail pointers queue elements causes high fraction cache leading substantially higher completion times 
queue operations processor fit time processor vice versa effectively measuring time processor complete enqueue dequeue pairs 
processors cache rate processors 
processor perform enqueue dequeue pairs operations processors longer fit processor time 
total elapsed time decreases fraction 
right hand side graph execution time rises algorithms smaller smaller amounts processor loop overhead subtracted total time dominated critical path length 
single lock mellor crummey curves increase probably accelerated high rates contention increase average cost cache valois algorithm plotted time continues decrease memory management overhead moves critical path overlapped part computation 
figures plot quantity system processes processor respectively 
operating system multiplexes processor processes scheduling quantum ms expected blocking algorithms fare worse presence multiprogramming preemption block progress process system 
expected degree performance degradation increases level multiprogramming 
graphs new non blocking queue outperforms alternatives processors active 
processors seconds single lock mc lock free valois non blocking new lock non blocking new non blocking processors net execution time enqueue dequeue pairs dedicated multiprocessor 
seconds processors net execution time enqueue dequeue pairs multiprogrammed system processes processor 
seconds processors net execution time enqueue dequeue pairs multiprogrammed system processes processor 
formance comfortably recommend situations 
lock algorithm outperforms lock algorithm processors active dedicated system appears reasonable choice machines multiprogrammed lack universal atomic primitive compare swap linked store conditional 
queues ubiquitous parallel programs performance matter major concern 
concurrent queue algorithm simple nonblocking practical fast 
surprised find literature 
algorithm choice queue application multiprocessor universal atomic primitives compare swap load linked store conditional 
queue separate head tail pointer locks 
structure similar nonblocking queue allows enqueue dequeue proceed time 
locks machines simple atomic primitives test set 
recommend heavily utilized queues machines queue usually accessed processors single lock run little faster 
part larger project seeks evaluate tradeoffs alternative mechanisms atomic update common data structures 
structures consideration include stacks queues heaps search trees hash tables 
mechanisms include single locks datastructure specific multi lock algorithms general purpose special purpose non blocking algorithms function shipping centralized manager valid technique situations remote access latencies dominate computation time 
related developing general purpose synchronization mechanisms cooperate scheduler avoid preemption 
immunity processes delays primary benefit non blocking parallel algorithms plan compare approaches context multiprogrammed systems 
anderson 
performance spin lock alternatives shared memory multiprocessors 
ieee transactions parallel distributed systems january 
barnes 
method implementing lock free data structures 
proceedings fifth annual acm symposium parallel algorithms architectures germany june july 
gottlieb rudolph 
basic techniques efficient coordination large numbers cooperating sequential processors 
acm transactions programming languages systems april 
herlihy wing 
concurrent objects 
proceedings th acm symposium principles programming languages pages january 
herlihy wing 
linearizability correctness concurrent objects 
acm transactions programming languages systems july 
herlihy 
methodology implementing highly concurrent data objects 
acm trans actions programming languages systems november 
hwang briggs 
computer architecture parallel processing 
mcgraw hill 
wisniewski 
scheduler information achieve optimal barrier synchronization performance 
proceedings fourth acm symposium principles practice parallel programming may 
lamport 
specifying concurrent program modules 
acm transactions programming languages systems april 
massalin pu 
lock free multiprocessor os kernel 
technical report cucs computer science department columbia university 
mellor crummey 
concurrent queues practical fetch algorithms 
tr computer science department university rochester november 
mellor crummey scott 
algorithms scalable synchronization shared memory multiprocessors 
acm transactions computer systems february 
michael scott 
correction memory management method lock free data structures 
technical report computer science department university rochester december 
prakash lee johnson 
non blocking algorithm shared queues compare swap 
proceedings international conference parallel processing pages ii 
prakash lee johnson 
non blocking algorithms concurrent data structures 
technical report university florida 
prakash lee johnson 
nonblocking algorithm shared queues compare swap 
ieee transactions computers may 
sites 
operating systems computer architecture 
stone editor computer architecture nd edition chapter 
science research associates 
stone 
simple correct shared queue algorithm compare swap 
proceedings supercomputing november 
stone 
non blocking compare swap algorithm shared circular queue 
editors parallel distributed computing engineering systems pages 
elsevier science publishers 
stone 
high performance computer architecture 
addison wesley 
treiber 
systems programming coping parallelism 
rj ibm almaden research center april 
turek shasha prakash 
locking blocking making lock concurrent data structure algorithms nonblocking 
proceedings th acm sigact sigmod sigart symposium principles database systems pages 
valois :10.1.1.53.8674
implementing lock free queues 
seventh international conference parallel distributed computing systems las vegas nv october 
valois 
lock free data structures 
ph 
dissertation rensselaer polytechnic institute may 
wisniewski scott 
scalable spin locks multiprogrammed systems 
proceedings eighth international parallel processing symposium pages cancun mexico april 
earlier expanded version available tr computer science department university rochester april 
wisniewski scott 
high performance synchronization algorithms multiprogrammed multiprocessors 
proceedings fifth acm symposium principles practice parallel programming santa barbara ca july 
