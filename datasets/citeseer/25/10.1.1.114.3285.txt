checking system rules system specific programmer written compiler extensions dawson engler benjamin chelf andy chou seth hallem lambda computer systems laboratory stanford university stanford ca systems software os kernels embedded systems libraries obey rules correctness performance 
common examples include accesses variable guarded lock system calls check user pointers validity message handlers free buffers quickly possible allow greater parallelism 
unfortunately adherence rules largely unchecked 
attacks problem showing system implementors meta level compilation mc write simple system specific compiler extensions automatically check code rule violations 
domain specific knowledge automatic machinery compilers mc brings benefits language level checking optimizing higher meta level systems implemented languages 
demonstrates effectiveness mc approach applying complex real systems linux openbsd xok exokernel flash machine embedded software 
mc extensions roughly errors systems led numerous kernel patches 
extensions lines code written implementors limited understanding systems checked 
systems software obey rules check user permissions modifying kernel data structures speed enforce mutual exclusion spin locks disabling interrupts message handlers free buffer completing 
lambda research supported part darpa contract mda fellowship 
code obey rules degrade performance crash system 
methods find violations system rules 
rigorous way build specification code model checkers theorem provers checkers check specification internally consistent 
applicable formal verification finds errors difficult detect means 
specifications difficult costly construct 
specifications necessarily mirror code practice suffer missing features simplifications 
begun attacking problems extremely rare software verified 
common method detect rule violations testing 
testing simpler verification 
avoids mirroring problems formal verification working actual code abstraction 
testing dynamic numerous disadvantages 
number execution paths typically grows exponentially code size 
thorough precise testing requires writing test cases exercise paths drive system error states 
effort required create tests time takes run scales amount code 
result real systems paths rarely hit testing errors manifest days continuous execution 
finding cause test failure difficult especially effect delayed system crash 
testing requires running tested code create significant practical problems 
example testing device drivers os requires acquiring possibly hundreds thousands devices understanding thoroughly exercise 
common method detect rule violations manual inspection 
method strength consider semantic levels adapt ad hoc coding conventions system rules 
unfortunately systems millions lines code deep complex code paths 
reasoning single path take minutes dealing concurrency hours 
reliability manual inspection erratic 
methods leave implementors unfortunate situation 
verification impractical systems 
testing misses cases diagnosis difficult 
manual inspection unreliable tedious 
possible alternative static compiler analysis find rule violations 
verification compilers code removing need write maintain specification 
testing static analysis examine execution paths errors code conveniently executed 
compiler analysis pass reduces need construct numerous test cases scales single function entire system little increase manual effort 
compilers enforce systems rules rules straightforward mapping program source 
rule violations checking source operations sense level 
example ordering rules interrupts enabled disabled reduce observing order function calls idiomatic sequences statements case call disable interrupt function followed re enable call 
main barrier compiler checking optimizing level precise understanding semantics input code typically idea meta semantics software system code constructs 
check properties inexpressible just expressed terms underlying language type system 
leaves unfortunate dichotomy 
implementors understand semantics system operations build mechanisms check exploit semantics automatically 
compilers machinery domain ignorance prevents exploiting 
shows automatically check systems rules meta level compilation mc 
mc attacks problem making easy implementors extend compilers lightweight checkers optimizers 
extensions written system implementors take account ad hoc bizarre semantics system 
compiler get benefits automatic static analysis 
mc system implementors write extensions high level state machine language metal 
extensions dynamically linked extensible compiler xg applied flow paths functions program source input 
language patterns recognize operations care 
input code matches patterns detect rule violations transitioning states allow disallow operations 
primary contribution demonstration mc general effective approach finding system errors 
important results 
mc checkers find serious errors complex real systems code 
series extensions roughly errors systems linux kernel openbsd xok exokernel flash machine embedded cache controller code 
errors worst type systems bugs crash system running continuously days 

mc optimizers discover system level opportunities difficult find manual inspection 
main focus error checking mc extensions optimization 
section describes flash specific mc optimizers hundreds system level optimization opportunities 

mc extensions simple 
extensions mentioned typically lines code 
practical result experience mc majority extensions written programmers passing familiarity systems checked 
writing code obeys system rules quite difficult rules easy express 
writing checkers relatively straightforward 
laid follows 
section discusses related 
section gives overview mc system implement 
section applies approach assert macro shows limited domain mc provides non trivial benefits 
section shows mc enforce ordering constraints checking kernels verify user pointers 
section extends global system wide constraints 
section detailed case study mc check linux locking interrupt disabling re enabling disciplines 
section describes flash optimizers section concludes 
related proposed initial idea mc provided simple system lcc ansi compiler 
original examples provided experimental evaluation 
provides developed view mc significantly easier powerful framework building extensions experimental demonstration effectiveness 
concurrently detailed case study applying mc flash system 
compiler extensions discovered errors flash code potentially crash machine message handlers lost double freed hardware message buffers buffer race conditions 
main difference demonstration mc general technique applying variety systems 
broader scope lacks detail finds roughly factor errors 
compare efforts highlevel compilation verification extensible compilers 
higher level compilation 
projects hard wired application level information compilers 
projects include compiler directed management eraser dynamic race detection checker insure check unix system call errors static analysis check security errors privileged programs gnu compilers wall option warns dangerous functions questionable programming practices :10.1.1.161.222
related checkers microsoft internal tool finding fixed set coding violations windows device drivers errors handling bit code missing user pointer validity checks 
projects compiler support analyze specific problems mc explicitly argues general compilers check optimize systems provides extensible framework doing 
extensibility enables detection rule violations impossible find knowledge 
systems finding software errors 
approaches statically finding software errors center formal verification discussed section strong type checking 
verification uses stronger analysis mc extensions 
mc extensions appear generally effective 
best knowledge verification papers tend find small number errors typically mc checkers hundreds 
verification lower bug counts largely due difficulty writing specifications scales code size 
consequence small pieces code verified 
contrast mc operates directly source code traditional compiler analyses applies easily millions lines code 
strong typing systems extended static type checking esc project prefix 
systems stronger analyses approach 
check fixed set low level errors buffer overruns null pointer 
lack extensibility means exception esc support finding class race conditions system find system level errors mc detect 
lclint statically checks programmer source annotations detect coding errors abstraction barrier violations 
esc lclint extensible prevents finding errors mc find 
source annotations lclint requires scale code size significantly increasing manual effort needed apply 
extensible compilation 
number open compiler systems allow programmers add analysis routines usually modeled extensions traverse compiler syntax tree 
include lord allows scheme extensions walk syntax tree crew prolog lamping kiczales argue pushing domain specific information compilation 
meta object protocols mops allow programs augmented meta part controls base 
protocols typically dynamic fairly limited analysis abilities 
shigeru chiba open provides static mop allows users extend compilation process 
extensions systems mainly limited syntax tree traversal transformation data flow information 
result powerful mc extensions difficult 
current language approach dramatic improvement previous tree systems extensions times smaller bugs handle cases 
best knowledge open provide experimental results making difficult evaluate effectiveness 
lower level atom object code cation system gives users ability modify object code clean simple manner 
focusing machine code atom situations mc requires source code 
dynamic testing schemes served object level modifications difficult perform static checks semantic information available compiler 
concurrently original kiczales proposed aspect oriented programming aop way combining code manages aspects synchronization code needs :10.1.1.115.8660
aop advantage integrated traditional language framework 
disadvantage aspects limited scope mc extensions survey entire system check rules difficult enforce aop framework preventing kernel code floating point 
aop requires source modifications retro fitting systems check non trivial 
meta level compilation systems constraints describe legal orderings operations specific contexts operations occur 
actions relevant rules visible program source mc compiler extension check searching corresponding operations verifying obey ordering contextual restrictions 
table gives representative set rule templates checked manner examples 
system rules roughly follow templates checked automatically 
example mc extension enforce contextual rule speed shared variable modified protect read locks search write lock critical section examine variable uses stores occur protected variables demote locks suggest alternative usage 
language overview implementation mc compiler extensions written high level state machine language metal 
extensions dynamically linked extensible compiler xg gnu compiler 
xg translates input function internal representation extensions applied possible execution path function 
state machine part language viewed syntactically similar yacc specification 
typically sms patterns include linux includes sm check interrupts variables patterns decl unsigned flags patterns specify enable disable functions 
pat enable sti restore flags flags pat disable cli states state initial state 
enabled disable 
disabled enable 
err double enable disabled enable 
enabled disable 
err double disable special pattern matches sm hits path state 
path 
err exiting intr disabled metal sm detect interrupts disabled cli re enabled sti restore flags duplicate enable disable calls 
search interesting source code features matched cause transitions states 
patterns written extended version base language match arbitrary language constructs declarations expressions statements 
expressing patterns base language flexible easy closely mirror source constructs describe 
shows stripped metal extension linux checks disabled interrupts restored initial state exiting function 
interrupts disabled calling cli procedure enabled calling sti restored restore flags flags flags variable holds interrupt state cli issued 
conceptually extension finds violations checking call disable interrupts matching enable call outgoing paths 
refinements extension warns duplicate calls functions non sequitur calls re enabling disabling 
complete version checker described section errors linux code 
extension tracks interrupt status rule template examples floating point kernel 
allocate large variables byte kernel stack 
send messages virtual network lane 
allocate storage object needs 
memory mapped copying 
avoid globally disabling interrupts 
check user pointers kernel 
handle operations fail memory disk block virtual interrupt allocation 
re enable interrupts disabling 
release locks acquiring 
check user permissions modifying kernel data structures 
acquire lock 
memory freed 
deallocate object acquire release lock twice 
increment module count calling function sleep 
situation protect variable mutations write locks 
system call fails reverse side effect operations deallocate memory disk blocks pages counters 
avoid deadlock interrupts disabled call functions sleep 
situation variable modified protect read locks 
code share data interrupt handlers spin locks expensive interrupt disabling 
save instruction setting message opcode xor new old opcode assignment 
table sample system rule templates examples 
checkers rule denoted section number 
linux drivers block raid static struct buffer head get free buffer struct stripe head sh int size struct buffer head bh unsigned long flags save flags flags cli bh sh buffer pool null return null sh buffer pool bh bh size size restore flags flags return bh example code linux raid driver illustrating real error caught extension 
sm applied paths function 
path return bh formed accepted 
path return null get warning re enabling interrupts 
states enabled disabled 
sms start state mentioned transition definition enabled 
state set rules specifying pattern optional state transition optional action 
actions arbitrary code 
state metal checks pattern rules lexical order 
code matches specified patterns metal processes matching code sets state new state token 
operator executes action 
example enabled rules 
rule searches functions disable interrupts disable pattern transitions disabled state 
second rule searches calls functions enable interrupts gives warning 
specify transition state sm remains enabled state 
pattern matches sm remains state continues current code path 
flags variable wild card matches expression type unsigned 
matched metal put matching expression flag action 
feature extension discussed section 
run sm compiled mcc metal compiler 
dynamically linked xg compile time command line flag 
run linux raid driver buffer allocation code pushed paths function 
path returns null buffer pool empty statement fails returns buffer successful allocation 
path fails re enable interrupts error caught reported extension 
way get feel costly manually perform check sm automatically showed experienced linux programmer exact error took minutes examine single call chain leading function 
performing similar analysis hundreds thousands lines driver kernel code impractical 
practical issues metal sms specify applied paths flow sensitive linearly code flow insensitive 
simple implementation flow sensitive sms take exponential time cases 
aggressive caching prune redundant code paths sm instances follow paths join statements loops reach join point state 
caching fact deterministic sm applied input internal state compute result 
system represents state sm vector holding value variables 
node input flow graph records set states visited 
sm arrives node state previous instance system prunes 
caching originally motivated speed important feature provides clean framework computing loop fixed points transparently 
sm exhausted set states reachable loop typically iterations metal automatically stops traversing loop 
fixed point behavior depends sm having finite small number states 
currently enforce restriction 
current xg system integrate global analysis sm framework 
provides library routines emit client annotated flow graphs file read traversed 
section gives example framework compute transitive closure possibly sleeping functions 
integrating passes 
interrupt disable bug masked immediate kernel segmentation fault callers function dereference returned pointer checking allocation succeeded 
caveats extensions checkers verifiers find bugs guarantee absence 
example ignorance aliases prevents asserting actions happen 
general compiler problems undecidable places hard limits effectiveness static analysis 
despite limitations results show mc extensions quite effective 
currently investigating turn classes checkers verifiers 
mainly check systems build 
result rule violations bugs code non obvious system feature works correctly specific situation 
countered danger ways 
sent error logs system implementors linux flash xok confirmation 
got feedback errors sheer number meant receive careful examination 
second conservatively count cases difficult reason 
results may contain mis diagnoses surprised caused percentage points difference 
checkers produce number false positives worst case section error 
due limitations static analysis checkers primarily simple local analyses 
usually numbers reduced significantly adding amount global analysis system specific knowledge 
cases false positive suppressed single source annotation 
extensions provide annotations supplying set reserved functions clients call indicate specific warning suppressed 
refinement checkers detect bogus erroneous annotations warning needed 
basing mc system compiler caused difficulties applying linux xok 
systems aggressively assume relaxed type system gnu extensions illegal 
theory mc applied system transparently modify xok linux remove gnu constructs illegal 
modified front relax type checking 
avoid labor systems currently finishing gcc implementation xg 
generally metal language designed shielded underlying language compiler plan port languages compilers 
remainder describes extensions implemented metal xg results applying concept meta level compilation real systems 
simple meta language assert macro takes single condition argument checks condition runtime aborts execution condition false 
macro defines simplest meta languages possible state single operation 
section shows mc help simple interfaces presenting extensions check assertion invariants 
assertions non debugging sideeffects 
frequently assert development turned production code 
assert condition important side effects disappear program behave incorrectly 

assertion conditions fail 
programmers assertions check conditions happen 
code path leading assertion causes boolean expression fail probably bug 
checking assertion side effects presents metal checker inspects assertion expressions side effects 
directive flow insensitive tells metal apply extension linearly input functions paths improving speed error reporting exactly message violation 
sm begins initial state start uses literal metal pattern expr find assert uses 
match metal stores assert expression variable expr 
runs start action uses metal procedure expr recurse recursively apply sm expression expr assert state 
assert state uses metal generic type match assignments pointer increments decrements type 
note assignment operator detect uses infix operators 
extension matches function call set arguments extended types patterns match nearly arbitrary code matter assert function macro modified pre processor ignore line file directives 
include assert apply sm ignoring control flow sm assert flow insensitive match expressions type decl expr combination match calls arguments decl call decl args args find assert calls 
apply sm expr state assert start assert expr 
expr recurse expr assert find side effects assert match calls args 
err function call match assignment including operators 
err assignment match increments decrements brevity 
err post increment 
err post decrement metal sm warns side effects assert uses 
call args combination 
assist developers writing extensions metal provides set generic types matching different classes types scalars pointers floats different programming constructs case labels indirections 
applied xok exos library operating system line extension violations assert uses 
false positives triggered debugging functions 
suppressed wrapping calls differently named unchecked assertion macro 
remaining fourteen cases errors crucial system code function incorrectly assertion removed 
underlying cause errors assert shorthand checking result possibly failing operations insertion page table entries deallocation shared memory regions 
typical example snippet exos mmap code insert page table entry os mmap mmap fault handler assert exos self insert pte pg pg pg va null effect removing assert condition calls mysterious virtual memory errors 
checking assertions statically assertions specify conditions programmer believes hold 
mc compilers oblivious fact assert checks occur dynamically 
mc possible find errors evaluating conditions statically quickly precisely finding errors 
wrote extension top xg 
high level uses xg dataflow routines track values scalar variables 
assert evaluates assertion expression known set values 
expression fail emits warning 
currently xg performs primitive analysis tracks set constant assignments scalar variables path 
set possible values variable just union constant assignments variable 
non constant assignments occur value considered unknown 
returning set possible values allows effectiveness checker transparently increase analysis xg powerful 
practical refinement eliminate large class false positives ignoring assertions constant fails idiomatic method programmers terminate execution impossible situations 
applied flash cache coherence code discussed section line extension errors crashed system 
errors underscore value static evaluation code heavily tested years 
missed length complexity typical flash code paths caused occur sporadically 
complexity manual detection errors difficult 
path assignment assertion violated lines apart separated statements clauses conditional compilation directives 
case beat having statements clauses conditional compilations 
exact situation leads error inspecting paths mind 
discussion library implementations inspect context invoked 
mc attack 
extension mc detect illegal actions assert uses assert implementation dynamically statically 
second extension context knowledge push dynamically evaluated conditions compile time 
similar approach certain dynamic error checks static improve performance allowing implementations specialize context memory allocator generates specialized inline allocations constant size allocation requests 
restriction side effects assertion conditions miniature example general pattern language subsetting systems impose execution context restrictive base language code written 
built extensions enforce system specific execution restrictions 
warns kernel code uses floating point 
case linux graphics driver assumes floating point calculations evaluated compile time 
compiler gcc lower optimization levels violate assumption 
second checks stack overflow 
places linux code allocated variables larger kernel stack numerous larger allocations 
led patches kernel maintainers 
similar case xok innocent looking stack allocated structure turned bytes 
addition checking systems restriction checkers optimization detecting application actions limited general case 
example threads package smaller stack sizes default derive upper bound stack usage 
temporal orderings system operations happen sequence 
sequencing rules suited compiler checking sequences frequently encoded literal procedure calls code 
allows metal extension find violations searching operations transitioning states allow disallow require operations 
section discusses extensions 
enforces rule system calls properly check application pointers passed validity 
second checks code obeys set ordering rules memory allocation deallocation 
checking copyin operating systems guard application corruption kernel memory part special routines check system call input pointers move data user kernel space 
mc extension finds errors code finding paths application pointer passing routines 
system call definition extension uses special metal pattern find pointer parameter binds tainted state 
variable state differs previous checkers single global state path 
legal operations tainted variable killed assignment passed argument functions expecting tainted inputs data movement routines output functions 
uses signaled error 
tailored version checker xok exokernel code 
detects procedures system calls exokernel naming convention routine names prefix sys refinement checker warns non routines paranoid user data routines 
examined distinct user pointers exokernel proper device code errors 
typical error command issue disk requests sys kern disk int sys disk request int sn struct xn name xn user struct buf int 
bypass direct scsi commands flags return sys disk sn pointer passed user space dereferenced statement checked 
extension signalled false positives 
due stylized nonnull pointers verified standard routines null ones allowed handled correctly lower levels 
due kernel backdoors system calls call system calls unchecked parameters 
remaining due checker lack global analysis disallowing tainted variable copies 
checking memory management kernel code uses memory managers loosely procedures malloc free 
extension checks common rules 
memory allocation fail kernel code check returned pointer valid null 

memory freed 

paths allocate memory abort error typically deallocate memory returning 
linux openbsd violation bug false bug false check error leak free underflow total table error counts linux openbsd 
checker applied times linux times openbsd 

size allocated memory size object assigned pointer holds 
shows stripped extension checks rules 
space size check error reporting code omitted 
extension previous associates variable state encoding operations legal 
pointers allocated storage exactly states unknown null null freed 
variable bound unknown state allocation site 
unknown variable compared null extension sets variable state true null path null false nonnull path null 
variable compared non null cases reversed 
initial patterns recognize check compare allocation idiom combine transitions initial variable binding 
pointers passed free transition freed state 
minor refinement variables overwritten extension stops transitioning special metal state 
checker allows dereferences null pointers 
restriction catches instances memory checked null paths freed 
catches double free errors warning freed pointers passed free 
catches cases error paths free allocated memory warning non null unchecked variable reaches return negative integer signals error path 
full version checker lines code 
get lot little extension implements flow sensitive compiler analysis pass checks rules paths takes consideration observations furnished passing conditionals 
table shows extension errors linux errors openbsd 
turned false positives respectively due handling variable copies detecting allocated memory freed cleanup routine 
common error checking result memory allocation cases linux openbsd 
linux single largest source errors allocation macro coda alloc widely coda file system code 
contains unfortunate code include linux coda linux coda alloc ptr cast unsigned long size ptr kernel malloc returns file line memset ptr size code prints helpful message failed allocation initialization memset immediately cause kernel segmentation fault 
common error freeing memory error paths linux openbsd 
typical freeing error 
idiomatic mistake exit points function forgetting free memory points 
freeing errors cause nondeterministic bugs thread re allocated freed memory 
common case paste uses code drivers isdn init dev dev unsigned char dev sh mem release mem region dev ph mem memory pointed dev freed immediately subsequent function calls 
additionally checker discovered errors 
particularly dangerous cause memory corruption routine failing high load 
caused apparent typo size memory needed structure type struct atm qos bytes computed size structure type struct atm qos bytes net atm mpc atm add qos struct atm qos entry entry sizeof struct atm qos gfp kernel error reversed size interrupt level arguments specifying value gfp kernel bytes storage allocated 
currently errors harmless kernel uses power memory allocator minimum allocation unit bytes 
latent time bombs space efficient allocator 
sm null checker decl scalar sz match scalar decl const int match const ints decl ptr match ptr state specifies state state decl ptr associate allocated memory unknown state compared null 
start set state true path null false path null malloc sz 
true null false null vice versa malloc sz 
true null false null unknown state observed 
malloc sz 
unknown allow variables states unknown null null unknown null null 
true null false null 
true null false null catch error path leaks warning non null non freed variable gets return negative integer 
unknown null return 
int cst err error path leak dereferences null unknown ptrs 
null unknown 
err ptr illegally allow free non freed variables 
unknown null null free 
freed check double free free 
freed free 
err dup free 
err free overwriting value kills state 
ok metal extension checks allocated memory checked free double freed freed error paths returning negative integer 
drivers char tea static int tea attach 
client sizeof client gfp kernel client return tea sizeof tea gfp kernel tea return 
mod count 
code errors freeing memory client error path discussed section calling mod count potentially blocking memory allocation calls 
checks focus raw byte memory management general extension template retrofitted check similar rules higherlevel objects 
modified version extension probable errors linux irq allocation code allocations checked errors irq deallocated error paths 
enforcing rules globally extensions described far implemented local analyses 
systems rules context dependent apply globally functions call chain 
section presents extensions xg global analysis framework check linux rules 
kernel code call blocking functions interrupts disabled holding spin lock 
violating rule lead deadlock 

dynamically loaded kernel module call blocking functions module count properly set 
violating rule leads race condition module unloaded 
describe global analysis pass computes transitive closure potentially blocking routines 
discuss extensions result 
computing blocking routines build list possibly blocking functions passes 
local pass metal extension check local global false pos interrupts spin lock module total table results checking kernel routines block interrupts disabled interrupts holding spin lock spin lock way causes module race module 
divide errors needed local global analysis 
local errors due direct calls blocking functions global errors reached blocking routine multi level call chain 
global analysis results module marked approximate manually confirmed 
traverses kernel routine marking calls functions known potentially block 
linux blocking functions primarily kernel memory allocators called gfp atomic flag specifies sleep request fulfilled routines move data user space block page fault 
processing routine extension calls xg support routines emit routine flow graph file 
flow graph contains routine annotation procedures routine calls 
entire kernel processed input source file corresponding emitted flow graph file 
second global pass uses xg routines link files global call graph entire kernel 
global pass uses xg routines perform depth traversal call graph calculating routines path potentially blocking function 
output pass text file containing names functions call blocking function 
running global analysis linux kernel gives roughly functions potentially sleep 
checking blocking deadlock linux oses uses combination interrupt disabling spin locks mutual exclusion 
interrupt disabling imposes implicit rule thread running interrupts disabled block runnable thread system deadlock 
similarly implementation linux kernel thread scheduling threads holding spin locks block 
doing causes deadlock sleeping thread holds spin lock thread cpu trying acquire 
metal extension checks rules assuming routine starts clean state interrupts enabled locks held 
traverses code path hits statement disables interrupts goes disabled state enable interrupt call returns original state 
similarly hits function acquires spin lock traverses locked state unlock call returns clean state 
states composition extension examines function calls reports error call function list potentially blocking routines 
despite simplicity rules real code violates numerous places 
extension errors linux 
errors lead deadlock 
remaining calls interrupts disabled 
possibly motivated frequency error code checks called interrupts disabled prints warning re enables interrupts 
situations interrupt disabling synchronization leads race conditions 
code snippet representative typical error mistake annotated source fixed drivers sound save flags flags cli count broke broke cant cli 
copy user char tmp data buf queue byte midi buf dev tmp data restore flags flags call copy user implicitly sleep called interrupts disabled call cli 
local errors caused driver implementors having clear picture rules follow user data movement routines block 
global errors caused fact hard tell function potentially block tracing function calls different files considerable amount priori linux kernel knowledge 
checker produced false positives 
global calculation blocking functions check called function interrupts calling blocking function 
caused name conflicts file defined called function name blocking function 
approach section applies operating systems 
implementor system write extension openbsd system checked interrupt handling code called blocking operation 
bug interrupt handler call page allocation routine turn called blocking memory allocator 
checking module counts linux allows kernel subsystems dynamically loaded unloaded 
modules count tracking number kernel subsystems 
modules increment count loading mod count decrement unloading mod dec count 
kernel unload modules zero count time 
module protect unloaded sleeping incrementing count calling blocking function 
similarly unloading block decrementing count 
module aborts installation incrementing count decrement count restore original value 
extension checks load race conditions tracking potentially blocking function called flagging subsequent mod incs 
conversely checks unload race conditions tracking mod dec performed flagging subsequent calls potentially blocking functions 
finds dangling emitting error mod reversed path returns negative integer signals error 
table shows local version extension global list blocking functions rule violations global version cases confirmed global errors 
linux mutual exclusion complexity dealing concurrency leads linux kernel device drivers follow localized strategy critical sections function body 
despite stylized size code implementors imperfect understanding leads errors 
wrote extended version interrupt checker described section check kernel function conforms conditions condition applied bug false pos holding lock double lock double unlock intr disabled bottom half bogus flags total table results running linux synchronization primitives checker kernel version 
applied column estimate number times check applied 
skipped twelve warnings difficult classify 
parenthesized numbers show changes files false positives ignored 

locks acquired function body released exiting 

execution paths attempt lock unlock lock twice 

exiting interrupts enabled restored initial state 

bottom halves interrupt handlers disabled exiting 

interrupt flags saved restored 
table shows results running extension linux 
applied column estimate number times check applied 
device drivers account large number false positives macros consult runtime state locking unlocking 
parenthesized numbers show changes false positive results files ignored 
common bugs holding lock leaving interrupts disabled function exit 
bugs occur detecting error condition function returns immediately 
example checker bug device driver pcmcia card services drivers pcmcia cs pcmcia client spin lock lock flags client clients client client handle client client client null forgot lock flags 
return cs bad handle checks linux locking conventions resulted kernel patches including fix error shown 
patches fix cases lock mistakenly held exiting function device drivers patch implementation ipv network filters 
able confirm potential bugs kernel device driver developers strong os implementors examined consider suspicious 
potential bugs device drivers networking code surprising code written developers world varying degrees familiarity linux kernel 
false positives come sources 
code intentionally violates convention sake efficiency modularity accounts false positives 
example family related device drivers define interface breaks conventions 
large source false positives caused fact checker performs local analysis 
drivers implement locking functions basic primitives provided system 
checker warn functions exit holding lock interrupts disabled exactly supposed 
global analysis eliminate false positives 
fact system prune simple impossible paths accounts false positives 
typical example kernel code conditionally acquires lock performs action releases lock condition 
possible paths code system thinks exist 
remaining false positives eliminated extending checker notion locking functions changing system prune false branch loop conditionals form 
optimizing flash addition checking mc optimization 
describe extensions written find system level optimization opportunities flash machine cache coherence code 
code fast implements functionality cache coherence usually placed hardware 
eliminating single instruction considered beneficial 
protocols examined aggressively tuned years due numerous performance papers evidence effectiveness software controlled optimization number false pos loc buffer free message length xor opcode hundreds table mc flash optimizer results 
number counts optimization opportunities 
xor checker written old version system version written metal factors smaller 
cache coherence 
despite effort mc optimizers hundreds optimization opportunities due difficulty manually performing equivalent searches flash deeply nested paths 
buffer free optimization 
time flash node receives message invokes customized message protocol handler determines satisfy request update protocol state 
handlers incoming message buffer send outgoing data messages free exiting 
handlers send data messages need buffer control messages 
handlers send message responding request 
minimize chance losing buffer implementors typically conservative defer buffer freeing handler send irrespective send control message need buffer 
unfortunately strategy simplifies handler code increases buffer contention high load 
extension indicates buffer frees occur earlier code 
traces sends path function looking send arguments detects send needs buffer frees buffer 
gives suggestion path active buffer ends suffix control sends 
extension lines long instances large flash protocol dyn ptr buffer safely freed earlier 
optimizations implemented changing lines code 
extension produced false positives 
cases execution path complex optimize major code restructuring 
redundant length assignments 
second lower level optimization extension detects redundant assignments message buffer length field 
speed sending multiple messages implementors set buffer message length early handler try reuse setting multiple messages 
long path lengths easy redundant assignments 
checker detects redundancies recording assignment path warning assignments constant 
discovered redundant assignments flash protocol code 
efficient opcode setting 
message headers specify message opcode type 
opcode assignment costs instructions 
handler knows opcode currently header change opcode instruction xoring message header xor new current opcode 
extension detects cases computing message header known opcode assigned new opcode 
old new opcodes incoming paths 
extension determines initial header value looking automatically built list opcodes handler receive 
possible opcode value extension records starts known state 
checker starts unknown state 
transitions state known state opcode assignment 
assignment encountered known state annotated current opcode value 
second pass checks assignment paths reached known state opcode emits warning user xor save instruction 
checker hundreds cases 
systems restrictions actions programmers perform order events actions legal context 
cases restrictions link entire system creating fragile intricate mess 
currently systems builders obey restrictions 
unfortunately system complexity difficult sustain 
programmers mistakes approximate understanding important system restrictions 
mistakes easily evade testing rarely exercises cases 
shown system restrictions automatically checked exploited metalevel compilation mc 
mc easy implementors extend compilers lightweight checkers optimizers 
currently system rule understood implementors 
mc allows implementor understands rule write check enforced code 
leverage exerts tremendous practical force development complex systems 
check errors false positives uses loc side effects static assert stack check user ptr allocation block module mutex total table results mc checkers summarized checks 
error number errors false positives number false positives uses number times check applied loc number lines metal code extension including comments whitespace 
mc general approach scaling simple cases checking assertions global strategies mutual exclusion deadlock avoidance 
demonstrated mc power check real heavily tested systems 
bugs roughly difficult find testing manual inspection 
extensions typically required day lines code implement 
curiously writing code check restrictions significantly easier writing code obeys 
exceptions extensions written programmers best passing familiarity systems applied 
believe results show meta level compilation significantly aid system construction 
david dill discussions software checking wilson hsieh discussions initial metal language mark heinrich willingness validate flash results 
wallace huang yu ping hu verified error messages null checker section 
russell tim waugh alan cox david miller answered numerous linux questions gave feedback error reports 
additionally generous readers linux kernel feedback support 
mark horowitz support initial suggestion looking flash led numerous interesting directions 
david dill wilson hsieh mark horowitz anonymous reviewers especially andrew myers valuable feedback 
bishop 
checking race conditions file accesses 
computing systems pages spring 
boyer yu 
automated proofs object code widely microprocessor 
journal acm january 
chiba 
metaobject protocol 
oopsla conference proceedings object oriented programming systems languages applications pages october 
chou chelf engler heinrich 
meta level compilation check flash protocol code 
appear asplos november 
chou engler 
metal language system building lightweight system specific software checkers analyzers optimizers 
available request acc cs stanford edu 
corbett dwyer hatcliff laubach pasareanu robby zheng 
bandera extracting finite state models java source code 
icse 
crew 
language examining syntax trees 
proceedings conference domain specific languages pages october 
detlefs leino nelson saxe 
extended static checking 
tr src compaq src december 
engler 
incorporating application semantics control compilation 
proceedings conference domain specific languages october 
extended version interface compilation steps compiling program interfaces languages selected appear ieee transactions software engineering may june volume number 
evans guttag horning tan 
lclint tool specifications check code 
proceedings acm sigsoft symposium foundations software engineering december 
floyd 
assigning meanings programs pages 
schwartz ed 
american mathematical society 
fraser hanson 
retargetable compiler design implementation 
benjamin cummings publishing redwood city ca 
reed hastings bob joyce 
purify fast detection memory leaks access errors 
proceedings winter usenix conference december 
holzmann smith 
software model checking extracting verification models source code 
invited 
proc 
forte publ 
kluwer 

technical prefix enterprise 
technical report 
kaashoek engler ganger hunt mazieres grimm jannotti mackenzie 
application performance flexibility exokernel systems 
proceedings sixteenth acm symposium operating systems principles october 
kiczales des rivieres bobrow 
art metaobject protocol 
mit press 
kiczales lamping mendhekar maeda lopes loingtier irwin :10.1.1.115.8660
aspectoriented programming 
european conference object oriented programming ecoop june 

insure tool support total quality software 
www com insure papers tech htm 
heinrich simoni gharachorloo chapin baxter horowitz gupta rosenblum hennessy 
stanford flash multiprocessor 
proceedings st international symposium computer architecture april 
lamping kiczales rodriguez jr ruf 
architecture open compiler 
proceedings imsa workshop reflection meta level architectures 
lord 
application specific static code checking programs 
digital version 
mcmillan 
formal verification cache consistency protocol 
proceedings international symposium shared memory multiprocessing pages 
tokyo japan inf 
process 
soc 
mowry krieger 
automatic compiler inserted prefetching applications 
proceedings second symposium operating systems design implementation 
nelson 
techniques program verification 
available xerox parc research report csl june stanford university 
owens 
please review modules unload races 
sent linux kernel rutgers edu 
gives protocol follow prevent module unload races 
rashid 
personal communication 
microsoft internal tool check violations windows device drivers july 
russell com 
unreliable guide hacking linux kernel 
distributed linux redhat kernel 

personal communication 
bug openbsd interrupt context call blocking memory allocator april 
savage burrows nelson sobalvarro anderson :10.1.1.161.222
eraser dynamic data race detector multithreaded programming 
acm transactions computer systems 
srivastava eustace 
atom system building customized program analysis tools 
proceedings sigplan conference programming language design implementation 
stern dill 
automatic verification sci cache coherence protocol 
correct hardware design verification methods ifip wg advanced research working conference proceedings 
