implementation gofer functional programming system mark jones yale university department computer science box new haven ct 
jones mark cs yale edu gofer system functional programming environment small haskell language 
supporting wide range different machines including home computers system widely teaching research 
report describes main ideas techniques implementation gofer 
information particularly useful gofer platform explore new language features primitives 
interest curious see general techniques functional programming language compilation adapted simple practical implementation 
gofer system functional programming environment small haskell language 
language characterized support lazy evaluation higher order functions static type system includes polymorphism overloading 
released september gofer widely education research 
judging comments users main reasons gofer popularity 
runs wide range machines including small home computers 
second particularly powerful systems interpreter provides fast interactive development environment avoiding need lengthy recompilation 
user documentation source code gofer included public distributions substantial effort provide details implementation 
time unnecessary introduced new ideas techniques believed standard known 
research report yaleu dcs rr may retrospect user feedback past years suggests ideas may wellknown expected 
quite lot interest modifying gofer system simple tasks addition new primitives sophisticated experiments language design 
information principle gleaned careful study source code certainly convenient form documentation 
report intended guide interested inner workings gofer 
aim explain original design goals structure datatypes way different pieces fit 
attempt cover technical detail system viewed replacement studies source code 
report intended tutorial implementation functional languages simon peyton jones book name constant companion development gofer remains certain prerequisite report 
report assume familiarity gofer environment described user documentation haskell functional programming language language design programming language system implemented 
outline report section outlining principal design goals development gofer system 
section summarizes main features system user perspective highlighting decisions design standard user interface 
section detailed study current implementation gofer 
starting overview system progress detailed descriptions important components including storage management section lexical analysis parsing section static analysis section type checking section compilation supercombinators section program execution section 
section discusses ways functional programming influenced development gofer system written imperative gofer compiler simple minded translator producing executable versions gofer programs described section 
section offers reflections current implementation areas development 
motivation design goals gofer system initially developed vehicle personal research 
name gofer derived claim functional languages supposedly equational reasoning reflection fact system originally planned tool machine assisted equational reasoning 
initial design included small interpreter intended simple calculations soon main focus project motivated particular desire investigate new implementation technique haskell overloading mechanism 
system designed specific goals mind compatibility language design closely definition haskell emerging freely available standard nonstrict functional programming languages 
course haskell natural choice type class overloading guaranteed initial supply examples base comparisons 
sensible avoid notoriously difficult process language design concentrating specific elements carefully developed system 
extensibility system provide foundation experimentation 
portability system usable wide range machines 
specific con aware similarly named gopher program access information internet time release gofer 
despite different application areas choice names unfortunate source confusion may soon warrant choice new name gofer 
straint able run system mhz pc ram running ms dos original development carried machine 
systems infamous awkward bit segmented architecture limits size individual blocks data 
gofer system runs different machines restrictions continued important influence basic design 
note speed execution important part making implementation usable consider primary design goal 
looking back believe reasonably successful meeting goals 
initially version haskell report gofer modified track subsequent versions haskell 
result large class programs run haskell gofer requiring changes source code 
unfortunately differences significantly treatment type class overloading 
easier realize goal compatibility stands direct conflict technical ideas motivated development 
believe gofer approach type classes important advantages incompatibility haskell minor little frustrating 
differences embarrassment goals design haskell reduce unnecessary diversity functional programming languages 
gofer proved useful subsequent developments way general releases gofer system 
examples include simple minded compiler translating gofer programs enable development standalone applications written gofer 
system constructor classes extending notion haskell type classes allow sophisticated forms user defined overloading 
example specialized partial evaluator described included standard distribution 
gofer system proved fairly portable includes support wide variety different machine operating system environments 
places source code depends assumptions compiler build gofer guaranteed language standards 
respect fairly lucky non portable assumptions happen true systems 
despite new features added release gofer small machines originally developed 
machines today home computers powerful 
may see significant benefits versions system free constraints older machines impose 
fact gofer small machines main reasons widespread 
functional language implementations require powerful machines gofer means unique providing functional programming environment smaller systems leroy caml light implementing dialect ml known example 
user perspective gofer system provides interpreter experimental language closely definition haskell version 
notable features include purely functional language non strict semantics lazy evaluation higher order functions pattern matching 
facilities defining new algebraic datatypes type synonyms 
polymorphic type system provision user defined overloading system type classes see section details 
full haskell expression pattern syntax including lambda case conditional expressions list comprehensions operator sections wildcard irrefutable patterns 
partial implementation haskell facilities supporting simple text file manipulation interactive programs 
user documentation sample programs source code freely available anonymous ftp 
relatively portable implementation runs wide range computer systems including smaller home personal computers 
report gofer version current release time writing 
comments report true earlier versions 
significant feature haskell currently supported haskell module system 
hand gofer supports experimental extensions constructor classes best known example 
latest release includes prototype implementations proposals extensions haskell including monadic lazy state threads 
typical gofer session system behaves interactive calculator 
user enters expression gofer prompt usually character 
checking errors interpreter evaluates expression lazily printing result produced returning prompt expression reductions cells sum reductions cells counts reductions cells give rough indication amount time memory calculation respectively 
statistics useful situations comparing relative complexity different algorithms 
messages suppressed command line option avoid unnecessary distractions 
process described common standard read eval print loop interactive programming environments particularly languages lisp scheme 
gofer allows local definitions expression example reductions cells lisp systems possible define new global values functions directly interpreter 
new definitions entered text editor produce script file definitions loaded interpreter 
strict separation sessions scripts conscious design decision inspired reflecting way expect system practice 
particular approach allows programmer switching scripts sessions adding new definitions testing making changes necessary 
addition script files provide consistent view current program allowing program development spread different gofer sessions avoiding complexities confusions incremental compilation type checking 
user interface carefully designed support style program development 
example error detected loading script file user enter command abbreviation edit start text editor file containing error approximate line position problem detected 
error corrected user saves file exits editor returning interpreter automatically reloads script 
example shows load command load definitions script file example gs interpreter load example gs reading script file example gs gofer session gofer standard prelude example gs notice list files displayed includes example gs prelude file called gofer standard prelude 
script standard definitions loaded gofer session 
example prelude typically includes definition standard arithmetic list processing functions 
interpreter allows users develop special versions prelude suit particular requirements 
example feature support experimental constructor classes provide closer compatibility haskell textbook introductory course functional programming 
hand system carefully designed ensure prelude file loaded interpreter started 
intended discourage users temptation modifying prelude definitions definitions usually shared different programs bad practice modify purposes particular program 
preferred method writing new prelude files build new definitions top minimal prelude new definitions moved stand prelude development complete 
entirely desirable process little awkward new resort inherently non standard 
gofer include module system convenient split large programs different script files 
allows different components program developed independently reused programs 
gofer system supports allowing user specify list script files loaded stacked top definitions preceding files 
example command load script files interpreter load ex gs ex gs ex gs files loaded strict order possible ex gs include definitions ex gs ex gs 
similar way definitions ex gs changed ex gs ex gs reloaded definitions potentially modified light changes 
sophisticated dependency analysis avoid reloading ex gs cases affected changes ex gs 
practice reloading script files usually fast concern 
convenience gofer allows list files required particular program recorded project file 
command form project program prj read file names listed program prj load corresponding script files interpreter 
important mention original gofer user interface closely modeled scrolling interface provided functional programming 
example early versions gofer displayed lines dots indicate progress various stages reading script files command syntax gofer leading colon character modeled editor vi versions available systems gofer 
comparison popular programs machines user interface gofer primitive 
unfortunately different stan feature supported current release requires command line option 
longer default behaviour surprisingly significant slowing effect total time taken process script files machines 
constructing sophisticated user interfaces aware standard toolkits offering degree portability required gofer system 
people developed graphical user interfaces gofer targeted specific machines 
widely known example extends standard gofer interpreter graphical user interface apple macintosh computers 
system developed kevin hammond university glasgow 
structure background information time tour gofer system 
implementation language decisions choice implementation language 
gofer intended run wide variety machines including small pcs limited memory language obvious candidate 
decision easy believe development gofer easier error prone written strongly typed functional language accepts 
approach designers means testing demonstrating confidence new language program development 
example chalmers lml standard ml new jersey glasgow haskell able compile source code 
systems requires substantial machine resources 
addition concerned bootstrapping systems relies compiler achieve reasonable performance gofer originally conceived interpreter 
gofer written imperative language shows strong influences functional programming 
discussed little detail section 
compilers ansi available time gofer code written compiled older compilers 
preprocessor allow important features ansi possible 
example preprocessor macro args allow function prototypes declarations void args string long ansi compiler args macro includes types arguments declaration allowing compile time detection argument mismatch errors 
older compilers args macro defined omit list argument types preprocessed version program 
turns datatypes gofer just synonyms existing types 
example types int text cell list pair module just new names standard type integers int 
careful different names provides valuable program documentation suggesting intend different values treated 
example prototype copy function defined storage written extern list copy args int cell gives clearer indication function returning list containing fixed number copies cell written just extern int copy args int int course looses benefits strong typing example compilers report errors expression copy val despite fact arguments written wrong order 
way restore strong typing introduce new types synonyms 
example typedef struct int cell sensible classes structs suitable older compilers prohibit struct values function arguments 
truth ability implicitly treating values type values turned quite convenient points code 
important preprocessor gofer source support display handling error messages 
example code error line syntax error display error message syntax error line line particular script file branch error handler 
small collection macro definitions file errors provides additional facilities including expressions types error messages 
advantage approach input lexical analysis parsing section static static analysis section easier identify error messages source code helps ensure handed uniform manner 
reader may surprised concessions support older obsolete compilers architectures 
recognize systems particularly personal computers gofer widely 
components gofer system main components gofer system illustrated diagram corresponds way input programs processed lexical analysis execution gofer machine 
components implemented corresponding file described sections report starting storage provides storage management facilities components 
part system responsible initializing maintaining variables data structures depends 
described including control function component 
example control function type checker called typechecker 
example reset type checker call form typechecker reset 
messages understood control functions including install initialize local data structures mark request component mark local data structures preparation garbage collection exit perform final tidying necessary exiting interpreter 
everybody function defined send particular message component system 
example things interpreter call everybody install things terminating call everybody exit 
storage storage management section type type checking translation section compiler compilation supercombinators section main components gofer system machine execution machine section components gofer system included including gofer standard interpreter user interface 
includes code parts user interface shared gofer compiler example command line processing machine dependent code example terminal 
builtin defines built primitives included file prims output provides pretty printer internal representations programs expressions types kinds 
routines display fragments expressions types part error messages produced gofer system 
quite useful debugging interpreter 
mention files variants gofer machine builtin respectively gofer compiler 
see section details 
storage management important components gofer system storage management facilities provided storage header file storage define datatypes structures parts system 
important data structures gofer system follows text datatype represent identifier names text strings section 
cell datatype representation wide variety values including programs types section 
module datatype deal programs built loading sequence script files section 
gofer stack variety purposes including execution programs gofer machine section 
text datatype gofer programs usually contain different character strings including keywords variable names text string literals 
naive treatment strings allocating fresh storage string encountered obvious disadvantages heap space may wasted keeping multiple copies string example function name source program 
memory allocators runtime systems perform poorly burdened allocation relatively small objects 
comparisons strings atomic character comparisons necessary distinguish strings initial prefix 
particularly important example code searches symbol table find entry corresponding particular string 
gofer avoids problems table character strings associating string offset table values type text record offsets 
strings added table time encountered 
subsequent occurrences text value 
text values represent strings avoids problems described ensures strings equal corresponding text values equal 
current implementation size character storage table fixed compile time 
limited memory older pc little point doing sophisticated particularly dynamically allocated table required indirection access values table 
dynamically allocated table useful powerful systems allowing size character table increased complete recompilation gofer system 
functions provided convert string text types extern string args text extern text args string simply returns pointer string offset table determined text value 
function find text value corresponding string extending character table necessary 
collection hash tables speed process searching character table previous occurrences string 
original implementation single hash table give starting point linear search character table 
quickly changed multiple hash tables discovered time required load large programs spent inside function searching previous occurrences strings 
possible current implementation uses levels hash tables resorting linear search 
large programs gave immediate increase compilation speed 
benefits smaller programs significant worthwhile 
functions extern text args void extern text args void generate new variables dictionary parameters respectively stages compiler 
implemented functions return values outside range offsets character table 
cell datatype advantages programming language gofer automatic storage allocation garbage collection 
frees programmer need specify memory allocation required allocated sections memory released parts program 
explicit memory management kind notorious source errors languages support automatic storage management gofer system includes implementation heap values type cell pointers objects heap 
turns useful data structure system just execution gofer programs 
example gofer heap build parse trees input programs store types type checker implement translation functions supercombinators 
subsections outline interpretation implementation cell values 
warned reasonably complete description cell values long complicated 
reading may best simply scan sections attempting absorb details 
interpretation cell values cell datatype includes representations different kinds value 
list describes important kinds cell value primitive constants cell datatype includes representations different kinds constant values including integers corresponding int type underlying implementation floating point numbers characters string literals 
pairs construct compound values including pairs trees lists 
pair containing cell values obtained result function call pair 
conversely components pair extracted expressions fst snd 
pair cells represent function application compile time runtime representation gofer programs 
storage header file includes macro definitions support define ap pair define fun fst define arg snd pairs build representation lists storage contains macro definitions describe encoding lists define cons xs pair xs define hd xs fst xs define tl xs snd xs define singleton cons nil define nil words non empty list represented pair fst component stores head list tail list remaining elements snd component 
special cell value nil represent empty list parts implementation general purpose dummy value 
refer lists constructed manner internal lists values corresponding list datatype gofer program different representation 
example fully evaluated gofer list represented ap ap mkint ap ap mkint ap ap mkint constant values see description name values corresponding gofer constructor functions respectively 
different names example pair ap cons single function may unnecessary complication 
practice careful different names code little readable 
variable names different kinds variable names represented cell values including ordinary variables constructor variables dictionary variables 
case expression gives text name variable represented cell value constructor cells cell datatype includes representations fragments parse trees 
example list comprehension generator form exp represented cell contains pair components pattern expression exp sections particularly grammars describing internal representations gofer programs notation exp describe cell value constructed way 
special cell values cell datatype includes number special values certain constants 
examples include arrow list unit represent function space list unit type constructors respectively 
unit representation gofer value value type 
wildcard representing wildcard pattern star representing kind types important concept treatment constructor classes 
function kinds mapping constructors kind constructors kind represented pair 
tuples representation tuple types values 
example construction pairs 
cell datatype includes values corresponding nullary unary tuples respectively current implementation 
offsets place holders type variables polymorphic type bound variables definition 
see sections details 
dictionaries selectors dictionaries package groups related values single unit 
selectors extract components dictionary 
described detail section 
type constructors represent gofer type constructors introduced type data declarations primitive built datatypes bool int char 
details type constructor represented cell value tc recorded structure tycon tc 
example tycon tc text gives name tc text value 
tycon tc kind gives kind tc described 
tycon tc contains code indicating type constructor defined data definition datatype type synonym synonym restricted type synonym 
tycon tc defn contains expansion type synonym list constructor functions algebraic datatype 
note tycon macro function returning struct syntax suggest 
names represent named values needed execution gofer programs 
includes user defined values constructor functions member functions primitives new supercombinators introduced compiler 
type constructors details corresponding cell value representing name held structure name including fields name text text name name arity number arguments function expects 
arity zero indicates constant applicative form caf described 
name type type known 
name defn distinguish different kinds name 
value field may indicate constructor function cfun member function 
user defined functions field record dependency information compilation 
save result evaluation caf machine name code starting address code implement 
see section details 
name pointer implementation primitive function zero name correspond primitive 
case type constructors name macro function returning struct 
type classes represent individual type constructor classes 
cell value representing class structure class includes fields class text text name class arity number arguments class takes 
class sig kind constructor expected parameter 
class list superclass constraints 
class members list member functions class defaults list default definitions member function 
class instances list instance declarations class class pointer index dictionary values class 
values described detail section 
type class instances type constructors names details instances type class kept structures indexed cell values 
example cell value corresponding instance declaration value whatis code predicate selector constructor integers isint mkint floating point characters pairs ap fst snd pair tuples tuple offsets offset selectors select dictionaries type constructors tycon tycon names name name newname type classes class class class instances instance inst predicates selectors constructors cell values instance eq eq true structure inst includes fields inst cl class instance applies case eq 
inst head form instance specified case eq 
inst specifics context part declaration case singleton list containing class constraint eq inst implements list member function implementations case singleton containing name function implementing equality lists 
values described detail section 
different kinds cell values supported small collection utility functions summarized including predicates determine cell represents particular kind value 
selectors return value associated corresponding particular kind cell 
fst snd name functions described examples 
constructors obtain cell values corresponding particular kinds value 
pair function described simple example 
whatis function provides way determine kind value represented cell 
lists codes returned whatis frequently cell values example test form whatis name equivalent may little efficient 
whatis function useful means testing particular types cell predefined predicate 
example testing condition whatis easiest way determine represents dictionary value 
important application whatis provide simple form pattern matching idiom widely implementation gofer reducing need repeated inspection cell values switch whatis case name case 
default 
profiling experiments suggest whatis frequently executed functions gofer system certainly worth investing little time try efficient possible 
implementation cell values starting description cell values obvious implementation algebraic data type similar gofer programmer normally introduce data definition 
pairs nil tags tuples offsets classes chars integers implementation cell values ranges integers scale 
fact current implementation uses complicated scheme encoding arbitrary cell values integers 
main idea different ranges integers represent different kinds value 
illustrates part encoding current implementation 
approach important benefits direct implementation avoids pointers representation cell values 
important consideration pc implementation required bit pointers result doubled storage requirements system bit integers 
occurrences commonly values including names type constructors small integers require storage regardless number times compilation execution program 
time representation significant disadvantages task decoding cell values little expensive 
integers pointers carries performance overheads reason array access single pointer indirection usually efficient integer index involves additional implicit pointer arithmetic 
difficult change mapping integer ranges different kinds cell value system running 
important wanted able modify initial configuration example accommodate larger input programs 
integer ranges current implementation values correspond described 
long string define directives header file storage ensure ranges overlap 
negative integers exclusively represent pair values 
allows implement test determine represents pair comparison cheap machines 
theory limits maximum number pair cells heap equal number negative integers pairs number bits integer 
practice doesn cause problems working bit machine upper bound larger heap size 
bit pc upper bound heap size lower maximum pairs pc architecture doesn memory support larger heap 
second components pair stored arrays cells called contains elements 
arrays single array containing components pair concession pc architecture limits maximum size array hope avoid expensive index calculations 
arrays pc architecture support heap containing maximum pairs requiring bytes 
decision arrays may allocation variable size heap objects difficult obstacle efficient implementation arrays records 
fact describe section constraints imposed garbage collector current design impossible support variable length allocation 
pairs represented negative cell values variables point locations immediately arrays respectively 
fst snd selectors implemented macros define fst define snd negative index values find way back appropriate elements array 
gofer heap quite heavily probably useful store variables global registers 
default heap size setting particular machine changed command line option current implementation provision expanding heap interpreter running 
useful example allow user request increase heap size permit automatic heap expansion garbage collection fails reclaim sufficient space 
reason feature added larger systems default heap size settings older pcs set maximum possible values 
zero value represent nil value making tests empty list fast 
indirect indirect symbolic names integers implementation indirection nodes 
see section details 
values range tags fst component pair representing boxed value 
table lists boxed values current implementation 
right hand column gives type value stored snd component boxed values identifier variable text operator variable text dictionary variable text identifier constructor text operator constructor text string literal text integer literal int pattern int pattern int dictionary dict input file 
int floating pt float main purposes tag value indicate snd component pair ignored garbage collector 
values range tags boxed values snd component cell 
value simple example pair containing pattern expression generator snd component 
values range special cell values unit wildcard star 
num tuples values 
represent tuple type value constructors 
default setting num tuples prelude allows tuples components 
practice rare find gofer programs tuples components 
num offsets values 
represent offsets 
default setting num offsets prelude allows extensive pattern matching local variables function definitions different polymorphic type variables inferred types 
examples exceeding limit usually interest pathological examples 
num tycon values 
represent type constructors 
tycon selector implemented macro define tycon tc tc array num tycon structures containing fields described previous section 
num name values 
represent names 
name selector implemented array structures similar way tycon selector described 
num selects values 
represent dictionary selectors 
num insts values 
correspond instances type class 
inst selector implemented cell values index elements array structures 
num classes values 
represent classes class selector implemented similar way tycon name inst 
num chars values 
represent character values 
default value num chars allows characters support full character set current machines 
remaining values covered range represent small integers unboxed values 
practice value tends quite small largest positive integer value 
result range small integers quite large range integers represented bits assuming bits cell value 
midpoint range representation zero define possible encode integer values cells requiring additional storage 
integer values represented way stored boxed values pair component second component containing integer 
programs small integer values representation gives noticeable reduction amount space programs 
hand simple arithmetic operations integers expensive implement written deal boxed unboxed integer values 
interpreter gofer significant performance overheads worry 
representation suitable systems execution speed issue 
garbage collection described new pair cells allocated calling pair function 
happens pairs heap allocated 
systems gofer relies assumption time happens pairs allocated earlier computation longer required 
garbage collector determine parts heap reused linking list free pairs called freelist 
new pair cells allocated removing element free list 
free list empty garbage collector called build new free list allocator continues 
possible heap full time garbage collector helps maintain illusion limit number pairs allocated 
automatic garbage collection particularly convenient frees programmer responsibility deciding particular piece storage safely reused avoids hard locate errors occur programmer wrong decision 
argued garbage collection faster forms memory allocation attempt claims particular garbage collection system gofer 
need programmer specify particular section storage reused important ensure garbage collector able identify parts heap 
achieved listing collection roots pointers data structures heap preserved garbage collector 
roots come different sources 
example type defn fields structure describing name value local variables hold intermediate results global variables pointing list definitions particular input program preserved garbage collector 
program behave badly parts heap variables point overwritten new values 
component system includes control function see section responds mark message marking roots relevant part system 
garbage collector uses calling everybody mark 
part heap marked reused 
example important realize component modified new global variable pointing list values heap control function component modified include line mark sensible ensure initialized reset suitable value usually nil response install reset messages respectively 
failure may mean storage pointed retained longer required 
described far relatively straightforward 
hinted specifics algorithm allocate new pairs collect unused cells freelist example mark scan garbage collector 
compared garbage collection algorithms systems mark scan collector serious disadvantages time taken build new freelist cells marked proportional total size heap size heap smaller 
allocating new pairs free list including test sure list non empty expensive compared alternative schemes new pairs allocated contiguous array cells heap pointer identifies free heap location 
testing heap overflow requires comparison heap pointer pointer heap 
addition possible allocate new pairs time single heap overflow test 
additional benefit approach described allows allocation different sized heap objects 
example allocate array cells simply need increment heap pointer checking overflow course 
theory mark scan collector allocate variable sized heap objects 
practice fails free space may fragmented making inefficient impossible allocate block memory right size total amount free memory large 
problems avoided garbage collector allowed move objects garbage collection typically compaction algorithm avoids heap fragmentation 
correctly need ensure garbage collector update pointers old position object reflect new position 
unfortunately possible ensure property gofer garbage collector allow heap arbitrary functions system garbage collector uses calling stack source roots 
see useful consider function taken storage allocate list containing number copies particular cell value list copy int cell list xs nil xs cons xs return xs suppose garbage collection occurs part way routine example half required list constructed 
clearly important ensure current value xs preserved garbage collector 
similarly value parameter may need preserved garbage collector particular case necessary garbage collector invoked call cons function value pointed included marked part data structure pointed xs 
easiest way garbage collector find values look calling stack 
course stack contains kinds values including example function parameters temporary values function return addresses 
garbage collector encounters value stack looks part heap treat value root garbage collector 
hand attempt change value stack allowing possibility kind value just happens fall range heap 
example modifying return address cause program branch wrong location stage unpredictable possibly disastrous effects 
particular example possible change definition copy ensure free cells available attempting construct result list avoiding chance garbage collection construction result list 
general solution cases impossible best expensive calculate upper bound amount storage particular function allocate 
furthermore requires programmer take responsibility storage allocation complicating code written 
alternatives extra code definition functions example label intermediate values avoid need garbage collection stack 
schemes soon find writing equivalent code low level assembly language see section ensure proper marking roots 
predicate accurate alternative test genuine pair cell values excluding cell values 
don trust programmer case person simply recognize easy errors memory allocation difficult detect correct mistakes 
bad copy function complex functions deal unfortunately simplest 
limitations garbage collector discussed problems mention 
garbage collector conservative sense may preserve parts heap needed 
happens garbage collector value stack pointer heap 
situations causes space leak preserving large data structures long point needed 
fortunately cause problems practice occasions heap full capacity 
major problem skimmed accessing values stack inherently generally speaking poor programming practice 
standard version garbage collector relies assumption stack treated contiguous array equally sized cell values 
true systems small pcs powerful workstations examples assumptions valid 
example port gofer system run operating system bryan modify garbage collector deal stack implemented linked list frames 
example development kevin hammond modify parts system accommodate bit byte representation floating point values fit directly byte units cell values 
illustration kind portability problems run common optimizing compilers place temporary values registers 
cases despite efforts avoid problem values registers hidden garbage collector treated roots 
example sun workstation compiler part gofer system heavy garbage collected heap usually compiled optimization avoid exactly kind problem 
garbage collection system enormous pain significant source portability problems 
part system demonstrates compromises necessary development gofer 
happily practice garbage collector usually reliable 
example run large gofer programs days execute requiring tens thousands garbage collections apparent problems 
light discussion consider fortunate garbage collector works 
current implementation allows transparent heap function definitions 
believe significantly difficult write maintain large sections system particularly compiler compiler time garbage collector cause problems particular prohibiting useful extensions allocation variable sized blocks memory 
problems avoided versions system switching language includes built support garbage collection 
alternatively possible language example allowing special treatment cell values ensure proper garbage collection remains see kind performance overheads approach carry 
module datatype described section gofer system allows user load sequence script files layered top definitions previously loaded files 
apart cell values described detail previous section values example names classes insts allocated fixed tables high water mark values example respectively pointing free position table 
module datatype record number script files currently loaded 
importantly script file loaded system maintains table recording values various high water mark variables immediately file loaded 
values saved call function module args void returns module number new script file 
system restore storage allocation position immediately module loaded call function void args module addition resetting values various high water marks function requires small adjustments additional data structures hash table locate name values 
functions provide simple checkpointing mechanism 
example calling reading new script file reading expression evaluated easy restore original state error occurs expression evaluated respectively 
sophisticated scheme allocation recovery values tables necessary system assume strict dependency script files order loaded 
gofer stack parts gofer system stack cell values parser uses stack record intermediate values corresponding fragments input programs section 
algorithm calculating strongly connected components program dependency graph static analysis uses stack record nodes graph visited section 
gofer machine uses stack hold intermediate values function arguments program execution section 
applications implemented stack data structure important operators follows void args void void push args cell cell pop args void cell top args void cell pushed args int functions obvious names types pushed returns value positions top stack 
expression top equivalent pushed 
fact operators implemented preprocessor macros function calls 
note values stack treated roots garbage collector important ensure stack preserved garbage collection occurs parsing static analysis program execution 
lexical analysis parsing input program read parse definitions gofer scripts commands expressions entered interpreter 
combining hand written lexical analyzer yacc generated parser part system draws standard techniques compiler construction 
lexical analysis code lexical analysis included file input character lookahead represented variables sufficient identify tokens gofer system 
stage current position input text maintained row column variables 
column positions chiefly keep track indentation significant implementation layout rule 
row values corresponding line numbers gofer programs recorded various points parsed form input expressions errors detected stages system referred back appropriate point source code 
lexical analyzer initialized take input console project file gofer script file functions void args string void args string void args string long console input string argument gofer prompt 
remaining cases string argument name file read 
second argument gives length input file known determine portion file read point parsing 
lexical analyzer able read gofer script files standard literate styles 
case program lines input files character column lines treated comments 
convention described fully appendix widely allows program text freely mixed documentation 
ability read literate scripts directly preprocessing significantly increase complexity lexical analyzer 
token encountered lexical analyzer returns code parser indicate kind token read 
example numeric literals varid variable name coco symbol 
distinguishing different types token parser needs process input different kinds tokens corresponding attributes needed stages obvious examples include value numeric literal name variable represented cells 
additional properties passed parser variable standard convention yacc generated parsers 
cases notably symbols value returned line number symbol occurs 
line numbers stages system locate approximate source error 
gofer grammar grammar gofer programs expressions defined file parser input yacc produce parser included part input convenience grammar includes productions module headers including import export declarations full haskell programs 
means possible file containing haskell module definitions input gofer modification 
checking syntax errors module headers completely ignored 
gofer grammar closely definition haskell little liberal respects 
simple example patterns gofer programs parsed expressions 
helps avoid unnecessary conflicts ambiguities grammar 
static static checks ensure expressions parsed valid patterns 
similar technique parse certain forms type expression 
examples show tokens lookahead may necessary determine type expression includes type class context vs vs 
yacc grammars allow single lookahead token deal problem parsing context part type expression just type 
symbol detected simple static check ensure value parsed type treated context 
example expression int bool accepted parser rejected static check 
hand current grammar accept type expression form eq bool strict adherence haskell grammar prohibit repeated parentheses predicate eq small differences interpretation certain expressions 
example haskell expressions different meanings evaluates local definition second introduces new value operator returns value bound enclosing environment compile time error binding exists 
gofer second interpretation expressions patterns top level pattern binding parentheses 
interesting aspect gofer parser way expressions involving infix operators treated 
haskell grammar appendix defines syntax infix operators complex family productions indexed precedence fixity values 
implementing directly yacc grammar cause significant increase size grammar 
gofer parser reads expressions involving infix operators sequence expressions separated operator symbols processing 
sequence read passed argument function parser uses simple shift reduce parser determine correct interpretation expression 
system supporting haskell style import declarations tidying process profitably delayed interface files imported modules read providing imported infix operators 
apart simplifying yacc grammar approach easy extend range precedence values assigned infix operators 
haskell current implementation allows single digit precedences 
small difference haskell gofer grammars treatment prefix unary minus operator 
definition haskell requires unary minus treated having precedence value precedence binary addition subtraction 
gofer unary minus binds tightly infix operator tightly function application 
rarely causes difficulties practice probably change gofer grammar point consistent haskell 
shadow stack parsing gofer system constantly heap build expression trees corresponding parsed fragments source program 
important ensure intermediate values preserved garbage collection occurs parsing 
fact parsers generated yacc maintain stack values internal values yacc stack known garbage collector wouldn worry loosing parse trees intermediate fragments garbage collections 
unfortunately yacc stack intended internal officially documented way access values 
insight way yacc generated parsers current implementation uses gofer stack simulate state internal parser stack 
duplication effort obvious disadvantages ensure garbage collector preserve intermediate values parsing relatively portable manner 
refer process shadowing yacc stack 
step shadowing process ensure lexical analyzer pushes appropriate value gofer stack time encounters token input file 
remaining taken care function defined parser productions ctype ctype atype gc ap expression form gc just abbreviation purpose remove top elements stack replace new expression fact definition little complicated need take account situations stack contains extra lookahead token 
refer reader parser details 
implementing layout rule haskell layout rule adopted gofer allows programmer layout indentation reflect structure program concise natural manner 
effect layout rule works automatically inserting tokens certain points input stream 
example case expression case expr true branch false branch transformed insertion additional tokens case expr true branch false branch refer reader chapter section complete description layout rule 
implementation layout rule little tricky relies quite heavily error recovery features yacc mildly complicated interactions lexer parser 
details little technical report refer reader code input parser particular productions close close information 
syntax parsed values explain role different components gofer system describe internal representation gofer programs stage sequence simple grammars 
purpose lexical analyzer parser translate input programs concrete syntax gofer syntaxes 
main result parsing gofer program list equations mixed type signature declarations 
grammar described list form eqn 
note gofer syntax lists notation 
indicate list values optional item bnf style notations 
line type indicates integer value corresponding line number source program 
names var con indicate variables constructor identifiers respectively 
fact parser lexer go step making distinction case identifier written applicative prefix syntax varid case infix syntax 
useful observations grammar 
suggested earlier comments grammar distinguish expressions patterns example fact wildcard permitted expression letrec clauses appear patterns captured grammar 
errors detected static analysis static section 
second grammar quite complex omits purely syntactic comments parentheses grouping eqn line var expr rhs expr var text con text ap expr expr const cond expr expr expr expr letrec eqn expr lambda alt comp comp runst expr expr case expr pat rhs var pat pat wildcard const unit tuple int text char float int comp expr qual qual pat expr eqn expr pat expr alt pat rhs rhs guarded line expr expr letrec eqn rhs line expr qual pred type type type arrow tuple unit list varid ap type type pred ap type ap pred type syntax parsed terms types quite close input language 
implementation little complicated keeping input form easier give accurate error messages static analysis type checking 
said examples special syntax gofer programs preserved 
table shows translations special syntax right sections unary minus arithmetic sequences source translation op flip negate 

apart list equations type signatures returned input file encountered parser processes kinds declaration type data definitions type constructor definition function allocate new tycon save details processing static analysis 
class instance declarations similar way new class inst values allocated record details class instance declaration input program respectively 
primitive declarations bindings variable names internal primitives gathered list parsing function 
part static analysis carried static new name values allocated named primitive 
fixity declarations precedence values infix operator symbols entered tables expression parser soon fixity declarations encountered 
note declarations appear top level input program 
static analysis main purpose code static carry static checks analyzes parsed programs expressions passed type checker 
tasks mundane don think explicitly writing programs gofer 
example consider program containing datatype definition form data type expressions 
ensure definition valid need carry tests check previous definition type constructor type class 
check format left hand side 
parser ensures arguments simple type variables additional check needed ensure repeated variables 
check type expressions appearing right hand side formed 
particular need ensure type variables involved left hand side definition 
type constructors referred right hand side defined current program 
types right hand side 
example prevents attempts supply type constructor arguments 
requires form kind inference described section 
add new name values suitable types arities constructor functions defined right hand side 
addition need ensure previous definitions functions datatype definition 
definitions type synonyms classes instance primitive function operator subjected static checks similar nature 
verifying conditions input programs allows system give early detection simple program errors 
addition simplifies code sections compiler 
example need deal unbound variables type checking code generation 
gofer system allows definitions script placed order result placement fixity declarations effect way programs parsed 
ordering definitions affect order errors reported user 
effect semantics error free programs 
static checks delayed script file parsed 
full list static checks quite long quite easy implement 
remainder section concentrate particular features translation parsed terms types form suitable type checker dependency analysis 
strictly speaking kind inference mechanisms gofer part static analysis 
implementation functions kind shares code data structures main type checker postpone discussion section 
translation parsed values addition checks described static analysis component gofer system translates parsed types declarations slightly different form 
changes motivated need avoid unnecessary stages 
example identifiers corresponding constants names classes input terms replaced corresponding values translated terms avoiding need symbol table lookups 
translation parsed types static analysis routines accomplished walking structure input terms types declarations 
example analysis parsed type expression produces result form described grammar 
notice occurrences cells input grammar replaced class tycon values refer 
similar way type variables represented varid cells parsed types replaced numbered offsets 
presence type variables signaling polymorphic type represented polytype values sig field record kinds polymorphic type variables full description representation polymorphic types requires fairly understanding technical issues discussed 
illustrate main ideas describing representation gofer type haskell convention type variables implicitly bound outermost universal quantifier corresponds preliminary stages static analysis sig field record number type variables kinds 
polytype sig type qual pred type type type arrow tuple unit list offset int tycon tycon ap type type pred ap class type ap pred type representation types static analysis type underlying formal system annotations variables specify kind constructors represent 
treating form binding type thought function mapping constructor kind constructor kind constructor kind 
interpretation choose kind signature type full representation type constructed expression ap polytype pair pair star sig pair pair star star star ap ap arrow type ap note corresponding variables respectively 
see representation particularly easy instantiate polymorphic type new constructor variables appropriate kinds 
translation parsed equations definitions variables functions represented lists equations output parser translated static analysis 
main change group equations bindings takes possible forms function variable binding groups equations single variable represented value form var type alt type value function binding record explicitly declared type function named var field 
explicit type declaration nil value place 
list alternatives binding obtained combining defining equations corresponding variable original script 
recall alt pair containing list patterns right hand side expression 
part conversion equations bindings static checks ensure equations particular variable grouped source file number argument patterns equations referred arity variable 
pattern binding represent group variables defined single equation left hand side pattern 
bindings represented values form var type pat rhs variables defined pattern binding listed component corresponding list explicitly declared types nil values necessary second 
differing slightly definition haskell gofer system reject pattern bindings define variables 
conscious design decision intended prohibit silly pattern bindings true false variables left hand side way force evaluation detect failure pattern matches 
arbitrary binding gofer implementation uses test isvar fst distinguish function pattern bindings 
description bindings nested pairs little easier explain explicit type information binding discarded type checking example mapping function binding value form var alt 
course gofer data structures built primitive pairing constructor just matter presentation 
binding var type alt var type pat rhs expr 
letrec binding expr 
name name qual pat expr binding expr rhs guarded line expr expr letrec binding rhs line expr grammar terms static analysis summarizes main changes form parsed terms declarations 
notice lists lists bindings local definitions lists equations original parsed form 
result dependency analysis described 
somewhat smaller change name values replacements variables refer constructor functions class member functions user defined functions previously loaded script files 
dependency analysis mentioned gofer place restrictions ordering definitions script file 
benefit parts system particularly kind type inference gofer system uses information gathered static analysis sort definitions order dependency 
example list bindings bs dependency analysis produce list lists bindings bs 
bs 
includes exactly collection bindings bs 
bindings mutually recursive 
variable defined bs referenced definition included practical terms means expression form bs expr rewritten sequence nested expressions bs expr principal motivation dependency analysis enhance polymorphism 
example dependency analysis type checker reject expression single binding group forces restrictive type id expect id succ id id true proper understanding relies fact pure hindley milner type system calls functions single binding group assigned monomorphic type 
dependency analysis discussed detail section section 
secondary reason dependency analysis current implementation gofer programs easier type checker digest describe section gofer type checker works best program split small binding groups 
dependency analysis implemented finding strongly connected components dependency graph program topological sort arrange desired order 
gofer dependency analysis implemented small modified version standard algorithm automatically produces strongly connected components required order 
core algorithm contained file scc file set allow different instances dependency analysis algorithm generated preprocessor copies code 
templates generics ada functors standard ml provided elegant ways deal languages 
dependency analysis applied group mutually recursive class type definitions dependency order prior kind inference 
previous versions gofer system including version separate dependency analyses type class definitions 
eye providing better compatibility haskell releases implementation version accommodates arbitrary recursions class type definitions combining dependency analyses 
strictly speaking need dependency analysis form current version gofer support polymorphic kinds 
anticipate may useful addition point 
benefit ability split kind inference declarations program smaller manageable pieces 
type checking inference main task type checker ensure expression definition gofer program type 
sections program assigned type treated errors 
help detect locate coding errors 
furthermore program type checks producing error messages sure execution go wrong run time type checks omitted compiled version program 
importantly types useful means describing documenting reasoning way objects 
reflects general philosophy types valuable tool software development 
practice usually necessary include explicit type information parts gofer program 
possible system able infer missing type information 
gofer type checker main roles calculate types functions variables defined script file ensure results consistent explicit type declarations included source program 
add extra parameters functions overloaded types pass dictionary values implementation type class overloading 
seen part static analysis described previous section second step sequence program transformations needed convert input code executable programs 
report persist standard practice referring component gofer system type checker 
reality checking plays secondary role important task type inference 
type checker largest complicated component gofer system 
course really surprising earliest motivations development gofer explore extensions type system 
type checker implemented code type includes additional sections files subst deals representation substitutions unification types kinds 
kind provides functions kind inference checking equalities kinds type checking 
preds provides support implementation type class overloading including simplification predicate sets construction dictionaries 
gofer type checker builds large body theoretical attempt describe 
particular assume familiarity basics standard type inference algorithms extensions qualified types constructor classes type checker depends theoretical basis 
give historical insight took approximately months develop version gofer version xx capable running small programs included hindley milner style type checker 
started add extra mechanisms required support type classes clear sufficient understanding underlying theory complete implementation 
months study resulting described summarized necessary able complete type checker 
expect understand full details implementation gofer type checker prepared spend considerable amount time studying examining 
information section provides brief complete description 
section quite long start brief outline contents 
description representations current substitution typing assumptions sections respectively show implement generalization section 
main type checking algorithm described section implementation overloading covered section 
includes details construction dictionary values 
section describes representation type checked programs 
kind inference strictly speaking part static analysis implemented ideas type checker discussed section 
section suggests simple experiments exploring workings type checker 
current substitution described representation polymorphic possibly qualified types grammar 
particular polymorphic types usually include offset values corresponding type variables original type expression 
example representation type identity function constructed expression ap polytype pair pair star star ap ap arrow identity function applied value type int need instantiate type replacing occurrence tycon representing type integers obtain ap ap arrow copying structure polymorphic type expression time instantiated gofer type checker adopts different representation monomorphic types combining skeleton type offset value 
skeleton captures basic structure type specifying types variables contains bound 
example skeleton ap ap arrow instances identity function 
notice skeleton taken directly original polymorphic type need copying 
instance uses skeleton describe approach structure sharing 
terminology similar purposes implementation logic programming languages 
second component representation monomorphic type offset array type variables structure form typedef struct type bound skeleton int offs offset kind kind kind tyvar array described current substitution viewed mapping type variables type expressions 
components type variable contain skeleton offset pair representing type variable bound 
unbound type variables represented type variables bound field nil 
third component specifies kind variable set information sig field representation polymorphic type 
describe workings type checker terms type variables type expressions remember system constructor classes allows variables constructors kinds kind types 
example expect type identity function instantiated bee applied integer values represented skeleton combined offset value pointing type variable bound kind star 
value offs matter case unbound type variables bound type 
type variables current substitution referred position array 
expression tyvar produces pointer nth element current substitution 
polymorphic types containing type variable instantiated consecutive type variables current substitution 
example offset value representation particular type occurrence cell form corresponding skeleton interpreted type variable pointed tyvar 
practice polymorphic types usually instantiated steps extend current substitution required number unbound type variables appropriate kinds 
process implemented instantiate function type returns skeleton offset value corresponding new type variable list predicates skeleton predicates overloaded functions global variables type skeleton int offset list predicates function applied arguments particular type unification algorithm match expected argument type type value applied binding variables appropriate types necessary 
representation current substitution described section possible instantiate polymorphic types new type variables efficiently copying 
biggest problem approach maximum number type variables allocated limited size array represent current substitution 
programs number type variables required type check top level binding group default setting 
programs type variables required 
pathological examples demonstrate complexity hindley milner typing exponential worst case defining terms high degrees polymorphism 
important programs large binding groups require large numbers type variables 
common source programs causing kind problem machine generated parsers produced systems 
change earlier versions gofer current distribution allows size current substitution increase dynamically type checking limits available memory course accommodate programs 
representing assumptions important data structure type checker collection assumptions types variables appear term 
obvious way represent type assumptions list pairs gives name type particular variable 
fact turns convenient split type assumptions groups bound variables variables bound expressions function arguments list comprehension generators 
variables single monomorphic type 
example definition permitted bound variable applied values distinct types right hand side funny true bound variables variables bound toplevel local definitions 
hindley milner type system gofer allows bound variables assigned polymorphic types 
example bound variable id expression id id true id type applied different types value example booleans characters causing type error 
note occurrences bound variable definition monomorphic type 
example permitted strange bool strange strange restriction necessary avoid problems polymorphic recursion type inference described 
quite versions haskell gofer extended permit weaker form polymorphic recursion requiring explicit type signature bound variable way 
types variable mixed single expression interleaving uses 
example function definition member xs xs variables member bound xs bound 
stage type checking current assumptions represented lists lists variable type pairs list bound list lambda bound lists lists easy interleave assumptions bound bound variables 
fact lists stack elements containing assumptions bound variables stage 
example type checking expression definition member lists form member mt yt xs xt types mt yt xt 
types bound assumptions take forms polymorphic type scheme monomorphic type expression just single integer referring particular type variable current substitution 
reason distinguishing different kinds variables representation assumptions bound variables require special treatment deal overloading recall bound variables overloaded types 
described detail section 
variables appear assumptions bound locally current enclosing binding group 
types globally defined values example constructor functions member functions functions definitions earlier binding groups script file obtained type field corresponding name value 
example types definition member obtained way 
addition assumptions types bound variables necessary keep list predicates capture class constraints required overloaded functions 
global variable list preds store predicates list triples contains skeleton predicate expression form tn parameter class 
tn skeletons parameter 
offset map offset values skeleton particular type variables current substitution 
expression obtain dictionary predicate 
initially expression newly generated dictionary variable inserted appropriate point translated expression 
may overwritten turns dictionary required obtained subcomponent dictionary value 
example consider expression definition 
type symbol eq bool type instantiated allocate new type variable beta current substitution generate new dictionary variable dv add triple eq beta dv preds 
time call original version program replaced dv dictionary parameter extra argument 
implementing generalization description current substitution section focussed way polymorphic types instantiated 
reverse process generalizing monomorphic type determine general type possible important operation type inference system 
generalization qualified type presence assumption set represented notation gen 
authors describe closure type respect particular set assumptions 
steps calculation generalization type need mark fixed type variables appearing current assumption set need copy type generalized replacing type variables fixed generic type variables represented offset values 
marking copying types implemented functions subst offs field unbound type variable distinguish fixed tyvar type variable appears assumption set 
unused generic type variable appearing free assumption set generic variable 
generic type variable appearing free assumption set previously encountered generic variable represented 
generalization type expression described skeleton offset value usually calculated manner 
offs field unbound type variable set unused generic function 
types current assumption set marked functions 
type generalized copied function 
occurrence fixed tyvar represented integer value variable current substitution 
time unused generic variable encountered offs field changed indicate new generic variable generic offset returned result subsequent copies variable 
full generalization operation implemented function generalise type adding type class constraints kind annotations necessary full representation polymorphic type 
basic typechecking function lies heart type checker 
line number error diagnostics problem detected expression arguments calculates type represented skeleton offset pair variables introduced section 
fact part implementation overloading returns translation input expression includes extra dictionary values parameters 
quite cases consider depending form expression consider examples 
simplest cases deals character constants represented values variable corresponds char type constructor initialized typechecker install 
fact function simple macro code expands surprisingly cases complicated 
example code conditionals follows int beta check fst snd cond check snd snd cond var beta check snd cond var beta beta step allocate new type variable beta hold type expression coinciding type expression true false branches conditional 
check macro lines calculate type particular expression generating error message type obtained unified type arguments 
types unified values parameters line number enclosing expression cond text string conditional included error message displayed system help programmer locate source problem 
uses check ensure test part conditional boolean value branches type unifying types variable beta 
final example code type check expression form letrec bs representing local definition fst snd snd snd snd snd call line pushes nil values front lists preparation addition bound variables typing bindings bs 
assumptions discarded call line type calculated 
intermediate lines type check group bindings bs find type resulting context 
third line suggests translation obtained destructively updating original expression 
complicated part type checker task finding types group mutually recursive definitions binding group 
purpose function code 
delay discussion section 
overloading innovative features design haskell support user defined overloading concept type classes introduced wadler blott 
extending earlier kaes type classes proposed general method dealing examples equality arithmetic functions fit comfortably simple polymorphic type system contrast ad hoc solutions adopted earlier languages 
ideas notation gofer extends basic system type classes haskell number ways example allowing multiple parameter classes mutually recursive class definitions constructor classes 
gofer type system differs subtle ways haskell treatment type classes 
allows fact requires arbitrary forms class constraints type expressions leads particularly simple implementation 
addition permits useful extensions possibility defining overlapping instances 
researchers including author investigated theory formal properties type classes experience practical implementations applications 
topics documented concentrate special features implementation gofer 
assume reader familiar syntax type classes gofer described chapter 
suggestions wadler blott implementation overloading gofer heavy dictionary values 
roughly speaking dictionary tuple values containing implementation overloaded functions corresponding particular instance class 
simple example consider definition eq class standard prelude class eq bool instance declaration int instance class instance eq int function primitive function type int int bool test integers equality 
default definition function explicit definition included instance declaration 
implementations packaged dictionary eqint eqint dictionary instance eq class contain implementations operators second components respectively 
general write denote nth component dictionary dictionary instance eq component equality function type bool 
implement overloaded functions member eq bool member false member ys member ys adding extra dictionary parameter replacing occurrences operator appropriate dictionary member false member ys member ys note definition works type values long ensure component dictionary passed member includes appropriate equality function component 
ideas handle default definitions case function integers implemented eqint dictionary 
function referred general function derived default definition class declaration uses additional dictionary parameter obtain implementation operator dictionary eq containing definition equality operator implementation 
type expression known compile time constant dictionary values adding extra dictionary parameters 
example expression implemented translating eqint evaluated follows eqint eqint eqint false true motivated examples split remaining description implementation overloading pieces construction dictionaries information provided class instance declarations section 
translation source programs include extra parameters dictionary values section 
dictionary construction understand process dictionary construction necessary explain representation dictionaries little detail 
general case dictionary value represented array cell values form illustrated 
storage space dictionary cells allocated header member functions superclasses instance specifics array called individual dictionary values identified position header cell array 
nth element dictionary array usually accessed expression form dict defined preprocessor macro 
dictionaries represented values heap storing corresponding integer offset snd component pair fst component 
indicated dictionary values split distinct sections header slot index dictionary contains cell value corresponding fact distinguish dictionary headers cells dictionary array 
original purpose ensure heap particular dictionary share pair 
dictionary created offset dictionary array header field dict initialized ap 
subsequent dictionary share value 
headers originally motivated concerns limited heap space original pc implementation gofer 
retrospect reduce heap saving probably quite small 
header part dictionary optional 
plays useful role ensuring allocation new dictionary strictly reduce amount space remaining subsequent dictionary allocation 
helps detect programs welltyped require infinite collection dictionaries size dictionary fixed compile time finite number dictionaries allocated space exhausted 
member functions implementations member functions particular class stored corresponding dictionaries starting index 
ordering member functions loosely determined order listed general layout dictionary class declaration instances class 
explicit member function definition included particular instance declaration default definition original class definition 
default definition member function slot filled function signals run time error 
superclass dictionaries suggested wadler blott superclasses implemented storing dictionaries components dictionaries immediate subclasses 
ordering superclass dictionaries determined form class declaration position particular superclass dictionary instances class 
example standard prelude includes class ord member functions definition begins class eq ord 
dictionary instance ord give implementation member functions gives dictionary eq equality function values type note superclass subclass terminology really appropriate possible mutually recursive classes includes distinct superclass see chapter example 
continue terms way haskell strict hierarchy enforced 
instance specifics parts dictionary format instance specifics section varies instance class depending instance declaration construct dictionary concerned 
example standard prelude contains definition equality lists eqlist eq tree int eqa eq tree int eqa eqlist eq int eqa eq int dictionary structure required instance eq tree int 
instance eq eq true xs ys ys false line declaration indicates equality lists type defined terms equality values type dictionary eq convenient store dictionary eq example 
equality lists implemented function eqlist true eqlist xs ys eqlist xs ys eqlist false example instance specifics consider definitions data tree node tree instance eq eq tree eq tree node node bs bs case instance specifics required constraints context instance declaration 
particular dictionaries eq eq tree stored positions respectively dictionary eq tree equality trees implemented node node bs bs dictionary values constructed class constraints free variables instances class types constructors involved fully determined 
example particular program requires comparison trees type tree int type checker call function preds construct suitable dictionary inserted translated version program 
may necessary invoke recursively fill dictionary values superclass instance specific sections dictionary 
particular case dictionaries required illustrated 
avoid unnecessary clutter dictionary header fields included diagram 
note particular instance class share exactly dictionary case recursion dictionaries shown 
significantly reduces amount space required store set dictionaries particular program avoids problems repeated construction discussed chapter 
sharing dictionaries achieved implementing kind memo function 
class corresponding index mapping monotypes constructors dictionaries 
allocating storage dictionary inserting path index attempting initialize components avoid trying build dictionary twice 
index constructors dictionaries implemented breaking type expression string single tycon values special values arrow list tuples strings locate required element tree form shown 
example constructor string cor int int int int int int int int bool int bool int bool bool int char char int indexing types strings constructors responding type form tn starts followed strings tn turn node index labeled constructor dictionaries corresponding individual types located traversing index obvious way 
translation binding groups main purpose section describe group mutually recursive bindings type checked show new dictionary parameters introduced necessary implement overloading 
process implemented function type current implementation convenient take arguments tn reverse order effect 
task analyze group bindings determine correct set typing rules 
cases binding group contains pattern bindings contains variable bindings bindings left hand side single variable explicit type declarations monomorphism restriction applies described section section 
function type check binding group case 
pattern bindings variable bindings explicit type signatures type checker infers general types possible bindings possibly adding extra parameters dictionaries function 
remaining case pattern bindings explicit type signatures may variable bindings 
function infer types functions binding group add dictionary parameters necessary ensure inferred types match declared types 
rest section concentrate second case 
arguably little easier third little complex need deal user supplied type constraints basic principles 
consider binding group form shown mutually recursive bindings variables 
fm bodies 
em explicit type signatures variables 
args fm args em steps calculating types possibly translated definitions variables follows new type variables allocated type corresponding fi values saved top level 
bindings group type checked 
equation fi args ei calculate types left right hand sides unify results ensure 
process dictionary variables added overloaded variable ei corresponding triples added preds described section 
type checking complete may turn need add extra dictionary parameters fi need traverse bodies second time replacing fi expression form fi dv 
dictionary parameters dv 

worst case nested binding groups repeated traversals expensive 
type checker arranges particular bound variable variable bound share exactly pair cell heap overwritten point extra parameters really necessary 
reasons distinguishing bound variables representation assumptions 
bindings processed type checker marks fixed variables current substitution way described section function deal class constraints accumulated preds 
ways eliminate triple pi beta preds stage pi contain free type variables function described section construct corresponding dictionary overwrite pointer 
free type variables pi marked fixed point including type fi generalize variables contains 
predicate treated constraint environment contains binding group 
cases correspond directly concepts constant locally constant overloading described 
remaining predicates preds simplified possible reduce number dictionary parameters required 
simplification process eliminates duplicate predicates preds 
predicates eliminated derived superclasses instance specifics members preds 
described section consider instance specifics way error original design may change behaviour releases system 
basic simplification algorithm implemented function simplify preds described pseudo code simp ps iterate ps 
length ps ps entails ps ps ps main idea eliminate predicate implied entailed remaining predicates ps 
addition simplification algorithm overwrites dictionary variable predicate removed suitable dictionary expression form 
case duplicate predicates corresponding dictionary parameters algorithm overwrites copy cell 
sharing single copy avoid problems overwritten simplification process 
dictionary variables remaining preds list added extra parameters variables binding group obtain translated versions original definitions 
similarly combine predicate parts constraints preds type bound current substitution generalize section calculate principal type fi 
consider description type checking group implicitly typed bindings daunting 
part complexity caused need deal overloading lot detail show simple rules formal presentations type inference 
hand level complexity uncommon dealing complete languages static semantics haskell definition ml 
syntax type checked programs gives grammar bindings produced results type checking 
important points type annotations longer included bindings 
binding var alt var pat rhs expr letrec binding expr cond expr expr expr ap expr expr const name name var text select int dict expr comp expr expr comp runst expr case expr pat rhs lambda alt grammar type checked bindings type annotations expressions example term int represented values previous stages included typed terms 
dictionary selector functions dictionary constants introduced select values respectively 
note select just representation dictionary selector function section 
comprehensions previously represented comp values split cases list comprehensions monad comprehensions 
note type checker produce values standard prelude containing suitable definitions monad constructor classes 
representation monad comprehensions includes expressions appropriate monad monad dictionaries respectively 
case comprehension interpreted arbitrary monad second dictionary expressions replaced nil 
kind system just types classify values kinds classify type constructors 
kind system gofer primarily support implementation constructor classes described main roles calculate suitable kinds data type constructors classes program kinds ensure formed type constructor expressions gofer programs 
complexities polymorphism overloading kind system implemented greatly simplified version type system 
readers struggling understand basic features type checker may find study kind inference code kind provides somewhat smoother 
mentioned kind checking really viewed part static analysis program type checking 
included section similarity main type 
importantly kind included part type data structures represent current substitution described section difference bound offs fields current substitution represent kinds kind field 
forms kind expression kind denoting collection types represented star function kinds form represented pairs pair representations respectively 
purposes kind inference offset values form skeleton kinds 
paired offset current substitution represent kinds initially unknown 
details kind system definitions kind straightforward implementation ideas described 
experiments type understand program works useful able examine study results produces different inputs 
particularly important stages gofer system type checker compiler machine support effort converting source programs machine code concentrated 
components describe simple ways modify gofer gain insight inner workings system 
features originally included gofer source code aid debugging 
main source file type checker type includes macro definitions symbols debug types debug kinds 
normally commented effect 
removing comments definition reads define debug types rebuilding system obtain modified version interpreter prints lot extra information type checking 
particular includes details allocation new type variables results unification new assumptions bound variables results type checking individual expressions 
large programs produces considerable amount output normally redirected file browsed text editor similar tools 
similar way removing comments second define obtain define debug kinds yields modified version interpreter displays inferred kinds datatype type class source program 
possible get insight construction dictionary values adding line define debug code type recompiling previous examples standard distribution include commented version line 
flags described combination select information interest 
format output complicated explain expect frequent gofer source code experiments 
compilation supercombinators having dispensed parsing static analysis type checking compiler translate gofer programs definitions 
translation implemented steps described subsections 
program transformation step compilation supercombinators translate gofer programs simpler language provides core elements features comprehensions pattern bindings advantage avoids complexity subsequent parts compiler 
switching simpler representation earlier stages eased task writing static analysis type checking components gofer system 
difficult give useful error messages helping gofer users locate source errors programs 
fortunately errors kind occur program passed successfully type checker leaving compiler free adopt different representations 
reduction core language carried tree walk structure type checked programs 
grammar output language described 
main steps transformation binding var alt rhs guarded expr expr letrec binding rhs expr expr letrec binding expr cond expr expr expr ap expr expr const name name var text select int dict grammar translated bindings follows 
line numbers removed representation right hand sides represented nonterminal rhs grammars report 
need retain information compiler expect program errors detected retrospect may little hasty considered possibility modifying pattern matching compiler described section produce warning messages non exhaustive definitions 
line numbers difficult relate errors back input program 
local definitions cast lists lists bindings dependency analysis flattened simple letrec values suggested expansions section 
list monad comprehensions eliminated translations suggested wadler respectively 
case lambda expressions eliminated translating equivalent expressions local definitions 
example expression xs case xs ys map ys translated xs ys map ys xs note requires new variable names case fact names gofer uses generated function described section printed letter followed number certainly seen variables result translation entered lambda expression arguments gofer interpreter 
pattern bindings reduced simple variable bindings 
example xs translated conf conf head xs tail 
couple items deserve attention 
function conf implement conformality test ensure value matches pattern xs 
conformality tests left hand side pattern binding contains irrefutable pattern 
addition gofer provides command line flag suppress conformality tests small change semantics pattern bindings 
default conformality tests ensure compatibility haskell 
notice new variables names case conf generated part transformation 
second point functions head tail code compiler generates calls internal primitive function printed sel 
definitions xs sel xs sel general sel extract nth component value constructed constructor function valid type sel function gofer system 
cause problems introduced type checking complete 
important type safety restored introducing special families selectors datatype think sel name function sel 
compilation pattern matching transformations described previous section significant complication representation gofer programs patterns function bindings 
section describes program transformation closely wadler description reduces pattern matching function definitions particularly simple form 
example standard map function usually defined map map xs map xs translated map case map description previous section eliminating case expressions translating function definitions may step back wrong direction 
important realize pattern matching compiler translate arbitrary functions definitions 
contrast function bindings introduced result case bindings original program special case exactly argument 
important fact case expressions produced pattern matching compiler nested patterns 
example nested pattern binding source function definition ys ys translated nested pair case expressions case case 
representation output pattern matching compiler little unusual include binding occurrences variables 
examples variable names 
bound variable names 
fact actual representation examples somewhat closer map arity case map arity case case 
main idea annotate function bindings arities omit bound variables pattern matching leaving just original constructor functions constants 
required omitted argument variables inferred context 
idea locally bound variables locally bound functions eliminated transformations described section 
example give standard haskell definition function filter results produced pattern matching compiler actual representation implicit naming bound variables 
example includes examples different ways local bindings occur function arguments patterns local definitions filter filter xs rest filter xs rest rest filter case filter filter arity case filter problems representation meaning expression depends context appears 
example local definition final version filter tell name variable bound filter 
fact appears scope function bound variables pattern bound variables necessary determine correct variable name case 
fortunately fairly easy keep track number bound variables traverse representation programs current offset parameter functions compiler hand choice representation important benefits 
omitting binding occurrences variables reduces space needed store compiled programs 
savings quite small important early pc implementation gofer space limited 
significant benefit naming scheme bound variables carefully optimized compatibility gofer machine described section 
particular variables 
represented offset values corresponding positions corresponding values stack program executed 
doesn mean results compiler different machine 
special case gofer machine avoids need special environment mapping variables stack locations gofer compiler added time initial design compiler uses compile time optimization changes direct mapping offsets stack locations 
simulation run time stack determine new location bound variables 
see section 
output pattern matching compiler described grammar 
rhs var int fvs ffs rhs rhs guarded expr expr letrec rhs case offset offset match fatbar rhs rhs expr match discr rhs expr letrec expr offset offset 
bindings pattern matching compiler additional comments necessary point important features 
preparation lambda lifting described section lists local definitions separated list expressions implicitly bound offset value list function definitions 
function definition represented grammar includes name function arity triple form fvs ffs rhs rhs right hand side body function 
fvs list offsets corresponding free variables appearing rhs 
ffs list referenced rhs 
links values reflecting dependencies 
note values included ffs may defined list current value enclosing scope 
illustrate information section 
task collecting details little pattern matching compiler gofer implemented haskell language process probably described separate pass representation compiled terms 
working chose merge steps avoiding repeated traversal program graph 
final comments may necessary explain fatbar construct 
right hand side form fatbar describe combination behaves fails failed pattern match guard case behaves exactly fatbar operator 
simple example compilation function null true null xs false writing definition way requires second equation fails 
applying pattern matching compiler definition produces definition null arity fatbar case true false reason introducing fatbar new construct primitive function easier code generator recognize right hand sides form practice uses fatbar construct eliminated code generation 
exception fatbar construct appears right hand size local variable definition non strict context 
code generator primitive function deal case 
lambda lifting lambda lifting program transformation eliminates local function definitions 
result program containing closed global functions known supercombinators term coined hughes presentation algorithm lambda lifting 
gofer compiler includes implementation alternative algorithm proposed johnsson introduced term lambda lifting 
descriptions johnsson algorithm may section chapter 
point program analyses transformations described fairly general largely independent particular implementation technique expect find similar components implementation non strict functional language 
hand lambda lifting essential compilation languages example lambda lifting required implementations turner peyton jones 
reason including lambda gofer transform gofer programs form compiled execution gofer machine variation chalmers machine described section 
simple example lambda lifting algorithms simple idea turn local function definition global function definition add extra parameter free variable body function 
illustrate effect lambda lifting algorithm gofer definition foldr function 
convenience write definition standard gofer syntax 
course practice point compiler definition represented case expression foldr xs xs style definition local definitions describe higher order functions popular gofer programmers 
hand definition foldr haskell report equivalent local definition 
see main effect lambda lifting example convert definition closely resembling definition haskell report 
stands treat global function includes free variables definition 
adding variables extra parameters obtain definition foldr xs xs new definition refer free variables lift definition new global function foldr xs xs reduced original program pair definitions local function bindings 
fact example opportunity improve definitions reduction define foldr better substituting foldr lifted function definition gives foldr foldr xs foldr xs final optimization reduction included current gofer implementation useful production quality compiler 
lambda lifting recursive definitions general case lambda lifting complicated need deal mutually recursive function definitions 
example consider definition 
approach previous example observe appears free appears free definitions rewritten 
turn definitions global functions transformation introduced new free variables body function 
example appears free body 
repeat original process adding parameters function definitions obtain 
definitions lifted global functions 
explain process little formally write lv set variables added lifted global definition fv set variables appear free body task find solutions simultaneous equations lv fv lv lv fv lv accurately prefer add parameters possible real task find solution equations 
fortunately simple way find solutions equations sequence approximations iterating reach fixed point 
words generate sequence values form lv lv equations lv fv lv fv lv lv lv lv lv lv reach point sequence sets produced change step 
finite number equations process guaranteed terminate finite number steps obtaining minimal solution original equations result 
technique applies arbitrary collections function bindings 
function need find smallest possible solution equation form lv fvs lv ffs fvs ffs free variables free functions respectively body note exactly values arranged pattern matching compiler store representation values described section 
information solve function compiler solve simultaneous equations calculate sets variables added definition 
apart adding extra parameters function need add appropriate variables extra parameters calls lifted functions 
example replacing calls calls 
direct implementation define function carry substitutions form replacing free occurrences expensive certainly require multiple traversals program fragments particularly dealing nested local definitions 
implementation avoids problem standard technique implementation programming language interpreters environment tr record translation variable 
information needed compute lv sets calculated lambda lifting translation environment tr extended appropriate translations locally defined functions traversing bodies scope local definition 
avoids need multiple traversals 
representation supercombinators result lambda collection global functions supercombinators described name arity right hand side form specified grammar 
representation rhs guarded expr expr letrec rhs rhs case offset offset match fatbar rhs rhs expr match discr rhs expr letrec rhs expr cond expr expr expr ap expr expr const offset offset name name select int dict grammar supercombinators definitions passed code generator machine pre compiler final poorly named stage compiler results lambda form input code generator 
structure compiled programs modified process 
changes adjustments numeric values offset values corresponding bound variables 
necessary decision binding occurrences variables implicit representation programs described section 
see adjustments necessary consider example rewriting implicit naming bound variables gives arity arity lambda lifting adds extra parameter produces definitions arity arity expanding implicit bindings definition clearly wrong variable right hand side appear left 
fortunately fairly easy calculate correct offset values lift body locally defined function know arity function prior lifting offset right hand side list free variables added extra parameters 
values parameters function example respectively 
writing length lifted function arity adjusted value offset body lifted function calculated follows corresponds free variable included list 
adjusted offset value range determined position list 
corresponds parameter function lifting maps offset range corresponds offset introduced body function maps offset example calculations map correct definition generated pre compiler arity parameters description correspond respectively current implementation 
despite appearances calculation adjusting offsets straightforward 
reason including details illustrate consequences non standard representation programs implicit bound variables 
experiments compiler best ways explore understand workings compiler study output produces particular gofer programs 
program provides easy way inspect output compiler fairly readable form 
systems command form prog gs run dumping pretty printed versions supercombinators definitions prog gs including prelude file prog gsc 
theory output file source code alternative back gofer system 
useful example experiments new code generators program analyzers gofer front writing new parser type checker problem current pretty printer include structure dictionary values output file 
shortcoming fixed modifying printer avoiding programs prelude files involve type classes 
program execution code machine compile definitions produced compiler instructions machine simulate execution machine provide lazy evaluator gofer programs 
differences part gofer system borrows heavily ideas chalmers machine described 
hand isolating details machine single file principle possible replace part gofer system alternative back ends example instruction machine 
practice may require changes system example storage management routines storage support heap allocation closures compiler add extra program transformation steps 
include formal rules translating gofer programs instruction set gofer expr ap expr expr const name name dict int representation program graphs machine report serve duplicate details clearly documented source code machine give detailed description way gofer machine works including description instruction set give examples illustrate implement reduction 
evaluator gofer programs executed evaluating expressions 
result list characters list requests determines user sees results running program 
starting initial expression represented graph structure heap gofer uses evaluator transform graph sequence reductions corresponding equation source program built system primitive 
simple example evaluation expression show requires reduction steps show show show internally expressions represented simple form program graph stored gofer heap described grammar 
note program graphs closed expressions free variables built atomic values function application 
graph structures necessary general case programs may include shared subexpressions cycles introduced recursive definitions 
values introduced implement input file lazy stream 
notice grammar program graphs includes dictionary values need include selector functions applications selectors implemented efficiently dict instruction described section 
simplicity consider overloading show arithmetic operations example 
strictly speaking included extra production indirection nodes grammar exprs indirections simply pointers expressions heap implementation lazy evaluation particularly update instruction described section 
returning example step reduction sequence implemented graph rewrite 
example reduction sequence corresponds show show evaluator implemented function eval reduces cell value passed argument weak head normal form 
suppose original expression represented program graph form en starting application labeled evaluator works way spine graph recording values application node stack reaches head base record original position stack pointer evaluator begins layout stack time head reached illustrated diagram base sp important cases need consider follows constant value example integer floating point number expression weak head normal form 
fact type system guarantees arguments case 
return result evaluator stores value head global variable serving register machine 
value integer evaluator records corresponding integer value variable 
similar way floating point numbers returned placing corresponding value variable 
constructor function expression weak head normal form 
evaluator returns head expression variable 
addition elements stack rearranged calling program access values arguments constructor function example layout stack evaluator returns en base sp illustrate fragment code shows gofer evaluator calculate sum list integers specified expression total eval eval pop head total total eval pop tail notice necessary evaluate just node list integer value contains 
hand gofer type system allows omit run time type checks code 
example need check value produced eval pop statement integer type system guarantees 
function expecting fewer arguments evaluator calls code carry appropriate modifications graph 
code may implemented built primitive function coded sequence machine instructions described 
calling function evaluator rearranges values stack 
suppose arity set point root identify top elements stack arguments base am root sp easier code access argument values application nodes came modify stack give base am em root sp note value am retained root position stack code overwrite original call resulting expression 
function may require evaluation argument values achieved calls eval body code reduction complete evaluator resets stack pointer root position continues unwinding result reduction stack looping weak head normal form obtained 
machine instructions small number gofer functions implemented primitives hand coded functions typical program represented sequences instructions executed gofer machine 
instructions purposes examine arguments function determine equation definition function applied appropriate rewrite 
list instruction set gofer machine groups 
group described section primarily construct result reduction 
second section deal control flow 
instructions constructing values instructions construct fragments program graph stack store temporary values function parameters results calls evaluator 
load push value position current stack frame top stack 
access values function arguments locally bound variables 
cell push constant cell value specified top stack 
access constants constructor functions supercombinators 
char push character value top stack corresponding integer value int push integer top stack 
float push floating point number top stack 
string str push string value str top stack 
note string represented text value described section 
apply function top stack argument values immediately 
top elements stack replaced resulting expression 
note instruction involve evaluation function arguments resulting expression 
example instruction takes stack form root xn reduces stack root sp xn 
sp update removes value say top stack updates nth element current stack frame pointer indirection node example instruction update reduces stack form root stack root sp root root sp instruction overwrite root expression part implementation lazy evaluation ensure proper sharing result expression 
save values variables bound local definition 
indirection cell avoid loss laziness section 
indirection reflected symbol diagram 
instruction effect instruction followed update instruction words nth element current stack frame replaced application formed top values stack subsequently discarded 
difference instruction known nth element stack points application node case old application node overwritten new values avoiding need allocate new application node 
alloc allocates pairs initialized second components nil pushes pointer pair allocated stack 
instruction part process initializing possibly recursive local variable bindings 
slide slides value top stack places removing values immediately 
instruction deal expressions involving local variable definitions 
example suppose expression constructed values 
vn bound local variables 
produces stack form root vn sp executing slide instruction produces stack form root sp course expression may contain pointers values 
vn 
dict replaces value top stack dictionary value say value held nth slot instruction implement dictionary lookup compiling expressions form instruction sequence code build 
dict type system ensures dict instruction value top stack dictionary 
furthermore dictionary values required program constructed executed need evaluate dictionary dict instruction 
dict implemented efficiently just couple machine instructions needing run time representation dictionary selectors 
root implementation root optimization see section details 
control flow instructions call evaluator test values returns indicate particular reduction signal irreducible expression 
eval pops top expression stack calls evaluator calculate value 
addr value register equal integer constant continue current sequence instructions 
values equal control transfers addr 
instruction support pattern matching integer constants 
addr value register greater equal integer pushed stack 
test fails control passes address addr 
instruction support patterns 
example addr instruction match value top stack pattern 
value top stack match fails execution transfers instruction addr 
match successful value pushed stack gives value bound variable extending gofer allow patterns matched values type integral class permitted haskell require extensions instruction significant changes program transformations compiler versions gofer eliminate support patterns altogether 
addr similar instruction determine value register positive multiple integer value pushed stack 
control transfers instruction address addr 
instruction support pattern matching patterns added experimental feature gofer interpreter 
form pattern considered obsolete 
test addr instruction compares value register value cell constant branching instruction address addr values 
instruction implementation pattern matching 
illustrate consider conditional expression note equivalent case expression case true false code calculate value conditional situations clear results conditional required conditional appears strict context code build 
eval test true label code build 
return label code build 
return sections code build expression expected leave required expression unevaluated top stack 
aside situations sure value conditional required code form code build 
code build 
code build 
cell build delayed version conditional expression 
cell refers primitive function defined true false clearly prefer code containing test instruction possible avoids need build code program executes 
goto addr causes unconditional jump instruction address addr 
return signals possible path code 
return function usually follows update instructions update root current redex 
fail signal failed pattern match usually resulting run time error 
convenience current version code generator places single fail instruction fixed address recorded variable initialization process 
pattern matching failures parts program triggered branching address 
resets stack pointer root instruction set stack pointer known position situations value determined compile time 
root optimization quite functions gofer standard prelude initial parameters recursive call 
example function call map definition map map xs map xs apart standard user defined functions program transformations gofer compiler generate definitions form particularly addition extra parameters implementation overloading 
parameters call shame duplicate time 
gofer code generator avoids problem detecting places part original expression reduced reused construct result 
example second equation definition map corresponds reduction map xs xs map case need reconstruct application map recycle application left hand side 
result reduction requires allocation new application nodes nodes normally required 
refer root optimization expressions recycled derived initial portions root original expression 
machine instruction root implement root optimization purpose push expression obtained deleting parameters root top stack 
example see section root instruction compilation map 
root optimization originally described including figures suggesting reduction space requirements small examples optimization 
aware systems similar optimization 
examples section gives examples machine code produced system implement combinator reduction 
simplest example identity function defined id corresponding sequence machine instructions load update return values left addresses instructions right 
code easy follow push argument stack overwrite original call id function 
slightly complicated implementation function composition defined described instructions load load load return instructions load values stack combine form subexpression result 
instructions overwrite root original call 
application completing reduction 
simple example pattern matching consider function defined false false true corresponding instruction sequence follows load eval test false cell false update return test true load update return instructions evaluate argument 
result false definition returns value false line labeled 
result false branch test instruction labeled 
label just value mentioned description fail instruction 
strictly speaking instruction redundant program branch type system guarantees possible results occur false eliminated true 
remaining instructions simply overwrite original expression value second parameter implementation id final example sequence instructions generated definition map function load eval test dc cell de update return test load root ea load ec load ee cell return comment example leaving task understanding instructions implement map function strongly recommended exercise reader 
experiments machine type checker compiler best ways understand workings machine study programs produces output 
achieved modifying source code include line define debug code machine recompiling 
produce custom version shows code compiled function produced code generator 
practice tends produce lot output probably best redirect output modified compiler file examined carefully text editor 
examples previous section obtained version interpreter modified way 
functional programming imperative world described section reasons gofer system written functional language 
looking source code clear functional programming significant influence development 
places small fragments gofer code type annotations develop sections program coding difficult find aspects implementation gofer influenced functional programming systems including garbage collected heap constructor functions pair selectors hd tl fst snd 
simple list processing functions length destructive append reverse implemented functions 
preprocessor quite heavily example support weak forms higher order functions polymorphism 
example implementation uses range map operations processing lists values implemented macros define init step list zs init nonnull zs zs tl zs step aspects current implementation rely side effects example error trapping mechanisms implementation type checking garbage collection graph reduction 
implemented cleanly efficiently purely functional language remain open uninteresting problems 
experience gofer believe ideas idioms functional programming play important useful role development programs written traditional imperative languages 
gofer compiler short time release gofer asked easy produce simple minded compiler translate programs written functional language executable code concerns performance 
machinery developed gofer interpreter turned relatively simple task 
gofer compiler developed modifying backend interpreter output suitable code machine instructions program 
combined run time system derived simplified version interpreter storage management system implementation primitive functions allows development small stand gofer applications 
performance terms simple tests suggest compiled programs typically offer twofold increase run time speed interpreted code 
serious haskell compilers better sophisticated implementation analysis optimization techniques 
addition support form separate compilation making unsuitable large projects requiring repeated compilation 
favour produces significantly smaller executable binary files systems 
translation gofer programs usually quite fast compilation resulting programs take longer 
extent interpreter reduces problems caused lack separate compilation offering responsive interactive development environment delaying need compilation final stages project 
important advantage simplified run time system require conservative garbage collector 
particular necessary scan stack look pointers heap avoiding problems restrictions garbage collection system interpreter described section 
fact source code currently includes different garbage collectors simple mark scan collector space copying garbage collector supports allocation variable length blocks heap space add implementation haskell style arrays access time 
contrast array implementation mark scan collectors interpreter compiler requires efficient representation arrays linked pair cells 
certainly possible extend run time system support different garbage collectors 
example obvious possibility experiment implementation simple generational collector 
go great details translation machine instructions corresponding code 
simple example implementation map function taken directly output compared sequence machine instructions map section 
comb sc map map eval offset test goto update ret test fail heap offset offset offset offset ret code heavy preprocessor macros defined header file lines form heap test availability blocks stack heap storage avoiding need check overflow push pair call respectively notice constructor functions represented values form 
example nil list cons function represented values respectively 
values represent boolean values false true type system ensures uses confused 
choice representation mean impossible write fully polymorphic primitive function show interpreter able interpret run time structure value produce corresponding printable representation string 
major shortcoming exactly kind application type classes intended 
feature translation machine instructions technique suggested section simulate run time stack compile time 
allows code generator avoid unnecessary stack requires complicated form instructions generated programs 
example single line heap instruction useful space collector allows allocation cells contiguous blocks 
mark scan collector just efficient continue testing heap exhaustion pair call treat heap calls ops 
offset offset implementation map corresponds sequence machine instructions load root sequence instructions uses stack locations duplicating value available position stack 
values pushed stack treated implicitly arguments instruction 
contrast code version avoids unnecessary pushes requires arguments specified explicitly 
clear noticeable effect execution time 
compiler shares substantial amount code interpreter 
main program code generator definitions built functions different corresponding components interpreter 
fact early decision ensure compiler interpreter built exactly compiled object code common components 
sharing code degree obvious benefits example version type checker maintain compile 
necessary compromises code allow proper sharing results entirely satisfactory 
implementation run time system runtime suffers severe problems share code parts system 
result primitive function interpreter rewritten compiler 
tedious best coding errors leading discrepancies behaviour compiled interpreted code 
addition run time system compiles single object code file included compiled program 
better approach arrange library modules allowing linker free omit definitions needed program 
fact goes lengths avoid including unused code user programs principles primitive functions 
sight hope problem overcome simply source code run time system separate parts 
unfortunately necessary fundamental changes representation primitives obtain benefits 
example programs fraction functions defined standard prelude 
really surprising implementation system intended designed support compiler 
opportunity develop new version system point allowing interpreter compiler initial design avoiding structural problems current version 
programmer knows development system provides valuable lessons version 
directions amount time available gofer currently quite limited plenty ideas developments extensions system 
final section describe topics indication possible directions development gofer system 
closer compatibility haskell goal closer compatibility may strange gofer closely haskell 
mentioned earlier small annoying incompatibilities languages subset 
fortunately problems severe new releases gofer move slowly closer compatibility haskell 
module system thought gofer released small programs 
lines lines certainly 
concerns able run interpreter small machines appropriate avoid complexities form module system 
quite sensible approach intended gofer experimental system easier develop experiment language extensions worry interaction modules 
gofer quite large programs form module system useful 
concessions area extend parser read ignore mod cases desirable remove features 
making firm commitments particular features studies current version source code reveal possible compile interpreter support patterns dialogue style ule headers haskell programs 
means haskell programs making trivial modules fed directly gofer changes 
gofer way develop sections programs ultimately compiled full haskell system 
option particularly goals compatibility mind add proper implementation haskell module system 
require fair amount quite feasible 
difficult task adapt current interactive user interface deal properly collections program modules 
see dealing similar problems targeted scheme programmers 
hand haskell module system criticized weakest parts language definition may change versions language 
ambitious goal gofer testbed alternative module systems providing example power standard ml style parametric modules preserving character haskell including type classes lack side effects call name lazy semantics 
currently exploring proposals module systems kind long way concrete implementation 
records weakest aspects collection primitive datatypes available gofer programmer lack support form records 
semantic viewpoint records just form tuple programmer convenient access components large tuple name position 
records form standard part languages pascal standard ml included current definition haskell 
flexible implementation extensible records building qualified types suitable inclusion gofer proposed 
hope experiment prototype implementation system near 
performance optimization execution speed major design goal pleasantly surprised performance gofer interpreter 
having developed system permits functional programming small computers nice offer level performance necessary language realistic tool serious application development machines 
possibility build ambitious compiler targeted machine interpretive overhead sophisticated optimization techniques 
lessons learned gofer implementation pushed far expectations original design source extended patched modified times relatively short life 
process learnt useful lessons design improved 
hope long opportunity develop new cleaner version system building experience 
preparation report supported part arpa contract number 
gofer users frequent questions implementation prompted write report 
particular ran carl helpful comments earlier draft 
current version gofer began january home pc borland turbo compiler 
development system continued small bursts time permits 
fortunately opportunity upgrade development system little early days 
know hours working development gofer documentation sample programs report 
carried home times spent wife melanie 
special heart felt constant support encouragement patience 
tiuryn kfoury urzyczyn 
type reconstruction presence polymorphic recursion 
acm transactions programming languages systems april 
andrew appel 
garbage collection faster stack allocation 
information processing letters june 
andrew appel david macqueen 
standard ml new jersey 
martin wirsing editor third international symposium programming language implementation logic programming pages new york august 
springer verlag 
lecture notes computer science 
augustsson johnsson 
chalmers lazy ml compiler 
computer journal april 
lennart augustsson 
implementing haskell overloading 
fpca conference functional programming languages computer architecture copenhagen denmark new york june 
acm press 
hopcroft aho ullman 
design analysis algorithms 
addison wesley 
bird wadler 
functional programming 
prentice hall 
stephen blott 
approach overloading polymorphism 
phd thesis department computing science university glasgow july 
draft version 

boehm weiser 
garbage collection uncooperative environment 
software practice experience september 
boyer moore 
sharing structure theorem proving programs 
machine intelligence 
edinburgh university press 
damas milner 
principal type schemes functional programs 
th annual acm symposium principles programming languages pages albuquerque january 
hall hammond partain peyton jones wadler 
glasgow haskell compiler retrospective 
proceedings glasgow workshop functional programming ayr scotland july 
springer verlag workshops computing series 
cordelia hall 
overloading express distinctions evaluators 
information processing letters december 
hammond blott 
implementing haskell type classes 
proceedings glasgow workshop functional programming scotland 
springer verlag workshops computing series 
sho huan simon tung 
interactive modular programming scheme 
acm conference lisp functional programming san francisco ca june 
hudak peyton jones wadler editors 
report programming language haskell non strict purely functional language version 
acm sigplan notices may 
hudak wadler editors 
report programming language haskell non strict purely functional language version 
technical report university glasgow april 
hughes 
graph reduction supercombinators 
technical monograph prg programming research group oxford university computing laboratory 
johnson 
yacc 
unix programmer manual 
johnsson 
lambda lifting transforming programs recursive equations 
jouannaud editor proceedings ifip conference functional programming languages computer architecture pages new york 
springer verlag 
lecture notes computer science 
mark jones 
new approach type class overloading 
distributed haskell mailing list february 
mark jones 
computing lattices application type classes 
technical report prg tr programming research group oxford university computing laboratory oxford england june 

mark jones october 
article posted internet newsgroup comp lang functional 
mark jones 
gofer september 
available anonymous ftp nebula cs yale edu directory pub haskell gofer part standard gofer distribution 
mark jones 
release notes gofer november 
included part standard gofer distribution 
mark jones 
type inference qualified types 
technical report prg tr programming research group oxford university computing laboratory oxford england may 
largely 
mark jones 
computing lattices application type classes 
journal functional programming october 
updated expanded version 
mark jones 
efficient implementation type class overloading draft 
superseded chapters march 
mark jones 
qualified types theory practice 
phd thesis programming research group oxford university computing laboratory july 
published cambridge university press 
currently available technical monograph prg oxford university computing laboratory programming research group road oxford ox qd email library comlab ox ac uk 
mark jones 
theory qualified types 
esop european symposium programming rennes france new york february 
springer verlag 
lecture notes computer science 
mark jones 
partial evaluation dictionary free overloading 
research report yaleu dcs rr yale university new haven connecticut usa april 
mark jones 
release notes gofer february 
included part standard gofer distribution 
mark jones 
system constructor classes overloading implicit higher order polymorphism 
fpca conference functional programming languages computer architecture copenhagen denmark new york june 
acm press 
simon peyton jones 
implementing lazy functional languages stock hardware spineless tagless machine 
journal functional programming april 
peyton jones wadler 
static semantics haskell draft 
technical report department computing science university glasgow february 
stefan kaes 
parametric overloading polymorphic programming languages 
esop european symposium programming nancy france new york 
springer verlag 
lecture notes computer science 
brian kernighan dennis ritchie 
programming language 
prentice hall edition 
konstantin ufer martin odersky 
statically typed language 
proc 
oopsla workshop reflection metalevel architectures september 
launchbury peyton jones 
lazy functional state threads 
conference programming language design implementation orlando fl june 
appear 
xavier leroy michel mauny 
caml light system version documentation user guide 
technical report inria 
milner 
theory type polymorphism programming 
journal computer system sciences 
robin milner mads tofte robert harper 
definition standard ml 
mit press 
torben mogensen 
parser generator scanner generator gofer 
nipkow snelting 
type classes overloading resolution order sorted unification 
th acm conference functional programming languages computer architecture new york 
springer verlag 
lecture notes computer science 
tobias nipkow christian prehofer 
type checking type classes 
proceedings th symposium principles programming languages 
acm january 
peterson jones 
implementing type classes 
proceedings acm sigplan symposium programming language design implementation 
acm sigplan june 
peyton jones wadler 
imperative functional programming 
proceedings th symposium principles programming languages 
acm january 
peyton jones 
implementation functional programming languages 
prentice hall 
peyton jones lester 
implementing functional languages 
prentice hall 
geoffrey seward smith 
polymorphic type inference languages overloading subtyping 
phd thesis department computer science cornell university ithaca new york august 
robert tarjan 
depth search linear graph algorithms 
siam comput 
david turner 
new implementation technique applicative languages 
software practice experience 
volpano smith 
complexity ml typability overloading 
th acm conference functional programming languages computer architecture new york 
springer verlag 
lecture notes computer science 
wadler 
efficient compilation pattern matching 
chapter 
wadler 
list comprehensions 
chapter 
wadler 
essence functional programming invited talk 
conference record nineteenth annual acm sigplan sigact symposium principles programming languages pages jan 
wadler blott 
ad hoc polymorphism ad hoc 
proceedings th acm symposium principles programming languages pages jan 
wadler miller 

technical report programming research group oxford university computing laboratory 

pitfalls conservative garbage collection 
software practice experience july 
wray fairbairn 
non strict languages programming implementation 
computer journal april 
