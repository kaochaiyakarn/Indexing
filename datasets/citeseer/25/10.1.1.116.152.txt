system modeling design refinement forsyde ingo sander stockholm thesis submitted royal institute technology partial fulfillment requirements degree doctor technology sander ingo system modeling design refinement forsyde isbn issn isrn kth se copyright ingo sander april royal institute technology department microelectronics information technology laboratory electronics computer systems kista sweden advances microelectronics allow integration functionality single chip 
emerging system chip architectures include large amount heterogeneous components increasing complexity 
applications architectures require low level details order yield efficient implementation 
hand constant time market pressure electronic systems demands short design process allows model system high abstraction level low level implementation details account 
clearly significant abstraction gap ideal model specification implementation 
abstraction gap addressed methodologies electronic system design 
thesis presents forsyde formal system design methodology developed objective move system design higher level abstraction bridge abstraction gap transformational design refinement 
forsyde carefully selected formal foundations 
initial specification model uses synchronous model computation separates communication computation notion time 
forsyde uses concept process constructors implement synchronous model allow design transformation mapping refined model target architecture 
specification model refined detailed implementation model stepwise application defined design transformation rules 
rules semantic preserving inflict design decision modifying semantics 
design decisions introduce low level implementation details needed efficient implementation 
implementation model mapped components target architecture 
forsyde models mapped vhdl order allow commercial tools generate custom hardware sequential software 
thesis uses digital equalizer illustrate concepts potential forsyde 
iii iv research funded royal institute technology swedish foundation strategic research 
people form contributed described thesis 
want take opportunity say big 
particular formal informal supervisors years 
biggest goes supervisor professor axel jantsch contributed various ways encouraged took time discussions research 
lot fantastic supervision 
want professor hannu years put enormous effort development research education electronic system design department 
want professor ahmed long time ago accepted phd student introduced research 
want past current phd students esd working 
possible mention name 
want particular andreas convinced functional languages fantastic ashish forsyde discussions strangely resulted joint learned dangerous johnny learned sweden fantastic patrik organized participated soccer matches esd lab dinesh chess games discussions 
special goes hans people system group department day night give great working environment 
lot lena administrative help 
want send old department campus 
want lars gave opportunity combine teaching phd studies 
special eva discussions research general 
big vi directly contributed thesis working fun 
mother father put right track 
biggest goes wife children maria tobias 
am lucky person 
stockholm april ingo sander contents motivation 
embedded systems 
embedded system design 
forsyde approach embedded system design 
thesis objectives 
author contribution 
publications included thesis 
publications included thesis 
thesis layout 
background models computation 
synchronous languages 
design methodologies 
hardware software design 
declarative approaches system design 
design transformation 
haskell 
system models forsyde formal models forsyde 
definition computational models forsyde 
signals 
processes 
specification model 
implementation model 
forsyde modeling language 
vii viii contents summary 
development specification model modeling forsyde 
equalizer specification model 
subsystem 
subsystem distortioncontrol 
subsystem 
subsystem audioanalyzer 
discussion 
design refinement transformational design refinement 
characteristic functions processes process networks 
processes synchronous process constructors processes domain interface constructors 
combinator processes 
network processes 
design transformations 
refinement equalizer 
refinement clock domain 
communication refinement 
resource sharing 
summary discussion 
implementation mapping 
mapping implementation model vhdl 
generation vhdl description process defined process constructor 
generation vhdl description process network importance optimized implementation model discussion 
summary thesis 

contents ix forsyde standard library 

forsyde core language 




libraries system functions data types 



computational model libraries 


application libraries 


equalizer specification model 
overview 

overview 
process 
process 


overview 

overview 

overview 
vhdl templates forsyde processes vhdl templates combinational process constructors 
vhdl template processes constructed mapsy vhdl template processes constructed zipwithsy vhdl templates sequential process constructors 
contents vhdl template processes constructed delaysy vhdl template processes constructed scanlsy vhdl template processes constructed scanldsy vhdl template processes constructed mooresy vhdl template processes constructed mealysy vhdl templates domain interfaces 
vhdl template processes constructed downdi vhdl template processes constructed updi 
vhdl template processes constructed sdi 
vhdl template processes constructed pdi 
list figures possible system chip architecture 
high abstraction level leaves wider design space 
synthesis process stepwise refinement high level specification model final implementation 
forsyde design flow 
data flow process network 
synchronous data flow process network 
feedback loop synchronous system 
system solutions multiple solutions single solution 
counter lustre 
systems modeled communicating concurrent processes 
signal sequence events 
process 
basic process output signal 
composition processes lead compositions input output input output 
equivalent process networks 
function composition 
sequential process composition 
parallel process composition 
relation tags periodic signals 
synchronous process constructors separate timing communication 
process constructor mapsy 
process constructor zipwithsy 
process constructor delaysy 
process constructor 
xi xii list figures tags output signal source process implicitly defined signals processes system model 
process constructor scanlsy 
process constructor scanldsy 
process constructor mooresy 
process constructor mealysy 
combinator process 
combinator process 
specification model viewed layered model 
synchronous sub domains introduced domain interfaces process network input output signal rates 
domain interface constructor downdi 
domain interface constructor updi 
example sampling 
usage 
domain interface constructor sdi 
domain interface constructor pdi 
composition sdi pdi introduces extra delay 
forsyde standard library 
equalizer environment 
subsystems equalizer 
subsystem 
state diagram process 
sdl description distortioncontrol 
subsystems 
fir filter 
audioanalyzer subsystem 
process 
transformational design refinement 
design transformation 
process completely defined characteristic function 
process network 
equivalent process network 
illustration transformation rule 
transformation rule 
transformation rule 
list figures xiii application semantic preserving transformation 
illustration transformation rule 
transformation rule 
transformation rule 
illustration transformation rule 
transformation rule 
illustration transformation rule 
transformation rule 
illustration transformation rule 
combining 
illustration transformation rule 
transformation rule 
input adder process 
refinement equalizer simplified 
audioanalyzer 
direct implementation audioanalyzer 
mathematical abstraction specification model 
transformation rule 
audioanalyzer refinement 
refinement handshake protocol 
transformation 
refinement fifo buffer 
transformation fir filter 
hardware implementation process mealysy 
synthesized implementation process distortioncontrol mapping handshake protocol hardware 
synthesized implementation handshake protocol top module 
critical path implementation model 
design transformation implementation mapping concurrent software running single processor scheduling process forsyde standard library 
basic butterfly computation time algorithm point decimation time fft algorithm 
fir filter 
fir filter model 
xiv list figures subsystems equalizer 
subsystem 
state diagram process 
sdl description distortion control 
subsystems audio filter 
audio analyzer subsystem 
hardware implementation mapsy 
hardware implementation zipwithsy 
hardware implementation delaysy 
hardware implementation scanlsy 
hardware implementation scanldsy 
hardware implementation mooresy 
hardware implementation mealysy 
hardware implementation downdi 
hardware implementation updi 
hardware implementation sdi 
hardware implementation pdi 
list abbreviations analog digital converter atm asynchronous transfer mode ccs calculus communicating systems design finite state machine cip computer aided intuition guided programming csp communicating sequential processes digital analog converter dft discrete fourier transform dsp digital signal processor fft fast fourier transform fifo buffer fir finite impulse response forsyde formal system design fpga field programmable gate array frp functional reactive programming fsm finite state machine gals globally asynchronous locally synchronous hml hardware ml meta language hw hardware international technology roadmap semiconductors matlab sdl codesign techniques matlab matrix laboratory modern embedded systems compilers architectures languages mimd multiple instruction multiple data ml meta language moc model computation xv xvi list abbreviations osi open systems interconnect rtl register transfer level statically allocated functional language sdf synchronous data flow sdl specification description language simd single instruction single data soc system chip spi system property intervals sw software vcc virtual component design vhdl high speed integrated circuit hardware description language chapter chapter presents motivation research forsyde defines objectives thesis 
states author contributions forsyde methodology gives overview structure thesis 
motivation embedded systems embedded systems play increasingly important role daily life 
embedded system defined system uses computer perform specific function perceived computer 
embedded systems different application areas train car aircraft controllers consumer electronics communication systems medical devices 
embedded systems include functionality single chip due moore law predicts number transistors chip doubled months 
far moore law observation formulated proven correct years works requirement specification semiconductor industry international technology roadmap semiconductors formulate challenges implicitly moore law 
moore law hold decade means moore observed number transistors square inch doubled year invention integrated circuit 
trend slowed months doubling transistors stable years 
chapter 
complex functionality implemented single chip new applications technology advances appear 
fpga memory dsp communication structure micro custom controller hardware memory 
possible system chip architecture today possible implement system single chip 
illustrated system chip soc integrates micro controllers digital signal processors dsps memories custom hardware reconfigurable hardware form field programmable gate arrays fpgas communication structure analog digital digital analog converters single chip 
architectures offer enormous potential 
hand extremely complex heterogeneous 
apply hardware software 
communications entities extremely complex entities distributed share communication channels memory resources 
embedded systems reactive systems 
reactive systems cruise control car react continuously environment speed environment 
contrast interactive systems internet application interact environment speed transformational systems compiler transform input data output data 
reactive systems safety critical 
case train control system train immediately emergency condition occurs 
design process able give guarantees risk human life 
embedded system design design process embedded systems able implement application guaranteed properties needed instance safety critical systems cope complexity heterogeneity underlying architecture 
trend industrial design part 
motivation verification costs related total design costs continuously increasing 
current industrial designs rely heavily simulation techniques course important need complement form formal verification methods 
practice difficult capture functionality system verify system level properties level architectural components system design start higher abstraction level 
unfortunately higher level abstraction implementation details missing needed obtain efficient implementation 
design process add implementation details 
system design starts development specification model 
phase designer formulates model requirements requirement specification usually written natural language english 
important specification model expressed formal language 
formal language formal syntax formal semantics allows formal manipulation tool support instance detect inconsistencies ambiguities incompleteness specification model 
higher abstraction level specification model fewer implementation details inherent model larger design space 
design space defined amount possible implementations fulfill specification model illustrated 
abstraction level abstraction gap high level specification model lower level specification model implementation number possible refined models 
high abstraction level leaves wider design space syntax language defines language symbols put form valid language expressions 
semantics language gives meaning language expressions 
chapter 
high abstraction level usually means system described cleaner simpler way implementation details taken account 
simple models help designer understand formulate functionality system distraction unwanted details 
addition simpler model allows efficient system model verification confirmed specification model fulfills functional requirements imposed system 
hand high abstraction level system model aggravates synthesis process model implementation details translated implementation complex heterogeneous architecture large amount implementation details needed 
leads large abstraction gap bridged synthesis 
system design methodology offer possibility model system high level abstraction synthesis process allows bridging abstraction gap order yield efficient implementation 
objectives summarized challenge successful system design methodology 
order manage complexity heterogeneity soc applications edwards believe design approach formal methods describe behavior system high level abstraction decision decomposition hardware software taken 
final implementation system automatic synthesis high level abstraction ensure implementations correct construction 
validation simulation verification done higher levels abstraction 
advocate design process representations precise mathematical meaning verification mapping initial description various intermediate steps carried tools guaranteed performance 
formal model design consist components 
functional specification set explicit implicit relations involve inputs outputs possibly internal state information term verification thesis system simulation formal verification 
term synthesis automatic refinement model model due addition details 
term manual refinement specification model implementation system architecture 

motivation 
set properties design satisfy 
set performance indexes evaluate design different aspects speed size reliability 
set constraints performance indexes 
abstraction level specification model design space refinement steps implementation 
synthesis process stepwise refinement high level specification model final implementation design process takes model design level abstraction refines lower 
refinement process involves mapping constraints performance indexes properties lower level 
design process illustrated 
view edwards understood goal system design 
particular correct construction design process difficult achieve 
similar view system design formulated point orthogonalization concerns particular separation computation communication function architecture crucial importance 
forsyde approach embedded system design thesis presents forsyde approach embedded system design 
forsyde formal system design design methodology embedded systems abstraction gap chapter 
similar view system design formulated 
particular starting point development forsyde methodology conviction system design methodologies start high level abstraction order able cope extreme complexity applications architectures give solid base incorporation formal methods simulation sufficient verify systems different levels abstraction 
functional domain implementation domain specification model verification transformational design transformation refinement library hardware implementation implementation model implementation mapping communication implementation 
forsyde design flow architecture model software implementation forsyde design process illustrated starts development formal functional specification model high abstraction level 
model formal formal syntax semantics 
functional system modeled mathematical function input signals 
specification model uses synchronous model computation clean simple mathematical formalism communication model 
formal base forsyde gives foundation integration formal methods 
synthesis process divided phases 
specification model refined detailed implementation model stepwise application models computations discussed section 

thesis objectives design transformations 
semantics specification model subset semantics implementation model verification techniques applied models 
design transformation conducted functional domain 
inside functional domain system model expressed function semantics forsyde 
second step synthesis phase mapping implementation model architecture 
phase comprises activities partitioning allocation resources code generation 
implementation mapping phase design process leaves functional domain enters implementation domain design described implementation level languages languages efficiently express details target architecture synthesizable vhdl hardware software running micro controller 
task refinement process optimize specification model add necessary implementation details order allow efficient mapping implementation model chosen architecture 
far forsyde restricted small number transformations chapter mapping rules hardware software processes chapter far sufficient target industrial designs allow indicate potential forsyde 
thesis objectives main objective thesis show perspectives forsyde offers embedded system design 
forsyde objective move system design higher level abstraction bridge abstraction gap transformational design refinement 
thesis gives motivation basic concepts forsyde particular choice synchronous computational model specification model concept process constructors transformational design refinement forsyde 
concepts illustrated example digital equalizer modeled refined mapped implementation hardware 
thesis discusses potential limitations directions forsyde 
second objective thesis comprehensive documentation forsyde far information exists distributed conference papers 
date simulation verification forsyde models due formal character forsyde base incorporate formal methods 
chapter 
author contribution forsyde published earlier preliminary forsyde started years earlier initiated discussions phd student andreas 
inspired reekie concept higher order functions inside functional language haskell model digital signal processing networks 
unfortunately andreas left university shortly discussions start industrial career 
time axel jantsch joined university participated informal formal supervisor development forsyde 
forsyde methodology mainly developed author thesis 
initially andreas contributed ideas joined industry 
wu worked author thesis design transformation half years 
lu ashish kumar singh joined forsyde group 
lu main contribution mapping technique sequential software 
axel jantsch main contribution stochastic processes forsyde extremely useful feedback forsyde concepts 
thesis shall regarded comprehensive document forsyde cover parts forsyde author essential contribution 
stochastic processes main contributor axel jantsch mapping procedure sequential software main contributor lu mentioned detail thesis 
part appendix original author 
large part thesis integrate earlier papers single consistent document consistent notation 
sub sections give contribution author papers included thesis papers 
papers peer reviewed 
publications included thesis modeling modeling concepts forsyde introduced 
presents synchronous computational model concept process constructors exemplifies modeling technique name methodology forsyde introduced 
process constructors denoted skeletons earlier papers inspired skillicorn 

author contribution case study atm switch operation maintenance oam functionality 
conducted author thesis supported feedback axel jantsch 
implementation mapping papers focus hardware synthesis 
illustrate forsyde model mapped hardware description vhdl 
fifo buffer atm switch manually synthesized netlist standard cell gates 
papers done author thesis supported feedback axel jantsch 
case study hardware software synthesis equalizer model 
suggests synthesis technique hardware software 
basic concepts technique earlier hardware synthesis 
lu developed synthesis technique sequential software manually synthesized equalizer model behavioral vhdl sequential assisted feedback author thesis axel jantsch 
design refinement transformational design refinement introduced 
gave examples simple semantic preserving design decision transformations atm switch model fully illustrate potential transformational refinement 
joint wu author thesis important feedback axel jantsch 
illustrated potential transformational design refinement clock domain refinement communication refinement 
introduces concept domain interfaces synchronous sub domains allows establish multiple clock domains design transformations 
transformations exemplified digital equalizer 
conducted author thesis supported feedback axel jantsch 
formal format transformation rule concept characteristic function allows describe implications transformation rule 
mainly conducted author thesis supported feedback axel jantsch synthesis fir filter example lu 
asynchronous transfer mode chapter 
forsyde methodology article submitted journal ieee transactions computer aided design integrated circuits systems review time writing thesis 
describes methodology concise way thesis 
article conducted author thesis supported feedback axel jantsch 
publications included thesis compares languages erlang haskell vhdl sdl program respect capabilities system level description telecommunication systems :10.1.1.26.9545
comparison evaluation method large number criteria 
order give specific emphasis particular aspects application area criteria weighted 
evaluation conducted pure software pure hardware mixed hardware software systems 
main conducted axel jantsch kumar 
authors contributed mainly opinions weighting criteria evaluation languages case author thesis sdl erlang vhdl haskell 
discusses role functions objects system specification 
authors argue functional models functional design space exploration functional model design validation activities 
contrast object oriented models architectural design space exploration design specification design implementation phases 
main done axel jantsch contribution author thesis lies example feedback 
reviews non determinism identifies different purposes 
descriptive purpose handles uncertainties behavior existing entities constraining purpose specifications constrain implementations 
authors suggest stochastic process non determinism mainly descriptive purpose constrain system 
illustrates usage stochastic processes means forsyde stochastic library defined 
main done axel jantsch author thesis supported integration stochastic processes forsyde feedback 

thesis layout thesis layout thesis consists main parts 
part contains related background information needed position forsyde understand described thesis chapter 
second part presents modeling concepts forsyde 
divided chapters 
chapter defines specification implementation model introduces forsyde standard library 
chapter illustrates modeling technique example digital equalizer 
third part describes transformational design refinement forsyde chapter 
gives format semantic preserving design decision transformation rules shows implication transformation means characteristic function 
shows potential transformational approach digital equalizer example 
fourth part thesis discusses mapping implementation chapter 
chapter focuses hardware synthesis discusses done order target implementations 
chapter summarizes thesis gives overview possible directions forsyde 
addition thesis contains appendix chapters thesis shall serve document forsyde 
appendix includes de standard library full equalizer model expressed haskell mapping templates vhdl 
chapter background chapter provides background material form overview related functional language haskell 
section discusses different models computation 
forsyde uses synchronous model computation detailed overview family synchronous languages second section 
third section gives overview design methodologies 
section covers traditional hardware software design methodologies approaches forsyde declarative environment 
fourth section discusses design transformation 
section gives functional language haskell simulation forsyde models 
models computation system models usually defined number concurrent processes 
model computation moc defines computation takes place structure concurrent processes giving semantics structure 
semantics formulate machine able execute model 
languages computational models underlying computational models 
instance sequential imperative languages pascal fortran share imperative sequential computational model 
hand languages support computational model 
thesis functional language haskell express synchronous multi rate computational model discussed chapter preliminary libraries chapter 
background ready created data flow discrete event models retrieved forsyde web page 
choose right model computation modeling systems utmost importance moc certain properties 
trivial case sequential imperative model able model concurrency suitable describe parallel structure 
part presents number important models computations gives key properties 
discussion tagged signal model introduced lee sangiovanni vincentelli framework compare models computation 
tagged signal model systems viewed concurrent process networks processes communicate means signals 
signal defined set events event tag value 
tag express order relation events 
tagged signal model properties different models computation discussed 
survey major source presentation important computational models 
discrete event model discrete event model timed model means events signals totally ordered tags 
contrast continuous time models finite number tags tags 
discrete event models simulation hardware 
vhdl verilog discrete event model simulation semantics discrete event simulator usually implemented global event queue automatically sorts events 
discrete event models may causality problems due zero delay feedback loops discussed section 
overview discrete event system 
synchronous model synchronous model special case discrete event system 
synchronous model signals set tags 
tags include explicit time information give order events 
synchronous assumption formulated 
synchronous approach considers ideal reactive systems produce outputs synchronously inputs reaction observable time 
implies computation output event languages different model computation synthesis similar perfect synchronous model due synchronous registers difference computation zero delay 

models computation instantaneous output event tag corresponding input event 
synchronous assumption leads clean separation computation communication 
global clock triggers computations conceptually simultaneous instantaneous 
assumption frees designer modeling complex communication mechanisms provides solid base formal methods 
synchronous design technique hardware design clocked synchronous circuits 
circuit behavior described independent detailed timing gates separating combinational blocks clocked registers 
implementation behavior circuit assumption combinational blocks fast circuit include zero delay feedback loops 
feedback loops zero delay may cause causality problems synchronous model discussed family synchronous languages section 

data flow process network data flow process networks data flow process networks special variant kahn process networks 
kahn process network processes communicate unbounded fifo channels 
writing channels non blocking succeed stall process reading channels blocking process reads empty channel stall continue channel contains sufficient data items tokens 
processes kahn process network monotonic means need partial information input stream order produce partial information output stream 
monotonicity allows parallelism process need input signal start computation output events 
processes allowed test input channel existence tokens consuming 
kahn process network total order events inside chapter 
background signal 
order relation events different signals 
kahn process networks partially ordered classifies untimed model 
data flow program directed graph consisting nodes actors represent communication arcs represent ordered sequences streams events tokens illustrated 
empty circles represent nodes arrows represent streams filled circle represents token 
data flow networks hierarchical node represent data flow graph 
behavior data flow process sequence firings 
firing tokens consumed tokens produced 
number tokens consumed produced may vary firing defined firing rules data flow actor 
data flow process networks shown valuable digital signal processing applications 
main goal design process find static firing schedule order implement data flow process network efficiently shared resources 
general data flow models undecidable schedule exists 

synchronous data flow process network synchronous data flow sdf puts restrictions data flow model requires process consumes produces fixed number tokens firing 
restriction guaranteed finite static schedule 
shows sdf process network 
numbers arcs show tokens produced consumed firing 
possible schedule sdf network 
exists variety different data flow models excellent overview see 
rendezvous models rendezvous model consists concurrent sequential processes 
processes communicate synchronization points 
order exchange information processes 
models computation reached synchronization point wait 
tagged signal model sequential process set tags 
synchronization points processes share tag 
partial order events model 
process algebra community uses rendezvous models 
csp model hoare ccs model milner prominent examples 
discussion evident different models fundamentally different strength weaknesses attempts combine common features result models low level difficult 
forsyde adopted synchronous computational model specification due simple clean mathematical formalism possibility model time level 
property reason instance data flow models neglected forsyde specification model 
supported mathematical framework suited application areas digital signal processing applications notion time express timing properties constraints level abstracts physical time 
argue synchronous assumption convenient analyzing point view imposes strong restriction implementation fast 
advocate gals globally asynchronous locally synchronous approach implement methodology network design fsms communicating events 
synchronous fsm communication done emission events happen time independently 
network inherently non deterministic 
argue enables easily model unpredictability reaction delay specification implementation level admit non determinism design verification process complex 
forsyde avoided non deterministic approach advantages deterministic synchronous system model may outweigh disadvantages 
non determinism system model implies possible solutions considered design verification process complex 
task develop verify system model soc application extremely complex complex nondeterministic system model 
fact soc applications implemented partly asynchronous architectures justify non deterministic communicating sequential processes calculus communicating systems chapter 
background approach 
forsyde methodology idea synthesis system model partly asynchronous implementation part synthesis process decided system level 
hsieh define synchronous assumption 
cycle consists interaction phase environment interacts design followed computation phase components design perform computation communicate internally 
assume zero delay computation phase case perfect synchrony hypothesis 
definition define synchronous equivalence implementations synchronously equivalent synchronous assumption conforming runs implementations input traces output traces 
long primary outputs cycle internal details execution matter 
concept synchronous equivalence design refinement 
forsyde synchronous equivalence shown characteristic function discussed chapter 
characteristic function restricted synchronous models implied models synchronous sub domains 
skillicorn talia discuss models computation parallel architectures 
community faces similar identical problems typical soc design soc architecture includes number parallel microprocessors parallel hardware blocks 
fact typical parallel computer structures simd mimd implemented soc architecture 
recognizing programming large number communicating processors extremely complex task try define properties suitable model parallel computation 
emphasize model hide details decomposition mapping communication synchronization programmers shall able manage intellectually creation software 
exact structure program inserted translation process programmer 
models possible means parallelism explicit program text 
point ad hoc compilation techniques expected problems complexity advocate building software correct construction verifying program properties construction 
programs architecture independent allow reuse 
model support cost measures guide design process guaranteed performance useful variety architectures 
flynn classified typical parallel data structures simd abbreviation single instruction multiple data mimd multiple instruction multiple data 

models computation depending information explicit model distinguish levels 
explicit 
parallelism explicit 
parallelism decomposition explicit 
parallelism decomposition mapping explicit 
parallelism decomposition mapping communication explicit 
parallelism decomposition mapping communication synchronization explicit scheme forsyde modeling approach classified focus modeling explicit focus implementation parallelism communication explicit 
motivation explicit functional language haskell forsyde modeling language explicit notion parallelism 
motivation specification model interpreted concurrent process model synchronous communication 
process communication structure fixed refinement phase processes merged split synchronous communication channels refined asynchronous channels elaborated chapter 
forsyde uses single unified system model lot done mixed models computation 
approach advantage suitable model computation part system 
hand system model computational models semantics interaction fundamentally different models defined simple task 
amplifies verification problem system model single semantics 
little hope formal verification techniques help simulation remains means validation 
addition heterogeneous system model specified difficult optimize systems different models computation 
summary cross domain verification optimization remain elusive years heterogeneous modeling approach 
overview related mixed models computation 
charts hierarchical finite state machines embedded variety concurrent models computations 
idea decouple concurrency chapter 
background model hierarchical fsm semantics 
advantage modular components basic fsms designed separately composed system model computation best fits application domain 
possible express state fsm process network specific model computation 
charts describe hierarchical fsms composed data flow discrete event synchronous models computations 
ptolemy project studies heterogeneous modeling simulation design concurrent systems 
implemented ptolemy ii software environment provides support hierarchically combining large variety models computation allows hierarchical nesting models 
basic block ptolemy model actor 
actors concurrent components communicate interfaces ports 
actors composed actors executable 
implementation model computation ptolemy associated composite actor called domain 
domain defines communication semantics execution order actors 
actor different domains 
concept decouples transmission data transfer control computation performed actor 
date domains implemented ptolemy ii communicating sequential processes continuous time discrete event process network synchronous dataflow 
methodology integrates data control flow system specification level languages matlab sdl 
data flow parts described matlab control flow parts sdl system simulated library wrappers communication functions 
computational model elaborated 
internal representations system property intervals spi model developed integrate heterogeneous system model internal representation 
idea spi model allow global system analysis system optimization language boundaries order allow reliable optimized implementations specified embedded real time systems 
synthesis relevant information resource utilization communication timing behavior extracted input languages transformed semantics spi model 
spi model set parameterized communicating processes parameters adaptation different models computation 
spi allows model nondeterminism behavioral intervals 
exists software environment spi called spi workbench developed analysis synthesis heterogeneous systems 

synchronous languages representation refines spi model adding capability explicitly modeling state information allows separation data flow control flow 
goal provide unifying specification focuses specific design methods particular scheduling verification 
internal model shall reduce design complexity representing properties system model relevant design methods 
synchronous languages synchronous languages successfully area reactive safety critical embedded control systems 
languages synchronous computational model discussed section 
model gives solid mathematical foundation formal reasoning application formal program manipulation techniques 
synchronous languages key properties 
support concurrency 
simple elegant formal semantics allows express parallel composition clean way 
support concept synchrony divides time discrete instants 
synchronous assumption implies simple formal communication model 
concurrent processes easily composed 
synchronous assumption implies zero delay output event corresponding input event feedback loop illustrated may imply solution solution solutions 
problem valid discrete event systems may feedback loops zero delay 
shows system zero delay feedback loop stable solution 
output boolean function true output nand function false 
means output function false contradiction starting point analysis 
starting value false output lead stable solution implies output nand function true output function true 
clearly solution problem 
shows system feedback loop multiple solutions 
system stable functions false functions true output value 
system possible solutions 
chapter 
background true true true true nand true true 
feedback loop synchronous system 
system solutions multiple solutions single solution 
shows system feedback loop solution 
solution outputs true 
crucial design safety critical systems feedback loops solution detected eliminated result oscillator 
feedback loops multiple solutions imply risk systems lead non determinism 
non determinism may acceptable detected designer aware implications may serious consequences stays undetected 
feedback loops synchronous models importance approaches address problem 
microstep order introduce order events produced consumed event cycle concept microsteps introduced languages vhdl 
vhdl belong synchronous languages similar model time 
order solve zero delay feedback problem vhdl distinguishes dimensions time 
time unit second number delta delays 
delta delay infinitesimal small amount time 
operation takes zero time units delta delay 
delta delays order operations time unit 
approach partly solves zero delay feedback problem introduces problem delta delays cause advance time measured time units 
event cycle may infinite amount delta delays 
result implemented vhdl operation causes time advance delta delay 
advantage delta delay simulation reveal composite function oscillates 
vhdl simulation detect solutions simulation seman 
synchronous languages tics vhdl assign initial value output gates false give stable solution concealing nondeterminism designer 
serious drawback microstep concept leads complicated semantics aggravates task formal reasoning 
forbid zero delays easiest way cope zero delay feedback problem forbid 
case mean insertion extra delay function upper function 
delay function initial value systems stabilize 
assuming initial value true stabilize current event cycle values false output nand function false value function 
stabilize output value true functions 
problem approach stable system rejected contains zero delay feedback loop 
approach adopted synchronous language lustre 
unique fixed point idea approach system seen set equations solution form fixed point exists 
special value bottom allows give systems solution solutions fixed point solution 
advantage method system regarded functional program formal analysis show system unique solution 
systems stable feedback loop accepted systems rejected result value solution feedback loops 
naturally fixed point approach demands sophisticated semantics theory understood 
esterel adopted approach constructive semantics esterel described 
relation approach allows specification systems relations 
system specification may zero solutions solution multiple solutions 
implementation system usually demands unique solution solutions may interesting high level specifications 
relation approach employed synchronous language signal 
vhdl defines data type boolean means type boolean false true 
program start variables signals take leftmost value data type definitions case boolean data type 
chapter 
background forsyde defines process networks set equations 
date forsyde forbids zero delays approach leads mathematically clean designs require sophisticated semantics 
forsyde models expressed simulated haskell zero delay feedback loop shown results control stack overflow haskell lazy evaluation semantics discussed section special cases may solve networks form 
shown case esterel possible develop fixed point semantics forsyde 
option languages incorporated express forsyde models zero delays forbidden 
modeling languages incorporated versions forsyde fixed point semantics developed new language approach forbid zero delays adopted 
part focuses largely presentation declarative data flow language lustre concepts closest forsyde 
presentation follows short discussion synchronous languages 
lustre declarative data flow language systems composed sets equations 
variable function time denotes flow 
operators operate single values flows expression generates flow value yk instance addition values ak bk 
order formulate sequential networks lustre defines temporal operators 
operator pre returns flow value undefined expressed nil value previous value operator followed defines initial value flow 
type flow equal instance equal 
operators simple counter defined pre constant flow zeros constant flow ones 
followed operator generates flow value followed flow pre 
flow graphically shown 
lustre programs recursive 
variable may depend past values order ensure zero delay feedback loops model 
error occurred simulation haskell interpreter hugs 

synchronous languages pre 
counter lustre lustre provides concept nodes order structure programs 
node flow operator lustre program hierarchically composed 
lustre program basic clock defines finest notion time 
flow associated clock flows may slower clocks basic clock 
operators require input flows share clock 
operator samples flow slower clock operator current interpolates flow clock faster clock 
table illustrates operators 
false true false true false false true true current nil table 
sample interpolation operators lustre expresses boolean flow associated basic clock 
flow associated basic clock 
clock flow defined instances boolean flow value true 
shown example flow slower clock sampled operator current 
esterel imperative language suitable description control 
program consists collection nested concurrently running threads described imperative syntax 
threads communicate means signals 
addition usual control signals esterel large number preemption statements allow termination statements 
formal framework developed esterel includes causality analysis ensuring causality constraints contradictory reachable state 
chapter 
background signal program specification constraints relations involved signals 
signal compiler performs formal calculations synchronization logic data dependencies check program correctness produce executable code 
signal declarative data flow language supports multiple clocks similar way lustre 
statecharts argos graphical automata languages 
synchronous languages successfully industry exist industrial tools esterel esterel technology lustre signal 
esterel technology acquired environment order able combine control oriented esterel data flow oriented lustre synchronous approach 
synchronous language programs usually translated finite state automata order implement sequential reactive program single processor 
esterel lustre translated hardware implementations 
clean mathematical formalism led development verification tools synchronous languages 
gives overview techniques tools developed validation reactive systems described lustre 
authors point techniques adapted synchronous language 
forsyde functional similar characteristics lustre 
environments processes nodes communicate means synchronous signals flows 
discussed section forsyde specification model uses basic clock slower clocks defined absent values 
forsyde operators operate signals values 
basic processes forsyde may higher complexity basic operators processes forsyde sense lustre 
complex operators pre current exist similar forms forsyde 
forsyde uses fully equipped modeling language powerful control constructs data type facilities gives better possibilities model control complex data structures lustre 
contrast lustre forsyde offers concept synchronous sub domains inside implementation model 
allows define clocks faster slower clock specification model domain interfaces section 
lustre slower clocks basic clock defined basic clock fastest clock 
forsyde foundation synchronous languages synchronous assumption aims cover control data flow appli 
design methodologies cations 
order achieve goal uses formal system modeling technique models expressed purely functional programming language haskell 
functional languages fit naturally data flow applications haskell provides rich variety control constructs making suitable control dominated applications 
haskell purely functional function side effects resulting system model function side effects deterministic 
properties haskell mainly support formal verification methods properties support design correctness 
lee type systems formal method ensure software correctness 
haskell strongly typed language type system ability infer correct type function offers dimension polymorphism compared popular object oriented languages java 
design methodologies section gives overview design methodologies 
part section discusses design methodologies emerged research hardware software design community 
community close links electronic design automation industry 
second part gives overview declarative approaches system design research community 
unfortunately interaction communities forsyde uses results areas 
hardware software design hardware software design defined study design embedded computing systems 
date term system design synonym hardware software design 
hardware software design covers problems specification creation specifications describe hardware software system interaction synthesis automatic semi automatic design hardware software meet specification simulation simultaneous simulation hardware software elements different levels abstractions 
chapter 
background forsyde methodology targets system design definition classified hardware software design methodology 
forsyde research project cover parts hardware software design flow extent 
fact parts far covered 
forsyde addresses specification problem proposes modeling methodology describes functionality system state distinguishing hardware software single executable specification chapter 
transformational design refinement approach described chapter specification model refined detailed implementation model belong domain synthesis covered definition wolf synthesis includes different tasks partitioning functionality system divided smaller interacting computation units 
allocation decision computational resources implement functionality system 
scheduling system functions share resource usage resource scheduled time 
mapping selection particular allocated computational resource computation unit 
clearly tasks depending 
date forsyde propose methods partitioning allocation scheduling mapping 
activities performed manually 
forsyde addresses mapping partitioned model hardware chapter sequential software 
forsyde allows simulation specification model detailed possibly partitioned implementation model may viewed simulation high abstraction level 
hardware software design methodologies discussed detail 
elaborate overview hardware software design process see 
mainly developed synthesis 
functionality formulated models system concurrent processes communicating 
target architecture consists 
design methodologies processor memory set asics synthesis starts configuration functions implemented hardware implemented hardware modules 
modules implemented software 
tries reduce hardware costs moving functions hardware software long performance constraints satisfied 
resulting partition serves input high level synthesis software compilation tools 
synthesis embedded architectures developed time 
contrast synthesis starts configuration functions implemented software 
advantage approach system may include functions implemented hardware dynamic data structures 
uses input language extends concept tasks 
target architecture consists processor memory custom hardware 
system designed control dominated systems target architecture consists micro controller asics 
uses globally asynchronous locally synchronous internal format design finite state machines 
finite state machine extended order able communicate asynchronously 
execution delay unknown assumed non zero order avoid zero delay feedback loops 
input specification consists parallel fsms expressed esterel connected communication links 
specification directly translated 
offer hardware software partitioning algorithm leaves choice designer allows synthesize model hardware software 
uses ptolemy simulation environment 
commercial tool vcc cadence approach 
specc specc system level design methodology follows top approach starts development specification model expressed application specific integrated circuits virtual component design chapter 
background language specc 
specc extension provides special language constructs modeling concurrency state transitions structural behavioral hierarchy exception handling timing communication synchronization 
specification model defines granularity exploration phase size leaf behaviors available parallelism 
free implementation details notion time 
specification model includes non functional constraints imposed design 
architecture exploration system architecture derived specification model 
phase includes allocation partitioning scheduling 
output phase architecture model reflects component structure system architecture annotated estimated execution delays 
communication synthesis phase communications architectural model refined communication protocols 
refined model communication model translated implementation model usage compilers high level synthesis tools 
strength specc methodology models described language different amount details 
tools different models design 
project formulated order develop methodologies tools appropriate algorithms support efficient development fully programmable platform designs specific application domains 
goal develop platform efficiently various applications inside application domain 
domain specific platforms highly programmable order provide needed flexibility 
goal develop compiler allows map source applications family programmable platforms microarchitectures 
order map application complex communication structure advocates osi stack model set formal semantics order perform correct construction synthesis high level description implementation 
methodology reflects trend today system design 
due increasing integration functionality single chip focus moved platform design formal design refinement required modern embedded systems compilers architectures languages osi open systems interconnect model defines protocol stack protocol layers mainly specification telecommunication systems 

design methodologies correct construction approach plays important role 
concept networks chip example emerging platform system design 
declarative approaches system design declarative languages research projects electronic design 
reekie haskell model digital signal processing applications 
similar forsyde modeled streams infinite lists higher order functions operate 
correctness preserving methods applied transform model efficient representation 
representation synthesized hardware software 
hydra developed educational purpose hardware description language embedded haskell 
circuits modeled functions hydra provides powerful structured composition operators form higherorder functions allow express regular circuit patterns elegant style 
ruby relational language mainly hardware design 
way hydra ruby focuses structural composition design providing variety efficient composition functions 
declarative framework hardware software design ruby proposed 
ruby supports transformations equational reasoning supports data type refinement 
exists path implementation hardware software 
lava hardware description language haskell 
similar ruby focuses structural representation hardware offers variety powerful connection patterns 
lava descriptions translated vhdl mapped xilinx fpgas 
exist interfaces formal method tools 
singh proposed formulate system level specifications lava haskell type classes describe communication links different levels abstraction 
lava focuses structural representation system suited express behavioral specifications 
mycroft sharp languages statically allocated functional language mainly hardware design extended approach hardware software design 
transform programs means meaning preserving transformations compile resulting program resource aware manner function called shared resource 
hawk language embedded haskell building executable specifications microprocessors 
hawk project addresses need chapter 
background verification complex modern microprocessors supported formal nature hawk specification 
hawk specify simulate integer part pipelined dlx processor 
hardware ml hml hardware description language functional programming language standard ml 
hml uses features standard ml polymorphic functions type system mainly improvement vhdl direct mapping hml constructs corresponding vhdl constructs 
forsyde similar reekie approach viewed extension development reekie 
mycroft sharp follow language similar intention forsyde intend move refinement higher level 
restrict semantic preserving transformations contrast forsyde allows design decision transformations discussed chapter 
lava ruby hml different perform hardware modeling design lower level forsyde 
modeling concepts seen competitors vhdl verilog forsyde languages target languages hardware synthesis tools back tools 
hawk different addresses modeling verification instruction sets processor architectures 
forsyde targets general hardware architectures embedded software running processors processor design 
functional reactive programming frp reactive programming domains animation robotics graphical user interfaces 
central semantic notions behavior function continuous time event time ordered sequence event occurrences 
frp initially implemented embedded language haskell 
frp guarantee bounds execution time speed unsuitable real time applications 
address problem real time frp rt frp developed operational semantics gives guarantees 
contrast frp operational semantics define discrete model time events behaviors 
event driven frp frp variant rt frp 
frp clock generalized set events explicit notion time 
behaviors events frp correspond forsyde signals frp event viewed forsyde signal values extended data type data type includes absent value frp behaviors correspond forsyde signals values non extended data types 
far frp target embedded software microcontroller hardware platform target architecture 
design transformation reported 
design transformation high level abstraction fits system level specification gap system model possible implementation soc architecture 
forsyde tries bridge gap concept process constructors 
system model formulated function process constructors implies functional model interpreted network synchronously communicating concurrent processes 
process structure fixed design languages vhdl sdl forsyde processes merged split application transformation rules design transformation phase chapter 
process constructor hardware software interpretation refined implementation model interpreted structure hardware software components chapter 
forsyde concept process constructors heavily influenced skillicorn homomorphic skeletons 
term skeleton coined cole parallel programming community denote building block predefined implementation parallel machine 
order obtain implementation program composed skeletons 
advantage approach raises level abstraction programmers program language aware underlying parallel architecture 
specialists design implementation skeletons 
algorithmic skeletons introduced cole algorithms encapsulate control structure 
skillicorn uses homomorphic skeletons composite data types 
approach uses bird meertens formalism allows equational reasoning 
bird demonstrates derive programs specifications lists arrays trees data types 
skillicorn points implementations guaranteed performance built computers standard topologies 
cost measures provided complete schedule computation communication known implementation skeleton 
concept forsyde process constructors homomorphic skeletons 
bird equational reasoning list homomorphisms starting point semantic preserving transformations forsyde process networks 
chapter 
background overview program transformation general transformation functional logical programs 
known transformation systems cip computer aided intuition guided programming project 
inside cip program development viewed evolutionary process usually starts formal problem specification ends executable program intended target machine 
individual transformations done semantic preserving transformation rules guarantees final version program satisfies initial specification 
approach advantages final program correct construction transitions described schematic rules reused class problems due formality process supported computer structure longer fixed development process approach quite flexible 
order allow successful transformation specification effective implementation transformation framework provide sufficient number transformation rules exist transformation strategy order choose suitable order transformation rules 
strategy ideally interacts estimation tool shows implementation efficient 
program transformation requires developed framework far mainly small programs modules inside larger program software correctness critical 
transformational approaches concerned software programs concepts synchronous sub domains resource sharing discussed thesis relevance 
number transformational approaches targeting hardware design explicitly develops concept design decisions addresses refinement synchronous model multiple synchronous sub domains attempt article 
particular forsyde approach allows large amount exists high level synthesis defining design decision transformations refinement techniques re timing resource sharing 
points transformational design generalpurpose language suffer fundamental incompleteness problems 
means initial model large extent determines effective satisfying implementation obtained limited part 
haskell design space explored 
problem known context high level synthesis syntactic variance problem general unsolvable 
haskell functional language haskell express system models forsyde section gives small functional languages haskell particular 
examples taken gentle haskell textbook haskell 
functional program function receives program input argument delivers program output result 
usually main function defined terms functions composed functions bottom functional hierarchy functions language primitives 
function free side effects internal state 
means functional program free side effects behaves totally deterministic 
inputs functional program produce identical outputs 
functions free side effects order evaluation data dependencies 
means may exist possible orders execution functional program 
considering function data dependencies imply functions evaluated evaluated 
data dependency functions possible orders execution evaluated evaluated evaluated parallel 
functional programs contain implicit parallelism useful dealing embedded system applications typically considerable amount built parallelism 
course possible parallelize imperative languages difficult extract parallelism programs languages flow control expressed order statements 
chapter 
background foundations functional languages discussed depth discusses functional languages improve modularity 
study supports claimed advantages functional languages brevity development ease understanding conventional imperative languages ada 
part introduces functional programming language haskell shows important features 
date forsyde methodology uses haskell defined haskell language libraries 
haskell standard library standard prelude defines basic types operators functions 
modules developed imported forsyde standard library defines data types functions forsyde 
addition common data types int standard prelude defines lists tuples 
example list integer list integers 
notation means type 
example tuple structure different types char integer element character second integer 
haskell adopted hindley milner type system developed functional language ml 
significant features 
strongly statically typed 

uses type inference determine types expression relying explicit type declarations 

allows polymorphic functions data structures functions may take arguments arbitrary type fact function depend type similarly data structures 

user defined constructs data types 
type system strongly typed type system vhdl ada capable infer calculate maximal possible data type expression 
function fst returns value pair haskell type system determine type 
haskell fst type declaration means function tuple pair input parameter value data type second value data type output value data type type declaration imply different type type declaration gives maximal type allowed different types 
function fst kinds pairs fst fst 
haskell lambda calculus allows write functions curried form mathematician haskell curry arguments written juxtaposition 
written curried form 
add num associates right left real type num 
means argument numeric type returns function partial application curried function 
new functions defined applying argument add dec dec functions argument type num dec num possible partial application uncurried form add num add argument tuple values supplied 
powerful concept functional languages higher order function 
higher order function function takes functions argument produces function output 
example higher order function map takes function list argument applies maps value list 
function defined follows map pattern empty list map xs fx map pattern lists chapter 
background higher order function uses additional feature language called pattern matching illustrated evaluation 
map map pattern matches map evaluation pattern map pattern matches map evaluation pattern map pattern matches map evaluation pattern map pattern matches evaluation pattern evaluation patterns tested top bottom 
pattern left hand side matches corresponding right hand side evaluated 
match pattern list empty 
second pattern matches xs matches list constructed single value list 
second pattern matches right hand side pattern evaluated 
procedure repeated recursively pattern matches right hand side include new function call 
example shows lists constructed processed head tail 
higher order functions lists fulfill type declaration haskell infers map type declaration reads follows 
argument map function takes value data type returns value data type second argument list data type result list data 
functions fst map types 
haskell static type system ensures haskell programs type safe type errors detected compile time 
type system allow function calls evaluated list boolean values false true false bool reject list list contains elements different types 
powerful higher order function function composition expressed composition operator 

haskell gx definition uses lambda abstractions read follows 
higher order functionf function takes value argument produces value 

creates function performs 
function composition extremely useful forsyde allows merge processes structured way 
haskell allows define data types declaration 
allows recursive declarations 
data type list recursively defined data alist empty cons alist declaration data constructors 
data constructor empty constructs empty list cons constructs list adding value type list 
cons cons cons empty constructs list numbers 
term type constructor denotes constructor yields type 
case alist type constructor 
mentioned haskell list data type predefined 
corresponds 
corresponds important aspect haskell uses lazy evaluation contrast eager evaluation 
value denote value non terminating expression expression result kind run time error 
function strict program languages functions strict means arguments function terminate cause run time error order terminate case lazy language haskell 
consider constant defined const result const haskell haskell attempts evaluate argument result 
functions const non strict functions called lazy functions evaluate arguments lazily need 
expressions const evaluate 
eager language standard ml functions strict result run time error program tries evaluate 
lazy evaluation great dealing possibly infinite data structures signals program evaluate expression needed 
possible define infinite list natural chapter 
background nat course possible evaluate infinite structure nat finite parts evaluated head nat take nat take map nat data types defined haskell module system 
module collection functions 
inside module functions data types visible 
modules may access functions explicitly exported module 
code shows part module part forsyde standard library 
module module vector module signal module mapsy zipwithsy zipwith sy zipwith sy scanlsy scanl sy scanl sy scanldsy sy sy delaysy zip sy unzip sy mooresy moore sy moore sy mealysy mealy sy mealy sy import signal import vector import module imports libraries signal vector abstext part forsyde core language section 
exports modules signal vector abstext functions parameter list module 
functions defined module listed parameter list visible modules 
haskell home page web page works portal haskell related tools information 
haskell compilers interpreters freely available 
forsyde project uses mainly interpreter hugs compiler glasgow haskell compiler ghc 
examples thesis tested hugs 
chapter system models forsyde chapter defines system models forsyde specification model implementation model 
specification model synchronous model computation 
implementation model extends specification model domain interfaces possibility establish synchronous sub domains 
uses multi rate model computation 
chapter introduces concept process constructors domain interfaces presents system models formulated 
addition overview forsyde standard library serves basis express forsyde models functional language haskell 
formal models forsyde design process forsyde starts high level specification model 
idea forsyde bridge abstraction gap specification model implementation means transformational refinement inside functional domain 
order define design transformations formally utmost importance models forsyde formal defined 
formal verification methods incorporated forsyde require formal semantics 
forsyde defines system models 
specification model synchronous computational model model offers clean mathematical formalism allows high level abstraction physical time needed formulate timing constraints 
implementation model shall include necessary low level implementation details order allow efficient mapping chapter 
system models forsyde system architecture 
far implementation model uses synchronous computational model extended synchronous sub domains 
model called multi rate model thesis allows direct efficient mapping hardware discussed chapter 
computational models may suitable mapping architectures instance data flow model may suitable software 
intention allow additional computational models inside forsyde implementation model 
order models defined formally transformation rules efficient mapping techniques architectural components developed 
interfaces computational models allowed implementation model developed 
preliminary libraries developed forsyde downloaded forsyde web page 
definition forsyde mathematics independent modeling language 
processes defined functions compositions processes result process 
discussed section forsyde explicitly define semantics zero delay feedback loops simply forbids 
date functional language haskell express forsyde model functional paradigm fits nicely formal definition forsyde models 
section gives framework definition computational models forsyde 
section defines specification model section implementation model 
section presents forsyde models expressed haskell modeling language forsyde 
definition computational models forsyde 
systems modeled communicating concurrent processes order compare properties different models computation lee sangiovanni vincentelli developed framework comparing models computation view system network concurrent processes illustrated 
general definition forsyde 
definition computational models forsyde computational models thesis uses similar notation closely related basic concepts framework 
signals value tag event 
signal sequence events signal sequence events event tag value 
tags model physical time order events key properties computational model 
definition event event value set events denoted set tags depends computational model 
models computation model physical time tags models express order events 
order partial order case data flow process networks 
set values restricted certain data types 
computational models synchronous computational model define special value model absence value tag 
data type extended adding value 
data type called extended data type 
function te extracts tag function extracts value event 
te chapter 
system models forsyde definition signal signal infinite sequence events ej te ej te ej te ej set signals denoted definition implies events signal values data type sorted tags ascending order 
relation te ej te ej able integrate additional computational models data flow models forsyde 
existing forsyde models relation te ej te ej sufficient 
signal values extended data type called extended signal 
definition put restriction order relation events different signals 
may related 
functions defined order access events signal 
ej te ej ej convenience operator introduced express possibly infinite sequence xn different way 
xj xn signal expressed ej 
function ts returns tags signal function vs returns values signal ts vs 
definition computational models forsyde thesis input signals usually denoted output signals internal signals processes im 
process process maps input signals output signals 
depending computational model different types processes defined 
definition process process functional mapping input signals im output signals 
set processes denoted im definition include processes input signals 
processes model signal sources 
useful example timer 
pb im 
basic process output signal basic process process output signal 
definition basic process basic process pb functional mapping input signals im output signal pb im set basic processes denoted pb 
processes composed processes 
term process network processes composed processes includes single chapter 
system models forsyde processes 
process network process formulated 
composition processes lead compositions input output input output process composition possible produce compositions input output input output 
process functional mappings input output signals compositions output sensible regarded processes 
hand compositions output signals input signal viewed constant functional mappings valid processes 
processes called sources modeling process signal generators 
proposition states processes composed basic processes 
proposition process input signals im outputs signals modeled network pn basic processes pn pn im im im im pn im im pn im 
definition computational models forsyde processes mathematical functions input signals proposition explained follows 
tuple outputs function inputs single output function inputs modeled basic process 
considering process network modeled basic processes pb pb proposition 
equivalence illustrated 
pb pb pb pb pb pb 
equivalent process networks forsyde defines composition operators order allow sequential definition parallel composition definition 
sequential composition function composition defined definition 
definition function composition functions composed new function application function composition operator xn xn chapter 
system models forsyde xn 
function composition function composition illustrated 
definition sequential process composition processes composed sequentially means function composition operator yield basic process pb 
im im im 
sequential process composition sequential process composition illustrated definition parallel process composition processes composed means parallel composition operator yield new process parallel process composition illustrated 
compositions including non zero delay feedback loops defined sets equations 
computational model specification model seen special case implementation model 
date implementation model restricted 
definition computational models forsyde 
parallel process composition multi rate models allow additional computational models 
order establish multi rate model domain interfaces introduced allow establish process networks different set tags inside implementation model 
sub networks internally synchronous assumption 
share set tags main network 
models denoted multi rate models basic clocks sub network different event rate 
characterize signals multi rate model term periodic signal defined definition 
definition periodic signal signal periodic signal te ej te ej event cycle signal function returns event cycle periodic signal subset signals periodic denoted sp 
term signal rate defined definition 
definition signal rate periodic signal sp associated signal rate definitions set tags periodic signal determined event cycle signal rate ts chapter 
system models forsyde periodic signal sp completely defined set values vs signal rate short notation introduced 
index index tag index tag tag 
relation tags periodic signals visualizes relation tags periodic signals different signal rates 
signals event tag 
events appear periodically event cycle 
signals process network periodic total order tags signals 
note tags give explicit notion time total order events 
events tag occur instance time 
mean event rate implies periodic clock final implementation 
fact multi rate system model implemented clock long total order events preserved 
possible transform multi rate model synchronous model defining basic clock event rate calculated common multiplier event rates sub networks 
may lead large amount absent values needed synchronize clocks 
event rates exist model common multiplier signal absent values value 
multi rate model restricts implementation larger extent synchronous data flow implies total order events different sub networks 
multi rate model chosen synchronous hardware implementation mind 
mapping synchronous hardware restrict implementation allows simple efficient mapping 

definition computational models forsyde mapping distributed asynchronously communicating implementation impose unnecessary requirements implementation total order tags meant synchronization preserved 
multi rate model restricted special class implementations order allow efficient mapping architecture components models computations sdf integrated forsyde 
order model aperiodic signals specification implementation model define value denote absent value 
forsyde methodology defines function extends function extended function defined absent value 
date forsyde methodology restricted periodic processes definition forsyde allows multi rate model implementation model 
definition periodic process periodic process pp functional mapping input signals im output signals input signals output signals periodic signals 
im ij sp ok sp set periodic processes denoted pp 
forsyde processes constructed process constructors process constructor takes functions values argument generates process output 
functions model computation behavior inside process values define parameters value initial state process 
examples process constructors chapter 
exception combinator processes perform computation 
transform signals tuples tuples signals vice versa 
combinator processes defined section 
chapter 
system models forsyde definition process constructor process constructor pc function takes combinational functions fi values vi produces process output 
pc fm vn set process constructors denoted pc 
specification model forsyde specification model network concurrent synchronous processes 
processes communicate synchronously means signals normalized signal rate rs 
signals set tags ts signals specification model signal rate short notation signal signal rate introduced specification model synchronous assumption forms base family synchronous languages section 
synchronous abstraction leads clean separation computation communication 
follows formal definition synchronous process specification model 
definition synchronous process synchronous process ps periodic process input signals im output signals signal rate im ps pp ij ok set synchronous processes denoted ps 

specification model definition specification model specification model ms process network composed synchronous processes models system 
signals process network signal rate rs 
ms ps set specification models denoted ms specification model reflects design principles forsyde methodology 
order allow formal design high abstraction level specification model characteristics synchronous computational model cleanly separates computation communication 
functional deterministic 
uses ideal data types lists infinite size 
uses concept defined process constructors implement synchronous computational model 
formally defined expressed functional language haskell 
specification model abstracts implementation details buffer sizes low level communication mechanisms 
enables designer focus functional behavior system structure architecture 
nature leaves wide design space design exploration design refinement supported transformational refinement techniques forsyde chapter 
order able model signals aperiodic behavior lower data rates data type extended extended data type adding absent value 
signal reset models reset signal value reset tag value tags 
model synchronous process concept synchronous process constructors 
synchronous process constructor higher order function may take combinational functions function internal state variables argument produces synchronous process output 
specification chapter 
system models forsyde model synchronous process constructors allowed 
possible formulate process constructors computational models may integrated implementation model 
definition synchronous process constructor synchronous process constructor pcs function takes combinational functions fi values vi basic synchronous process ps output 
pcs fm vn ps ps set synchronous process constructors denoted pcs 
event tag value mapsy computation process 
synchronous process constructors separate timing communication concept synchronous process constructors illustrated means 
synchronous process constructor mapsy formally defined takes increment function construct process maps function value input signal 
computational model synchronous produced output event tag corresponding consumed input event 
shows clearly separation timing gray shaded performed process constructor mapsy computation white shaded performed supplied function process formally defined ps mapsy process constructor mapsy model combinational processes input output signal 
supplied function defines computational behavior process 
forsyde methodology designer synchronous process constructors modeling processes specification model 
leads 
specification model mapsy mapsy ps ps ps 
process constructor mapsy defined specification model processes constructed synchronous process constructors 
please remember definition disallows non combinational functions argument process constructors 
concept synchronous process constructors gives benefits synchronous process constructors implement synchronous computational model 
due construction processes process constructors combinational functions clean separation synchronization computation 
synchronization implemented inside process constructors computation achieved supplied combinational functions 
family process constructors generate process local state 
explicit global state model difficult reason formally system model 
process constructors structural hardware software interpretation 
means system model composed process constructors interpretation hardware software mixture 
hardware semantics described chapter software semantics please refer 
process constructors higher order functions transformations development semantic preserving transformations chapter function useful tool design transformations determined process constructors section 
chapter 
system models forsyde define additional synchronous process constructors combinational processes processes internal state sequential process processes internal state 
im zipwithsy zipwithsy ps ps ps im im im 
process constructor zipwithsy synchronous process constructor zipwithsy applies function current values input signals im 
model combinational processes inputs 
delaysy delaysy ps ps ps 
process constructor delaysy basic sequential synchronous process constructor delaysy 
takes initial value delays signal event cycles illustrated example 
delaysy short notations mapsy zipwithsy delaysy complex process constructors defined composition basic constructors mapsy zipwithsy delaysy 
specification model delaysy mapsy ps ps ps delaysy mapsy 
process constructor process constructor define source process 
process generate infinite series output values 
input signal tags output signal source process implicitly defined signals processes part system model indicated 
ts ts ts 
tags output signal source process implicitly defined signals processes system model useful example process counter counts expressed follows process constructors scanlsy scanldsy model finite state machines output decoder 
difference location delay process 
means output process chapter 
system models forsyde im im scanlsy zipwithsy delaysy scanlsy ps ps ps im zipwithsy im delaysy 
process constructor scanlsy scanldsy zipwithsy delaysy scanldsy ps ps ps im delaysy zipwithsy im 
process constructor scanldsy scanldsy event cycle delayed compared process scanlsy shown example 
scanlsy scanldsy synchronous process constructors mooresy mealysy model finite state machines moore mealy type 
difference fsms 
moore machine result output decoder represented process mapsy depend state represented input signals 
mealy machine result output decoder zipwithsy depends state input signals 
process constructors scanldsy definition 
specification model im mooresy scanldsy mapsy im mooresy ps ps ps im mapsy scanldsy im 
process constructor mooresy mealysy scanldsy zipwithsy mealysy ps ps ps im zipwithsy im scanldsy im 
process constructor mealysy follows traditional synchronous hardware design style register located state decoder order design reliable 
forsyde defines combinator processes 
processes perform computation convert tuple signals signals tuples vice versa shown example 
specification model hierarchy processes viewed layered model illustrated 
chapter 
system models forsyde im ps ps ps im im im 
combinator process ps ps ps vj vj ok vj 
combinator process system layer process network layer process layer pb pn pn pb pb pn 
specification model viewed layered model 
implementation model system layer contains top level process composition processes defines signals interface environment 
system model may need number process network layers layer consists process networks 
process network layer 
process layer bottom layer consists networks basic processes constructed process constructors supplied functions values combinator processes 
shows processes process network pn processes process networks pn pn part 
system layer structure process network layer expressed set equations pn pn pn manner process pn expressed set equations pn pb pb pb processes pb pb pb explicitly defined process constructors supplied combinational functions values 
implementation model implementation model product refinement process chapter 
contrast specification model network concurrent synchronous processes may include processes computational models 
date forsyde methodology allows addition synchronous processes domain interfaces implementation model 
domain interfaces defined definition 
principle interfaces called multi rate domain interfaces shortness called domain interfaces thesis 
chapter 
system models forsyde definition domain interface domain interface pd periodic process input signals im signal rate ri different signal rate ro output signals 
im pd pd ij ri ok ro ri ro set domain interfaces denoted pd domain interfaces establish synchronous sub domains comprise local synchronous process network different signal rate 
illustrated 
pd main synchronous pd main domain rate sub domain rate domain interface pn im ak bl domain rate pd pd pn ps pd pd 
synchronous sub domains introduced domain interfaces domain interfaces pd pd establish synchronous sub domain 
main domain signals event rate synchronous subdomain event rate domain interfaces introduce interface synchronous process networks different event rates establish multirate process network 
ps ps pd pn ps pd ps 
process network input output signal rates 
implementation model implementation model allows synchronous processes domain interfaces 
composition processes may generate periodic processes classified synchronous process domain interface illustrated process network pn output signals different event rate 
leads definition implementation model definition implementation model implementation model mi process network composed synchronous processes domain interfaces models system 
mi pp set implementation models denoted mi 
synchronous processes domain interfaces belong class homogeneous periodic processes defined definition 
definition homogeneous periodic process homogeneous periodic process ph periodic process input signals im rate ri output signals rate ro 
ph im ph pp ij ri ok ro set homogeneous periodic processes denoted ph 
proposition set homogeneous periodic processes union possible synchronous processes domain interfaces 
ph ps pd definition system model system model specification model implementation model 
ms mi set system models denoted definition extended additional models computation integrated forsyde methodology chapter 
system models forsyde synchronous sub domains violate synchronous assumption allowed specification model introduced defined transformations refinement process 
inside synchronous sub domain synchronous assumption valid formal techniques initial system model 
domain interfaces formal definition implementation model formally analyzed modified elaborated chapter 
forsyde defines process constructors domain interfaces 
process constructors called domain interface constructors definition 
definition domain interface constructor domain interface constructor pcd function takes combinational functions fi values vi domain interface pd output 
pcd fm vn pd pd set domain interface constructors denoted pcd 
downdi downdi pd pd pd kj kj 
domain interface constructor downdi domain interface constructors downdi updi generate processes sampling illustrates functionality downdi updi small example 
note updi introduces output signal event rate times higher event rate input signal insertion absent events outputting value times 
may look strange sight reason 
assume output updi input accumulation definition domain interface constructors functions div rem 
function div performs integer division truncates result rem returns remainder integer division 
result div result rem 

implementation model updi updi pd pd pd div uk kr 
domain interface constructor updi downdi updi 
example sampling process 
wrong result produced value accumulated 
updi just sampling event rate introduce new values 
needed process introduced shown 
process scanlsy outputs absent input value input value 
case input signal starts absent value output value 
usage shown 
updi updi 
usage domain interface constructor sdi generates process transforms parallel input signals serial signal signal rate times higher signal rate inputs 
domain interface constructor pdi generates process performs opposite operation chapter 
system models forsyde im sdi sdi pd pd pd im im iu rem div im 
domain interface constructor sdi pdi pd pd pd pdi ok nj ok ok 
domain interface constructor pdi transformation serial signal parallel signals 
illustrates sequential composition sdi pdi introduces extra delay 
fact signals value tag process pdi needs event cycles input signal determine values output signals output event cycle 
forsyde modeling language principle languages able express forsyde computational models may modeling language forsyde 
forsyde started 
forsyde modeling language sdi pdi 
composition sdi pdi introduces extra delay research perspective functional language haskell introduced section selected modeling language free side effects supports key concepts forsyde due concepts higher order functions lazy evaluation 
implementation signals process constructors domain interfaces absent extension function straight forward allows express forsyde models clean way minimal effort 
contrast haskell imperative languages java vhdl directly support concepts forsyde particular concept higher order functions 
system model expressed languages elegant haskell model 
hand industrial system designers imperative languages may difficulties accept haskell modeling language 
eventual forsyde possible approaches order appealing designers 
incorporation accepted modeling language enable designer forsyde learning new language paradigm 
language restricted accordance de principles 
similar idea successfully vhdl logic synthesis synthesis semantics differ simulation semantics 
approach allow gradually introduce new concepts industrial design practice 
system candidate allows development class library process constructors 
contrast haskell weakly typed free side effects 
aid designer extent 
development graphical user interface forsyde allow hide haskell designer 
designer able pick process constructors may intuitive names comb comb mapsy zipwithsy need formulate corresponding combinational functions initial values order specify chapter 
system models forsyde process 
specification model developed drawing signals processes 
gui assist designer design refinement tool ideally highlight possible transformations estimation data designer selects proposed transformations 
naturally approaches combined 
libraries computational application libraries forsyde core language haskell libraries system functions model system data types 
forsyde standard library forsyde standard library consists layers illustrated 
bottom layer haskell language 
layer haskell defines forsyde core language 
fundamental data types signal vector corresponding functions defined 
computational models defined computational model libraries located top core language 
top core language libraries system functions data types contain functions data types typical system applications independent computational model 
examples functions dft fft appendix 
top layer forsyde standard library consists application libraries 
libraries include components functions modeled specific computational models fir filter modeled synchronous computational model appendix 
appendix shows large part forsyde standard library 
part contains library synchronous multi rate model sufficient model examples thesis 
discrete fourier transform fast fourier transform finite impulse response 
forsyde modeling language forsyde standard library continuous development 
idea keep forsyde core library existing computational model libraries stable 
extension library planned done incorporation new computational models new system functions data types 
version forsyde standard library discussed thesis version downloaded forsyde web page 
date signals forsyde modeled data 
data type models signals sequence list events exception information tags signal order tags position sequence 
sufficient modeling purpose information signal rates implicitly chosen process constructors domain interfaces 
data defined data signal nulls signal reads follows 
signal values data empty nulls recursively composed value signal nulls signal integers 
output haskell program short notation signal 
order able model absent value forsyde defines data type abstext extends data type extended data type 
data abstext abst prst abst denotes absent value prst denotes value type extended data type aperiodic signals reset signals signals low data rate 
data type signal abstext int models signal addition integer values contains absent values 
signals defined value tag modeled regular data types 
forsyde standard library defines function psi implements higher order function extends function function data abstext chapter 
system models forsyde psi abst abst prst prst process constructors implemented higher order functions 
mapsy nulls nulls mapsy xs mapsy xs higher order function mapsy defined way function map haskell standard prelude 
arguments 
argument function second argument signal type 
definition mapsy uses pattern matching 
pattern matches signal empty nulls 
second pattern matches signal value constructed head signal 
applied result function value output signal 
rest output signal calculated recursively function xs 
infinite signals generated implementation process constructor counter part application library synchronous computational model inside forsyde standard library 
fx succ signal definition defines infinite signal repetitively counts 
signal evaluated total definition useful laziness haskell allows evaluate parts infinite signal discussed section 
allow forsyde standard library defines returns values signal returns th value counted signal 
session haskell interpreter hugs shown illustrate possibly infinite signals accessed 
hugs prompt takes signal integer hugs prompt ats integer forsyde standard library implements domain interface constructors downdi updi sdi pdi illustrated hugs session example illustrates composition sdi 
summary pdi shown 
session signals defined hugs prompt downdi takes hugs prompt updi takes hugs prompt par ser di hugs prompt ser par di par ser di process networks modeled composition operators set equations 
functions sequential parallel function composition definition implemented 
operation identical haskell function composition operator thesis 
process network expressed set equations 
system summary chapter defines specification implementation model forsyde 
specification model synchronous computational model models system hierarchical process network 
processes constructed process constructors benefits implement synchronous computational model allow design transformation chapter implementation semantics chapter 
implementation model uses domain interfaces synchronous processes order establish synchronous sub domains process network domain interface constructors sdi pdi implemented par ser di par di respectively 
chapter 
system models forsyde different signal rate 
model called multi rate model 
far forsyde uses multi rate model inside implementation model computational models integrated 
forsyde modeling language embedded functional language haskell 
forsyde standard library provides data types process constructors domain interfaces allow express simulate specification implementation models haskell 
chapter illustrates development forsyde specification model means digital equalizer 
full specification model expressed haskell appendix chapter development specification model topic chapter development specification model forsyde 
part discusses importance modeling rules 
forsyde models expressed functional language haskell modeling rules needed ensure model complies formal definition forsyde specification model particular synchronous computational model 
second part illustrates modeling forsyde means specification model digital equalizer 
modeling forsyde system design forsyde starts development functional system specification model synchronous computational model 
discussed section forsyde modeling language embedded haskell 
means designer restricted subset possible haskell programs 
subset implicitly defined modeling rules forsyde 
rules guarantee forsyde specification model complies synchronous computational model interpreted network concurrent processes 
important modeling rule specification model expressed composition processes 
composition done composition operators set equations discussed chapter 
semantics forsyde define system model function chapter 
development specification model input signals functional language paradigm suited express forsyde models 
modeling rule states processes constructed process constructors combinator processes composition processes 
discussed chapter process constructors lot benefits 
particular implement computational model allow give implementation semantics process illustrated chapter mapping forsyde processes hardware 
important modeling rule defines process constructors may combinational stateless functions order ensure clear semantics model 
local states forsyde model states reside inside processes constructed sequential process constructors 
forsyde allows top bottom design process 
components form process networks system models stored design library reused bottom approach 
due functional characteristic forsyde model hierarchy functions top process natural development specification model section 
pointed designer models forsyde modeling language date embedded haskell 
designer confronted directly formal definition forsyde previous section 
forsyde restricted haskell specification model mathematical notation forsyde 
order show mapping formal notation haskell parts model haskell 
equalizer specification model development specification model illustrated means digital equalizer 
equalizer originally illustrate methodology 
uses sdl model control matlab model data flow parts 
sdl heavily particular telecommunication industry specification control intensive applications 
matlab sdl codesign techniques specification description language matrix laboratory 
equalizer specification model concurrent finite state machines 
contrast matlab contains powerful mathematical operations mainly modeling signal processing algorithms 
section presents main parts forsyde equalizer specification model uses mainly formal notation chapter 
complete executable equalizer specification model expressed haskell appendix discussion specification model starts top 
general interfaces environment requirement specification written natural language 
task equalizer modify audio input signal position buttons bass treble levels output modified signal 
addition equalizer monitors output signal order prevent damage speakers case high bass level 
shows equalizer black box environment 
bassup bassdn equalizer 
equalizer environment trebleup trebledn specification naturally decomposed functions delay process shown 
bassup bassdn trebleup trebledn bass button distortion control treble control audio filter audio analyzer 
subsystems equalizer delaysy subsystem monitors position button inputs override signal subsystem distortioncontrol adjusts current bass treble levels 
information passed subsystem receives audio input filters amplifies audio chapter 
development specification model signal current bass treble levels 
signal output signal equalizer analyzed audioanalyzer subsystem determines bass exceeds predefined threshold 
result analysis passed subsystem distortioncontrol decides minor major violation encountered issues necessary commands subsystem 
equalizer internal feedback loop delay process introduced audioanalyzer distortioncontrol order give system defined start value 
indicated equalizer model divided parts 
data flow part white boxes responsible processing audio signal 
control part gray shaded controls signal processing input buttons output audioanalyzer sets current bass treble levels 
data flow signals defined value event cycle control signals bassup bassdn trebleup trebledn aperiodic asserted time 
output audioanalyzer signal outputs valid value certain number input values depending size dft inside audioanalyzer modeled extended data type 
specification model synchronous model absence valid values modeled special value 
types signals equalizer model 
signals bass treble valid values modeled signals non extended data type case signals certain tags valid value modeled extended data types include value 
signal extended data types value event cycles 
information useful design refinement elaborated chapter 
table summarizes data types signals 
signal data type signal values bass treble bassup bassdn trebleup trebledn extended enumeration type extended enumeration type table 
data types signals interaction subsystems modeled means set equations equation specifies input output signals subsystem 
formal forsyde description 

equalizer specification model equalizer bassdn bassup trebledn trebleup bass treble bassdn bassup trebledn trebleup bass treble distortioncontrol audioanalyzer delaysy equalizer contains feedback loop need initial value order stabilize system 
required forsyde modeling rules zero delay feedback loops forbidden 
done insertion process delaysy delays signal event cycle produces value value 
follows corresponding haskell code level equalizer model 
direct mapping formal forsyde description 
code include parameters equalizer model abstracted away formal description 
give coefficients fir filters define characteristics low pass band pass high pass filters subsystem 
gives number points dft subsystem 
equalizer vector double vector double vector double integer signal abstext sensor signal abstext sensor signal abstext sensor signal abstext sensor signal double signal double equalizer bassup bassdn trebleup trebledn input output bass treble overrides bassup bassdn trebleup trebledn output bass treble input audioanalyzer output overrides distortioncontrol delaysy abst chapter 
development specification model bassdn bassup trebledn trebleup button interface button level control hold level levels 
subsystem subsystem bass treble subsystem works user interface equalizer system 
receives input signals bassdn bassup trebledn trebleup override signal distortioncontrol calculates new bass treble values output signals bass treble 
subsystem contains main processes 
process monitors input button signals outputs value pressed button absent value button pressed event cycle 
process keeps track current bass treble levels adjusts event signal button 
case process outputs current levels output value absent 
process holds value current bass treble levels new value computed 
modeled means process outputs value input value absent 
process transforms signal tuples current bass treble level tuple signals bass treble signal 
process network expressed set equations formal notation bassdn bassup trebledn trebleup bass treble bass treble levels levels button button bassdn bassup trebledn trebleup haskell signal abstext signal abstext sensor signal abstext sensor signal abstext sensor signal abstext sensor signal bass signal treble overrides bassdn bassup trebledn trebleup bass treble 
equalizer specification model bass treble levels levels button overrides button bassdn bassup trebledn trebleup process process monitors input buttons bassdn bassup trebledn trebleup outputs value pressed button button 
buttons pressed conflict resolved priority order buttons 
button pressed output absent 
process purely combinational inputs modeled means process process constructor zipwithsy 
bassup bassdn trebleup trebledn zipwithsy bassup bassdn trebleup trebledn bassup bassdn trebleup trebledn bassup bassup active bassdn bassup bassdn active trebleup bassup bassdn trebledn trebleup active bassup bassdn trebleup trebledn active observe process constructors simplifies task designer 
process constructor zipwithsy implements synchronous computational model designer formulate combinational function applied process constructor values incoming signal 
modeled help pattern matching 
writing large number clauses pattern matching allows write conditional patterns readable concise way 
value works wild card 
signal abstext sensor signal abstext sensor chapter 
development specification model operating lock release locked bassup operating trebledn bassdn trebleup incl decl incl decl operating locked trebledn bassdn trebleup decl decl incl decl locked 
state diagram process signal abstext sensor signal abstext sensor signal abstext button bassup bassdn trebleup trebledn zipwith sy bassup bassdn trebleup trebledn prst active prst bassup prst active prst bassdn prst active prst trebleup prst active prst trebledn abst process state diagram process shown 
functionality extended compared original model 
state diagram inspired original sdl diagram 
process local state expressing current values bass treble modes mode operating bass treble values stepwise changed steps 
exists maximum minimum value respectively 
process enters mode locked value lock 
mode additional increase bass level prohibited decreased case signal value 
subsystem returns mode operating value 
equalizer specification model release 
output process absent extended signal tuples current bass treble levels 
button mealysy nextstate output button operating nextstate ov locked operating ov lock locked ov release operating operating ov lock locked ov release incl step operating bassup ov decl step bassdn ov decl ov incl step decl step trebleup trebledn step maxlevel maxlevel step maxlevel incl step step step decl step step ov output ov process modeled means process constructor mealysy state function nextstate output function output initial state arguments 
process constructor implements computational model designer formulate initial state state output function 
state divided mode initial value operating bass value treble value 
state function extracted state diagram 
output function selects bass treble chapter 
development specification model values state case value button 
output event absent value 
haskell code follows formal forsyde description appendix subsystem distortioncontrol distortion control directly developed sdl specification model 
specification shown 
process dcl cnt integer dcl lim integer passed pass fail passed lock cnt lim failed pass fail locked fail pass failed cnt lim cnt cnt failed cnt release locked passed 
sdl description distortioncontrol distortioncontrol single fsm modeled means process constructor mealysy global state expressed modes passed failed locked means variable cnt 
state machine possible input values pass fail output values 
equalizer specification model lock release 
takes functions ns calculate state calculate output 
state represented pair mode variable cnt 
initial state sdl model tuple passed 
input value matches pattern ns function corresponding right hand side evaluated giving state 
event absent value leaves state unchanged 
output function modeled similar way 
output absent output message indicated sdl model 
forsyde model distortioncontrol 
distortioncontrol mealysy ns passed lim ns st cnt inp st cnt inp passed cnt st passed inp pass failed lim st passed inp fail locked cnt st failed inp pass failed cnt st failed inp fail failed lim st locked inp fail passed cnt st locked inp pass cnt locked cnt st locked inp pass cnt st cnt inp lock st passed inp fail st failed inp fail release st locked inp pass cnt lim subsystem task amplify different frequencies audio signal independently current bass treble levels 
audio signal split identical signals frequency region 
signals filtered amplified assigned amplification level 
equalizer design bass treble control middle frequencies amplified 
output signal addition filtered amplified signals 
level modeled set equations 
chapter 
development specification model low pass band pass high pass bass treble amplifier amplifier 
subsystems bass treble sum low middle low high bass lowpass middle bandpass high treble bandpass subsystems implemented processes 
parametric process fir models fir filter implement filter functions low pass band pass high pass filter 
fir filter described equation xn yn xn mhm xn xn xn hk 
fir filter yn 
equalizer specification model fir filter modeled shown composition shift register parallel outputs captures current state filter combinational process calculates inner product outputs shift register coefficient vector fir hk shift register parameters size initial values consists parts 
sequential process constructor creates process models shift register vector size elements initial value 
definition process constructor output shift register signal vector elements converted parallel signals 
conversion done combinator process process coefficient vector parameter 
modeled process constructor zipwithsy 
supplied parametric function ipv calculates inner product coefficient vector state vector 
zipwithsy ipv ipv xn formal fir filter description directly translated haskell 
haskell implementations process constructor zipwithsy combinator process vectors signals equal type 
fir lengthv scanldsy initstate initstate ipv ipv nullv nullv ipv hv xv ipv hv xv chapter 
development specification model group samples dft spectrum 
audioanalyzer subsystem check bass parametric fir filter express various fir filters different order 
band pass filter equalizer expressed bandpass fir processes see appendix 
subsystem audioanalyzer audioanalyzer analyzes current bass level raises flag bass level exceeds limit 
illustrated audioanalyzer divided blocks 
input signal grouped samples size process process dft operates vector samples 
process dft calculates frequency spectrum signal 
power spectrum calculated spectrum 
lowest frequencies compared threshold value 
exceed value output value fail 
needs cycles grouping produces absent values grouped sample 
processes dft spectrum extended order able process absent value 
means output signal absent values value 
audioanalyzer audioanalyzer spectrum dft mapsy spectrum mapsy spectrum dft mapsy dft 
equalizer specification model process expressed library process 
process mooresy defined follows 
ps ps ps im ps mooresy operator defined vn vn returns number elements vector vk 
process process illustrated 
input value read stored internal state vector state vector values 
point state vector written output reset empty vector 
synchronous process absent values produced input value long grouping completed 
process starts empty vector initial state sent output 
processes audioanalyzer see appendix 
chapter 
development specification model discussion chapter illustrated modeling forsyde example specification model digital equalizer 
forsyde modeling technique leads compact structured models may levels hierarchy 
process networks described sets equations capture structure system cleaner way vhdl 
control modeled means sequential process constructors result processes directly implemented finite state machines 
functional character forsyde allows efficient modeling data flow parts 
specification model shows important absent values modeling 
absent values signals indicate value event cycles reflected data type signal 
information design refinement order obtain efficient implementation elaborated chapter 
example showed direct correspondence formal notation forsyde haskell 
haskell powerful type system gives additional benefits system design 
haskell programs type safe type system allows type inference functions process constructors processes formulated flexible way facilitates development design library 
example potential forsyde process fir modeled lines code parametric number coefficients direct interpretation hardware 
forsyde gives support combined top bottom modeling process leads models refined transformational design refinement discussed chapter 
principle possibility formulate forsyde models level implementation model belongs functional domain 
low level model transformation directly mapped implementation 
may useful application areas transformations developed 
low level models combined models application areas sufficient amount transformations exists 
intention forsyde start specification model large design space forsyde allows start lower abstraction levels 
haskell program considerably shorter corresponding vhdl description 
chapter design refinement chapter presents transformational design refinement key concepts forsyde 
objective refine specification model application formally defined transformation rules detailed implementation model 
transformational approach formal definition forsyde particular concept process constructors 
transformation rules classified semantic preserving design decision 
rule accompanied implication indicates semantical changes caused transformation 
part chapter gives foundations transformational design refinement forsyde particular shown characteristic function derived process networks forsyde 
addition semantic preserving transformations design decisions introduced illustrative examples 
second part uses model digital equalizer illustrate powerful design transformations clock domain communication refinement 
transformational design refinement key ideas forsyde methodology move large parts synthesis traditionally part implementation domain functional domain 
done refinement phase specification model stepwise refined defined design transformations ti final implementation model mn 
late stage design process implementation model translated forsyde hardware software semantics synthesizable implementation description 
chapter 
design refinement specification model tn mn implementation model 
transformational design refinement transformation definition application transformation rule definition process network part system model illustrated 
pn rule pn 
design transformation transformation rule rule applied process network pn inside system model result transformation system model difference replacement pn pn definition transformation rule transformation rule functional mapping process network pn process network pn number input signals number output signals 
transformation rule denoted pn pn pn pn set transformation rules denoted definition transformation transformation functional mapping system model system model input signals number output signals 
transformation rule internal process network pn replaced pn yield transformation denoted pn pn pn pn reads replaced set transformations denoted 
transformational design refinement order able compare process networks develop classify transformation rules forsyde defines characteristic function basic processes definition extends processes general definition 
definition characteristic function basic process characteristic function im basic process pb input signals im output signal expresses dependence output event index input signals 
im pb im pb im pb im im im characteristic tag function characteristic value function process pb 
im pb im im 
process completely defined characteristic function characteristic function sufficient specify behavior basic process pb input signals im means pb im im im illustrated 
process expressed network basic processes stated proposition processes completely defined characteristic function exists characteristic function basic process 
definition characteristic function process characteristic function ep im process input signals im output signals expresses dependence output events index input signals 
chapter 
design refinement ep im im im im pb im pb im pbn im discussed chapter characteristic function derived process constructed synchronous process constructor domain interface constructor combinator process 
possible give characteristic function compositions processes 
characteristic function process networks system models forsyde include zero delay feedback loop input signal 
characteristic function pure source process determined 
characteristic function sufficient fully describe behavior process 
basic processes classified causal synchronous combinational sequential 
classifications extended cover processes output signal 
basic process pb input signals im causal exists function im im kl im im km il kl im process causal output events depend input events larger tag produced output event 
forsyde considers causal systems 
basic process pb input signals im synchronous im im 
transformational design refinement basic process pb input signals im combinational synchronous im im basic process pb input signals im sequential synchronous im 
contrast transformational approaches design software allow application semantic preserving transformation rules forsyde defines design decision transformation rules change semantics model defined manner 
design decisions mainly motivated application domain forsyde 
forsyde targets embedded systems fulfill hard requirements performance power dissipation 
fulfill requirements resources system efficiently 
purpose specification model model system level abstracts implementation details 
forsyde specification model uses ideal infinite buffers floating point numbers simple synchronous communication scheme 
hand efficient implementation finite buffers fixed point numbers may versatile communication mechanisms synchronization different components distributed implementation 
clearly possible transform high level specification model implementation changing semantics 
design decisions needed bridge abstraction gap 
application semantic preserving transformation rule change meaning system model mainly optimize model synthesis 
contrast application design decision rule changes meaning system model 
typical design decision refinement infinite buffer fixed size buffer size elements 
design decision clearly modifies semantics system model transformed model may behave way original model certain precondition 
instance possible prove ideal buffer contain elements replaced finite buffer size behave ideal buffer precondition 
design transformation rules classified semantic preserving definition design decision definition 
chapter 
design refinement definition semantic preserving transformation rule transformation rule pn pn semantic preserving rule epn im epn im 
design decision changes semantics design small extent close relation original design transformed design 
reflected definition relation required 
definition design decision rule transformation rule pn pn design decision rule semantic preserving epn im epn im 
exists relation rel pn pn pn rel pn relations practice difficult express creator transformation rule ensure exists meaningful relation 
examples close relations original transformed process network functional equivalence definition tail equivalence definition discussed section 
rest chapter structured follows 
section gives characteristic functions processes constructed process constructors process networks 
section shows characteristic function development classification transformation rules 
section illustrates potential transformational design refinement example digital equalizer powerful design transformations applied 
characteristic functions processes process networks section characteristic function processes synchronous process constructors domain interface constructors combinator processes process networks 
processes synchronous process constructors synchronous processes output events tag corresponding input event 
synchronous process characteristic tag function yields tag corresponding input event index 
characteristic functions processes process networks combinational processes processes mapsy zipwithsy characteristic function depends current input events 
characteristic function process mapsy characteristic function process zipwithsy im im im im im im im sequential processes processes delaysy depend past input events 
characteristic function process delaysy characteristic function process scanlsy recursively expressed chapter 
design refinement im im im im im im im sj sj im sj elements characteristic value function scanlsy explicitly scanlsy im im im im example shows characteristic function increasing complexity increasing sequential depth 
characteristic function process scanldsy recursively expressed im im im im im im sj sj im sj characteristic function process mooresy recursively expressed 
characteristic functions processes process networks im im im im im im sj im sj characteristic function processes mealysy recursively expressed im im im im im im im sj sj im sj processes domain interface constructors characteristic function domain interface constructors div integer division function rem remainder function 
remember event cycle periodic signal definition 
characteristic function domain interface constructor downdi kj kj characteristic function domain interface constructor updi chapter 
design refinement div characteristic function domain interface constructor sdi ep sdi im tp sdi im vp sdi im tp sdi im mc mc vp sdi im im iu rem div characteristic function domain interface constructor pdi pdi ep epn epk tpk tpk jn combinator processes characteristic function combinator processes im im im im im im im characteristic function combinator processes 
characteristic functions processes process networks vj vj vj network processes characteristic function process network composed sequential composition determined ep im ep output process ep im ep im 
characteristic function process network composed parallel composition determined ep ep order illustrate characteristic functions complicated networks calculated characteristic function network derived 
delaysy zipwithsy zipwithsy 
process network step transform process network equivalent form basic processes shown 
chapter 
design refinement pb pb pb pb 
equivalent process network process network characteristic function derived epn characteristic tag function processes synchronous processes 
characteristic value function derived vp vp vp vp characteristic value function vp vp 
design transformations results inserted expression characteristic function 
forsyde disables zero delay feedback loops possible derive characteristic function meaningful process networks process constructors processes defined chapter input signal 
practice small process networks described characteristic function mathematical expressions increase complexity number processes sequential depth number synchronous sub domains 
sufficient characteristic function mainly design transformation rules applied process networks limited size 
design transformations designer applies transformations system model choosing transformation rules transformation library 
transformation rules characterized name required format constraints original process network format transformed process network implication design relation original transformed process network expressed characteristic function 
transformation rules exemplified semantics preserving transformation identity mapsy mapsy mapsy transformation rule takes process network form transforms form pn mapsy mapsy pn mapsy illustrated 
characteristic function expressions formally proven process networks pn pn semantically equivalent 
means transformation semantic preserving 
proof 
chapter 
design refinement mapsy mapsy mapsy 
illustration transformation rule characteristic function mapsy derived 
characteristic function divided characteristic tag function characteristic value function 
characteristic tag value functions derived general expression mapsy 
characteristic function characteristic tag function derived mapsy synchronous process constructor 
characteristic value function returns output value signal index process 
output signal indicated 
formulated mapsy 
design transformations signal expressed leads characteristic function process networks pn pn equivalent shows transformation rule semantic preserving 
transformation rule pn process network pn pn mapsy mapsy transformed process network pn pn mapsy implication epn epn 
transformation rule transformation rule 
process networks match format original process network transformed application format transformed process network 
implication expresses transformation rule semantic preserving change meaning process network characteristic functions process networks identical 
implication part provides designer information extent application transformation rule changes meaning original process network 
chapter 
design refinement transformation rule expressed haskell code 
transformation fgs pn ref original process pn org mapsy mapsy transformed process pn ref fgs mapsy occurrence pattern mapsy mapsy forsyde model replaced pattern mapsy alternatively pattern signal haskell session haskell interpreter hugs shows transformation rule 
hugs prompt mapsy mapsy hugs prompt mapsy 
hugs prompt way transformation rules expressed applied haskell 
date transformations introduced manually haskell code system model 
tools ultra interactive program transformation system haskell programs may versions forsyde support transformation process 
semantic preserving exists reverse transformation rule named 
illustrates application transformation rule simple example 
merge processes single process subsystem borders 
trivial case transformed process mapsy ulm transformation tool 
design transformations transformation rule pn process network pn pn mapsy transformed process network pn pn mapsy mapsy implication epn epn 
transformation rule subsystem pn subsystem mapsy mapsy pn pn mapsy 
application semantic preserving transformation chapter 
design refinement merging processes optimize design saving adder 
note processes form mapsy mapsy merged splitting process mapsy processes usually needs support designer suitable functions selected splitting processes efficient case 
illustrates powerful feature forsyde 
system model hierarchy functions processes easily moved subsystem borders case mapsy moved subsystem subsystem vice versa 
example semantic preserving transformation illustrated 
im im im im im stage stage stage log 
illustration transformation rule transformation transforms combinational input process balanced network processes inputs 
contrast transformation applicable processes format transformation puts additional requirements process format 
sufficient combinational process format constraints number inputs 
design transformations form combinational function xm xm operator associative 
additional requirements formulated original process network part transformation rule 
transformation rule instance transform input adder balanced circuit input adders shown section 
transformation rule pn process network pn im pn im im xm xm associative transformed process network pn im pn im im im im im implication epn im epn im 
transformation rule design decisions change meaning system model imply change characteristic function transformed process 
characteristic function design decision rules defined change meaning system model controlled manner 
order classify design decision rules terms functional equivalence definition tail equivalence definition introduced 
definition functional equivalence process functionally equivalent process 
im ep im output process output process delayed 
chapter 
design refinement definition tail equivalence processes tail equivalent exists ep im ep im output signals process networks identical events index initial events 
transformation rule transforms process process called functionally equivalent transformation rule processes functionally equivalent tail equivalent transformation rule processes tail equivalent 
functional equivalence tail equivalence examples relation original transformed process network required definition design decision rule definition 
transformation rule process network pn im transformed process network pn im pn im pn im implication epn im pn im 
transformation rule transformation rule illustrated basic example functionally equivalent transformation rule 
application rule adds delay process output original process network 
im im pn pn 
illustration transformation rule 
design transformations transformation rule process network pn im pn im im transformed process network pn im pn im im implication epn im epn im 
transformation rule transformation rule illustrated example tail equivalent transformation rule 
application rule moves delay output original process network input 
im im 
illustration transformation rule transformation rules complex design decision rule illustrated 
transformation rule composed initial log transformation number transformations implication shows transformation combination functional equivalent tail equivalent transformations 
output cycles delayed equivalent output original process network indexes combining transformation rules new transformation rule generated chapter 
design refinement transformation rule ree process network pn im pn im fm fm im im transformed process network pn im fm fm im implication im epn im pn im im im im im 
transformation rule im im im stage stage stage stage stage log fm fm stage log 
illustration transformation rule 
design transformations enhance throughput combinational function pipelining illustrated 
im im im im im stage stage stage log 
combining direct translation computation intensive algorithm fir filter results implementation large amount multipliers adders 
concept synchronous sub domains transformation developed transform combinational process regular structure structure separate clock domains 
transformed process network uses fsm process schedule operations clock cycles 
transformation illustrated formally allows efficient implementation identical operations shared 
im im sdi downdi 
illustration transformation rule chapter 
design refinement transformation rule process network pn im pn im im xm gm hm xm transformed process network pn im pn im downdi sdi im mooresy hk gk hk gk hk implication epn im pn im 
transformation rule transformation rule requires combinational function format xm gm hm xm order able schedule computation steps 
step calculated steps intermediate value yi calculate final result ym yi gi hi yi transformed process network works follows 
input event cycle domain interface sdi parallel serial reads input values signal rate outputs sequence xm signal rate corresponding event cycles 
process process constructor mooresy executes combinational function original process event cycles 
state function applied 
design transformations input value result stored intermediate value states function gi applied hi xi intermediate value 
tag 
process outputs intermediate value output absent 
domain interface downdi samples input signal signal rate outputs th input value starting tag suppressing absent values output 
domain interfaces characterized characteristic function means shown characteristic function transformed process network developed 
follows delays output transformed process network event cycle compared original process network stated implication 
event output signal second component initial state value 
transformation expressed haskell follows 
original process format express pn org hs gs hs gs vector implementation zipwithsy size hs gs expresses format combinational function format hs lists functions represents functions hi functions gi 
nullv hs gs xv hs gs xv transformed process expressed pn ref hs gs downdi fsm hs gs par fsm hs gs mooresy prst abst hs 
gs 
length hs 
returns th value starting 
functionally equivalent transformation rule 
chapter 
design refinement parameter tuple kind value demanded data type 
transformation expressed hs gs pn ref hs gs zipwithsy 
input adder process chapter concluded example input adder refined transformations 
example expressed haskell show result transformations 
examples tuple signals vs values 
vs semantic preserving design transformation rule refined adder behaves exactly original 
hugs prompt vs refined pipelined adder introduces extra delays 
initial value delay elements 
hugs prompt vs transformation adder refined 
refinement equalizer adder ref hs gs hs id id id id gs simulation shows output refined adder event cycle delayed 
hugs prompt adder org vs hugs prompt adder ref vs refinement equalizer bassdn bassup trebledn trebleup hold level button control low pass band pass high pass button interface level control bass treble amplifier treble amplifier bass dist flag distortion check control low freq 
distortion control power spectrum sum audio filter dft group samples audio analyzer 
refinement equalizer simplified specification model equalizer chapter discuss refinement techniques indicated 

refinement clock domain section 
communication refinement section chapter 
design refinement 
resource sharing section refinement clock domain group samples dft spectrum 
audioanalyzer check bass shows audio analyzer subsystem includes discrete fourier transform dft algorithm 
internal function dft takes vector samples produces corresponding dft result form vector size denoted xk dft determine frequency spectrum signal modeled process dft 
process power spectrum calculates power spectrum 
process check low frequencies analyzes power low frequencies exceeds threshold issues warning case sent distortion control 
process group samples reads samples groups vector size computation vector takes event cycles serves input dft 
synchronous computational model specification model grouping process produce output event input event 
results output absent values computed dft value 
group samples dft power check spectrum low freq 

direct implementation audioanalyzer due definition defined process process absent values 
drawback specification phase direct implementation semantics chapter fact dft calculated th clock cycle 
dft process produce result single event cycle idle clock cycles 
implementation audio analyzer inefficient computation dft function clearly time consuming determine clock period system system performance 

refinement equalizer order get efficient specification forsyde methodology allows introduce synchronous sub domains system model refinement process discussed section 
idea transformation introduce new clock domain process order filter absent values allow efficient dft process 
order develop transformation characteristic function known 
characteristic function wk processes constructed process constructor mapsy absent extension function 
mapsy mapsy mapsy model computation functions processes 
identities gives mapsy mapsy mapsy mapsy mapsy mapsy processes composed single process 
mapsy chapter 
design refinement characteristic function ep tp vp tp vp vk vk 
mathematical abstraction specification model specification model audio analyzer expressed illustrated 
process network characteristic function ep tp vp tp vp wk initial idea synchronous sub domain identity updi downdi derived 
identity uses special characteristic grouping process proven identity 

refinement equalizer comparison characteristic functions 
characteristic function process network developed 
characteristic tag function process tu tu ed ed kc characteristic value function process vu vu ed ed mod wk ed mod wk vd mod wk mod wk characteristic function process shows process synchronous 
process propagates th event counted output 
output events absent value 
characteristic function process derive characteristic function 
characteristic tag function trivial processes synchronous 
chapter 
design refinement characteristic value function 
vu mod wk vg mod wk wk shown characteristic function equivalent processes 
identity easily proven follows step replaced produce absent values 
semantic preserving transformations follows refined process network semantical meaning process network characteristic function 
analyzing stated process processes events th tag implemented slower clock 
considerations semantic preserving transformation expresses identity introduces synchronous sub domain defined 
transformation called 
synchronous sub domain implemented clock frequency fc slower clock frequency fc main synchronous 
refinement equalizer transformation rule process network pn pn mapsy transformed process network pn pn updi mapsy downdi implication epn epn 
transformation rule domain 
design step dft refined fft implementation transformed audioanalyzer illustrated time interval available calculation dft times longer slowing rest system 
group samples dt sample fft power spectrum check low freq 

audioanalyzer refinement ut sample transformation directly expressed haskell 
implementation process follows directly formal definition process 
mooresy nullv lengthv lengthv lengthv prst nullv lengthv prst gv abst original process format expressed haskell algorithms part forsyde standard library appendix 
chapter 
design refinement pn org mapsy psi seen variables function parameter transformation 
haskell supports concept higher order functions transformation expressed means pn ref pn ref updi mapsy psi downdi simple process network pn mapsy vn vn transformed network expressed haskell simulation shows process networks expected behavior 
examples signal 
hugs prompt pn org hugs prompt difference types results haskell infers double extended data type output 
results fact updi extends extended data type second time due type declaration 
updi num signal signal abstext haskell logically infers data abstext abstext integer lacks knowledge double extended data type meaningful 
phenomena refers type system haskell principle problem forsyde 
possibility define transformation works way sample process stage 
refinement equalizer transformed process network 
transformation useful need sample frequency data rate processes dft fft 
transformation course introduce design decision may affect parts system 
case equalizer require transformation order introduce sample domain interface internal feedback loop lead signal rate inconsistencies 
communication refinement specification model uses synchronous communication mechanism subsystems 
nice feature modeling analyzing partitioning issues special interfaces subsystems taken account phase 
large systems usually implemented single unit partitioned hardware software blocks communicating dedicated communication protocol 
forsyde methodology offers transformations synchronous communication protocols 
looking equalizer example rate values input output signals button control distortion control subsystems considerably lower rate corresponding signals audio filter audio analyzer 
assumed button control distortion control shall implemented software audio filter audio analyzer hardware 
communication parts handshaking protocol fifo send receive processes chosen 
refinement synchronous interface button control audio filter subsystems shown 
emphasizes data types signals 
please note data types extended data types containing absent values 
signals lower rate values corresponding signals data types carry value event cycle 
process hold level convert absent extended signal absent values outputting value receiving absent value 
refinement done steps 
process hold level moved subsystem button control order implement interface process level control process hold level communication channel significantly lower data rate expressed data type signal 
second step refine interface handshake protocol 
hold level modeled means see chapter 
design refinement step move subsystem borders step interface refinement level control level control level control fo button control hold level fifo send rec sf sm hold level rm audio filter audio filter hold level 
refinement handshake protocol audio filter done transformation channel level control hold level means transformation 
transformation introduces fifo receive process 
send idle tries read data fifo sf sends message sm receiver receiving message ready rm sends data sd receiver sends rm data received 
handshake protocol implies delay cycles event send receive synchronous processes 
means timing behavior refined interface different original interface 
mean audio filter process exactly combination values event cycle system model 
consequences taken account interfaces refined 
case shown refined interface behaves practice system model assumptions 

average data rate process level control lower data rate audio filter 
fifo correctly dimensioned 
refinement equalizer transformation rule process network transformed process network pn rm receive sm sd sm sd sf send fo rm fo fifo sf implication see text 
transformation buffer overflow fifo values reach audio control small number event cycles 

output function audio filter change significantly input signals level control delayed 
clearly case small delay level signal delays change amplitude small time effect signals shape 
assumptions point obligations design activities 
formalization design decisions allow assumptions obligations explicit 
fifo buffers dimensioned sufficiently large separate analysis 
imply design decision transformation illustrated 
assumptions environment application kind expected input signal case data rate validated justify applied design decisions 
read read fifo buffer fifo buffer 
refinement fifo buffer chapter 
design refinement interface synthesized hardware semantics forsyde 
sole purpose transformation prepare asynchronous implementation 
note model derived truly asynchronous sense completely deterministic non deterministic channel delays 
course channel modeled realistically desired 
forsyde methodology suggests avoid non deterministic model stochastic channel model supported means stochastic process constructors 
resource sharing shows application design decision fir filter 
process ipv defined rate ipv sdi main domain rate synchronous sub domain rate nr ipv downdi 
transformation fir filter main domain rate ipv xn complies input process network format transformation rule serial gi hi hix rule apply transformation ipv fir filter model order receive model remains unchanged fir filter realized clock domains multiplier adder 
original transformed fir filter translated vhdl synthesized mapping procedure chapter 

summary discussion summary discussion objective transformational design refinement forsyde convert high level specification model implementation model includes necessary details order allow efficient mapping implementation model selected target architecture elaborated chapter 
forsyde allows application design decision rules transformation rules change semantics design 
design decisions needed order transform concepts infinite buffers real numbers representations finite buffers fixed point numbers mapped efficiently architectural component 
order allow transparent refinement process transformation rule accompanied design implication informs designer extent application rule changes semantical meaning process network 
chapter characteristic function process network express implication transformation rule 
addition potential transformational refinement illustrated application powerful transformations digital equalizer model 
transformational refinement approach leads documented structured design refinement refinement step application transformation rule 
designer trace entire refinement process may select transformation options point refinement process final result satisfactory 
discussed section transformational refinement method requires sufficient amount transformation rules efficient transformation strategy order yield solutions 
prerequisite transformation strategy availability cost measures allow indicate model implemented efficiently architecture 
cost measures estimation tool provides estimates terms speed area power particular model implemented architecture 
transformation problem compared chess 
transformation rule corresponds chess move estimation corresponds evaluation position chess board 
analogy indicates complex transformation task chess average number possible moves typical position majority chess games finishes moves white moves black 
quite large market commercial chess programs programs running faster faster chapter 
design refinement hardware able show superiority human chess players situation chess transfered system design problem system design complicated due large number possible moves transformations systems increasing complexity 
tool check possible transformations experienced designer knows transformations may give improvement design 
forsyde defines limited amount transformations sufficient indicate potential forsyde 
order forsyde applicable larger problems transformations developed estimation tool incorporated 
order experience designer transformation process semi automatic 
tool provide designer information possible transformations implication defined transformation rule possible design improvement 
designer selects transformations may go back steps order find efficient solution 
architecture embedded systems heterogeneous extremely complex forsyde initially dedicated parts embedded system 
possible areas communication refinement selected protocols communication patterns gals structure handshake protocols refinement data flow path architectures 
chess program deep fritz drew match vladimir number world chess rating list deep junior drew match kasparov number rating list 
chapter implementation mapping chapter describes forsyde implementation model mapped pure hardware implementation 
mapping procedure converts implementation model vhdl description 
description synthesized netlist gates asic technology commercial logic synthesis tools 
order obtain effective solution implementation model optimized architecture mapping process focus optimization 
discussion mapping implementation model architectures concludes chapter 
implementation mapping implementation model mapped architecture 
system chip designs architectures consist different components micro controller cores digital signal processors memories switches routers custom logic 
large part system implemented software may run different operating systems 
ip blocks may part design 
implementation mapping complex 
involves subtasks partitioning allocation scheduling mapping research areas hardware software synthesis discussed section 
intellectual property ip refers creation mind 
ip block component acquired ip vendor 
example component microprocessor core placed system chip 
chapter 
implementation mapping date forsyde defines mapping hardware vhdl sequential software 
thesis focuses mapping hardware mapping software described 
state forsyde support hardware software partitioning 
task left designer 
mapping implementation model vhdl forsyde defines mapping rules implementation model vhdl 
order get implementation implementation model include necessary details allow map efficient synthesizable vhdl code 
implementation model viewed design entry rtl synthesis compared rtl descriptions rtl vhdl verilog 
better implementation model mapped vhdl description efficient implementation exists efficient hardware implementation 
concept process constructors allows define efficient mappings 
process process constructors exists mapping vhdl component netlist vhdl components allows efficient hardware implementation 
addition mapping procedure comprises activities mapping functions data types process networks 
procedure mapping activities 

generation vhdl description processes defined single process constructor selection vhdl template process constructor mapping data types mapping process parameters constants translation functions vhdl 
generation vhdl description process networks mapping procedure illustrated examples 
section uses process distortioncontrol section explain vhdl descriptions generated processes single process constructor 
processes process constructors translated analog way vhdl 
appendix gives vhdl templates synchronous processes register transfer level 
mapping implementation model vhdl domain interface constructors 
section uses forsyde model handshake protocol section show vhdl descriptions generated process network 
generation vhdl description process defined process constructor model process distortioncontrol discussed section 
forsyde model process order illustrate generation vhdl descriptions process process constructor 
distortioncontrol mealysy ns passed lim ns st cnt inp st cnt inp passed cnt st passed inp pass failed lim st passed inp fail locked cnt st failed inp pass failed cnt st failed inp fail failed lim st locked inp fail passed cnt st locked inp pass cnt locked cnt st locked inp pass cnt st cnt inp lock st passed inp fail st failed inp fail release st locked inp pass cnt lim step select appropriate vhdl template process constructor process distortioncontrol 
process defined distortioncontrol mealysy ns passed lim mapping template process mealysy selected 
mapping visualized shows result mapping vhdl description mealy finite state machine 
combinational functions mapped combinational circuits reads hardware implementation 
internal process delaysy chapter 
implementation mapping mapped bank registers reset state 
registers asynchronous active low reset 
im mealysy zipwithsy scanldsy clk reg resetn mapping 
hardware implementation process mealysy vhdl template mealysy divided parts entity part package part 
entity part gives entity architecture declaration package part defines data types constants functions entity part 
entity part vhdl template mealysy shown 
architecture declaration contains processes 
process sequential process implements state registers finite state machine 
second process combinational process implements state decoder means function output decoder means function 
please note entity part basically processes mealysy 
difference occurrences mealysy replaced name process 
library ieee ieee std logic mealysy lib library synopsys synopsys attributes entity mealysy port type mealysy 
mapping implementation model vhdl type mealysy clk std logic resetn std logic mealysy architecture seq mealysy signal state nextstate type mealysy state attribute state vector string attribute state vector seq architecture state seq process clk resetn process resetn asynchronous reset active low state elsif clk event clk rising clock edge state nextstate process process state process nextstate state state process seq package part vhdl template mealysy shown 
part defines data types functions constants process 
mapping procedure occurrences exchanged name process distortioncontrol occurrences defined replaced corresponding vhdl expression forsyde data type constant function 
package mealysy lib type type mealysy defined type type type mealysy defined type type type mealysy state defined type state constant type mealysy state defined initial value function type mealysy state type mealysy state return type mealysy state function type mealysy chapter 
implementation mapping state type mealysy state return type mealysy state package body mealysy lib function type mealysy state type mealysy state return type mealysy return defined definition function type mealysy state type mealysy state return type mealysy return defined definition mealysy lib step mapping process map forsyde data types vhdl 
chapter explicitly define data types forsyde 
assumed notation easily extended include data types haskell representation forsyde models 
values input signals extended data type include value 
extended data types mapped vhdl data type ways 
possibility model data types record variables 
entry defines value second entry value gives value 
approach extended data type mapped type type abst record boolean value type record disadvantage approach may create unnecessary logic registers case example represented bit bits bits needed 

mapping implementation model vhdl leads second approach efficiently enumeration types 
absent value treated additional value enumeration type leads type definition 
type type abst abst technique extended integers real data types order keep mapping process simple thesis mapping technique records 
example data type values input signal extended data type values pass fail mapped type type value pass fail type type distortioncontrol record boolean value type value record values output signal extended data type mapped type type value lock release type type distortioncontrol record boolean value type value record internal state process distortioncontrol tuple part st enumeration type second part cnt constrained integer 
forsyde tuple mapped vhdl record case entries enumeration type constrained integer 
type type st passed locked failed subtype type cnt integer range type type distortioncontrol state record st type st cnt type cnt record process distortioncontrol defines constants 
constant passed initial state finite state machine translated reset state lim internal parameter 
constants defined package part 
constant type distortioncontrol state passed constant lim integer range combinational functions ns translated vhdl 
forsyde demands combinational functions far restricts chapter 
implementation mapping non recursive functions targeting hardware mapping vhdl function straight forward 
case process distortioncontrol forsyde model nextstate output decoder described naturally translate clauses vhdl 
vhdl code function ns implemented function implements state decoder finite state machine 
function type distortioncontrol state type distortioncontrol state return type distortioncontrol state variable result type distortioncontrol state false result state st state cnt elsif state st passed value pass result passed state cnt elsif state st passed value fail result failed state cnt elsif state st failed value pass result locked state cnt elsif state st failed value fail result failed state cnt elsif state st locked value fail result failed lim elsif state st locked value pass state cnt result passed state cnt elsif state st locked value pass state cnt result passed state cnt return result function implemented implements output decoder 
function type distortioncontrol state type distortioncontrol state return type distortioncontrol variable result type distortioncontrol state st passed value pass result true lock elsif state st failed value fail result true 
mapping implementation model vhdl elsif state st locked value pass state cnt result true release result false lock return result vhdl implementation process distortioncontrol synthesizable 
synthesis result synthesis process lsi technology schematic 
generation vhdl description process network refinement signal values extended data type handshake protocol discussed detail section 
illustrated 
give details processes involved handshaking protocol 
particular show delay processes exist forsyde model order prevent zero delay feedback loops 
forsyde model handshake protocol 
handshake rm receive sm sd sm sd sf send fo fo rm fifo sf shows delay processes forsyde model handshake protocol explicitly 
delay processes located inside process send 
shows mapping process network vhdl description hardware 
process network translated structural vhdl description forsyde signals mapped vhdl signals forsyde processes mapped vhdl components 
code shows structural vhdl description handshake protocol 
forsyde process translated component forsyde design maximum clock frequency fmax mhz occupies area equiva lent nand gates 
chapter 
implementation mapping 
synthesized implementation process distortioncontrol 
mapping implementation model vhdl fo sender receiver sf rm forsyde processes mapped vhdl components fo send sm forsyde signals mapped vhdl signals sender receiver sd sd reg sf sf rm reg reg sm sd sm 
mapping handshake protocol hardware signal vhdl signal 
code vhdl netlist components 
architecture part lists components defines internal signals 
components connected internal external signals port map 
output components sender receiver records signals signal records connected internal signal expressed lines architecture description 
library ieee ieee std logic handshake pkg entity port type type resetn std logic clk std logic architecture structure component port type type type chapter 
implementation mapping clk std logic resetn std logic component component sender port type type type clk std logic resetn std logic component component receiver port sendmsg type sendmsg type type clk std logic resetn std logic component component port type sendmsg type sendmsg resetn std logic clk std logic component component port type type resetn std logic clk std logic component 
mapping implementation model vhdl component port type type resetn std logic clk std logic component signal fo type signal sf sf type signal sm sm type sendmsg signal sd sd type signal rm type signal type signal type fifo port map sf fo clk clk resetn resetn send sender port map fo rm clk clk resetn resetn rec receiver port map sendmsg sm sd clk clk resetn resetn port map sm chapter 
implementation mapping sm resetn resetn clk clk port map sf sf resetn resetn clk clk del port map sd sd resetn resetn clk clk sm sendmsg sd sf rm structure forsyde processes handshake protocol constructed process constructors mapped vhdl techniques described section 
handshake protocol synthesized lsi standard cell library target architecture 
top module synthesized description shown 
shows clearly mapping forsyde processes vhdl components 
synthesis results table 
component area max 
frequency mhz sender mhz receiver mhz total design mhz table 
synthesis results handshake protocol 
mapping implementation model vhdl 
synthesized implementation handshake protocol top module chapter 
implementation mapping importance optimized implementation model mapping technique described previous sections translate forsyde implementation models vhdl descriptions forsyde leaf processes vhdl mapping template defined 
far mapping done manually vhdl templates mapping rules defined mapping process automated 
order able synthesize implementation model hardware obvious forsyde implementation model synthesizable forsyde constructs synthesizable vhdl constructs 
fifo contains infinite buffer synthesizable infinite data structures hardware 
order get efficient hardware implementation forsyde implementation model optimized translation forsyde vhdl mapping process include optimization 
application speed critical implementation model optimized order minimize critical path 
seq 
process comb 
process seq 
process comb 
seq 
process process cl cl cl cl cl cl cl cl path mapping path 
critical path implementation model critical path illustrated 
forsyde model contains combinational sequential processes 
sequential process translated combinational components registers 
maximum frequency circuit determined path longest combinational delay critical path 
crucial importance implementation model optimized critical path 
means transformational design process supported estimation tool allows give estimate combinational delay process networks 
date forsyde support estimation tool 

discussion discussion chapter describes mapping forsyde implementation model custom hardware 
forsyde defines mapping processes process networks vhdl 
vhdl description synthesized commercial synthesis tools gate netlist chosen target technology 
mapping process done manually automated 
order target complex embedded systems mappings forsyde implementation model architectures defined 
describes mapping procedure sequential software aimed single microprocessor discusses possible hardware software implementation digital equalizer 
specification model ma design transformation implementation model implementation mapping microprocessor ma memory implementation 
design transformation implementation mapping concurrent software running single processor scheduling process compared mapping architectures embedded systems mapping pure hardware sequential software straightforward 
target architecture single processor processes run parallel communicate shared memory design task gets difficult 
illustrated process network specification model processes communicate directly signals transformed implementation model scheduling process takes care chapter 
implementation mapping scheduling processes communication done indirectly memory access process ma 
process implementation model mapped software components 
real time operating system rtos scheduling process mapped rtos 
example shows architecture need mapping procedure exist transformation rules allow prepare implementation model mapping 
development transformation mapping rules feasible require lot effort 
forsyde research project transformation mapping rules may defined limited amount architectures 
chapter chapter concludes thesis giving summary previous chapters key ideas concepts forsyde emphasized 
state forsyde gives overview directions research objective forsyde larger applications 
summary thesis increasing capacity integrated circuits possible integrate functionality single chip 
soc architectures may include variety components allow design powerful applications 
ideally design process applications starts high level model allows designer capture functionality system 
hand low level details required efficiently implement system target architectures 
exists large abstraction gap ideal specification model efficient implementation 
objective forsyde methodology bridge abstraction gap 
forsyde carefully chosen foundations 
specification model uses synchronous computational model separates computation communication expressed clean simple mathematical formalism allows formal reasoning 
addition synchronous model implies total order events allows formulation timing constraints 
processes constructed synchronous process constructors implement synchronous computational model allow design transformation facilitate chapter 
mapping process networks custom hardware sequential software 
implementation model allows establishment synchronous sub domains inside multi rate model 
foundations prepare forsyde incorporation formal methods increasing importance simulation able solve verification task systems increasing size 
details forsyde methodology described chapter 
definitions specification implementation model chapter 
models expressed simulated functional language haskell 
system modeling forsyde illustrated specification model digital equalizer chapter 
chapter describes transformational design refinement forsyde 
phase uses semantic preserving transformations design decisions 
effect design decision implication part transformation rule information designer 
characteristic function derived process network forsyde serves useful tool development transformation rule 
potential transformational refinement illustrated means powerful transformations applied specification model digital equalizer 
step forsyde design flow implementation mapping discussed chapter 
far mapping rules exist custom hardware sequential software 
mapping procedure include optimization idea forsyde move design refinement higher levels abstraction 
optimization shall performed transformational design refinement inside functional domain forsyde 
implementation mapping design process leaves functional domain 
commercial tools software compilers logic synthesis tools take order generate software hardware implementation 
main contribution thesis show system design process moved higher level abstraction carefully selected model computation high level concept process constructors 
forsyde larger examples thesis give indication transformational system design approach application specific domains system design 
date main concepts forsyde formulated validated smaller case studies 
order target realistic applications 
focus restricted application domains target architectures 
list defines areas forsyde 
incorporation models computation multi rate model suitable model applications shall implemented custom hardware 
target architecture concurrent software runs single processor computational models synchronous data flow communicating sequential processes better suited candidates integration implementation model forsyde 
transformation rules number transformation rules forsyde extended include data type memory refinement 
effort put development transformation rules selected application domain selected target architecture 
tool support design refinement transformation tool developed informs designer possible transformations implications ideally possible improvement terms performance measures estimation tool 
starting point incorporate ultra tool forsyde allows apply transformations haskell code 
automation mapping forsyde implementation model vhdl indicated thesis mapping forsyde implementation model automated 
similar tool developed synthesis software architectures 
incorporation verification methods forsyde formal synchronous model similar verification methods lustre esterel incorporated forsyde 
haskell hardware description lava includes formal verification methods investigated extent methods forsyde 
chapter 
modeling language industrial designers general languages vhdl experience functional language haskell 
order forsyde attractive industry modeling language systemc better practical choice forsyde support concepts forsyde extent haskell 
graphical user interface graphical user interface gui increase acceptance industry 
gui hide formal concepts forsyde presents way designers familiar 
process constructor mooresy represented schematic moore finite state machine designer specify initial state functions state output decoder 
forsyde webpage 
www ele kth se forsyde 
haskell home page 
www haskell org 
ultra home page 
www informatik uni ulm de pm ultra 
allan jr kahng rodgers 
technology roadmap semiconductors 
ieee computer january 
armstrong virding williams 
concurrent progamming erlang 
prentice hall 
hsieh lavagno sangiovanni vincentelli suzuki 
hardware software design embedded systems approach 
kluwer academic publishers 
hsieh lavagno sangiovanni vincentelli suzuki 
synthesis software programs embedded control applications 
ieee transactions computer aided design integrated circuits systems june 
bauer ller pepper 
formal program construction transformations computer aided intuition guided programming 
ieee transactions software engineering february 
benveniste berry 
synchronous approach reactive realtime systems 
proceedings ieee september 
benveniste caspi edwards halbwachs guernic simone 
synchronous languages years 
proceedings ieee january 
berg kumar 
grammar hardware synthesis port size independent specifications 
ieee transactions large scale integration vlsi systems 
berry 
real time programming special purpose general purpose language 
ritter editor information processing pages 
elsevier science publishers north holland 
berry 
hardware implementation pure esterel 
proc 
international workshop formal methods vlsi design january 
berry 
foundations esterel 
plotkin stirling tofte editors proof language interaction essays honour robin milner 
mit press 
berry 
constructive semantics pure esterel 
draft version 
berry gonthier 
esterel synchronous programming language design semantics implementation 
science computer programming 
bird 
theory lists 
oxford university computing laboratory technical monograph prg edition 
bird 
lectures constructive functional programming 
oxford university computing laboratory technical monograph prg edition 
claessen sheeran singh 
lava hardware design haskell 
international conference functional programming 
jantsch 
specification method integrating data control flow 
proceedings design test europe conference date 
jantsch 
modeling mixed control dataflow systems 
ieee transactions large scale integration vlsi systems 
de simone 
esterel language 
proceedings ieee september 

discrete event systems modeling performance analysis 
associates 
claessen 
embedded languages describing verifying hardware 
phd thesis chalmers university technology teborg university 
cole 
algorithmic skeletons structured management parallel computation 
research monographs parallel distributed computing 
pitman london 
mer gajski 
specc methodology high level modeling 
th ieee electronic design processes workshop monterey california april 
edwards lavagno lee sangiovanni vincentelli 
design embedded systems formal models validation synthesis 
proceedings ieee march 
eker lee liu liu sachs xiong 
taming heterogeneity ptolemy approach 
proceedings ieee january 
sarma 
sdl formal object oriented language communicating systems 
prentice hall 
ernst 
codesign embedded systems status trends 
ieee design test computers april june 
ernst henkel brenner 
hardware software microcontrollers 
ieee design test computers december 
flynn 
computer organisations effectiveness 
ieee transactions computers september 
gajski dutt 
wu 
lin 
high level synthesis 
kluwer academic publishers 
gajski 
high level synthesis 
ieee design test computers 
gajski zhu mer zhao 
spec specification language methodology 
kluwer academic publishers 
girault lee lee 
hierarchical finite state machines multiple concurrency models 
ieee transactions computer aided design integrated circuits systems june 
gordon milner morris wadsworth 
metalanguage interactive proof lcf 
conference record th annual acm symposium principles programming languages pages 
acm 
gr liao martin swan 
system design systemc 
kluwer academic publishers 
guernic gautier de marie 
programming real time applications signal 
proceedings ieee september 
gupta 
synthesis hardware software digital embedded systems 
kluwer academic publishers 
gupta micheli 
hardware software digital systems 
ieee design test computers september 
halbwachs 
synchronous programming reactive systems 
kluwer academic publishers 
halbwachs caspi raymond pilaud 
synchronous data flow programming language lustre 
proceedings ieee september 
halbwachs raymond 
validation synchronous reactive systems formal verification automatic testing 
asian asian computing science conference thailand december 
lncs springer verlag 

mastering matlab comprehensive tutorial 
prentice hall 
harel 
statecharts visual formalism complex systems 
science computer programming 
hoare 
communicating sequential processes 
communications acm 
hsieh lavagno sangiovanni vincentelli 
synchronous approach functional equivalence embedded system implementations 
ieee transactions computer aided design integrated circuits august 
hudak 
conception evolution application functional programming languages 
acm computing surveys september 
hudak jones 
haskell vs ada vs vs awk vs experiment software prototyping productivity 
technical report dept computer science yale university july 
hudak peterson fasel 
gentle haskell 
october 
www haskell org tutorial 
hughes 
functional programming matters 
computer journal 
ieee 
ieee standard verilog hardware description language 
ieee 
ieee 
ieee standard vhdl language manual 
ieee 
ii goel lee liu liu reekie smyth xiong 
overview ptolemy project 
technical report ucb erl 
dept eecs university california berkeley ca 
jantsch 
composite signal flow computational model combining events sampled streams vectors 
proceedings design test europe conference date 
jantsch kumar sander berg nils 
comparison languages system level descriptions telecom systems 
international forum design languages proceedings volume pages lausanne switzerland september 
jantsch sander 
roles functions objects system specification 
proceedings international workshop hardware software codesign 
jantsch sander wu 
usage stochastic processes embedded system specifications 
proceedings ninth international symposium hardware software codesign april 
jantsch editors 
networks chip 
kluwer academic publishers 
jones sheeran 
circuit design ruby 
formal methods vlsi design pages 
north holland 
jones 
haskell language libraries 
cambridge university press 
kahn 
semantics simple language parallel programming 
proceedings ifip congress 
north holland 
kahn macqueen 
coroutines networks parallel processes 
ifip 
north holland 
malik newton rabaey sangiovanni vincentelli 
system level design concerns platform design 
ieee transaction computer aided design integrated circuits systems december 
lee 
ahead embedded software 
ieee computer september 
lee messerschmitt 
static scheduling synchronous data flow programs digital signal processing 
ieee transactions computers january 
lee messerschmitt 
synchronous data flow 
proceedings ieee september 
lee parks 
dataflow process networks 
ieee proceedings 
lee sangiovanni vincentelli 
framework comparing models computation 
ieee transactions computer aided design integrated circuits systems december 
li 
hml novel hardware description language translation vhdl 
ieee transactions vlsi february 
lu 
refinement system specification digital equalizer hw sw implementations 
master thesis department microelectronics information technology royal institute technology december 

lu sander jantsch 
case study hardware software synthesis forsyde 
proceedings th international symposium system synthesis kyoto japan october 
luk wu 
declarative framework hardware software codesign 
proc 
third international workshop hardware software codesign pages 

argos language graphical representation automata description reactive systems 
ieee workshop visual languages oct 
matthews cook launchbury 
microprocessor specification hawk 
international conference computer languages 
micheli 
synthesis optimization digital circuits 
mcgraw hill 
micheli ernst wolf 
readings hardware software design 
morgan kaufmann publishers 
micheli gupta 
hardware software design 
proceedings ieee march 
kulkarni moskewicz tsai shah weber jin sauer vissers malik 
developing architectural platforms disciplined approach 
ieee design test computers november december 
milner 
theory type polymorphism programming 
journal computer system sciences 
milner 
calculus communicating systems 
lncs 
milner 
communication concurrency 
prentice hall 
milner tofte harper macqueen 
definition standard ml revised 
mit press 
moore 
components integrated circuits 

mycroft sharp 
hardware software design functional languages 
proceedings tools algorithms construction analysis systems tacas volume lncs 
springer verlag 
donnell 
transistors computer architecture teaching functional circuit specification hydra 
springer verlag editor symposium functional programming languages education volume lncs pages 

specification transformation programs 
springer verlag 

rules strategies transforming functional logic programs 
acm computing surveys june 

self timed circuit design action systems approach 
phd thesis university turku finland 
proakis 
digital signal processing 
prentice hall edition 
reekie 
realtime signal processing 
phd thesis university technology sydney australia 
halbwachs 
implementing reactive programs circuits hardware implementation lustre 
rex workshop proceedings june 
sander jantsch 
formal system design synchrony hypothesis 
proceedings th international conference vlsi design pages goa india january 
sander jantsch 
system synthesis formal computational model skeletons 
proceedings ieee workshop vlsi pages orlando florida april 
ieee computer society 
sander jantsch 
system synthesis utilizing layered functional model 
proceedings seventh international workshop hardware software codesign pages rome italy may 
acm press 
sander jantsch 
transformation communication clock domain refinement system design 
th design automation conference dac new orleans usa june 
sander jantsch 
system modeling transformational design refinement forsyde 
submitted journal ieee transactions computer aided design integrated circuits systems 
sander jantsch lu 
development application design transformations forsyde 
design automation test europe conference date pages munich germany march 

systematic design synchronous digital circuits 
phd thesis university turku finland 
sheets malik rabaey sangiovanni vincentelli 
addressing system chip interconnect communication design 
design automation conference dac las vegas nevada usa june 
sharp mycroft 
higher level language hardware synthesis 
proceedings th advanced research working conference correct hardware design verification methods volume lncs 
springer verlag 
singh 
system level lava 
design automation test europe conference date pages march 
skillicorn 
foundations parallel programming 
cambridge university press 
skillicorn talia 
models languages parallel computation 
acm computing surveys june 
strehl thiele gries ernst teich 
fun state internal design representation codesign 
ieee transactions large scale integration vlsi systems august 
stroustrup :10.1.1.26.9545
programming language 
addison wesley 
thompson 
haskell craft functional programming 
addison wesley edition 

fundamental transformational design 
acm transactions design automation electronic systems october 
wan 
functional reactive programming principles 
programming language design implementation pldi 
wan taha hudak 
real time frp 
international conference functional programming icfp 
wan taha hudak 
event driven frp 
fourth international symposium practical aspects declarative languages padl 
winskel 
formal semantics programming languages 
mit press 
wolf 
hardware software design embedded systems 
proceedings ieee july 
wu sander jantsch 
transformational system design formal computational model skeletons 
forum design languages bingen germany september 
richter ernst thiele teich 
spi system model specified embedded systems 
ieee transactions large scale integration vlsi systems august 
appendix forsyde standard library libraries computational application libraries forsyde core language haskell libraries system functions model system data types 
forsyde standard library forsyde standard library consists layers illustrated 
bottom layer haskell language 
layer haskell defines forsyde core language 
fundamental data types signal vector corresponding functions defined 
computational models defined computational model library located top core language 
top core language libraries system functions data types contains functions data types typical system applications independent computational model 
top layer forsyde standard library consists application libraries 
appendix forsyde standard library libraries include components functions modeled specific computational models 
forsyde standard library imported import includes sub modules library 
appendix covers parts library thesis 
preliminary versions computational models stochastic library see forsyde web page 
code written literate haskell style possible include latex code documentation 
parts literate program entirely enclosed code 
code treated program text lines comments 
allows include usual latex text figures equations comments 
overview forsyde standard library contains data types functions forsyde design 
module works container exports libraries 
module module module module module vector module signal module memory module module queue module combinators module dft module fir import import import import vector import signal import memory import import queue 
forsyde core language import combinators import fir import dft forsyde core language forsyde core language includes vector 
overview defines data functions operating data type 
module signal signal nulls signal units nulls heads tails ats takes drops lengths selects writes reads infixr infixr infixr infixr data signal defined list events 
event tag value 
tag event defined position list 
data signal nulls signal deriving eq signal defined instance 
signal nulls represented 
functions data module defines functions data appendix forsyde standard library signal signal signal units signal nulls signal bool heads signal tails signal signal ats int signal takes int signal signal drops int signal signal selects int int signal signal lengths num signal signal writes show signal char reads read char signal signal signal signal signal signal functions signal convert list signal vice versa 
function units creates signal value 
function nulls checks signal empty 
gives value head signal gives rest signal tail 
returns th event signal 
numbering events signal starts 
operator version function 
returns values signal drops values signal 
function selects takes parameters offset stepsize signal returns elements signal example signal selects signal signal integer new signals created means functions 
data constructor adds element signal head signal 
operator adds element signal tail 
operator signals signal 
function lengths returns length finite stream 
creates infinite signal 
argument function applied current value 
second argument gives value signal 
signal takes signal integer creates signal 
transforms signal string format signal writes signal 
forsyde core language char transforms formatted string signal 
signal reads signal int signal int takes andp generates process network signal split processed andp 
fans signal signal signal signal signal signal signal instance show show signal showsprec nulls showsprec showchar xs nulls showchar nulls shows showchar xs shows showchar xs instance read read signal read reads signal nulls rest lex reads rest lex nulls lex lex xs lex reads lex xs read reads signal nulls appendix forsyde standard library reads lex xs reads lex xs signal nulls signal xs signal xs nulls xs xs units nulls nulls nulls true nulls false heads nulls error heads signal empty heads tails nulls error tails signal empty tails xs xs ats nulls error ats signal elements ats ats xs ats xs xs ats xs takes nulls takes nulls nulls takes xs nulls takes xs drops nulls nulls drops nulls nulls drops xs xs drops xs selects offset step xs select step drops offset xs 
forsyde core language select step nulls nulls select step xs select step drops step xs xs xs nulls nulls ys ys xs ys xs ys lengths nulls lengths xs lengths xs nulls fans xs xs xs writes nulls writes xs show writes xs reads xs reads words xs reads nulls reads xs reads xs reads xs read reads xs overview module vector defines data type vector corresponding functions 
development defined reekie 
vector modeled list viewed array vector fixed size 
unfortunately possible size vector parameter vector data type due restrictions type system 
operations defined vectors size 
module vector vector vector nullv lengthv mapv appendix forsyde standard library infixr infixl infixr data data modeled similar list 
data type constructors 
nullv constructs empty vector vector adding value existing vector 
inheritance mechanism haskell declared vector instance 
means vector nullv shown 
data vector nullv vector deriving eq functions data converts list vector converts vector list 
vector vector vector function creates vector element 
function nullv returns true vector empty 
function lengthv returns number elements value 
returns th element vector starting zero 
replaces element vector 
vector nullv vector bool lengthv num vector vector int vector num vector return element element vector 
returns element vector returns elements vector 
returns elements vector drops elements vector 

forsyde core language vector vector vector vector vector vector num ord vector vector num ord vector vector selects elements vector 
argument gives initial element starting zero second argument gives stepsize elements argument gives number elements 
num ord vector vector groups vector vector vectors size num ord vector vector vector data constructor adds element add front vector operator adds element 
operator vectors 
vector vectors single vector 
vector vector vector vector vector higher order applies function elements vector 
mapv vector vector higher order applies function pairwise vectors 
vector vector vector higher order fold function right left vector initial value 
vector vector higher takes predicate function vector creates new vector elements predicate true 
bool vector vector function zips vectors vector tuples 
function vector tuples vectors 
vector vector vector vector vector vector appendix forsyde standard library function shifts value left vector 
function shifts value right vector 
rotates vector left right 
note change size vector 
vector vector vector vector vector vector vector vector function transforms vector vectors single vector 
reverses order elements vector 
vector vector vector vector vector function generates vector number elements starting initial element supplied function generation elements 
function behaves way starts th application supplied function supplied value 
function generates vector number copies element 
vector vector integer vector vector integer vector vector integer num vector num vector num vector functions construct serial parallel networks processes 
vector vector vector vector functions scan function vector 
functions take initial element apply functions recursively element result function application 
vector vector vector vector 
forsyde core language reekie proposed iterators 
combination mapv 
argument function supplies pair values input application function second output value 
example consider expression vector calculate running sum 
vector vector vector vector vector implementation instance show show vector showsprec nullv showsprec showchar xs nullv showchar nullv shows showchar xs shows showchar xs instance read read vector read reads vector nullv rest lex reads rest lex nullv lex appendix forsyde standard library lex xs lex reads lex xs read reads vector nullv reads lex xs reads lex xs vector nullv vector xs vector xs nullv xs xs nullv nullv nullv true nullv false lengthv nullv lengthv xs lengthv xs vs lengthv vs vs vs vs nullv error vector elements xs xs nullv error vector empty nullv error vector empty vs vs 
forsyde core language nullv error vector empty nullv vs vs nullv error vector empty nullv nullv vs vs nullv nullv nullv vs nullv vs vs vs nullv nullv vs vs vs vs nullv lengthv vs error vector elements vs vs lengthv nullv lengthv nullv ys ys xs ys xs ys xs xs mapv nullv nullv mapv xs mapv xs xs ys xs ys nullv nullv xs xs appendix forsyde standard library nullv xs xs nullv nullv vs vs vs xs ys xs ys nullv nullv nullv nullv xys xs ys xs ys xys vs vs vs vs nullv nullv vs vs vs nullv nullv vs vs vs nullv nullv nullv vs vs nullv nfa fa nullv nfa id fs fs nullv fs fs 
forsyde core language nullv nullv nullv nullv error vectors size nullv error vectors size fs xs fs xs nullv nullv xs xs fax nullv nullv nullv nullv xs ys ys xs nullv nullv xs ys fax ys xs nullv nullv xs ys ys xs overview module extend existing data types value absent 
module abstext abst prst abstext psi data constructors 
model absence value model values 
data abstext abst prst deriving eq appendix forsyde standard library data defined instance 
represents value represented value prst represented 
functions data module defines functions abstext abstext bool abstext bool abstext abstext psi abstext abstext function abstext converts value extended value 
function converts value extended value 
functions check presence absence value 
function extends function order process absent extended values 
input output 
function psi identical 
implementation library functions instance show show abstext showsprec abst prst show instance read read abstext read reads abstext abst lex prst reads abstext prst abst prst abst false 
libraries system functions data types prst true abst abst prst prst psi overview module contains operators function sequential composition parallel composition 
module combinators 
ps ps ps libraries system functions data types overview module contains data structure access functions memory model 
module memory module memory access adr appendix forsyde standard library import vector import data structure data type memory modeled vector 
data tpe access defines access patterns read adr adr val type 
type adr int type int data memory mem adr vector abstext deriving eq show data access read adr write adr deriving eq show functions data module defines access functions memory memory memory access memory memory access abstext function creates new memory number entries parameter 
gives new state memory access memory 
operation leaves unchanged 
gives output memory access memory 
operation gives absent value output 
implementation functions size mem size size abst memory int memory mem size vs size mem size vs abstext mem size vs 
libraries system functions data types memory int abstext mem size vs size vs abst mem read mem mem write mem mem read mem write abst overview provides data types model queue structures fifos 
data type queue infinite size queue finite 
data type queue queue modeled list 
data type additional parameter determines size queue 
module queue import data queue deriving eq show data fq int deriving eq show functions data table shows functions data 
queue queue queue queue queue queue abstext queue queue abstext int appendix forsyde standard library infinite finite description pushes element queue pushes list elements queue pops element queue queue transforms list queue implementation table 
functions data xs xs abst xs xs prst queue xs xs fq length fq fq fq xs fq take xs fq fq abst fq qs fq qs prst xs fq take module includes standard discrete fourier transform dft function formulated kn 
libraries system functions data types 
basic butterfly computation time algorithm wn fast fourier transform fft algorithm computing dft size power 
module dft dft fft import signal import vector import complex follows forsyde implementation dft dft lengthv mapv error dft vector right size lengthv mapv mapv cis integer vector double frominteger nullv pi frominteger follows radix fft algorithm decimation time implementation 
divide conquer algorithm reuses calculation basic butterfly appendix forsyde standard library 
point decimation time fft algorithm feven km km feven feven calculation point fft illustrated 
fft xv lengthv xv mapv xv error fft vector right size nullv odd xv odd frominteger evens xv odd odds xv lengthv xv cis pi frominteger frominteger 
computational model libraries evens nullv nullv evens nullv nullv evens evens odds nullv nullv odds nullv nullv odds odds computational model libraries overview defines process constructors processes synchronous computational model 
process constructor higher order function combinatorial function values arguments constructs process 
process constructor viewed process constructor 
module module vector module signal module mapsy zipwithsy zipwith sy zipwith sy scanlsy scanl sy scanl sy scanldsy sy sy delaysy zip sy zip sy unzip sy unzip sy mooresy moore sy moore sy mealysy mealy sy mealy sy import signal import vector import process constructors combinatorial processes combinatorial processes internal state output depends input signals 
module includes process constructors combinatorial processes appendix forsyde standard library mapsy signal signal zipwithsy signal signal signal zipwith sy signal signal signal signal zipwith sy signal signal signal signal signal vector vector signal signal vector signal vector signal process takes combinatorial function argument returns process input signal output signal 
shown process increments values input signal 
similar zipwith sy sy apply combinatorial function number input signals 
process works works vector signals input 
process creates process network maps function signals vector signals 
process constructors sequential processes sequential processes local state 
process constructors construct processes take functions values arguments express value local state process 
output sequential processes deterministic depends initial state input signals 
module includes process constructors sequential processes delaysy signal signal int signal signal scanlsy signal signal scanl sy signal signal signal scanl sy signal signal signal signal scanldsy signal signal sy signal signal signal sy signal signal signal signal mooresy signal signal moore sy signal 
computational model libraries signal signal moore sy signal signal signal signal mealysy signal signal mealy sy signal signal signal mealy sy signal signal signal signal signal bool signal signal abstext process constructor delaysy delays signal event cycle introducing initial value output signal 
process delays signal events introducing identical default values 
define different basic process constructors construct sequential processes scanlsy 
process constructors take arguments 
process constructors function ns calculate state calculate output different way 
scanlsy behaves haskell prelude function scanl value new state output value scanldsy current state value output 
example exemplifies scanlsy signal signal integer scanldsy signal signal integer process constructors sy scanl delaysy way input signals 
process constructors mooresy mealysy model state machines 
process constructors process naturally state machines hardware output operates current state state 
process constructors take function ns calculate state function calculate output value initial state 
process process constructor output current state process 
contrast output function process process constructor operates current state input 
takes function initial state generates infinite signal starting initial state output followed appendix forsyde standard library recursive application current state serve output values 
process infinite signal natural numbers output constructed takes signal integer process takes produces process discards values 
case output 
processes module contains synchronous processes signal abstext signal abstext signal abstext signal abstext signal signal abstext signal signal signal signal zip sy signal signal signal signal zip sy signal signal signal signal signal signal signal signal unzip sy signal signal signal signal unzip sy signal signal signal signal signal vector signal signal vector signal vector vector signal signal signal signal signal process creates process synchronizes signal timed values signal timed values 
output signal value signal event value event absent value 
process constructor creates process fills signal timed values replacing absent values value 
process creates process fills signal values replacing absent values preceding value 
cases preceding value exists absent value replaced supplied value 
zips incoming signals signal tuples process signal tuples signals 
functions 
computational model libraries zip sy zip sy unzip sy sy perform corresponding function signals 
process zip signal vectors vector signals 
vector signals signal vectors 
processes select second value signal pairs 
implementation library functions mapsy nulls nulls mapsy xs mapsy xs zipwithsy nulls nulls zipwithsy nulls nulls zipwithsy xs ys zipwithsy xs ys zipwith sy nulls nulls zipwith sy nulls nulls zipwith sy nulls nulls zipwith sy xs ys zs zipwith sy xs ys zs zipwith sy nulls nulls zipwith sy nulls nulls zipwith sy nulls nulls zipwith sy nulls nulls zipwith sy ws xs ys zs zipwith sy ws xs ys zs mapsy mapv mapsy scanlsy nulls nulls scanlsy mem xs mem scanlsy xs mem scanl sy nulls nulls scanl sy nulls nulls scanl sy mem xs ys mem scanl sy xs ys mem appendix forsyde standard library scanl sy nulls nulls scanl sy nulls nulls scanl sy nulls nulls scanl sy mem xs ys zs mem scanl sy xs ys zs mem scanldsy nulls nulls scanldsy mem xs mem scanldsy xs mem sy nulls nulls sy nulls nulls sy mem xs ys mem sy xs ys mem sy nulls nulls sy nulls nulls sy nulls nulls sy mem xs ys zs mem sy xs ys zs mem delaysy es es xs xs xs mooresy nextstate output initial mapsy output 
scanldsy nextstate initial moore sy nextstate output initial inp inp mapsy output sy nextstate initial inp inp moore sy nextstate output initial inp inp inp mapsy output sy nextstate initial inp inp inp mealysy nextstate output initial signal zipwithsy output scanldsy nextstate initial signal signal mealy sy nextstate output initial inp inp zipwith sy output sy nextstate initial inp inp inp inp 
computational model libraries mealy sy nextstate output initial inp inp inp zipwith sy output sy nextstate initial inp inp inp inp inp inp nulls nulls xs true prst xs abst xs delaysy mapsy nulls nulls nulls nulls xs abst ys abst xs ys xs ys xs ys xs mapsy xs abst prst xs scanlsy hold xs hold abst hold prst xs ys xs ys nulls zip sy xs ys zs zip sy xs ys zs zip sy nulls zip sy ws xs ys zs zip sy ws xs ys zs zip sy nulls nulls nulls nulls xys xs ys xs ys xys unzip sy nulls nulls nulls nulls unzip sy xs ys zs appendix forsyde standard library xs ys zs unzip sy unzip sy nulls nulls nulls nulls nulls unzip sy ws xs ys zs ws xs ys zs unzip sy nullv nulls nulls xss xss xs xss mapv heads xss xs mapv tails xss nulls nullv nullv vss vss vs vss mapsy vss vs mapsy vss mapsy fst mapsy snd overview defines domain interface constructors multi rate computational model 
module downdi updi par ser par ser di par ser di par ser di ser par di ser par di ser par di import signal import vector import domain interface constructors domain interface constructors downdi updi take parameter sample input signal 
domain interface constructors par ser di par ser di par ser di implement domain interface constructor sdi 
domain interface implements domain interface constructor sdi variable 
computational model libraries domain interface constructors ser par di ser par di ser par di implement domain interface constructor pdi 
domain interface implements domain interface constructor pdi variable downdi num signal signal updi num signal signal abstext par vector signal signal ser num ord signal abstext vector signal abstext par ser di signal signal signal par ser di signal signal signal signal par ser di signal signal signal signal signal ser par di signal signal abstext abstext ser par di signal signal abstext abstext abstext ser par di signal signal abstext abstext abstext abstext implementation downdi xs xs nulls nulls xs xs xs xs xs xs xs updi nulls nulls updi xs prst abst updi xs par ser di xs ys par ser di xs ys par ser di nulls nulls par ser di xys par ser di xys par ser di xs ys zs par ser di zip sy xs ys zs par ser di nulls nulls par ser di par ser di par ser di ws xs ys zs par ser di zip sy ws xs ys zs par ser di nulls nulls appendix forsyde standard library par ser di par ser di ser par di group sy abst mapsy abstext ser par di group sy abst mapsy abstext ser par di group sy abst mapsy abstext par par par nulls nulls par xv xs signal xv par xs ser delaysy abst group group sy nulls nulls group sy nulls nulls group sy xys group sy xys group sy nulls nulls group sy nulls nulls group sy nulls nulls group sy group sy group sy nulls nulls group sy nulls nulls group sy nulls nulls group sy nulls nulls group sy group sy signal abstext signal nulls nulls abst xs xs prst xs xs group xs mapsy output scanlsy addelement nullv xs addelement vs vs output vs prst vs abst 
application libraries application libraries overview synchronous process library defines processes synchronous computational model 
synchronous library 
module module module signal module import import signal import import queue import memory processes library defines processes signal signal abstext int signal signal abstext int signal access signal abstext signal abstext signal abstext signal abstext enum ord signal process implements synchronous model fifo infinite size process implements fifo finite size 
fifos take list values event cycle output value 
delay cycle 
process implements synchronous memory 
uses access functions adr adr value 
process merges input signals single signal 
process internal buffer order prevent loss data 
process deterministic outputs events time tag 
valid values signals 
value signal output 
function appendix forsyde standard library groups values vector size takes cycles 
grouping takes place output process consists absent values 
implements counter counts 
process counters input output infinite signal 
implementation processes xs mooresy queue xs queue queue xs xs xs fst xs queue abstext abst xs prst xs mooresy xs fq xs fq xs xs fst xs abstext fq abst fq xs prst size xs mealysy ns size xs ns mem read mem read ns mem write mem write mem read mem read mem write mem write xs ys moore sy xs ys abst abst abst prst prst abst prst prst abst abst 
application libraries abst prst prst abst prst prst abst prst mooresy nullv lengthv lengthv lengthv prst nullv lengthv prst gv abst fx succ fir filter described equation illustrated xn yn xn mhm xn xn xn hk 
fir filter yn state fir filter seen shift register parallel output 
element shift register cycle xn element xn cycle new value xn shifted register left appendix forsyde standard library elements shifted place right value xn discarded 
model shift register process process process constructor scanlsy takes shift function argument initial vector size zeroes initial values 
output signal vectors transformed process vector signals 
process calculates inner product coefficient vector output shift register 
process implemented process constructor zipwithsy takes function ipv arguments 
module fir fir import fir lengthv signal zipwithsy signal vector signal 
fir filter model scanldsy initstate initstate ipv ipv nullv nullv ipv hv xv ipv hv xv vector signal kinds fir filters modeled means fir 
argument needed list coefficients vector size 

application libraries illustrate th order band pass filter modeled follows 
bp fir vector appendix equalizer specification model chapter gives executable code equalizer specification model 
code written literate haskell style possible include latex code documentation 
parts literate program entirely enclosed code 
code treated program text lines comments 
allows include usual latex text figures equations comments 
overview main task equalizer system adjust audio signal works user interface 
addition bass level exceed predefined threshold avoid damage speakers 
specification naturally decomposed functions shown 
subsystems distortioncontrol control dominated grey shaded audioanalyzer data flow dominated subsystems 
subsystem monitors button inputs override signal subsystem distortioncontrol adjusts current bass treble levels 
information passed subsystem receives audio input filters amplifies audio signal current bass treble levels 
signal output signal equalizer analyzed appendix equalizer specification model bassup bassdn trebleup trebledn bass button distortion control treble control audio filter audio analyzer 
subsystems equalizer delaysy audioanalyzer subsystem determines bass exceeds predefined threshold 
result analysis passed subsystem distortioncontrol decides minor major violation encountered issues necessary commands subsystem 
frequency characteristics equalizer adjusted coefficients fir filters 
module equalizer equalizer import import import import distortioncontrol import audioanalyzer import structure equalizer expressed network blocks equalizer bassup bassdn trebleup trebledn input output bass treble overrides bassup bassdn trebleup trebledn output bass treble input audioanalyzer output overrides distortioncontrol delaysy abst equalizer contains feedback loop signal delayed event cycle initial value 

bassdn bassup trebledn trebleup button interface button level control hold level levels 
subsystem overview bass treble subsystem works user interface equalizer system 
receives input signals bassdn bassup trebledn trebleup override signal override distortioncontrol calculates new bass treble values output signals bass treble 
contains main processes 
process outputs new value signal button signal output value absent 
process modeled means outputs value input value absent 
process transforms signal tuples current bass treble level tuple signals bass treble signal 
module import import data state operating locked deriving eq show type level double type bass level type treble level signal abstext signal abstext sensor signal abstext sensor signal abstext sensor signal abstext sensor signal bass signal treble overrides bassdn bassup trebledn trebleup bass treble bass treble levels levels button overrides button bassdn bassup trebledn trebleup appendix equalizer specification model process monitors input buttons bassdn bassup trebledn trebleup indicates button pressed 
buttons pressed conflict resolved priority order buttons 
signal abstext sensor signal abstext sensor signal abstext sensor signal abstext sensor signal abstext button bassup bassdn trebleup trebledn zipwith sy bassup bassdn trebleup trebledn prst active prst bassup prst active prst bassdn prst active prst trebleup prst active prst trebledn abst process process local state consists mode current values bass treble levels 
modes mode operating bass treble values stepwise changed steps 
exists maximum minimum values 
process enters mode locked override input value lock 
mode additional increase bass level decreased case override signal value 
subsystem returns operating mode override value release 
output process absent extended signal tuples current bass treble levels 
signal abstext button signal abstext signal abstext bass treble button overrides mealy sy nextstate output initstate button overrides nextstate state double double abstext button abstext state double double nextstate state bass treble button override newstate newstate state operating override prst lock locked operating 
operating lock release locked bassup operating trebledn bassdn trebleup incl decl incl decl operating locked trebledn bassdn trebleup decl decl incl decl locked 
state diagram process override prst release operating locked state locked override prst bass button prst bassdn bass step bass state operating button prst bassdn bass step button prst bassup bass step appendix equalizer specification model bass button prst trebledn treble step button prst trebleup treble step treble output bass treble abstext button abstext abstext bass treble output abst abst abst output levels prst levels process uses initial values 
initstate operating maxlevel step process uses auxiliary functions 
level level level level step level step level level level level step maxlevel maxlevel level step block distortioncontrol directly developed sdl specification model 
specification shown 

process dcl cnt integer dcl lim integer passed pass fail passed lock cnt lim failed pass fail locked fail pass failed cnt lim cnt cnt failed cnt release locked passed 
sdl description distortion control distortioncontrol single fsm modeled means skeleton mealysy global state expressed explicit states passed failed locked means variable cnt 
state machine possible input values pass fail output values lock release 
mealysy creates process interpreted mealy machine 
takes functions calculate state calculate output 
state represented pair explicit state variable cnt 
initial state sdl model tuple passed 
function uses pattern matching 
input value matches pattern function corresponding right hand side evaluated giving appendix equalizer specification model state 
event absent value leaves state unchanged 
output function modeled similar way 
output absent output message indicated sdl model 
module distortioncontrol distortioncontrol import import data state passed failed locked distortioncontrol signal abstext signal abstext distortioncontrol distortion mealysy passed distortion lim state input nextstate state cnt abst state cnt passed cnt prst pass passed cnt passed prst fail failed lim failed cnt prst pass locked cnt failed cnt prst fail failed cnt locked prst fail failed lim locked cnt prst pass passed locked cnt state input output passed prst pass abst passed prst fail prst lock failed prst pass abst failed prst fail prst locked prst fail abst locked cnt prst pass cnt prst release abst abst abst 
overview shows structure 
task subsystem amplify different frequencies audio signal independently assigned levels 
audio signal splitted identical signals frequency region 
signals filtered amplified assigned amplification level 
equalizer design bass treble control middle frequencies amplified 
output signal addition filtered amplified signals 
low pass band pass high pass bass treble amplifier amplifier 
subsystems audio filter model structure network blocks directly 
consists filters amplifiers adder 
blocks modeled process layer 
filter coefficients low pass band pass high pass filter parameters 
module import floating vector vector vector signal signal signal signal bass treble zipwith sy add amplify bass lowpass bandpass amplify treble highpass lowpass fir bandpass fir highpass fir appendix equalizer specification model group samples dft spectrum 
audio analyzer subsystem amplify zipwithsy scale add scale base base overview check bass audioanalyzer analyzes current bass level raises flag bass level exceeds limit 
audioanalyzer divided blocks 
input signal grouped samples size process processed dft order get frequency spectrum signal 
power spectrum calculated spectrum 
lowest frequencies compared threshold value 
exceed value output value fail 
needs cycles grouping produces absent values grouped sample 
processes dft spectrum extended order able process absent value 
module audioanalyzer audioanalyzer import import complex import limit audioanalyzer pts mapsy psi check bass mapsy psi spectrum spectrum mapsy psi dft pts dft pts group samples mapsy 
spectrum mapv log mapv power log log log xs xs xs half xs half floor lengthv xs power magnitude limit limit limit fail pass vs vs overview module collection data types equalizer model 
module data pass fail deriving show read eq data lock release deriving show read eq data sensor active deriving show read eq data button bassdn bassup trebledn trebleup deriving show read eq appendix vhdl templates forsyde processes appendix gives overview templates mapping forsyde processes hardware description vhdl 
appendix divided parts vhdl template processes combinational process constructors section vhdl template processes sequential process constructors section vhdl template processes domain interface process constructors section vhdl templates combinational process constructors vhdl template processes constructed mapsy mapsy 
hardware implementation mapsy illustrates mapping process mapsy hardware 
vhdl code template 
appendix vhdl templates forsyde processes package mapsy lib type type mapsy defined type type type mapsy defined type function type mapsy return type mapsy package body mapsy lib function type mapsy return type mapsy return defined definition mapsy lib entity mapsy port type mapsy type mapsy architecture comb mapsy vhdl template processes constructed zipwithsy im zipwithsy 
hardware implementation zipwithsy illustrates mapping process zipwithsy hardware 
vhdl code template 
package zipwithsy lib type type zipwithsy defined type type type zipwithsy defined type type type zipwithsy defined type function type zipwithsy type zipwithsy return type zipwithsy 
vhdl templates sequential process constructors package body zipwithsy lib function type zipwithsy type zipwithsy return type zipwithsy return defined definition zipwithsy lib entity zipwithsy port type zipwithsy type zipwithsy type zipwithsy architecture comb zipwithsy vhdl templates sequential process constructors vhdl template processes constructed delaysy delaysy clk resetn reg reg 
hardware implementation delaysy illustrates mapping process delaysy hardware 
vhdl code template 
package delaysy lib type type delaysy defined definition type type delaysy defined definition constant type delaysy defined initial state appendix vhdl templates forsyde processes library ieee ieee std logic delaysy lib entity delaysy port type delaysy type delaysy resetn std logic clk std logic architecture seq delaysy signal type delaysy process clk resetn resetn elsif rising edge clk process vhdl template processes constructed scanlsy im scanlsy zipwithsy delaysy clk 
hardware implementation scanlsy reg resetn illustrates mapping process scanlsy hardware 
vhdl code template 

vhdl templates sequential process constructors package scanlsy lib type type scanlsy defined type type type scanlsy defined type subtype type scanlsy state type scanlsy constant type scanlsy state defined initial state function type scanlsy state type scanlsy state return type scanlsy package body scanlsy lib function type scanlsy state type scanlsy state return type scanlsy return defined definition scanlsy lib library ieee ieee std logic scanlsy lib library synopsys synopsys attributes entity scanlsy port type scanlsy type scanlsy clk std logic resetn std logic scanlsy architecture seq scanlsy signal state nextstate type scanlsy state attribute state vector string attribute state vector seq architecture state seq appendix vhdl templates forsyde processes process clk resetn process resetn asynchronous reset active low state elsif clk event clk rising clock edge state nextstate process process state process nextstate state process nextstate seq vhdl template processes constructed scanldsy im scanldsy zipwithsy delaysy clk 
hardware implementation scanldsy reg resetn illustrates mapping process scanldsy fp hardware 
vhdl code template 
package scanldsy lib type type scanldsy defined type type type scanldsy defined type subtype type scanldsy state type scanldsy constant type scanldsy state defined initial state function type scanldsy state type scanldsy state return type scanldsy package body scanldsy lib 
vhdl templates sequential process constructors function type scanldsy state type scanldsy state return type scanldsy return state scanldsy lib library ieee ieee std logic scanldsy lib library synopsys synopsys attributes entity scanldsy port type scanldsy type scanldsy clk std logic resetn std logic scanldsy architecture seq scanldsy signal state nextstate type scanldsy state attribute state vector string attribute state vector seq architecture state seq process clk resetn process resetn asynchronous reset active low state elsif clk event clk rising clock edge state nextstate process process state process nextstate state state process appendix vhdl templates forsyde processes seq vhdl template processes constructed mooresy im mooresy scanldsy mapsy clk reg resetn 
hardware implementation mooresy illustrates mapping process mooresy hardware 
vhdl code template 
package mooresy lib type type mooresy defined type type type mooresy defined type type type mooresy state defined type state constant type mooresy state defined initial state function type mooresy state type mooresy state return type mooresy state function state type mooresy state return type mooresy package body mooresy lib function type mooresy state type mooresy state return type mooresy state return defined definition function state type mooresy state return type mooresy return defined definition 
vhdl templates sequential process constructors mooresy lib library ieee ieee std logic mooresy lib library synopsys synopsys attributes entity mooresy port type mooresy type mooresy clk std logic resetn std logic mooresy architecture seq mooresy signal state nextstate type mooresy state attribute state vector string attribute state vector seq architecture state seq process clk resetn process resetn asynchronous reset active low state elsif clk event clk rising clock edge state nextstate process process state process nextstate state state process seq appendix vhdl templates forsyde processes im mealysy zipwithsy scanldsy clk reg resetn mapping 
hardware implementation mealysy vhdl template processes constructed mealysy illustrates mapping process mealysy hardware 
vhdl code template 
package mealysy lib type type mealysy defined type type type mealysy defined type type type mealysy state defined type state constant type mealysy state defined initial state function type mealysy state type mealysy state return type mealysy state function type mealysy state type mealysy state return type mealysy package body mealysy lib function type mealysy state type mealysy state return type mealysy state return defined definition 
vhdl templates sequential process constructors function type mealysy state type mealysy state return type mealysy return defined definition mealysy lib library ieee ieee std logic mealysy lib library synopsys synopsys attributes entity mealysy port type mealysy type mealysy clk std logic resetn std logic mealysy architecture seq mealysy signal state nextstate type mealysy state attribute state vector string attribute state vector seq architecture state seq process clk resetn process resetn asynchronous reset active low state elsif clk event clk rising clock edge state nextstate process process state process nextstate state process appendix vhdl templates forsyde processes state seq vhdl templates domain interfaces vhdl template processes constructed downdi downdi clk resetn fsm 
hardware implementation downdi process downdi implemented counter counts 
counter value input value send output 
practice means output clock divided vhdl template 
package downdi lib type type downdi defined type downdi lib library ieee ieee std logic downdi lib entity downdi port type downdi clk std logic resetn std logic type downdi downdi architecture seq downdi signal div clk std logic signal cnt integer range 
vhdl templates domain interfaces constant integer seq process clk resetn process resetn cnt rising edge clk case cnt cnt div clk cnt cnt div clk case process process div clk process rising edge div clk process seq vhdl template processes constructed updi updi clk resetn fsm value 
hardware implementation updi process updi implemented counter counts 
counter value output value true output value value gets input value 
output value absent value false 
clock clk frequency times higher corresponding input frequency determines clock output signal 
appendix vhdl templates forsyde processes vhdl template 
package updi lib type type updi defined type value type type updi record value type updi boolean record type type updi type updi updi lib library ieee ieee std logic updi lib entity updi port type updi type updi clk std logic resetn std logic updi architecture seq updi constant integer signal cnt integer range seq process clk resetn process resetn asynchronous reset active low cnt elsif clk event clk rising clock edge case cnt cnt cnt cnt case process process clk cnt process value case cnt 
vhdl templates domain interfaces true false case process seq vhdl template processes constructed sdi im sdi clk resetn fsm 
hardware implementation sdi process sdi implemented fsm counter counts counter state input value forwarded output 
clock clk determines output frequency times faster frequency input signal 
vhdl template 
package par lib type type par defined type par lib library ieee ieee std logic par lib entity par port type par type par type par clk std logic reset std logic par appendix vhdl templates forsyde processes architecture seq par signal cnt integer range seq process clk reset process reset asynchronous reset active low cnt elsif clk event clk rising clock edge case cnt cnt cnt null case process process cnt process case cnt null case process seq vhdl template processes constructed pdi pdi clk resetn fsm fsm 
hardware implementation pdi value value process pdi implemented fsms 
fsm directs output round robin style second fsm clock division guarantee outputs synchronized output clock 
reset state output values absent 

vhdl templates domain interfaces vhdl template 
package ser lib subtype type ser defined type type ser record value type ser boolean record ser lib library ieee ieee std logic ser lib entity ser port type ser type ser type ser clk std logic resetn std logic ser architecture seq ser signal cnt integer range signal cnt integer range signal type ser seq process clk resetn process resetn asynchronous reset active low cnt elsif clk event clk rising clock edge case cnt cnt cnt cnt null case process process cnt process appendix vhdl templates forsyde processes true true case cnt value false false value value null case process process clk resetn process resetn asynchronous reset active low cnt elsif clk event clk rising clock edge case cnt cnt cnt null case process process cnt process case cnt null case process seq 
