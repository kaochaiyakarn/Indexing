flux oskit substrate kernel language research bryan ford back greg benson jay lepreau albert lin olin shivers university utah university california davis massachusetts institute technology implementing new operating systems tedious costly impractical large projects 
flux oskit addresses problem novel way providing clean documented os components designed reused wide variety environments defining new os structure 
oskit uses unconventional techniques maximize usefulness intentionally exposing implementation details platform specific facilities 
oskit demonstrates technique allows unmodified code existing mature operating systems incorporated quickly updated regularly wrapping small amount carefully designed glue code isolate dependencies export defined interfaces 
oskit uses technique incorporate lines stable code including device drivers file systems network protocols 
experience demonstrates approach component software structure reuse surprisingly large impact os implementation domain 
real world examples show oskit research development operating systems programming languages 
operating system functionality continues expand diversify increasingly impractical small group implement basic useful os core functionality traditionally unix kernel entirely scratch 
furthermore generally specific areas os core interesting research purposes 
exam ford back lepreau univ utah lepreau cs utah edu benson davis benson cs ucdavis edu shivers lin mit shivers lin ai mit edu 
appears proceedings th acm symposium operating systems principles october saint malo france 
research supported part defense advanced research projects agency monitored dept army contract number dabt rome laboratory national science foundation ccr 
copyright association computing machinery permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists requires prior specific permission fee 
request permissions publications dept acm fax permissions acm org 
ple realistic os order useful research include largely uninteresting elements boot loader code kernel startup code various device drivers kernel printf malloc code kernel debugger 
necessity writing kind infrastructure slows larger os research projects greatly increases cost entry os research small useful experiments simply viable 
possible adapt existing systems generally complicated interdependencies 
oskit developed flux research group university utah addresses problem providing framework set modularized library code straightforward documented interfaces construction operating system kernels servers core os functionality 
oskit provides functionality simple bootstrapping minimal posix environment usable kernels memory management suited physical memory constraints extensive debugging support higher level subsystems protocol stacks file systems 
os kit gives developer immediate starting point investigating real os issues scheduling virtual memory ipc file systems security 
developers easily replace generic oskit modules functions guided research interests performance considerations 
os kit bootstrap unconventional operating systems quickly embedded systems network computers 
oskit heavily os kernels ongoing development different institutions 
microkernel os fluke puts os kit 
half fluke kernel oskit code servers user level utilities run top kernel rely heavily parts oskit 
oskit enhanced accelerated os research allowing quickly create prototype kernels order explore ideas investing effort necessary incorporate ideas larger primary development system 
research groups mit davis represented authors adopted oskit systems level language research 
traditional kernels distance language hardware microkernels extensible kernels enforce default policy conflicts particular language semantics 
oskit provides valuable tool allow advanced languages evaluated experimented low level ex novel os structures enabled languages possible obtain accurate performance measurements interference full scale os 
implementing standard ml directly hardware oskit able model hardware resources constructs functional programming language 
port sr synchronizing resources parallel language intended systems level programming extensively purpose allows investigate effectiveness communication oriented language implementing os functionality 
java virtual machine running oskit prototyped small network computer supporting java web server applications active network router dynamically executes java bytecode embedded network packets 
rest describes oskit reports experience research operating systems advanced language systems 
section discusses related 
section outlines major oskit components section details oskit design implementation 
section describes example network oriented applications 
section presents experience oskit case studies 
sections status 
related os research projects taken code existing stable systems reduce startup cost os research mach device drivers bsd hardware vendors port spin uses device drivers freebsd vino takes device drivers bootstrap code low level support virtual memory netbsd 
approach certainly saves time developer manually take apart old os relevant inter module dependencies requirements find way emulate requirements new os environment change code appropriately adapt new environment 
oskit allows developer save time providing common components convenient form separated documented 
research projects exokernel spin vino focus creating extensible systems allow applications modify behavior core os suit particular needs 
systems define particular fixed set core functionality set policies core extended 
exokernel authors state mechanism policy albeit layer indirection 
oskit contrast attempt useful os define particular set core functionality merely provides suite components real os built 
real time embedded operating systems qnx vxworks designed set modular components statically dynamically linked small core kernel various configurations 
systems apparently provide relatively kernel environment single posix application java virtual machine industry constructed java system vxworks 
main purpose embedded systems modularity allow small tightly constrained hardware environments workstations pcs 
optional components rely basic os environment provided core kernel designed intention making usable environments sufficiently documented practical users systems 
example vxworks execution environment runs special exception thread vxworks terminology task purpose field messages threads providing safe execution environment execute cleanup code 
vxworks components require thread presence easily environments 
object oriented operating systems created choices provides full operating system system provides os services underlying microkernel 
oskit systems attempt provide extensible os structure built customizable replaceable components 
operating systems define basic core os structure framework os components extended attempt allow components easily separated widely different os environments 
object oriented operating systems comparable basic design goals extensible scalable systems described 
overview oskit components section provide brief overview important oskit components 
illustrates structure oskit relationships components 
bootstrapping operating systems come boot loading mechanisms largely incompatible systems 
diversity existing mechanisms caused fundamental difference bootstrap services required os merely ad hoc way boot loaders typically constructed 
boot loaders basically uninteresting research standpoint os developers generally just produce minimal quick dirty design results boot loader unsuitable os due slight native oskit code encapsulated legacy code freebsd networking netbsd file system glue glue generic device driver support linux executable loading file system reader freebsd drivers drivers linux glue freebsd glue generic device driver support disk partitioning hardware client operating system language run time system address map manager minimal library malloc debugging list memory manager freebsd math library kernel support smp structure oskit 
shaded components indicate shelf code encapsulated oskit glue code 
shows approximate relationships components sizes regions correspond sizes components 
differences design philosophy requirements 
solve problem oskit directly supports standard cooperatively designed members os projects provide simple general interface boot loaders os kernels allowing compliant boot loader load compliant os 
oskit easy create os kernels support variety existing boot loaders adhere standard 
addition oskit includes tools allow kernels loaded older bsd linux boot loaders ms dos 
key feature standard highly useful research systems ability boot loader load additional files boot modules kernel 
boot module simply arbitrary flat file boot loader interpret way merely loads chunks reserved physical memory kernel image 
starting kernel boot loader provides kernel list physical addresses sizes boot modules loaded arbitrary user defined string associated boot module 
boot modules associated user defined strings interpreted kernel sees fit typically purpose ease kernel bootstrapping burden providing arbitrary data kernel need get started initialization programs device drivers file system servers 
kernel support library primary purpose oskit kernel support library provide easy access raw hardware facilities adding overhead obscuring underlying abstractions 
contains large collection useful functions symbol definitions highly specific supervisor mode code 
contrast libraries oskit useful user mode code designed primarily kernels mind 
rest oskit kernel support code necessarily architecture specific attempt hide machine specific details useful client os 
instance kernel support library includes functions create manipulate page tables segment registers 
oskit components provide higher level architecture neutral facilities built low level mechanisms architecture specific interfaces remain accessible order provide maximum flexibility 
oskit kernel support library especially important architecture os level programming environment particularly complex obscure 
kernel support library takes care setting basic bit execution environment processors normally start bit mode compatibility ms dos initializing segmentation page translation tables installing interrupt vector table providing default trap interrupt handlers 
naturally client os modify override behavior default kernel support library automatically necessary get processor convenient execution environment interrupts traps debugging standard facilities expected 
library default automatically locates boot modules loaded kernel reserves physical memory located application easily 
client os need provide main function standard style set kernel support library call arguments environment variables passed boot loader 
oskit hello world kernel simple ordinary hello world application memory management library memory management code typically user space malloc implementation standard library generally suitable kernels special requirements hardware run 
device drivers need allocate memory specific types specific alignment properties mb physical memory pcs accessible built dma controller 
address memory management issues oskit includes pair simple flexible memory management libraries 
list memory manager provides powerful efficient primitives managing allocation physical virtual memory kernel user level code includes support managing multiple types memory pool allocations various type size alignment constraints 
address map manager amm designed manage address spaces don necessarily map directly physical virtual memory provides similar support aspects os implementation management processes address spaces paging partitions free block maps ipc namespaces 
libraries easily user space designed specifically satisfy needs os kernels 
minimal library mature os kernels typically contain considerable amount code simply basic library functionality printf malloc 
done real library implementations functions optimized maximum performance functionality rich user space environment provided full function os assumptions usable kernel environment 
example standard printf usually relies full stdio package complexities manages mapping file handles file descriptors dynamically allocates buffer memory 
contrast oskit provides minimal library designed principle minimizing dependencies maximizing functionality performance 
example locales floating point supported standard calls don buffering relying directly underlying read write operations 
dependencies library functions minimized dependencies exist documented individual functions replaced necessary order adapt minimal library arbitrary environments 
debugging support oskit important practical benefits appropriate hardware setup immediately provides os developer full source level kernel debugging environment 
oskit kernel support library includes serial line stub gnu debugger gdb 
stub small module handles traps client os environment communicates serial line gdb running machine gdb standard remote debugging protocol 
oskit gdb stub client os performs trap handling supports multithreaded debugging client os provides appropriate hooks 
plan integrate local debugger oskit separate machine running gdb available 
addition basic debugging support oskit provides memory allocation debugging library tracks memory allocations detects common errors buffer overruns freeing freed memory 
library provides similar functionality popular application debugging runs minimal kernel environment provided oskit 
device driver support expensive tasks os development maintenance supporting wide variety available hardware 
devices tricky undocumented glitches new hardware constantly released incompatible software interfaces 
reasons os kit leverages extensive set stable tested drivers developed existing kernels linux bsd 
avoid divergence existing source bases allow new improved drivers easily integrated os kit existing driver code incorporated oskit largely unmodified encapsulation technique described section 
existing drivers surrounded thin layer oskit glue code allows environments completely different drivers originally written 
currently ethernet scsi ide disk device drivers linux included character device drivers imported freebsd way supporting standard pc console serial port various multi serial port boards 
oskit careful packaging drivers freebsd drivers alongside linux drivers problem 
expect incorporate drivers sources possibly popular commercial operating systems hardware vendor supplied drivers available 
protocol stacks oskit provides full tcp ip network protocol stack device drivers networking code incorporated encapsulation easily kept date 
oskit currently takes network device drivers linux largest source freely available drivers pc platform oskit network components drawn freebsd system generally considered mature network protocols 
demonstrates secondary advantage encapsulation package existing software flexible components approach possible pick best components different sources case linux network drivers bsd networking 
file systems complete picture oskit incorporates standard disk file system code encapsulation time netbsd file systems 
netbsd chosen case primary source base file system code cleanly separated available systems freebsd linux file systems tightly coupled virtual memory systems 
currently incorporating linux file systems support diverse file system formats windows os system development highly secure file server oskit file system provided interesting experience component 
oskit file system exported com interfaces similar internal vfs interface unix file systems 
interfaces sufficiently fine granularity able leave untouched internals oskit file system 
example oskit interface accepts single pathname components allowing security wrapping code appropriate permission checking 
fileserver exports interface accepting full pathnames providing efficiency matters processes 
avoiding modification main file system code greatly reduces maintenance burden allowing easily track netbsd releases 
oskit design implementation order oskit flexible wide variety diverse environments necessary adopt different set design rules normally building kernels 
involves applying known accepted software engineering principles unconventional ways 
section describes oskit design implementation philosophy rationale provides specific examples applied 
library structure important goal oskit convenient possible developer 
goal ramifications oskit design manifestation basic layout usage pattern oskit 
oskit structured package automatically built installed cases easily ordinary gnu style application 
self sufficient depend existing libraries header files installed system things user provide compiler linker development tools 
building installing oskit causes set libraries created user defined location usr local lib usr local include linked operating systems just ordinary libraries linked user level applications 
oskit structured way developers familiar libraries know common practice link libraries kernel simply libraries designed usable kernels 
set libraries designed purpose easier developer link library drop set files compiler options compile header files need developers define source tree layout build environment required integrate sources predefined existing structure 
modularity versus separability modularity standard software design goal oskit gains new level importance 
primary goal oskit allow developers arbitrary components situation forced parts oskit means oskit components modular fully separable 
example client able oskit device drivers having oskit memory manager device drivers necessarily require kind memory allocation service 
traditional kernel bsd may extremely clean modular separable extensive inter module dependencies difficult instance bsd device drivers bsd memory allocator bsd file system code bsd vfs layer 
provide full separability components oskit necessary introduce thin intermediate glue layers provide level indirection component services requires 
cases layers take form library functions trivial default implementations sole purpose overridden client os need arises 
cases layer indirection provided function pointers dispatch tables allow components dynamically bound client os run time 
method generally services generally implementation system putchar malloc method multiple implementations service coexist block interfaces different disk device drivers 
separability functions example method allocate memory device driver components oskit invoke client supplied function called mem alloc 
default implementation function provided uses oskit memory management library default easily overridden client os uses method managing physical memory 
way simple situations client just uses oskit defaults just works special action client part client os obtain full control memory allocation services needed 
separability dynamic binding example second method ensuring separability oskit file system components dependencies oskit device driver components file systems invoke block device drivers order access underlying disk file system resides 
client os initializes oskit device driver device driver returns pointer interface access device 
oskit interfaces described detail essentially just opaque objects dynamic dispatch tables similar virtual function tables 
initializing oskit file system component client os passes device driver interface pointer file system henceforth uses interface invoke driver services 
way client os bind run time file system device driver component needs know 
component granularity oskit libraries contain number logical components client os incorporates components referencing symbols defined libraries linker determines specific object files pull 
principle single standard definition exactly component 
attempting force components single fixed design methodology oskit gains degree flexibility essential success 
particular natural size granularity components vary widely different parts oskit tiny components strcpy large components consisting modules bsd file system 
cope large variations granularity corresponding variety implementation usage patterns 
oskit libraries roughly divided main categories function libraries component libraries 
function libraries oskit function libraries provide relatively simple low level services traditional language style 
designed fine grained control generally function function basis allowing client os particular library functions leaving individually overriding functions 
dependencies library functions minimized dependencies libraries dependencies inevitably exist defined explicitly exposed os developer 
instance oskit minimal library provides implementation known printf function standard services services designed differently traditional libraries 
standard module traditionally acts big black box implements broad set high level services top corresponding set low level services read write maintains private state implement buffering common features 
making single standard function application pulls various internal support routines dependencies facilities memory allocation terminal control standard services oskit minimal library hand minimize dependencies internal state perform buffering implementations documented client os exercise full control 
instance oskit default printf function implemented terms functions puts putchar default puts implemented terms putchar 
implementation bug standard library overriding function supposed affect behavior oskit minimal library extremely useful allows client os obtain basic formatted console output simply providing putchar function 
component libraries function libraries designed maximum fine grained flexibility controllability component libraries designed provide large chunks functionality shot quickly conveniently possible 
adopt coarse grained object oriented black box design philosophy relatively fewer public 
example oskit device driver component libraries device driver represented single function initialize register entire driver 
internal details driver hardware controls hidden client os generally interacts components common welldefined object oriented interfaces giving os developer plug play control system structure 
design increases large scale flexibility expense fine grained controllability particular oskit device driver os developer gives direct control piece hardware driver controlling gains ability drop different driver place changing 
clear cut criterion defining appropriate granularity particular components fact services may desirable alternative libraries available implemented different granularities 
example oskit minimal library serves needs kernels simple applications emphasizing simplicity flexibility functionality may integrate traditional library bsd library alternative oskit component situations complete functionality fine grained control needed application 
com interfaces usability critical oskit components clean defined interfaces designed coherent set global conventions principles 
provide standardization adopted subset component object model framework define oskit component interfaces 
lowest level com merely language independent protocol allowing software components address space rendezvous interact efficiently retaining sufficient separation developed evolved independently 
obvious advantages making oskit interfaces consistent widely component oriented applications com brings technical advantages described 
implementation hiding com founded notion interfaces comparable java interfaces define set methods invoked object providing direct access object internal state 
com interfaces defined independently components implement ensuring implementation interface remain separated practice different implementations particular com interface coexist single system 
represented language com interface opaque structure actual size content unknown client member pointer table function pointers similar virtual function table 
example shows slightly simplified essentially complete definition oskit interface implemented os kit disk device drivers components 
typedef struct struct ops ops struct ops error query io const struct guid iid void unsigned io unsigned release io unsigned io error read io void buf offset size amount size actual error write io const void buf offset size amount size actual error io size error io new size friendly macros define oskit read io buf ofs amount actual io ops read io buf ofs amount actual 
define iid guid aa df cf xb xc oskit com interface block ops structure dynamic dispatch table interface representing methods called 
lines define globally unique identifier guid identifying interface 
interface extension evolution object export number com interfaces interface represents particular view object independent function table methods invoked 
interfaces identified algorithmically generated dce universally unique identifiers new com interfaces defined independently essentially chance accidental collisions 
pointer com interface object dynamically queried pointers interfaces providing known languages safe narrowing mechanism allows objects implement new extended versions existing interfaces retaining compatibility clients understand original interface allows clients probe object safely take advantage extended interfaces available falling back base interface 
example os kit interface extension interface adds methods allow direct pointer access data stored object common case data happens local memory 
os kit raw unbuffered disk device drivers provide basic interface read write object translates disk read write object representing buffered disk device ram disk support extended interface provide efficient access clients take advantage extended interface 
required support code abstraction features com important purposes oskit interfaces completely standalone require common infrastructure support code client os order interfaces 
contrast example bsd linux kernel network stacks protocols modular interchangeable degree interfaces depends particular buffer management abstraction particular concrete implementation mbufs msgs respectively 
order bsd networking code incorporate design bsd mbuf code nontrivial best replace alternative buffer management implementation differs minor details 
oskit corresponding interfaces hand purely behavioral contracts modules rely particular common implementation infrastructure 
execution environment achieve full oskit component separability necessary define document interface implemented component interfaces component uses execution environment depends words component described front function libraries minimal library matter documenting function behavior dependencies instance documented environment printf function consists puts putchar functions 
larger components device drivers issues concurrency synchronization important requirements component defined carefully 
naturally complexity execution environment required component varies depending size complexity component addition factors cases oskit design attempts minimize complexity expected execution environment 
instance oskit require os provide notion interrupt priority levels bsd oskit incorporates bsd file system networking code multiple desired 
oskit documentation specifies basic execution models varying complexity ranging extremely simple concurrency model component assumptions environment complex model components aware control various concurrency issues blocking preemption interrupts 
oskit components conform documented execution models 
oskit environment invariably involve adaptation local requirements included documentation number recipes oskit components various common environments preemptive multiprocessor interrupt model kernels 
exposing implementation hiding implementation module generally considered software design practice take approach line kiczales open implementation philosophy 
oskit explicitly exposes implementation component part documented interface order provide maximum power flexibility client os 
instance oskit basic memory management library exposes number functions fairly specific particular implementation ability reserve particular regions physical memory walk examine free list 
client os obligated low level interfaces cases stick standard malloc interface availability low level interfaces important meeting needs particular kernels 
oskit employs open implementation philosophy coarse grained component libraries usually desirable hide implementation details 
case key point implementation details hidden explicitly requested forced client 
example oskit device drivers derived bsd linux export common set basic interfaces hide nature origin individual driver device driver export additional interfaces providing extended functionality 
fact com interface extension mechanism section provides ideal basis open implementation oskit 
encapsulation legacy code code oskit derived directly indirectly existing systems bsd linux mach 
small pieces code aren expected change original source base expected diverge widely original base anyway simply assimilated code oskit source tree modifying necessary maintaining part oskit 
large rapidly changing bodies code borrowed existing systems device drivers file systems network protocol stacks took approach cleanly encapsulating code new environment 
approach generalizes technique explored goel columbia utah linux device drivers unchanged mach kernel 
oskit defines set com interfaces client os invokes oskit services oskit components implement services thin layer glue code turn relies larger mass encapsulated code imported directly donor os largely entirely unmodified 
glue code translates calls public oskit interfaces interface calls imported code internal interfaces turn translates calls imported code low level services memory allocation interrupt management calls oskit equivalent public interfaces 
tricky implement design requires virtually modifications encapsulated code vastly simplifying task keeping code date new versions donor os 
course glue code updated deal major changes native environment emulated simpler updating imported code manually occurs frequently 
example oskit linux driver set tracked linux kernel versions starting linux encapsulation technique upgrades relatively straightforward continue easier emulation mechanisms refined 
sections describe particular techniques employed encapsulating legacy code oskit 
basic structure extremely useful preserve contents source files imported legacy systems directory structure reside 
instance encapsulated freebsd code located oskit subdirectory freebsd src directory exactly mirrors usr src tree actual freebsd distribution contains files oskit uses 
glue code encapsulates imported freebsd code located separate directories freebsd net freebsd dev keeping glue separated encapsulated code 
structure allows changes new release donor os incorporated simply applying appropriate patch appropriate oskit directory subtree fixing resulting conflicts 
course changes donor os extensive conflict resolution debugging process take time thought simpler quicker updating heavily modified restructured code 
conversions namespace management imported os code defines relies large number symbols create namespace management problems compile link time 
instance imported linux freebsd kernel header files define versions standard posix types size struct stat may may happen equivalent definitions oskit component interfaces 
mismatches types imported code public oskit interfaces differences stat structure handled performing conversions glue code surrounding encapsulated component 
means glue code include header files imported donor os header files defining oskit interfaces prevent symbol name conflicts symbols defined os kit headers prefixes oskit stat disambiguate symbols legacy code 
rule oskit interface definitions leaves cleaner namespace client os 
link time namespace presents problem legacy header files seen components client os global functions variables legacy code defines may conflict defined client os components 
example netbsd file system freebsd networking components functions names incompatible definitions surprising common heritage systems 
solve problem preprocessor magic rename symbols wakeup function freebsd device drivers named freebsd wakeup compiled object files comprising library preventing linker conflicts code 
exporting com interfaces implementation flexibility afforded oskit com interfaces critical exporting efficient interfaces legacy code 
example mentioned earlier bsd linux internal network packet buffer abstractions known respectively implementation details thoroughly known respective device driver networking code 
impractical change code base different packet buffer representation order bsd linux components interoperate client os code may different abstraction details hidden respective components 
com interfaces allow done copying unavoidable situations 
linux network driver receives packet hardware reads contiguous passes higher level networking code case oskit linux glue code 
glue code turn export packet component oskit common networking interfaces packets represented interfaces see section 
com interfaces essentially restrictions implementation details objects linux glue code export directly com object copying data merely adding interface linux structure 
com interface simply word field structure glue code places pointer function table providing methods access contents semantics functions defined interface functions implemented glue code full internal knowledge linux implementation 
leaves component external code manipulates interface 
packets submitted driver component transmission represented com interface linux glue code assume object really example packet may manufactured freebsd tcp ip code packets represented mbufs 
linux glue code easily recognize foreign objects checking function table pointer receives calls map method obtain direct pointer data buffer possible 
call succeed implementor object happens store requested range data contiguous local memory linux glue code creates fake pointing directly data 
glue code allocates normal calls interface read method copy data buffer 
way copying avoided possible presenting clean interface client os components 
blocking interrupts oskit encapsulated components currently come systems relatively simple wellunderstood blocking model encapsulated oskit components retain execution model seen client os 
model levels process level interrupt level process level threads control separate stacks run time context switches occur defined blocking points interrupt level activities run time interrupts enabled run completion blocking 
conventional kernels process interrupt abstractions oskit components generally relevant purposes defining concurrency model necessarily correspond real processes hardware interrupt handlers 
long client os ensures calls component follow constraints defined concurrency model component practically environment 
example encapsulated oskit components inherently multiprocessor thread safe easily multiprocessor multithreaded environments component wide lock just entering component releasing component returns blocking calls component back client os 
allows relatively coarse grained concurrency granularity sufficient situations clearly best heavily modifying imported code 
furthermore client os run different oskit components independently instance multiprocessor os place separate locks file system network components allowing execute concurrently 
medium grained concurrency possible clean separation independence oskit components harder achieve bsd linux file system networking code imported client os directly packaging done oskit 
hiding details legacy environments concurrency model client os oskit encapsulated components superficially similar models donor os environments oskit environment simpler limited ways making demands possible client os order components widely usable possible 
example mentioned oskit components generally assume client os notion process traditional sense 
imported legacy code generally code assumptions processes accesses current process structure directly bsd linux current pointer 
done reasons common cases permission checking blocking events 
avoid having large number changes required eliminate dependencies structured glue code emulate abstractions expected encapsulated code 
example emulate current process component outside glue code creates initializes minimal temporary process structure stack initializes global component wide pointer point 
structure represents current process far encapsulated code concerned duration call automatically disappears call completes essence glue code manufactures processes demand 
threads control may execute component blocking calls component back client os glue code intercept calls save pointer local thread stack duration order prevent getting concurrent activities 
way glue code emulates process abstraction expected legacy code completely hiding client os 
sleep wakeup related part donor os environment imported legacy code sleep wakeup mechanism example interrupt handler device driver uses wake blocked read write request completed 
naturally details sleep wakeup mechanism vary widely similarly structured kernels bsd linux 
glue code encapsulated component emulates native sleep wakeup mechanism donor os top single extremely simple underlying abstraction designed easy possible client os implement sleep record condition variable thread control wait time 
client os directly implement sleep records various ways conventional condition variables event objects client os uses internally synchronization 
fact oskit single threaded example kernels sleeping implemented simply busy loop spins bit field sleep record structure 
minimal sleep wakeup mechanism provided client os easiest way emulate elaborate mechanisms expected legacy os code incorporate actual sleep wakeup code legacy os modify slightly oskit sleep record abstraction place legacy os scheduler 
instance bsd sleep wakeup mechanism uses global hash table events event just arbitrary bit value wakeup called particular event processes waiting particular value woken 
encapsulated bsd oskit components retain bsd original event hash table management code hash table particular component entire system scheduling related fields emulated proc structure sleep record bsd glue code uses block current process necessary 
memory allocation tricky aspect legacy environment emulated memory allocation mechanism 
bsd kernel malloc package tries particularly clever number respects allocated blocks naturally aligned size byte blocks aligned byte boundary blocks size exactly power allocated efficiently wasting space allocator automatically keeps track sizes allocated blocks 
properties implemented easily takes special tricks provide parts bsd kernel mbuf code networking clist code character depend properties 
bsd kernel allocator provides properties reserving system startup special range kernel virtual memory allocator creating separate table entry page range 
entry records size blocks allocated page call free allocator quickly look size allocated block having reserve space memory block information conflict properties 
unfortunately solution acceptable oskit oskit components knowledge control virtual physical memory layout kernel user mode application run 
case appears entirely satisfactory solution involve heavy modifications imported legacy code adopted imperfect practical solution relies generally true heuristic assumption memory blocks returned client os fairly densely packed address space 
provide properties context bsd glue code uses bsd kernel malloc package unmodified layering top memory allocation facility client os provides glue code watches memory blocks returned client os dynamically re allocates grows allocation table necessary ensure covers addresses allocator seen naturally solution may inefficient cease unusual cases memory blocks returned client os widely dispersed component address space works fine situations far encountered 
physical memory access common problem legacy kernel code particularly device driver code assumptions access physical memory 
example linux device drivers assume physical memory direct mapped address space starting virtual address zero access memory mapped devices bios information simply manufacturing pointers directly physical addresses 
impossible particular drivers client os directly map physical memory way case appears solution fixing drivers 
fortunately freebsd drivers known symbolic constant accessing physical memory way constant simply changed variable initialized bsd glue code start point region mapped physical memory 
example oskit systems examples distributed oskit include test tcp ttcp benchmark measures tcp send receive bandwidth 
implemented second benchmark measure latency similar hbench lat tcp measures time required byte round trip 
examples demonstrate applications tie various oskit components gether measure unavoidable fairly small performance impact caused interactions components mismatches internal abstractions imported legacy code 
minimal library provided functions required examples 
ttcp relies times reported timing implemented simple timers kept freebsd derived networking code 
ttcp uses signal select currently provided oskit handle exceptional conditions implemented null functions affecting results 
aside additions initialization device drivers networking stack able compile applications unchanged 
required initialization code looks linux init ethernet probe oskit freebsd net init sf posix set sf device lookup ethernet iid dev oskit freebsd net open ether dev eif oskit freebsd net eif linux init ethernet initializes linux ethernet drivers causing supported drivers linked resulting application 
client os alternatively link specific drivers chooses 
probe locates devices driver initialized 
freebsd networking stack initialized oskit freebsd net init returns socket factory interface create new sockets posix set called register socket factory library socket function 
device lookup call searches device table constructed probe returning array handles ethernet devices 
device bound freebsd network stack oskit freebsd net open ether returns handle oskit freebsd net perform bsd style configuration network interface 
application library freebsd tcp ip linux ethernet hardware bsd socket interface oskit socket com interface ethernet oskit oskit com interfaces structure ttcp rtcp example kernels 
shows structure ttcp rtcp kernels compiled oskit libraries 
application uses familiar bsd socket functions 
os kit library maps functions directly methods linux receiver freebsd oskit sender linux freebsd oskit table tcp bandwidth mbit measured ttcp pentium pro mhz pcs connected mbps ethernet 
oskit socket com interface implemented freebsd networking component associating file descriptors com objects 
library socket call uses client provided socket factory interface create new sockets library code protocol stack provides socket socket factory interfaces 
client os binds freebsd protocol stack linux device driver initialization components exchange callback functions subsequently pass packets back forth asynchronously 
driver receives packet hardware driver calls protocol stack registered callback similarly protocol stack needs transmit packet calls device driver callback 
packets passed callbacks represented opaque objects implementing oskit com interface see section 
system configuration incoming packets initially represented internally inthe linux network driver code passed directly freebsd tcp ip component com objects freebsd glue code internally mbufs benefit imported freebsd code 
represents packets contiguous buffers freebsd glue code able obtain direct pointer packet data map method interface copy incoming data 
outgoing packets manufactured freebsd tcp ip code hand consist multiple buffers chained case mbuf chain passed linux driver object linux glue code read data contiguous buffer order encapsulated driver code 
mismatch linux bsd internal packet representations requires extra copying send path receive path 
tables compare tcp send receive bandwidth latency environments linux freebsd oskit freebsd protocol stack linux device drivers 
running tests applications top linux freebsd involves system call overhead oskit versions factor transmit receive loops ttcp rtcp moved kernel linux linux server freebsd oskit client linux freebsd oskit table tcp byte round trip time sec measured rtcp pentium pro mhz pcs connected mbps ethernet 
freebsd accessed special system call 
table presents bandwidth measurements obtained ttcp 
case ttcp transmitted blocks data bytes mb total 
reasonably long run test compensates relatively low ms granularity clock timing 
results show oskit implementation receives fast freebsd due fact linux driver hands contiguous buffers mapped mbuf clusters copying 
hand packet sent additional copy necessary non contiguous protocol mbufs copied contiguous device driver accounting decrease send performance 
table shows latency byte round trip 
interpret linux performance freebsd versus oskit results indicate oskit imposes significant overhead 
extra data copies part problem test involves small packet sizes fit single protocol mbuf enabling mapping device driver 
overhead largely attributable additional glue code oskit components price pay modularity separability ability existing driver networking code unmodified environment designed 
experience oskit oskit different research projects institutions world traditional os research systems level advanced programming language research designing systems programming language operating system 
language implementations usually take operating system interface hardware languages semantics differ markedly match ideal 
unix example tuned provide services required run time model protected flat address spaces stack allocation 
oskit time enables advanced language systems easily implemented directly raw hardware avoiding mismatches created traditional operating systems 
striking common finding various research projects remarkably easy implement experimental kernels advanced language systems raw hardware oskit substrate 
case studies section briefly describe major research projects taken advantage oskit experience oskit case section describe detail specific aspects oskit proved particularly useful research projects 
fluke os developed entirely new microkernel system called fluke explore numerous ideas fundamental kernel structuring including scheduling mechanisms execution models ipc virtual memory 
pursuing research mach microkernel directions explored effectively evaluated context existing system large inflexible tightly bound amenable fundamental changes needed 
started new system incorporating pieces mach bsd code written scratch 
ensure fluke quickly tightly bound inflexible predecessor started developing oskit concurrently set components fluke projects 
fluke acted primary driving application oskit oskit simultaneously purposes able prevent specific fluke 
fluke puts oskit fact half fluke microkernel oskit code 
basic servers utilities run fluke oskit provide standard library memory allocation address space management debugging facilities 
servers include virtual memory manager file network servers process manager 
fluke includes complete standard library freebsd library unix applications running fluke situations oskit minimal library provides functionality needed smaller simpler flexible 
standard ml standard ml functional programming language includes class higher order procedures static polymorphic type system exceptions continuations sophisticated module system 
built system called ml os porting standard ml new jersey sml nj implementation run pc os kit 
sml nj complex unix system comprising lines code source files 
run time model sml nj fairly exotic example system runs completely stack aggressive heap allocation garbage collection techniques manage procedure frames 
current research focus ml os effort modeling concurrency semantic features higher order programming languages particular continuations 
requires lan guage compiler intimately involved fundamental context switch code possible traditional operating systems 
mit ml os developed semester master student part time assistance undergraduate programmer 
student previously familiar os internals low level details architecture 
effort spent learning dealing details sml nj implementation far complex oskit code mated 
contrast experience strong groups advanced programming language researchers intending years implement sophisticated functional language directly raw hardware platform 
example fox project cmu page programming principles group bell labs different times begun efforts port sml nj run bare hardware 
details doing sufficiently forbidding prevent efforts completed 
sr sr language designed writing concurrent programs parallel distributed application systems software 
offers flexible concurrency model includes inherent parts language entities threads synchronization communication mechanisms 
standard sr implementation tightly coupled unix unix sockets described started previously developed version sr 
version removes unix dependencies isolates system dependent functionality threads synchronization network communication 
research goal porting sr raw hardware investigate effectiveness communication oriented language implementing os functionality 
implementing sr os oskit accomplished davis student visiting university utah 
initial implementation took approximately week adding network support kernel protocol stack required week 
contrast earlier attempts implement sr directly hardware proved difficult 
early version sr implemented directly pdp machines development debugging extremely tedious 
distributed operating system project sr implementation bare hardware considered abandoned due lack development tools 
java project create java environment raw hardware started kaffe freely available portable java virtual machine just time compiler 
kaffe written standard posix environment requiring support file calls open read bsd socket api 
implements user level thread system relies minimal signal handling facilities timer support 
implementation goals provide prototype java network computer called java pc active network router 
research goals explore resource management issues comparing java system bare hardware java system atop fluke microkernel 
building java pc atop oskit remarkably easy utah student time major contributor oskit took just hours get system run hello world java application large single threaded applications sun java compiler ran day 
weeks built usable system ran complex applications jigsaw web server making extensive threads timers file network resulting system similar function sun dramatically different implementation 
components system reuse existing components provided oskit sun primarily written anew java took longer build 
uses oskit early version oskit dos extender small os kernel runs ms dos creates complete process environment bit applications dos extender commercial products 
oskit small experimental kernels prototyped order test new ipc capability kernel execution environment concepts committing ideas main fluke kernel effort 
kernels developed matter days point useful measurement analysis prototypes feasible oskit 
experimental kernels oskit smaller utilities specialized kernels boot kernels network existing non boot loaders 
sites retrieved oskit informed 
researchers university carlos iii spain built distributed adaptable microkernel top oskit bits pieces microkernel developed finland 
network storage solutions oskit provide base hardware support network appliance style server 
wake successful language os projects discussed utah student ported gnu smalltalk system bare hardware 
implemented complete functional multithreaded smalltalk system just hours starting little experience operating systems pc oskit smalltalk run time system 
system serious research 
common experiences section describes specific aspects oskit proved particularly useful research projects oskit features caused problems commonly needed available 
posix environment language implementations greatly benefited fairly complete posix environment provided os kit minimal library memory allocator kernel support library 
environment allowed unix versions languages quickly ported bare hardware gradually specialized take advantage new environment extending control various hardware resources registers traps interrupts hidden normal operating system 
furthermore oskit minimal posix environment allowed language research focus issues critical research posix environment pick rest unimportant code remain unimportant 
bootstrap support particularly notable feature oskit minimal environment boot module support see section provides simple ram disk file system accessible immediately bootstrap posix standard open close read write interfaces 
example fluke boot module file system includes executable loaded run kernel subsequently acts root file system initial server requiring real file system device driver components embedded kernel 
ml os uses boot module hold precompiled initial heap image ml runtime kernel written ml similarly java pc loads java bytecode class files initial boot module file system 
alternatives available cases manually embedding data files linked kernel oskit device drivers file system components load data real disk file system boot module facility invariably proved far simple robust convenient purpose 
imposed process thread abstraction absence os defined process thread abstraction proved great benefit languages 
ml os provides continuation concurrent ml threads machine basic thread facility complete preemptive scheduler console timer events 
os thread systems usually center stacks cml threads entirely stacks running entirely heap 
interrupts thread context switches garbage collected continuations 
modeling concurrency way central line research building infrastructure imposed thread abstraction meant implement model directly 
similarly straightforward port built thread packages kaffe sr oskit 
contrasts experience porting kaffe kernel providing thread abstraction fluke microkernel 
fluke order avoid classic problems blocking needed native fluke threads kaffe built threads minor mismatches java fluke thread semantics caused fluke port kaffe take longer 
exposed implementation hardware ml port pleasant discover simple implement high performance functional programming language doesn bend backwards accommodate demands ill suited operating system 
sml nj sources complex sequences code designed limits unix architecture 
example sml nj allows heap allocation signal handlers run time system go arcane wishes modify processor register state unix signal handler 
involved considered sufficiently clever worth reporting literature 
case hardware exposed documented manner just 
unix 
java provided examples leveraging exposed implementation hardware 
kaffe relies delivery sigsegv signals detect null pointer accesses throw null pointer exception specified java semantics 
architecture provides efficient way catch accesses setting processor breakpoint registers appropriately 
allowing java pc direct access facility oskit provided simple way install custom trap handlers written ordinary fall back default handler traps interest 
modular separable components network computers seek minimize memory footprint need disk file system oskit proved trivial build version java pc included networking file system 
effort minimize memory footprint inherent modularity oskit keeps resulting system modest size static code data size executable kb including ethernet driver networking kb kaffe virtual machine native libraries kb various glue code 
note system contain implementation java windowing toolkit awt 
mature components flexible interfaces networking performance java pc sr os systems demonstrates value mature tuned components flexible interfaces 
weeks java pc project measurement program written java measured sustained tcp receive throughput mbps mbps ethernet hardware platform described section 
expected tcp send throughput lower mbps due extra copy 
relatively high performance surprising considering bsd network protocols tuned years 
contrast sun re implementation tcp ip java reported adequate web browsing inference probably near performance traditional implementations 
fully defined interfaces execution models simple defined execution models os kit components enabled fairly easily different environments originally designed 
example linux freebsd components designed traditional nonpreemptive uniprocessor kernel environment easily incorporated fully multithreaded java pc sr os environments surrounding small amounts locking glue code 
fluke kernel uses components exotic environment 
fluke configured interrupt model kernel kernel stack processor thread impossible run process model oskit components kernel stacks retained context switches 
easily able solve problem running process level activities components ordinary fluke threads running user mode kernel address space interrupt handlers components run supervisor mode 
oskit components fundamentally foreign environments possible assumptions surrounding environment minimized remaining assumptions precisely defined 
library structure sr os kernel protocol framework demonstrated value oskit simple structure set libraries independent client system 
kernel extremely complex build environment entirely different oskit got kernel working quickly sr os working completely build environment oskit independent previously installed package os kit functionality provided libraries just needed add appropriate parameters main makefile point main makefile oskit include directories 
oskit exported structure simple easy complicated environments 
tools debugging documentation mundane research perspective practical importance quality debugging tools documentation underestimated particularly important primary interest expertise lie operating systems 
oskit robust debugging support provided environment familiar application developers contrasting sharply meth ods early phases ml os project gdb support available debug inserting halt instructions kernel rebuilding rebooting observing kernel quietly lock success exhibit random behavior failure 
documentation provided oskit developers utah great help ml os hackers mit complete today 
ml project proceeded original intent linux puzzling code interfaces kernel internals 
informal form documentation line kernels utah mit answer questions 
tiny source complete kernels enabled features oskit working bootstrap kernel support posix environment boot modules component separability 
deficiencies research projects revealed deficiencies oskit addressed remain 
include java pc concern memory revealed size disadvantage technique components built encapsulated legacy code imported code designed memory footprint primary concern glue code encapsulating imported code adds additional overhead 
may import develop alternative implementations components designed minimal size generality 
profiling benchmark kernels described section revealed significant amount time spent memory allocation deallocation 
overhead attributable fact oskit default memory manager library designed flexibility space efficiency common case performance 
fast allocation small data structures type alignment restrictions conventional high level allocator appropriate possibly layered top oskit existing low level allocator 
oskit currently provide high level allocator kind expect integrate 
oskit application exits oskit simply reboots machine performing cleanup 
applications ttcp benchmark section assume network connections cleanly closed exit done unix processes 
oskit application currently just leaves peers hanging problem fixed version oskit minimal library 
released version oskit layout stack frames synchronous traps documented visible client os layout stack frames hardware interrupts 
deficiency caused problems ml os java pc needed access state interrupted code order handle preemption properly 
gained access state replacing oskit default interrupt handling mechanism doing inconvenient modified oskit hardware interrupt handler documented stack frame synchronous traps 
experience demonstrates instance oskit initially failed expose implementation details sufficiently fixed 
status table breakdown source sizes various oskit components 
oskit currently consists lines code 
lines native assimilated code interfaces provide access remaining lines entirely encapsulated imported code 
pages documentation provided documentation unix man page format module interface page forbidding sounds 
oskit currently runs pcs designed easily portable platforms thirds oskit exported interfaces architecture neutral 
heavily architecture specific aspects oskit isolated low level kernel support library bootstrap code 
public release oskit july alpha version months public update primarily adding initial device driver support 
months versions available inspection ftp logs shows excluding obvious mirror sites different external sites obtained oskit including companies 
currently released version oskit available www cs utah 
edu projects flux 
pleasantly surprised quickly develop os direct hardware language implementations oskit widespread disparate interest oskit research commercial communities 
oskit evolution entirely demand driven believe major reason success 
designed priori inevitably flawed vision needs constantly refined augmented driven demands wide variety real client systems 
ability oskit reuse components outside sources unchanged critical immediate long term interface implementation native encapsulated library description mi mi boot bootstrap support kern kernel support smp multiprocessor support lmm list memory manager amm address map manager minimal library malloc debugging disk partitioning file system reading exec program loading com com interfaces support device driver support linux dev linux drivers support freebsd common code freebsd dev freebsd drivers support freebsd net freebsd network stack freebsd freebsd math library netbsd fs netbsd file system windowing total table filtered source code size oskit components classified interface header files implementation assembly language source classified home grown assimilated code encapsulated imported code 
code broken machine independent mi machine dependent portions 
count source code lines filters comments blank lines preprocessor directives punctuation lines line containing just brace typically size unfiltered code 
windowing support currently progress 
success 
experience conclude research development operating systems languages greatly aided pragmatic systematic approach software structure reuse oskit exemplifies 
expect growing number oskit clients drive continued growth power flexibility 
especially grateful mike hibler minute writing help people university utah contributed oskit including steve mike hibler john bart robinson steve pat kevin van jeff turner 
goel important columbia utah linux device driver framework mach 
erich authored specification developed boot loader 
oskit clients feedback especially shepherd john ousterhout anonymous reviewers members flux project bob kessler ron olsson helpful comments 
grateful thousands contributed systems provided base components 
accetta baron bolosky golub rashid tevanian young 
mach new kernel foundation unix development 
proc 
summer usenix conf pages june 
andrews 
personal communication feb 
andrews olsson 
sr programming language concurrency practice 
benjamin cummings publishing redwood city california 
appel 
runtime system 
lisp symbolic computation nov 
appel 
compiling continuations 
cambridge university press cambridge ma 
appel macqueen 
standard ml new jersey 
third international symp 
programming language implementation logic programming pages 
springer verlag lncs aug 
baird smith 
jigsaw object oriented web server java 
www org pub www jigsaw 
ballesteros fernandez 
network hardware operating system 
proc 
sixth workshop hot topics operating systems cape cod ma may 
appear 
benson olsson 
portable run time system sr concurrent programming language 
proceedings workshop run time systems parallel processing 
ir department mathematics computer science vrije universiteit amsterdam netherlands april 
bershad savage pardyak sirer fiuczynski becker chambers eggers 
extensibility safety performance spin operating system 
proc 
th acm symp 
operating systems principles pages copper mountain dec 
brown seltzer 
operating system benchmarking wake lmbench case study performance netbsd intel architecture 
proc 
acm sigmetrics conf 
measurement modeling computer systems seattle wa june 
campbell islam 
designing implementing choices object oriented system 
communications acm sept 
computer consultants test tcp ttcp 
www com tools ttcp 
engler kaashoek toole jr exokernel operating system architecture application level resource management 
proc 
th acm symp 
operating systems principles pages copper mountain dec 
ford 
moss dos extender flux os toolkit 
available www cs utah edu projects flux moss 
ford 
standard 
available ftp flux cs utah edu flux 
ford hibler lepreau back 
microkernels meet recursive virtual machines 
proc 
second symp 
operating systems design implementation pages seattle wa oct 
usenix assoc 
goel duchamp 
linux device driver emulation mach 
proc 
annual usenix technical conf pages san diego ca jan 
gosling 
java language environment white 
technical report sun microsystems computer 
available java sun com doc language environment 

architectural overview qnx 
proc 
usenix workshop micro kernels kernel architectures pages seattle wa apr 
hutchinson peterson 
kernel architecture implementing protocols 
ieee transactions software engineering se jan 
kiczales 
black box open implementation 
ieee software jan 
kleiman 
vnodes architecture multiple file system types sun unix 
proc 
summer usenix conf pages atlanta ga june 

complete freebsd 
walnut creek cdrom books 
microsoft digital equipment 
component object model specification oct 
pp 
milner tofte harper 
definition standard ml 
mit press cambridge ma 
myers 
promise objects 
computer mar 
olsson 
personal communication feb 
reppy 
cml higher order concurrent language 
proc 
acm sigplan conf 
programming language design implementation pages june 
seltzer endo small smith 
dealing disaster surviving misbehaved kernel extensions 
proc 
second symp 
operating systems design implementation pages seattle wa oct 
usenix assoc 
sr programming language version dec 
www cs arizona edu sr 
stallman cygnus support 
debugging gdb gnu source level debugger 
free software foundation boston ma edition jan 
sun microsystems standalone java environment feb 
www javasoft com products white html 
wilkinson 
kaffe virtual machine run java code 
www demon uk kaffe kaffe htm 
wind river systems ca 
vxworks programmer guide 
