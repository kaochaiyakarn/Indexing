efficient computation frequent top elements data streams ahmed agrawal amr el abbadi propose approximate integrated approach solving problems finding popular elements finding frequent elements data stream coming large domain 
solution space efficient reports frequent top elements tight guarantees errors 
general data distributions topk algorithm returns elements roughly highest frequencies uses limited space calculating frequent elements 
realistic zipfian data space requirement proposed algorithm solving exact frequent elements problem decreases dramatically parameter distribution top queries analysis ensures top elements correct order reported 
experiments real synthetic data sets show space reductions loss accuracy 
having proved effectiveness proposed approach analysis experiments extend able answer continuous queries frequent top elements 
problems incremental reporting frequent top elements useful applications best knowledge solution proposed 
decade ago industry research communities realized benefit statistically analyzing vast amounts historical data discovering useful information 
data mining emerged active research field offered scalable data analysis techniques large volumes historical data 
data mining established key research area foundations applications domains including databases algorithms networking theory statistics 
new challenges emerged data acquisition technology evolved aggressively 
applications data generated rate high long term storage cost outweighs benefits 
streams data stored temporarily mined fast lost forever 
data mining community adapted devising novel ap supported part nsf eia nsf cnf 
part done author department computer science university california santa barbara agrawal amr cs ucsb edu proximate stream handling algorithms incrementally analyze arriving data pass answer approximate queries store summaries usage 
growing need develop new techniques cope high speed streams answer online queries 
currently data stream management systems monitoring click streams stock sensor readings telephone call records network packet traces auction bidding patterns traffic management network aware clustering security dos 
reviewed literature 
complying restricted environment motivated applications researchers started working novel algorithms analyzing data streams 
problems studied context include approximate frequency moments differences distinct values estimation bit counting duplicate detection approximate quantiles histograms wavelet aggregate queries correlated aggregate queries elements classification frequent elements top queries :10.1.1.123.5152:10.1.1.114.9563:10.1.1.131.3373:10.1.1.19.8594
earlier results data streams 
primarily motivated setting internet advertising 
internet continues grow internet advertising industry means reaching focused market segments 
main coordinators setting internet advertising positioned brokers internet publishers internet advertisers 
standard setting advertiser provides advertising commissioner advertisements agree commission action impression advertisement rendering surfer clicking advertisement bidding auction making sale 
publishers motivated commission paid advertisers contract commissioner display advertisements web sites 
time surfer visits publisher web page loading page surfer browser publisher web page script refers browser commissioner server loads advertisements logs advertisement impression 
surfer clicks advertisement publisher web page surfer referred servers commissioner logs click accounting purposes clicks surfer web site advertiser loads web page surfer browser 
commissioner earns commission advertisers pay ments publishers 
generally motivated show advertisements publishers web pages maximize publishers earnings 
achieve goal analyze traffic prevalent trends 
way optimize rendering advertisements show right advertisements right type surfers 
publishers prefer paid advertising load servers main types paying publishers pay impression pay click 
revenue generated pay impression advertisements proportional number times advertisements rendered 
hand rendering pay click advertisements generate revenue 
generate revenue number times surfers click 
average click pay click advertisement generates revenue rendering pay impression advertisements 
maximize revenue impressions clicks render pay click advertisement expected clicked 
chance display pay impression advertisement generate small guaranteed revenue 
know advertisements clicked commissioner know surfer advertisement displayed frequent 
identify surfers assign unique ids cookies set surfers browsers 
rendering advertisement surfer summarization clicks stream queried see surfer frequent 
surfer frequent probably click displayed advertisement 
profitable show pay impression advertisements 
hand surfer frequent profiles chance click advertisements shown 
case pay click advertisements displayed 
keeping mind limited number advertisements displayed web page choosing advertisements display entails retrieving top advertisements terms clicking 
scenario motivates solving famous problems simultaneously 
commissioner able query click stream frequent users top advertisements impression 
exact queries frequent top elements scalable handle problem 
commissioner unique monthly surfers publisher sites advertisers campaigns numerous advertisements 
storing unique ids assigned surfers requires gigabytes main memory ids bits 
size motivating problem poses challenges answering exact queries frequent top elements streams 
approximately solving queries require space solving queries exactly feasible 
traffic rate entails performing update query microseconds average sized commissioner re records hour 
existing approximate solutions frequent top elements relatively slow online decision making 
allow online decisions advertisements displayed propose commissioner keep cache frequent users top advertisements 
set frequent users top advertisements change impression depending user reacts advertisements displayed 
cache updated efficiently user response impression 
propose updating cache necessary 
cache serve materialization queries answer sets updated continuously 
problems approximately finding frequent top elements closely related best knowledge integrated solution proposed 
propose integrated online streaming algorithm solving problems finding top elements finding frequent elements data stream 
space saving algorithm reports frequent top elements tight guarantees errors 
general data distributions space saving answers topk queries returning elements roughly highest frequencies stream uses limited space calculating frequent elements 
realistic zipfian data space requirement exact frequent elements problem decreases dramatically parameter distribution top queries ensure top elements correct order reported 
aware algorithms solves exact problems finding frequent top elements constraints 
addition slightly modify baseline algorithm answer continuous queries frequent top elements 
answering queries continuously useful applications aware existing solution 
rest organized follows 
section highlights related 
section introduce space saving algorithm associated data structure followed discussion query processing section 
report results experimental evaluation section 
describe proposed scheme extended handle continuous queries frequent top elements section conclude section 
background related formally alphabet element ei element frequency number hits fi ina stream current size exceeds user specified support top elements elements highest frequencies 
exact solutions problems require complete knowledge frequencies elements impractical applications large alphabets :10.1.1.131.3373
relaxations original problems proposed 
term heavy hitters 
variations problems problem proposed ask elements top elements concealed guarantees rank remaining elements :10.1.1.131.3373
practical approximation top problem :10.1.1.131.3373
user asks list elements element ei list fi fk user defined error ek element kth rank 
reported elements frequency close kth element 
hot items problem special case frequent elements problem proposed asks elements frequency extends early done identifying majority element 
popular variation frequent elements problem finding deficient frequent elements asks elements frequencies element reported frequency :10.1.1.19.8594
algorithms proposed handle top frequent elements problems variations :10.1.1.131.3373
addition preliminary version published :10.1.1.114.9563
techniques classified counter techniques 
counter techniques counter techniques keep individual counter element monitored set subset counter monitored element ei updated time ei observed stream 
observed id monitored counter kept element disregarded algorithm dependent action taken 
sticky sampling algorithm slices rounds non decreasing length :10.1.1.19.8594
probability element added list counters monitored decreases round length increases 
rounds boundaries monitored element coin tossed success occurs 
counter decremented unsuccessful toss deleted reaches probability adding elements constant simpler famous lossy counting algorithm breaks equal rounds length proposed outputs list elements guarantee elements frequency round non monitored items added list :10.1.1.19.8594
round element ei estimated frequency deleted 
new item added round benefit doubt initial count set maximum possible estimation recorded new item 
algorithms simple intuitive zero counters rounds boundaries 
addition answering frequent elements query entails scanning counters reporting elements estimated frequency greater 
proposed frequent algorithm solve hot items problem 
frequent re discovery algorithm term hot items coined 
algorithm proposed independently 
frequent extends early done finding majority item counter 
algorithm monitors item stream 
observation counter incremented observed item monitored decremented 
counter reaches assigned observed element algorithm repeated 
algorithm terminates monitored element candidate majority element 
second pass required verify results 
frequent keeps counters monitor elements 
monitored element observed counter incremented counters decremented 
case counter reaches assigned observed element 
proposed lightweight data structure decrement counters operations 
sampling algorithm probabilistic inplace solves counters 
stream divided rounds increasing length 
round assigns empty counters distinct elements 
round deletes counters 
algorithm returns largest counters hope contain correct topk 
algorithm simple deleting half counters rounds boundaries distinct values deleted counters trades precision constant item processing counters accuracy 
general counter techniques fast item processing provable error bounds 
sketch techniques sketch techniques monitor subset elements provide stringent guarantees frequency estimation elements bit maps counters 
usually element hashed space counters family hash functions hashed counters updated hit element 
representative counters queried element frequency expected loss accuracy due hashing collisions 
probabilistic countsketch algorithm proposed solves problem :10.1.1.131.3373
space requirements countsketch decreases data skew increases 
algorithm keeps sketch structure approximate probability count element additive quantity function fk 
family hashing functions employed hashes id representative counters counters incremented decremented occurrence element stream 
approximate frequency element estimated finding median representative counters 
heap top elements kept estimated frequency observed element exceeds smallest estimated counter heap smallest element replaced observed element 
grouptest algorithm proposed answers queries hot items constant probability failure 
novel algorithm devised detect majority element keeping system global counter log counters 
elements ids assumed 
hit element handled updating global counter counters index corresponds binary representation time counters value half global counter correspond binary representation candidate majority element exists 
deterministic generalization hot elements keeps log counters elements ids mapped superimposed codes 
simpler generalized solution grouptest proposed keeps ln systems uses family universal hash functions select elements system 
queried algorithm discards systems hot items 
proposed elegant scheme suppressing false positives checking systems hot item belongs hot 
grouptest general accurate 
space complexity large offers information elements frequencies order 
multistage filters approach proposed independently proposed similar grouptest :10.1.1.110.5030
idea bloom filters multistage filters algorithm hashes element number counters updated time element observed stream 
element considered frequent smallest representative counters satisfies user required support 
algorithm judges element frequent updating counters :10.1.1.110.5030
counter estimated frequent added specialized set counters monitoring frequent elements flow memory 
decrease false positives proposes techniques reduce estimation errors counters :10.1.1.110.5030
element added flow memory counters monitored anymore multistage filters 
addition proposed incrementing counter minimum value :10.1.1.110.5030
algorithm employ error reduction techniques employed :10.1.1.110.5030
keeps number imaginary elements hits 
algorithm elements alphabet checked frequent estimation error elements estimated average number hits imaginary elements 
sketch techniques monitor elements 
affected ordering elements stream 
hand expensive counter techniques 
hit query entails calculations counters 
offer guarantees frequency estimation errors answer limited number query types 
summarizing data stream algorithms described section handle individual problems 
main difficulty devising integrated solution queries type serve preprocessing step type queries formation data distribution 
instance general data distribution frequent elements receiving total hits constitute top elements 
order frequent elements queries pre process stream top query frequent elements queries issued reach lower bound frequency th element order top queries pre process stream frequent elements query top queries issued reach upper bound number frequent elements 
offer integrated solution generalized problems accurately estimate frequencies significant elements store frequencies sorted structure 
devise generalized algorithm generalized problem 
integrated problem finding significant element intriguing 
addition applications advertising networks frequent elements top problems need solved integrated problem serves purpose exploratory data management 
user panoramic understanding application data issue meaningful queries 
times user issues queries top elements discovers returned elements insignificant frequencies 
query frequent elements specific threshold returns elements 
having algorithm solves integrated problem significant elements underlying data structure facilitates exploring data samples understanding prevalent properties 
space saving algorithm section propose counter space saving algorithm associated stream summary data structure 
underlying idea maintain partial information interest elements monitored 
counters updated way accurately estimates frequencies significant elements lightweight data structure utilized keep elements sorted estimated frequencies 
ideal situation significant element ei rank received fi hits accommodated th counter 
due errors estimating frequencies elements order elements data structure reflect exact ranks 
reason denote counter th position data structure counti 
counter counti estimates frequency fi 
th position data structure right element element th rank ei ei counti estimation fi 
algorithm straightforward 
monitored element observed corresponding counter incremented 
observed element monitored give benefit doubt replace em element currently estimated hits min new element occurred min times 
assign value significant elements interesting elements output meaningful queries top frequent elements 
algorithm space saving counters stream element ins monitored counti counter increment counter counti replacement step em element hits min replace em increment counter assign value min space saving algorithm min designed algorithm err positive side frequent element 
monitored element ei keep track maximum estimation resulting initialization counter inserted list 
starting monitor ei set counter value evicted 
keeping track overestimation error elements useful giving guarantees output algorithm clear section 
algorithm depicted 
general top elements non skewed data great significance 
concentrate skewed data sets minority elements frequent ones get majority hits 
basic intuition skewed property data assigning counters distinct elements keep monitoring fast growing elements 
frequent elements reside counters bigger values distorted ineffective hits infrequent elements replaced monitored counters 
numerous infrequent elements striving reside smaller counters values grow slower larger counters 
addition skew remains popular elements change time algorithm adapts automatically 
elements growing popular gradually pushed top list receive hits 
previously popular elements loses popularity receive hits 
relative position decline counters get incremented eventually get dropped list 
data skewed errors counters inversely proportional number counters shown 
keeping moderate number counters guarantees small errors proved illustrated experiments space saving efficient techniques terms space 
reason counters kept probable replace elements smaller estimation errors counters values 
implement algorithm need data structure cheaply increments counters violating order ensures constant time retrieval 
propose stream summary data structure purposes 
algorithm increment counter counter counti bucket counti bucket neighbor larger value detach counti child list counti finding right bucket counti bucket exist counti bucket attach counti bucket child list new bucket created create new bucket assign value counti attach counti child list insert cleaning child list empty detach stream summary delete increment counter algorithm stream summary stream summary stream summary example updates stream summary stream summary elements counter value linked linked list 
point parent bucket 
value parent bucket counters value elements 
bucket points exactly element child list buckets kept doubly linked list sorted values 
initially counters empty attached single parent bucket value 
elements stored hash table constant amortized access cost associative memory constant worst case access cost 
stream summary sequentially traversed sorted list buckets list sorted 
algorithm counting elements hits stream summary straightforward 
element counter updated bucket neighbor larger value checked 
value equal new value element element detached current list inserted child list neighbor 
new bucket correct value created attached bucket list right position element attached new bucket 
old bucket deleted points empty child list 
optimization worst case scenario costs pointer assignments heap operation 
increment counter algorithm sketched 
example assuming anda 
stream yield stream summary counters accommodate observed elements 
arrives new bucket created value andy gets attached shown 
arrives element minimum counter replaced count evicted 
final stream summary shown 
stream summary motivated done 
look value counter data structure proposed takes stream summary look ups online queries specific elements 
online queries specific elements crucial motivating application check element frequent 
looking frequencies specific elements constant time space saving efficient answering continuous queries shown section 
properties space saving algorithm prove space bounds section analyze properties space saving help establish space bounds 
strength simplicity algorithm keeps information space absolutely needed initialize counters batches counter algorithms 
characteristics key proving space saving properties proposed algorithm 
lemma length stream equal sum counters stream summary data structure 
counti proof 
hit increments counter counters 
true replacement happens observed hit previously monitored replaces counter em 
incremented 
time sum counters equal length stream observed far 
pivotal factor analysis value min 
value min highly dynamic dependent permutation elements give illustrative example 
andn 
yields min yields min 
useful quantify min want involve order hits received analysis analysis possible stream permutations intractable 
establish upper bound min 
assume number distinct elements counters occupied 
counts exact problem trivial 
lemma deduce 
lemma counters minimum counter value min greater 
proof lemma min counti min terms summation equation nonnegative counters smaller min min 
interested min represents upper bound estimation counter stream summary 
relation established lemma 
lemma element ei stream summary min fi fi counti fi min 
proof 
algorithm estimation ei non negative observed element benefit doubt 
estimation assigned value minimum counter time ei started observed 
value minimum counter monotonically increases time reaches current min monitored elements min 
element ei frequency fi min guaranteed monitored shown 
theorem element ei fi min stream summary 
proof 
proof contradiction 
assume ei stream summary 
evicted previously 
fi min minimum counter value previous time minimum counter value increases monotonically 
lemma ei evicted estimated frequency greater minimum counter value time 
contradicts space saving algorithm evicts element counter accommodate new element 
theorem lemma infer interesting general rule estimation elements counters 
element ei ei fi counter occupying th position stream summary 
count counter position stream summary upper bound position stream summary occupied 
theorem occupies th position stream summary counti counter position smaller fi frequency element rank ei 
proof 
possibilities position ei 
element ei monitored 
theorem fi min 
counter stream summary smaller fi 
element ei position lemma estimated frequency ei smaller fi 
greater estimated frequency ei smaller estimated frequency ei 
counti fi 
element ei position lemma counti fi fi 
element ei position element ex rank iis located position estimated frequency ex smaller frequency fx lemma estimated frequency ex smaller fi 
counti county equal estimated frequency ex 
counti fi 
cases counti fi 
theorem significant enables estimating upper bound rank element 
rank element ei guaranteed hits ei counter position thatis counti rank ei conversely rank element ei greater number elements having guaranteed hits counti 
rank ei count ej counti 
theorem helps establishing order preservation property top discussed 
section properties derive bound space requirements solving frequent elements top problems 
processing queries section discuss query processing stream summary data structure 
analyze space requirements general case data distribution assumed interesting zipfian case 
frequent elements order answer queries frequent elements sequentially traverse stream summary sorted list element frequency user support reached 
frequent elements reported frequent elements 
element ei frequent element guaranteed number hits counti exceeds minimum support 
reported element ei counti algorithm guarantees frequent elements reported 
guarantee conveyed boolean parameter guaranteed 
number counters specified user data properties required error rate available memory 
algorithm 
determine value guarantees user specified error rate 
general case analyze space requirements general case data distribution 
theorem assuming specific data distribution space saving uses number counters min find frequent elements error 
element ei frequency fi guaranteed reported 
algorithm counters support bool guaranteed true integer counti output ei counti guaranteed false return guaranteed reporting frequent elements proof 
theorem element ei fi min guaranteed stream summary upper bound min lemma follows min 
set min guarantees error rate 
theorem element frequency greater summary guaranteed reported 
bound theorem tight 
instance happen ids stream distinct 
addition theorem shows space consumption space saving constant factor lower bound space deterministic counter algorithm shown theorem 
theorem deterministic counter algorithm uses number counters min find frequent elements error 
proof 
proof similar :10.1.1.123.5152
streams arbitrary large multiple streams elements wherem elements occur times 
observing stream elements counter algorithm counters monitoring elements 
element difference 
ends element observed ends element occurred monitored algorithm 
deterministic algorithm handle element manner record previous hits 
algorithm estimated previous hits element algorithm error rate case 
hand algorithm esti mated previous hits element algorithm error rate case 
estimation results error cases number counters guarantee error rate zipf distribution analysis zipfian data set parameter fi ei rank fi converges small constant inversely proportional 
instance ln 
grows infinity 
assume ensure data skewed worth analyzing 
noted expect popular elements great importance data uniform weakly skewed 
analyze zipfian case need introduce new notation 
possible permutations maximum possible min denoted minmax elements hits minmax element hits denoted er 
deduce theorem lemma element ei fi minmax regardless ordering guaranteed monitored minmax ander bound space requirements processing zipfian data 
theorem assuming noiseless zipfian data parameter calculate frequent elements error rate space saving uses min counters 
regardless stream permutation 
proof 
equation lemma minmax fi ascertained minmax fi lemma substitute fr minmax 
rewriting frequencies zipfian form yields mated approxi simplified set satisfy stronger constraint fr minmax smaller error bound smaller value minmax larger larger 
chosen satisfy combining result relation established implies guarantee error bound 
upper bound enforced satisfying bound apply general case discussed previously theorem 
having established bounds space saving general zipf distributions compare bounds algorithms 
addition comment practical issues directly inferred theoretical bounds 
comparison similar bound theorem tighter guaranteed algorithms :10.1.1.110.5030:10.1.1.19.8594
sticky sampling space bound ln failure probability :10.1.1.19.8594
lossy counting bound ln :10.1.1.19.8594
algorithm multistage filters require number counters bounded ln ln furthermore space saving tighter bound grouptest bound ln ln saving :10.1.1.110.5030
example making assumptions data distribution space saving needs counters sticky sampling needs counters lossy counting needs counters multistage filters need counters grouptest needs counters 
frequent similar space bound space saving general case 
counters elements estimation error frequent bounded close theoretical estimation error bound proved :10.1.1.123.5152
straightforward feasible extension algorithm track estimation error counter current form algorithm support estimating missed hits element starting monitored 
addition observation non monitored element increases errors monitored elements counters get decremented 
elements higher frequency error prone difficult guess frequent elements case space saving 
structure proposed built queried way allow user specify error threshold 
algorithm parameter support increases number false positives dramatically clear experimental results section 
number counters grouptest depends failure probability support 
suffer single threshold drawback frequent 
output frequencies reveal relative order elements 
addition assumption ids enforced building indexed lookup table maps id unique number range 
practice grouptest needs space infeasible cases 
algorithm similar assumption alphabet 
addition scan entire alphabet domain identifying frequent elements 
true small portion ids observed stream 
contrast space saving requires ids fit memory 
zipfian case aware similar analysis 
numerical example data zipfian space saving need counters guarantee error algorithm counters integer bool order true bool guaranteed false integer min guar freq output ei counti min guar freq min guar freq counti counti counti order false min guar freq guaranteed true output ek counti min guar freq min guar freq counti counti min guar freq guaranteed true break output ei return guaranteed order top elements reporting top top elements algorithm output elements 
element ei top guaranteed number hits counti exceeds estimated number hits element position 
theorem upper bound fk hits element rank ek top elements 
call results guaranteed top simply inspecting results algorithm determine reported top elements correct 
space saving reports guaranteed top counti reported elements guaranteed top elements 
guaranteed top subsets reported iterating counters 
iteration elements guaranteed top elements minimum value far smaller counti algorithm guarantees top addition condition true number distinct elements stream similarly call top guaranteed order counti counti 
thatis addition having guaranteed top order elements top elements guaranteed hold guaranteed hits element top estimated hits element 
order guaranteed algorithm guarantees top algorithm 
algorithm consists loops 
loop outputs top candidates 
iteration order elements reported far checked 
order violated order set false 
loop top candidates checked guaranteed top checking candidates guaranteed hits exceed overestimated counter element 
hold second loop executed iterations total inspected elements guaranteed top algorithm implemented way outputs elements outputs elements closest possible regardless greater vice versa 
rest assume algorithm outputs elements second loop executed 
look space requirements algorithm 
general case guaranteed top case widely accepted space requirements solving exact problem assumptions data distribution :10.1.1.131.3373
general data distribution able solve exact problem restrict discussion relaxed version find list elements frequency fk :10.1.1.131.3373
deal skewed data section provide proven space bound guaranteed solution exact top problem zipfian data distribution 
theorem regardless data distribution solve problem space saving uses min counters 
element frequency fk fk guaranteed monitored 
proof 
form theorem min fk token set fk fk guaranteed 
zipf distribution analysis answer exact top queries zipf distribution automatically set fk fk 
space saving guarantees correctness order 
theorem assuming data noiseless zipfian parameter calculate exact top space saving uses min counters 
space complexity min ln 
regardless stream permutation 
order top elements preserved 
proof 
equation lemma lemma deduce maximum possible value min minmax frequent element guaranteed monitored er fi minmax simplification substituting fr minmax lemma follows fr fi rewriting frequencies zipfian form yields relation approximated simplifies guarantee slots occupied top sure difference fk fk minmax lemma minmax monitored elements 
condition minmax fk fk enforced 
minmax enforcing tighter condition fr set satisfy fr enforcing tighter condition combining ln space complexity reduces min ln ln 
converges small constant inversely proportional space complexity re duces min 
best knowledge look space bounds answering exact queries case zipfian data guaranteed results 
having established bounds space saving general zipf distributions compare bounds algorithms 
comparison similar relation essential satisfy manipulation lower bound reached guarantee top correctness ln complexity reduces min ln 
converges small constant inversely proportional complexity reduces min 
prove order preserving property 
data distribution zipfian fi fi fi fi 
minmax fk fk minmax fi fi 
minmax estimation errors effective change order top elements 
addition solving deficient frequent elements problem section theorem establish bound space needed exact solution frequent elements problem case zipfian data 
noise free zipfian data parameter space saving report elements satisfy user support small errors frequencies 
corollary assuming zipfian data parameter calculate exact frequent elements space saving uses min counters 
space complexity min ln ln 
regardless stream permutation 
proof 
assuming zipf distribution possible map query 
support known possible know rank frequent element satisfies support 
rank frequent element satisfies support 
theorem number needed elements calculate exact top 
substituting yields bounds tighter bounds guaranteed best known algorithm countsketch large range practical values parameters andk :10.1.1.131.3373
countsketch solves relaxed version problem failure probability space log 
fk fi large constant hidden big notation 
bound space saving relaxed problem fk witha failure probability 
instance assuming specific data distribution space saving requires counters countsketch needs counters entire stream 
addition space saving guarantees element ei fi fk belongs stream summary simply output random elements 
case non zipf distribution weakly skewed zipf distribution assume fi assumption justified 
assuming non skewed distribution top elements significant share stream case zipf frequent elements higher share distribution zipf 
assumption rewrite bound space saving ln bound rewritten log log :10.1.1.131.3373
depending data distribution space saving guarantee reported top subset correct weak data skew countsketch offer guarantees 
case zipf distribution bound log :10.1.1.131.3373
bound space saving 
space complexity ln space saving requires space cases skewed data long streams windows failure probability 
addition space saving preserves order top elements 
show difference space requirements consider example 
space saving space requirements counters countsketch needs counters 
algorithm give guarantees output 
top queries space saving specifies guaranteed elements top 
guarantee top elements guarantee top elements 
experimental results evaluate capabilities space saving conducted comprehensive set experiments real synthetic data 
tested performance space saving finding frequent top elements different parameter settings 
compared results best algorithms known far problems 
interested recall number correct elements percentage number correct elements precision number correct elements percentage entire output 
worth noting algorithm recall precision outputs exactly correct set elements 
superfluous output reduces precision failing identify correct elements reduces recall 
measured run time space algorithm indicators capability handle high speed streams reside servers limited memories 
notice included size hash tables algorithms fair comparisons 
frequent elements problem compared space saving grouptest frequent 
grouptest web site author 
top problem implemented probabilistic inplace countsketch :10.1.1.131.3373
countsketch implemented median algorithm hoare median partition linear run time average case :10.1.1.131.3373
maintaining heap suggested kept stream summary fixed length guarantees constant time update elements stream summary heap entail log operations :10.1.1.131.3373
difference space usage heap stream summary size negligible compared space countsketch 
hidden constant space bounds ran countsketch times estimated factor enable countsketch give results comparable space saving terms precision recall :10.1.1.131.3373
probabilistic algorithms grouptest countsketch set probability failure typical value 
algorithms compiled compiler run pentium iv ghz pc gb ram gb hard disk 
synthetic data generated synthetic zipfian data sets zipf parameter varying slightly uniform highly skewed fixed size data set hits alphabet size conducted sets experiments 
set varied zipf parameter measured algorithms performances change set queries 
second set experiments data set realistic skew compared algorithms results varied queries parameters 
varying data skew set experiments varied zipf parameter measured algorithms performances change set queries 
set experiments measure algorithms adapt data skew 
frequent elements problem query issued space saving grouptest find elements frequency space saving assigned counters guarantee correct results corollary 
zipf parameter assign number counters case zipf parameter 
results comparing recall precision time space algorithms summarized 
frequent ran times faster space saving constant recall reported figures results competitive terms precision 
possible specify parameter algorithm precision low runs 
zipf parameter algorithm reported elements elements satisfying support 
rest experiments precision achieved frequent ranged 
space ranged tenth times space space saving shown 
interesting note data skewed space advantage space saving increased frequent able exploit data skew reduce space requirements 
frequent output exactly elements experiment 
case decrements lowest counter element sharing counter potentially deleted reaches 
ratio run time space saving grouptest changed zipf parameter data highly skewed 
zipf parameter frequent elements algorithms identified 
report fact algorithms having precision recall respectively 
zipf parameter difference precision algorithms grouptest able prune false positives due weak data skew 
values zipf parameter larger precisions algorithms constant reported 
recalls algorithms constant values zipf parameter clear 
advantage space saving evident shows space saving achieved reduction space factor ranging zipf parameter zipf parameter run time recall run time fe synthetic data space saving grouptest frequent zipf alpha recall fe synthetic data space saving grouptest frequent zipf alpha precision space mb precision fe synthetic data space saving grouptest frequent zipf alpha space fe synthetic data space saving grouptest frequent zipf alpha performance comparison frequent elements problem synthetic zipfian data varying data skew 
shows space saving adapts data skew 
top problem space saving countsketch probabilistic inplace identify top elements 
space saving monitored elements guarantee top elements correct reported right order illustrated theorem 
number counters monitored case 
space saving inplace allowed number counters 
able probabilistic inplace produce results comparable quality results space saving 
probabilistic inplace counters outputs elements recall unsatisfactory 
allowed large number counters recall increases due tighter estimation precision drops dramatically lot superfluous elements output 
allowed run number counters space saving time precision recall measured 
results summarized 
output probabilistic inplace comparable algorithms terms precision 
contrary recall probabilistic inplace constant entire range 
run time space usages probabilistic inplace space saving comparable 
notice run time probabilistic inplace longer space saving due unnecessary deletions boundaries rounds 
hidden factor indicated earlier countsketch failed attain recall precision experiments countsketch precision recall varying clear figures 
space reductions space saving clear skewed data 
ratio space space saving countsketch ranged data weakly skewed data highly skewed 
space saving takes advantage skew data minimize number counters needs keep proved bound space countsketch fixed :10.1.1.131.3373
reductions space saving time compared countsketch significant 
space saving run time constant times smaller data skewed times smaller data skewed 
run time countsketch decreased increased number times countsketch estimate frequency element decreased bottleneck countsketch 
run time space saving dropped faster data skewed gap significant buckets values increased grew elements top share bucket 
reduced number operations increment top elements 
easily see running ghz machine enables countsketch handle streams rate countsketch saving precision equal recall query exactly elements output 
run time recall run time top synthetic data space saving countsketch probabilistic inplace zipf alpha recall top synthetic data space saving countsketch probabilistic inplace zipf alpha precision space mb precision top synthetic data space saving countsketch probabilistic inplace zipf alpha space top synthetic data space saving countsketch probabilistic inplace zipf alpha performance comparison top problem synthetic zipfian data varying data skew higher hits ms data uniform countsketch took ms average process observation stream 
varying query parameters set experiments measure algorithms perform different realistic query parameters keeping data skew parameter constant realistic value 
data set zipf parameter purpose 
frequent elements problem query issued space saving grouptest find elements frequency 
support varied 
results summarized 
frequent able attain recall queries issued 
frequent run time times faster space saving 
addition space usage frequent dropped space saving clear 
frequent precision ranging indicated significant drawback algorithm 
due inability prune false positives 
grouptest space saving able attain value recall values support clear 
precision grouptest dropped shows space saving space ranging times grouptest twice fast shown 
see space saving combined lightweight advantage frequent precision advantage grouptest 
top problem space saving countsketch probabilistic inplace identify top elements stream parameter varied results shown 
probabilistic inplace run time space usage close space saving illustrated figures 
probabilistic inplace able attain recall set experiments clear 
low precision shown 
highest precision algorithm impractical real life applications 
space saving precision recall entire range clear figures 
countsketch recall precision values ranging top top top top satisfactory real life applications 
figures show space saving run time times countsketch space saving space times smaller 
space saving combined lightweight property probabilistic inplace better precision countsketch 
run time recall run time fe zipf data space saving grouptest frequent support recall fe zipf data space saving grouptest frequent support precision space mb precision fe zipf data space saving grouptest frequent support space fe zipf data space saving grouptest frequent support performance comparison frequent elements problem synthetic zipf data varying support real data real data experiments click stream anonymous com 
stream size hits alphabet size 
data fairly skewed difficult estimate zipf parameter 
sum counts frequent elements small compared length stream 
instance frequent element top top top elements occurred times respectively 
difficult estimate apriori calculate bound number counters 
set experiments provide simulation behavior space saving running limited space 
fix space available experiments size function query parameters examined space saving behaves restricted conditions 
surprisingly restricted space space saving achieved substantial gains run time space hardly loss precision recall 
results similar synthetic data experiments query parameters varied 
start comparing algorithms behavior varying query parameters comment space saving guarantees output 
varying query parameters set experiments measure algorithms perform different realistic query parameters 
frequent elements problem frequent elements algorithms find elements minimum frequency 
parameter varied number elements monitored space saving fixed results summarized run time frequent consistently faster space saving saving clear 
excessive number false positives reported frequent precision ranged indicated 
grouptest ids alphabet mapped range able compare space saving account mapping lookup table part grouptest space requirements 
despite restricted space condition imposed space saving algorithm able attain value precision recall support levels clear figures 
grouptest precision ranging 
hand space saving space times grouptest ran faster time shown 
top problem space saving countsketch probabilistic inplace identify top elements stream 
parameter varied number elements monitored space saving probabilistic inplace fixed results shown 
run time recall run time top zipf data space saving countsketch probabilistic inplace recall top zipf data space saving countsketch probabilistic inplace precision space mb precision top zipf data space saving countsketch probabilistic inplace space top zipf data space saving countsketch probabilistic inplace performance comparison top problem synthetic zipf data varying parameter probabilistic inplace recall shown figures precision clear comparable algorithms highest precision 
run time probabilistic inplace times tha space saving space usages comparable 
interestingly figures show space saving close recall precision 
average precision recall space saving countsketch respectively 
shows space saving run time times countsketch 
space saving space requirements times larger shown 
measuring guarantee space saving introduce new measure guarantee 
guarantee metric close precision measurable algorithms offer guarantees output 
guarantee number guaranteed correct elements percentage entire output 
percentage output correctness guaranteed 
instance algorithm outputs elements guarantees correct guarantee algorithm remaining elements correct 
guarantee specific answer set greater precision number correct necessarily guaranteed elements output 
context frequent elements problem guarantee space saving number elements guaranteed hits exceeds user support percentage entire output 
formally equal count ei counti count ei counti context topk problem guarantee space saving number elements guaranteed topk 
guaranteed hits exceed percentage top 
formally count ei counti worth noting set experiments synthetic data guarantee space saving 
thatis space saving guaranteed output correct 
possible estimate parameter real data set ran space saving restricted space experimental runs precision 
reason report guarantee precision space saving frequent elements top problems tables 
frequent elements problem frequent elements problem guarantee precision space saving constant clear table 
space saving outputs correct elements correct elements guarantees output correct 
top problem top problem guarantee space saving ranged precision space saving ranged clear table 
words space saving run time recall run time fe real data space saving grouptest frequent support recall fe real data space saving grouptest frequent support precision space mb precision fe real data space saving grouptest frequent support space fe real data space saving grouptest frequent support performance comparison frequent elements problem real click stream support number frequent size number guaranteed accuracy precision elements output frequent elements table space saving guarantee frequent elements problem real click stream able guarantee output correct 
experimental runs number non guaranteed elements 
answering continuous queries validating theoretical analysis experimental evaluation real synthetic data extend proposed algorithm answer continuous queries frequent top elements 
incremental reporting answer useful applications monitoring interesting elements aware proposed solution problem 
main goal incrementally report changes place answer set scanning monitored elements 
changes take place stream observation increment counter algorithm modified check changes answer set cache updated advertisement rendering 
extensions increment counter discussed 
continuous queries frequent elements incremental reporting frequent elements classified types reporting 
type reporting infrequent element frequent 
happen element receives hit frequency satisfy minimum support 
happen observed element 
second type updates reporting group frequent elements infrequent 
happen minimum support increased gets incremented 
elements may infrequent stream observation 
stream observation result types updates 
checking updates types effective running algorithms observation call increment counter 
subroutine called call increment counter clean step sketched 
maintain pointer ptr bucket minimum value satisfies support 
initially pointer points run time recall run time top real data space saving countsketch probabilistic inplace recall top real data space saving countsketch probabilistic inplace precision space mb precision top real data space saving countsketch probabilistic inplace space top real data space saving countsketch probabilistic inplace performance comparison top problem real click stream number size number guarantee precision top output top elements table space saving guarantee top problem real click stream algorithm counter counti incrementing stream size reporting elements infrequent bucket bucket ptr points bucket bucket neighbor larger value bucket report bucket child list infrequent move ptr bucket reporting ei frequent bucket new bucket counti bucket new bucket ptr points bucket bucket bucket ei element counti report ei frequent move ptr bucket incremental reporting frequent elements initial bucket stream summary 
call increment counter algorithm deleting empty bucket invoke continuous 
check bucket satisfies required support stream size incremented 
satisfy support elements child list bucket reported frequent elements infrequent ptr moved bucket neighbor bucket larger value 
observed element ei counter counti incremented check new bucket counti bucket moved infrequent bucket infrequent bucket frequent bucket frequent bucket need update set frequent elements 
new bucket counti satisfies old bucket ei reported infrequent element frequent 
case ptr moved point bucket new bucket counti sure bucket minimum value satisfies support 
algorithm checks condition making sure bucket value satisfies support value greater value bucket pointed ptr 
reporting element frequent reporting group elements infrequent elements infrequent 
takes updated elements update cache 
increment counter algorithm old bucket counti deleted child list empty 
algorithm called deleting old bucket counti 
ptr pointing deleted bucket efficient way know bucket bucket scanning buckets stream summary data structure constant time operation 
continuous queries top elements answering continuous queries top similar answering continuous queries frequent elements 
maintain pointer bucket belongs counter th position stream summary data structure 
top elements elements belong buckets values value 
elements belong buckets values 
instance buckets values elements elements elements belong reported top 
case elements needed report top report subset elements top 
rest elements value reported topk 
maintain set reported top 
initially set empty points initial bucket stream summary 
underlying idea keep track boundary elements lie boundary top non top elements 
elements move outside top inside top frequency increases 
element belong member entering top set elements receives hit 
elements belong change top received hits 
elements belong buckets effect top receive hits 
stream summary data structure needs modified slightly tell distinct elements observed stream 
modification helps transient start distinct elements observed top 
telling distinct elements observed stream easy problem 
keep counter incremented time element algorithm counter counti ei element counti case top reported distinct elements counti report ei top case ei kth element reported ei kth distinct element report ei top bucket bucket value move bucket insert bucket child list case general case elements reported top bucket points bucket neighbor larger value bucket new bucket counti bucket bucket ei delete ei select element delete report top report ei top empty move bucket insert bucket child list incremental reporting top deleted initial bucket stream summary inserted bucket value 
simplicity delete details algorithm assume oracle answer question 
receiving distinct elements new element reported top implies element longer top 
algorithm responsible task counter clean step sketched 
cases handle special cases distinct elements stream case algorithm checks number distinct elements observed strictly true ei observed element reported top occurrence ei 
case ei th distinct element reported number distinct elements changed tok observation ei 
addition reporting ei top moved bucket bucket value 
ei th distinct element top elements buckets values 
include elements belong bucket 
case general case 
case executed ei moves bucket neighbor larger value 
ei top belong top elements change needs deleted belong 
ei boundary element belong ei moving outside top inside top 
ei reported top 
addition element picked deleted reported non top element 
ei belongs deletion element leave empty 
case sure exactly elements buckets values 
top elements 
moved point bucket neighbor larger value initialized contain elements child list bucket elements time assume stored associative memory operation 
stored hash table amortized cost operation 
easy see amortized cost constant 
step inserting elements bucket cost amortized exactly element deleted time element moves bucket average element inserted deleted element moving bucket observation 
called deleting old bucket counti 
pointing deleted bucket constant time method know bucket bucket discussion devised integrated approach solving interesting family problems data streams 
stream summary data structure proposed utilized space saving algorithm guarantee strict bounds error rate approximate counts elements limited space 
showed space saving handle frequent elements topk queries efficiently estimates elements frequencies 
memory requirements analyzed special attention case skewed data 
introduced motivated problem answering continuous queries top frequent elements incremental reporting changes answer sets 
minor extensions applied set algorithms answer continuous queries 
conducted extensive experiments synthetic real data sets validate benefit proposed algorithm 
algorithm best knowledge guarantees correctness frequent elements correctness order top elements data skewed 
practice alphabet large case ip addresses subset alphabet observed stream addresses 
space bounds function number distinct elements occurred stream 
analysis assumed entire alphabet observed stream worst case space saving 
space bounds tighter algorithms 
main practical strengths space saving space available estimate elements frequencies provide guarantees results possible 
analysts sure appropriate parameters algorithm run available memory results analyzed tuning 
interesting running algorithm available space ensures important elements susceptible noise 
underlying reason easily shown expected value estimation increases monotonically sum length stream sections ei monitored inversely related fi 
alon matias szegedy 
space complexity approximating frequency moments 
proceedings th acm stoc symposium theory computing pages 
arasu babu widom 
cql language continuous queries streams relations 
proceedings th dbpl international conference data base programming languages pages 
arasu babu widom 
cql continuous query language semantic foundations query execution 
technical report stanford university 
babcock babu datar motwani widom 
models issues data stream systems 
proceedings st acm pods symposium principles database systems pages 
babcock olston 
distributed top monitoring 
proceedings nd acm sigmod international conference management data pages 
burton bloom 
space time trade offs hash coding allowable errors 
communications acm 
bonnet gehrke seshadri 
sensor database systems 
proceedings nd ieee mdm international conference mobile data management pages 
bose kranakis morin tang :10.1.1.123.5152
bounds frequency estimation packet streams 
proceedings th international colloquium structural information communication complexity pages 
boyer moore 
fast majority vote algorithm 
technical report institute computing science university texas austin 
charikar chen farach colton :10.1.1.131.3373
find ing frequent items data streams 
proceedings th icalp international colloquium automata languages programming pages 
chen dewitt tian wang 
niagaracq scalable continuous query system internet databases 
proceedings th acm sigmod international conference management data pages 
cormode korn muthukrishnan srivastava 
finding hierarchical heavy hitters data streams 
proceedings th acm vldb international conference large data bases pages 
cormode korn muthukrishnan srivastava 
diamond rough finding hierarchical heavy hitters multi dimensional data 
proceedings rd acm sigmod international conference management data pages 
cormode muthukrishnan 
hot tracking frequent items dynamically 
proceedings nd acm pods symposium principles database systems pages 
cortes fisher pregibon rogers smith 
hancock language extracting signatures data streams 
proceedings th acm sigkdd international conference knowledge discovery data mining pages 
datar gionis indyk motwani 
maintaining stream statistics sliding windows 
proceedings th acm siam symposium discrete algorithms pages 
demaine pez ortiz munro 
frequency estimation internet packet streams limited space 
proceedings th esa annual european symposium algorithms pages 
estan varghese :10.1.1.110.5030
new directions traffic measurement accounting focusing elephants ignoring mice 
acm transactions computer systems 
fang shivakumar garcia molina motwani ullman 
computing iceberg queries efficiently 
proceedings th acm vldb international conference large data bases pages 
feigenbaum kannan strauss viswanathan 
approximate difference algorithm massive data streams 
proceedings th focs annual symposium foundations computer science pages 
fischer salzberg 
finding majority votes solution problem 
journal algorithms 
flajolet martin 
probabilistic counting algorithms 
journal computer system sciences 
gehrke korn srivastava 
computing correlated aggregates continual data streams 
proceedings th acm sigmod international conference management data pages 
gibbons matias 
new sampling summary statistics improving approximate query answers 
proceedings th acm sigmod international conference management data pages 
gilbert kotidis muthukrishnan strauss 
surfing wavelets streams pass summaries approximate aggregate queries 
proceedings th acm vldb international conference large data bases pages 
demaine pez ortiz munro 
identifying frequent items sliding windows online packet streams 
proceedings st acm sigcomm internet measurement conference pages 
ozsu 
issues data stream management 
acm sigmod record 
greenwald khanna 
space efficient online computation quantile summaries 
proceedings th acm sigmod international conference management data pages 
guha indyk muthukrishnan strauss 
histogramming data streams fast item processing 
proceedings th icalp international colloquium automata languages programming pages 
guha koudas shim 
data streams histograms 
proceedings rd acm stoc symposium theory computing pages 
ozsu 
web page prediction model click stream tree representation user behavior 
proceedings th acm sigkdd international conference knowledge discovery data mining pages 
gupta mckeown 
packet classification multiple fields 
proceedings acm sig comm international conference applications technologies architectures protocols computer communication pages 
haas naughton stokes 
sampling estimation number distinct values attribute 
proceedings st acm vldb international conference large data bases pages 
hoare 
algorithm find 
communications acm 
jin qian sha yu zhou 
dynamically maintaining frequent items data stream 
proceedings th acm cikm international conference information knowledge management pages 
karp shenker papadimitriou 
simple algorithm finding frequent elements streams bags 
acm transactions database systems 
martinez 
analysis hoare find algorithm median partition 
random structures algorithms 
lin lu xu yu 
continuously maintaining quantile summaries elements data stream 
proceedings th ieee icde international conference data engineering pages 
manku motwani :10.1.1.19.8594
approximate frequency counts data streams 
proceedings th acm vldb international conference large data bases pages 
manku rajagopalan lindsay 
random sampling techniques space efficient online computation order statistics large datasets 
proceedings th acm sigmod international conference management data pages 
matias vitter wang 
dynamic maintenance wavelet histograms 
proceedings th acm vldb international conference large data bases pages 
agrawal el abbadi 
duplicate detection click streams 
proceedings th www international world wide web conference pages 
extended version appears university california santa barbara department computer technical report 
agrawal el abbadi :10.1.1.114.9563
efficient computation frequent top elements data streams 
proceedings th icdt international conference database theory pages 
extended version appears university california santa barbara department computer technical report 
misra gries 
finding repeated elements 
science computer programming 
whang vander zanden taylor 
linear time probabilistic counting algorithm database applications 
acm transactions database systems 
zhu shasha 
statstream statistical monitoring thousands data streams real time 
proceedings th acm vldb international conference large data bases pages 
zipf 
human behavior principle effort 
addison wesley 
