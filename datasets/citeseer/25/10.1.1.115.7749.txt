design programming language joel richardson michael carey daniel schuh university wisconsin extension designed writing software systems support persistent applications 
originally designed language implementing database systems evolved general persistent programming language extension support transparent persistence implementation support generic classes remains extension provide general purpose addition contributions programming domain contributions field languages general including distinct implementations persistence 
thm describes main features shows examples addresses problems arise building persistent systems 
categories subject descriptors programming languages language object oriented languages programming languages language constructs features database management languages database persistent la general terms design languages additional key words phrases 
extensible database systems persistent object management 
motivation mid database research groups responding needs variety emerging applications began explore extensible database systems 
different groups different notions extensible means common desire support high degree flexibility customizing database system user application 
flexibility lacking today commercial systems attempts provide added software layers experienced severe performance penalties care 
experiences prompted researchers explore system architectures extended easily loss perfor research partially supported defense advanced research projects agency contract national science foundation iri fellowships ibm university wisconsin dec incentives excellence program gte laboratories texas instruments apple computer 
authors addresses richardson ibm almaden research center harry road san jose ca 
carey schuh computer sciences department university wisconsin west dayton street madison wi 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice ven copying permission association computing machinery 
copy republish requires fee specific permission 
acm acm languages systems vol july pages design programming language mance 
example extensible dbms easy augment collection base types new user defined types exodus project university wisconsin exploring toolkit approach extensibility 
software tools simplify construction customized database systems extension systems built 
component exodus toolkit exodus storage manager 
provides basic support objects files transactions 
programming language compiler 
describes language design various approaches implementation described richardson carey schuh shekita :10.1.1.106.4431
third major exodus component optimizer generator allows database implementor dbi produce customized query optimizer set rules describing query algebra 
originally intended language write database system code data types time access methods grid files operator methods hash join written intended target language schema query compilation user defined schemas translated types user queries procedures 
difficulty building dbms conventional systems programming language derives factors 
dbi write code primary task manipulate shared data secondary storage 
significant portion total system code devoted interacting storage layer calling buffer manager read record 
second dbi write code operators access methods knowing priori data types operate 
example dbi know user eventually want build index keyed area set polygons 
dbi build query processor converts queries posed users form system execute 
translation greatly simplified basic operators written composable manner 
influences led design language 
original goals clearly evident evolved general purpose language coding persistent applications 
extension providing generator classes iterators persistent objects :10.1.1.26.9545
provided starting point class data abstraction features expanding popularity systems programming language 
parameterized types form generator generic classes added utility defining database container types sets indices expressing generic operators select join 
iterators added useful programming construct general mechanism structuring database queries particular 
generators iterators commercial ingres supports user defined data types lines pioneered adt ingres postgres 
acm transactions programming languages systems vol 
july 
richardson inspired clu 
persistence ability language object survive program run added essential attribute database objects 
addition describing database object base terms persistent variables may manipulate directly expressions language 
factors influenced way extensions added 
desire maintain upward compatibility strict superset 
originally forced small compromise order support generator classes nested class definitions follow nested scope rules nested class definitions exported global scope versions 
supports nesting class scopes longer problem 
second important factor concerned efficiency 
desired subset compilable code efficient produced compiler 
primarily influenced way added tence language allowing persistence property object allow persistence objects type declared database db type 
section explains point fully 
design implementation represent contributions field persistent programming languages 
designed approximately time extend persistence 
ln persistence inheritance class recoverable access persistent objects context special pinning block 
persistence persistent storage class required access persistent object transparent 
storage class approach appeared language designs persistent modula objectstore 
extension add generic classes design implementation template design 
addition remains extension provide general purpose iterator construct 
remainder organized follows section reviews basics classes introducing simple binary tree example 
follow ing sections main language extensions adds 
sections compare features similar features languages 
section discusses iterators uses help extend binary tree support duplicate keys 
section describes generators redefines example generic binary tree 
section describes database types persistence modifies example tree part database 
presentation language design sections section discusses shortcomings current design implementation designed implemented persistent extensions appeared discussed briefly section 
section concludes presentation summarizing current status language 
appendix included indicate parts database application described atkinson acm transactions programmmg languages systems vol july design programming language buneman expressed noted examples compiled run 

review original design extension extended classes operator overloading type checked function calls features 
added multiple inheritance ported version 
order avoid unnecessary tion review examples include data abstraction features version 
necessary highlight interaction inheritance especially multiple tance features added see section 
classes central concept notion class 
class defines type definition includes representation instance class operations may performed instance 
abstraction mechanisms provided clu smalltalk class necessarily hide representation instances 
designer class declare explicitly members data function private public 
data abstraction capabilities classes provide main motivations selection starting point design parlance representation objects called data members class operations called member functions methods 
member functions applied specific instance function unqualified data member class bound instance 
binding realized implicit parameter pointer object method invoked 
member function unqualified member class equivalent inheritance reason chose starting point supports subtyping 
class may define class subtype follows class class public called base class derived class 
inherits representation member functions 
public keyword context specifies public members public members keyword public members private members may declare additional data members member functions may reimplement member functions defined acm transactions programming languages systems vol 
july 
richardson key contributions object oriented programming languages late binding method calls 
suppose method type reimplemented suppose program contains invocation object pointer static type runtime may refer instance type late binding defers binding code runtime 
point actual type object determined appropriate implementation called 
late binding allows type hierarchy extended new subtypes requiring changes recompilation existing code 
late binding achieved declaring member functions virtual 
show specific examples extends subtyping mechanisms including single multiple inheritance realm database types persistent objects 
task challenges defining semantics types type tence adapting implementation 
problems completely solved discuss issues section 
example example figures la lb complete definition simple binary tree index 
basic operation tree map key value address entity having key 
example tree node stores floating point key pointer indexed entity pointers left right subtrees 
implementation uses pair classes defines nodes tree defines tree 
node class recursive representation nodes point nodes operations search insert recursive methods 
tree class simple wrapper encapsulates nodes 
order keep example simple showing major features tree unbalanced limit operations tree inserting searching 
la gives definition class 
representa tion node tree follows class heading 
node contains floating point key value node key pointer indexed entity pointers left right subtrees 
keyword public introduces set member declarations form public interface class 
interface comprises methods search insert named 
member functions elaborated class declaration 
function constructor class 
constructors initialize class instances constructor initializes fields newly created node 
guarantees class constructor constructor invoked automatically instance class created 
constructor takes arguments supplied void may legally point type object 
acm transactions programming languages systems vol 
july design programming language class float void public float void 
constructor void 
search float void float void null void binary 
search float searchkey searchkey return searchkey null return null return search searchkey null return null return search searchkey void newnode newnode return 
duplicates allowed newnode null newnode ld newnode null newnode newnode fig 

class definition binary tree nodes 
object declaration 
example declaration anode null anode instance initialized zero key null pointer 
member function search compares node key argument returns node entity pointer recur searches appropriate subtree 
subtree exist key null pointer returned 
insert member function takes pointer new node inserted tree 
assume node initialized key pointer values 
routine searches proper position adds node acm transactions programming languages systems vol 
july 
richardson class binarytree public root constructor void search float void insert float void root null void search float searchkey root null return null return root search searchkey void float void newnode new root null root newnode root newnode fig 

class definition binary trees new leaf 
note duplicate keys simply rejected section remedy shortcoming 
lb gives definition binarytree class 
said earlier class really thin wrapper node class mainly start recursion search 
representation binarytree pointer root node 
binarytree constructor initializes pointer null 
search tree check root pointer null search root node recursively 
insert member function contains example creating node dynamically 
new operator returns pointer node allocated heap 
creating instance class having constructor provided arguments 
tree empty new node immediately root pass new node root insert proceeds recursively 

iterators consider extensions inspired clu language 
contributions clu demonstrated sepa rating production sequence values values elegant highly practical 
control abstraction called iterator generalizes iteration loops 
iterator com cooperating agents iterator function function iterate acm transactions programmmg languages systems vol 
july design programming language loop loop produce process sequence values 
loop client function views simply source stream values 
function produces stream yielding result value time client loop 
return normal function function yields value local state preserved 
loop requests value function resumes execution 
function viewed limited form coroutine may invoked context loop 
iterators originally included iterators utility structuring database query processing quickly convinced usefulness general programming construct 
syntactically iterator function looks normal function keyword iterator precedes return type function body may contain yield statements 
function may take parameters type may yield values type 
code comprising function body arbitrary function may invoke iterators may recursive 
consider example 
purpose function ments yield elements unsorted integer array greater average elements 
invoked pass array order compute average 
second pass yielding element larger average 
yield point suspends execution client processes element client requests element func tion resume yield point 
loop terminates control falls bottom function terminates 
iterator may terminate executing normal return 
example shows yield statement general function may 
iterate loop comprises keyword iterate followed function invocations parentheses followed statement forms loop body 
invocation supplies actual arguments function declares variable receive yielded values 
example loop activates functions yield types int foo respectively iterate mt foo int 
note simultaneous activations associated function invoked context loop 
shows main program containing loop uses big elements iterator 
initializing array control enters loop function activated control returns loop holds value sequence 
loop body prints value control returns active terminated loop terminates control flows statement program 
acm transactions programming languages systems vol 
july 
richardson fig 

simple iterator example 
flow control iterator mt mt array mt size float sum oo float ave compute average mt size sum array ave sum size 
yield blg elements mt ze array ave yield array mt 

find blg elements iterate mt printf example flow control iterate loop implicitly defined 
loop entry top loop iteration function resumed order obtain value 
num ber iterations determined function loop iterates function decides terminate 
addition single function controls loop simple example 
provides variations theme providing programmer general control flow capabilities 
allows multiple functions activated concurrently 
case default flow control resumes functions top loop order resumption implementation dependent 
loop terminates functions terminated 
functions terminated active values loop variables associated termi nated functions unaffected resumption remain ing active functions 
order allow program determine functions terminated built function empty may applied loop variable empty returns function tion associated variable terminated 
see example shortly 

default flow control described tive certain cases 
consider iterator supposed yield sorted stream values merging sorted input streams 
naturally wish produce input streams iterators merge function client functions 
default flow control inappropriate acm transactions programmmg languages systems vol july task 
simply try design programming language iterate int vail int va stream 
march streams lock step loop body may buffer arbitrary number values entire sequence produced streams 
try nesting iterate int vail iterate int va stream 
repeat entire inner loop element considered outer 
clearly flexible control needed 
advance statement introduced part meet need 
example consider advance va statement appears context iterate loops 
effect statement resume function activation associated va case stream advance statement va new value 
general form advance may comma separated list variables function activation associated variables resumed implementation dependent order 
advance statement executed pass body loop default resumptions carried functions advanced functions advanced iteration 
shows advance statement empty function implement merge example 
control enters loop functions stream stream activated loop variables val va receive initial values 
test see function terminated simply yield element stream 
default flow control advance active function exhausted 
functions active yield smaller value explicitly advance function came function advance iteration 
loop terminates functions terminated 

merge example shows client loop decide function activation resume iteration 
far loop termination determined functions client iterates functions terminated 
alternatively client may decide break loop normally causes immediate termination active functions associated loop 
function may require explicit control tion sequence 
may example need release heap space perform bookkeeping tasks 
handle cases extended yield syntax optional clause 
clause statement executed client terminates loop function suspended yield point 
example suppose function built structure deallocate terminating sup acm transactions programming languages systems vol 
july 
richardson fig 
advance statement 
iterator mt iterate mt vail int va stream empty vail yield va empty vai yield vail vail va yield vail advance vail yield va advance va pose variable points root structure 
example client breaks function yielded user defined cleanup routine called function terminates yield cleanup absence clause function code executed termination 
recursive iterator example final example modifies binary tree implementation previous section handles duplicate keys 
brevity show search routine 
assume amended insert routine longer rejects duplicate entry finds match recursively inserts new entry left subtree 
prepared find entries key value rewritten tree search iterator yields sequence pointers entities matching keys 
search key greater key current node simply yield results searching right subtree 
search key equal current node key search left subtree yielding result level 
keys equal yield entry current node subtree search terminated 
top level client picks return values 
point client loop stack active functions corresponding levels tree 
situation illustrated right sample tree built inserting keys order 
assume client asked search tree entries key value 
left tree show stack recursive iterator activations point immediately execution yield 
arrow stack indicates direction growth 
activation labeled current line number code 
acm transactions programming languages systems vol 
july design programming language iterator void search float searchkey searchkey null iterate void 
search searchkey yield searchkey yield elseif null iterate void search searchkey yield 
fig 
recursive search iterator 
fig 

operation search iterator 
note client may choose break loop duplicate entries yielded event triggers cascading tion active functions 
yield statements binary tree search iterator contain termination clauses needed clauses executed described newest activation stack 
iterators languages iterators appeared various forms languages 
ously clu allowed programmer define generators functions provided loop loop iterating results 
write generator programmer defined form similar class provided functions init 
execution loop invoke init repeatedly invoke 
similar solution possible advocated provide special support iterators 
defines class data members maintain state iteration member functions include initialize state return value advance state 
define special construct invoking iterators fairly clean solution possible standard loop simple coding conventions 
acm transactions programming languages systems vol 
july 
richardson approach writing iterators relative languages clu type object iterated usually define separate class form kind iterative access desired 
required programmer responsible explicitly saving state iterator invocations data types involved iteration state depend type target object iteration 
second coding iterator multiple yield points significantly complicate logic required func tion programmer explicitly save resume control state data state iterator 
problems occur clu iterators preservation data control state part semantics 
iterators appeared languages clu trellis owl 
sev eral database programming languages languages de signed simplify task writing database applications offer restricted form iterator yields results database query 
examples include pascal plain 
languages allow program mer write arbitrary loops functions specified implicitly predicates sets objects 
dbpl offers general design allows implicit functions iterating built container types lists arrays sets programmer provided functions 
comparing languages recall intended systems programming language control flow explicit programmer control 
intended useful target language database query compilation provide low level iteration support sufficient implementing queries 
provide high level query oriented iterators 
func tions programmer defined clu trellis owl 
hand supports parallel invocation functions clu trellis owl support restricted form parallel invocation permitting individual tuples satisfying join cate query obtained processed 
parallel iterators provided support general stream merging computations 
advance statement unique allowing explicit resumption functions re quired processing 
provide means functions clean premature termination loop 
permits just cleanup clause function permits cleanup clause yield point 
shaw mentions difficulty writing certain kinds iterators compute recurrence relations 
simple example consider generating numbers numbers computed differently rest function know returning second nth number simply write function having yield points 
flexibility cost restricted semantics clu iterators allow efficient stack oriented implementation function activations allocated heap 
acm transactions programmmg languages systems vol 
july 
generator classes design programming language mentioned problems facing dbi code large flexible system dbms written knowledge specific types objects code eventually manipulate 
traditional dbms knowledge basic attribute types wired basic operators access methods operate types essentially switching type attribute hand 
obvious problem approach set basic types fixed system difficult extend 
problem order handle different record types offset length information passed explicitly routine 
addition programmer responsible coding offset calculations interpreting untyped buffer pages 
original goals mechanical tasks implicit 
inspired clu generators confused generators providing elegant solution problem 
generator parameterized type defined terms unknown formal types 
classic example generic type stack element type defines type stack elements 
case binary tree generic class introducing type parameters type key type entity indexed 
generator classes introduces parameterized types form generator classes generator class may number class parameters formal class names may freely generator regular type names data member types argument return types member functions basis type definitions 
syntactically generator class form regular class formal parameters specified square brackets class name 
parameters form skeletal class declarations 
example definition bounded generic stack class shown 
shall omit showing stack member functions notable feature name element type needed 
instantiation 
order generic class ate specific class supplying actual arguments generator 
example assume defined class frame define type stack frames class stack frame note generics added form templates 
generator classes templates compared section 
acm transactions programming systems vol 
july 
richardson fig 

generic stack class declaration 
public class stack class mt top 
top stack index stk elements push mt ii constructor definition declare instances 
example instance frame frame push ii push attempting push frame flagged type error compile time 
constraints class parameters 
class parameter specified empty body stack example type may instantiate generator 
example define intstack stack lnt int really class 
programmer may specify constraints instantiating types parame ter class body member function declarations classes having mem ber functions names type signatures instantiate generic class 
furthermore generator mem ber functions may invoked objects parameter type 
example binary tree class generic introducing type parame ters key type 
order key type useful able compare key values determine ordering 
means accomplishing constrain key type class class keytype public int compare keytype class declaration actual class may bound keytype public member function compare takes keytype pointer returns integer 
search routine compare keys follows int search key compare 


acm transactions programmmg languages systems vol 
july design programming language course additional requirement integer returned compare function equal greater zero corresponding ordering keys 
semantic constraints expressed type system 
parameters 
shortcoming approach names class parameters formal names names member functions included constraints actual names 
example class may instantiate keytype provided member function name literally compare 
may useful contexts may restrictive 
example may preexisting class comparison routine routine name may compare 
may class defining different comparison routines corresponding different criteria ordering instances 
overcome problem allows member functions parameter class named separate formal parameters generic 
example redefine generic node class follows class class keytype class int keytype compare keytype parameter keytype may instantiated class having member function takes keytype pointer returns integer name specific member function supplied instantiation time 
programmer wishes formal actual member functions may overloaded operators 
examples chosen pass single compare routine passed pair overloaded operators illustrate points assume class datapoint recording experimental observations wish build index points 
key complex number taken experimental data complex defined follows class complex representation 
public int complex compare imaginary parts int complex compare real parts may instantiate node type keys ordered imaginary parts follows class complex datapoint complex despite flexibility provided member function class parameters approach falls short cases 
remaining problem acm transactions programming languages systems vol 
july 
richardson possible directly instantiate binary tree fundamental key type float types classes comparison methods 
problem relatively common coding practice define comparison routines symmetric binary opera tors class friend functions member functions class 
actual key type class comparison routine member function 
handle cases allows normal functions generic class parameters example illustrates class class keytype class int compare keytype keytype type including fundamental type may instantiate keytype function having matching signature may instantiate compare 
solution ongoing binary tree example 
constant parameters 
kind class parameter sup ports constant value 
parameter may fundamental type generator class may freely const 
value instantiation compile time constant 
particularly useful defining array members size depends particular instantiation 
example may define generic stack class maximum number elements class parameter class stack class int int top stk may define class stacks integers follows class intstack stack lnt nested instantiation shown define generator class 
order define wrapper class binarytree generic arrange instantiated automatically user program instantiates binarytree 
allows new type defined scope class lines 
creating types way includes defining class declare function friend 
function member class permitted access class representation 
acm transactions programming languages systems vol 
july 
design programming language type instantiating generic 
furthermore context generator class ga may instantiate generator gb supplying gas parameters gb instantiation ga actual parameters causes nested instantiation gb 
binarytree class generator shown 
context binarytree new class instantiated passing parameters supplied bi 
complete class definition section 
discussion comparison related generic class true type objects declared class 
contrast languages ml fun type systems support truly generic objects generic identity function return type depends type actual parameter 
follows common practice defining generic mold creating new types instantiation type defined essentially equivalent macro expansion generic class definition 
note imply macro expansion implementation 
fact follows clu compiling generic code shared instantiations 
languages define generics similarly include clu ada trellis owl eiffel 
language supports generics sort version 
generic class function called template 
generator class template class specify constraints instantiating type 
member functions template class invoke methods unknown actual parameter type design implies instantiating template type supply required methods error may detected link time 
error caught compile time 
templates directly provide generic functions 
effect achieved defining function static member generic class class created template serve base class subtyping 
furthermore template class may inherit contemplate class template class 
case class instantiated subclass case class instantiated subclass instantiated automatically parameters 
example define set inherit collection specific type set subtype collection 
trellis eiffel support kind definition 
member function class declared static exists independently object class may invoked directly scope resolution operator 
example valid invocation static member function class acm transactions programming languages systems vol 
july richardson class class keytype class int compare keytype keytype 
keytype compare root public 
search keytype void insert keytype fig 

binary tree class similar allows class instantiated class generator serve base class subtyping 
allows generator class inherit types generics supporting incremental definition generic types 
unfortunately define subtype relationships types instantiated classes 
language design standpoint certainly flaw fortunately proved problem practice 
hand 
support constraints class parameters useful 
implementation generics terms shared generic code allowed write large separately compiled generic modules tree index 
large packages impractical implementation 
generator classes designed implemented prior appearance template design 
diverged respect 
templates design content continue 
templates available reconsider 
despite relative strengths generator design possibility correcting flaws currently plan drop generator classes favor templates move version 
clearly mistake support generators templates result impossible understand maintain 
equally clearly community going familiar templates justifiably reluctant program required switch generators 
realities adopting templates releases best choice 

db types persistence discussion far described extensions allow programmer process sequences values define parameterized types 
features important database style programming 
data objects available program far volatile objects lifetimes bounded program run 
introduce features allow program create persistent objects describe database object base operations strictly language 
acm transactions programmmg languages systems vol july database types design programming language mirrors existing types type constructors corresponding database types db types type constructors 
type definable analogously defined db type 
db types describe types objects database database schema 
db type object necessarily part database db type objects may allocated stack heap 
shortly convert binary tree class db type 
informally define db type fundamental db types 
fundamental db types fully interchangeable counterparts legal multiply int assign float 

data member db type 
argument return types member functions may db types 
pointer db type object 
usual kinds pointer arithmetic legal db pointers casting allowed db pointer type 
possible convert db pointer normal pointer type int 
array db type objects 
array name equivalent pointer element 
db type object 
persistent storage class having db types allows programmer define types objects database 
persistent storage class provides basis populating database 
declaration db type variable specifies storage class persistent variable survives runs program crashes 
simple example program counts number times run persistent count main printf program run times count integer count persistent variable initial value set time program runs prints current value count increments 
note explicit calls read write count external files implicit program 
great convenience language support persistence allows programmer concentrate algorithm hand details moving data disk main memory 
implementation persistence compiler interacted runtime system reserve storage location object address compiled code constant 
current implementation uses flexible scheme defers binding storage location acm transactions programming languages systems vol july 
richardson runtime 
persistent store keeps map translating variable names source file corresponding storage locations exo dus storage manager 
program starts run interacts persistent store obtain current object address persistent variable named program 
object current address program running time object deleted created time 
scheme substantial improvement original implementation problems concerning naming shall discuss section 
collections provides built generator db class collection allow dynamic creation deletion objects 
specific type collection may contain objects type subtype 
lifetime object collection bounded lifetime collection particular program creates object persistent collection object persistent 
generic class programmer instantiate specific type collection declaring collection object 
objects db type collection may volatile persistent depending declaration may data member class 
noted possible define heap collections capable containing objects type instantiating built collection class argument 
creating objects collection 
may overload new operator order take control storage allocation 
uses mechanism allow programs create objects collection 
example suppose person defined constructor takes character string containing person name 
code defines type describing collections persons declares instance type creates people collection person city person city madison person pi new madison person jane person new pl person toby shown overloaded new operation takes arguments 
argument specifies containing additional collection newly allocated object argument expression evaluates collection long type new object subtype type entity collection 
compiler verify condition type collection type object created manifest 
example creating instances person collection persons example student subtype person create student instances collection 
deletion named persistent variables defined language 
provide separate task 
acm programming languages systems vol july design programming language note collection similar typed heap objects allocated deallocated inserted removed 
object exist collection tasks slightly awkward 
example simulate object appearing collection declare collection pointers 
design keeping purpose low level language supporting implementation higher level data models 
example class extent higher level data model implemented collection objects sets implemented collections pointers 
physical clustering 
objects stored disk locations relative significant impact performance 
generally speaking objects stored possible 
second new argument optional allows programmer communicate physical clustering hints storage layer 
second new example requests new person toby created near object referenced pl jane general second argument new may pointer valued expression referenced object need type collection newly created object 
implementation underlying storage layer determine near means worst hint ignored 
current implementation exodus storage manager search nearby location begins disk page objects allocated collection disk cylinder 
scanning collections 
collection generator class iterator member function scan scanning elements collection 
iterator returns sequence pointers objects collection 
example processes people madison iterate person madison 
scan 
note collection may contain objects subtype scan returns pointers 
example preceding scan yields person instances collection type student 
multiple inheritance posed challenges implementation collection scans 
challenges stem fact collection implemented exodus storage manager file records oids objects contains 
file scan produces pointer object 
necessarily correct pointer return program 
example suppose class supertypes create object near clauses added new syntax extensions 
elected drop syntax favor new operator overloading capability introduced old syntax second new example read near pl new person toby acm transactions programmmg languages systems vol 
july 
richardson collection bl 
suppose scan collection obtaining pointer object turn 
scan encounters object returned pointer adjusted refer part object 
mechanisms accomplish handle virtual base classes implemented note existing mechanism moving type hierarchy compiler inserts code adjust pointer apply situation known runtime particular object returned scan type destroying objects collections 
usual delete operator may remove object collection 
example delete toby previous example delete object type destructor destructor called object destroyed 
collection destroyed objects contains destroyed collection contains objects class having destructor destructor invoked object collection destroyed 
assume wish delete madison collection person 
conceptually process involves steps iterate person delete destroy empty collection 
performance reasons implementation destroy objects individually 
destructor calls reinitialize object entire collection destroyed en masse 
semantics persistent object destruction parallel volatile object destruction consequently inherit problems 
particular dangling possible 
storage layer reuses object ids prevent worst effect dangling overwriting random data 
problems associated explicit deletion creation garbage addressed design 
relies destructors ensure proper cleanup object deleted 
designing elected extend existing semantics persistent objects attempting define implicit deletion semantics 
binary tree example revisited reimplement binary tree example db type 
previous incremental examples reproduce entire offset part stored object header provided exodus storage manager scan adjusts pointer amount returning client virtual base class object header contains offset virtual base pointer object case scan iterator retrieves pointer object returns 
case appropriate part unambiguous error reported compiler processes new statement attempts create object 
acm transactions programming languages systems vol 
july design programming language implementation comparison original version 
node class shown changed version la ways insert routine accepts duplicates search routine iterator developed section 
key entity types type parameters key comparison routine function parameter developed section 
class developed section 
shows binary tree class 
order define class instantiate new classes 
class instantiated parameters binarytree nested instantiation described section 
instantiated type collection containing nodes 
binary tree represented collection containing nodes root pointer root node 
insert new node allocated tree collection 
changes binary tree class parallel node class type parameters definition search iterator 
shows example persistent binary tree index 
program builds index students keyed grade point average gpa 
students persist define school collection students declare persistent instance type 
define comparison routine floating point numbers routine types student instantiate specific index type 
declare persistent index 
main program shows examples creating new student adding corresponding index entry iterating students gpa 
implementing disk index binary tree example developed clearly hinting implementation real database index structures trees node contains keys 
defining structures essential constraint index node fit disk page maximal space page 
define node type generic class number keys fit page varies specific key type 
approach define generator constant parameter stack example section 
approach forces user class compute maximal number keys instantiation 
easier approach fact generator expression sizeof type parameter treated constant may declaring array bounds 
example assume pagesize constant giving size disk page bytes 
outlined definition simplified generic class describing leaf nodes tree node contain array key pointer pairs number array elements maximum fit page 
binary tree example class parameterized key entity types key comparison routine 
convenience defined acm transactions programming languages systems vol 
july 
richardson keytype eni int compare keytype key type keytype node key leff public key type constructor iterator search key type void node 
keytype null iterator search key type searchkey mt cmp compare searchkey cmp null searchkey yield cmp yield null iterate search searchkey yield void newnode int cmp compare newnode cmp null newnode newnode null newnode newnode fig 
binary tree clam 
auxiliary type kpp key pointer pairs tree node array structures 
note kpp defined terms class parameters generic type implicitly instantiated instantiation 
define macros convenience 
amount usable space page size page minus overhead control information simple example control data integer giving current number entries array 
maximum number acm systems vol 
july 
design programming language keytype int compare keytype keytype binary keytype compare public root constructor iterator entity type 
search keytype void insert keytype root null iterator search keytype searchkey root null return iterate root search searchkey yield void keytype newnode new root null root newnode root newnode fig 

binary tree class 
array entries amount available space divided size entry sizeof kpp 
data member defined array dimension maximum 
comparison persistence mechanisms reachability 
style persistence provided termed allocation persistence 
object persistent created declared persistent variable created persistent collection 
approach quite different reachability persistence object persists reachable distinguished roots 
number persistent languages vol 
july 
richardson student school collection student persistent school int compare 
float cmp cmp return cmp return return binarytree student compare persistent student new student gpa iterate student search fig 

example persistent binary tree date adopted approach ps algol galileo gemstone reachability convenient mechanism programmer longer needs worry persistent objects containing dangling reclaimed volatile object 
allows greater flexibility program decide object persistent exists 
volatile object persistent copying value persistent object 
elected base persistence reachability reasons 
mentioned earlier envisioned target language compilation higher level data models 
felt language persistence object explicit property implicit side effect part particular data structure 
compelling reason reachability fits naturally garbage collected language 
reachability traversal determining persistence requires information garbage collection 
extension basing persistence reachability required database types quite different counterparts wanted avoid 
example probably disallow persistent unions change semantics union carry information determine member active acm transactions programming languages systems vol 
july design programming language key type mt compare keytype key type auxiliary kpp keytype keyval 
define pagesize define kpp public 
data members kpp rs fig 

generic tree leaf nodes 
collections class extents 
central issue design database programming language collections persistent objects defined 
pascal introduced relation type constructor tuples added deleted program control relations named variables 
implication restriction nested relations allowed 
dbpl plain took similar approach similar restrictions 
ps algol language providing fully general orthogonal persistence runtime heap basis persistence object reachable distinguished database root pointer persist 
persistent heap notion collection objects collection coded explicitly persistent data structure 
takes intermediate approach 
dbpl collection stores specific type object facilities processing objects collection 
ps algol restrictions type object persistent db type example may define collections collections 
provide implicit persistent heap dynamic creation persistent object requires specification collection create new object 
popular approach persistence support class extents 
extent set instances class instance created system automatically places object proper extent 
programs class extents form basis queries 
systems support extents define inclusion semantics subtypes extent class includes extents subclasses 
query extent may specify include subclass extents 
examples systems support extents include orion pc los 
acm transactions programming systems vol 
july 
richardson const typedef part forward decl pan 
uses part 
composite part uses quantity subpart 
entry part uses chain entry subpart chain part string name name part 
subpart chain 
part char mt match char 
virtual void public part cost cost base part mass weight base part char virtual void composite pan public parl 
hst components assembly cost additional cost assemble com nents additional mass assemble components virtual void nd part char 
persistent database composite char compos base parts uses uses links fig 

task describe database 
extents simple convenient fairly natural way add persistence object oriented especially focusing database applications 
fact extents seen extension relational dbms semantics just relation defines tuple type existing tuples class define object type existing instances 
acm transactions programming languages systems vol 
july 
design programming language void task iterate 
cost lo printf name name printf cost mass fig 

task print expensive parts 
void task char 
name part 
int database name printf name cost mass name fig 

task find cost mass part 
void task char name cost 
assume points subpart subparts recorded new part 
part new database composite name null cost mass lnc 
null due new composite part insert record head subpart chain uses uses fig 

task add new manufacturing step 
feel extents appropriate associate persistence types instances 
general purpose implementation language wanted able implement extents desired force cases 

discussion far design language shown examples 
course true test language practicality implementation actual 
built compilers acm transactions programming languages systems vol 
july 
richardson explored distinct implementations persistence 
furthermore build number persistent applications 
experience revealed language weaknesses strengths uncovered interesting implementation challenges 
section describe interesting issues 
detailed evaluation appear forthcoming 
language design issues naming persistent objects 
idea defining new storage class struck clean approach extending persistence mechanism 
just auto variable lives procedure invocation static variable lives lifetime process persistent variable live processes kind super static object 
definition name persistent variable merely handle object persistent store denotation object 
retrospect approach drawbacks area name space management 
names top level persistent objects variable names name space seen program obey scope rules 
sufficiency rules writing large applications questionable restrictive organizing large database 
example sharing hampered fact program include persistent variables different modules name just clashes transient global variable names disallowed 
similarly long term program evolution hampered currently possible change name persistent object created 
writing general purpose code impeded early binding names objects procedures largely alleviate problem 
possible circumvent problems doing requires fair amount foresight care developing large program 
alternative separate names objects persistent store names program text 
example chosen limit persistent variable access pointer traversals requiring pointer variables bound specific objects runtime calls similar opening file 
feeling adding persistence storage class natural doesn prevent programmers simulating approach building directory class manage name space persistent objects dynamically 
orthogonality 
controversial design points decision give headed type system simply introduce persistence orthogonal property types 
orthogonality cited desirable feature persistent language users complained dual approach 
motivation db types stems philosophy implementation concerns 
originally conceived language write database management systems 
systems clear distinction acm transactions programming languages systems vol july design programming language objects persist volatile 
example lock tables transaction descriptors definitely persistent objects database definitely 
db attribute type distinguishes objects may persistent definitely volatile 
note designed similar distinction 
separation normal types db types strong grounding performance considerations 
system resources known volatile mentioned previous paragraph ones accessed highest frequency 
object persistent access check needed object memory 
check costs boolean test significantly increase cost accessing critical system resources 
accesses type objects suffer loss performance accesses 
addition cost pointer dereference factor decision introduce db types representation pointers 
vax pointer bits giving address space approximately gb 
databases exceeding limit fact moving terabyte range 
persistence orthogonal types faced appealing alternatives 
pointers bits guarantee obsolete real world applications 
alternatively pointers large projected needs 
current implementation uses exodus storage manager persistent store pointer involves exodus object id bytes plus offset bytes 
approach quadruple space needed copying cost pointer desirable standpoint achieving program performance 
implementation issues preceding sections discussed issues related language design section turn attention shortcomings implementation 
shall see problems stem largely unix model creating running programs model attempted preserve apparent model insufficient supporting persistent language integrated programming environment needed 
type persistence 
type definitions shared compilation units textual inclusion header files 
necessarily true persistent language implementations 
example possible implement object faulting mechanism relies machine paging hardware see shekita lamb :10.1.1.106.4431
mechanisms tend limit space addressable objects space concurrently addressable objects size machine virtual address space performance problems programs operate large relative physical memory databases :10.1.1.106.4431
acm transactions programming languages systems vol 
july 
richardson notion type existing outside particular run compiler 
type compile module may may compile 
mechanism acceptable particularly desirable programming 
programs critical definition type remain consistent compilations 
object created type manipulated program different definition database easily corrupted 
persistent objects limited simple structures careful programming avoid problem 
object oriented language persistence careful programming insufficient 
order support late binding method invocations object carry information identify type uniquely 
face persistence identity type persist 
issue persistent type identity fundamentally odds existing model writing programs unix 
complete solution problems requires integrated programming environment provides features type library type identity independent particular compilation 
requires answering hard questions types shared programmers 
type changes type 
happens existing objects type old programs new type issues extend scope original intentions designing implementation provides partial solution type identity problem solution computing hash value class definition 
approximation type identity achieved way environment support class definition hash value different compilations 
persistent class instance created class hash value stored object identifying object type method dispatch 
course hash collisions possible extremely program includes classes hash value simply terminates startup time 
considered alternative designs best initial compromise 
type availability 
computing hash values provides initial solution type persistence problem related issue address 
problem possible program encounter object type known program compiled 
see problem arises consider implementation 
assumed object encountered program created program 
result type object encountered module program created object knows type 
implementation virtual function dispatch questions relate problem schema evolution known hard problem database systems 
researchers object oriented database systems offered approaches problem entirely satisfactory 
acm transactions programming languages systems vol 
july design programming language assume method dispatch table vtbl method code program address space 
unfortunately assumptions break presence persistence 
suppose persistent graph nodes type 
suppose write program pi traverses invoking virtual function node 
order compile pl need include definitions base classes 
suppose write program defines subtype adds node run pi program terminate error invokes virtual function new node 
note type error subtype tl invocation legal 
problem vtbl methods available pi 
case type persistence root problem lies language design language implementation context environment adequately support persistence 
providing support involve significant amount effort 
programs objects database execution involve incremental dynamic linking method code 
environment track dependencies programs persistent objects create 
tools provided allow users build execute debug evolve programs environment 
turn require define model programs programming process 
interesting important problems fall far outside scope exodus project 
maintaining programs unix awkward 
transactions 
implementations primitive notion transaction 
program run constituted transaction 
current support somewhat better library calls available commit abort transaction 
calls supported current implementation exodus storage manager provides atomic recoverable transactions 
persistent data touched transaction locked phase manner recovery provided write ahead logging 
program limited executing series independent flat transactions may provide nested transactions 
expect integrate transaction support introduced facilities handling exceptions 

related compared particular features languages having similar features 
important comparisons languages 
section focus attention comparing languages extended persistence 
language designed support reliable distributed computing 
language utilizes inheritance mechanism acm transactions programming languages systems vol 
july 
richardson allow programmers design data types having customized synchronization recovery properties 
persistence modeled set objects encapsulated server server may recover state objects crash 
differs approach main goal provide transparent persistence structuring large object bases transparent manipulating 
persistent objects exist independently active process 
inheritance declare db types reasonable alternative adding feature 
defining type define class inherits directly indirectly special predefine class db 
problems approach 
fundamental types int classes define db analogs terms inheritance 
second problem addition multiple inheritance possible define class inherits db classes 
clear define consistent meaning class having simply disallow cases 
researchers bell laboratories designed implemented lan guage seeks blend high level systems level program ming features 
extension including persistence 
maintains class extents provides support integrity constraints triggers 
provides form iterator expressing calculus queries type extents variations looping construct allow querying extent single type extents type subtypes 
despite higher level application oriented features shares basic limitations problems inherits possibility storing persistent pointer volatile object 
interesting point comparison requirements defining type possibly persistent object 
associates db attribute type pointer type poten tially refer persistent object 
associates type modifier dual declaration pointer indicate refer persistent object db pointers essentially dual pointers 
glance may afford flexibility methods essentially equivalent 
consider defining class contains pointer data member 
objects class may persist requires class defined db type requires pointer dual type modifier 
consider function takes pointer argument 
desire function able handle pointers persistent objects requires type modifier persistent confused persistent storage class indicates pointer refers persistent object 
acm transactions programming languages systems vol 
july 
design programming language pointer refer db type requires argument declaration dual type modifier 
potential advantage approach possibly persistent attribute need appear place type definition 
potential advantage design syntax isolates essence difference persistent types place really difference pointers 
objectstore past years startup companies introduced object oriented database products data model 
particular relevance objectstore system object design 
commercial offerings offer persistence library interfaces objectstore extended language persistence order provide tightly integrated language interface database system 
objectstore designed essentially goals having intended complex data intensive applica tions cad cae case geographic information systems gis 
objectstore number features common objectstore shares basic allocation approach persistence extended persistent storage class persistent objects obtained ing variables storage class allocating objects persistent collection 
objectstore improves approach partitioning persistent storage class named databases alleviating naming problem discussed earlier 
persistence orthogonal type objectstore pointers size normal pointers virtual memory mapping techniques auxiliary data structures manage handle databases larger virtual memory 
driving goal design objectstore desire get close pointer dereferencing speeds possible applications working sets fit main memory 
objectstore provides type collection class template representing sets objects 
object store intended user dbpl provides variants collection type form object class library 
advanced features objectstore include support inverse members model relationships objects associative queries index ing versioned data cooperative transactions 

current status currently compilers working cfront 
translator 
compilers differ manage persistent objects 
caches objects buffers exodus storage manager uses hash table locate cached objects copies objects virtual memory pointers converting object id pointers virtual memory addresses target objects resident 
implementations experimented acm transactions programming languages systems vol 
july richardson compile time approaches scheduling optimizing calls storage layer explored implementation persistence virtual memory mapping mach operating system :10.1.1.106.4431
experience shows implementation certain classes applications research continuing programs fast robust wide range database sizes 
addition 
version currently development 
version gnu compiler enable freely distribute anonymous ftp exodus software handled 
implementation underway expect distributing version late spring 
mentioned earlier depart earlier versions generic types supported template design collection generator class appropriately redefined template 
features iterators persistence remain 
exodus toolkit distributed external sites date 
construct variety data object management prototypes including small demonstration relational dbms university wisconsin dbms integrated production rule system wright state university nested relational dbms air force institute technology object manager support arcadia program development toolset university colorado extra excess moose object oriented database systems university wisconsin database system support programming environment project university wisconsin 
initial experiences external user sites reported hanson 
appendix parts database atkinson buneman proposed set tasks evaluate expressiveness database programming languages 
coded run example tasks excerpts code 
example parts database part base part composite part 
tasks describe database 
print name cost mass base parts cost 
compute total mass total cost composite part 
record new manufacturing step database new composite part manufactured subparts 
implementation follows spirit described atkinson buneman 
part may 
implementation classes defined subtypes part 
way linked list objects maintains usage relation parts 
part keeps list parts immediate subpart 
addition composite part keeps uses list immediate subparts 
acm transactions programming languages systems vol 
july design programming language database defined class containing collections base parts composite parts usage records 
alternatively combined single collection parts 
class provides search routine looks part name 
database declared persistent instance class 
perform task reporting expensive parts simply iterate base parts database printing desired information qualifying record 
task recursive calculation composite part cost mass somewhat interesting due virtual functions bodies shown 
base part simply returns cost mass composite part recursively sums cost mass subparts adds incremental cost mass task adds new composite part definition database 
routine assumes name new composite part cost mass increments list subparts 
routine completes task creating new composite part instance adding instance list subparts 
acknowledgments members exodus project willingness play role guinea pigs patiently 
particular mike wrote numerous programs test suite invaluable aid finding compiler bugs 
paul dan contributed similarly extensive language 
larry rowe suggestions regarding iterators marvin solomon pointing direction david dewitt numerous helpful discussions constant feedback 
referees comments helped improve presentation significantly 

agrawal gehani ode object database environment language data model 
proceedings acm sigmod conference portland june 

albano cardelli orsini galileo strongly typed interactive conceptual language 
acm trans 
database syst 
june 

atkinson bailey cockshott morrison approach persistent 
comput 


atkinson buneman types persistence database programming languages 
acm comput 

june 

atkinson liskov scheifler aspects implementing clu 
proceedings acm national con 

atwood hanna approaches adding persistence 
proceedings th international workshop persistent object systems martha vineyard ma sept 

bancilhon benzaken delobel pfeffer richard velez design implementation object acm transactions programming languages systems vol 
july richardson oriented database system 
proceedings nd workshop object ori database systems bad frg 
sept 

kim kim korth semantics implementation schema object oriented databases proceedings acm confer ence san francisco ca may 

batory leung wise implementation concepts extensible data model data language 
acm trans 
database syst 
sept 

cardelli wegner understanding types data abstraction 
acm 

dec 
carey df witt extensible database systems 
knowledge base management integrating artificial intelligence database technologies brodie eds springer verlag 
carey dewitt frank graefe richardson shekita architecture exodus extensible dbms proceedings international workshop object oriented database systems pacific grove ca 

carey dewitt rg data model query language exodus 
proceedings acm sigmod conference chicago il june 
carey dewitt richardson shekita storage management objects exodus object concepts databases applications kim lochovsky eds addison wesley 
carey dewitt graefe richardson schuh 
exodus extensible dbms project overview readings object databases zdonik maier eds morgan kaufman 

da nd smith probe knowledge oriented database management system 
knowledge base management integrating intelligence database gies brodie eds springer verlag 

fs herlihy wing inheritance recovery properties 
ieee comput 
dec 

ellis stroustrup annotated manual 
addison wesley 

ford joseph lively pathak perez peterson thatte wells database support object oriented programming advances object database springer verlag 

goldberg robson smalltalk language addi son wesley 

graefe mu dewitt exodus optimizer generator 
proceedings acm sigmod conference san francisco ca may 
hanson initial report design ariel sigmod record sept hanson harvey roth experiences dbms implementation object oriented persistent programming language database toolkit 
proceedings acm conference object oriented programming systems languages applications phoenix az oct 

harvey 
roth design nested relational database system 
sigmod record sept 

heimbigner personal communication oct 
herlihy wing language support reliable distributed systems 
proceedings th international symposium tolerant computing pittsburgh pa july 

hosking moss compile time optimizations persistence 
proceedings th international workshop persistent object systems martha vineyard ma sept 

barnes krieg bruckner mm rationale design ada programming language 
notices 

ioannidis moose objects simulation environment 
acm transactions programmmg languages systems vol july design programming language proceedings ifip world computer congress san francisco ca aug 

kernighan ritchie programming language 
prentice hall 

lamb landis orenstein weinreb objectstore database system 
commun 
acm oct 

liskov snyder atkinson schaffert abstraction mechanisms clu 
commun 
acm aug 

maier stein development object oriented dbms 
proceedings acm conference object oriented programming systems languages applications portland 

meyer genericity versus inheritance 
proceedings acm conference object oriented programming systems languages applications portland oregon sept 

meyer object oriented software construction 
prentice hall 

milner proposal standard ml 
proceedings symposium lwp functional programmmg new york aug 

flexible implementation clos persistence 
proceedings european conference object oriented programming oslo norway 

penny stein class modification gemstone object oriented dbms 
proceedings acm conference object oriented programming systems languages applications orlando fl oct 

richardson carey programming constructs database system implementation exodus 
proceedings acm conference san francisco ca may 

richardson persistent systems implementation language 
ph dissertation univ wisconsin madison aug 

richardson carey persistence language issues implementation 
pratt 
exper 
dec 

richardson compiled item faulting new technique managing persistent language 
proceedings th international workshop persistent object systems martha vineyard ma sept 

rowe data abstraction views updates 
proceed ings acm sigmod conference 

rowe stonebraker postgres data model 
proceedings th vldb conference brighton england 

schaffert cooper trellis object environment language manual 
dec tr nov 

schaffert cooper kilian trellis owl 
proceedings acm conference object oriented programming sys tems languages applications portland oregon sept 

schmidt high level language constructs data type relation 
acm trans 
database syst 


schuh carey dewitt persistence revisited experiences 
proceedings th international workshop persistent object systems martha vineyard ma sept 

schwarz chang freytag lohman mohan pirahesh extensibility starburst database system 
proceedings international workshop object oriented database systems pacific grove ca 

wulf london abstraction verification defining specifying iteration generators 
commun 
acm aug 

sh cricket mapped persistent object store 
proceedings th international workshop persistent object systems martha vineyard ma sept 

exodus software demonstration 
acm conference chicago il may 

skarra zdonik type evolution object oriented database 
research acm transactions programming languages systems vol 
july 
richardson directions object programmmg shriver wegner eds mit press 
solomon personal communication 
jan 

stonebraker inclusion new types relational database systems 
proceedings nd international conference data engineering los angeles ca feb 

stroustrup 
programmmg language 
addison wesley 

stroustrup parameterized types 
proceedings usenix conference oct 

programming language nd ed 
addison wesley 

tarr wileden clarke extending limiting style persistence 
proceedings th international workshop persistent object systems martha vineyard ma sept 

wasserman data management plain 
proceedings acm sigmod conference 

white dewitt pointer swizzling virtual memory alternative approach supporting persistence programming language 
submitted publication 
available computer sciences dept tech 
rep univ wisconsin madison feb 
received february revised december january accepted march acm transactions programmmg languages systems vol 
july 
