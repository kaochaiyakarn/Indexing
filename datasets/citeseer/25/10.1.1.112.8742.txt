empirical study operating systems errors andy chou yang benjamin chelf seth hallem dawson engler computer systems laboratory stanford university stanford ca acc engler cs stanford edu study operating system errors automatic static compiler analysis applied linux openbsd kernels 
approach differs previ ous studies consider errors manual inspec tion logs testing surveys static analysis applied uniformly entire kernel source approach necessarily considers comprehensive variety errors previous studies 
addition au allows track errors multiple versions kernel source estimate long errors remain system fixed 
device drivers error rates times higher rest ker nel 
largest quartile functions error rates times higher small est quartile 
newest quartile files error rates twice oldest quartile provides evidence code time 
bugs remain linux kernel average years fixed 
examines features operating system er automatically compiler extensions 
attempt address questions drivers account errors 
bugs distributed 
long bugs 
bugs cluster 
different oper ating system kernels compare terms code quality 
derive initial answers questions ex bugs snapshots linux spanning years 
cross check results openbsd snapshot 
bugs examine previous compiler extensions automatically find violations system specific rules kernel code 
bugs fall categories including releasing acquired locks calling blocking operations interrupts disabled freed mem ory dereferencing potentially null pointers 
basing analysis compiler errors nice properties 
compiler applies permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial tage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission foe 
sosp banff canada acm isbn extension uniformly entire kernel 
handed error slice allows apples apples comparison different parts kernel 
likewise compare different kernels run ning checks 
comparisons difficult manual error reports tend errors skilled developers happened look bugs happened triggered 
second automatic analysis lets easily track errors versions making possible apply analysis trends time 
scope errors study limited automatic tools 
bugs straightforward source level errors 
directly track problems performance high level design user space programs facets complete system 
apply types issues open question 
revolves central questions 
errors 
section compares dif ferent subsections kernel shows driver code error rates times higher certain types errors code rest kernel 

bugs distributed 
section shows error distribution readily matched loga series distribution properties yield insight bugs generated 

long bugs live 
section calculates formation bug lifetimes kernel snapshots shows average bug lifetime certain types bugs years 

bugs cluster 
expect function file directory error 
section shows clustering tends occur heavily programmer ignorance interface system rules combines copy paste 
ily clustered error type files checked contained errors 

operating system kernels compare 
sec tion shows openbsd higher error rate linux checkers compare 
openbsd error rates range times higher 
laid follows 
section describes kernels check gather data 
section examines bugs 
section discusses distribution error counts matches distribution 
section addresses long bugs live 
section describes bugs cluster 
section compares openbsd linux 
section sum related 
methodology section discusses versions linux study system gather results 
data comes data comes different snapshots linux kernel spanning years 
linux reasons 
source code freely available 
feature compiler driven study 
release snapshots dating back early nineties readily accessible allowing look trends time allowing get releases check results 
second linux widely 
re sult relative systems code heavily tested meaning bugs easy find removed 
pro developed linux code 
aggregate effect reduce degree results skewed individual idiosyncrasies 
structurally linux kernel split main sub directories kernel main kernel mm memory man agement pc inter process communication arch ar chitecture specific code net networking code fs file system code drivers device drivers 
shows size code check time 
size measured millions lines code loc including newlines comments 
dif ferent releases check marked point 
graph ignores parts kernel specific ar 
graph shows interesting features checked snapshots grown factor roughly lines version lines version 
bulk code check comes drivers 
extreme ends graph versions driver code accounts code size middle graph percentage drops slightly 
years size os doubles growing previous years 
growth comes drivers 
secondary contributors file systems network code 
measurements graphs built different measurements 
computed directly code calculated metrics inspected errors errors manually re viewed 
projected errors errors low false positive checkers 
notes count number times check applied 
notes errors 
linux code base growth otal 
drivers fs net ql 



ll time size linux tree check time 
versions pre mark labelled 
growth comes drivers secondary contributors file system network code 
growth rest kernel significantly smaller 
growth rate changes rate new driver code increases 
relative error rate metric number er inspected projected divided number notes error type err rate errors notes 
example kernel error notes average error rate 
normalize results comparing different code bases checkers 
gathering errors errors twelve system specific checkers listed table 
come previous compiler 
past demonstrated effectiveness system specific static analysis relatively errors arose 
takes approach focuses solely errors 
get inspected errors manually examined error logs produced checkers small num ber kernel versions determined reports bugs false positives 
se lected error logs annotated information propagated versions 
tion process inspected error logs kernel version automatically annotate errors appear error logs 
example null checker manually inspected errors linux 
error report annotated annotated results propagated backwards version back 
bug reported earlier version versions au got bug annotation 
back propagation bugs kernel 
ad dition inspecting error logs distributed system implementors external confirmation 
get projected errors ran checkers low false positive rates linux versions treated unexamined results errors 
primarily low false positive checkers vat check block null vat range lock intr free float real param size rule checked avoid deadlock call blocking functions interrupts disabled spinlock held 
check potentially null pointers returned routines 
allocate large stack variables fixed size kernel stack 
inconsistent assumptions pointer null 
check bounds array indices loop bounds derived user data 
release acquired locks double acquire locks 
restore disabled interrupts 
freed memory 
floating point kernel 
leak memory updating pointers potentially null return values 
dereference user pointers 
allocate memory hold type allocating 
table twelve checkers 
checker false positives report number bugs inspected projected 
total bugs 
top primary projected checkers assume potential errors reported checkers real bugs 
middle set checkers count manually inspected errors real bugs 
bottom set checkers occasionally 
total number projected bugs time 
code base growth 
block projected pre 
null projected var projected 
float projected 
real projected 


absolute number projected errors study 
believe conservative estimate number unique bugs 
errors projected checkers usually function code size block checker unusual dip version 
number projected errors goes block null block errors null errors fixed version 
block null 
var checker produces false positives block percent null percent 
projected results noise fairly representative inspected results 
raw error counts answer questions re error rates require notion number times programmer correctly obeyed restriction 
notes emitted extension encounters event checks 
example null checker notes call routines return null block checker number critical sections ters free checker number calls sees notes number places programmer mistake relevant check 
checker dividing number errors number notes gives relative error rate 
graphs projected errors 
approximately unique bugs total counting projected inspected errors 
features note graph number errors unsupervised check ers generally rises time especially release version 
block checker accounts unexpectedly large number errors 
developers unaware restriction checks 
null checker accounts large num ber errors 
caused careless slips ig exactly functions return null ubiquitous null pointers indicate special cases 
scaling key feature experimental infrastructure completely automatic 
main manual parts writing checkers inspected bugs auditing output single run 
running checker versions linux requires typing single command 
results automatically entered database cross correlated previous runs 
common pattern inspecting errors release having system auto matically calculate releases long error lasts dies checks done relative error rate 
exception axis labeling graphs gen erated scripts 
adding new results new checkers operating systems requires little 
caveats caveats keep mind re sults 
approximately errors automatic compiler analysis 
unknown set bugs rep errors 
attempt compensate results collection checkers find variety different types errors comparing results manually conducted studies 
second caveat treat bugs equally 
shows patterns bugs 
interesting improvement find patterns impor tant bugs 
potential ranking algorithms supplement static results dynamic traces 
third caveat check narrow axes 
potential problem poor quality code masquerade code happen contain errors check 
try correct problem examining bugs time presenting distributions aggregating samples 
argument possibility extreme bias bad programmers consistently bad 
produce perfectly error free code axis adding types errors 
clustering results section provide empirical evidence intuition 
final related caveat checks mis represent code quality biased low level bookkeeping operations 
ideally count number times operation eliminated done correctly notes 
result low level focus code may fare poorly metrics 
concrete exam ple consider lines code structured performs potentially failing allocations misses check 
hand consider lines code perform operation allocation operations fail checked 
metrics code error rate second error rate arguably bet ter structure 
bugs 
set errors methodology previous section want answer questions errors 
drivers account bugs 
identify certain types functions higher error rates 
drivers gives breakdown absolute count inspected bugs linux 
glance confirmed vast majority bugs drivers 
effect especially dramatic block null checkers 
striking trend holds checkers 
drivers account block free intr bugs lock null var bugs 
drivers account majority code release bugs 
effect pronounced correct code size 
plot ting ratio relative error rate drivers versus rest kernel formula err err drivers number errors directory linux block free intr lock null range var 
arch net fs drivers graph gives total number bugs checker main sub directory linux 
combine kernel pc sub directories bugs 
errors driver directory unsurprising accounts code 
currently compile 
float param real size checkers shown 
rate errors compared directories block 
free intr null ge var arch net fs drivers graph shows drivers error rate times higher rest ker nel 
arch directory high error rate null checker identical errors arch arch relatively notes 
drivers relative error rate err 
identical rest kernel ratio 
lower rate ratio 
actual ratio far greater 
checkers error rate driver code times greater rest kernel 
lock checker extreme case error rate drivers times higher error rate rest kernel 
checker disproportionate num ber bugs different part kernel null checker 
identical errors arch notes arch di error rate relatively high 
graphs show driver code buggy terms absolute number bugs suspect size terms error rate 
possible explanations re sults list 
drivers linux systems developed wide range pro tend familiar device correlation error rate function size 
block 
intr 
lock 
null 



average function size lines graph shows correlation function sizes error rates 
drawn sorting functions notes size dividing equally buckets computing aggregated error rate bucket checker 
checkers large functions correlated higher error rates 
os driver embedded 
developers mistakes os interfaces fully understand 
second drivers heavily tested rest kernel 
sites may device sites run kernel proper 
large functions shows functions grow bigger error rates increase checkers 
null checker largest quartile functions average error rate twice high smallest quartile block checker error rate times higher larger functions 
function size measure code complexity results confirm intuition complex code error prone 
memorable experiences examining er ror reports large highly complex functions control flow 
higher error rate large functions case decomposition smaller understandable functions 
bugs distributed 
report errors checkers provide summary errors sorted number errors file 
common pattern emerges summaries files errors longer tail files just errors 
section consider bugs show phenomena described log series distribution 
fitting theoretical distribution useful compactly describes basic characteristics error data quantitative testable predictions allows derive theoretical metric kernel wide error clustering behavior 
log series distribution implies high level properties 
mode common value number errors unit files chunks attempts ll bugs block error count total files errors graph shows histogram number files number bugs checkers block 
actual data points theoretical log series distribution best fits data 
theoretical distribution parameter 
data set maximum likelihood value gives density formula distribution pr 
probability seeing unit errors monotonically decreasing function infor mally files bugs files bugs 

distribution completely determined single parameter estimated di rectly data 
data shows distribution errors files histogram representation 
points actual data points points theoret ical distribution described section 
note files contain error contain distribution rapidly drops files errors 
note files large number errors get sparser number errors increases points sparser tail distribution 
implies files unique large number errors 
fitting distribution fit distribution graph start set distributions test 
distribution parameters change shape curve 
estimate parameters method maxi mum likelihood established statistical technique estimations 
technique finds value parameters give rise observed data 
parameters determine data fits distribution ing chi squared goodness fit test 
specific details calculations postponed subsection 
performing cal analysis discovered data best fit block ee xxxxxxx error count total files errors graph shows histogram num ber files number bugs block checker 
actual data points theoretical yule distribution best fits data 
yule distribution parameter maximum likelihood value data 
logarithmic series distribution omit block checker 
possible prove data set drawn particular distribution data set anomaly 
possible show data set come particular distri bution 
table shows distri butions tried maximum likelihood parameters non block errors value obtained 
value roughly interpreted proba bility seeing data obtained came theoretical distribution 
standard statistical convention requires value lower re distribution stringent value 
yule geometric log se ries distributions rejected test distributions values re spectively 
chose log series distribution provided better fit relatively easy analyze describe 
block checker errors fit log series distribution results checkers 
main cause files large num ber block errors simply clustering log series distribution predicts 
discuss distribution block checker bugs section 
logarithmic series distribution subsection describes statistical methods fitting testing distribution data 
logarithmic series distribution gives probability seeing value ct er kl number bugs parameter curve normalization constant chosen probabilities add 
determined curve 
bugs block checker calculated maximum likelihood value distribution parameter value binomial geometric log series poisson yule zipf table distributions attempted fit errors block 
ge poisson distributions shifted value model distribution files error 
parameter values maximum likelihood values derived numer ically 
statistical literature value lower required reject distribution 
stringent value 
criteria reject log series ric yule distributions log series gives distinctly better fit 
bin bin bin bin observed expected table calculation errors block bugs bins 
techniques johnson kotz 
visually distribution appears fit data statistical test precise human eye 
distribution passes fit test assurance data really come distribution 
apply test data partitioned small number bins number errors bin equal possible 
example bins files error typically bin files errors bin files bin 
bins picked put reasonable number points bin test usually requires bin expected errors 
value calculated oi ei number bins oi ei number errors observed predicted bin respectively 
value calculated probability seeing data set looked table values degrees freedom parameter equal 
table shows observed expected number errors bin testing logarithmic series distribution parameter 
obtained corresponds value 
means time random sample came log series distribution different theoretical distribution bug sample properties distribution give useful approximation maximum 
average number errors file files errors implies 
data typically approximated log calculated various formulas follow distribution 
example predict total number files errors type number files contain exactly bug log predict total number errors nz calculating non block bugs data set check approximations 
nl files contained bug formulas predicted total files bugs bugs total 
actual number files errors total number bugs 
note derived data rigorous evaluation give feel best curve distribution fits data set 
explicit formulas mean num ber errors file variance section equations derive theoret ical measure kernel wide clustering 
log series distribution fit data bugs fit indi vidual checker bugs separated different 
block checker yule distribution fit better log series distribu tion 
omit details yule distribution high level similar log series distribution monotonically decreasing distribution single parameter 
qualitatively primary differ ence longer tail proba bility seeing large numbers bugs file accord finding block bugs exhibit significantly clustering 
shows distribution block bugs maximum likelihood yule distribution value 
discussion potential pitfall method rely files appropriate units aggregating error counts 
relying files appealing programmers introduce errors group related code files mak ing natural unit aggregation 
vantage files equal terms size complexity especially number chances making error checkers find 
result possible distribution file sizes notes influencing distribution bugs observe 
counter possibility bias com puted distribution bugs equal sized chunks notes 
distribution errors chunks essentially equivalent qualitatively respect fitting theoretical distribution 
form chunks order notes full path name file occur 
take consecutive chunks notes count number errors notes 
distribution chunks error plotted described 
choice somewhat arbitrary natural choice average number notes file excluding var float checkers notes somewhat misleading due nature checks 
tried possible values log series distri bution fit qualitatively passing test non block errors value chunks size files 
clearly data needs collected differ ent types systems general drawn distribution bugs systems 
initial results analyzing distribu tion bugs linux believe significant evidence recognizable patterns exist 
long bugs live 
sections looked bugs dis tributed space 
section looks dis tribution time examining bug lifetimes 
lifetime spans time bug introduced born time eliminated killed 
sample system time lifetime bugs system controlled birth rate determined current bugs born point past death rate symmetrically deter mined current bugs die point 
aggregate control old bugs system average killed time span 
show views data 
lifetime bugs study 
life time bugs indication effectiveness testing inspection process system 
ideal situation bugs fixed bug lifetimes zero 
gen eral shorter bug lifetimes better 

back projection bugs alive re cent release showing born birth rate percentage bugs past releases study 

magnification bug births deaths unsupervised checkers releases shows birth death rates different points time number bugs shared release 

estimation bug lifetimes 
calculation difficult bugs examine alive 
problem analogous measuring lifetime patients medical study patients enter different times bugs typ ically number alive study ends 
kaplan meier km estima tor estimate bug lifetime dence range 
lifetime bugs pre time graph shows lifetimes bugs 
horizontal line represents bug lifetime sorted birth date death date 
bugs appear die really censored 
errors linux broken checker beck 
free 

intr lock 
null 
range 

date graph shows origin bugs bug type calculating percentage bugs came date 
bug life gives raw lifetime data bugs study 
bug unique horizontal line rep lifetime 
left endpoint denotes bug introduced kernel born 
right denotes bug fixed died 
bugs alive release artificially truncated right endpoint follow fu ture 
truncation called censoring statis tical literature handled explicitly calculating bug lifetimes return point section 
left right endpoints cated version releases granularity sample kernel 
sort data release lifetime bugs shortest lived bugs top band longest bottom 
gives distinct lip version corresponds bugs detected version 
notice bugs detected just version lasted years versions 
magnification birth rates bugs magnify data bugs alive back time back propagation see introduced 
fig ure shows information plotting percent age bugs alive release broken checker checkers omitted graph simplify 
back propagation lets compare age bugs checkers 
back propagation shows half bug life gives feel shape birth distribution 
distri butions checkers similar shape sharp dropoff followed somewhat longer tail 
magnification births deaths time previous focused known inspected bugs single release 
complete picture answer birth death rates 
rates fluctuate time 
answer questions projected checkers block null var obtain errors releases 
checkers give false positives allow automatically extract ac picture actual number errors born died 
shows bug birth death rates kernel releases 
left side curve peak corresponds back propagation birth rate curve right side shows mortality rate propagating bugs forward releases see long fixed 
primary feature graph curves sharp dropoff directions similar back propagation shape errors 
rapid falloff going backward time left peak means typically bugs version introduced previous year rest carried code older year 
example consider peak curve labeled 
peak appears version version containing bugs 
version forwards backwards plot num ber bugs appear version 
graph decreases forward time right bugs die backwards time con sider releases bug introduced 
graph shows sharp dropoff directions approximately errors carried errors survived 
similar peak appears versions usually quite sharp 
non centered version graph encodes sev eral interesting properties 
connecting peaks gives curve showing absolute number errors time 
graph allows estimate 
bugs versions share take peak version follow curve forwards backwards version position axis 
height curve point number bugs common 

number bugs introduced fixed versions take peak version follow curve version number fixed peak minus height curve version lifetime bugs selected versions 




zu 




oo 

date ages bugs selected versions 





oo 
jl loo 
months away upper graph shows forward backward lifetimes bugs low false positive checkers block null vat selected major release snap shots 
symmetrically snapshots sharp forward backwards time giving ev bugs die quickly 
lower graph shows symmetry centering lifetime distribu tions point 
number bugs introduced height peak minus value 
version distribution old bugs take peak version consider peaks time 
follow curves version relative distances curves indicate errors version past 
calculating average bug lifetime natural questions ask ag data average median values 
extracting type data main problems quantization error censor ing interference 
granularity ver sions check limits precision 
ver sions separated months gap ranges month year 
effect quantization completely bugs lifespan falls versions check tends average lifetime calculate artificially long 
deal quantization ing birth date version kaplan meier estimator block null var 

years kaplan meier survival curve shows probability bug living longer num ber years 
dotted curves show dence band 
estimator computed bugs low false positive checkers block null vat 
bug appears death date version bug appears exact mates lifetime bugs find 
ignore bugs don find lifetimes fall tween versions 
effects bias different directions partially cancel 
second mentioned exact death data bugs alive right censoring 
naively averaging ob served lifespan treating truncation death sig underestimate real lifetime 
fortunately studied problem standard statistical solution kaplan meier km estimator 
kaplan meier estimator gives maximum likelihood dis tribution bug lifetimes bugs censored age age mean lives long 
kaplan meier estimator takes censored data account 
meaningful estimate data available serve basis extrapolation 
bugs real birth real death observed unsupervised runs block var null described previous subsection 
problem calculating lifetimes interference providing bug logs may shortened bug lifetimes 
previous errors released kernel developers 
sure exactly errors fixed error reporting evidence efforts shorten bug lifetime 
noticeable vertical edge versions 
edge corresponds significant number bugs having appearance 
specifically bugs died died previous release died 
finesse problem treating bugs die right censored doing results longer lifetime average years median years censor checker died censored mean yr median yr block null vat table average bug lifetimes predicted kaplan meier estimator 
died number bugs observed entire lifetime censored right censored 
mean standard error standard deviation random samples size true mean 
median triple lb ub lb lower confidence level median ub upper confidence level 
means statistic derivable data 
opposed average years median years censor 
estimate err long side unknown number bugs may removed interference 
consider problem interference rest section 
calculation bug lifetimes take account nature purpose development period measured 
traditionally odd re leases development versions incorporate new features fix bugs versions stable release ver sions changes bug fixes exceptions 
development odd versions proceeds parallel stabilization versions 
chosen model development path picking minor releases odd versions major releases versions 
choice allows linearly order versions time done exam ined minor releases versions 
set data points representing bug lifetimes kaplan meier km estimator derives maximum likelihood survivor function defined follows 
random variable representing lifetime bug 
survivor function fx gives probability bug lives long dl fx prix 
function di number bugs die time ri number bugs alive time including censored bugs 
shows km survival curve low false positive checkers combined 
dot ted curves surrounding curve show con band 
notice band grows rapidly bug lifetime increases 
increase due small number bugs data extremely long lifetimes 
possible bug lifetime maximum lifetime observed km curve gives probability random bug live long 
example curve shows approximately chance bug year percentage drops lifetimes years 
notice upper left hand corner curve sampling granularity 
significant number errors show single version count having lifetime zero 
graph estimate max imum error birth rate tolerated increasing total number bugs 
birth rate exceeds death rate kernel tend accrue er time converse holds errors gradually purged 
assuming km approxi mation errors manually inspect crude metric system tested audited sharp ward slope indicates rapid rate bug fixing horizontal slope indicates fewer bugs re moved time implication bug lifetimes longer 
surprised find errors tend live quite long time extinguished 
av erage bug lifetime calculated years median years 
table breaks number checker 
note shorter lifetime var compared block null 
indicates relative importance errors kernel developers due fact vat bug easy find bugs type string search 
hand relatively long average lifetime vat may mean easy errors removed rest difficult find didn cause stack overflows practice 
average age 
compute average age bugs particular version relatively small 
example average age bug year 
mesh estimate years average bug lifetime 
simple analogy human lifetimes clarifies situation 
suppose average person life expectancy years 
time take sample ages people find mean far years 
sample point version right censored get shorter average age average lifetime 
code hardening 
widely held systems belief code ages buggy presumably testing inspection gradually weed errors 
order test hypothesis calcu lated average number bugs file func tion file age 
ordered files notes ages equally divided buck ets computed aggregated error rate bucket checker 
shows older files tend lower error rates 
checkers shown newest quartile files average error rate twice high oldest quartile files 
correlation error rate file age 
block 


lock oo 
average file age days older files tend lower error rates 
bugs cluster 
errors independent type bug ap pears function file directory bug appear unit random unit 
reasons dependence incompetence ignorance 
programmer tence degrades error rates increase 
similarly pro grammer ignorant system restrictions tend errors programmer 
large systems programmers dependent errors cause error clustering parts os higher error rates global error rate 
section 
graphically shows clustering linux raw form compared clustering measured random events 

presents applies intuitive measurement clustering subsystems 
measurement rank subsystems auditing tems strong clustering rule rea clustering profitable candidates auditing 

presents applies global measure clustering compare system wide clus tering different types errors 
particular type error exhibits system wide clustering programmers probably ignorant partic ular rule interface involved 
implies rule interface abolished pro educated prevent errors 
views clustering figures shows graphical demonstration cluster ing block checker 
sort files num ber notes plot number errors file 
random distribution expect number errors relatively stable fraction number notes deviations far ex pected curve 
see spikes relatively weak correlation number notes indicate clustering 
way look clustering consider skew caused clustered bugs 
skew de number errors vs number notes block checker oo files ordered increasing number notes view block errors entire linux kernel 
files numbered number notes placed sorted order axis 
ran dom coin tosses expect number errors relatively stable fraction number notes 
absolute number notes file plotted right axis absolute number errors file plotted left axis 
scribe situation small portion lation files directories notes accounts large portion interesting cases 
shows clustering viewed skew distribution considering block checker 
axis place files ordered number bugs files bugs far left 
axis plot bugs remain files right point 
block checker far left curve ap total errors accounted files contain errors point 
note errors block checker occur files total files account errors block checker 
course threw bugs source random clustering er fall really independently placed 
comparison plot results random experiment run times distribution notes plot maximum minimum results far right curves 
things immediately apparent random experiment pre dicts files errors observed results errors accounted point point files 
clustering subsystems subsection calculate approximately observed cluster due chance chernoff bounds independent poisson trials 
met ric useful ranking subsystems auditing provide kernel metric global metric section 
suppose model call function return null pointer coin flip probability pb caller forgets check return value path uses pointer 
tak dir notes expect block checker net atm drivers drivers isdn drivers usb serial drivers isdn icn drivers net pcmcia drivers net wan lmc drivers isdn act drivers atm null checker fs udf drivers net drivers char drm drivers net pcmcia drivers pcmcia drivers scsi drivers char rio drivers telephony drivers ide table number notes bugs linux top clustered leaf directories 
expect expected number errors find errors distributed coin flips expect notes bug total number bugs divided total number notes entire kernel checker 
errors notes block errors notes null 
chernoff bound independent poisson trials calculate upper bound probability number bugs exceed expected number observed 
expected errors block rule programmers relatively ignorant cluster significantly null errors 
ing pb measured average rate errors entire linux kernel single function directory errors error 
test model compute likelihood randomly distributed errors cluster way observations directory linux distribution 
table lists leaf directories signif bugs expected number block null checkers 
apply chernoff bound poisson trials bound probability di bugs expected num ber errors pr number bugs directory expected number errors directory fraction actual number bugs exceeds expected number 
clustering exist probability directory expected reasonably large values close especially number directories samples relatively small 
extremely low bounds strong evidence errors randomly distributed clustering exists 
extreme likelihood seeing results net arm directory 
clustering turned caused primarily file called blocking function times spin lock held 
example single file drivers directory 
file errors caused cut paste errors copied places 
global clustering metric equation gives simple way rank clustering subsystems deviate coin flip process provide single summary metric clustering exists entire kernel 
rea son bound depends global error rate different error rate particular tems applied kernel difference error rates disappears bound mean 
example compare errors different checkers cluster entire kernel 
propose simple metric provides global quantitative measure clustering 
provide intuition metric consider possible arrange ments errors files shown table 
value metric seen example system number known errors provides quantitative way describing closely errors grouped 
intuitively row clustering row 
natural way formalize intuition note clustering aggregate measure far distribution errors deviates average file 
consider system units files exam ple 
el en denote number errors clustering skew block checker 
real 
random min random max 
ot 
files plot clustering skew files account errors 
maximum minimum shown curves random random 
curve real represents observed results 
bugs thrown files randomly expect curve real fall random max random 
arrangement clustering el xx xx xx xxx xxxx table possible arrangements errors files clustering value assigned ar clustering metric 
permutations arrangements result identical amounts clus tering shown 
unit 
ei average number errors unit 
clustering metric defined ei ei clustering formula similar formula variance el denominator total number errors total number units 
problem directly measure standard deviation variance metric clus tering number units arbitrary 
metrics difficult compare different clustering values number units different 
notice vari ance related tt clustering metric simply ratio variance mean 
statistical literature called dispersion index 
bio logical applications measure clustering tendency populations modeling burstiness network traffic 
main feature predicts distribution clustered random clustering random clustered random random taken mean poisson distribution 
distribution uniform clustering 
table shows value linux version broken checker value matters cal explained sec tion 
clustering metric computed twice notes units described files units 
chunks accurate measure clustering chunk equal number notes note rep resents opportunity error 
contrast files ignores fact different files contain dif ferent number notes 
remainder section focus clustering results chunks 
striking thing clustering data exception block checkers show clustering random 
param size checkers easy explain simply bugs show clustering 
chunks free intr lock checkers show clustering near uni form clustering 
hypothesize due level understanding pro 
example calls dis able interrupts know meaning disabling interrupts know leave disabled 
part interface program mer demonstrates knowledge interface knowledge 
result bugs find isolated mistakes 
null checkers show higher clustering values cluster random 
null checker programmers known functions return null 
checker believe clustering largely caused cut paste incorrect code 
clustering values greater potentially demon strate programmer understand doing places bugs 
block checker falls category 
programmer realize call blocking function interrupts disabled spin lock held 
knows rule fails know single function block 
case programmer understanding interface incorrect mistake repeatedly 
important note clustering values calculated including chunks bugs 
words numbers represent clustering chunks bugs 
include chunks numbers higher underestimate clustering 
ignore zero bug chunks compare numbers theoretical distribution calculated section 
relate clustering metric distribution errors way 
seen fitting logarithmic series curve data obtain value turn determines theoretical approximation variance equation 
ing approximation derives approximation cth eti log 
log series dis tribution derive approximations mean standard deviation value estimate clustering data 
table shows values eti son actual clustering values 
closer distribution errors follows log series distribution theoretical clustering close actual clustering 
example check ers block distribution shown actual clustering value file value 
theoretical clustering value case derived turn derived data judge predictive value equation give sense best estimate cluster ing log series distribution matches actual value 
discussion far discussed clustering comes 
simple hypothesis programmers dif ferent abilities poor programmers produce errors single place 
experience probably second important cause clustering 
important cause probably ignorance program mers appear ignorant relevant system rules produce highly concentrated clusters errors aware 
addition ignorance prevalence cut paste error clustering different device drivers versions suggests pro believe working code correct code 
unfortunately copied code incorrect placed context intended sumption goodness violated 
code simply executed making tested contain clusters errors 
initial cross validation openbsd linux simply bad system studying errors particularly useful 
provide initial examination possibility compare re cent linux openbsd releases checkers free null param 
older versions checkers rest controlled checker variation identical checker versions kernels 
difference text file specify names routines check routines disable interrupts free memory return poten tially null pointers manipulate user pointers 
checkers provide roughly uniform compar ison vulnerable types false positives kinds errors 
openbsd far factor fewer checked loca tions notes higher error rate check ers compared 
closest result null checker 
openbsd error rate error possibly failing calls roughly checker block free intr lock null parma size ex 
block chunks files 
table table shows clustering values bugs computed chunks notes chunk file 
values imply uniform distri bution random distribution frequencies follow poisson distribution indicate clus tering random 
values cth computed equation maximum likelihood value checker 
considering chunks block bugs cluster type null distant second 
float range vat checkers omit ted notes correspond number times rule checked 
worse linux rate 
intr checker versus 
free checker error rate times worse linux call site incorrect param checker arguably important factor worse 
fact numbers may biased un difference kernels 
openbsd errors hand verified openbsd implemen tor point fixed checked main kernel tree diagnosis 
contrast bugs linux diagnosed reported 
said numbers table give full picture code quality 
generic problems limited number check ers discussed section checkers examine low level operations give direct measurement design quality 
specific ac tual measurements part openbsd high error rate comes small number files see little sites 
skew especially true errors parma checker resided system compatibility layer sees limited 
checkers significantly fewer errors rest kernel 
related numerous projects static analysis find er 
indirectly contrast differ ent code bases primarily focus machinery methods find errors 
contrast assume way automatically getting errors concentrate errors 
system reliability studies focused checker null intr free param percentage bugs notes linux openbsd ratio linux openbsd linux openbsd table comparison shipping versions linux openbsd checkers 
checkers openbsd worse linux ranging worse factor 
error logs analysis system behavior fault injection testing 
consider 
performance studies operating systems rela tively look code quality os community 
defect studies come soft ware engineering tolerant fields data gathered post mortem inspec tion error logs defect reports typically high availability systems 
studies largely complementary 
focus naturally leads different questions consider causes faults effects predicted system mis handled 
error populations different tions 
main advantages contain realistically exploitable bugs treat bugs equally checks find higher level deeper errors checkers 
limitations 
impor tant restricted errors de diagnosed testing field 
errors biased modules paths workloads happened exercise give poten tially misleading view error properties bug distributions main focuses 
contrast suffer biases checkers de errors certain class paths regardless particular workload triggered 
consider representative sample studies 
gray surveyed outages tandem systems manually gathered bug reports classify causes outages 
subsequent study lee iyer looked memory dumps field software failures tandem guardian operating system collected year 
focused effectiveness fault detection recovery classifying errors type uninitialized variables race conditions 
chillarege examined mvs oper ating system failures classifying error causes man 
randomly sampled reports population gathered year pe 
main focus measuring errors caused memory corruption versus 
generated highest number reported system crashes 
measured bug fixes introduced bugs 
similar study databases 
xu reboot logs measure dependability node windows nt cluster months reboots 
classi fied causes failures hardware software time recover availability measurements 
interesting result reboots occur bursts similar finding errors cluster source code 
studies largely ignore questions address closer 
fenton examined faults con versions telecommunication switching sys tem 
strong support pareto prin hypothesis small number modules accounts large fraction faults es call skew 
specifically modules account faults discovered testing 
contrast linux files accounted errors automatic checkers 
numbers different keep mind take files modules unit basic point principle supported results 
smaller portion modules account operational failures 
basili report manually con study satellite planning software consisting loc spread modules functions 
reusing modules new purpose decreased initial development cost effort required correct errors 
tradeoff tween cost initial development time cost adapting modules new specification 
related area fault injection studies dynamically insert bugs system see crashes survives 
focus robustness face artificial errors interested features actual errors 
approach explicit testing fuzz studies compare set systems ties behaved face random inputs :10.1.1.32.7648
terms examining bugs automatic techniques closest compared study koopman randomized testing measure effectiveness error handling code different posix implementations 
measured types errors resulted silent machine crash caught caught overlap errors diversity different operating systems 
study measure ob applies tests uniformly set code biased locations programmers decided examine 
study advantage spans operating systems 
focus error handling general rules 
look limited portion os device drivers auxiliary code 
study address error behavior time 
uses roughly unique automatically de operating system errors test spot pat terns kernel code relative error rate drivers compared kernel code factor worse errors cluster roughly factor tightly random distribution long bugs average years 
gathered data years linux releases 
countered checker specific artifacts twelve au checkers errors objectively manual inspection hope 
view promising initial results 
hope researchers find results study useful understanding nature errors systems code 
peter glynn peter suggested discrete dis tributions maximum likelihood techniques test kaplan meier estimator 
consulting staff stanford depart statistics helpful guiding statistical analysis 
diane tang critical reading greatly improved presentation clarity structure 
ken evan parker contributing range check ers inspecting results 
readers linux kernel generous feedback support 
alan cox verified fixed errors re ported linux kernel 
costa inspected error logs openbsd committed fixes cvs repository 
linus torvalds inspected near final draft provided helpful comments clustering 
shepherd mike jones careful reading valuable feedback 
supported nsf award darpa contract mda 
aiken fahndrich su 
detecting races relay ladder logic programs 
proceedings ist international conference tools algorithms construction analysis systems april 

fabre laprie martins powell 
fault injection dependability validation methodology ap plications 
ieee transactions software engineering february 
basili 
software errors complex ity empirical investigation 
communications association computing machinery 
bishop 
checking race conditions file accesses 
computing systems pages spring 
chen endo chan dias smith seltzer 
measured performance personal computer operating systems 
acm transactions computer systems tocs february 
chillarege bowen 
understanding large system failures fault injection experiment 
inter national symposium fault tolerant computing june 
cox 
analysis survival data 
chap man hall london uk 
engler chelf chou hallem 
checking system rules system specific programmer written compiler extensions 
proceedings operating systems design implementation osdi september 
fenton 
quantitative analysis faults failures complex software system 
ieee transactions software engineering au 
gray 
census tandem system availability 
ieee transactions software engineer ing october 

technical prefix enterprise 
technical report 
johnson kotz 
discrete distributions 
john wiley sons new york ny 
philip koopman jr john sung christopher ding man daniel siewiorek ted 
comparing op erating systems robustness benchmarks 
reliable distributed systems pages 
kanawati kanawati abraham 
ferrari flexible software fault error injection sys tem 
ieee transactions software engineering february 
lee iyer symptoms 
faults symptoms software fault tolerance tandem guardian op erating system 
international symposium fault tolerant computing ftcs 
leland willinger wil son 
self similar nature ethernet traffic 
acm sigcomm pages san francisco nia 
miller 
empirical study reliability unix utilities 
communications association computing machinery 
miller koski lee murthy natarajan 
fuzz revisited re examination reliability unix utilities ser vices 
technical report cs tr university wisconsin 
motwani raghavan 
randomized algorithms 
cambridge university press cambridge uk 
perl sites 
studies windows nt perfor mance dynamic execution traces 
operating sys tems design implementation pages 
rosenblum bugnion herrod witchel gupta 
impact architectural trends operating system performance 
symposium operating systems principles pages 

statistical inference 
chapman hall lon don uk 
sullivan chillarege 
software defects impact system availability study field fail ures operating systems 
international fault tolerant computing june 
sullivan chillarege 
comparison software defects database management systems operating systems 
nd international symposium fault tolerant computing july 
wagner foster brewer aiken 
step automated detection buffer overrun 
network distributed systems security conference 
san diego ca february 
xu iyer 
networked windows nt system filed failure data analysis 
proc 
pacific rim international symposium dependable computing 
