optimally profiling tracing programs thomas ball research bell labs com james larus larus cs wisc edu july appears acm transactions programming languages systems july 
copyright association computing machinery permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists requires prior specific permission fee 
request permissions publications dept acm fax permissions acm org 
optimally profiling tracing programs thomas ball james larus university wisconsin madison describes algorithms inserting monitoring code profile trace programs 
algorithms greatly reduce cost measuring programs respect commonly technique placing code basic block 
program profiling counts number times basic block program executes 
instruction tracing records sequence basic blocks traversed program execution 
algorithms optimize placement counting tracing code respect expected measured frequency block edge program control flow graph 
implemented algorithms profiling tracing tool substantially reduce overhead profiling tracing 
define study hierarchy profiling problems 
problems dimensions profiled vertices basic blocks edges control flow graph instrumentation code placed blocks edges 
compare optimal solutions profiling problems describe new profiling problem basic block profiling edge counters 
problem important optimal solution profiling problem control flow graph better optimal solution problem 
unfortunately finding optimal placement edge counters vertex profiling appears hard problem general 
shows edge profiling edge counters works practice simple efficient finds optimal counter placements cases 
furthermore yields information vertex profile 
tracing benefits placing instrumentation code edges vertices 
categories subject descriptors performance systems measurement techniques software engineering tools techniques programmer workbench software engineering testing debugging diagnostics tracing general terms algorithms measurement additional key words phrases profiling instruction tracing instrumentation control flow graph 
known technique recording program behavior measuring program performance insert code program execute modified program 
discusses insert monitoring code profile trace programs 
program profiling counts number times basic block control flow edge program executes 
widely measure instruction set utilization identify program bottlenecks estimate program execution times code optimization 
instruction tracing records sequence basic blocks traversed program execution 
basis trace driven architectural simulation analysis trace driven debugging 
techniques implemented wide variety systems 
preliminary version appeared th symposium principles programming languages january 
supported part national science foundation ccr ccr wisconsin research foundation 
authors current addresses ball rd box il 
email research att com larus computer sciences department univ wisconsin dayton st madison wi 
email larus cs wisc edu describe algorithms placing profiling tracing code greatly reduce cost measuring programs compared previously implemented approaches 
algorithms reduce measurement overhead ways inserting instrumentation code placing code executed 
algorithms implemented widely distributed profiling tracing tool called qpt instruments executable files performs practice 
described section considerable efficiently profiling tracing programs 
factors significantly distinguish previous 
consider theoretic algorithmic underpinnings program profiling tracing 
second previous implemented algorithms experimented different instrumentation strategies collection real programs 
experience exposed deficiencies previous algorithms led extensions algorithms robust practical 
third implemented compared strategies profiling tracing 
approaches categorized measure basic block control flow edge frequency place instrumentation code basic blocks control flow edges 
categorization helps relate efficiency various approaches 
categorization identified new problem previously considered basic block profiling edge counters 
characterizes new problem compares existing approaches 
algorithms produce exact basic block profile trace contrasted statistical tool prof command samples program counter program execution 
algorithms consist pre execution phase post execution phase 
phase selects points program insert profiling tracing code 
instrumentation code inserted points producing instrumented version program 
algorithms inserting instrumentation profiling tracing nearly identical 
compute spanning tree program control flow graph place instrumentation code control flow graph edges spanning tree 
profiling instrumentation code increments counter records times edge executes 
tracing instrumentation code writes unique token witness trace file 
placement instrumentation code optimized respect weighting assigns frequencies edges vertices 
weightings obtained empirical measurement profiling estimation 
instrumented program executes second phase uses results collected execution program control flow graph derive complete profile trace 
major contributions enumerate space profiling problems profiled profiling code placed 
vertex profile counts number executions vertex basic block controlflow graph 
edge profile counts number times control flow edge executes 
edge profile determines vertex profile converse hold 
knuth published efficient algorithms finding minimum number vertex counters necessary sufficient vertex profiling denoted vprof vcnt minimum number edge counters edge profiling denoted eprof ecnt 
consider new problem finding set edge counters vertex profiling vprof ecnt characterize set instrumented edges necessary sufficient vertex profiling 
relate optimal solutions profiling problems vprof vcnt eprof ecnt vprof ecnt compare run time overhead practice 
show cfg weighting optimal solution vprof vcnt ecnt better optimal solution vprof ecnt 
unfortunately finding optimal solution vprof ecnt hard problem general 
believe problem np complete proof 
show large class structured control flow graphs optimal solution eprof ecnt optimal solution vprof ecnt 
furthermore show eprof ecnt lower overhead vprof vcnt practice 
show profiling tracing placing instrumentation code edges better placing vertices 
intuitively edges vertices controlflow graph 
instrumenting edges provides opportunities place instrumentation code areas low execution frequency 
give simple heuristic estimating execution frequencies analysis controlflow graph accurately predicts areas low execution frequency place instrumentation code 
show solution profiling problem sufficient solve tracing problem 
solution necessarily optimal 
ramamoorthy kim chen necessary sufficient condition set edges solves tracing problem single procedure programs 
condition multi procedure programs 
reformulate condition intuitive manner show extended apply programs 
shows knuth algorithm eprof ecnt profiling algorithm choice profiling simple efficient finds optimal counter placements cases yields information vertex profile measuring edge frequency vertex frequency 
show extend algorithm handle early procedure termination caused exceptions 
emphasize algorithms solely control flow information 
applicable control flow graph 
graphs need reducible properties preclude analysis programs 
algorithms semantic information derived program text constant propagation induction variable analysis 
information reduce amount instrumentation code needed profile trace program 
remainder organized follows 
section provides background material control flow graphs weightings spanning trees 
section shows profile programs efficiently section describes trace programs efficiently 
section presents heuristic weighting algorithm 
section presents performance results 
section reviews related profiling tracing heuristics minimizing instrumentation overhead estimating execution frequency 
section concludes 

background presents algorithms instrumenting programs record information behavior 
algorithms intraprocedural control flow structure programs order determine place instrumentation code 
programs consideration assumed written imperative language procedures control flow procedure statically determinable 
interprocedural control flow occurs mainly procedure call procedure return show algorithms extended handle exceptions interprocedural jumps 
procedures class objects affect instrumentation algorithms 
algorithms require control flow graph constructed procedure program 
necessary know procedure called particular call site 
review graph terminology 
directed graph consists set vertices set edges edge ordered pair vertices denoted note parallel edges vertices allowed notation abbreviation 
vertex source edge denoted src vertex target edge denoted tgt 
edge incoming edge vertex outgoing edge vertex ifv vertex predecessor vertex vertex successor vertex path directed graph sequence vertices edges form en vn edge ei ei vi vi ei vi vi 
cycle path vn 
path cycle directed edge ei ei vi vi 
simple cycle cycle vn distinct 
cycle simple edges cycle distinct converse true 
terms path cycle denote undirected paths cycles 
edge direction important explicitly state path cycle directed 
control flow graph cfg rooted directed graph corresponds procedure program way vertex represents basic block instructions straight line sequence instructions edge represents transfer control basic block 
addition cfg includes special vertex exit corresponds procedure exit return 
root vertex basic block procedure 
directed path root vertex directed path vertex exit 
profiling algorithm convenient insert edge exit root cfg strongly connected 
edge correspond actual flow control instrumented 
exit vertex successors root vertex 
vertex predicate distinct vertices weighting cfg assigns non negative value integer real edge subject flow law vertex sum weights incoming edges equal sum weights outgoing edges weight vertex sum weights incoming outgoing edges 
cost set edges vertices sum weights edges vertices set 
execution procedure represented directed path ex cfg begins root vertex procedure entry ends exit procedure return 
frequency vertex edge execution ex number times appears ex 
vertex edge appear ex frequency zero execution frequency edge exit root defined number times exit appears execution 
edge frequencies execution cfg constitute weighting cfg 
spanning tree directed graph subgraph pair vertices connected unique path connects vertices cycles 
maximum spanning tree weighted graph cost tree edges maximal 
maximum spanning tree graph computed efficiently variety algorithms 
illustrates definitions 
graph cfg program shown 
graph weighting 
second graph maximum spanning tree graph 
note vertex spanning tree serve root direction edges tree program fi break fi od exit 
program cfg weighting maximum spanning tree 
edge exit needed flow equations root vertex exit consistent 
edge correspond actual flow control instrumented 
cycle diamond piped cycles 
classification cycles 
exit directed cycle unimportant 
example vertices exit connected spanning tree path exit 
underlying concept instrumentation problems consider certain cycles cfg contain instrumentation code instrumentation code break certain cycles 
classify cycles direction edges 
consecutive vertices cycle 
fork pipe 
cycle contains pipes direction edges strictly alternate cycle 
cycle piped contains pipe 
piped cycles classified directed cycle contains pipes edges direction diamond cycle distinct edges exactly fork join changes direction cycle cycles piped cycles 
gives examples cycles 

program profiling order determine times basic block program executes program instrumented counting code 
simplest approach places counter basic block pixie instrumentation tools method 
drawbacks approach counters total number increments execution larger necessary 
vertex profiling problem denoted vprof cnt determine placement counters cnt set edges vertices cfg frequency vertex execution deduced solely cfg measured frequencies edges vertices cnt 
furthermore reduce cost profiling set cnt minimize cost weighting similar problem edge profiling problem denoted eprof cnt determine placement counters cnt cfg frequency edge execution deduced solely cfg measured frequencies edges vertices cnt 
solution edge frequency problem obviously yields solution vertex frequency problem summing frequencies incoming outgoing edges vertex 
place counters vertices edges counter placement take forms set edges ecnt set vertices vcnt mixture edges vertices 
combined profiling problems yields possibilities 
consider eprof vcnt cfgs solutions problem 
possible determine edge frequencies vertex frequencies 
mixed placements interest placing counters vertices edges eliminates need insert unconditional jumps 
hand vertex executed frequently outgoing edges implying worthwhile instrument outgoing edges vertex 
usefulness mixed placements depends cost unconditional jump relative cost incrementing counter memory 
risc machines constructed profiling tool code sequence incrementing counter generating tracing token ranges instructions cycles 
cost unconditional branch quite small comparison usually cycle delay slot unconditional branch filled useful instruction 
case questionable benefit mixed placements 
fact samples shown mixed placements provide little benefit edge placements machine increment branch costs comparable worse cases 
furthermore shown section benchmarks examined half instrumented edges quarter total number control flow edges required unconditional jumps profiling edge counters 
reasons consider mixed counter placements 
focus remaining profiling problems vprof vcnt eprof ecnt vprof ecnt 
section presents results comparison optimal solutions vprof vcnt eprof ecnt vprof ecnt 
summarizes relationship problems general cfgs 
means placing instrumentation code edges cfg essentially creates new basic blocks may require insertion unconditional jumps assuming linearization original basic blocks instrumented program original program 
hand placing instrumentation code vertices simply expands extent original basic blocks require insertion jumps 
possible rearrange placement basic blocks minimize number unconditional jumps needed discussed solomon 
algorithms perform optimization respect original linearization 
cfg weighting optimal solution problem cost equal cost optimal solution problem general weighted cfg optimal solution vprof ecnt cheap eprof ecnt vcnt 
characterization set edges ecnt necessary sufficient eprof ecnt algorithm solve eprof ecnt optimally 
describe problem introduced early procedure termination simple solution 
characterization set edges ecnt necessary sufficient vprof ecnt 
appears difficult efficiently find minimal size cost set edges 
show optimal solution eprof ecnt optimal solution vprof ecnt large class structured cfgs heuristic solving vprof ecnt eprof ecnt algorithm subcomponent 
discussion time complexity profiling tracing problems characterization cycle breaking problems 

comparing profiling problems section examines relationships optimal solutions vprof vcnt eprof ecnt vprof ecnt general cfgs summarized 
cfgs illustrate optimal solutions vprof vcnt eprof ecnt vprof ecnt weighting cfg 
black dots represent counters 
costs counter placements respectively 
case counter necessary uniquely determine profile lower cost placements suffice 
example counter vertex case eliminated impossible determine times executed 
case counts vertices exit directly measured deduced measured vertices follows exit case count unmeasured edge uniquely determined counts measured edges flow law 
case count unmeasured edge set uniquely determined measured edges 
yields information deduce count vertex 
eprof ecnt eprof ecnt vprof ecnt vprof vcnt vprof ecnt vprof vcnt 
relationship costs optimal solutions frequency problems general cfgs 
relationship cfgs constructed loops conditionals blocks 
cost exit cost cost 
optimal solutions vertex profiling vertex counters edge profiling edge counters vertex profiling edge counters 
exit vprof vcnt eprof ecnt vprof ecnt cfg weighting optimal solution vprof vcnt lower cost optimal solution vprof ecnt vertex vcnt counter pushed outgoing edge resulting counter placement ecnt clearly solves vertex profiling problem cost equal vcnt 
shows example vprof ecnt lower cost vprof vcnt 
counter placement case solves vprof ecnt lower cost counter placement case solves vprof vcnt 
solution eprof ecnt solve vprof ecnt optimal solution eprof ecnt lower cost optimal solution vprof ecnt cfg weighting 
counter placement case solves vprof ecnt lower cost counter placement case solves eprof ecnt 
comparing eprof ecnt vprof vcnt examples lower cost vice versa 
cases show example eprof ecnt lower cost vprof vcnt 
easily modified show example vprof vcnt lower cost eprof ecnt 
consider black dot vertex right split dotted edge edges 
dots constitute set vcnt solve vprof vcnt cost 
optimal solution eprof ecnt graph cost 
exit 
edge profiling edge counters eprof ecnt solved placing counter outgoing edges predicate vertex 
placement uses counters necessary 
knuth describes follows law edge counter placement ecnt solves eprof ecnt cfg iff ecnt contains undirected cycle 
spanning tree cfg represents maximum subset edges cycle follows ecnt minimum size solution eprof ecnt iff ecnt spanning tree minimum number counters necessary solve eprof ecnt 
see placement solves edge frequency problem consider cfg set ecnt ecnt spanning tree edge ecnt associated counter initially set incremented time executes 
vertex leaf spanning tree tree edge incident remaining edges incident ecnt 
edge frequencies execution satisfy law unmeasured edge frequency uniquely determined flow equation known frequencies incoming outgoing edges remaining edges unknown frequency form tree process repeated frequencies edges ecnt uniquely determined 
ecnt contains cycles spanning tree ecnt forest trees 
approach applied tree separately determine frequencies edges ecnt 
known maximum spanning tree algorithms described tarjan efficiently find maximum spanning tree cfg respect weighting 
edges spanning tree solve eprof ecnt minimize cost ecnt 
result counters placed areas lower execution frequency cfg 
ensure counter placed exit root maximum spanning tree algorithm seeded edge exit root 
fact cfg weighting maximum spanning tree includes edge exit root 
derived count edge exit root represents number times procedure associated cfg executed 
illustrates frequencies edges ecnt derived frequencies edges ecnt 
black dots identify edges ecnt 
edges ecnt form spanning tree cfg 
edge frequencies execution shown 
emphasize edges frequencies recorded edges black dots 
vertex root spanning tree 
vertex leaf spanning tree flow equation 
frequencies known substitute equation derive frequency frequency known frequency derived flow equation 
weighting counter placement cost 
shows counter placement induced maximum spanning tree resultant cost 
propagation algorithm performs post order traversal spanning tree ecnt propagate frequencies edges ecnt unprofiled edges spanning tree 
procedure dfs calculates frequency spanning tree edge 
calculation carried post order line dfs ecnt reached counts edges incident vertex calculated 
flow equation states sum incoming edges equal sum outgoing edges 
sums includes count edge initially set 
count subtracting minimum sums maximum 
execution exit exit 
solving eprof ecnt spanning tree 
weighting counter placement case optimal minimal cost counter placement case optimal 
profiling described terms single cfg algorithm requires changes deal multi procedure programs 
pre execution spanning tree algorithm post execution propagation edge frequencies applied procedure cfg separately 
simple extension multi procedure profiling determine correct frequencies interprocedural control flow occurs procedure call return call eventually corresponding return 
interprocedural jumps procedure call return handled adding edges corresponding interprocedural jumps instrumenting edges 
determining interprocedural edge needs instrumented require interprocedural analysis perform 
problem arises dynamically computed interprocedural jumps setjmp longjmp language early program termination may caused system call error condition 
cases procedures terminate reaching exit vertex breaking law 
example suppose cfg executes path shown top 
furthermore suppose execution terminates early vertex divide zero error 
result control enters vertex edge exits propagation algorithm see assumes law holds vertex edge receive count shown 
example count 
general multiple procedures activation stack exited early early exiting common occurrence counts may diverge greatly 
purposes determining frequencies intraprocedural control flow edges matter procedures functions class objects 
programs fixed call graph structure intraprocedural frequency information sufficient determine frequency edges call graph 
programs procedure function parameters tool record callee call sites callee determined run time 
exit global control flow graph edges cnt array edge integer edge ecnt cnt frequency execution procedure propagate counts ecnt set edges ecnt cnt od dfs ecnt root vertex null procedure dfs ecnt set edges vertex edge tgt src sum ecnt dfs ecnt src fi sum sum cnt od sum ecnt dfs ecnt tgt fi sum sum cnt od null cnt max sum sum min sum sum fi ni 
edge propagation algorithm determines frequencies edges spanning tree ecnt frequencies edges ecnt 
algorithm uses post order traversal spanning tree 
execution exit divide 
early termination vertex yields incorrect counts corrected addition edge exit 
exit case information available activation stack sufficient correct count error 
conceptually procedure activation stack exits early edge exit count added procedure cfg vertex procedure called procedure 
edge models early termination procedure vertex practice edge exit represented exit counter associated vertex counter incremented time procedure exits early vertex early termination caused conditional exception divide zero increment code placed exception handler vertex code invoked raises exception 
early termination caused increment code handler may pop activation frames stack requires incrementing associated exit counter 
illustrates early exit problem solved 
procedure terminates early vertex edge exit added cfg count 
additional edge correctly incoming flow vertex propagation algorithm yields correct counts 
shown case edge correctly receives count 

vertex profiling edge counters section addresses problem vertex profiling edge counters 
section characterizes set edges ecnt solves vprof ecnt gives algorithm propagating edge frequencies cfg order determine vertex frequencies 
discussed section appears difficult solve vprof ecnt efficiently minimizing size cost ecnt 
discussed section certain classes cfgs optimal solution eprof ecnt optimal solution vprof ecnt 
class cfgs counter placements induced maximum spanning tree optimal 
section presents heuristic finding ecnt placement solve vprof ecnt improves spanning tree approach certain situations 

characterization algorithm edge profiling edge counters requires undirected cycle cfg contain counter 
edge profile determines vertex profile vertex profiling requires edge counters edge profiling 
illustrated example cases fewer edge counters needed vertex profiling edge profiling 
example cycle counter free edges information recorded determine frequency vertex 
section formalizes observation 
certain types counter free cycles allowed edge counters vertex profiling captured theorem theorem 
set edges ecnt solves vprof ecnt cfg iff simple cycle ecnt edges simple cycle ecnt alternate directions 
cycles allowed ecnt non simple piped cycles long simple cycles compose 
counter free cycle represented set edges 
counter free edges contain piped cycle cycle simple 
simple counter free cycles example 
freq function mapping edges cfg frequency execution 
give algorithm frequencies edges ecnt execution assumption ecnt contains simple piped cycle find function freq edges frequencies vertex frequency equivalent freq 
vertex sum frequencies incoming outgoing edges freq freq 
explain algorithm show operates example 
prove correctness algorithm showing ecnt contains simple piped cycle ecnt solves vprof ecnt 
show ecnt contains simple piped cycle possible ecnt solve vprof ecnt 
presents propagation algorithm 
frequencies edges ecnt determined execution ex 
algorithm operates follows simple cycle set edges ecnt break edge cycle added set break frequency edge initialized zero 
ecnt break acyclic follows frequencies edges ecnt break uniquely determine frequencies edges spanning tree propagation algorithm 
show vertex frequencies determined edge frequencies true vertex frequencies execution ex 
presents example algorithm works 
cfg contains simple cycles ecnt 
usual edges ecnt marked black dots 
counter free simple cycles clearly 
simple cycles combine non simple cycle containing pipe allowed structural characterization vprof ecnt 
edges cfg numbered frequencies execution 
frequencies checked edges derived easily frequencies edges ecnt 
frequencies count vertex grey vertex clearly determined 
derive counts edges simple cycles order determine frequency grey vertex 
suppose algorithm chooses break simple cycles ecnt putting dashed edges see set break giving frequency shown case 
spanning tree propagation edge frequencies set ecnt break edges ecnt break assign unique frequencies edges simple cycles shown case 
sum frequencies incoming outgoing edges grey vertex correct frequency frequencies edges cycle execution 
assumption ecnt contains simple piped cycle edge ecnt cnt frequency execution break simple cycle ecnt break edge break break cnt ni od propagate counts ecnt break 
algorithm propagating edge counts determine vertex counts 

example cfg ecnt contains simple cycles 
dashed edges assigned frequency spanning tree propagation assign remaining edges simple cycles frequencies shown 
yields count grey vertex correct frequency 
prove correctness algorithm 
freq function mapping edges cfg frequency execution freq function edges frequencies created algorithm 
show freq vertex frequency equivalent freq induction size break determined algorithm 
base case break 
case ecnt contains cycles 
ecnt solves eprof ecnt freq freq 
follows directly freq vertex frequency equivalent freq 
induction hypothesis break freq vertex frequency equivalent freq 
induction step suppose break 
consider edge break putting ecnt resulting sets 
induction hypothesis function defined vertex frequency equivalent freq 
show function freq vertex frequency equivalent completing proof 
ecnt break 
addition edge creates simple cycle define function function edge cycle shown 
show function properties function vertex frequency equivalent function satisfies flow law vertex edge ecnt break freq 
points imply freq identical functions values edges ecnt break uniquely determine values edges flow law 
point implies freq vertex frequency equivalent 
function defined follows freq edge cycle edge cycle direction edge show flow law holds vertex vertex frequency equivalent 
obvious vertices frequency edge incident vertex 
vertex appears fork join cycle edges incident subtracted frequency added frequency preserving flow law vertex frequency prove point 
clear freq 
show edge ecnt freq 
definition edge 
cycle contains edges ecnt 
freq edges ecnt follows edge freq 
ecnt contains simple piped cycle executions different frequencies vertex frequencies edges ecnt 
clear ecnt contains directed cycle edge disjoint directed paths pair vertices diamond 
gives example cfg ecnt contains piped cycle pipe vertex directed cycle diamond shows different execution paths 
execution paths traverse instrumented edge exactly 
ex contains vertex ex 
way look edge frequencies cycle ecnt unconstrained 
function mapping edges values satisfies flow law vertex 
applying function transformation defined proof piped cycle ecnt results exit ex ex exit exit exit exit 
example instrumentation sufficient vertex profiling 
dashed edges cfg constitute simple cycle uninstrumented edges pipe vertex 
executions ex ex traverse instrumented edge number times ex contains ex 
function flow law holds vertex 
frequency vertex fork join cycle remains shown frequency vertex pipe changed 

cases eprof ecnt vprof ecnt section examines class cfgs optimal solution vprof ecnt efficiently optimal solution eprof ecnt optimal solution vprof ecnt 
represent cfgs cycle contains pipe 
cfg weighting statements equivalent ecnt minimal cost set edges ecnt contains simple piped cycle ecnt maximum spanning tree follows directly observations cfg optimal solution eprof ecnt optimal solution vprof ecnt 
class graphs contains cfgs multiple exit loops cfgs generated gotos irreducible graphs 
class contains structured cfgs generated loops conditionals blocks simple cycle cfgs directed cycle diamond 
general cfgs programs repeat loops breaks members cfg example graph 

heuristic vprof ecnt believe vprof ecnt hard problem solve optimally developed heuristic vprof ecnt 
heuristic computes maximum spanning tree st inducing counter placement edges tree checks counters removed creating simple piped cycles set counter free edges 
algorithm heuristic 
heuristic observation st spanning tree edge st addition st creates precisely simple cycle ce st heuristic examines cycle ce turn 
prevent counter free cycles combining simple counter free piped cycle marks vertices cycle ce counter removed counter removed remove unmark vertices find maximum spanning tree st edge st decreasing order weight add st cycle ce st vertex ce marked mark vertex ce remove remove fi remove st od 
heuristic vprof ecnt 
edge cycle ce contains marked vertices 
heuristic described detail 
termination set remove contains edges counters removed safely 
considering edges decreasing order weight algorithm tries remove counters higher cost 
consider application heuristic cfg 
case shows counter placement resulting maximum spanning tree algorithm 
removing counter edge creates cycle set counter free edges 
removing counter edge creates piped cycle set counter free edges 
example heuristic produces optimal counter placement case 
examples heuristic find optimal solution vprof ecnt 

cycle breaking problems problems profiling tracing programs edge instrumentation described cycle breaking problems certain types cycles cfg contain instrumentation code order solve profiling tracing problem 
summarizes classification cycles section problems correspond known time complexity optimally breaking class cycle 
solving eprof ecnt corresponds breaking undirected cycles 
solving vprof ecnt corresponds breaking simple piped cycles shown section 
discussed section solving tracing problem corresponds breaking directed cycles diamonds 
course interested minimum cost set edges breaks certain class cycles 
finding minimum size set edges breaks directed cycles np complete problem feedback arc set 
maheshwari showed finding minimum size set edges breaks diamonds np undirected cycles vprof ecnt piped cycles cycles directed cycles diamonds np np eprof ecnt trace ewit 
hierarchy cycles profiling tracing problems correspond time complexity breaking cycles type polynomial np np complete 
unknown 
np complete subgraph 
minimizing respect weighting satisfies flow law problems easier 
furthermore easy show optimally breaking directed cycles diamonds easier problem isolation 
solving tracing problem cost instrumented edges minimized np complete problem shown unpublished result 
reduction similar maheshwari complicated requirement weighting satisfies flow law 
believe optimally solving vprof ecnt minimizing size cost ecnt np complete problem proof 
shown related problem finding minimum size set edges breaks pipes np complete 
breaking pipes guarantees piped cycles broken necessarily optimally possible break piped cycles breaking pipes 

program tracing just program instrumented record basic block execution frequency instrumented record sequence executed basic blocks 
tracing problem record information program execution reproduce entire execution 
straightforward way solve problem instrument basic block executes writes unique token called witness trace file 
case trace file need read regenerate execution 
efficient method write witness basic blocks targets predicates 
code execution predicate trace file program cfg pc root vertex output pc pc pc successor pc pc read trace fi output pc pc exit assuming standard representation witnesses byte half word word witness tracing problem solved significantly time storage overhead solution writing witnesses edges traversed vertices executed carefully choosing witnessed edges 
section formalizes tracing problem single procedure programs 
section considers complications introduced multi procedure programs 

single procedure tracing section assume basic blocks contain calls extra edge exit root included cfg 
set instrumented edges cfg denoted ewit 
tracing edge ewit traversed witness edge execution written trace file 
assume edges ewit generate witness stronger necessary may possible reuse witnesses cases 
statement tracing problem relies definitions definition 
path cfg witness free respect set edges ewit iff edge path ewit 
definition 
cfg set edges ewit edge predicate witness set vertex predicate witness ewit ewit writes witness ewit writes witness witness free path eof witness free path exit illustrates definitions 
witness abbreviation witness ewit 
examine execution regenerated trace 
re execution starts predicate root vertex 
determine successor read witness trace member witness witness 
vertex execution 
vertex follows execution sole successor edge produced witness traversed read witness 
witness member witness witness exit vertex follows vertex witness valid edge traversed determines successor 
continuing manner original execution reconstructed 
witness member witness ewit witness ewit different executions may generate trace regeneration solely control flow trace information impossible 
example edge generate witness witness eof witness 
executions exit exit generate trace eof 
motivates definition tracing problem execution trace witness witness exit eof witness witness witness exit witness exit eof 
example traced function 
vertices predicates 
witnesses shown labeled dots edges 
execution shown trace generated eof 
witness eof witness trace 
execution reconstructed trace witness sets guide branches take 
definition 
set edges ewit solves tracing problem cfg denoted trace ewit iff predicate successors qm pairs qi qj witness ewit qi witness ewit qj 
straightforward show ewit solves trace ewit cfg iff ewit contains diamonds directed cycles 
optimally breaking diamonds directed cycles np complete problem discussed section 
note solution eprof ecnt vprof ecnt solution trace ewit breaking undirected cycles simple piped cycles guaranteed break directed cycles diamonds 
edges maximum spanning tree cfg comprise ewit solve trace ewit necessarily optimally 
cfg optimal solution eprof ecnt optimal solution trace ewit directed cycles diamonds piped cycles cycle cfg piped 
cfg set edges ewit solves trace ewit trace produced execution ex algorithm execution ex 

multi procedure tracing unfortunately tracing extend easily multiple procedures profiling 
complications illustrate cfg 
suppose basic block contains call procedure execution proceeds procedure called 
returns suppose executes 
call creates problems regeneration process witnesses generated procedure procedures invokes possibly enormous number precede witness trace file 
procedure regenerate cfg ewit set witnessed edges trace file witnesses declare pc vertices wit witness pc root vertex wit read trace output pc pc successor pc wit witness ewit pc fi pc ewit wit read trace fi pc output pc pc exit 
algorithm regenerating execution trace 
order determine branch predicate take witnesses generated procedure buffered witness set information propagated calls returns call graph edges control flow edges 
solution impractical number witnesses may buffered unbounded 
second solution expensive need propagate information interprocedurally complicated multiple calls procedure calls unknown procedures recursive calls 
furthermore witness numbers reused different procedures greatly reduces amount storage needed witness second approach complicated 
separate trace file maintained procedure problems disappear extending tracing multiple procedures quite straightforward 
solution practical toy programs obvious reasons 
solution places blocking witnesses edges paths predicate call site predicate exit vertex 
ensures regeneration procedure cfg reads witness determine branch predicate take witness generated edge definition 
set ewit blocking property cfg iff predicate witness free directed path exit vertex vertex containing call 
definition 
set ewit solves tracing problem set cfgs gm iff solves trace gi blocking property gi 
regeneration algorithm need modified maintain stack currently active procedures 
algorithm encounters call vertex pushes current cfg name pc value stack starts executing callee 
algorithm encounters exit vertex pops stack resumes executing caller 
easy way ensure ewit blocking property include incoming edge call exit vertex ewit 
illustrates approach suboptimal 
shaded vertices call vertices 
subgraph blocking witness placed incoming edge call vertex black dots 
addition witness needed edge white dot 
placement suboptimal witness edge needed witnesses edges cost replaced witnesses edges cost 
second subgraph blocking witnesses placed far call vertices possible resulting optimal placement 
consider call vertex directed path predicate vertex path predicate 
weighting placing blocking witness outgoing edge predicate path cost equal placing blocking witness incoming edge vertex predicate 
placing blocking witnesses far away possible ensures blocking witnesses redundant 
furthermore placing blocking witnesses fashion increases likelihood solve trace ewit 
tracing applications data witnesses addresses written trace file 
vertices cfg generate addresses blocked witnesses address mistakenly read witness 
feasible situation break trace file files witnesses addresses avoid placing blocking witnesses 
cost cost 
placements blocking witnesses suboptimal placement optimal placement 
blockers blockers blockers general case blocking witness placement solve trace ewit 
computing ewit step process place blocking witnesses ensure trace ewit solved adding edges ewit 
details algorithm follow definition 
vertex cfg blockers defined follows blockers path xn predicate xn xi predicate vertex call exit vertex edges blockers added ewit initially empty 
ensure ewit solves trace ewit add additional edges ewit ewit contains diamonds directed cycles 
maximum spanning tree algorithm modified add edges 
edge ewit allowed spanning tree 
edges spanning tree added ewit guarantees ewit solves trace ewit 
applying algorithm control flow fragment blocking phase adds black dot edges ewit 
spanning tree phase adds white dot edge ewit 
question better reverse process compute ewit solves trace ewit maximum spanning tree algorithm add blocking witnesses needed 
shows approach yield undesirable results 
black dot edges placed spanning tree phase solve trace ewit satisfy blocking property 
white dot edge added satisfy blocking property creates suboptimal ewit 
modified spanning tree algorithm may able create spanning tree edges ewit 
case algorithm simply identifies maximal cost set edges ewit contains undirected cycle 
cost cost 
ordering blocking witness placement spanning tree placement affects optimality 

heuristic weighting algorithm order profile trace efficiently instrumentation code placed areas low execution frequency 
may appear find areas low execution frequency requires profiling 
structural analysis cfg accurately predict portions frequently executed 
section presents simple heuristic weighting edges solely control flow information 
shown section simple heuristic quite effective reducing instrumentation overhead 
basic idea give edges deeply nested conditional control structures lower weight areas frequently executed 
general path loop requires instrumentation 
loop containing conditionals instrumentation deeply nested possible 
cfg heuristic generate weighting shown case 
weighting cfg edge frequencies satisfying flow law assigns edge non zero weight give edges deeply nested lower weight 
discussed section expensive matrix oriented methods generating weightings 
heuristic advantage requires depth search topological traversal cfg 
heuristic steps 
depth search cfg root vertex identifies backedges cfg 
heuristic uses topological traversal backedge free graph cfg compute weighting 
heuristic uses natural loops identify loops loop exit edges 
natural loop backedge defined follows nat loop directed path include vertex loop entry target backedges 
natural loop loop entry denoted nat loop simply union natural loops nat loop backedge 
different loop entry vertices nat loop nat loop disjoint entirely contained 
nesting property define loop exit edges loop entry exit exit 
program fragment cfg weighting satisfying flow optimal edge counter placement black dots 
case shows weighting derived post order numbering vertices edge value post order number source vertex sub optimal placement results finding maximum spanning tree respect weighting 
loop exits nat loop nat loop edge loop exit edge exists loop entry loop exits 
heuristic assumes loop iterates loop multiplier times implementation times branch predicate equally chosen 
loop exit edges specially handled described 
weight edge exit root fixed change 
edge exit root treated backedge identified depth search 
rules describe compute vertex edge weights weight vertex sum weights incoming edges backedges 
vertex loop entry weight loop exits edge loop exits weight 
loop entry vertex weight vertex times loop multiplier weight vertex sum weights outgoing edges loop exit edges outgoing edge loop exit edge weight number outgoing edges loop exit edges 
rules applied single topological traversal backedge free graph cfg 
edge possibly backedge assigned weight rule applies traversal follows 
vertex visited traversal weights incoming non backedges known 
rule determines weight vertex vertex loop entry rule assign weight edge loop exits 
rule determines weight outgoing edge loop exit edge 

performance results section describes experiments demonstrate algorithms significantly reduce cost profiling tracing real programs 
sections discuss performance profiling tracing algorithms respectively 
section considers optimizations decrease overhead profiling tracing 
section examines effectiveness heuristic weighting algorithm 

profiling performance implemented profiling counter placement algorithm qpt basic block profiler similar mips pixie 
qpt instruments object code insert counters basic block program redundant mode subset edges identified spanning tree algorithm optimal mode 
spec benchmark suite test qpt 
collection moderately large fortran programs widely evaluate computer system performance 
programs compiled high level optimization interprocedural register allocation 
mips utility cord reorganizes blocks improve cache behavior interprocedural delay slot filling 
optimizations confuse program structure greatly complicate constructing control flow graph 
timings run decstation local disks mb main memory 
times elapsed times 
table describes benchmarks shows size object files time required insert profiling code redundant optimal mode keep mind qpt tuned current speed adequate executables encountered practice 
seen instrumenting optimal profiling slightly slower instrumenting redundant profiling 
due extra find loops cfg compute weighting drive maximum spanning tree algorithm 
practice extra instrumentation overhead quickly regained reduction profiling overhead 
graph shows normalized execution time benchmarks profiling qpt redundant profiling pixie profiling inserts counter basic block qpt optimal profiling 
spec size redundant optimal increase benchmark description bytes sec 
sec 
opt red 
cc compiler espresso pla minimization xlisp lisp interpreter eqntott boolean eqns 
truth table spice circuit simulation doduc monte carlo simul 
dnasa floating point kernels matrix matrix multiply fpppp electron integral deriv 
tomcatv vectorized mesh generation table 
spec benchmarks 
size input object files times instrumenting programs redundant optimal profiling 
programs programs 
remainder fortran programs 
pixie rewrites program free registers enables insert code sequence half size qpt instructions vs instructions 
course pixie may insert spill code order free registers 
seen graph optimal profiling reduces overhead profiling dramatically redundant profiling 
timings affected variations instruction data cache behavior caused instrumentation 
measured profiling improvement way factors variations 
graph records reduction counter increments going redundant optimal profiling number counter increments redundant mode number increments optimal mode 
graph records reduction number instrumentation instructions executed assuming instructions counter increment instruction unconditional branch edge profiling code 
general reduction reduction counter increments edge profiling may require insertion unconditional jumps 
fortunately greatest improvements occurred programs profiling overhead largest programs conditional branches opportunities optimization 
programs frequently executed conditional branches improvements large 
programs cc espresso xlisp eqntott placement algorithm reduced number increments factor overhead factor 
fortran programs improvements varied 
programs large basic blocks execute conditional branches profiling inexpensive improved counter placement effect number increments normalized execution time uninstrumented redundant pixie optimal cc espresso xlisp eqntott spice doduc dnasa matrix fpppp tomcatv graph 
normalized profiling execution times 
redundant profiling qpt inserts counter basic block vertex 
optimal profiling qpt inserts counter selected edges eprof ecnt 
pixie mips utility inserts counter basic block 
cost profiling 
fortran program doduc dynamic block size instructions abundance short branches accounts reduction counter increments 
decrease run time overhead doduc substantial 
fpppp benchmark produced interesting result 
showed largest reduction counter increments overhead measuring basic block quite low average dynamic basic block size instructions 
implies large basic blocks dominated execution 
basic blocks smaller size executed yielding dramatic reduction counter increments contributed little running time program 
graph compares reduction dynamic instrumentation overhead eprof ecnt algorithm optimal profiling vprof ecnt heuristic knuth stevenson vprof vcnt algorithm compared redundant profiling measure vertex 
algorithms weighting compute counter placement 
counter placement algorithms profile information collected previous run determine times counter incremented extra jumps needed vprof vcnt require extra jumps counting code placed vertices 
doing avoided instrumenting running programs redundant mode optimal mode cc espresso reduction increments reduction instructions xlisp eqntott spice doduc dnasa matrix fpppp tomcatv graph 
reduction counter increments instrumentation instructions due optimized counter placement guided heuristic weighting described section 
reduction increments number counter increments redundant profiling number counter increments optimal profiling 
reduction instrumentation number basic blocks increments number extra jumps 
average dynamic basic block size instructions program shown parenthesis 
redundant mode optimal mode eprof ecnt vprof ecnt vprof vcnt cc espresso xlisp eqntott spice doduc dnasa matrix fpppp tomcatv graph 
comparison instrumentation reduction eprof ecnt vprof ecnt vprof vcnt 
larger plot better greater reduction instrumentation code 
instrumentation reduction basic blocks increments number extra jumps 
algorithm collecting accurate results 
benchmarks eprof ecnt superior vprof vcnt producing greater reduction instrumentation instructions predicted 
heuristic vprof ecnt yields improvement eprof ecnt cases counter eliminated 
table provides statistics number edges program total edges number edges counting code placed spanning tree algorithm profiled edges number profiled edges require insertion unconditional jump jump edges 
observations 
notice percentage edges profiled narrow range 
consistent facts cfgs quite twice edges vertices number edge counters required edge profiling 
second half profiled edges require insertion unconditional jump 

tracing performance witness placement algorithm implemented ae program tracing system incorporated part qpt tool 
ae originally recorded outcome conditional branch record regenerate full control flow trace 
complication ae traces instruction data trace file contains information reconstruct data addresses witnesses 
combining information file requires additional blocking witnesses described section 
total profiled edges jump edges program edges total profiled cc espresso xlisp eqntott spice doduc dnasa matrix fpppp tomcatv table 
static statistics control flow edges 
total edges shows total number control flow graph edges program 
profiled edges shows number edges counters placed spanning tree algorithm 
jump edges shows number profiled edges require insertion unconditional jump 
table shows reduction total file size file witness trace size trace execution time result switching original algorithm recording conditional old witness placement described section new 
profiling results programs regular control flow pdp gain tracing algorithm 
programs complex control flow compress tracing algorithm reduced size trace file factors times respectively 
discussion tracing assumed standard representation witnesses cfg 
modern architectures convenient representation multiple byte 
case record bits witness necessary 
explored method tracing called bit tracing seeks reduce size trace 
bit tracing outgoing edge predicate vertex generates witness witness values reused 
predicates successors bit information required distinguish witness sets 
general predicate successors requires log bits 
illustrates tradeoff spanning tree approach bit tracing 
case witnesses placed spanning tree approach 
pair distinct witnesses set assigned value bits witness required 
case bit witness required 
iteration loop cfg generate bits trace 
case amount trace generated iteration bits 
program old file new file old old trace new trace old old run new run old bytes bytes new bytes bytes new sec 
sec 
new compress pdp table 
improvement ae program tracing system 
old refers original version ae recorded outcome conditional branch 
new refers improved version ae uses witness placement algorithm section 
file refers total size recorded information includes witness data 
trace refers total size witness information 
example witness placement clear winner 
compared spanning tree approach naively uses byte needed storage witness bit tracing clearly superior 
instrumentation code executed trace generated reduces overhead 
method decreases size trace times spanning tree approach 
shown bits necessary spanning tree approach improved 
example bits witness needed 
general witnesses cfg log bits witness needed 
situations witness values reused possibly decreasing number bits needed 
complicated fact different placements witnesses may give rise different opportunities reuse values 
investigation optimizing spanning tree approach clearly needed 
bit tracing avoids multi procedure tracing problem discussed section directed path predicate call vertex 
address trace generated program bit tracing requires separate files maintained efficiency instruction trace address trace 
cost bit tracing additional implementation complexity required manage witnesses bit level 

optimizations optimizations decrease overhead profiling tracing 
optimization register scavenging specific instrumenting object code 
risc machines counter increment code requires registers hold counter address addressing risc machines done indirection register hold counter value 
registers need saved restored preserve values instrumentation code jumps instructions 
register scavenging notes unused caller saved registers procedure 
registers 
tradeoff placing witnesses spanning tree approach placing witnesses outgoing edge predicate vertex 
instrumentation code preserving values procedure callers expect registers modified 
benchmarks specifically fortran programs large basic blocks unused registers register scavenging little effect execution overhead 
benchmarks results varied small reductions percent larger reductions range 
second optimization substantially reduce profiling overhead removing counters loops 
number iterations loop determined loop executes induction variable value recorded loop counter eliminated loop body allowing counter free path loop 
sarkar goldberg successfully implemented approach profiling tools 
example goldberg reports eqntott reduction increments redundant optimal profiling increased adding induction variable analysis 
scientific codes benefitted greatly analysis fold decrease instrumentation code executed matrix 
pointer chasing programs xlisp benefits analysis quite small induction variables programs 
mentioned placing instrumentation code edges may require insertion jumps order avoid executing instrumentation code 
example control flow fragment instrumented incoming edges vertex 
general rule instrumentation code associated edge placed just code associated vertex target edge fragment require unconditional jump order jump instrumentation code associated edge 
grey vertex incoming edge outgoing edge instrumentation point moved outgoing edge incoming edge resulting placement case 
placement may require extra jumps grey vertex outgoing edge fall 
jump optimization searches vertices incoming outgoing edge instrumentation code outgoing edge 
instrumentation code simply moved incoming edge 
simple optimization may reduce increase number extra jumps needed 
case xlisp optimization reduced execution overhead percent 

placement requiring insertion jump 
jumps required 
discuss problems register scavenging instrumenting object files greater detail 

effectiveness heuristic weighting algorithm effectiveness heuristic weighting algorithm measured ways graph 
measured reduction counter increments number increments redundant mode number increments optimal mode exact edge weighting previous run program identical input 
number exact max represents best hope semantics optimizations induction variable analysis 
second heuristic exact weightings computed reduction increments minimum spanning tree place counters 
maximum spanning tree places counters frequently executed areas cfg minimum spanning tree places counters frequently executed areas 
exact min worst possible reduction spanning tree algorithm 
difference exact min exact max shows great variation reduction counter increments depending spanning tree chosen 
heuristic clearly successful predicting areas low execution frequency shown heuristic max 
note heuristic max produced greater reduction heuristic min 
difference reduction heuristic exact weightings usually small ranging 
surprisingly heuristic quite accurate fortran programs conditional 
graph shows normalized times benchmarks run optimal profiling heuristic weighting corresponds heuristic max graph exact weighting corresponds exact max graph 
case fpppp run time exact weighting greater run time redundant mode optimal mode exact max heuristic max heuristic min exact min cc espresso xlisp eqntott spice doduc dnasa matrix fpppp tomcatv graph 
heuristic weighting vs exact weighting reduction increments redundant optimal 
reductions increments computed counter placements maximum minimum spanning trees 
normalized execution time uninstrumented optimal heuristic optimal exact cc espresso xlisp eqntott spice doduc dnasa matrix fpppp tomcatv graph 
normalized profiling times heuristic exact weightings 
heuristic weighting 
aberration due different instruction data cache behavior instrumented program different counter placements requires investigation 
heuristic weighting algorithm assumes branch predicate equally chosen 
programs varying probability great effect instrumentation overhead 
weighting schemes attempt pick branch directions independently may greater success 
example favoring edges leading blocks containing loops high dynamic cost reduces instrumentation overhead benchmarks 

related 
edge profiling spanning tree solution eprof ecnt known long time 
area network programming problem known specialization simplex method network program 
knuth describes spanning tree profiling 
authors written application spanning tree profiling include goldberg samples 
far know goldberg samples researchers implemented spanning tree approach performed significant experimentation real programs 
occurred concurrently 
goldberg implemented edge profiling instrumenting executable files 
profiler built part system analyze memory performance programs 
goldberg optimized instrumentation ways consider 
tool selected statically registers executable eliminated uses inserting loads stores existing uses registers 
allows counting code sequence registers saving restoring 
similar approach mips pixie profiling tool 
result number instructions needed increment counter memory cut roughly half 
tool looks free registers scavenge save restore registers counter increment code sequence 
second goldberg identifies simple loop induction variables 
allows counter eliminated loop number iterations inferred values induction variable lowering instrumentation overhead drastically scientific codes 
tool perform optimization 
samples considers refinement takes account unconditional jump may inserted profiled program placing counter edge 
algorithm places counters mixture edges vertices reduce number unconditional jumps number counter increments 
approach useful architectures cost unconditional jump comparable cost incrementing counter memory 
mentioned samples results show overhead incurred mixed placements differ edge placements 
discusses solving eprof vcnt possible general 
graph grammars characterizes set delimited programs eprof vcnt solved 
class graphs arises introducing delimiter vertices structured programs 
discusses find minimal number vertex measurement points opposed minimal cost set measurement points 
sarkar describes choose profiling points control dependence implemented profiling tool system 
algorithm finds minimum sized solution eprof ecnt variety rules control dependence opposed spanning tree approach 
major differences algorithm works subclass reducible cfgs algorithm weighting place counters points lower execution frequency 
result algorithm may produce suboptimal solutions bounds loop known execution loop algorithm eliminates loop iteration counter done goldberg 

vertex profiling knuth stevenson exactly characterize set vertices vcnt solves vprof vcnt show efficiently compute minimum size vcnt solves vprof vcnt 
authors note algorithm modified compute minimum cost solution vprof vcnt set measured estimated vertex frequencies 
shows costly measure vertex frequency instrumenting edges vertices 

tracing ramamoorthy kim chen consider instrument single procedure program minimal number monitors traversal directed path program may ascertained execution 
equivalent tracing problem single procedure programs discussed 
authors give algorithm reconstructing execution trace consider trace multi procedure programs 
interested finding minimal size solution tracing problem np complete problem 
minimum size solution necessarily yield minimum cost solution 

minimizing instrumentation overhead cfg spanning trees induces counter placement associated run time overhead cost 
section heuristic estimating edge frequency order drive maximum spanning tree algorithm 
section compares heuristic methods minimizing instrumentation overhead may include methods estimating frequency 
cfg basis comparing various heuristics discussed 
weighting cfg satisfies flow law edges black dots optimal edge counter placement profiling respect weighting 
edges form maximum spanning tree 
mentioned heuristic generates weighting case 
forman discusses problem minimizing counter overhead spanning tree approach graph theoretic perspective 
defines partial order spanning trees cfg weighting spanning tree element partial order spanning tree lower order induces counter placement lower cost induced course may element partial order 
spanning tree element 
forman proposes structural method computing element works structured cfgs 
heuristic works cfg 
proposes general solution generates weighting branch probabilities predicate vertices cfg 
maximum spanning tree weighting element forman partial order 
generate weighting requires matrix operations essentially adjacency matrix representations cfg 
general approach slower heuristic operates directly control flow graph structure 
heuristic generates edge frequencies satisfying flow law easily adapted take branch probabilities account 
goldberg developed heuristic profiling tool uses post order numbering vertices cfg determined depth search root vertex assign edge weights 
defines edge weight post order number source vertex 
edge loop backedge weight larger number vertices graph 
rationale heuristic node executes times descendants successors best place counters nodes far root possible heuristic clearly produce weighting satisfying flow law shows 
distance edge root vertex correspond edge level nesting goldberg heuristic lead best counter placements 
example maximum spanning tree weighting determined heuristic induces sub optimal counter placement 
wall experimented number heuristics estimating basic block procedure profiles solely program text reporting poor results 
wall heuristics information loop nesting call graph structure predict basic block procedure profiles take account conditional control flow predicting code deeply nested conditionals executed frequently heuristic 
aspect heuristic key reducing instrumentation overhead main idea forman partial order 
wall heuristic basic block nested number loops gets equal weight 
example graph block get equal weight clearly useful purposes minimizing instrumentation cost 
authors heuristics similar usually purpose aiding code optimization 
example fisher ellis nicolau loop nesting level programmer supplied hints estimate block execution frequency trace scheduling 
heuristics goal producing edge frequencies satisfying flow law 
heuristics mentioned heuristic attempts predict branch directions 
branches accurately predicted instrumentation code placed frequently executed branch choice possible 
branch prediction ball larus application 

studied algorithms efficiently profiling tracing programs 
algorithms optimize placement instrumentation code respect weighting control flow graph 
empirical results real programs show algorithms successful reducing instrumentation overhead 
placing instrumentation code edges control flow graph essential reduce profiling tracing overhead 
open questions remain efficient algorithm optimally solve vertex frequency problem set edge counters problem intractable 
better weighting schemes accurately guide placement instrumentation code 
susan horwitz support 
gary schultz jonathan provided valuable advice network programming 
bob meyer helped characterize vprof ecnt problem 
samuel bates paul adams phil pfeiffer descriptions progress 
chris fraser suggested bit tracing approach implemented viswanathan 
sohi tony provided code basic block profiler assisted development qpt mark hill provided disk space computing resources performance measurements 
computer resources obtained digital equipment external research 

aho sethi ullman compilers principles techniques tools addison wesley reading ma 

ball larus optimally profiling tracing programs conference record nineteenth acm symposium principles programming languages albuquerque nm january pp 
acm 

ball larus branch prediction free proceedings acm sigplan conference programming language design implementation published sigplan notices pp 
acm june 

choi miller netzer techniques debugging parallel programs analysis acm transactions programming languages systems pp 
october 

cmelik kong kelly analysis mips sparc instruction set utilization spec benchmarks asplos iv proceedings sigarch computer architecture news pp 
april 

systems performance evaluation cooperative spec newsletter editor 

fisher ellis nicolau parallel processing smart compiler dumb machine proc 
acm sigplan symposium compiler construction sigplan notices pp 
june 

forman time overhead counters traversal markers proceedings th international conference software engineering pp 
march 

garey johnson computers intractability guide theory np completeness freeman san francisco 

goldberg reducing overhead counter execution profiling technical report csl tr stanford university stanford ca october 

goldberg hennessy integrated system performance debugging shared memory multiprocessor applications ieee transactions parallel distributed systems pp 
january 

graham kessler mckusick execution profiler modular programs software practice experience pp 


algorithms network programming wiley interscience john wiley sons new york 

kernighan ritchie programming language prentice hall software series englewood cliff nj 
second edition 

knuth art computer programming vol 
fundamental algorithms addison wesley reading ma 
second edition 

knuth stevenson optimal measurement points program frequency counts bit pp 


larus execution technique efficiently tracing programs software practice experience pp 
december 

larus efficient program tracing ieee computer pp 
may 

larus ball rewriting executable files measure program behavior appear software practice experience 

maheshwari traversal marker placement problems np complete report 
cu cs dept computer science university colorado boulder 

mcfarling procedure merging instruction caches proceedings sigplan conference programming language design implementation toronto june acm sig plan notices pp 
june 

morris ccg prototype code generator proceedings sigplan conference programming language design implementation toronto june acm sigplan notices pp 
june 

pettis hanson profile guided code positioning proceedings acm sigplan conference programming language design implementation sigplan notices pp 
acm june 

private communication 
october 

optimal insertion software probes delimited programs ieee transactions software engineering se pp 
january 

ramamoorthy kim chen optimal placement software monitors aiding systematic testing ieee transactions software engineering se pp 
december 

solomon optimal code control structures pp 
conference record ninth acm symposium principles programming languages albuquerque nmp acm new york 

samples profile driven compilation ph 
thesis report 
ucb csd university california berkeley april 

sarkar determining average program execution times variance proceedings acm sigplan conference programming language design implementation sigplan notices pp 
acm june 

smith cache memories acm computing surveys pp 


mips computer systems manual pixie mips computer systems sunnyvale ca 

tarjan data structures network algorithms society industrial applied mathematics philadelphia pa 

wall predicting program behavior real estimated profiles proceedings sig plan conference programming language design implementation toronto june acm sigplan notices pp 
june 
