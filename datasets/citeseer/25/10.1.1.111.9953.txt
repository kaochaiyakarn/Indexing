object types races cormac flanagan mart abadi flanagan ma pa dec com systems research center compaq 
investigates approach statically preventing race conditions object oriented language 
setting variant gordon hankin concurrent object calculus 
enrich calculus form dependent object types enables verify threads invoke update methods acquiring appropriate locks 
establish typed programs race conditions 
concurrent object oriented programs suffer errors common programs sorts 
particular objects diminish importance careful synchronization 
objects improper synchronization may lead race conditions processes accessing shared resource simultaneously ultimately 
standard approach eliminating race conditions consists shared resource lock requiring process acquires corresponding lock resource 
object oriented programs approach peculiar patterns 
common group related resources object attach lock protects re sources object 
processes may acquire lock invoking methods object alternatively methods may acquire lock start execution 
constructs java synchronized methods object oriented languages support synchronization patterns 
standard object oriented languages enforce proper synchronization remains possible easy write programs race conditions 
investigates static analysis approach preventing race condi tions object oriented language 
approach consists associating locks shared object components verifying appropriate locks operation 
object oriented language treat object components methods invoked updated fields special case methods 
approach consists associating locks methods verifying appropriate locks method invocation update 
method invocation may trigger operations locks may required required method update 
annotations checks necessary static analysis type system 
standard type systems type system assigns type methods object 
addition gives set locks held invoking method lock held updating method indication update forbidden 
ofthese locks may external object may special lock associated self object led type system dependent types type object refers values locks 
type system preserve important phase distinction compile time run time 
checking takes place compile time possibility run time checking 
checking guarantees absence race conditions program typed execution threads attempt access object component time 
addition checking guarantees absence run time type errors message understood errors 
approach handle interesting common examples demonstrate 
itis far complete believe represents sensible compromise simplicity generality worthwhile step ongoing investigation ofthe types safe locking 
background developed analogous technique basic cells data structures 
singleton types types single element enable tracking locks existential types hiding singleton types locks 
describes technique avoiding deadlocks possible adapt setting 
substantial novelty treatment objects object types subtyping 
avoid singleton existential types resort specialized dependent types 
dependent types require somewhat conceptual machinery support subtyping relations 
addition previous rely gordon hankin object calculus :10.1.1.149.9088
calculus small extremely expressive concurrent object oriented language features compact concepts expression process store configuration 
refer reader gordon hankin motivations additional examples technical developments 
calculus extends sequential calculus abadi cardelli adopting basic type structure subtyping relation sequential calculus 
extend type system form dependent types 
hankin type system attempt guarantee absence race conditions type system provides guarantee simplicity omit cloning construct 
replace synchronization primitives gordon hankin extension 
primitives separate operations acquiring releasing 
expression lock acquires lock evaluates releases lock 
java synchronized statement expression lock automatically guarantees proper nesting helping static checking 
calculus associates locks objects java languages starting point particular di fisher calculus 
prefer base gordon hankin main reasons 
di fisher calculus extension subtyping typed objectoriented languages wish treat subtyping 
furthermore di calculus combines synchronization mechanisms primitive operations objects 
gordon hankin prefer keep object operations object types mention locks 
di fisher interesting study address race conditions certain synchronization guards side effects 
pieces related discussed 
rely ona variety techniques including program verification methods data flow analyses example 
relevant kobayashi develops type techniques avoiding deadlocks necessarily race conditions context process calculus 
system partial detection race conditions deadlocks ansi programs 
aware specifically addresses object oriented programs 
direction intriguing explorations combination dependent types objects emphasis logical frameworks programming languages 
outline section presents syntax informal semantics oriented language treat appendix contains formal semantics 
section develops type system calculus 
section shows applications type system 
section considers formal properties 
section concludes 
proofs omitted 
concurrent object calculus section describes variant gordon hankin concurrent 
largely review 
syntax define sets results denotations lock states terms grammar syntax results variable name denotations xi bi object lock states locked ffi unlocked terms result restriction 
denomination method invocation method parallel lock lock acquired results include variables names 
variables represent bound methods expressions constructs bind variable scope names represent stored objects 
introduced restriction name scope fn fv denote sets free variables respectively 
write denote free substitution free occurrences write equal renaming bound variables reordering object methods 
informal semantics denotation xi bi describes object containing collection 
method label consists self parameter xi bi 
addition object associated lock state lock held term program ffi unlocked 
straightforward extension object associated locks denotation may appear denomination 
maps name denotation intuitively term represents portion object represents address object 
term introduces fresh name evaluates operation allocating fresh address objects stored 
name name definition 
type programs multiple definitions name 
method invocation invokes method object replaces method term evaluates yield result binds result evaluates composition evaluates parallel 
result composition result subterm evaluated effect lock operation lock functions similar manner java synchronized statement lock object acquired sub term evaluated lock released 
implementation relies auxiliary construct locked indicates acquired term evaluated 
locks expressions lock lock deadlock similarly recursive method lock ffi deadlock cf 
java appendix contains detailed formal semantics language 
chemical semantics style berry boudol 
consists group congruence rules permit rearrangement terms imply example associative group reduction rules computation steps 
typical structural congruence rule fn bn denotes evaluation context locked binding names bn evaluation context names restriction encloses hole purposes interesting reduction rules 
ffi lock 

locked red lock 
locked 

ffi red locked 
represents object excluding lock state 
rule red lock evaluates lock operation acquiring lock associated term locked subsequent reduction steps may evaluate reduced result rule red locked releases lock result locked expression 
example clarity example programs extended language operations abbreviate fv counter read method increment method initially contains integer defined delta val read val val val program allocates counter initially containing counter reads value counter 

count read expected program reduces 
count correctly sequential setting 
presence concurrency counter may exhibit unexpected behavior 
illustrate danger program creates counter increments twice parallel 

count program non deterministic 
may reduce 
count 
alternatively evaluations calls interleaved program may reduce 
count programmer intended 
program race condition threads may attempt update method val simultaneously 
fix error adding appropriate synchronization counter sync delta val read lock val lock val val synchronized counter method val protected lock 
lock held method val invoked updated methods read acquire lock 
modified race free behave correctly multiple threads provided threads access val read lock accessing val directly 
revisit example sections 
type system race conditions count common bug concurrent object oriented programs just concurrent programs kinds 
practice race conditions avoided strategy sync count mutable component protected lock lock held 
section describe type system supports programming discipline 
type language set types system described grammar types xi ai ri si proc exp types 
un permissions protection annotations object type xi ai ri si describes object containing labeled 
ln 
method li result type ai permission ri protection annotation si 
permission ri set results locks held invoking li 
method trigger operations allow ri contain lock 
annotation si result describing lock held li refer si lock protects li additional required invoking li 
case li updated si symbol 
methods commonly protected self lock lock object description binds self variable xi variable may occur free ai ri si example type describes object containing asingle method result type permission indicates acquired invoking method protection annotation indicates method updated 
type describes object method updated 
self lock object acquired invoking updating method type mentions additional method protected external lock lock protects self lock acquired invoking code may update invoke locking slightly complicated example suitable type synchronized counter sync described earlier val int read int type states method val protected self lock acquired invoking updating method 
methods read read updated 
furthermore necessary synchronization internally locks need held invoking methods addition object types type language includes types exp proc 
type exp describes results may returned expressions type proc supertype exp covers terms return results denomination 
clean defined names addition checking appropriate locks held invoked updated type system verifies lock held thread time 
name form locked 
program 
verifying mutual exclusion property little tricky contains denomination 
ffi potentially acquire lock reduction rule red lock 
introduce notion clean names say clean name term term includes 

ffi evaluation context 
restriction evalu ation contexts excludes nonsensical programs 
set clean names term preserved evaluation set locks held may vary 
type system checks parallel composition clean names subterms distinct 
check ensures simultaneously held terms executing parallel 
type system verifies name introduced unique denotation 
say name defined term associated denotation evaluation context 
clean defined names clean 
ffi locked bn defined 
bn type rules define type system judgments 
judgments environment sequence bindings types form 
un 
judgments pi formed environment type formed permission formed subtype term type type rules env 
pi env dom pi perm pi dom type proc pi proc type exp pi exp type object distinct pi xi bi exp xi ri si ri xi bi ri si val object xi bi ri si pi ri xi bi xi bi xi defined bi clean bi 
xi bi proc val pi val select xi bi ri si rj xj bj xj val update xi bi ri si rj xj xj bj xj sj clean sj xj xj val exp clean val res defined clean val par proc defined clean clean val lock clean lock val locked clean locked val subsumption sub refl sub trans sub exp proc exp sub proc proc sub object xi bi ri si xi bi ri si xi bi ri si rules type system corresponding rules hankin system turn abadi cardelli calculi 
novel aspects system mainly pertain locking treatment permissions dependent types 
core system set rules judgment read ais typed expression type typing environment permission intent judgment holds race free yields type provided free variables bindings consistent environment current thread holds locks type system tracks set locks assumed program point 
rule val object checks method body race free assumption locks described method sion held 
rule val select ensures locks held method invoked 
rule val update ensures lock method held method updated 
rule val lock lock typechecks assumption lock held 
rule val subsumption allows subsumption types permissions term race free permission race superset type system provides dependent types type may contain refers object 
cases object referent results example self variable external name 
type rules contain number substitutions support changing result refer particular object 
example rule val select method invocation replaces occurrences self variable xj thetype bj result xj refer object xj scope 
similar substitution performed permission rj rules val object val update rely analogous substitutions 
order accommodate self dependent types description anobject method may refer object rule type object checks result type permission method formed contains binding self variable 
types may refer results rules val val res ensure type outside result binding formed 
rule val res similar requirement permissions 
type rules include conditions clean defined names subterms rule val par requires defined names subterms disjoint 
furthermore clean names subterms disjoint condition implies subterms simultaneously hold lock 
rule val res requires name defined lock associated unlocked held rule val locked disallows nested acquisitions 
addition order ensure clean defined names term invariant evaluation type rules require terms clean defined names 
rule sub object defines usual subtyping relation object types appropriately adapted type syntax 
protection annotation considered variance annotation extend type powerful subtyping rule 
rule allow result types permissions immutable components behave covariantly 
conjecture thatthe extended system race free 
examples section show applications type system examples 
convenience abbreviation delta result 
counters unsynchronized counter implementation count described earlier type val int read int type states method val protected self lock object self lock acquired invoking methods read method val may considered private implementation dropped subtyping yielding read int type describes public interface counter states counter acquired invoking counter methods 
interface expresses synchronization protocol sufficient ensure operates correctly 
type system requires protocol obeyed client counter 
programs obey 
count forbidden 
input streams cases may wish provide similar synchronized object 
example input stream may provide synchronized method read reading characters stream unsynchronized method read 
modula package provides methods 
outline implementation input stream delta buffer 
internal data structure read buffer fast unsynchronized lock read slower synchronized read method buffer contains internal data structures input protected self lock 
method read assumes self lock held returns input character manipulation buffer method read assume self lock held acquires lock dispatches read suitable type input stream buffer buffer read char read char subtyping allows view input stream having synchro interface read char faster unsynchronized interface read char 
lines points examples describe objects components protected lock object 
addition object components protected lock external object 
illustrate possibility consider example consisting point line objects 
point delta bmp line delta start pt pt bmp lock start bmp bmp point contains method bmp increments coordinate point analogous method omitted brevity 
line object includes points start method bmp increments coordinate points line 
method acquires lock line calls method bmp points 
points perform synchronization internally mutable methods protected lock enclosing line object 
appropriate types lines points delta int int bmp line delta start point points bmp type describes point mutable methods lock type line states methods start yield mutable components protected lock enclosing line object 
interestingly type line permits line object line delta start pt pt bmp lock start bmp lock bmp thread runs method bmp object acquires releases lock twice hold lock continuously execution method 
thread may observe line start updated 
intermediate state violate higher level invariants interleaving threads regarded higher level race condition 
type system address errors directly 
encoding functions race free objects encode function abstraction application calculus follows object calculi encoding functions delta new arg arg val arg fv delta new lock arg val fv absence cloning need method new create fresh usual methods arg val self lock acquired accessing arg val 
locking needed methods arg mutable arg 
translation provides encoding simply typed call value calculus function type mapped object type new arg val translation encode dependent function types depends argument value 
encoding dependent function types calculus require extension example allowing terms just results locks 
encodings sketches translate programs imperative object calculus straightforward manner gordon hankin 
calculus include cloning translation works clone free pro grams 
translated program includes single global lock protects object components program 
program single threaded needs acquired start program execution held execution allowing unrestricted invocations object components 
gordon hankin describe encoding ss calculus concur rent object calculus 
encoding implementation channels 
similar approach works setting neatly 
calculus semaphores implementation channels uses example reading channel may involve looping written channel thread 
typed programs don races fundamental property type system typed programs race conditions 
formalize notion race condition follows 
term reads exists bn similarly term writes exists bn 
term accesses reads writes 
term immediate race condition exists access write 
term race condition evaluation term immediate race condition exists term immediate race condition type system ensures typed program thread accesses method holds appropriate locks 
lemma crucial property 
lemma 
accesses clean 
furthermore access write 
lock held term time immediate race condition 
lemma 
immediate race condition 
furthermore typing invariant reduction 
lemma 
previous lemmas prove typed programs race conditions 
theorem 
race condition 
shows simple type system help detect avoid errors concurrent object oriented programs 
type system builds underlying object constructs extends standard object types information 
operational arguments establish welltyped programs race conditions static analysis technique necessarily incomplete 
practice probably complemented mechanisms escaping require ments means asserting program fragments race conditions fragments typecheck 
currently investigating type systems sophisticated liberal 
context java methods 
acknowledgments andrew gordon paul hankin permission adapt inference rules 
appendix formal semantics formal semantics calculus closely follows gordon 
consists group structural congruence rules permit rearrangement terms group reduction rules computation steps 
addition rules listed set rules imply congruence relation 
structural congruence rules struct res fn bn struct par fn bn reduction rules red red select xi bi 


bj xj red update xi bi xi bi 


red lock 
xi bi 
ffi lock 

locked red locked 
xi bi 
locked 

ffi red red struct 
mart abadi luca cardelli 
theory objects 
springer verlag 

ken arnold james gosling 
java programming language 
addisonwesley 

david aspinall adriana 
subtyping dependent types 
proceedings th annual ieee symposium logic computer science pages july 

erard berry erard boudol 
chemical machine 
theoretical computer science 

andrew birrell 
programming threads 
research report digital equipment systems research center 

paolo di kathleen fisher 
calculus concurrent objects 
concur concurrency theory volume lecture notes computer science pages 
springer verlag 

luca cardelli 
phase distinctions type theory 
unpublished 

cormac flanagan mart abadi 
types safe locking 
proceedings th european symposium programming esop pages 
springerverlag march 

andrew gordon paul hankin 
concurrent object calculus reduction typing 
uwe nestmann benjamin pierce editors high level concurrent languages volume electronic notes theoretical computer science 
elsevier science publishers 
extended version appears technical report university cambridge computer laboratory february 

james gosling bill joy guy steele 
java language specification 
addison wesley 

robert harper john mitchell eugenio moggi 
higher order modules phase distinction 
conference record seventeenth annual acm symposium principles programming languages pages january 

martin hofmann wolfgang martin steffen terry 
inheritance proofs 
theory practice object systems 

naoki kobayashi 
partially deadlock free typed process calculus 
proceedings th annual ieee symposium logic computer science pages 

greg nelson editor 
systems programming modula 
prentice hall 

nicholas sterling 
static data race analysis tool 
usenix winter technical conference pages 

naoki kobayashi 
generalized deadlock free process calculus 
uwe nestmann benjamin pierce editors high level concurrent languages volume electronic notes theoretical computer science 
elsevier science publishers 
