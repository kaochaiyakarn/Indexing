building control flow graph scheduled assembly code keith cooper timothy harvey todd waterman variety applications arisen apply code optimizations directly machine code assembly code produced bya compiler 
include link time program analysis optimization code compression binary binary translation bit transition reduction power 
optimizations presence control flow graph cfg 
com scheduled code properties cfg construction complex inside typ ical compiler 
examine problems scheduled code architectures slots 
particular branch delay slots contain branches classic algorithms building cfg produce incorrect results 
explain problem simple exam ples 
algorithm building correct cfgs scheduled assembly code branch delay slots 
algorithm works building approximate cfg reflect actions delayed branches 
branches explicit targets complexity step linear respect number branches code 
analysis kind step system analyzes translates compiled assembly level code 
implemented algorithm consumption experiments tms architecture texas instruments development algorithm motivated output ti compiler 
authors address department computer science rice university ms houston tx usa 
corresponding author waterman rice edu increasingly systems applying compiler technol ogy previously compiled code 
dynamo system interprets statically compiled executable improve performance dynamic information improve scheduling cache management link time systems perform program analysis optimization start compiled procedure module 
just time compilers java take compiled bytecodes rapidly produce machine code regions 
binary translation systems executable code rewrite instruction set 
past systems emulation perform load time tailoring grid environments systems reads manipulates previously compiled code 
control flow graph cfg structure needed compiler techniques find optimization opportunities safety optimizations 
analysis includes global data flow analysis construc tion ssa graph data dependence analy sis 
techniques cfg guide amore local analysis replacement phase 
techniques assume existence cfg input transformation compiled scheduled code cfg construction handle complexity arise code 
compiled code differs intermediate inside compilers 
particular features complicate cfg construction 
branches tar get address held register opposed explicit immediate constant introduce level add spurious edges cfg compiler avoid branches intermediate representations compiled scheduled assembly code 
branch de lay slots exacerbate problem finding operation block 
branches occupy delay slot branch complex 
branch register operations complicate cfg con struction compiler may unable determine branch targets 
happens add edge block containing branch block reach naively set contains block 
compiler narrow set finding labels thatthe program loads registers 
safe program performs arithmetic label value result 
perform precise analysis similar required call graph con struction function valued parameters 
needs approximate cfg mates set potential paths perform analysis 
branch delay slots complicate task operation block 
delay slots contain ordinary operations control flow delay slots just requires additional counter track stream branch takes effect 
existing systems handle problem 
slots contain branch operations compiler maintain counters pending branches multiple branches target label block multiple predecessors cfg handle effects multiple sets pending branches 
pending terminate block add edges cfg 
effects cause classic cfg construction fail building cfg correctly reflect potential control code 
sorting effects adds significant complication cfg constructor 
traditional setting compiler avoid problems 
careful design intermediate code compiler avoid usingthe branch register construct internally source language constructs 
compiler annotate operation labels correspond source targets branch 
similarly uses cfg occur schedul ing compiler avoid dealing delay slots completely cfg construction 
compiler authors assume cfg built wellbehaved intermediate representation include branches delay slots 
authors simply assume cfg construction understood omit algorithm entirely 
loop branch loop loop branch loop loop branch loop loop branch zero zero side zero zero side product loop branch zero zero side zero zero side zero zero side load zero zero side load value loop load load load add add ca sub decrement loop loop branch loop add ca cb pipelined code produced ti compiler performs allocation scheduling may pre serve scheduler cfg alloca tor 
system handles scheduled code compiler avoid problems encountered problem assembly assembly translator texas instruments tms high performance dsp chip dsp architectures allows branches issue delay slots branches branch latency cycles compiler delay slots fill 
uses feature generate efficient albeit cryptic code 
body shorter branch latency compiler pre schedule multiple loop branches efficient loop 
resulting loop begins consecutive branches 
branches instruction instructions loop body loop branch 
run time ev ery loop branch execute systems om alto convert scheduled code back higher level representation contain delay slots 
arbitrary control flow resulting multiple branches delay slots may prove impractical 
delay slot branch 
shows product operation optimized manner 
example taken seshan pa 
leads code executes efficiently difficult analyze 
branch delays longer expect architectures experiment feature 
commodity architectures include 
systems analyze modify compiled code examples include performance analyzers debuggers link time optimizers 
systems code encounter 
executable branches execute delay slots branches algorithm correctly constructs connects basic blocks required 
necessary precursor building tools pro cess compiled code machines allow branches delay slots 
accurate set local algorithms analyzing rewriting code fail 
main result worklist algo rithm constructs correct cfg code branches delay slots branches 
applied code complexity classic cfg construction algorithms 
algorithm creates op analyze improve compiled code architectures long branch latencies execute delay slots features appear dsp architectures today 
simple example illustrate complexity arises issue branch delay slots consider code fragment inst inst inst naive scheduling code single architecture produces cfg goto inst jump nop inst jump nop inst phi phi phi phi ss hhh hj hhh hj phi phi phi phi ss nop inserted branch instruction inthe code fragment fill delay slots 
compiler tries fill delay slots delays blocks goto jump jump inst phi phi phi phi ss hhh hj hhh hj phi phi phi phi ss unfortunately nop start block remains instructions block moved delay slot branches placed inside delay slots aggressive compiler trim schedule 
jump instructions blocks promoted combined target 
results cfg assembly code goto inst inst inst phi phi phi phi ss hhh hj hhh hj phi phi phi phi ss goto jump inst inst inst assembly code shows existence delay slots quickly confusing 
locally evident examining control flow proceeds block common assumption instruction termination basic block located basic block longer valid situation quickly complicated simple example 
architecture goto inst inst jump inst inst goto inst jump inst inst inst original code goto inst inst jump inst inst goto inst jump inst inst inst step continuing example large number delay slots program branch instructions scheduled delay slots branches resulting cfg come small basic blocks clear obvious path leading 
cycles branches created branches delay slots 
result cfg construction algorithm complete ina single pass 
necessitates complex approach 
may appear problem solved 
notion misleading reasons 
replication cause significant 
second replication easily invalidate results register allocation scheduling 
understand duplicate put compiler needs cfg built forced duplicate kind simulation worklist step performs 
new algorithm cfg construction steps detecting marking labels adding standard control flow adding control flow delay slots 
steps constitute standard cfg construction algorithm 
time grows linearly program length 
branches delay slots valid cfg 
branches occur de lay slots third step needed model program behavior construct corresponding con trol flow 
base algorithm branches delay slots cfg steps 
step partitions code set basic blocks maximal length straight line code 
nodes cfg 
second step looks branches fills cfg edges represent control 
steps correspond situations terminate basic block branch 
code branches delay slots branches cfg construction steps 
block list initial list block block block list branch ound instruction bif branch ound countdown branch branch instruction countdown break countdown split remainder block edges targets iif conditional add edge branch ound countdown add edge handling normal control flow code fragment left side continuing example illustrate step algorithm 
assumes architecture delay slots branch 
step detects labels single splits label form new basic block table created label 
right side shows original code broken presence labels 
simplicity assume branches target labels pc addresses 
see earlier discussion initial set basic blocks algorithm add normal control flow 
sec ond linear pass detailed 
branch delay slot triggers cre ation counter value equal number delay slots supported architecture 
decremented additional instruc goto inst jump inst goto jump inst inst inst phi phi phi phi ss hhh hj hhh hj phi phi phi phi ss ioe adding normal control flow tion examined counters reaches zero subsequent branches ignored 
counter reaches zero block split point edges added possible targets branch 
cfg 
current block ends counter counter discarded adding edges branch targets 
occur occurs branch delay slots 
edges added algorithm third pass 
stead algorithm adds edge current block block begun labeled statement 
target machine allow branches inthe delay slots branches allow transfer control operation occupies slot branch situation handled simply replicating operations blocks 
creates label free copy code delay slots separate copy original code 
requires copy operation delay slots cost minimal 
third final step adds control flow re sults branches delay slots ignored previous steps 
algorithm simulates flow program time account control flow instructions delay slots 
necessitate splitting initial blocks turn affects continuing walk 
ex ample include jump label block cfg built step shown correct third step shown section unnecessary 
iterative algorithm completion algorithm second step cfg consists blocks branching instruction instruc tions delay slots branch 
delay slot instructions may ordinary operations nops control flow instruc tions 
architecture control flow instructions take cycles activate cycles control flow instruction issues control shifts accordingly 
control flow instruction br executes example second delay slot control flow instruction br control shift br tar gets instructions block targeted br block reached br instruction br activates 
cfg cfg builder break tar block instructions add edges lead block blocks targeted br 
algorithm proceeds symbolic walk cfg 
control passes block passes target blocks list pending control flow instructions countdown timer foreach shows activate 
call data structures branch counters instance containing pending branch numerical counter represents number cycles remain ing branch activates 
block algorithm walks instructions block order counting branch counters reaches zero 
counter reaches zero breaks block point adds edge shortened block remainder block adds edge shortened block targets activated branch 
counters list replicated passed new target blocks 
algorithm continues way block new branch counter 
efficient implement algorithm witha worklist adding block worklist time gets new branch counter 
block associ ated branch counters represent specific control flow path reached block 
block onthe worklist single point time different set branch counters denoting path block 
critical algo assume unreachable code scheduled compiled code algorithm takes input 
assumption justified branch shortened block block created hold remainder may spurious 
simple postpass final cfg detect situation remove dead branch block 
worklist start block worklist remove element worklist process block block list process block block counter list block seen counter list break instruction block decrement counters counter list branch counter list counter list branch latency counter counter list break block create new block remaining instructions block add edge block new block counter counter list block fall block worklist worklist counter list branch instruction counter list counter target block instruction add edge block target worklist worklist counter list pseudo code worklist algorithm rithm adds block block distinct new branch counter 
restriction ensures algorithm terminates 
pseudo code forthe algorithm shown 
worklist algorithm continually calls process block element worklist empty 
process block accepts block examine list branch counters 
list counters represents branches pending control flow passed current block path 
process instruction adding new branches list counters decrementing exist 
counter reaches zero block ends creates new block withthe remaining instructions adds target branch counter reached zero remaining counters 
counter reaches zero block block block added worklist current list counters 
block fall immediately block input stream 
returning continuing example block start block begins worklist 
processing block change cfg extraordinary control flow branch encountered counter reaches zero ends 
completion block successors blocks added worklist 
processing block causes changes 
contains branch delay slot 
process block reaches block counter associated jump instruction completed 
possible suc cessors terminating branch placed worklist outstanding branch counter 
block reexamined inherited complete instructions block 
forces algorithm split block add new edge shortened block block shown 
addition branch counter associated branch block completed itis propagated newly created block block block change processed block split instruction edge added back block due block block need placed worklist vis new branch counters passed 
newly created block processed block deal branch counters remains unchanged block processed branch counter inherited block block reduced single instruction counter decremented passed block worklist 
block added worklist counter reaches zero completes fall successor added worklist 
correctly conveys possible control flow path block block branches back block block processed branch counter split branch back block block added worklist processed affect cfg 
goto inst inst jump inst inst goto inst jump inst inst inst phi phi phi phi ss hhh hj hhh hj phi phi phi phi ss ioe ioe ioe final cfg note order blocks chosen list irrelevant 
cuts example happened differently blocks different order final cfg bethe cases 
termination correctness worklist step terminates con sider counter pair 
code explicitly checks case lines 
counter list consists number delay slots branch 
branch counter branch operation number range thenumber branch counters finite bis number branches 
course iis number instructions 
number counter lists finite 
number blocks finite set counter pairs finite algorithm terminates 
number possible counter large 
algorithm considers paths length start branch operation 
construct correct precise cfg speed algorithm having consider individual branch counters counter lists algorithm add spurious edges final cfg edges arise execu tion 
correctness proven contradiction assume reachable branch statement associated edge final cfg 
line algorithm shows branch added counter list appropriate edge created branch edge added counter list 
lines block encountered process counters block added counter list 
block branch statement processed 
blocks placed worklist line targets branch added worklist line block reachable start block 
contradicts original assumption branch statement 
reachable branch statement associated edge final cfg construction cfg correct 
note discussion addresses correct ness precision 
question precision general undecidable algorithm adds edge execution path calls unreachable code exception rule bottom half split block unreachable edge halves taken 
complexity complexity pass considered sepa 
step examines instruction performs instruction 
time instructions 
second step examines instruction 
operations takes time 
fora branch add edges isthe number potential branch targets branching factor 
time second step number branches 
branches program explicit targets second step requires time branches ambiguous targets branch register produce higher value branches number values reg 
worst case second step 
taken step proportional number edges cfg third step invokes process block counter pair appears worklist 
upper bound cost number ofthese pairs 
view counter list list element branch counter token indicating counter branch 
delay slot filled operation 
number bk fortunately structure code restricts set valid branch counters 
assume list increasing order 
slot occupied branch second slot null token branch reachable cycle number branches branching factor 
third slot contain null token branch second branch 
number counter lists result specific branch limited jk 
number distinct items appear worklist jk complexity third pass dominates complexity 
complex ity algorithm derives bound 
algorithm calls process block jk times 
process block examines operation tak ing time operation 
blocks process block examines twice instructions trip process block split block instruc tions entry 
worst case complexity third step jk jk practice worst case complexity depends heavily branching factor number de lay slots 
branches explicit targets jis usually 
number delay slots typically small 
example sparc onthe 
jk small con stant algorithm runs time 
adding small number delay slots adding ambiguous branches raises constant asymptotic limit 
adding single delay slot produces worst case complexity 
com bination ambiguous branches multiple delay slots causes complexity explode increased complexity reflects number potential paths algorithm consider 
paths requires constant amount 
increase complexity algorithm fore solely function increase number paths 
comparison natural ask quickly algo rithm runs situations require algorithm occur 
believe question situation occurs 
literature area shows situation occurs solutions general 
example larus schnarr examine prob lem branches single delay slot 
algorithm transforms code eliminate de lay slots case handle general case 
ramsey cifuentes approach different perspective adding looping code mimic behavior delay slots code machine delay slots machine delay slots 
compiler gives upin presence branches delay slots 
contrast algorithm handles num ber delay slots implemented tms delay slots 
existence utility aggressively pipelined loops shown forthe 
output compiler experiments power step algorithm triggered multiple sions 
years seen number systems con sume input compiled code optimized scheduled allocated 
systems provides reason compilers avoid ambiguous branches possible 
perform optimizations require data flow analy sis computed cfg 
presence branch delay slots complicates construction cfg compiled code classic algorithms building cfg results 
presents method correctly build cfg scheduled code presence delay slots 
pass algorithm construct cfg passes build normal cfg third pass uses worklist gorithm propagate branch information block block construct control flow associated delay slots 
decomposing algorithm separate steps simplifies explanation lows algorithm bypass final step code include branches branch delay slots running time algorithm dependent complexity cfg explicit targets worklist portion algorithm linear 
implemented algo rithm assembly assembly translator tms 
benefited support tions encouragement entire scalar compiler group rice university 
reid patiently answered questions tms xx ti compiler 
supported darpa contract texas advanced technology project los alamos institute 
alfred aho ravi sethi jeffrey ull man compilers principles techniques tools 
addison wesley 
andrew appel 
modern compiler imple mentation java 
cambridge university press 
bala evelyn duesterwald san banerjia 
dynamo transparent dynamic optimization system 
proceedings conference programming language design implementation pages june 
fran berman andrew chien keith cooper jack dongarra ian foster dennis gannon lennart johnsson ken kennedy carl man john mellor crummey dan reed linda torczon rich wolski 
grads project software support high level grid application development 
journal high formance computing applications winter 
preston briggs 
drawing control flow style 
july 
preston briggs keith cooper 
value numbering 
software practice experience june 
david callahan alan carle mary hall kennedy 
constructing procedure call multigraph 
ieee transactions software en april 
ron cytron jeanne ferrante barry rosen mark wegman kenneth zadeck 
efficiently computing static single assignment control dependence graph 
acm transactions programming languages sys tems january 
paul david hunter david jason 
studying performance fx system 
proceedings workshop binary translation october 
charles fischer junior 
leblanc 
crafting compiler benjamin cummings 
ian foster carl kesselman 
grid blueprint new computational infrastructure 
morgan kaufman publishers sanfrancisco ca usa 
gina ken kennedy chau wen tseng practical dependence testing 
sigplan notices june 
proceedings ofthe acm sigplan conference programming language design implementation 
david goodwin 
interprocedural executable optimizer 
sigplan notices june 
proceed ings acm sigplan conference programming language design implemen tation 
allan 
compiler design prenticehall 
james larus eric schnarr 
eel machine independent executable editing 
sigplan notices june 
pro ceedings acm sigplan conference programming language design imple mentation 
dror maydan john hennessy mon ica lam 
efficient exact dependence analysis 
sigplan notices june proceedings acm sigplan conference programming language design im plementation 
charles morgan 
building 
digital press 
steven muchnick 
advanced compiler design implementation 
morgan kauffman 
robert muth saumya debray scott koen de 
alto link time optimizer compaq alpha 
software experience pages january 
karl robert hansen 
profile positioning 
sigplan notices june 
proceedings acm sig plan conference programming language design implementation 
norman ramsey cristina cifuentes 
approach binary translation delayed branches 
technical report department computer science university virginia department computer sci ence electrical engineering university queensland december 
nat seshan 
high processing 
ieee sig nal processing magazine pages march 
amitabh srivastava david wall 
prac tical system intermodule code optimization link time 
journal programming languages pages march 
sun microsystems java machine 
available online java sun com products hotspot 
philip beatty 
dominator path schedule global scheduling method 
proceedings th annual interna tional symposium microarchitecture december 
reid 
private communication 
dis related tms xxx isa andthe code produced texas instruments compiler processors 
todd waterman 
post compilation analysis reduction 
master thesis rice university december 
daniel weaver tom editors sparc architecture manual version 
ptr prentice hall 

