optimal aggregation algorithms middleware ronald fagin amnon lotem moni naor assume object database grades scores attributes 
example object color grade tells red shape grade tells round attribute sorted list lists object grade attribute sorted grade highest grade 
monotone aggregation function rule min average combines individual grades obtain grade 
determine top objects best grades naive algorithm access object database find grade attribute 
fagin algorithm fagin algorithm fa efficient 
monotone aggregation functions fa optimal high probability worst case 
analyze elegant remarkably simple algorithm threshold algorithm ta optimal stronger sense fa 
show ta essentially optimal just monotone aggregation functions just high probability worst case sense database 
fa requires large buffers size may grow unboundedly database size grows ta requires small constant size buffer 
ta allows early stopping yields precise sense approximate version top answers 
distinguish types access sorted access middleware system obtains grade object sorted list proceeding list sequentially top random access middleware system requests grade object list obtains step 
consider scenarios random access impossible expensive relative sorted access provide algorithms essentially optimal cases 
extended appeared proc 
twentieth acm symposium principles database systems pods pp 

ibm almaden research center harry road san jose california 
email fagin almaden ibm com university maryland college park dept computer science college park maryland 
email lotem cs umd edu dept computer science applied mathematics weizmann institute science rehovot israel 
email naor wisdom weizmann ac il 
author performed visiting scientist ibm almaden research center 
early database systems required store small character strings entries tuple traditional relational database 
data quite homogeneous 
today wish database systems able deal character strings small large heterogeneous variety multimedia data images video audio 
furthermore data wish access combine may reside variety data repositories may want database system serve middleware access data 
fundamental difference small character strings multimedia data multimedia data may attributes inherently fuzzy 
example say image simply red red 
degree ranges red totally red 
approach fag deal fuzzy data aggregation function xm interval grades object attributes xm grade object shall discuss aggregation functions useful contexts :10.1.1.55.2172
large literature choices aggregation function see zimmermann textbook zim discussion fag :10.1.1.55.2172:10.1.1.55.2172
popular choice aggregation function min 
fact standard rules fuzzy logic object grade attribute attribute grade fuzzy conjunction min 
popular aggregation function average sum contexts care resulting grade longer lies interval 
say aggregation function monotone xm xi certainly monotonicity reasonable property demand aggregation function attribute grade object high object expect grade high notion query different multimedia database system traditional database system 
query traditional database system relational database system unordered set answers 
contrast multimedia database system answer query thought sorted list answers sorted grade 
fag shall identify query choice aggregation function user typically interested finding top answers parameter ork :10.1.1.55.2172:10.1.1.55.2172
means want obtain objects may refer top objects highest grades query grades ties broken arbitrarily 
convenience think constant value consider algorithms obtaining top answers databases contain objects 
applications applications multimedia databases aggregation function combine grades want find top answers 
important example information retrieval sal objects interest documents attributes search terms sm grade xi measures relevance document shall abuse notation write grade xm course relational database result query may sorted way convenience presentation sorting department members salary logically speaking result simply set defined collection members 
search term si common take aggregation function sum 
total relevance score document query consists search terms sm taken xm xm 
application arises franklin af scheduling large scale ondemand data broadcast 
case object page fields 
field represents amount time waited earliest user requesting page second field represents number users requesting page 
product function wish broadcast page top score 
model assume database consists finite set objects 
shall typically take represent number objects 
associated object fields xm xi may refer xi ith field database thought consisting sorted lists lm length entry list objects 
may refer li list entry li form xi xi ith field list li sorted descending order xi value 
take simple view database view relevant far algorithms concerned 
completely ignoring computational issues 
example practice expensive compute field values ignore issue take field values 
consider modes access data 
mode access sorted sequential access 
middleware system obtains grade object sorted lists proceeding list sequentially top 
object th highest grade ith list sorted accesses ith list required see grade sorted access 
second mode access random access 
middleware system requests grade object ith list obtains random access 
sorted accesses random accesses sorted access cost scs random access cost rcr middleware cost scs rcr sum sorted access cost random access cost 
algorithms obvious naive algorithm obtaining top answers 
looks entry sorted lists computes grade object returns top answers 
naive algorithm linear middleware cost linear database size efficient large database 
fagin fag introduced algorithm fagin algorithm fa better naive algorithm :10.1.1.55.2172:10.1.1.55.2172:10.1.1.55.2172
case orderings sorted lists probabilistically independent fa finds top answers database objects middleware cost arbitrarily high probability 
fagin proved independence assumption assumption aggregation function correct algorithm high probability incur similar middleware cost worst case 
shall threshold algorithm ta 
algorithm discovered independently groups including ramakrishna nr publish balke :10.1.1.31.9882:10.1.1.31.9882
information comparison see section related 
shall discuss probability model including notion independence track 
details see fag :10.1.1.55.2172:10.1.1.55.2172
second author defined ta extensive simulations comparing fa project database course taught michael franklin university maryland college park fall 
shall show ta optimal stronger sense fa 
define notion optimality consider interesting right 
instance optimality class algorithms class legal inputs algorithms 
assume considering particular nonnegative performance cost measure cost represents amount resource consumed running algorithm input 
cost running time algorithm input middleware cost incurred running algorithm database say algorithm instance optimal cost cost equation means constants cost cost choice 
refer optimality ratio 
similar competitive ratio competitive analysis shall discuss competitive analysis shortly 
word optimal reflect fact essentially best algorithm intuitively instance optimality corresponds optimality instance opposed just worst case average case 
algorithms optimal worst case sense instance optimal 
example binary search worst case binary search guaranteed require log probes data items 
instance positive answer obtained probe negative answer probes 
consider nondeterministic algorithm correct branch mistake 
take middleware cost nondeterministic algorithm minimal cost branches halts top answers 
take middleware cost probabilistic algorithm expected cost probabilistic choices algorithm 
say deterministic algorithm instance optimal really comparing best nondeterministic algorithm contains deterministic algorithms 
deterministic algorithm choices nondeterministic algorithm 
view cost best nondeterministic algorithm produces top answers database cost shortest proof database really top answers 
instance optimality quite strong cost instance optimal algorithm essentially cost shortest proof 
similarly view contains probabilistic algorithms mistake 
convenience proofs shall assume contains deterministic algorithms results carry automatically nondeterministic algorithms probabilistic algorithms mistake 
fa optimal high probability worst case sense certain assumptions 
ta optimal stronger sense instance optimal natural choices particular instance optimality holds taken class algorithms normally implemented practice algorithms excluded lucky guesses taken class databases 
instance optimality ta holds case monotone aggregation functions 
contrast high probability worst case optimality fa holds assumption strictness shall define strictness intuitively means aggregation function representing notion conjunction 
definition instance optimality formally definition competitive analysis bey st competitive analysis assume cost typically represent performance cost 
competitive analysis typically class instances particular problem class offline algorithms give solution instances cost number represents goodness solution bigger numbers correspond worse solution particular online algorithm 
case online algorithm said competitive 
intuition competitive online algorithm may perform poorly instances instances offline algorithm perform poorly 
example framework instance optimality appears assumption cost represent performance cost context approximation algorithms hoc 
case class instances particular problem class algorithms solve instances exactly cases interest algorithms polynomial time algorithms cost value resulting answer algorithm applied input particular polynomial time algorithm 
dagum give interesting example call instance optimal algorithm 
consider problem determining mean unknown random variable monte carlo estimation 
case class random variables distributed interval class algorithms repeatedly doing independent evaluations random variable averaging results obtain estimate mean random variable precision probability cost expected number independent evaluations random variable algorithm algorithm call aa approximation algorithm 
main result says terminology aa instance optimal demaine dlm give example algorithm close instance optimal 
consider problem finding intersection union collection sorted sets 
case class instances collections sorted sets class algorithms pairwise comparisons elements cost running time number comparisons running algorithm instance algorithm 
certain sense algorithm close call instance optimal explain details take far astray 
approximation early stopping times user may satisfied approximate top list 
assume 
define approximation top answers aggregation function collection objects grades objects objects 
note definition gives top answers 
show modify ta give approximation prove instance optimality modified algorithm certain assumptions 
fact easily modify ta interactive process time system show user current view top list guarantee degree approximation correct answer 
user decide process point 
restricting random access shall discuss section systems random access impossible 
deal situations show section modify ta obtain algorithm nra random accesses random accesses 
prove nra instance optimal algorithms random accesses databases 
situations random access forbidden simply expensive 
wimmers discuss number systems issues cause random access expensive 
ta instance optimal optimality ratio depends ratio cs cost single random access cost single sorted access 
define algorithm combination ta nra call ca combined algorithm 
definition algorithm depends cr cs 
motivation obtain algorithm instance optimal optimality ratio independent cr cs 
original hope ca instance optimal optimality ratio independent cr cs scenarios ta instance optimal 
hope fail interestingly prove exist deterministic algorithm probabilistic algorithm mistake optimality ratio independent cs scenarios 
find new natural scenario ca instance optimal optimality ratio independent cr cs 
outline section discuss modes access sorted random data 
section fa fagin algorithm properties 
section ta threshold algorithm 
section show ta instance optimal natural scenarios 
important scenario give theorem says optimality ratio ta best possible 
section discuss dependence optimality ratio various parameters 
section show turn ta approximation algorithm prove instance optimality approximation algorithms 
show user prematurely halt ta precise sense treat current view top answers approximate answer 
section consider situations suggested bruno gravano marian bgm sorted access impossible certain sorted lists 
section focus situations random accesses impossible expensive 
section nra random access algorithm show instance optimality algorithms random accesses 
give theorem says optimality ratio nra best possible 
section ca combined algorithm result combining ta nra order obtain algorithm intuitively minimizes random accesses 
section show instance optimality ca optimality ratio independent cr cs natural scenario 
section show careful choice ca random accesses necessary instance optimality ratio independent cr cs 
compare contrast ca versus ta 
section prove various lower bounds optimality ratio deterministic algorithms probabilistic algorithms mistake 
summarize upper lower bounds section 
section discuss related 
section give state open problems 
modes access data issues efficient query evaluation middleware system different traditional database system 
middleware system receives answers queries various subsystems accessed limited ways 
assume interface middleware system subsystem 
consider qbic nbe query image content subsystem 
qbic search images various visual characteristics color texture experimental version search shape 
response query color red subsystem output graded set consisting objects grades query sorted order grade middleware system tells subsystem halt 
middleware system tell subsystem resume outputting graded set left 
alternatively middleware system ask subsystem say qbic trademark ibm 
top objects sorted order grades request cases corresponds referred sorted access 
way expect middleware system interact subsystem 
middleware system ask subsystem grade respect query object 
corresponds referred random access 
fact qbic allows sorted random access 
situations middleware system allowed random access subsystem 
example occur middleware system text retrieval system subsystems search engines 
way ask major search engine web internal score document choice query 
measure cost corresponds intuitively cost incurred middleware system processing information passed subsystem qbic 
sorted accesses random accesses middleware cost taken scs rcr positive constants cs cr 
fact cs cr may different reflects fact cost middleware system sorted access random access may different 
fagin algorithm section discuss fa fagin algorithm fag :10.1.1.55.2172
algorithm implemented garlic chs experimental ibm middleware system see interesting details implementation performance practice 
chaudhuri gravano cg consider ways simulate fa filter conditions say example color score 
fa works follows 

sorted access parallel sorted lists li 
parallel mean access top member lists sorted access access second member lists 
wait matches wait set objects objects seen lists 

object seen random access lists li find ith field xi 
compute grade xm object seen 
set containing objects seen highest grades ties broken arbitrarily 
output graded set fairly easy show fag algorithm correct monotone aggregation functions algorithm successfully finds top answers :10.1.1.55.2172
objects database orderings sorted lists probabilistically independent middleware cost fa arbitrarily high probability fag :10.1.1.55.2172
important lists accessed lockstep 
practice may convenient allow sorted lists accessed different rates batches algorithms sorted access parallel remain correct sorted access lockstep 
furthermore instance optimality results continue hold sorted access lockstep long rates sorted access lists constant multiples 
graded sets sorted order sorted grade 
aggregation function strict fag xm holds precisely xi aggregation function strict takes maximal value precisely argument takes maximal value :10.1.1.55.2172
certainly expect aggregation function representing conjunction strict see discussion fag :10.1.1.55.2172:10.1.1.55.2172
fact reasonable think strictness key characterizing feature conjunction 
fagin shows algorithm optimal high probability worst case aggregation function strict intuitively dealing notion conjunction orderings sorted lists probabilistically independent 
fact access pattern fa oblivious choice aggregation function fixed database middleware cost fa exactly matter aggregation function true constant aggregation function case course trivial algorithm gives top answers objects middleware cost 
fa optimal sense monotone aggregation functions interesting example aggregation function max strict shown fag simple algorithm mk sorted accesses random accesses finds top answers :10.1.1.55.2172:10.1.1.55.2172
contrast shall see algorithm ta instance optimal monotone aggregation function weak assumptions 
cases fa optimal optimality holds worst case high probability 
leaves open possibility algorithms better middleware cost fa certain databases 
algorithm ta discuss algorithm 
threshold algorithm threshold algorithm ta 

sorted access parallel sorted lists li 
object seen sorted access list random access lists find grade xi object list li 
compute grade xm object grade highest seen remember object grade ties broken arbitrarily objects grades need remembered time 

list li grade object seen sorted access 
define threshold value 
soon objects seen grade equal halt 

set containing objects seen highest grades 
output graded set show ta correct monotone aggregation function theorem aggregation function monotone ta correctly finds top answers 
proof part ta 
need show member high grade object definition case object seen may wasteful random access find grade determined earlier 
discuss done order avoid unbounded buffers 
running ta 
assume seen 
assume fields xm 
xi xm inequality follows monotonicity definition desired 
show stopping rule ta occurs early stopping rule fa sorted accesses fa 
fa object appeared sorted access list monotonicity grade equal threshold value 
objects appeared sorted access list stopping rule fa objects grade equal threshold value stopping rule ta 
implies database sorted access cost ta fa 
imply middleware cost ta fa ta may random accesses fa 
middleware cost ta sorted access cost times constant independent database size follow middleware cost ta constant times fa 
fact shall show ta instance optimal natural assumptions 
consider intuition ta 
simplicity discuss case user trying determine top answer 
assume stage algorithm seen object grade big threshold value intuition point know top answer object see sorted access grade bigger grade object seen far 
furthermore see object grade safe halt see proof theorem 
intuitively stopping rule ta says halt soon know seen top answer similarly general stopping rule ta says intuitively halt soon know seen top answers view ta saying sorted access corresponding random access know seen top answers 
little generally view ta saying gather information need allow know top answers halt 
programs viewed high level knowledge programs 
fact ta viewed designed thinking terms knowledge programs 
shall give scenario situations random accesses forbidden knowledge programs implementation different 
consider scenario random accesses expensive relative sorted accesses forbidden need additional design principle decide gather information order design optimal algorithm 
simple theorem gives useful property ta distinguishes ta fa 
theorem ta requires bounded buffers size independent size database 
proof little bit bookkeeping ta remember current top objects grades pointers objects seen sorted order list 
contrast fa requires buffers grow arbitrarily large database grows fa remember object seen sorted order list order check matching objects various lists 
price pay bounded buffers 
time object sorted access ta may random accesses number lists find grade object lists 
spite fact object may seen lists 
instance optimality threshold algorithm section investigate instance optimality ta 
intuitive argument ta instance optimal 
algorithm stops sooner ta database finds objects grade equal threshold value mistake database object list grade xi list grade xm new object seen higher grade object top list output stopping soon 
convert intuitive argument proof monotone aggregation function ta instance optimal algorithms correctly find top answers class databases 
shall see situation somewhat delicate 
distinction algorithms wild guesses perform random access objects previously encountered sorted access 
fa ta wild guesses natural algorithm context 
theorem theorem says monotone aggregation function ta instance optimal algorithms correctly find top answers wild guesses class databases 
show distinction wild guesses vs wild guesses essential algorithms wild guesses allowed class algorithms instance optimal algorithm compete algorithm instance optimal example theorem 
heart example corresponding theorem fact may multiple objects grade list 
restrict attention databases objects value list slight natural additional restriction aggregation function monotonicity ta instance optimal algorithms correctly find top answers theorem 
section consider instance optimality situation relax problem finding top objects finding approximately top give positive result instance optimality ta 
say algorithm wild guesses random access find grade object list algorithm seen sorted access 
algorithm wild guesses grade obtains object random access 
normally implement algorithms wild guesses 
fact contexts possible wild guesses database context algorithm know name object seen 
making lucky wild guess help show example 
show instance optimality ta algorithms wild guesses 
theorem take class databases really mean class databases involve sorted lists corresponding arguments aggregation function trying find top answers aggregation function fixed 
fixed number arguments number sorted lists fixed 
section discuss assumptions constant 
theorem assume aggregation function monotone 
class databases 
class algorithms correctly find top answers database wild guesses 
ta instance optimal proof assume algorithm run database assume algorithm halts depth di number objects seen sorted access list maxi di 
assume sees distinct objects possibly multiple times 
particular wild guesses sees distinct objects sorted accesses middleware cost acs 
shall show ta halts depth middleware cost ta mcs cr am cr plus additive constant km cr 
optimality ratio ta am cr acs cr cs 
shall show aggregation function strict precisely optimality ratio ta best possible 
note choice algorithm ta sees objects depth depth md sorted accesses object accessed times sorted access 
output set consisting top objects 
objects see ta halts depth having seen object done 
assume objects see 
size object see threshold value algorithm halts 
means xi grade object seen sorted access list algorithm xm 
list accessed sorted access take xi call object big call object small 
show member big 
define database just object grade xi ith list put list objects grade xi list 
algorithm performs exactly particular gives output databases algorithm output database grade follows correctness big desired 
cases depending algorithm sees member output set case algorithm sees member depth ta see member showed member big follows ta halts depth desired 
case algorithm see member show object seen big 
define database just object seen grade list xi put list objects grade xi list 
grade database distinguish output see see sake generality allowing possibility algorithm output object seen 
discuss issue section 
information distinguish able give output making mistake 
output correctness follows big 
big desired 
sees objects ta sees objects depth follows depth ta sees objects seen shown object seen big 
depth ta sees big objects 
ta halts depth desired 
proof theorem showed assumptions theorem wild guesses optimality ratio ta cr cs 
theorem says aggregation function strict optimality ratio precisely value best possible 
recall aggregation function strict xm holds precisely xi intuitively strictness means aggregation function representing notion conjunction 
theorem arbitrary monotone strict aggregation function arguments 
class databases 
class algorithms correctly find top answers database wild guesses 
ta instance optimal optimality ratio cr cs 
deterministic algorithm lower optimality ratio 
proof proof theorem shown ta optimality ratio cr cs arbitrary monotone aggregation function lower bound follows theorem 
drop assumption strictness theorem 
example aggregation function max strict 
easy see ta halts rounds sorted access optimality ratio add best possible max 
consider sorted access cost 
corresponds 
see theorem optimality ratio ta furthermore follows easily proof theorem aggregation function strict cr best possible deterministic algorithm lower optimality ratio consider random access cost 
corresponds cs case ta far instance optimal 
naive algorithm sorted access object list random accesses sorted access cost 
show making lucky wild guess help 
example assume objects call simply lists 
assume list objects order top objects grade remaining objects note instance optimality ta theorem holds aggregation function strict 
example instance optimality ta theorem holds aggregation function max 
contrast situation fa high probability worst case optimality fails aggregation function max 
theorem assumption strictness order show optimality ratio ta precisely cr cs best possible 
assuming cr cs strictly positive 
theorem proof theo rem hold allow cr 
grade 
assume list objects reverse order bottom objects grade remaining objects grade 
assume aggregation function min interested finding top answer 
clear top answer object grade object object grade 
algorithm wild guess asks grade object lists determine correct answer able halt safely random accesses sorted accesses 
algorithm ta wild guesses 
winning object middle sorted lists follows sorted accesses required algorithm see winning object 
enlarge class algorithms allow queries form object ith largest grade list grade list see example replace wild guess query asks object st largest grade list ta instance optimal 
effectively new queries just bad wild guesses 
example shows ta instance optimal class algorithms find top answer min arguments class databases 
theorem says circumstances ta instance optimal algorithm 
theorem class databases 
class algorithms correctly find top answer min arguments database 
deterministic algorithm probabilistic algorithm mistake instance optimal proof modify example obtain family databases sorted lists 
list objects order top objects having grade remaining objects having grade 
second list objects reverse order top objects having grade remaining objects having grade 
unique object grade object middle orderings remaining object grade 
arbitrary deterministic algorithm consider distribution databases member ordering list chosen uniformly random ordering second list reverse ordering list 
easy see expected number accesses sorted random algorithm distribution order see winning object 
database number accesses equal expected number accesses number accesses database 
example algorithm random accesses sorted accesses 
optimality ratio arbitrarily large 
theorem follows deterministic case 
probabilistic algorithms mistake appeal yao minimax principle yao see section see lemma simple proof says algorithm halt safely knows object maximal possible grade grade maximal assuming grades lie 
assume grades lie additional sorted access provide information grade database 
expected cost optimal deterministic algorithm arbitrary input distribution lower bound expected cost optimal probabilistic algorithm mistake 
noted earlier algorithms wild guesses normally implemented practice interesting consider 
interpretation instance optimality algorithm saying cost essentially cost shortest proof database really top answers 
consider algorithms allow wild guesses allowing larger class proofs 
example fact object grade proof top answer 
say aggregation function strictly monotone xm xi average min strictly monotone aggregation functions suggested literature representing conjunction disjunction monotone strictly monotone see fag zim examples :10.1.1.55.2172
say database satisfies distinctness property objects grade list grades list li distinct 
show conditions guarantee optimality ta algorithms wild guesses 
theorem assume aggregation function strictly monotone 
class databases satisfy distinctness property 
class algorithms correctly find top answers database ta instance optimal proof assume algorithm run database 
assume sees distinct objects possibly multiple times 
shall show ta halts depth ta accesses plus additive constant 
follows easily optimality ratio ta cm cs cs crg 
objects see ta halts depth having seen object done 
assume objects see 
size object see shall show ta halts depth 
threshold value ta depth 
xi grade th highest object list xm 
call object big call object small 
note definitions big small different proof theorem show member big 
grade top grades list grade list object seen grade grades list distinct sees objects 
agree objects seen object grade ith list grade unseen assigned grades list level reached sorted access follows algorithm performs exactly particular gives output databases algorithm output database correctness follows big desired 
claim member top members list seen ta depth 
assume way contradiction top members confused aggregation function strict monotone 
apologize clash terminology exists historical reasons 
list assumptions aggregation function strictly monotone 
satisfies distinctness property follows easily small 
showed member big 
contradiction proves claim 
follows ta halts depth desired 
proof theorem showed assumptions theorem strict monotonicity distinctness property optimality ratio ta cm cs cs crg 
theorem give aggregation function strictly monotone deterministic algorithm optimality ratio cr case greatest interest cs cr cs gap factor upper lower bounds 
proofs theorems nice properties proofs go scenario random access object list takes place learn grade list relative rank 
ta instance optimal allow include algorithms learn relative rank information 
shall see prove instance optimality approximation algorithms approximation version ta assumptions theorem small change proof theorem hold assumptions theorem 
treating constants theorems instance optimality ta treating trying find top answers number sorted lists constants 
discuss assumptions 
assumption constant 
proofs theorems number accesses algorithm 
ifa need treat constant 
restrict class algorithms contain algorithms accesses find top answers need assume constant 
arise algorithm find top answers making accesses particular accessing objects 
happen objects database object seen grade 
occur example constant function 
circumstances reasonable contexts certain database contexts allow algorithm output object member top objects having seen algorithm know name object 
similar issue raised earlier wild guesses 
assumption constant 
noted earlier certainly reasonable assumption number arguments aggregation function course fixed 
case assumptions theorem wild guesses theorem tells strict aggregation functions dependence inevitable 
similarly case assumptions theorem strict monotonicity distinctness property theorem tells certain aggregation functions dependence inevitable 
turning ta approximation algorithm allowing early stopping ta easily modified approximation algorithm 
situations care approximately top answers 

define approximation top answers database collection objects grades objects objects 
modify ta find approximation top answers modifying stopping rule part say soon objects seen grade equal halt call approximation algorithm ta theorem assume aggregation function monotone 
ta correctly finds approximation top answers proof follows straightforward modification proof theorem 
theorem says wild guesses allowed ta instance optimal 
theorem assume aggregation function monotone 
class databases 
class algorithms find approximation top answers database wild guesses 
ta instance optimal proof proof theorem carries verbatim provided modify definition object big theorem shows analog theorem holds ta example modification example shows analog theorem hold ta interpretation results theorem sufficiently robust survive perturbation allowing approximations theorem 
example assume objects call simply lists 
assume list grades assigned grades different ordering objects grade object grade object grade 
assume list grades assigned grades different ordering objects grade reverse ordering object grade object grade 
assume aggregation function min interested finding approximation top answer 
grade object object 
grade object follows unique object returned algorithm ta correctly finds approximation top answer object 
algorithm wild guess asks grade object lists determine correct answer able halt safely random accesses sorted accesses 
algorithm halt safely knows object big possible grade 
sorted access list ta see objects order sorted access list ta see objects reverse order 
winning object middle sorted lists follows sorted accesses required ta see winning object 
just converted example theorem convert example theorem 
theorem assume 
class databases satisfy distinctness property 
class algorithms find approximation top answer min database deterministic algorithm probabilistic algorithm mistake instance optimal early stopping ta straightforward modify ta interactive process time system show user current top list guarantee degree approximation correct answer 
user decide process point 
grade kth bottom object current top list current threshold value algorithm stopped early 
easy see similarly situation theorem current top list approximation top answers 
user current top list number told approximation top answers 
restricting sorted access bruno gravano marian bgm discuss scenario possible access certain lists sorted access 
give nice example user wants get information restaurants 
user aggregation function gives score restaurant inexpensive close example review web site gives ratings restaurants nyt review web site gives prices web site gives distances 
review web site accessed sorted access best restaurants top list 
set indices lists li accessed sorted access 
assume nonempty lists accessed sorted access 
take cardinality jzj take total number sorted lists 
define taz natural modification ta deals restriction sorted access 

sorted access parallel sorted lists li object seen sorted access list random access lists find grade xi object list li 
compute grade xm object grade highest seen remember object grade ties broken arbitrarily objects grades need remembered time 

list li grade object seen sorted access 
list li 
define threshold value 
soon objects seen grade equal halt 
shall see example objects possible seeing grade object list having done sorted access object list objects grade equal final threshold value situation say taz halts seen grade object list 
situation happen ta 

set containing objects seen highest grades 
output graded set case jzj algorithm taz essentially algorithm ta adapt bgm 
footnote noted algorithms sorted access parallel remain correct sorted access lockstep 
algorithm taz provides extreme example sorted lists accessed sorted access remaining sorted lists accessed random access 
show theorem says ta instance optimal wild guesses allowed theorem says optimality ratio ta wild guesses allowed best possible generalize hold ta theorem instance optimality ta theorem says aggregation function strictly monotone class legal databases satisfies distinctness property ta instance optimal 
interestingly shall show example theorem generalize taz 
theorem assume aggregation function monotone 
class databases 
class algorithms correctly find top answers database wild guesses lists may accessed sorted access lists li taz instance optimal proof proof essentially proof theorem bookkeeping 
assume algorithm run database assume algorithm halts depth di number objects seen sorted access list maxi di 
assume sees distinct objects possibly multiple times 
wild guesses sees distinct objects sorted accesses middleware cost acs 
proof theorem follows taz halts depth middleware cost taz cs cr am cs am cr plus additive constant km cs km cr 
optimality ratio taz am cs am cr acs cr cs 
theorem analogous theorem 
theorem arbitrary monotone strict aggregation function arguments 
assume jzj class databases 
class algorithms correctly find top answers database wild guesses lists may accessed sorted access lists taz instance optimal optimality ratio cr cs 
deterministic algorithm lower optimality ratio 
proof proof theorem shown taz optimality ratio cr cs arbitrary monotone aggregation function lower bound follows simple variation proof theorem take dm cs dm cr 
simple details left reader 
theorem says aggregation function strictly monotone class legal databases satisfies distinctness property ta instance optimal 
show example analogous result fails taz 
fact shall show taz need instance optimal assume aggregation function strictly monotone class legal databases satisfies distinctness property addition assume aggregation function strict wild guesses allowed 
example assume sorted lists may accessed sorted access 
aggregation function min fx yg zg 
easy see strictly monotone strict 
assume interested finding top answer 
assume object grade lists grade list 

note object necessarily grade distinctness property 
unique top object 
assume minimum grade list 
follows threshold value 
taz halt seen grade object list 
algorithm sorted access top object list random access lists halts announces top object 
algorithm sorted access random accesses database 
safe algorithm halt knows object grade object grade bigger 
arbitrarily large number objects follows taz instance optimal 
analogue theorem fails taz 
instructive understand goes wrong example problem cause theorems fail 
intuitively goes wrong example threshold value conservative estimate upper bound grade unseen objects 
contrast case theorem unseen object may grade equal threshold value threshold value conservative estimate 
case theorem analysis proof shows consider threshold value depth depth intuitively threshold value may conservative estimate threshold value extra level 
minimizing random access far especially concerned number random accesses 
algorithms discussed far fa ta sorted access random accesses take place 
recall number sorted accesses number random accesses middleware cost scs rcr positive constants cs cr 
notion optimality ignores constant factors simply multiplicative factors optimality ratio 
motivation far concern ourself number random accesses 
scenarios pay attention number random accesses 
scenario random accesses impossible corresponds cr 
discussed section example scenario arises middleware system text retrieval system sorted lists correspond results search engines 
scenario random accesses impossible simply expensive relative sorted access 
example second scenario arises costs correspond disk access sequential versus random 
optimality ratio independent cs 
treating cs cr constants allow vary optimality ratio bounded 
section describe algorithms random access 
give algorithms 
uses random accesses called nra random access 
second algorithm takes account cost random access 
combination nra ta call ca combined algorithm 
algorithms access information natural way spirit knowledge programs section halt know improvement take place 
general point execution algorithms number sorted random accesses taken place object subset fi mg fields algorithm determined values xi xi xi fields 
information define functions information lower upper bounds value obtain 
algorithm proceeds candidates current upper bound better current kth largest lower bound 
lower bound object subset fi mg known fields values xi xi xi known fields define ws subset clear minimum worst value aggregation function attain object monotone minimum value obtained substituting missing field value applying result 
example ws 
property immediate definition proposition set known fields object ws 
words represents lower bound 
best possible 
additional information value appear lists 
general algorithm progresses learn fields object value larger smaller 
aggregation functions value yields knowledge includes fields instance min values discovered 
functions meaningful 
instance median fields soon known smaller 
upper bound best value object attain depends information 
bottom values field defined ta xi smallest value obtained sorted access list li 
object subset fi mg known fields values xi xi xi known fields define bs subset clear maximum best value aggregation function attain object monotone maximum value obtained substituting missing field value xi applying result 
example bs xm 
property immediate definition proposition set known fields object bs 
words represents upper bound value best value information far 
best upper bound 
lists may contain equal values general assume information possible bs 
distinctness property holds equalities allowed list continuous aggregation functions case best upper bound value general algorithm progresses learn fields object bottom values xi decrease decrease remain 
important special case object encountered 
case xm 
note threshold value ta 
random access algorithm nra discussed situations random accesses forbidden 
consider algorithms random accesses 
random accesses forbidden section change criterion desired output 
earlier sections demanded output top answers consists top objects grades 
section weaker requirement output consist top objects grades 
reason random access impossible may cheaper require fewer accesses find top answers grades 
show example obtain partial information grades know object top objects knowing exact grade 
example consider scenario aggregation function average interested top object 
sorted lists grade object object grade grade 
sorted accesses sorted access information know object top object average grade object average grade 
wished find grade object need sorted access 
note requiring output consist top objects information sorted order sorted grade 
wish know sorted order easily determined finding top object top objects ci cost finding top objects 
interesting note necessary relationship cj example example 
modify example objects grade grade grade remaining grades objects lists 
cost finding top objects sorted order max ci 
treating constant follows easily convert instance optimal algorithm shall give shortly finding top objects instance optimal algorithm finding top objects sorted order 
practice usually know top objects sorted order knowing grades 
fact major search engines web longer give grades possibly prevent reverse engineering 
algorithm nra follows 

sorted access parallel sorted lists li 
depth objects accessed sorted access list maintain bottom values encountered lists 
object discovered fields mg compute values ws bs 
objects seen values virtually computed xm threshold value 
current top list contain objects largest values seen far grades objects value ties broken values object highest value wins arbitrarily objects tie highest value 
kth largest value 
call object viable halt distinct objects seen particular contains objects viable objects left outside return objects show nra correct monotone aggregation function theorem aggregation function monotone nra correctly finds top objects 
proof assume nra halts sorted accesses list fr 
objects output nra rk 
object rk 
show ri algorithm halts depth know depth proposition 
objects ri ri ri proposition definition 
combining inequalities shown desired 
ri ri note tie breaking mechanism needed correctness instance optimality 
claim instance optimality nra algorithms random access theorem assume aggregation function monotone 
class databases 
class algorithms correctly find top objects database random accesses 
nra instance optimal proof assume 
algorithm nra halts depth nra saw distinct objects time depth nra constant number accesses km database 
suppose database algorithm nra halts depth nra saw distinct objects depth 
claim get depth lists 
follows optimality ratio nra theorem follows 
suppose claim fails fact algorithm nra halt depth object know know tie breaking mechanism ri ri necessarily ri 
cases depending algorithm outputs top objects 
case construct database errs 
case algorithm outputs top objects 
construct database errs follows 
database identical depth top objects grades list li 
ri missing field ri assign value object assign missing fields value 
show rj top objects algorithm 
ri ri ri ri desired 
assume consider separately subcases ri 
wish show ri ri subcase ri 
ri ri desired inequality follows tie breaking mechanism 
subcase see ri ri 
ri desired 
ri 
inequalities case algorithm output top objects 
construct database errs follows 
database identical depth 
depth gives missing field value remaining missing fields including missing fields rk assign value 
ri ri ri ri object rk algorithm outputting top objects 
note issue wild guesses relevant restricting attention algorithms random accesses wild guesses 
proof theorem showed optimality ratio nra show aggregation function strict optimality ratio precisely best possible 
theorem arbitrary monotone strict aggregation function arguments 
class databases 
class algorithms correctly find top objects database random accesses 
nra instance optimal optimality ratio deterministic algorithm lower optimality ratio 
proof proof theorem shown nra optimality ratio arbitrary monotone aggregation function lower bound follows theorem 
unfortunately execution nra may require lot bookkeeping step nra sorted access depth value updated object seen far 
may updates depth yields total updates depth furthermore ta longer suffices bounded buffers 
specific function min possible appropriate data structures computation greatly simplified 
issue investigation 
account random access cost combined algorithm ca random accesses takes cost relative sorted access account 
cs cost sorted access cr cost random access 
middleware cost algorithm sorted accesses random ones scs rcr 
know ta instance optimal optimality ratio function relative cost random access sorted access cr cs 
goal section find algorithm instance optimal optimality ratio independent cs 
view ca merge ta nra 
csc 
assume section cr cs 
idea ca run nra steps run random access phase update information upper lower bounds accordingly 
section section require output consist top objects grades 
wish obtain grades requires constant number additional random accesses effect instance optimality 
algorithm ca follows 

sorted access parallel sorted lists li 
depth objects accessed sorted access list maintain bottom values encountered lists 
object discovered fields mg compute values ws bs 
objects seen values virtually computed xm threshold value 
current top list contain objects largest values seen far grades objects value ties broken values object highest value wins arbitrarily objects tie highest value 
kth largest value 
call object viable steps time depth sorted access increases pick viable object seen fields known value big possible ties broken arbitrarily 
perform random accesses missing fields 
object random access step reason escape clause ca wild guess 
give example escape clause may invoked 
assume cs 
assume round sorted access parallel object appears lists 
opportunity random access escape clause invoked 
halt distinct objects seen particular contains objects viable objects left outside return objects note large say larger number objects database algorithm ca nra random access performed 
algorithm ca similar ta different intriguing ways 
step doing sorted access parallel ca performs random accesses missing fields object 
performing random accesses missing fields object ta performs random accesses missing fields object seen sorted access 
section discuss ca versus ta 
moderate values case ca equivalent intermittent algorithm executes steps nra step ta 
show section example intermittent algorithm performs worse ca 
difference algorithms ca picks wisely objects perform random access values 
consider knowledge program section design instance optimal algorithm ca need principle objects perform random access 
issue designing ta context random accesses increase cost constant multiple 
correctness ca essentially nra upper lower bounds maintained theorem aggregation function monotone ca correctly finds top objects 
section consider scenarios ca instance optimal optimality ratio independent cr cs 
instance optimality ca section gave scenarios ta instance optimal scenario theorem aggregation function monotone class databases class algorithms correctly find top objects database wild guesses 
second scenario theorem aggregation function strictly monotone class databases satisfy distinctness property class algorithms correctly find top objects database hope scenarios ca instance optimal optimality ratio independent cr cs 
unfortunately hope false scenarios 
fact theorems say ca fail fulfill hope algorithm 
words scenarios guarantee existence algorithm optimality ratio independent cs 
case scenario obtain negative result theorem 
case second scenario obtain negative result theorem 
shall show slightly strengthening assumption second scenario ca instance optimal optimality ratio independent cr cs 
say aggregation function strictly monotone argument argument strictly increased field known object seen 
proof theorem show escape clause invoked depth rounds sorted access parallel ca halts immediately 
remaining arguments held fixed value aggregation function strictly increased 
strictly monotone argument xi implies xi xi xi xm xi xi xm average sum strictly monotone argument min 
show theorem second scenario replace aggregation function strictly monotone aggregation function strictly monotone argument ca instance optimal optimality ratio independent cs 
shall show theorem result holds simply take min min strictly monotone argument 
theorem assume aggregation function strictly monotone argument 
class databases satisfy distinctness property 
class algorithms correctly find top objects database ca instance optimal optimality ratio independent cs 
proof assume 
assume ca runs halts doing sorted access depth ca md sorted accesses random accesses md note ca components rcr cost rcr roughly equal sum 
assume sorted accesses random accesses 
cost incurs cs cr 
suppose algorithm announces objects top claim appears top objects list lj 
suppose 
object output list accessed sorted random access 
database identical locations accessed object fr kg values reside 
distinctness property field value strictly larger strict monotonicity making mandatory member output 
note strict monotonicity stronger property strictly monotone variable 
contradiction 
appears top objects list lj 
sk minft define set objects output value step ca parallel sorted accesses sk fr fr claim object algorithm random access determine value list 
suppose 
show database algorithm performs sk 
contradiction output field accessed assign highest value top locations li accessed free locations exist pigeonhole principal touched objects 
field accessed top values li assumption accessed sorted access construction remaining field top values li 
field top values li 
construction value field high follows monotonicity value need stronger fact strictly monotone argument 
sk sk 
contradiction shown 
object algorithm random access 
jcj 
set jcj 
show ca halts depth cases depending escape clause part ca says object random access step invoked depth db case escape clause ca invoked depth db subcases depending subcase just second paragraph proof theorem know algorithm ca seen objects depth depth sorted accesses object accessed times sorted access 
ca seen strictly objects depth escape clause invoked 
escape clause invoked follows ca seen exactly objects depth depth algorithm ca exactly dm sorted accesses 
ca seen exactly bd objects depth object accessed times sorted access follows objects ca seen seen sorted access lists 
depth objects seen sorted access lists 
situation sound familiar stopping rule fa 
object seen uncertainty grade seen list object seen top list viable 
object seen bd value equal threshold value depth member top list grade equal threshold value follows object seen viable 
viable objects outside top list ca halts depth desired 
subcase algorithm sees objects halts 
database contains objects objects algorithm see algorithm outputs part top algorithm information distinguish mistake database database database obtained reversing roles 
database contain objects 
assuming number objects database follows contains exactly objects 
depth algorithm ca objects seen sorted access list 
similarly proof subcase follows ca halts depth know ca halts depth desired 
case escape clause ca invoked depth db recall ca performs random access viable objects values 
receive random access step ca members highest values 
steps reaching depth step members randomly accessed 
argue objects accessed ca output randomly accessed 
appeal strict monotonicity argument aggregation function function strictly monotone argument step ca database satisfies distinctness property object ifs missing fields bs 
step ca value determined ri sk 
object value larger sk left hk steps ca fr kg missing fields randomly accessed value known ca 
claim step ca viable objects left sk fr kg accessed field values equals values 
objects sk accessed viable objects left ca halts 
shown cases algorithm ca halts depth recall ca gets depth incurs cost 
showed ca halts depth jcj 
cost ca incurs cs cs plus additive constant mcs 
cs cr cs cs cs cr cs cs cr cs assumption cr cs cr cs kr cr see md cs cr cs cr cs cr middleware cost get optimality ratio ca need show may assume 
assume 
random accesses 
theorem nra instance optimal compared algorithms random access course optimality ratio independent cr cs 
cost ca twice nra 
ca instance optimal compared algorithms random access optimality ratio independent cr cs 
proof theorem showed assumptions theorem strict monotonicity argument distinctness property optimality ratio ca theorem give lower bound linear aggregation function strictly monotone argument 
theorem says function min strictly monotone argument algorithm ca instance optimal 
theorem class databases satisfy distinctness property 
class algorithms correctly find top objects min database ca instance optimal optimality ratio independent cs 
proof sketch proof similar proof theorem key point function min step ca different value equals fields distinctness property assures different fields lists value replaces strict monotonicity argument 
step objects value equals sk objects outside fr kg value exceeds sk 
value member fr kg sk follows hm steps fr kg randomly accessed viable objects left ca halt 
rest analysis similar proof theorem hk replaced hm 
net result optimality ratio 
proof theorem showed assumptions theorem distinctness property min aggregation function optimality ratio ca 
theorem give lower bound linear ca versus algorithms section compare ca algorithms 
algorithm compare call intermittent algorithm composed running nra delayed ta steps 
intermittent algorithm random accesses time order ta simply delays random accesses csc steps 
second algorithm compare ca ta 
ca versus intermittent algorithm consider choice ca doing random access find fields viable object value maximum 
compare performance intermittent algorithm just described 
show database intermittent algorithm worse ca 
consider aggregation function 
cr cs large integer 
database top locations grades form matched 
location lists belong object grade 
location lists grade 
inl top locations grades form location object grade 
note maximum grade occurs object objects appear top locations lists grades object top locations grade grade grade 
step ca objects value 
database ca performs sorted accesses parallel single random access halts 
middleware cost hcs cr cr 
intermittent algorithm hand give priority checking random accesses objects top lists 
take objects distinct random accesses middleware cost cr 
ratio middleware cost intermittent algorithm middleware cost ca database arbitrarily large 
particular theorem false replace ca intermittent algorithm example shows optimality ratio intermittent algorithm arbitrarily large arbitrarily large 
ca versus ta intriguing consider differences ca ta cr cs large 
intuitively ta beats ca terms sorted accesses ca beats ta terms random accesses 
precisely ta sorted accesses ca ta gathers information object encounters sorted access 
hand focus random accesses see ta random access field object sees sorted access 
ca selective random accesses 
stores objects seen sorted access random access object stored collection best potential 
consider advantages ca ta 
database comparing ca intermittent algorithm random access cost ta intermittent algorithm 
database ratio middleware cost ta middleware cost ca 
manifestation dependence optimality ratio ta cs independence optimality ratio ca cr cs 
furthermore fact certain assumptions ta optimality ratio quadratic certain assumptions ca optimality ratio linear indicator possible superiority ca ta certain circumstances 
requires investigation 
example interesting compare ca ta aggregation function min class databases satisfy distinctness property class algorithms correctly find top objects min database know ta ca instance optimal scenario theorems know optimality ratio ca independent cr cs theorem 
precise optimality ratios ta ca scenario 
better optimality ratio say cr cs 
ta important advantage ca 
ta requires little bookkeeping face ca requires great deal bookkeeping 
ca sorted access necessary update value upper bound grade object fields known 
discussed nra interesting develop data structures ca lead reasonable amount bookkeeping 
compare ca versus ta realistic scenarios analysis simulations 
lower bounds optimality ratio section prove various lower bounds optimality ratio deterministic algorithms probabilistic algorithms mistake 
lower bound corresponds theorem earlier 
theorem gives matching lower bound upper bound optimality ratio ta proof theorem provided aggregation function strict 
noted earlier lower bound need hold aggregation function strict example aggregation function max 
theorem arbitrary monotone strict aggregation function arguments 
class databases 
class algorithms correctly find top answers database wild guesses 
deterministic algorithm instance optimal optimality ratio cs 
proof assume shall remove assumption 
restrict attention subfamily making positive parameters 
integers 

dm cs dm cr 

max cs 
family contains database form 
list top grades remaining grades 
object top list 
object grade lists top list 
object top lists grade lists grade remaining list 
easy see pick big satisfy conditions sufficiently large number objects 
arbitrary deterministic algorithm show adversary argument adversary force middleware cost database idea adversary dynamically adjusts database query comes way evade allowing determine top element late possible 
say object high list top list high high list 
object high list dm high objects 
assume sees dm high objects see high objects 
adversary force answers receives consistent top object contradiction information halt safely know identity top object 
see dm high objects 
wild guesses sorted access cost dm cs 
cases 
case algorithm sees high object sorted access list high position list object top positions list 
sorted access cost cs cs cs desired 
case high object sees sorted access list high 
say high object fully randomly accessed random access lists high 
random access high object list high adversary assures random accesses grade final random access grade possible adversary continue done random accesses high objects 
assume high objects fully randomly accessed 
adversary force answers receives consistent top object contradiction information halt safely 
high object fully randomly accessed 
dm high objects follows dm random accesses random access cost dm cr 
middleware cost dm cs dm cr desired 
case middleware cost algorithm resulting database algorithm sorted accesses random accesses middleware cost dcs cr 
choosing sufficiently large ratio dm cs dm cr close desired cr cs 
theorem fol dcs cr lows case 
describe modify proof case 
idea top objects easy find 
modify databases proof creating new objects grade list putting top lists 
simple details left reader 
proof theorem assumes strict monotonicity distinctness property showed optimality ratio ta cm max fcr cs cs crg 
theorem give aggregation function strictly monotone deterministic algorithm optimality ratio cr case greatest interest cr cs cs gap factor upper lower bounds 
aggregation function result function xm min xm reason unusual aggregation function case min aggregation function average strictly monotone argument algorithm algorithm ca section optimality ratio independent cr cs restrict attention databases satisfy distinctness property 
negative result theorem hold min average 
theorem aggregation function 
class databases satisfy distinctness property 
class algorithms correctly find top objects database deterministic algorithm instance optimal optimality ratio cr cs proof proof theorem assume loss generality 
restrict attention subfamily making positive parameters 
integers 

cr 

max cs multiple 
family contains database form 
objects 
top grades lists form object grade list grade list 
value objects 
grades lists form top objects lists grade half closed interval lists grade half closed interval open interval lists 
rest top objects lists grade remaining list 
top object call unique object grade 
grade lists occurs objects lists 
furthermore simply grades top objects lists clear top object grade 
arbitrary deterministic algorithm show adversary argument adversary force middleware cost database idea adversary dynamically adjusts database query comes way evade allowing determine top element late possible 
cases 
case sorted accesses 
sorted access cost cs cs cs desired 
case sorted accesses 
call top objects lists candidates 
see candidate sorted access lists call grade high grade low 
say candidate fully randomly accessed random access lists random access candidate lists long possible adversary assures random accesses high grade final random access low grade possible adversary continue candidates fully randomly accessed 
assume candidates fully randomly accessed 
adversary force answers receives consistent top object contradiction information halt safely 
candidate fully randomly accessed 
candidates fully randomly accessed random accesses random access cost cr 
middleware cost cr desired 
case middleware cost algorithm resulting database algorithm accesses top objects lists random access object lists middleware cost dcs cr 
choosing sufficiently large ratio cr dcs cr follows 
close desired cr cs theorem theorem somewhat redundant fact deals probabilistic algorithms theorem 
give proof simple generalize proof theorem 
theorem arbitrary monotone strict aggregation function arguments 
class databases 
class algorithms correctly find top answers database wild guesses 
deterministic algorithm probabilistic algorithm mistake instance optimal optimality ratio 
proof proof theorem assume loss generality wenow define family databases sorted lists 
parameter top dm values lists remaining values 
object value lists object value lists 
grade object grade 
suppose position lists position dm lists 
arbitrary deterministic algorithm consider distribution databases member list appears position chosen uniformly random 
easy see expected number sorted accesses distribution algorithm dm 
database number sorted accesses equal expected number sorted accesses number sorted accesses database dm middleware cost resulting database dm cs 
algorithm sorted accesses random accesses middleware cost dcs cr 
choosing sufficiently large ratio dm cs dcs cr close desired 
theorem follows deterministic case 
case probabilistic algorithms mistake conclude proof theorem 
proof theorem showed assumptions theorem distinctness property min aggregation function optimality ratio ca 
theorem gives lower bound linear theorem class databases satisfy distinctness property 
class algorithms correctly find top answers min database 
deterministic algorithm probabilistic algorithm mistake instance optimal optimality ratio 
proof proof obtained proof theorem modifying construction slightly guarantee consider databases satisfy distinctness property 
simple details left reader 
theorem gives matching lower bound upper bound optimality ratio nra proof theorem provided aggregation function strict 
theorem arbitrary monotone strict aggregation function arguments 
class databases 
class algorithms correctly find top objects database random accesses 
deterministic algorithm instance optimal optimality ratio proof proof theorem assume loss generality 
restrict attention subfamily making positive integer parameter family contains database form 
special objects tm object database grade list special objects 
top object special objects 
refer list challenge list special objects top objects list precisely special objects ti special object top challenge list special objects 
top objects list grade remaining object list grade 
ti position list unique top object position list 
note special object position challenge list exactly special object top object position challenge list 
arbitrary deterministic algorithm show adversary argument adversary force sorted access cost dm database idea adversary dynamically adjusts database query comes way evade allowing determine top element late possible 
times algorithm reaches position list adversary forces encounter object special position time adversary allows algorithm encounter special object position position list accesses depth time adversary allow algorithm discover top object 
clear sorted access cost resulting database dm 
algorithm sorted accesses list sorted accesses distinctness ref 
sm ref 
smv ref 
min ta cm thm ca thm correct instance min thm wild guesses ok optimal algorithm possible thm cr cs certain thm thm wild ta cr cs guesses cr cs strict thm thm random nra thm access thm strict table upper lower bounds remaining lists total sorted accesses 
middleware cost cs 
choosing sufficiently large ratio cs close desired theorem follows 
summary upper lower bounds table summarizes upper lower bounds 
rows correspond different restrictions set algorithms columns restrictions set databases aggregation function note sm means strictly monotone smv means strictly monotone variable 
note maxf cr cs combination provide upper cs cr lower bounds theorem bounds proven 
upper bounds stated explicitly proofs referenced theorems 
lower bounds may deterministic probabilistic 
related ramakrishna nr define algorithm equivalent ta 
notion optimality weaker 
assumption essentially equivalent aggregation function min 
assumption ramakrishna aggregation function satisfies lower bounding prop erty 
property says xm 
balke define algorithm equivalent ta :10.1.1.31.9882:10.1.1.31.9882
call algorithm quick combine basic version distinguish algorithm interest call quick combine 
difference algorithms quick combine provides heuristic rule determines sorted list sorted access 
intuitive idea wish speed ta advantage skewed distributions grades 
claims optimality 
extensive simulations compare quick combine fa compare quick combine ta 
feel interesting problem find heuristics list accessed sorted access 
heuristics potentially lead speedup ta number sorted accesses decrease factor number lists 
unfortunately problems heuristic quick combine 
problem involves partial derivative defined certain aggregation functions min 
seriously easy find family examples shows result heuristic quick combine instance optimal 
note heuristics modify ta deciding list accessed sorted access forced instance optimal simply insuring list accessed sorted access steps constant balke consider situation random accesses impossible 
define basic algorithm called stream combine basic version modified algorithm stream combine incorporates heuristic rule tells sorted list li sorted access 
version stream combine instance optimal 
reason basic version stream combine instance optimal considers upper bounds grades objects algorithm nra considers upper lower bounds 
require top objects grades discussed require grades case random accesses impossible 
algorithm say object top object seen sorted list 
note monotone aggregation functions max interestingly median possible determine grade object knowing grade sorted list 
open problems studied elegant remarkably simple algorithm ta algorithms scenario random access forbidden expensive relative sorted access nra ca 
study algorithms introduced instance optimality framework context aggregation algorithms provided positive negative results 
framework appropriate analyzing comparing performance algorithms provides strong notion optimality 
considered approximation algorithms provided positive negative results instance optimality 
hard see aggregation function satisfies lower bounding property xm min fx 
note particular natural assumption xm min fx 
claim optimality results proven fag fa hold skewed distribution grades uniform distribution :10.1.1.55.2172:10.1.1.55.2172
claim incorrect probabilistic assumption fag orderings sorted lists probabilistically independent :10.1.1.55.2172:10.1.1.55.2172
open problems say algorithm tightly instance optimal instance optimal optimality ratio best possible 
theorem says nra tightly instance optimal theorem says case wild guesses strict aggregation function ta tightly instance optimal 
case wild guesses aggregation functions ta tightly instance optimal 
possible optimality ratios 
cases showed instance optimality algorithms shown table algorithm question fact tightly instance optimal 
cases algorithms turn tightly instance optimal algorithms tightly instance optimal 
interesting lines investigation 
find scenarios instance optimality yield meaningful results 
find applications algorithms information retrieval 
mentioned section issue finding efficient data structures nra ca cases interest comparing ca versus ta 
acknowledgments grateful michael franklin discussions led research ajtai allan borodin erik demaine david johnson madhu sudan andrew tomkins yannakakis useful suggestions larry stockmeyer helpful comments improved readability 
af franklin 
scheduling approach large scale demand data broadcast 
ieee acm transactions networking december 
bey borodin el yaniv 
online computation competitive analysis 
cambridge university press new york 
bgm bruno gravano marian 
evaluating top queries web accessible databases 
proceedings th international conference data engineering 
ieee computer society 
cg chaudhuri gravano 
optimizing queries multimedia repositories 
proc 
acm sigmod conference pages 
chs carey haas schwarz arya cody fagin flickner niblack petkovic thomas williams wimmers 
heterogeneous multimedia information systems garlic approach 
ride dom th int workshop research issues data engineering distributed object management pages 
dagum karp luby ross 
optimal algorithm monte carlo estimation 
siam computing 
noted earlier aggregation function max strict ta tightly instance optimal optimality ratio similarly constant ta tightly instance optimal optimality ratio 
aggregation functions ta tightly instance optimal 
example define letting xm min 
hard see ta tightly instance optimal choice 
dlm demaine pez ortiz munro 
adaptive set intersections unions differences 
proc 
th acm siam symposium discrete algorithms soda pages san francisco 
fag fagin :10.1.1.55.2172
combining fuzzy information multiple systems 
comput 
system sci 
fagin halpern moses vardi 
knowledge programs 
distributed computing 
meyer auf der heide wigderson 
infinity lower bounds parallel computation 
proc 
th acm symposium theory computing stoc pages providence 
:10.1.1.31.9882
balke 
optimizing multi feature queries image databases 
proc 
th large databases vldb conference pages cairo egypt 

balke 
efficient multi feature queries heterogeneous environments 
proc 
ieee international conference information technology coding computing las vegas usa april 
hoc hochbaum editor 
approximation algorithms np hard problems 
pws publishing boston ma 
motwani raghavan 
randomized algorithms 
cambridge university press cambridge 
nbe niblack barber equitz flickner petkovic yanker 
qbic project querying images content color texture shape 
spie conference storage retrieval image video databases volume pages 
qbic web server almaden ibm com 
nr ramakrishna 
query processing issues image multimedia databases 
proc 
th international conference data engineering icde pages march 
sal salton 
automatic text processing transformation analysis retrieval information computer 
addison wesley reading ma 
st sleator tarjan 
amortized efficiency list update paging rules 
comm 
acm 
wimmers haas roth 
fagin algorithm merging ranked results multimedia middleware 
fourth ifcis international conference cooperative information systems pages 
ieee computer society press september 
yao 
yao 
probabilistic computations unified measure complexity 
proc 
th ieee symp 
foundations computer science 
zadeh 
fuzzy sets 
information control 
zim zimmermann 
fuzzy set theory 
kluwer academic publishers boston rd edition 

