programming experience inspiration self randall smith david ungar sun microsystems laboratories casey ave ms mtv mountain view ca usa randall smith sun com david ungar sun com 
self system attempts integrate intellectual non intellectual aspects programming create experience 
language semantics user interface implementation help create integrated experience 
language semantics embed programmer uniform world simple objects modified appealing definitions abstractions 
similar way graphical interface puts user uniform world tangible objects directly manipulated changed switching modes 
implementation strives support world objects illusion minimizing perceptible pauses providing true source level semantics sacrificing performance 
side benefit encourages factoring 
see areas fall short vision language interface implementation conspire self programmer lives acts consistent malleable world objects 
decade dozen papers published self described semantics implementation user interface 
completely articulated important part shared vision programming 
vision focuses experience working programming system feeling thing intellectual thing 
gives chance talk underlying inspiration review project self reflective comments done differently 
authors luxury commenting overview perspective reader keep mind result efforts individuals worked self project years 
motivation programmers human beings embedded world sensory experience acting responding just rational thought 
course effective programmers need logical language semantics need things confidence comfort satisfaction aspects experience domain pure logic 
concerns traditionally addressed separately putting logic language providing rest experience programming environment 
self system attempts integrate intellectual experiential sides programming 
vision self programmer lives acts consistent malleable world concrete motor sensory intellectual levels 
lowest motor sensory level experience objects provide foundation natural interaction 
consequently visual element self largest window smallest triangle directly manipulable object 
higher semantic levels language possible computational models order sensory level self models computation exclusively terms objects 
piece self data largest file smallest number directly manipulable object 
order ensure objects directly experienced manipulated devised model prototypes just button added graphical object method added individual object language needing refer class 
prototype model objects requires radically new kind implementation 
self implementation interface language designed create unified programming experience 
sections turn review language semantics user interface implementation 
section try point think succeeded think failed true vision 
language semantics self initially designed authors xerox parc 
employed minimalist strategy striving distill essence object message 
self evolved years design implementation stanford university sun microsystems laboratories 
user interface programming environment built self part system self today fairly large system includes complete programming environment user interface framework 
computation self consists solely objects turn consist slots 
slot name value 
slot names strings slot values self object 
slot marked asterisk show designates parent 
illustrates self object representing dimensional point slots parent slot called special assignment slots assign slots 
object parent single slot called print containing method object 
sending message slot name matches receiving object parent slots searched slots parent parent 
point object respond messages plus message print inherits print slot parent 
self object potentially print 
self point slots slots containing assignment primitive changing slot carries parent denotation shown asterisk 
parent slots inheritance link indicating message lookup continues object slots 
example point object respond print message inherits print slot parent 
parent number children child object 
uniform ability object participate role inheritance contributes consistency malleability self hope contributes programmer comfort confidence satisfaction 
addition slots self object include code 
objects called methods methods languages 
example object print slot includes code serves method 
self object regarded method data object contains code merely returns 
viewpoint serves unify computation data access object slot result message send run data returns method invokes code 
print message sent point object code print slot method run immediately 
unification reinforces interpretation experience client matters inner details object 
example soda machines dispense pre mixed soda dynamically mix syrup water demand 
user care involved distinction matters product soda result computation 
course self language unifies access computation 
example beta 
traditional computer science viewpoint unification serves provide data abstraction impossible tell abstraction value stored computed 
designing self sought unify assignment computation unification slightly unusual 
assignment self performed assignment slots contain special method symbolized arrow takes argument addition receiver slot 
desire access assignment symmetry interpreted arising sensory motor level 

time children experience manipulation inextricably intertwined best experience object touch pick turn push buttons taste 
believe notion container fundamental intuition humans share unifying assignment computation way access computation self allows abstraction containers inspected filled sending messages object may pretend container employing different implementation 
contrast self beta may illustrate role concern particular kind programming experience played language design 
beta data takes forms values 
beta unifies accessing values computation unifies assignment values computation uses different syntax accessing changing 
example data attribute containing point accessed saying pt method receiver returning point run pt 
giving programmer forms data seen giving programmer tools 
tools course thing opinion value distinction really exist sensory motor level experience chose slightly elaborate scheme single kind data structuring mechanism 
believe advantages uniformity 
design slots self proven challenging unified access state behavior 
self message sent read data slot run method slot 
distinction maintained 
taken position method objects fundamentally different run non trivial code data objects just return 
behavior method objects means directly manipulated run 
invent primitive objects called mirrors way indirectly mentioning methods 
mirrors better justified reflective operations relieving object burden inheriting behavior 
mirrors hamper uniformity unclear method take mirror argument object 
approach unifying invocation access add bit slot record slot method data slot 
approach problems mean put method slot 
opinion issue fully resolved 
treatment assignment slots self bit troublesome 
self assignment slot slot containing special primitive assignment slots uses name slot odd find corresponding data slot object odd 
treatment leads sorts special rules instance illegal object contain assignment slot corresponding data slot code removes slots extra checks 
treatment fails capture intuitive notion container 
prototype languages address issue having slot pair entity language casting assignable slot slot pair 
alternative assignment object slot identifying target principle slot assign 
messages extra arguments addition receiver 
example sends message object argument 
contrast object oriented languages numbers objects self just smalltalk 
languages smalltalk self arithmetic sending messages programmers free add new numeric data types language new types inherit reuse existing numeric code 
adding complex numbers matrices system straightforward defining slot matrices user matrix freely inherit slot code sends 
code sends matrices integers 
self juxtaposition simple uniform language objects numbers messages arithmetic case sophisticated implementation permits programmer inhabit consistent malleable computational universe 
said language new self objects simply copying special class objects instantiation see section entitled prototypes classes 
current implementation allows multiple inheritance requires strategy dealing multiple parents 
block closure objects threads 
constructs somewhat obscure language self methods contained local slots methods supported implementation 
discussion desire provide certain kind programming experience colored self stance traditional issues type declarations 
order understand design self language helps examine assumptions underlie language design 
fortran algol lisp 
languages programmer say necessary execute programs 
lisp interpreted type information supplied 
algol fortran compiled necessary programmers specify primitive type information variable contained integer float order compiler generate correct instructions 
compiled languages evolved discovered adding static declarations compiler create efficient code 
example pl procedures explicitly declared recursive compiler faster procedure prologue non recursive ones 
programmers noticed static declarative information great value making program understandable 
main benefit declarations compiler simula pascal movement born declarations benefit human readers compilers 
opinion trend mixed blessing especially object oriented languages concerned 
problem information human needs understand program reason correctness necessarily information compiler needs program run efficiently 
languages declarations confuse issues limiting efficiency gained declarations frequently hindering code reuse extent algorithms get duplicated type systems subverted 
self distinguishes concrete types 
concrete types embodied maps completely hidden self programmer 
maps visible implementation efficiency mechanism 
types hand notions programmer think 
self particular type manifestation language declarative information left environment 
example language level notion type clone family agesen aps self type inference 
clone family object self language objects created programming environment 
order structure complexity provide environment possible layered design self language proper includes information needed execute program leaving declarative information environment 
design keeps language small simplifies pedagogy allows users potentially extend intensional domain discourse 
minimalism 
tried keep self language minimal 
tempting add new feature handles example better 
feature possible directly handle examples burden imposed reasoning programs just 
abandoned self 
adding features new concept burdens programmer comes contact language 
learned hard way smaller better examples deceptive 
early evolution self mistakes prioritized multiple inheritance sender path tie breaker rule method holder privacy semantics 
motivated compelling example cuch 
prioritized multiple parent slots order support mix style programming 
sender path tie breaker rule allows disjoint objects parents example rectangle parent tree node parent vlsi cell object 
method holder privacy semantics allowed objects parents part encapsulation domain supporting binary operations way smalltalk cuch 
simula tm trademark simula fairness author atlantic time 
hand mistakes avoided 
greater learning time policy decisions revisit features examples direct solutions 
features embedded language programmer gets things immediately 
complexity grows feature fundamental language elements interact defined complexity growth combinatorial 
complexity basic language harder learn harder forcing programmer choice implementation options choice may revisited 
feature caused confusion 
prioritization multiple parents implied self resend call method lookup prepared backup parent links order follow lower priority paths 
resultant semantics took pages write 
year experience features members self group wasted small amount time chasing compiler bugs merely unforeseen consequences features 
clear language original path 
believe features rules elaborations motivated particular examples bet addition mistake 
second author coined term architect trap similar field computer architecture phenomenon called language designer trap examples trusted think motivate language designer 
consistency malleability 
way doing things easier modify reuse code 
code reused programs easier change importantly shrink 
program shrinks construction maintenance requires fewer people allows opportunities reuse 
consistency leads reuse reuse leads conciseness conciseness leads understanding 
feel hard justify type system impedes reusability resultant duplication leads bigger program harder understand get right 
type systems self defeating 
emphasizing ability express intuitive relationships covariant specialization ability checking statically possible better job 
see mmm 
prototypes classes 
fairly mature object oriented languages prototypes 
overviews see blas dmc sls 
languages differ somewhat treatment semantic issues privacy copying role inheritance 
notable system tai tai tai delegation inheritance 
languages model object important sense self contained 
prototypes alternative class language designs subject prototypes vs classes serve point usually debate 
depending defines class may may think classes prototype system 
blas see self prototype playing role class determines structure copies 
note current self system organized particular way call traits objects places provide common state behavior sharing children 
sharing reminiscent provided class 
classes normally provide description instance implementation new method instantiation traits object 
class system change new instance variable class affect new instances subclass 
self change prototype new slot affect prototype subsequent direct copies 
implemented copy mechanism environment share implementation information 
allows programmer add remove slots entire hierarchy prototypes single operation 
functionality provided language level class systems risen programming environment level self 
general simple object model self means functionality omitted language may go back environment 
environment built self objects copy policy changed programmer 
flexibility comes price 
interfaces adding slots objects simple language level copying self object level 
loss uniformity source confusion writing program needs add slots objects 
time tell flexibility worth complication 
brief examination emulation classes self serve illuminate nature prototype object model trade implementing concepts language versus environment 
order self shared parent look class create new method shared parent 
method copy internal prototype appear instantiation device 
suggests start smalltalk class self objects 
mario wolczko built complete implementation shown wol works quite read smalltalk source code execute self program 
certain restrictions smalltalk self prototypes really special objects distinguished fact convention copied 
copy prototype serve prototype equally 
prototype systems take different approach 
class superclass instantiation method new proto proto copy parent class instvar instvar parent parent method method instances parent class instvar instvar 
suggests self objects composed form smalltalk class structures demonstrated completely wolczko wol 
shows caveats smalltalk code read self system parsed self objects executed significant performance benefits self dynamically optimizing virtual machine 
source self implementation technology code adaptively optimizes self version smalltalk code generally run faster smalltalk version 
prototype systems self classes 
answer definition class satisfied existing language elements probably build quite easily happy 
difficult kind trick prototype language inheritance mechanism 
course language emulate case classes built directly prototype objects directly classes constructed self objects run faster built smalltalk 
general metaobject issues prototype languages tackled system mul 
traits seen self group smalltalk experience 
interestingly old habits done self justice observed dmc 
ways organize self objects prototypes inheriting chain traits parents ways avoid problem traits organization traits object appears object fact respond messages 
example point traits object lacks slots respond printstring printstring slot contains method intended shared point objects 
probably done better put effort exploring organizations 
investigating new language old habits lead astray 
user interface programming environment self unusually pure object oriented language uses objects messages achieve effects flow control variable scoping primitive data types 
object message paradigm intended match user interface concrete direct manipulation uniform graphical objects 
matching language user interface hope create experience programming learned easily performed cognitive overhead 
notion direct manipulation years interesting note earlier prototype systems visual programming environments bd smi 
current self user interface smu ms enhances sense direct manipulation employing principles call structural reification live editing 
define principles show example interface brings feeling direct object experience task creating objects assembling applications 
structural reification fundamental kind display object self called morph term borrowed greek meaning essentially thing self provides hierarchy morphs 
root hierarchy embodied prototypical morph appears kind golden colored rectangle 
object systems choose root graphical hierarchy class instances 
prototype systems usually provide generic examples abstractions 
important part structural reification principle invisible display objects 
descendant root morph morph matter guaranteed fully functional graphical entity 
inherit methods displaying responding input events enable directly manipulated 
keeping principle structural reification morph attached 
acts glued surface hosting morph 
composite graphical structure typical direct manipulation interfaces arises morph hierarchy 
systems provide compositing special group objects normally invisible 
want things feel solid direct chose follow simple metaphor sticking morphs glued 
final part structural reification arises approach layout 
graphical user interfaces require subparts lined column row 
self graphical elements organized space layout objects force line rows columns 
john maloney ms shown create efficient row column morphs children generic morph 
objects class tangible elements interface 
embody layout policy visible parts hierarchy user need able access structure order inspect change layout way 
possible price uniformity paid user wish see layout mechanism confronted anyway 
example section illustrate structural reification assures morph seen grabbed moved inspected assures graphical composition layout constraints physically interface 
structural reification important part making programming feel tangible direct 
live editing live editing simply means time object directly changed user 
interactive system allows arbitrary runtime changes objects degree support live editing 
believe self provides unusually direct interface live changes 
key live editing provided self meta menu menu pop user holds third mouse button pointing morph 
meta menu contains items resize dismiss change color allow user edit object directly 
menu elements enable user embed morph structure morph menu elements give access hierarchy point screen 
outliner menu item creates language level view morph mouse view shows slots object provides full set editing functionality 
outliner add remove slots rename edit contents 
code method slot textually edited important tools programmers 
access outliner meta menu possible investigate language level object graphical object screen 
outliner supports live editing principle letting user manipulate edit slots object example illustrates slot carried object interactively modifying language level structure 
lars bak designed outliner framework self 
popping meta menu prototypical morph response third mouse button click 
morphs inherit behavior elements interface pop menus 
wait 
pop menus impossible click find mouse mouse button 
release button preparation third button click causes pop disappear 
consequently provide pin button selected causes menu normal permanent display object 
mechanism new providing self enables menu interactively pulled apart modified user programmer 
live editing partly result having interactive system enhanced features user interface 
principle reinforces feel programmer working directly concrete objects 
example clarify principle structural reification principle help give programmer feeling working uniform world accessible tangible objects 
example direct application construction suppose programmer motivated user wishes expand ideal gas simulation extending functionality adding user interface controls 
simulation starts simply box containing atoms bouncing inside 
third mouse button user invoke meta menu select outliner get representation object 
outliner enables arbitrary changes ideal gas simulation 

self window user pops meta menu ideal gas simulation 
selecting outliner gives self level representation user carried placed needed 
italic items bottom outliner represent slot categories may expanded view slots 
slots categories language level semantics essentially user interface convenience 

middle mouse button pop menu slot enables user create button immediate user interface 
button embedded row morph lines horizontally 
outliner user start create controls right away 
outliner slots labeled start slots converted user interface buttons selecting middle mouse button pop menu slot 
pressing buttons starts stops bouncing atoms simulation 
example live editing just gestures programmer gone outliner create interface elements simulation continues run 
programmer may wish create buttons arrange row 
programmer selects row morph palette buttons embedded row immediately snap position 
row buttons created programmer wishes align row gas tank 
programmer create column frame gas tank button row embedded column frame line 
composite graphical effects achieved embedding kind morph embedded kind morph 
ideal gas simulation left compound morph embedding relationships shown right 
illustrates composite graphical effects achieved morph hierarchy 
interface employs morphs quite low level 
labels buttons example class morphs 
uniformity having morphs way reinforces feel working concrete objects 
example user may wish replace textual label icon 
user task pointing label invoking meta menu 
menu item labeled allows user select morph collection mouse wishes denote see 
user remove label directly button surface 
similar way user select atoms gas tank duplicate 
new atom serve icon replacing textual label 
structural reification play making display objects accessible direct immediate modification 

user wishes remove label surface button 
series operations user starts pointing label selects meta menu selects label resulting menu list 
menu options user selects 
button wraps tightly shrinks minimum size 

environment available reuse 
user created menu operations gas tank surrounding frame 
pinned menu pressing button top menu 
take menu apart constituent buttons gets resize button incorporated simulation 
mentioned elements interface pop menus dialogue boxes available reuse 
example programmer may want gas tank simulation simulation user 
programmer create resize button gas tank simply pinning meta menu removing resize button menu illustrated 
button embedded row controls buttons 
illustrates programmer modify behavior individual atom reveal energy color 
morph slot called normally contains paint object example programmer replaces object method paint computed energy level 
change accepted modified slot immediately takes effect 
programmer shown copying slot atom parent object widely shared atoms 
atoms slot overrides slot parent 
programmer point remove slot prototypical atom new atoms energy color 

user selected atom experiment 
user changes slot computed stored value editing directly atom outliner 

user copies modified slot step getting computed method coloring widely shared 
slots moved readily restructuring changes relatively light weight enhancing sense flexibility 

completed application 
user invoked color changing tool unifies colors invoked meta menu item move window shows completed application 
atoms reveal energy move controls running simulation appear row bottom object 
programmer invoked meta menu item move window wraps application window system frame 
important note process simulation left running fundamental need enter edit mode atoms bouncing 
live editing principle system feel responsive reminiscent physical world concrete presence 
structural reification means parts interface visible accessible direct modification 
issues principles live editing structural reification help create sense working world tangible malleable objects imagine going 
discuss things interfere full realization goals 
multiple views existence outliner separate view weakens sense directness 
want add slot simulated atoms different display object atom outliner 
courage time go wild ideas enable unification morph outliner 
ironically self interface probably better issue cha cus 
self programming environment enforces constraint outliner screen time object 
user asks see object outliner screen outliner animated slide mouse cursor 
constraint encourages identification object outliner programmer mind 
mention particularly morph objects identification hold 
difference objects represent fundamental dichotomy system interferes direct object experience goal 
programmer believe outliner list object really list 
list graphical appearance intrinsic part 
list intrinsic display location color 
chosen easy answer object represents list programmer actual self list object 
take easy road fundamentally impossible maintain impression objects screen self objects 
unfortunately clear just display stand ins real invisible self object buried computer 
text object fundamental clash text direct manipulation 
word inherently denotes object necessarily denote 
see word cow image comes mind 
fact difficult avoid image way words supposed 
stand things 
manipulate pencil comes mind 
depends context 
words pencil denote 
consequently textual notation object manipulation fundamentally different worlds 
pencil word denoting pencil different entities 
text quite bit self denotational character weakens sense direct encounter objects 
example tools user interface employ print string denote object 
programmer working tools encounter text list programmer know denotes object viewed directly outliner 
bother 
textual string says needs know 
programmer moves satisfied particularly feeling encountered list 
mind set denotational world different direct object world text creates different kind experience 
issues mention direct manipulation interfaces discussed suc 
summary self user interface helps programmer feel directly experiencing tangible objects 
design principles help achieve feeling 
structural reification assures graphical relationships play particular arrangement manifest directly display objects screen 
second live editing means need course grained edit mode objects available immediate direct editing 
textual names objects distinction object representation problems weaken experience directly working objects 
balance feel self user interface successfully presents illusion world readily modified physically objects 
implementing self implementation language usually approached mathematical mechanistic viewpoint desired creation program interprets programs language created program compiler interpreter 
hand taken view goal implementation fool user believing reality language 
self objects physical existence machine capable executing self methods implementation strive convince user 
despite tricks programmer debug source level seeing variables single stepping change method inlined ones interference implementation 
transparent efficiency implementation techniques self previously summarize briefly 
see hol hu hcu hcu cha cu cu cul details 
self large efficiency challenge pure semantics implied access assignment arithmetic operation control structure performed sending message 
worse self user interface stance structural reification placed demands efficiency screen smallest triangle implemented separate object redraw active layout behavior 
time order produce experience concrete objects system responsive interpreter 
self implementors confronted fundamental problem responsive compiler afford spend time elaborate optimizations needed language matter effective 
caught scylla self needed completely different 
relying single compiler speed cleverness self adopted hybrid system compilers fast clever 
optimizing type feedback permits system adaptively optimize code introducing long pauses 
shows overview compilation process system 
time method invoked virtual machine uses dynamic compilation create instrumented version method counts invocations types receivers call site 
invocation counter crosses threshold opti source methods compiler automatically invoked guided counters call sites 
way self feeds type information back compiler adaptively optimize code 
language implementations force programmer choose interpretation compilation different modes compilation 
placing burden choice programmer shoulders weaken confidence reality self force consider difference program written really runs 
self employs compilers myriad optimizations programmer chooses knows employed code 
results medium size cross language benchmarks richards deltablue suggest self runs times faster parcplace smalltalk times faster sun full optimization times slower optimized hu 
course smalltalk lisp implementations may include aggressively optimized compilers language semantics concessions efficiency purity simplicity safety 
implementations strive efficiency employ optimizations show programmer 
tail recursion elimination example optimizes methods iterate calling ends impossible show meaningful stack trace 
destruction information show user need see missing stack frames order debug program 
self optimize tail recursion 
endless loops built primitive operation 
optimizations left undone self see hol list 
responsiveness method invoked unoptimized code executed needed debugging hcu optimized code dynamic compilation ds adaptive optimization hu 
compilation self system hu 
systems impose long unpredictable pauses users 
pause middle user task addition slot object ruin experience consistent world 
pauses existence alert users 
program self language reality pauses changing 
believe pauses destroy fragile illusion reality reduce self implementation 
smalltalk tm trademark parcplace systems 
fact pauses compilation serious problem early versions self inspired effort speed compiler 
method changed second 
ultimate goal elimination perceptible pauses 
hu lzle ungar measured compilation pauses occurring minute session self user interface cha cus 
analysis grouped individual pauses clusters perceived pauses users 
results indicated intrusive clustered pauses current generation workstation pauses exceed seconds generation machine exceed seconds see 
number pauses exceeding length sparcstation current faster faster pause length seconds 
compilation pauses hu 
clustering pauses order magnitude difference reporting individual pauses resulted distorted overly optimistic characterization 
idea pause clustering example vision providing particular kind experience programmer affects standards evaluate system 
malleability clear reader philosophy implementation deception places additional burdens implementation avoiding inconsistent behavior pauses 
may come surprise requirement malleability arises logical consequence unusual philosophy 
example smalltalk self control structure realized sending message iftrue iffalse boolean object arguments included block execute true false 
boolean simply implements self user interface described section places demands implementation pause behavior measurements suggest 
message message executes appropriate block true iftrue iffalse method runs true block false runs false block 
self smalltalk objects real directly faithfully execute user control user able change methods observe results 
smalltalk extra performance obtained short circuiting method implementation gr may change method programmer alter behavior 
failure malleability help raise disturbing questions programmer 
self short circuit methods providing malleability efficiency loss extracts cost implementation 
encouraging factoring extensible control non traditional approach led techniques provide traditional benefit factoring free 
suppose methods object contain lines common 
moving common lines new method sharing method callers programmer centralize program easier change 
implementations object oriented programming languages slow program additional procedure call providing strong programmer factoring small operations 
example programmer ask explicitly inlining give virtual semantics pay price statement overhead 
self relies automatic inlining price paid 
consequently self programmers feel factor programs system written unusually factored style 
example loop implemented levels message passing primitives 
believe performance characteristics self implementation techniques encourage programmers write programs easier maintain 
addition free factoring self implementation user defined control structures efficient built ones 
smalltalk programmer block implementation cases inline away 
believe control abstraction necessary real data abstraction making control abstraction free help encourage programmers write better programs 
strongly believe languages user extensible control smalltalk beta benefit realized adopting implementation techniques put user defined control structures footing system defined ones 
open issues current self system daily number people concerns remain implementation 

self compiler creates copy method kind object inherits 
method trivial copies waste code space compiler time reason 
fact second author thought cost great 
craig chambers compiler convinced 
memory footprint 
information preserved maintain source level semantics self takes space systems 
self barely fits sparcstation mb real memory 
believe programming time precious memory cost resource requirement puts self reach current users 
real time operation 
progress elimination perceptible pauses system feels running self environment 
hard real time operation possible today system 
user control 
self group debate control user optimization process 
hand users want able tell system optimize 
hand effort add ability better spent doing better job automatically giving users control distract tasks destroy fragile illusion self reality 
far kept control optimization entirely virtual machine experiment philosophy implementation deception 
summary confidence comfort satisfaction desires imply implementation techniques 
rarely show topics compiler papers believe goals exerted profound influence self implementors 
self language semantics implementation user interface guided goal generating particular kind experience user system 
programmers directly uniform world malleable objects immediate direct fashion 
self moves giving objects kind tangible reality 
language helps give rise experience prototypes provide copy directly modify mechanism changes 
self treatment slots symmetry assignment access reflect deep connection perception manipulation sensory motor level enabling objects reimplement state behavior reflecting intuition objects behaviorally perceived real world 
self design departs significantly object oriented languages separating information needed run program information programmer intentions 
distinguishes types programmers understanding reasoning correctness concrete types run optimize program 
left environment left implementation 
sparcstation tm trademark sparc international licensed exclusively sun micro systems opinion approach avoids number undesirable consequences follow attempts integrate forms information 
designing self learned lesson making mistakes examples persuade designer include additional features turn produce incomprehensible behavior unforeseen circumstances 
called language designer trap minimalism simplicity consistency better guides 
benefit programmer just ones need advanced features 
suspect today object oriented languages profit dropping features 
self user interface programming environment provides direct object experience creating objects assembling applications adhering principals structure reification graphical containment structure layout rules appear graphical objects assures graphical object manipulated displayed connected objects customized 
live editing ensures object may changed time halting activities 
simple gesture takes user graphical object programming language level counterpart just real world objects taken apart 
consequently programmers need long object libraries find start simply find graphical widget environment button menu similar want proceed dissect inspect modify reassemble 
time retreat concrete object definition abstraction 
problems user interface interfere achieving goal 
existence multiple views graphical object self level outliner experience views merged 
duality text object goes deeper readily solution 
consistency purity self language ubiquitous objects live layout interface place enormous demands self implementation interestingly desire create particular kind programming experience imposes unique requirements implementation 
implementation optimizations hidden tail recursion elimination 
supports full source level debugging single stepping allows programmer change method basic ones addition time 
long pause compilation alert programmer existence lower level reality implementation works hard avoid pauses 
view implementation interpreter programs creator illusion self objects real 
way self implementation techniques adaptive recompilation achieve traditionally important rarely achieved goals elimination run time penalty factoring user defined control structures 
programmer may chop method finely desired slowing may introduce new abstractions combine control data paying run time price 
characteristics encourage create programmers smaller malleable 
said done suggest tease hint create self 
order fully appreciate experience interacting lively responsive world objects effortlessly diving change create freely mixing data programs getting coffee tired change program obtain self public release try 
may journey fruitful 
acknowledgments past members self group highly talented individuals body possible 
authors consider fortunate known worked 
sun microsystems laboratories hosted project past years deeply grateful 
special mario wolczko ole lehrmann madsen comments draft 
aps ole agesen jens palsberg michael schwartzbach 
type inference self analysis objects dynamic multiple inheritance proc 
ecoop pp 

germany july 
blas 
object oriented programming prototypes springer verlag new york berlin 
bd borning constraint tools building user interfaces acm transactions graphics pp 
october 
cul craig chambers david ungar lee 
efficient implementation self dynamically typed object oriented language prototypes 
oopsla conference proceedings pp 
new orleans la 
published sigplan notices october 
cu craig chambers david ungar 
iterative type analysis extended message splitting optimizing dynamically typed object oriented programs 
proceedings sigplan conference programming language design implementation white plains ny june 
published sigplan notices june 
cu craig chambers david ungar 
making pure object oriented languages practical 
oopsla conference proceedings pp 
phoenix az october 
cuch craig chambers david ungar bay wei chang urs lzle parents shared parts objects inheritance encapsulation self 
journal lisp symbolic computation kluwer academic publishers june 
cha craig chambers 
design implementation self compiler optimizing compiler object oriented programming languages 
ph thesis computer science department stanford university april 
cus bay wei chang david ungar randall smith getting close objects burnett goldberg lewis editors visual object oriented programming concepts environments pp 
manning publications greenwich ct 
cha bay wei chang object focused interaction self user interface ph dissertation preparation stanford university 
ds peter deutsch allan schiffman 
efficient implementation smalltalk system 
proceedings th annual acm symposium principles programming languages pp 
salt lake city ut 
dmc dony malenfant cointe prototype languages new taxonomy constructive proposals validation proc 
oopsla pp 

gr adele goldberg david robson smalltalk language implementation 
addison wesley reading ma 
hcu urs lzle craig chambers david ungar 
optimizing dynamically typed object oriented programs polymorphic inline caches 
ecoop conference proceedings pp 
geneva switzerland july 
hcu urs lzle craig chambers david ungar 
debugging optimized code dynamic deoptimization proc 
acm sigplan conferences programming language design implementation pp 
san francisco ca june 
hol urs lzle 
adaptive optimization self reconciling high performance exploratory programming 
ph thesis stanford university computer science department 
hu urs lzle david ungar 
optimizing dynamically dispatched calls run time type feedback 
proceedings sigplan conference programming language design implementation orlando fl june 
hu urs lzle david ungar 
third generation self implementation reconciling responsiveness performance 
oopsla conference proceedings pp 
portland october 
published sigplan notices october 
mmm ole lehrmann madsen boris magnusson ller pedersen strong typing object oriented languages revisited 
ecoop oopsla conference proceedings pp 
ottawa canada october 
ole lehrmann madsen ller pedersen nygaard object oriented programming beta programming language addison wesley publishing wokingham england 
mul flexion langages prototypes ph thesis preparation ecole des mines de nantes france 
ms john maloney randall smith directness liveness morphic user interface construction environment 
preparation 
smi randall smith 
experiences alternate reality kit example tension magic proc 
chi gi conference pp toronto april 
suc randall smith david ungar bay wei chang 
mention perspective programming interface brad myers languages developing user interfaces jones bartlett boston ma 
pp 
sls smith smith taivalsaari ungar prototype languages object lessons class free programming panel proc 
oopsla pp 
october 
see panel summary title addendum proceedings oopsla pp 

smu randall smith john maloney david ungar self user interface manifesting system wide vision concreteness uniformity flexibility 
appear proc 
oopsla 
tai taivalsaari prototype object oriented language concatenation module operations 
university victoria technical report dcs victoria canada june tai taivalsaari critical view inheritance reusability objectoriented programming 
ph dissertation studies computer science economics statistics university finland december pages isbn 
tai taivalsaari concatenation object oriented programming 
actes de la eme conference sur la representations par objets rpo la grande france june published ec france june pp david ungar randall smith self power simplicity proceedings acm conference object oriented programming systems languages applications oopsla orlando fl october pp 

revised version appeared journal lisp symbolic computation kluwer academic publishers june 
david ungar randall smith craig chambers urs lzle 
object message performance coexist self 
computer pp 

october 
wol mario wolczko implementing class language prototypes preparation 
