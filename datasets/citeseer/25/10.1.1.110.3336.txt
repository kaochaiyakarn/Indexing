adaptive security symbolic encryption daniele micciancio university california san diego la jolla ca usa daniele cs ucsd edu 
prove computational soundness theorem symbolic analysis cryptographic protocols extends analogous theorem abadi rogaway cryptology scenario adversary gets see encryption sequence adaptively chosen symbolic expressions 
extension theorem abadi rogaway adaptive scenario nontrivial raises issues related classic problem selective decommitment appear original formulation theorem 
theorem abadi rogaway applies passive adversaries extension adaptive attacks substantially stronger powerful analyze security cryptographic protocols practical interest 
exemplify soundness theorem analysis group key distribution protocols arise multicast broadcast applications 
specifically provide cryptographic definitions security multicast key distribution protocols symbolic computational framework theorem prove soundness symbolic definition 
keywords symbolic encryption adaptive adversaries soundness theorem formal methods security protocols 
traditionally security protocols designed analyzed competing approaches symbolic computational 
symbolic approach characterized adversarial execution model cryptographic operations objects treated data type honest protocol participants malicious players attacking system 
allows simple proofs security typically syntactic properties messages exchanged execution protocol 
computational approach detailed execution research supported part nsf 
opinions findings recommendations expressed material author necessarily reflect views national science foundation 
model accounts wider class adversaries attacking system arbitrary probabilistic polynomial time bounded adversaries necessarily respect cryptographic abstractions protocol 
stronger security guarantees offered computational approach come substantial price complexity proofs security framework typically involve subtle probabilistic arguments complicated running time analysis ubiquitous computational assumptions intractability factoring large integers 
lot interest combining approaches generic goal coming models allow computationally sound symbolic security analysis method translate symbolic security proofs precise computational statements security concrete protocol executions computational framework 
follows line research initiated abadi rogaway simple language encrypted expressions defined computationally sound symbolic semantics 
technically introduces notion pattern expression syntactic characterization information leaked expression evaluated computationally secure encryption scheme 
pattern expression defined expression formed substituting ciphertexts ciphertexts encryption key deduced applying dolev yao rules special symbol 
example pattern expression ki kj kj kj ki ki ki ki 
structure soundness result simple adversary attacking system produces symbolic expression subsequently receives computational evaluation expression pattern 
soundness theorem states expression satisfy certain syntactic restrictions contain encryption cycles adversary efficiently determine received evaluation expression pattern 
result interesting step demonstrating feasibility computationally sound symbolic security analysis 
class encrypted expressions considered fairly general allows describe messages transmitted practical protocols 
result simple direct application security analysis protocols 
intuitively scenario considered involves party sending single message party authenticated channel passive adversary monitoring channel 
practice security protocols involve exchange messages parties different directions 
messages may depend computational interpretation previously chosen messages external inputs known protocol 
results 
consider extension adversary produces sequence expressions subsequently evaluated common key assignment 
expressions sequence specified time wouldn different original soundness theorem expressions sequence concatenated single expression 
extension interesting nontrivial fact sequence adversarially specified adaptive way expression sequence may depend computational evaluation previous ones 
ability specify expressions adaptively allows adversary generate probability distributions correspond fixed sequence expressions immediately raises issues related classic problem selective decommitment adaptive corruption 
see section details 
order avoid problems introduce syntactical restrictions expressions acyclicity condition considered 
informally syntactic restrictions postulate key stages key distribution stage key message key deployment stage key encrypt messages 
syntactic restrictions able bypass selective decommitment problems prove soundness result symbolic encryption adaptively chosen expressions 
soundness result allows analyze generic class protocols involve communication multiple parties authenticated network 
execution model protocols involves adversary observes messages sent network adaptively change execution flow protocol interaction execution environment allowed modify delete messages sent received legitimate parties 
result substantially increases expressive power soundness theorem making powerful analyze practical cryptographic protocols 
exemplify soundness theorem analysis group key distribution protocols multicast applications 
multicast key distribution problem data source wants broadcast information dynamically changing group parties way point time current group members decipher transmitted messages 
problem typically solved establishing secret key known current group members 
time user joins leaves group group controller broadcasts messages new set members update group key 
give formal definitions security multicast key distribution protocols computational framework symbolic framework show protocol secure symbolic setting implementation protocol secure computational setting provided messages protocol conform syntactic restrictions soundness theorem 
multicast key distribution protocols aware satisfy restrictions proven secure powerful computational adversaries symbolic definition 
best knowledge formal definitions security protocols discussed authenticated channels widely model cryptographic protocol design implemented top non authenticated networks standard techniques message authentication codes digital signatures 
literature prior attempt relate security analysis protocols symbolic framework done implicitly papers computational security guarantees implementations 
soundness theorem important building block direction 
related 
improvements refinements followed original abadi rogaway orthogonal results 
micciancio warinschi prove converse soundness theorem showing sufficiently strong encryption scheme computationally bounded adversary recover information captured symbolic patterns 
result refined gligor horvitz give exact characterization computational requirements encryption scheme completeness theorem holds true :10.1.1.88.1283
extension soundness result multiple message player settings abadi 
result considers arbitrary set parties exchanging messages authenticated network time 
protocol specification language allows describe protocols messages transmitted protocol execution uniquely determined execution protocol begins 
words result account scenarios messages chosen adaptively technical point view closer 
papers different extensions framework allow active attacks adversaries total control communication network may drop alter inject messages network 
works encryption schemes satisfying stronger notion security chosen ciphertext attack cca 
results hold encryption scheme secure chosen plaintext attack cpa 
results qualitatively different complex formulation results 
micciancio warinschi consider trace properties symbolic computational executions cryptographic protocols relate models proving cca secure encryption scheme protocol satisfies trace property symbolic executions satisfies corresponding trace property computational executions overwhelming probability 
results incomparable trace properties allow readily model indistinguishability properties considered 
laud result quite different soundness results considered far 
considering computational symbolic execution models relating considers computational execution model set symbolic program transformations proves symbolic transformations computationally sound sense pre class properties extensively formal verification distributed protocols represented allowable sequences internal states external actions performed honest protocol participants 
serve computational secrecy properties original transformed program executed computational model 
approaches problem computationally sound symbolic analysis exemplified :10.1.1.3.4629:10.1.1.8.7994
backes pfitzmann waidner implementation dolev yao style terms achieving simulation security definition general computational framework 
important notice allow formulate prove computational security properties protocols built library results apply protocols direct encryption schemes satisfying standard security notions cpa cca indistinguishability 
relies syntactic restrictions symmetric encryption similar 
shows difficulties encountered trying lift restrictions specific universally composable security framework arise simpler scenarios considered 
lincoln mitchell mitchell scedrov probabilistic process calculus analyze computational security properties cryptographic protocols 
works substantially complex powerful technically incomparable line initiated allow describe arbitrary probabilistic polynomial time computations 
impagliazzo approaches problem computationally sound symbolic analysis side 
axiomatic system limited forms recursion carry proofs type analysis basic cryptographic constructions explicit nested quantifiers asymptotic notation 
interesting question soundness theorem proved proved logic 
organization 
giving basic definitions section soundness theorem section 
proof soundness theorem section describing application multicast key distribution section 
section concludes discussion open problems 
preliminaries keys const sets symbols called keys constants respectively 
assume sets finite size bounded polynomial security parameter 
value security parameter keys kn set keys 
define language exp expressions called basic expressions generated syntactic rules kn symbol keys const rule symbolizes pairing operation ki ki symbolizes encryption ki 
sequences expressions converted single expression operation obvious way sequence 
represented expression 

sequence 
indexes notation denote subsequence 

exp key occurs plaintext sub expression referred message key encrypt subexpression called encryption key 
denote set message resp 
encryption keys resp 

say key ki encrypts kj kj encrypted ki denoted ki kj contains sub expression ki kj 
call key recoverable occurs unencrypted encrypted keys turn recoverable 
set recoverable keys denoted 
set unrecoverable encryption keys set denoted 
example 
formal semantics 
information extracted expression known keys decryption algorithm represented syntactic object called pattern 
definition patterns proposed characterizes encryption schemes satisfying standard notion semantic security chosen plaintext attack 
patterns slightly different correspond encryption schemes satisfying variant semantic security 
definition similar 
define structure expression exp denoted struct expression obtained substituting message keys symbol encryption keys constants symbol keys const fresh symbols 
example struct 
definition 
exp pattern set keys denoted pat expression defined recursively follows keys const pat pat pat pat 
ki ki pat pat ki 
ki ki pat struct ki 
pattern denoted pattern defined pat 
definition patterns captures intuitive idea bitstring interpretation expression encrypted say ki adversary learn expression knows ki learn structure know ki 
just say expressions exp equivalent denoted patterns viewed strings symbols identical renaming keys 
equivalent exists injective map keys keys key ki structure key pattern substituted ki resulting expression identical pattern 
example consider expressions 
computational semantics 
define computational semantics expressions including basic expressions respective patterns single procedure 
denote set expressions exp 
symmetric encryption scheme denote random variable corresponding vector keys sampled independently key generation algorithm giving security parameter input 
procedure defining computational semantics expressions takes security parameter input works steps 

generate key vector distribution keys map keys keys elements vector 
specifically corresponds ki 
second step look expressions exp expression define bitstring interpretation random variable recursive manner const bitstring representation standard encoding 
ki keys 

exp random variable corresponding standard efficiently computable invertible encoding pairing operation 
ki exp ki keys random variable corresponding 
exp random variable corresponding 
security encryption 
consider encryption schemes semantically secure chosen plaintext attacks 
symmetric encryption scheme left right oracle lr program generates key key generating algorithm query bitstrings equal length replies ciphertext ek mb 
called ind cpa secure probabilistic polynomialtime distinguisher quantity adv ind cpa pr lr pr lr negligible function sufficiently large 
soundness consider setting adversary gets see computational evaluation sequence adaptively chosen expressions 
want model fact adversary learn expressions information deduced patterns 
formalize problem cryptographic experiment follows 
fix symmetric encryption scheme 
probabilistic polynomial time machine issues queries consisting pairs basic expressions ith query denoted 
experiment runs worlds decided bit sampled uniformly random 
selecting adversary executed security parameter input queries adversary answered oracle parameterized encryption scheme bit oracle selects random key vector key generation algorithm query replies sample distribution mb bitstring interpretation bth expression query respect 
concise description oracle experiment appears 
oracle jth query received reply sample mb expt adpt 
fix 
run goal adversary guess value probability better random constraint sequences expressions queried oracle pattern 
specifically denote number queries execution experiment mb mb sequence expressions encrypted oracle 
loss generality assumed fixed polynomial security parameter polynomial upper bound running time 
require 
technical reasons order prove soundness theorem need introduce additional restrictions syntax 
definition 
sequence basic expressions mb mb mb called legal satisfies properties standard cryptography distinguishability pairs messages model leakage partial information messages 

expressions contain encryption cycles 

unrecoverable encryption key mb occurs message key mb mb mb example mb ki kj illegal mb kj kl mb kj 
requirement standard cryptography 
second requirement natural informally states key stages key distribution stage key message subsequent deployment stage key encrypt messages keys 
way keys cryptographic protocols key distribution protocols 
intuitively reason introduce requirement key encrypt messages revealed symbolic patterns previously received messages may change consequently proof breaks 
technical level absence second requirement adversary play game issue expressions 
ml kl getting corresponding ciphertexts ask randomly chosen set keys ki 
kim im issuing expression ki 
kim 
question security ciphertexts decrypted revealed keys ensured game classic problem selective decryption answer known date 
adversary expt adpt called legal queries issued legal sequences 
advantage experiment denoted adv adpt defined quantity adv adpt ao probabilities taken randomness state soundness theorem theorem 
ind cpa secure encryption scheme legal negligible function 
adversary adv adpt provide overview proof soundness theorem section doing discuss application 
application secure multicast section example illustrate soundness theorem analysis real cryptographic protocols 
example expression said contain encryption cycle exist keys ki ki kim ki ki ki kim ki 
examples expressions 
multicast key distribution problem large set users communicates multicast broadcast channel time users called group members share secret key known rest users 
group members change dynamically order maintain secrecy property group key time central authority called group center broadcasts messages enable members update key new member joins old member leaves group 
words center group composition changes 
goal ensure point time non members unable compute group key collude share information attempt 
problem arises practical scenarios studied extensively cryptography computer networks communities 
see example 
little attempt formulating sound cryptographic model problem proving security proposed solutions standard cryptographic techniques 
works implicitly dolev yao framework arguing security multicast key distribution protocols clear analysis relates actual security protocols 
soundness theorem provides useful tool relating proofs security protocols formal framework security proofs standard computational framework cryptography 
security computational framework model multicast key distribution protocol set programs initialization program group center program compute rekey messages program run group members un 
programs follows 
takes security parameter input outputs initial state center sc initial states users sn initial group membership 
typically 
center program takes input current state command returns message mt rekey message time updated state center command center form add ui adds new user group form del ui removes existing member group 
users program takes input user index previous state user ui current rekey message mt outputs string updated state ui 
correctness require time instant identical member ui current group gt 
value called group key time denoted kt 
security definition security multicast key distribution modelled adversary controls subset corrupted users adaptively issues commands change membership group 
adversary goal gain information group key corrupted users part group 
formally protocol consider experiment denote expt generate initial states group center users adversary set corrupted users initial states si ui 
adversary issues sequence commands com command corresponding rekey message mt computed program group center initial state produced 
point time users may may group 
kt group keys times computed honest group members 
set time instants corrupted users group kt ki corresponding keys 
security requirement keys kt pseudorandom 
precisely set uniformly independently chosen keys random bit 
experiment adversary kt depending respectively goal correctly guess value pa probability outputs expt corrupted set users probabilities taken random choices 
advantage function experiment defined adv pa pa definition 
multicast key distribution protocol secure probabilistic polynomial time adversaries sets adv negligible function 
definition allows adversary change group membership adaptive way permit adaptive corruption users set corrupted users chosen protocol starts executing 
computationally sound security dolev yao model define security multicast key distribution dolev yao framework consider special class key distribution protocols encompasses protocols practical applications 
cf uf denote multicast key distribution protocol dolev yao framework 
program works just previous definition initializes state user ui fixed symbolic key ki unique user state center set unique keys kn bound number users 
program cf definition stronger giving adversary key kt random key time instant gt giving set keys kt experiment done 
strengthening affect result way definition sake simplicity 
practice group center store compact representation keys pseudorandom function 
takes commands form add ui del ui command returns expression mt denoting rekey message time 
internal state cf time consists unique keys rekey messages sent till time group composition time gt 
uf takes user index input returns key ki obtained applying dolev yao rules rekey messages received till current time knowledge key ki 
ki encryption key rekey messages sent group center time correctness require time instants identical group member ui time mt denote expression 
mt set kb denote set unique keys users set definition 
multicast key distribution protocol secure dolev yao framework sequence commands com com subset holds kt gt group key group member set time set gt 
mt kt kb mt kb kt kt set fresh keys 
protocol dolev yao framework translation computational framework respect symmetric encryption scheme protocol behaves identically difference key assignment generated set keys protocol execution key generation algorithm symbolic expressions key rekey message replaced bitstring interpretation soundness theorem show connection definitions 
theorem 
multicast key distribution protocol dolev yao framework property sequence commands com sequence rekey messages mt returned center program cf legal sequence 
ind cpa secure symmetric encryption scheme 
secure dolev yao framework definition secure computational framework definition 
proof sketch suppose contradiction satisfies definition satisfy definition 
computational adversary non set initially corrupted users adv negligible 
choice build adversary uses black box non negligible advantage experiment expt adpt defined soundness theorem 
queries oracle unique keys users invokes input corresponding keys 
query uses program cf determine rekey reason introduce requirement key encrypt message key necessarily pseudorandom anymore encryption scheme may leak partial information key 
message mt uses oracle determine computational interpretation returns 
queries oracle pair kt gt set fresh symbolic keys reply passed outputs outputs 
sequence rekey messages generated run legal sequence fact key kt encryption key messages follows adversary constructed legal adversary 
easy see advantage expt adpt means exactly expt non negligible quantity 
leads contradiction soundness theorem 
practical group key distribution schemes satisfy precondition theorem requires sequences rekey messages generated protocol legal sequences 
protocols easily proved secure symbolic framework 
follows natural implementation secure computational framework 
proof soundness theorem section provides overview proof soundness theorem 
details appear full version 
defining orders legal sequences expressions acyclic expression exp encrypts relation defines partial order keys consider restriction partial order just unrecoverable encryption keys 
total order set unrecoverable encryption keys consistent partial order called order example expression unrecoverable encryption keys 
gives partial order orders 
re interpret definition legal sequences expressions section 
recall sequence expression acyclic unrecoverable encryption key message key 
condition implies unrecoverable encryption key recoverable sets 

form monotonically nondecreasing sequences 
relation enables partition unrecoverable encryption keys sets ith set partition say contains keys encryption keys 
definition legal sequences implies key encrypt key fact acyclic find order keys precede keys ki kj ki kj 
select lexicographically order orders having property denote 
order just lexicographically order defined ordering produced prefix produced 
example consider sequence expressions observe sequence consistent definition legal sequences 
expressions 
lexicographically orders 
relations denoted respectively 
defining hybrid oracles proof soundness theorem uses hybrid technique 
define set hybrid oracles keys relate success probability legal adversary distinguishing neighboring pair oracles success probability distinguishing instances oracle viz 
experiment expt adpt relation show legal adversary non negligible advantage expt adpt non negligible success probability distinguishing mount successful attack ind cpa security underlying encryption scheme 
denote hybrid oracles extreme oracles correspond instantiations loss generality number key symbols potentially adversary generating queries assumed fixed polynomial security parameter 
respectively 
behavior oracle close behavior close similarly behavior similar close defined follows oracle oi oracle 

jth query received compute order set keys smallest keys 
new expression obtained substituting kl sub expressions form kl struct kl 
return new oracles oi defined analogously difference steps gets replaced 
fact oracles easy deduce lemma 
queries received oracles come legal adversary oracles identical behavior sequence queries distribution replies exactly replies 
proof note si simply set encryption keys mb unrecoverable means step oracle essentially involves substituting sub expressions encrypted key corresponding structure 
resulting expression pat replies query sample pat similarly replies query sample pat queries issued legal adversary expression pat mb mb equivalent pat mb mb unrecoverable encryption key mb recoverable queries 
case know expressions pattern renaming keys means pat pat denotes equality renaming keys 
elements key vector oracle generated independently conclude distribution replies sequence queries sequence queries 
identical replies define advantage distinguishing quantity oracles adv adpt oi oi oi lemma relates advantages advantage expt adpt lemma 
proof lemma follows chain inequalities shorthand adv adpt oi oi oi oi oi oi oi oi oi oi adv adpt eqn 
just application triangle inequality eqn 
follows lemma 
reduction legal adversary experiment expt adpt construct distinguisher attacking ind cpa security advantage performing ind cpa attack related polynomial multiplicative factor advantage expt adpt essentially implies successful attack expt adpt effectively translated attack underlying encryption scheme 
construction advantage expt ind cpa poly times expected advantage distinguishing oracles oi treated random variables sampled uniformly 
precisely construction adv ind cpa applying lemma get adv ind cpa adv adpt imply non negligible advantage expt ind cpa theorem follow immediately 
construction 
distinguisher works follows selects non negligible advantage experiment expt adpt random number range random bit tries simulate behavior oracle pair oi oi ora cle lr runs inside answers queries simulated setup 
carry simulation guesses value randomly hopes query issued th key order mb ki number unrecoverable encryption keys mb smaller ki recoverable key unrecoverable encryption key mb 
fails guess gives outputs 
treats key lr corresponding ki answers queries way behavior lr resp 
corresponds simulation oracle resp 

adversary lr 


guess value 

generate key vector follows 

ith entry empty rest random keys 

run 

issues jth query compute order mb 
check ki th key mb mb mb ki mb set keys mb smallest keys mb 
ii 
new expression obtained substituting kl sub expressions mb form kl struct kl iii 
return sample lr new ki 
output halt 

output outputs 
observe expression new step pseudocode created exactly way created oracle query 
crux code lies subroutine sample invoked step 
subroutine behaves differently way lr instantiated sample returns bitstring interpretation new exactly oracle sample returns bitstring interpretation modified version new viz 
expression created replacing sub expressions new occur encrypted ki corresponding structures mimics behaviour oracle 
main reason sample able carry desired simulation oracle pair oi key ki expression new passed arguments sample code ki message key new enables subroutine create bitstring interpretations expressions oracle access function uses encryption key knowing 
see invocation sample ki message key new observe takes place ki th key mb keys mb ki recoverable mb just doesn occur unrecoverable encryption key 
reason ki occur message key mb encrypted key si mb occurences ki get substituted structure key transforming mb new procedure sample lr ki 
constant return corresponding bitstring 

kl return 
return 

return sample ki sample ki 

kl return sample ki 
return sample ki 

kl return lr sample kj struct 
event values picked queries issued run inside conditions hold ki th key mb number unrecoverable encryption keys mb ki mb mb 
notice event takes place distinguisher reaches step simulation oracle pair oi goes perfectly oi access oracle lr resp 
lr receives replies queries just resp 
oi 
recall way defined orders mb mb mb th key orders mb size mb smaller means probability event takes place equal probability choice random values involved th key mb exactly key ki number unrecoverable encryption keys mb ki mb mb 
chosen uniformly random set probability happens advantage function computed follows adv ind cpa lr lr lr lr lr lr aoi adv adpt exactly required advantage 
proved generalization soundness theorem adversary issue sequence adaptively chosen expressions single expression demonstrated usefulness theorem application secure multicast key distribution 
simplicity considered language expressions symmetric encryption operations techniques easily extended cryptographic primitives security expressed indistinguishability property 
examples primitives public key encryption different keys encrypt decrypt messages pseudorandom number generators expand key sequence multiple seemingly independent keys 
extensions pseudorandom generators especially interesting context multicast security protocols protocol shown optimal dolev yao model operations 
proof soundness theorem introduces syntactic restriction acyclicity condition order key message encryption key 
interesting question assume execution exists unrecoverable encryption key 
keys recoverable identical chooses win experiment expt adpt probability better 
restriction lifted possibly special encryption scheme additional security properties candidate encryption introduced canetti feige goldreich naor 
practical protocols satisfy syntactic restrictions soundness theorem removing ordering restriction allow model attack scenarios adaptive corruption users adversary wants corrupt user holding secret key ki internal state simply issue expression ki learn value key 
currently allowed ki encrypt messages 
designing protocols secure adaptive corruption raises issues similar selective decommitment problem discussed section easily addressed techniques developed 
leave investigation multicast key distribution protocols secure adaptive corruption users 

abadi 
formal eavesdropping computational interpretation 
kobayashi pierce editors proceedings th international symposium theoretical aspects computer software volume lecture notes computer science pages 
springer verlag oct 

abadi rogaway 
reconciling views cryptography computational soundness formal encryption 
journal cryptology 

backes pfitzmann 
symmetric encryption simulatable dolev yao style cryptographic library 
proceedings th computer security foundations workshop pages 
ieee computer society june 

backes pfitzmann waidner 
composable cryptographic library nested operations 
proceedings th acm conference computer communications security pages 
acm oct 

canetti feige goldreich naor 
adaptively secure multiparty computation 
proceedings eighth annual acm symposium theory computing pages 
acm may 

canetti garay micciancio naor pinkas 
multicast security taxonomy efficient constructions 
infocom volume pages 
ieee mar 

canetti malkin nissim 
efficient communication storage tradeoffs multicast encryption 
stern editor advances cryptology eurocrypt volume lecture notes computer science 
springer verlag may 

dolev dwork naor 

siam journal computing 
preliminary version stoc 

dwork naor reingold stockmeyer 
magic functions 
journal acm nov 

gligor horvitz 
weak key authenticity computational completeness formal encryption 
boneh editor advances cryptology crypto volume lecture notes computer science pages 
springer verlag aug 

goldwasser micali 
probabilistic encryption 
journal computer system 

herzog 
computational soundness standard assumptions formal cryptography 
phd thesis massachusetts institute technology boston usa 

impagliazzo 
logics reasoning cryptographic constructions 
proceedings rd annual symposium foundations computer science pages 
ieee nov 

laud 
symmetric encryption automatic analyses confidentiality active adversaries 
ieee symposium security privacy pages 
ieee computer society may 

lincoln mitchell mitchell scedrov 
probabilistic polytime framework protocol analysis 
proceedings fifth acm conference computer communications security ccs pages 
acm nov 

micciancio 
computationally sound symbolic security analysis june 
tutorial 
slides available dimacs rutgers edu workshops protocols slides micciancio pdf 

micciancio 
optimal communication complexity generic multicast key distribution 
cachin camenisch editors advances cryptology eurocrypt volume lecture notes computer science 
springer verlag may 

micciancio warinschi 
completeness theorems abadi rogaway logic encrypted expressions 
journal computer security 

micciancio warinschi 
soundness formal encryption presence active adversaries 
naor editor theory cryptography conference proceedings tcc volume lecture notes computer science pages 
springer verlag feb 

rackoff simon 
non interactive zero knowledge proof knowledge chosen ciphertext attack 
feigenbaum editor advances cryptology crypto volume lecture notes computer science 
springer verlag aug 

rafaeli hutchinson 
survey key management secure group communication 
acm computing surveys sept 

wong gouda lam 
secure group communications key graphs 
ieee acm transactions networking feb 
