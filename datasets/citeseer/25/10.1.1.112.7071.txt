combinators bi directional tree transformations linguistic approach view update problem nathan foster university pennsylvania michael greenwald bell labs lucent technologies jonathan moore university pennsylvania benjamin pierce university pennsylvania alan schmitt inria rh ne alpes propose novel approach view update problem tree structured data domainspecific programming language expressions denote bi directional transformations trees 
direction transformations dubbed lenses map concrete tree simplified view map modified view original concrete tree correspondingly modified concrete tree 
design emphasizes robustness ease guaranteeing strong behavedness totality properties welltyped lenses 
identify natural mathematical space behaved bi directional transformations arbitrary structures study definedness continuity setting state precise connection classical theory update translation constant complement databases 
instantiate semantic framework form collection lens combinators assembled describe transformations trees 
combinators include familiar constructs functional programming composition mapping projection conditionals recursion novel primitives manipulating trees splitting pruning copying merging 
illustrate expressiveness combinators developing number bi directional transformations derived forms 
extended example shows combinators define lens translates native html representation browser bookmarks generic bookmark format 
categories subject descriptors programming languages language classifications specialized application languages general terms languages additional key words phrases bi directional programming harmony xml lenses view update problem permission digital hard copy part material fee personal classroom provided copies distributed profit commercial advantage acm copyright server notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
acm xxx xxx xx xxxx xxxx xx xx acm transactions programming languages systems vol 
tbd 
tdb month year pages 
foster 
computing full situations structure converted different form view way changes view reflected back updates original structure 
view update problem classical topic database literature far little studied programming language researchers 
addresses specific instance view update problem arises larger project called harmony foster 
harmony generic framework synchronizing tree structured data tool propagating updates different copies tree shaped data structures possibly stored different formats 
example harmony synchronize bookmark files different web browsers allowing bookmarks bookmark folders added deleted edited reorganized browser propagated 
ultimate aim project provide platform harmony programmer quickly assemble high quality synchronizer new type tree structured data stored standard low level format xml 
harmony instances currently daily development include synchronizers calendars palm ical formats address books slide presentations structured documents generic xml html 
views play key role harmony synchronize structures may stored disparate concrete formats define common view collection lenses transform concrete format view 
example synchronize mozilla bookmark file internet explorer bookmark file transforming bookmark structure propagating changed information 
need take updated structures reflect corresponding updates original concrete structures 
lens include functions extracting view concrete putting updated view back original concrete view yield updated concrete view 
call get putback components respectively 
intuition mapping concrete commonly sort projection get direction involves getting part larger concrete structure putback direction amounts putting new part old concrete structure 
show concrete example process section 
difficulty view update problem springs fundamental tension expressiveness robustness 
richer set possible transformations get direction difficult define corresponding functions putback direction way lens behaved get putback behaviors fit sensible way total get putback functions defined inputs may applied 
reconcile tension successful approach view update problem carefully designed particular application domain mind 
approach described tuned kinds projection rearrangement transformations trees lists useful implementing harmony instances 
directly address known difficulties view update acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations classical setting relational databases difficulty inverting queries involving joins hope may suggest new attacks problems 
second difficulty concerns ease 
general ways equip get function putback function form behaved total lens need means specifying putback intended way natural application domain involve onerous proof obligations checking side conditions 
adopt linguistic approach issue proposing set lens combinators small domain specific language expression simultaneously specifies get function corresponding putback 
combinator accompanied type declaration designed behavedness non recursive lenses totality composite lens expressions verified straightforward compositional checks 
proving totality recursive lenses ordinary recursive programs requires global reasoning goes types 
step formal development section identifying natural mathematical space behaved lenses arbitrary data structures 
deal territory explored semantic level 
phrase basic definitions allow underlying functions lenses partial general structures lens sensibly applied 
sets structures intend apply lens specified associating type form set concrete source structures set target structures second define notion behavedness captures intuitions get putback parts lens behave concert 
example get part lens extract view concrete view putback part push back get back 
third standard tools domain theory define monotonicity continuity lens combinators parameterized lenses establishing foundation defining lenses recursion needed trees lenses manipulate may general arbitrarily deep nested structure represent directory hierarchies bookmark folders 
allow lenses create new concrete structures just updating existing ones needed example new records added database view adjoin special missing element structures manipulated lenses establish suitable conventions treated 
semantic foundations place proceed syntax 
section group generic lens combinators identities composition constants kind data 
section focus attention tree structured data combinators perform various manipulations trees hoisting splitting mapping show assemble primitives generic combinators yield useful derived forms 
section introduces set generic combinators implementing various sorts bi directional conditionals 
section gives ambitious illustration expressiveness combinators implementing number bi directional list processing transformations derived lenses projecting head tail list mapping list acm transactions programming languages systems vol 
tbd 
tdb month year 
foster grouping elements list concatenating lists complex example bi directional filtering lens putback function performs intricate weaving operation recombine updated list concrete list elements filtered away get 
section demonstrate reasoning techniques developed section 
section illustrates combinators real world lens programming walking substantial example derived harmony bookmark synchronizer 
section presents steps somewhat different region lens design space lenses dealing relational data encoded trees 
define primitives flattening combinator transforms list keyed records bush pivoting combinator promote key field higher position tree transposing combinator related outer join operation databases 
combinators play important role harmony instances relational data address books encoded xml trees 
section surveys variety related states precise correspondence behaved lenses closely related idea update translation constant complement databases 
section sketches directions research 
keep things moving defer proofs appendix 
small example suppose concrete tree simple address book phone pat url pat com phone chris url chris org draw trees sideways save space 
set hollow curly braces corresponds tree node denotes child labeled string children node unordered 
avoid clutter edge leads empty tree usually omit braces symbol final node stands trees linearized running text separate children commas easier reading 
suppose want edit data concrete tree simpler format name associated directly phone number 
pat chris want 
edits going performed synchronizing tree replica address book url information recorded 
synchronizer involved edits going performed human interested phone information doesn want see urls 
reason going changes tree yielding new tree acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations form modified content 
example change pat phone number drop chris add new friend jo 
pat jo lastly want compute new concrete tree reflecting new tree want parts kept calculating pat phone number overwritten corresponding information parts filtered pat url values carried phone pat url pat com phone jo url google com need fill appropriate values parts particular jo url created contains information 
simply set url constant default general want compute information 
transformations plus form lens 
goal find set combinators assembled describe wide variety lenses concise natural mathematically coherent manner 
reader lens expression implements transformations map focus phone url google com 

semantic foundations combinators trees semantic underpinnings setting parameterized data structures call views manipulated lenses 
section section discuss generic combinators simply assume fixed set views section choose set trees 
basic structures partial function write defined argument 
write write dom set arguments defined 
write note interested final tree particular sequence edit operations transform important context harmony designed support synchronization shelf applications general access current states replicas trace modifications tradeoffs state trace synchronizers discussed detail pierce vouillon foster 
word view slightly different sense database papers cite view query maps concrete states function concrete database state picks view sense 
note view refer uniformly concrete structures come programming lenses distinction merely matter perspective anyway output lens input 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster ran 
take function application strict implies 
definition lenses lens comprises partial function called get function partial function called putback function 
intuition notations get part lens lifts view concrete putback part pushes new view existing concrete view 
say put apply putback function definition behaved lenses lens subsets say behaved lens written iff maps arguments results vice versa get put get putback functions obey laws putget call source target note may behaved lens different cs particular trivially behaved lens undefined lens belongs intuitively law states get view concrete view immediately putback modifications get back exactly operations defined 
putget hand demands putback function capture information contained view putting view concrete view yields view view obtained exactly example lens satisfying putget 
suppose string int string define 
intuitively law fails putback function side effects modifies information concrete view reflected view 
example lens satisfying putget 
string string int define putget fails information contained view get propagated new concrete view 
example 
putget laws reflect fundamental expectations behavior lenses removing law significantly weakens semantic foundation 
acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations may consider optional third law called law states effect sequence modulo definedness just effect second gets completely overwritten 
alternatively series changes view may applied incrementally resulting final concrete view 
say behaved lens satisfies behaved 
behaved behaved lenses correspond known classes update translators classical database literature see section 
foundational development section valid behaved behaved lenses 
come defining lens combinators tree transformations require lens combinators map flatten fail satisfy reasons pragmatically unavoidable see sections 
simple example lens behaved behaved constructed follows 
consider lens string int string 
second component concrete view intuitively represents version number 
get function projects away version number yields just data part putback function overwrites data part checks new data part old increments version number 
lens satisfies putget 
critical property lenses totality respect source target 
definition totality lens said total written dom dom 
reasons considering partial total lenses building totality definition behavedness conventional functional languages 
practice want lenses total guarantee harmony synchronizers predictably lenses defined domains get direction defined structure concrete set putback direction capable putting back possible updated version set 
primitive lenses designed total lens combinators map total behavedness somewhat trivial absence totality function obtain behaved lens undefined inputs slightly trivially defined inputs form 
intend lenses build synchronizers updated structures results synchronization 
fundamental property core synchronization algorithm harmony updates synchronizations occur just replicas effect synchronization propagate changes replica 
implies acm transactions programming languages systems vol 
tbd 
tdb month year 
foster lenses total lenses sole important exception lenses defined recursion usual recursive lenses constructed semantics limits chains increasingly defined partial lenses 
soundness type annotations give syntactic lens combinators guarantees typed lens expression behaved recursion free expressions shown total completely compositional reasoning types recursive lenses global arguments required 
basic properties explore simple useful consequences lens laws 
definition partial function say injective injective standard sense component arguments drawn views implies 
lemma injective 
main application lemma corollary provides easy way show lens behaved 
times designing combinators quickly generate test candidates 
corollary injective important special case arises putback function lens completely insensitive concrete argument 
definition lens said oblivious oblivious lenses special properties simpler reason lenses general 
example lemma oblivious 
lemma oblivious bijection conversely bijection induces total oblivious lens set bijections subsets forms subcategory category total lenses 
combinators defined live simpler subcategory related surveyed section 
putback function lens associated replica prepared accept value domain 
settings different notions totality may appropriate 
example hu mu takeichi hu argued context interactive editors reasonable definition totality defined differs edit operation acm transactions programming languages systems vol 
tbd 
tdb month year 
recursion combinators bi directional tree transformations interested lenses trees trees interesting application domains may unbounded depth bookmark link folder containing list bookmarks want define lenses recursion 
task set necessary structure interpreting definitions 
development follows familiar lines 
introduce information ordering lenses show set lenses equipped ordering complete partial order cpo 
apply standard tools domain theory interpret variety common syntactic forms programming languages particular functional abstraction application higher order lenses lenses defined single mutual recursion 
say lens informative lens written get putback functions domains large results agree common domains definition iff dom dom dom dom dom dom 
lemma partial order lenses 
cpo partially ordered set increasing chain elements upper bound set 

ln 
increasing chain write ln shortened ln upper bound 
cpo bottom cpo element smaller element 
setting lens get putback functions undefined 
lemma 
ln 
increasing chain lenses 
lens defined li li li li undefined upper bound chain 
corollary 
ln 
increasing chain lenses 
ln iff li 
ln iff li lemma 
ln 
increasing chain lenses 

increasing chains subsets behavedness commutes limits 
li ci ai implies ln ci ai 
totality commutes limits 
li ci ai implies ln ci ai 
theorem set behaved lenses cpo bottom 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster defining lenses heavy standard theorem domain theory winskel 
recall function cpos continuous monotonic increasing chains 
ln 
ln ln 
fixed point function fix satisfying fix fix 
theorem fixed point theorem continuous function cpo bottom 
define fix fix fixed point fact fixed point theorem tells apply theorem continuous functions lenses lenses justifies defining lenses recursion 
corollary packages argument convenient form appeal times sections show recursive derived forms behaved total 
corollary suppose continuous function lenses lenses 
implies fix 
suppose 

increasing chains subsets ci ai implies ci ai fix ci ai 
apply standard domain theory interpret variety constructs defining continuous lens combinators 
say expression continuous variable function continuous 
expression said continuous variables simply continuous continuous variable separately 
examples continuous expressions variables constants tuples continuous expressions projections continuous expressions applications continuous functions continuous arguments lambda abstractions bodies continuous bindings continuous expressions continuous bodies case constructions continuous expressions fixed point operator 
tupling projection define mutually recursive functions want define continuous define fix 
proving totality recursive lenses need powerful induction scheme lens proved simultaneously total collection different types induction step 
supported generalization proof technique 
specify total type pair subsets say lens type written iff variable total types sets total types 
write iff write 
definition increasing chain 
increasing instance sequence 
iff ti 
acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations note 
arbitrary sequence sets total types sequence need increasing 
trick proof technique start sequence sets total types 
priori show continuous function lenses gets ti ti sense takes lens belongs total types ti lens belongs total types ti 
identify increasing chain particular total types 
limit total type desire show fixed point belongs ti type 
generalization corollary increasing instances sequences sets total types 
lemma suppose continuous function lenses lenses 
sequence sets total types 
ti 
implies ti 
increasing instance 

fix dealing creation practice cases need apply putback function old concrete view available saw jo url section 
deal cases enriching universe views special placeholder pronounced missing assume write 
intuitively means create new concrete view information view convention interesting way second argument putback function lenses defined maintain invariants including 
write set behaved lenses obeying conventions set total lenses obeying conventions 
brevity lens definitions assume defining defining results cases uniquely determined conventions 
formally equivalent ways handling missing concrete views 
advantages discussed section 
useful consequence conventions lens type lemma lens sets views 
generic lenses implies semantic foundations hand ready move syntax 
section generic lens combinators usually say just lenses definitions independent particular choice universe definition accompanied type declaration asserting certain conditions identity lens belongs 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster lens definitions parameterized arguments 
may various types views const lenses composition predicates views conditional lenses section lenses trees section edge labels predicates labels appendix contains representative proofs lenses define behaved type declaration accompanying definition theorem total lenses take lenses parameters continuous parameters map total lenses total lenses 
nearly lenses behaved lens arguments exceptions map flatten prove behavedness mainly interested just behaved case 
identity simplest lens identity 
copies concrete view get direction view putback direction 
id id id having defined id prove behaved total type declaration theorem 
state properties explicitly postponing proofs appendix henceforth give statements properties proofs representative lenses 
lens elide statements properties read lens definition proofs largely calculational nature 
lemma behavedness id lemma totality id lens definition statements totality lemma lemmas identical just replacing case id just combine single lemma lens total type behaved type 
lens definitions parameterized lenses composition just totality compound lens depends totality just behavedness argument lenses 
establish behavedness arguments behaved necessarily total 
scenario lemma combines behavedness totality help mentions total lenses 
expect situation common practice programmers want check lenses behaved reasoning involved simple local may want go trouble setting intricate global reasoning needed prove recursive lens definitions total state lemmas typings separately 
composition lens composition combinator places sequence 
acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations get direction applies get function yield view get function applied 
direction putback functions applied turn putback function put concrete view get applied result put putback function 
concrete view conventions treatment effect put put result 
note record different type declarations composition case parameter lenses known behaved case known total 
proofs composition operator types mentioned appendix lemma behavedness lemma totality behavedness totality show lens composition continuous arguments 
justify composition recursive lens definitions order recursive lens defined fix may mention formed need apply theorem requires continuous lemma shows case continuous proved analogous lemma lens combinators takes lenses parameters continuity lens expression follow continuity immediate constituents 
sake brevity give full argument omit statements proofs continuity lemmas 
lemma continuity continuous functions lenses lenses 
function 
continuous 
constant simple combinator const transforms view constant view get direction 
putback direction const simply restores old concrete view available concrete view returns default view 
const const const acm transactions programming languages systems vol 
tbd 
tdb month year 
foster note type declaration demands putback direction applied argument define generic lenses section turn lens combinators tree structured data ground definitions specific examples 

lenses trees keep definitions lens primitives straightforward possible extremely simple form trees unordered edge labeled trees repeated labels 
model natural fit applications data unordered keyed address books described section 
unfortunately unordered trees structure need applications particular need deal ordered data lists xml documents encoding shown section 
experience shown reduction complexity definitions lens primitives far outweighs increase complexity lens programs due manipulating ordered data encoded form 
notation point choose universe set finite unordered edge labeled trees labels drawn infinite set names character strings children node labeled distinct names 
trees form extended labels internal nodes children called feature trees podelski 
variables range convention trees thought concrete trees 
tree essentially finite partial function names trees 
convenient adopt slightly different perspective consider tree total function yields finite number names 
write dom domain set names returns subtree associated name dom 
tree values written hollow curly braces 
empty tree written 
note node children different 
describe trees comprehension writing function set names 
disjoint domains write especially multi line displays tree mapping dom dom 
set names write complement write restriction children names tree dom dom just singleton set drop set braces write just 
shorten lens definitions adopt conventions dom writing types extend tree notations sets trees 
note defining syntax lens expressions types classify expressions semantic just sets lenses views 
see section acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations denotes set singleton trees 
denotes set trees dom denotes set trees dom 
write 
doms dom 
note doms set sets names dom set names 
value tree special form written just instance phone number example section value 
write val type denotation set values 
hoisting warm combinators perform simple structural transformations trees 
lens hoist shorten tree removing edge top 
get direction expects tree exactly child named returns child removing edge putback direction value old concrete tree ignored new created single edge pointing tree 
meet derived form hoist nonunique works trees 
hoist hoist hoist conversely plunge lens deepen tree adding edge top 
get direction new tree created single edge pointing concrete tree 
putback direction value old concrete tree ignored tree required exactly subtree labeled result plunge 
plunge plunge forking plunge lens combinator xfork applies different lenses different parts tree splits tree parts names immediate children applies different lens concatenates results 
formally xfork takes arguments sets names lenses 
get direction xfork pc pa visualized concrete tree bottom 
triangles labeled pc denote trees immediate children labels pc dotted arrows represent splitting concatenating trees 
result applying pc tree formed dropping immediate children names pc tree top level labels set pa similarly result proposing algebra types algorithm mechanically checking membership lens expressions type expressions 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster pa pa pa pc pc pc pa pc fig 

get direction xfork applying pc pa lens may change names immediate children tree map part tree immediate children belonging pc tree children belonging pa likewise map part tree immediate children belonging pc tree children pa conversely putback direction map pa pc pa pc 
full definition xfork pc pa pc pc xfork pc pa pa pc pa pc pc pa pc 
pa pc 
pa 

xfork pc pa pc pa pc 
pa pc 
pa 

xfork pc pa rely convention avoid explicitly splitting case putback direction 
defined basic lenses implement useful derived forms manipulating trees 
uses xfork sets names specifying split concrete tree split tree identical 
define simpler fork fork xfork 

fork 

fork acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations fork define lens discards children tree names belong set filter fork id const filter get direction lens takes concrete tree keeps children names id throws away rest const 
tree putting tree back missing concrete tree providing default information appear tree required concrete tree 
type filter follows directly types primitive lenses define const type lens id type fork observation 
see filter behaves example 
concrete tree name pat phone lens filter name 
calculate underlining term step 
fork name id const name pat phone definition id name pat const phone definition fork splitting name name pat name pat definitions id const suppose update tree name calculate result putting back save space write const 
fork name id name pat name pat phone definition id name name pat phone definition fork splitting name name phone definition id const note putback function restores filtered part concrete tree propagates change tree 
case creation put back tree default argument const concatenated tree form result filtered part concrete tree restore 
way thin tree explicitly specify child removed exists prune fork const id 
prune acm transactions programming languages systems vol 
tbd 
tdb month year 
foster lens similar filter name child removed set children keep default tree go concrete tree 
conversely grow tree get direction explicitly adding child 
type annotation disallows changes newly added tree dropped putback 
add xfork const plunge id add explore behavior add example 
save space write 
calculate directly underlining term step 
xfork id definition id definition xfork splitting definitions composition id definition definition suppose modify tree renaming child obtaining result putback function calcu lated follows xfork id definition id definition xfork splitting splitting definition id definition composition definition definition acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations lens focuses attention single child focus filter hoist focus get direction focus filters away children removes edge yields subtree 
usual default tree case creation default children filtered away 
type focus follows types lenses defined observing filter hoist hoist primitive defined earlier requires name hoisted unique child concrete tree 
useful relax requirement hoisting child 
generalized version hoist annotated set possible names grandchildren children hoist disjoint names existing children 
hoist nonunique xfork hoist id 
hoist nonunique derived lens renames single child 
rename xfork hoist plunge id 
rename get direction rename splits concrete tree 
tree single child guaranteed exist type annotation hoisted removing edge named rest original tree passed id lens 
similarly putback direction splits view tree single child rest tree 
tree put back lens hoist plunge removes edge named resulting tree note type annotation rename demands concrete view child named view child named section see wrap lens conditional obtain lens flexible type 
mapping far lens combinators things near root trees 
course want able perform transformations interior trees 
combinator fundamental means doing 
combined recursion allows iterate structures arbitrary depth 
map combinator parameterized single lens get direction map applies subtree root combines results acm transactions programming languages systems vol 
tbd 
tdb month year 
foster new tree 
section define general combinator called wmap apply different lens subtree 
defining map notational burden explanations fine points behavior typing combinators 
example lens map behavior get direction applied tree children putback direction map interesting 
simple case equal domains behavior straightforward uses combine concrete subtrees identical names assembles results new concrete tree map general tree putback direction need domain edits produced new view may involved adding deleting children behavior map case little involved 
observe domain determined domain argument putback 
aim building total lenses may suppose map map defined case equal rule putget 
dom map map dom dom map dom get map change domain tree 
means simply drop children occur dom dom 
children bearing names occur dom dom dealt described 
leaves children appear dom need passed included need concrete argument pass 
corresponding child trees put missing tree case precisely introduced 
formally behavior map defined follows 
relies convention dom type declaration involves new notation explained 
map dom map dom doms doms 

map doms doms 

map way takes tree apart transforms pieces typing map little subtle 
example get direction map acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations modify names immediate children concrete tree putback direction names tree left unchanged expect simple typing rule stating behaved lens concrete subtree type subtree type child map unfortunately arbitrary map lens guaranteed behaved type 
particular doms set domains trees equal doms putback function produce tree example shows 
consider sets trees observe trees map id tree shows type map include requirement doms doms 
recall type set doms set sets names 
related problem arises sets trees dependencies names children trees may appear names 
naively expect type name map type consider set value appears appears set appear consider just projections specific names obtain sets subtrees 
lens id type names 
clearly case map id avoid error give type map precise derive interesting types lenses defined terms map require source target sets type map closed shuffling children 
formally set trees set denoted doms set trees domain children taken set 
say shuffle closed iff example shuffle closed 
alternatively shuffle closed set identified set set names function names types dom name dom 
formally shuffle closed set defined follows acm transactions programming languages systems vol 
tbd 
tdb month year 
foster situations map shuffle closure typically easy check 
example restriction tree grammars embodied schema implies shuffle closure informally restriction schema analagous imposing shuffle closure schemas path just root 
additionally set trees elements singleton domains shuffle closed 
set trees encoding introduced section lists elements shuffle closed justifies map recursion implement operations lists 
furthermore types form infinite domain structure edge heavily database examples top level names keys structures records shuffle closed 
point note map obey law 
consider lens dom 
map map map map intuitively difference hand modifying child removing adding back case information concrete view projected away view carried new concrete view second information replaced default values 
difference pragmatically reasonable prefer keep map lose 
final point interest relation map missing tree 
putback function lens combinator results putback missing tree combinator called 
case map calling putback function missing tree may result application putback children earlier variant map dealt missing children providing default concrete child tree actual concrete tree available 
discovered practice difficult find single default concrete tree fits possible trees particularly xfork different lenses applied different parts tree recursion depth tree unknown 
tried parameterizing default concrete tree tree lens noticed primitive lenses ignore concrete tree defining putback function information available tree 
natural choice concrete tree parameterized special tree 
lens putback function needs defined const alternatively refinement type system track hold annotating lens combinators extra type information recording fact oblivious give map types gave plus saying map applied oblivious lens result behaved acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations lens discards information 
led design const lens lenses defined focus expects default tree approach local tried provides defaults exact point information discarded 
define general form map parameterized total function names lenses single lens 
wmap dom wmap dom doms doms 

wmap doms doms 
wmap 
type annotation dependent type notation mean total function mapping name behaved lens 
total function describe giving behavior finite set names adopting convention maps name id example lens wmap plunge maps plunge trees id subtrees child 
easily define map derived form map wmap 
typing wmap subtle state prove behavedness lemma explicitly 
lemma behavedness doms doms 

wmap copying merging consider lenses duplicate information direction performing equality checks 
view underlying data structure may require distinct subtrees maintain relationship equality 
example subtree representing manager alice employee manager database may list name id number employee alice group 
bob managed alice bob employee record list name id number information including pointer alice manager 
bob name changes date expect updated identically record alice record 
concrete representation contains name single location need duplicate information get direction 
need lens copies subtree allows transform copy shape want 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster get direction copy takes tree child labeled exists copy duplicates setting equal 
putback direction copy simply discards 
type copy ensures information lost 
copy copy 
copy want copy total lens equality constraint type copy essential ensure behavedness 
see consider happen putback function defined equal copy removed 
way application get function restore discarded information 
consequently putget violated 
unfortunately constraint set lenses validly composed right restricted composed lenses respect equality 
example go wrong consider copy prune suppose want assign lens typing concrete component simple calculation shows get function behaves id lens copies prunes away run problems evaluate copy prune 
un winding composition evaluate copy argument argued copy lens defined behaved argument copied data identical 
example demonstrates lenses composed copy preserve equality copied data 
ensure type requirement satisfied 
intended application lenses build synchronizers tree structured data need copy 
surprising concrete representation demands invariant hold data structure assume application locally maintain invariants representation function synchronizer simply propagate changes formed replica 
field concrete representation derivable set fields need expose fields view 
merge fields see 
change merged field pushed back derived fields concrete view 
merge inverse copy sense views manipulated data synchronizer 
contrast argued need powerful forms copy settings editing user friendly view structured document hu mu 
consider situation user edits view view document table contents automatically generated section headings appearing source text concrete structure 
feel adding new section add entry table contents acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations similarly adding entry table contents create empty section text 
functionality consistent putget law adding section heading adding entry table contents result concrete document putback putback function injective participate lens sense 
contexts functionality primary goal system designers may willing weaken promises programmers guaranteeing weaker properties putget 
example mu mu require bidirectional transformations obey law 
weaker putget ways 
require equal require contain information sense second allow get undefined parts range putback required hold defined requirements broadly get defined 
setting interactive reasonable say get putback undefined system signal user modification illegal withdrawn 
hu hu go step weaken putget requiring putget hold requiring hold concrete representation requires equality distinct subtrees view 
merge lens way preserve invariant view updated 
get direction merge takes tree equal branches deletes 
putback direction merge copies updated value remaining branch branches concrete view 
merge merge 
merge freedom type merge 
hand give precise type expresses intended equality constraint concrete view lens behaved total type 
alternatively give permissive type ignoring equality constraint original branches unequal merge defined behavedness preserved 
possible old concrete view argument putback function tested see branches equal value overwrite value deleted branch allowing merge obey putget 
copy merge quite useful synchronization framework 
example bookmark synchronizer xml representation apple safari bookmark files includes url data link twice 
merging appropriate children record dependency ensure updates url fields consistently propagated locations 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster 
conditionals conditional lens combinators selectively apply lens view necessary writing interesting derived lenses 
xfork variants split input trees parts send part separate lens recombine results conditional lens performs test sends trees sub lenses 
requirement conditionals tricky totality want able take concrete view put conditional lens obtain view take view suitable type push back 
ensure view guaranteed sent sub lens way took way sub lenses constrained behave coherently 
want reasoning behavedness totality compositional absence recursion want behavedness totality composite lenses follow just behavedness totality sub lenses special facts behavior sub lenses second unacceptable 
interestingly adopt approach give complete characterization possible conditional lenses argue binary conditional operator yields behaved total lenses instance general cond combinator 
general cond little complex start discussing particularly useful special cases 
concrete conditional conditional ccond parameterized predicate views lenses 
get direction tests concrete view applies get satisfies predicate 
putback direction ccond examines concrete view applies putback satisfies predicate 
arguably simplest possible way define conditional fixes decisions get direction constraint target 
interested ccond define total lenses strong condition 
ccond ccond ccond ccond subtlety definition worth noting arbitrarily choose putback 
equally arrange definition send 
fact need behaved defined construct behaved total lens ccond acm transactions programming languages systems vol 
tbd 
tdb month year 
conditional combinators bi directional tree transformations quite different way defining conditional lens ignore concrete argument putback direction basing decision entirely argument 
obliviousness concrete argument removes need side conditions relating behavior works fine putback opposite lens get long immediately put result get lens get 
requiring sources targets disjoint guarantees 
acond acond 

acond acond 

section defined lens rename type demands concrete tree child named tree child named conditional write permissive lens renames child behaves identity 
rename acond rename id 
rename general conditional general conditional cond essentially obtained combining behaviors ccond acond 
concrete conditional requires targets lenses identical conditional requires disjoint 
generally overlap arbitrarily behaving ccond region overlap arguments putback intersection targets acond regions argument putback belongs just targets 
add additional observation definition acond arbitrary 
required putback concrete argument come guaranteed 
considerations lead definition 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster cond cond 



cond 


cond targets cond chooses solely ccond targets overlap 
lies range cond choice lens putback predetermined acond targets disjoint 
chosen old value ran apply function choose new value ran 
possible result functions general compute interesting value see list filter lens defined section 
introduced cond argued captured power ccond acond functions 
argue maximum generality possible behaved total lens combinator behaves binary conditional obtained special case cond 
course argument hinges mean say behaves conditional capture intuition direction test input decide behave get direction little choice say just argument test just amounts testing membership set predicate 
putback direction apparent flexibility test investigate arguments 
requirements behavedness feeling conditional lens parametric sense choice investigating behavior eliminate flexibility 
example input falls choice apply fully determined may case guarantees required gives guarantee conversely 
similarly choice type promise applying argument type yield result 
similarly 
little genuine freedom type acm transactions programming languages systems vol 
tbd 
tdb month year 

combinators bi directional tree transformations danger order apply need element concrete argument matter pick conversely 
functions cover possible deterministic ways making choice 
possible slightly general making take arguments pragmatically little point doing going called result functions just take account 

derived lenses lists xml concrete data formats heavy ordered lists 
describe section represent lists trees standard cons cell encoding introduce derived lenses manipulate 
simple lenses projecting head tail list encoded cons cell 
define recursive lenses implementing complex operations lists mapping reversal grouping concatenating filtering 
give proofs behavedness totality lemmas appendix recursive lenses demonstrate reasoning principles developed section applied practical examples 
encoding definition tree said list iff empty exactly children named named list 
lighter notation tn tree tn 
types write set containing empty list set cons cell trees head belongs tail belongs set lists elements smallest set trees satisfying 
refine notation describe lists specific lengths writing set lists ds length writing set lists length exactly 
list values set lists denoted contains lists formed elements combining elements arbitrary fashion maintaining relative order 
example set 
lift interleaving operator list types obvious way interleaving list types union interleavings lists belonging lists belonging 
similarly lift usual append operator written list types denotes set lists obtained appending element element 
head tail projections list lenses extract head tail cons cell 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster hd focus hd tl focus tl lens hd expects default tree uses putback direction tail created tree concrete tree missing get direction returns tree lens tl works analogously 
note types lenses apply homogeneous lists type hd implies 
hd cons cells head tail unrelated types possibilities type bookmark lens section 
types hd tl follow type focus 
list map list map lens applies lens element list list map wmap list map list map list map get direction applies subtree recurses subtree putback direction uses corresponding pairs elements concrete lists 
result length list concrete list longer extra tail thrown away 
shorter extra element list putback 
list map recursive lens worth noting recursive calls direction 
get function wmap lens simply applies head list map tail reaches tree children 
similarly putback direction wmap applies head tree head concrete tree applies list map tail tree tail concrete tree 
directions recursive calls continue entire tree concrete get putback traversed 
list map defined recursively proving behaved requires just little non recursive derived lenses need show particular type assuming recursive list map type 
surprising exactly reasoning process typing recursive functional programs 
recall type wmap requires sets trees type shuffle closed 
prove list map behaved total need lemma showing cons cell list types shuffle closed 
lemma acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations pieces hand behavedness lemma follows straightforward calculation type wmap 
lemma behavedness list map proof totality list map interesting 
corollary 
corollary requires identify chains types 
ci ai prove ci ai conclude fix ci ai 
list map choose increasing chains types follows ci 
ai 
full argument proof lemma 
lemma totality list map reverse lens reverses elements list 
algorithm implement list reversal quadratic time algorithm reverse tail list auxiliary lens rotate head reversed tail 
presenting list reverse lens describe auxiliary lens called rotate 
rotate acond id rename tmp hoist nonunique fork id rename tmp rotate plunge rotate get direction rotate cases 
list empty singleton applies id returns original empty singleton list unmodified 
renames head tmp tail yields children list empty singleton splits tree fork applying id lens part tree consisting single child second element original list rest tree renaming tmp back recursively rotating list contains head tail tail original list result putback direction cases corresponding arms acond lens 
checks view empty list singleton list 
applies id lens returns list unchanged 
applies steps reverse order splitting concrete lists get direction passing head id lens tail hoisting tail tag recursively applying rotate renaming child named element original list tmp rotated tail original head list renaming tmp effect bringing element acm transactions programming languages systems vol 
tbd 
tdb month year 
foster list head result shifting position element 
behavedness proof simple calculation corollary types lenses composed 
lemma behavedness rotate totality lemma proved corollary establishing induction rotate di di 
lemma totality rotate rotate definition list reverse straightforward list reverse wmap list reverse rotate list reverse get direction simply reverse tail rotate head element list 
putback direction perform steps reverse order rotating element list head reversing tail 
note list reverse behaves identity applied empty list get putback components wmap rotate map 
algorithm computing reversal list shown runs quadratic time 
interestingly able code familiar linear time algorithm derived lens course introduce primitive lens reversing lists uses efficient implementation internally interesting try write efficient version combinators 
difficulty arises accumulator store result putback function transformation non injective satisfy putget 
see consider putting tree containing accumulator child rest list 
yield result abc putting back tree containing accumulator child rest list 
behavedness lemma follows straightforwardly types wmap rotate corollary 
lemma behavedness list reverse totality lemma corollary proving induction list reverse lemma totality list reverse grouping give definition grouping lens get direction takes list ds produces list list ds elements grouped pairs 
bookmark synchronizer part transformation takes dictionaries user preferences stored particular xml format apple safari browser yields trees simplified format 
concrete list number elements behavior group lens simple maps 
acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations odd number elements list group places final odd element singleton list maps 
typing group describes odd case 
explicitly destroys builds cons cells definition group little bit longer lenses seen far 
explain behavior part lens detail 
group acond id acond plunge add rename tmp hoist nonunique fork map group xfork add plunge rename tmp plunge group get component group cases branch acond conditionals 
concrete list empty group behaves branch identity 
concrete list singleton group behaves second branch singleton list adds child leading empty list 
maps singleton lists singleton list containing previous cases apply group behaves third branch 
steps 
renames head element storing away child named tmp 
tail list yielding tree children tmp list empty singleton 
third step recursively groups tail tree list length yields cons cell trees result 
specifically third step final case group splits tree tree single child tree containing tmp children 
recursively groups tail map group 
tree split tmp 
tree singleton list adding child leading empty view tree containing tmp turned head cons cell renaming tmp back xfork trees tmp di dj transformed tree di dj final result obtained merging grouped tail head element 
lens group oblivious putback function symmetric cases corresponding branches acond 
behavior group uses const lens indirectly add semantically 
recall add expands xfork const plunge id 
type annotation add ensures putback function applied trees child leading 
simple argument shows arguments const 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster calculated evaluating compositions reverse order 
behavedness group follows corollary simple compositional argument types lens appearing definition 
lemma behavedness group prove totality lemma corollary increasing chains types ci 
ai 
limit total type want show group 
lemma totality group concatenation concat lens takes tree argument 
maps lists containing sublists ds concatenates single list single element track position list ends second begins 
example tree get component concat produces single list 
conversely putback function takes list containing exactly splits list producing lists containing elements left right respectively 
definition follows 
concat acond wmap const hd fork id hoist rename tmp fork id rename tmp concat plunge concat get direction cases branch acond 
concrete list form concat produces result applying const head hd extract tail 
element concrete list non empty acond selects second branch 
fork splits outermost cons cell 
id lens applied tail component form component form edge labeled clipped hoist yielding children head tail sublist child renamed tmp 
steps yield tree tmp second fork splits tree 
id lens applied tree part tree tmp renaming tmp recursively concatenating result obtain tree combining results single tree obtain list 
result case behavior const depend concrete argument lens oblivious 
acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations putback function oblivious behavior symmetric get function 
behavedness lemma concat follows simple compositional calculation corollary 
lemma behavedness concat totality lemma follows corollary increasing chains types ci 
ai 
limit total type want show concat 
lemma totality concat filter interesting derived list processing lens list filter parameterized sets views assume disjoint non empty 
get direction takes list elements belong projects away belong leaving list containing ds putback direction restores projected away es concrete list 
definition utilizes complex lens combinators wmap forms conditionals recursion yielding lens behaved total lists arbitrary length 
get direction desired behavior list filter brevity call clear 
putback direction things interesting ways restore projected elements concrete list 
lens laws impose constraints behavior 
law forces putback function restore filtered elements list put original concrete list 
example letting elements 
putget law forces putback function include element list resulting concrete list elements ds result restriction es tree filtered concrete tree 
general case list different filtered concrete list freedom behaves 
may selectively restore elements concrete list intuitively add new elements 
second may interleave restored es ds list order long order ds preserved possibilities behavior natural overwrite elements elements element wise runs elements runs appends rest elements runs restores remaining es discards remaining ds satisfy putget 
choices lead specification single step putback part recursively defined lens implementing list empty acm transactions programming languages systems vol 
tbd 
tdb month year 
foster restore es empty empty return cons cells heads return cons cell head head tail result obtained recursing tails type restore head recurse tail translating lens combinators leads definition recursive lens inner filter filters lists containing top level lens list filter handles arbitrary lists ds es 
inner filter ccond tl inner filter wmap id cond const inner filter list filter cond const inner filter 
inner filter list filter choice operator denotes arbitrary element non empty set function usual list filtering function purposes simply assume defined primitive 
implementation list filter expository purposes simplify totality proofs avoid extra bit recursiveness 
function appends arbitrary element right hand list functions applied putback direction cond lens 
behavior get function list filter described follows 
outermost cond selects const lens produces 
cond selects inner filter uses ccond instance test head list test succeeds strips away head tl recurses retains head filters tail wmap 
putback direction outermost cond lens selects const lens concrete argument 
effect restoring es cond instance selects putback inner filter lens concrete argument contains appends dummy value type tail 
dummy value required dealing countable sets finite trees construct poses metaphysical alternatively pass list filter extra argument acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations inner filter expects concrete argument contains intuitively dummy value marks point head placed 
illustrate works step examples detail 
example concrete type type 
write di ej stand elements respectively 
shorten presentation write list filter cond lens defined inner filter example tree concrete tree 
step underline term simplified step 
definition cond tl definition ccond tl tl definition composition tl reducing tl tl wmap id definition ccond tl definition wmap id tl const definition cond tl definition const definition tl 
examples illustrate functions supplied cond lens 
function list empty concrete list 

const definition cond const definition definition const 
function inserts dummy element list filter called non empty list concrete list acm transactions programming languages systems vol 
tbd 
tdb month year 
foster elements assume 
definition cond definition tl definition ccond tl tl definition composition tl reducing tl tl wmap id definition ccond tl definition wmap id tl const definition cond tl definition const definition tl 
behavedness proof inner filter straightforward simply decide type recursive inner filter show assumption bodies lenses type 
list filter recursive behavedness totality lemmas follow straightforwardly types lenses definition 
lemma behavedness 
inner filter list filter totality proof inner filter hand somewhat challenging involving detailed reasoning behavior particular subterms particular conditions 
surprising known difficulties reasoning totality ordinary recursive functional programs 
imagine practice detailed proofs totality undertaken lenses lens programmers probably satisfied assurance easier proofs behavedness plus informal reasoning totality just working functional programmers reasonably happy typechecking plus informal totality arguments functions 
interesting acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations non trivial totality proofs detail see sorts reasoning techniques required 
lemma totality 
inner filter list filter 
extended example bookmark lens section develop larger realistic example programming lens combinators 
example comes demo application data synchronization framework harmony bookmark information diverse browsers including internet explorer mozilla safari synchronized transforming format concrete native representation common form 
show slightly simplified form mozilla lens handles html bookmark format netscape descendants 
path taken bookmark data harmony system pictured follows 
html new html html reader html writer concrete view new concrete view bookmark get view bookmark put view sync new view generic html reader transform html bookmark file isomorphic concrete tree 
concrete tree transformed get direction bookmark lens generic bookmark tree tree synchronized bookmark tree obtained bookmark file yielding new tree transformed new concrete tree passing back putback direction bookmark lens supplying original concrete tree second argument 
new concrete tree written back filesystem html file 
discuss transformations detail 
abstractly type bookmark data name pointing value contents list items 
item link name url folder type bookmark data 
formalizes types 
concretely html see bookmark item represented dt element containing element href attribute gives link url content defines name 
element includes add date acm transactions programming languages systems vol 
tbd 
tdb month year 
foster name val url val link name val contents folder fig 

bookmark types html head title bookmarks title head body bookmarks folder dl dt href www google com add date google dt dd conferences folder dl dt href www cs luc edu icfp add date icfp dt dl dd dl body html fig 

sample bookmarks html tribute chosen reflect form supported browsers 
bookmark folder represented dd element containing header giving folder name followed dl list containing sequence items folder 
html bookmark file follows standard head body form contents body format bookmark folder enclosing dd tag 
html experts note dl dt dd tags legal html 
unfortunate conventions established early versions netscape de facto standard 
generic html reader writer know specifics bookmark format simply transform html syntax trees mechanical way mapping html element named tag attributes attr sub elements tag attr val tag acm transactions programming languages systems vol 
tbd 
tdb month year 
html head title pcdata bookmarks body pcdata bookmarks folder dl dt pcdata google add date href www google com dd pcdata conferences folder dl dt pcdata icfp add date href www cs luc edu icfp val pcdata pcdata val combinators bi directional tree transformations fig 

sample bookmarks concrete tree clink dt clink dt clink add date href pcdata dd dd pcdata dl dl clink html html head title pcdata title head body body fig 

concrete bookmark types tree form attr val tag note sub elements placed list distinguished child named 
preserves ordering original html file 
ordering acm transactions programming languages systems vol 
tbd 
tdb month year 
foster name bookmarks folder contents link name google url www google com folder name conferences folder contents link name icfp url www cs luc edu icfp fig 

sample bookmarks tree sub elements important example important maintain ordering items bookmark folder 
html reader writer generic record ordering original html tree leaving lens applied tree throw away ordering information needed 
leaf html document parsed character data element containing text string str converted tree form pcdata str 
passing html bookmark file shown generic reader yields tree 
shows type concrete bookmark structures 
readability type relies notational shorthand reflects structure encoding html trees 
write tag attr tag tag attr val val 
recall val set values trees single child 
elements attributes degenerates simply tag tag tag 
transformation concrete tree bookmark tree shown implemented means collection lenses shown 
lenses get direction involves stripping various extraneous structure renaming certain branches desired field names conversely putback direction restores original names rebuilds necessary structure 
aid checking behavedness annotate lens source target type writing 
infix notation written source target types conventional looks strange line works multi line displays 
additionally annotate composition suitable cut type writing just maintain invariant interested checking behavedness composite lens source target types determined context annotation allows propagate invariant straightforward check type annotations supplied bookmarks 
omit proof totality seen intricate totality arguments section 
practice composite lenses developed incrementally gradually trees correct shape 
shows process developing acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations link clink hoist clink hd clink hoist pcdata add date val href val rename name name pcdata add date val href val rename href url name pcdata add date val url val prune add date today name pcdata url val wmap name hd pcdata hoist pcdata name val url val folder hoist xfork name hoist rename name pcdata hoist hd dl rename dl contents name pcdata contents wmap name hoist pcdata hd hoist pcdata pcdata contents hoist list map item name val contents item wmap dd folder dt link dd dt rename dd folder folder dt rename dt link bookmarks hoist html hoist tl head title pcdata bookmarks hd hoist body folder fig 

bookmark lenses link lens transforming representation html dt element containing link desired form 
level tree branches relabeled rename undesired structure removed prune hoist hd continued deeper tree wmap 
putback direction link lens restores original names structure automatically composing putback directions constituent lenses acm transactions programming languages systems vol 
tbd 
tdb month year 
foster step lens expression resulting tree get id pcdata google add date href www google com ii hoist pcdata google add date iii hoist hd iv hoist hd hoist hoist hd hoist rename name rename href url vi hoist hd hoist rename name rename href url prune add date today vii hoist hd hoist rename name rename href url prune add date today wmap name hd href www google com pcdata google add date href www google com pcdata google add date href www google com name pcdata google add date url www google com name pcdata google url www google com name pcdata google url www google com viii hoist name google hd hoist rename name rename href url prune add date today url www google com wmap name hd hoist pcdata fig 

building link lens incrementally 
acm transactions programming languages systems vol 
tbd 
tdb month year 
link name google url www google com link name search engine url www google com combinators bi directional tree transformations yields putback 
dt pcdata search engine add date href www google com updated 
fig 

update tree resulting concrete tree link turn 
example shows update tree link 
concrete tree beneath update shows result applying putback updated tree 
putback direction hoist pcdata lens corresponding moving step viii step vii puts updated string tree back concrete tree replacing search engine pcdata search engine 
transition step vi step putback direction prune add date today utilizes concrete tree restore value add date projected away tree 
concrete tree case new bookmark added new tree default argument today fill today date 
formally set lenses parameterized variable today ranges names 
get direction folder lens separates folder name contents stripping undesired structure necessary 
wmap iterate contents 
item lens processes element folder contents element link folder want apply link lens folder lens 
fortunately distinguish contained dd element dt element wmap operator wrap call correct 
rename dd folder dt link 
main lens bookmarks get direction takes concrete bookmark tree strips boilerplate header information combination hoist hd tl invokes folder deal rest 
huge default tree supplied tl lens corresponds head tag html document filtered away bookmark format 
default tree recreate formed head tag missing original concrete tree 

lenses relational data close technical development presenting additional lenses harmony deal preparing relational data trees portions trees consisting lists records synchronization 
lenses constitute full treatment view update relational data may regarded small acm transactions programming languages systems vol 
tbd 
tdb month year 
foster step direction 
particular lens performs transformation related outer join operation database query languages 
flatten critical complex lenses flatten takes ordered list keyed records flattens bush example flatten phone pat url pat com phone chris url org phone pat url pat com phone chris url org importance transformation intended alignment data structurally obvious 
frees synchronization algorithm needing understand data ordered fashion order significant 
synchronization simply proceeds child wise record pat synchronized corresponding record pat replica similarly chris 
replicas happens place chris pat concrete ordered form exactly thing happens 
generally flatten handles concrete lists key appears placing records key order appear concrete view list key view flatten phone pat phone url pat com phone pat url pat com chris phone url org url com phone pat phone url com chris url org putback direction flatten distributes elements list bush concrete list maintaining original concrete positions 
elements concrete ones simply appended resulting concrete list arbitrary order auxiliary function listify listify listify tk tkn listify tk tkn type flatten write set lists singleton views form key value key smallest set trees satisfying 
acm transactions programming languages systems vol 
tbd 
tdb month year 
flatten combinators bi directional tree transformations flatten dom flatten flatten listify flatten flatten dom flatten flatten definition simplified assume ks concrete list pairwise different truly keys 
case view need bush lists simply point directly associated subtree concrete list 
practice assumption reasonable concrete view linearized database ks taken key field record 
type disjoint flatten complicated write express constraint concrete list occurs 
eventually intend implement mechanical typechecker combinators prefer complex definition elementary type 
obvious question variant flatten expressed terms primitive combinators plus recursion list mapping reversing filtering derived forms section 
feel ought possible succeeded doing 
final point flatten obey 
flatten behaved flatten flatten flatten 
left hand side equality right hand side 
pivot lens pivot rearranges structure top tree transforming acm transactions programming languages systems vol 
tbd 
tdb month year 
foster intuitively value represents key rest tree get function pivot returns tree points directly putback function performs reverse transformation ignoring old concrete tree 
pivot heavily harmony instances data synchronized relational sets records concrete format ordered xml 
apply pivot record bring key field outside 
apply flatten smash list keyed records bush indexed keys 
example consider transformation concrete piece data list map pivot name name pat phone url pat com phone pat name chris url pat com phone phone chris url org url org name pat phone pat phone url com url com saw flattened phone pat url pat com phone url com phone chris url org type pivot extend conventions values fact write types 
set names means 
pivot pivot join 
pivot final lens combinator idea daniel inspired full outer join operator databases 
example applying get component join addr phone tree containing collection addresses collection phone numbers keyed names acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations yields tree address phone information collected name 
chris paris addr paris addr kim palo alto chris phone pat philadelphia kim chris phone pat lou addr palo alto addr philadelphia pat phone lou phone note information lost transformation names missing addr phone collection mapped views just phone addr child 
putback direction join performs reverse transformation splitting addr phone information associated name separate collections 
transformation bijective information lost get putback function ignore concrete argument 
join dom dom join dom dom join 
related lens combinators evolved setting harmony data synchronizer 
architecture harmony role lenses building synchronizers various forms data described foster pierce detailed discussion related synchronization 
foundational structures lenses laws new closely related structures studied decades database community 
treatment structures arguably simpler transforming states update functions refined treating behavedness form type assertion 
formulation novel addressing issues totality offering programmers static guarantee lenses fail run time continuity supporting rich variety surface language structures including definition recursion 
idea defining programming languages constructing bi directional transformations various sorts explored previously diverse communities 
appear take totality primary goal connecting language formal semantic foundation choosing primitives combined composite lenses totality guaranteed construction emphasize types compositional reasoning behavedness totality organizing design principle 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster foundations view update foundations view update translation studied intensively database researchers late 
thread closely related semantics lenses section 
discuss main similarities differences classical approaches view update particular dayal bernstein notion correct update translation bancilhon notion update translation constant complement gottlob zicari dynamic views basic view update relational triggers mechanisms offered commercial database systems oracle fogel lane lorentz view update problem concerns translating updates view reasonable updates underlying database 
helpful structure discussion breaking broad problem statement specific questions 
reasonable translation update defined 
second possibility update may reasonable way translating effect underlying database 
third deal possibility reasonable translations choose 
consider questions order 
imagine possible ways assigning precise meaning reasonable update translation fact remarkable degree agreement literature approaches adopting basic positions 
stricter enunciated bancilhon notion complement view include information missing view 
complement fixed exists update database reflects update view leaving complement unmodified translates updates constant complement constant complement approach influenced numerous works area including papers rger 
permissive definition reasonable elegantly formulated gottlob zicari call dynamic views 
general framework identify special cases formally equivalent bancilhon constant complement translators advocate pragmatic grounds dynamic views 
notion lenses adopts permissive attitude reasonable behavior update translation 
modulo small technical refinements correspondence exact pierce schmitt set behaved lenses isomorphic set dynamic views sense gottlob zicari 
set behaved lenses isomorphic set translators constant complement sense bancilhon 
precise need additional condition regarding partiality 
frameworks gottlob zicari formulated terms translating update functions update functions putback functions type lenses translate states update functions putback functions type isomorphic 
frameworks update translators analog putback functions defined particular acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations dayal bernstein seminal theory correct update translation adopts permissive position reasonableness notion exactly performing update corresponds intuitively putget law 
pragmatic tradeoffs perspectives reasonable update translations discussed introduces term closed view stricter constant complement approach open view looser approach adopted dynamic views 
works closed world framework notes choices may pragmatic advantages different situations open world useful users aware really view convenient way edit underlying database closed world preferable users isolated existence underlying database cost offering restricted set possible updates 
formalizes additional condition reasonableness noted dayal bernstein monotonicity update translations sense update adds records view translated just additions database update adds records view translated larger update database similarly deletions 
commercial databases oracle fogel lane lorentz sql server microsoft db international business machines typically provide quite different mechanisms updating views 
simple views defined select project restricted form join key attributes relation subset considered inherently updatable 
notion reasonableness essentially constant complement position 
alternatively programmers support updates arbitrary views adding relational triggers invoked update attempted view execute arbitrary code update underlying database 
case notion reasonableness left entirely programmer 
second question posed section deal possibility reasonable translations update 
simplest response just translation update fail sees effect going unreasonable dayal bernstein approach example 
advantage determine reasonableness case case basis allowing translations usually give reasonable results fail rare conditions 
disadvantage lose ability perform chosen set update functions functions update translators return total functions putback functions hand slightly general defined states return partial functions get functions lenses allowed partial corresponding functions called views frameworks assumed total 
order correspondences tight sets behaved behaved lenses need restricted subsets total suitable sense 
related observation restrict get putback total functions putback total respect update functions lens laws including characterize set isomorphic acm transactions programming languages systems vol 
tbd 
tdb month year 
foster updates view offline need concrete database order tell update going allowed 
possibility restrict set operations just ones guaranteed correspond reasonable translations position taken papers area 
different approach taken restrict view schema arbitrary schema respecting updates guaranteed sense 
third question posed deal possibility may multiple reasonable translations update 
attractive idea restrict set reasonable translations possibility arise translatable update unique translation 
example constant complement approach particular choice complement translation 
additional condition monotonicity ensures updates consisting inserts deletes translation update unique independent choice complement 
possibility place ordering possible translations update choose minimal ordering 
idea plays central role example johnson account view update sketch data model johnson 
buneman khanna tan established variety intractability results problem inferring minimal view updates relational setting query languages include join project union 
key idea allow programmer describe update policy time view definition enriching relational primitives annotations select variety reasonable update policies 
literature programming languages laws similar lens laws somewhat simpler dealing total get putback functions appear oles category state shapes oles hofmann pierce positive subtyping 
languages bi directional transformations level syntax different forms bi directional programming explored surprisingly diverse range communities including programming languages databases program transformation constraint user interfaces quantum computing 
useful way classifying languages shape semantic space transformations live 
identify major classes bi directional languages including form lenses pairing get function type putback function type general get function project away information concrete view restored putback function 
bijective languages putback function simpler type concrete argument refer 
avoid loss information get acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations putback functions form partial bijection reversible languages go step demanding performed function produce output undone applying function reverse working backwards output produce original input 
separate putback function get function constructed step run reverse 
class fundamentally similar meertens formal treatment constraint maintainers constraint user interfaces 
meertens semantic setting general takes get putback relations just functions constraint maintainers symmetric get relates pairs elements putback relates pairs elements idea constraint maintainer forms connection graphical objects screen objects changed user change propagated maintainer object desired relationship objects maintained 
special case get relation function important meertens case composition sense combinator guaranteed preserve behavedness yields essentially behaved lenses 
meertens proposes variety combinators building constraint maintainers analogs lenses directly deal definition recursion combinators support compositional reasoning behavedness 
considers constraint maintainers structured data lists trees adopts different point view focusing constraint maintainers structures directly terms edit scripts produced 
terminology synchronization switches state operation treatment point 
mu hu takeichi injective languages view structure editors adopts similar perspective 
transformations obey law notion behaved transformations informed different goals leading weaker form putget law 
primary concern view view transformations simultaneously restore invariants source view update concrete view 
example view may maintain lists name field element list match name field corresponding element list 
element added list change propagated concrete view add new element second list view 
easy see putget hold view sense modified putback 
similarly assume edits view mark modified fields updated marks removed putback lens computes modifications concrete view change view violate putget 
consequently support invariant preservation view support edit lists transformations obey weaker variant putget described section 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster hu mu takeichi applies bi directional programming language quite closely related design programmable editors structured documents 
mu support preservation local invariants putback direction 
annotating view modification marks assume putback get occurs modification view 
update assumption choose correct inverse lens copied data get direction branch modified time 
consequently putback data modified branch overwrite unmodified branch 
notion behavedness needs weakened described section 
trip system matsuoka uses bidirectional transformations specified collections prolog rules means implementing interfaces application data structures 
get putback components mappings written separately user 
languages bijective transformations active thread program transformation community concerns program inversion inverse computation see example abramov gl ck papers cited 
program inversion dijkstra derives inverse program forward program 
inverse computation mc computes possible input program particular output 
approach inverse computation design languages produce easily invertible expressions example languages express injective functions program trivially invertible 
database community abiteboul cluet milo defined declarative language correspondences parts trees data forest 
turn correspondence rules translate tree format non deterministic prolog computation 
process assumes isomorphism data formats 
authors defined system bi directional transformations concept structuring schemas parse grammars annotated semantic information 
get functions involved parsing consisted unparsing 
avoid ambiguous updates restricted lossless grammars define isomorphism concrete views 
ohori developed statically typed polymorphic record calculus defining views object oriented databases 
specifically restricted fields view updatable allowing ground simple type updated lenses accommodate structural updates 
related idea functional programming community called views wadler extends algebraic pattern matching data types operators :10.1.1.14.3532
languages reversible transformations aware totality compositional reasoning totality taken primary design goals 
languages discussed expectation programmers acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations want transformations total sets inputs get putback functions defined large purpose 
particular expect putback functions accept suitably large set inputs concrete input point languages allow editing view 
quite different class languages designed support reversible computation putback functions applied results corresponding get functions 
goals languages quite different view update intriguing similarities basic approach 
landauer observed non injective functions logically irreversible irreversibility requires generation dissipation heat machine cycle 
bennet demonstrated irreversibility inevitable constructing reversible turing machine showing reversible computers plausible 
baker argued irreversible primitives part problem irreversibility highest levels computer usage cause difficulty due information loss 
consequently advocated design programs conserve information deciding reversibility large programs unsolvable proposed designing languages guaranteed formed programs reversible designing languages primitives reversible combinators preserved reversibility 
considerable body developed ideas mu 
update translation tree views proposals query languages trees xquery xquery unql struql lorel consider view update problem handle update situations concrete views isomorphic 
example davidson studied problem updating relational databases xml solution requires mapping xml view elements objects database updates unambiguous 
tatarinov ives halevy weld described mechanism translating updates xml structures stored underlying relational database 
setting isomorphism concrete relational database xml view updates unambiguous problem choosing efficient way translating xml update sequence relational operations 
view update problem studied context object oriented databases 
school restrict notion views queries preserve object identity 
view update problem greatly simplified setting objects contained view objects database update view directly update objects database 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster update translation relational views research view update translation database literature tended focus existing language defining get functions relational algebra considering infer corresponding putback functions automatically user assistance 
contrast designed new language definitions get putback go hand hand 
approach goes classical relational setting directly transforming updating tree structured data flat relations 
course trees encoded relations clear tree manipulation primitives expressed recursion free relational languages considered previous area 
bohannon pierce vaughan extend framework obtain lenses operate natively relational data bohannon 
syntax lenses classical relational algebra annotated additional syntax specifies update policy syntax identifies single putback function behaved putback functions corresponding get function 
develop semantic type system functional dependencies aid reasoning behavedness 
briefly review relevant research relational setting 
described automated algorithm translating updates views defined relational algebra 
core idea annotate semantic ambiguities arise indicating resolved knowledge underlying database semantic constraints interactions user 
keller catalogued possible strategies handling updates join view showed exactly set translations satisfy small set intuitive criteria 
criteria database side effects update tuples underlying database appear view 
step changes underlying tuple updated 
unnecessary changes operationally equivalent translation performs proper subset translated actions 
replacements simplified avoid changing key avoid changing attributes 
delete insert pairs relation deletions insertions replacements 
criteria apply update translations relational databases state approach means criteria apply 
keller proposed allowing users choose update translator view definition time engaging interactive dialog system answering questions potential sources ambiguity update translation 
building foundation barsalou keller wiederhold described scheme interactively constructing update translators object views relational databases 
medeiros tompa medeiros tompa design tool exploring effects choosing view update policy 
tool shows update acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations translation update requests supplied user considering possible valid concrete states tool predicts desired update fact reflected back view applying translated update concrete database 
miller miller describe clio system managing heterogeneous transformation integration 
clio provides tool visualizing schemas specifying correspondences fields defining mapping schemas viewing sample query results 
consider get direction lenses system somewhat mapping agnostic eventually possible framework clio user interface supporting incremental lens programming 
atzeni torlone atzeni torlone described tool translating views observed translate concrete view meta model shared view gets bi directional transformations pair concrete views 
limited mappings concrete views isomorphic 
complexity bounds studied various versions view update inference problem 
earliest cosmadakis papadimitriou cosmadakis cosmadakis papadimitriou considered view update problem single relation view projection underlying relation showed polynomial time algorithms determining insertions deletions tuple replacements projection view translatable concrete updates 
buneman khanna tan buneman established variety intractability results problem inferring minimal view updates relational setting query languages include join project union 
designers language rowe argued programmers specify translations updates 
provide way ensure consistency get putback directions translations 
problem mentioned connection view update translation incremental view maintenance abiteboul efficiently recalculating view small update underlying concrete view 
phrase view update problem confusingly domain little technical connection problem translating view updates updates underlying concrete structure 

ongoing worked design collection combinators fit sensible way easy program reason 
starting lens laws define reasonable behavior adding type annotations proving lenses total imposed strong constraints design new lenses constraints paradoxically design process easier 
early stages harmony project working constrained design space extremely difficult converge useful set primitive lenses 
understood impose framework type declarations demand compositional reasoning experienced huge increase manageability 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster fig 

web demo safari bookmark lens types helped just finding programming errors derived lenses exposing design mistakes primitives early stage 
interest bi directional tree transformations arose context harmony data synchronization framework 
bookmark synchronizer described section developed prototype synchronizers calendars address books structured text growing library lens programs 
building implementations continues provide valuable stress testing combinators formal foundations 
gives confidence lenses practically useful 
source code lens compiler synchronization engine harmony web page harmony 
system available online web demo screenshot safari component bookmarks portion demo shown 
naturally progress lens combinators raises host challenges 
static analysis urgent automated typechecking 
lens programmers responsibility check behavedness lenses acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations write 
compiler ability perform simple run time checking debugging probe points track stack frames 
simple dynamic techniques proven helpful developing debugging small medium sized lens programs able reason statically program type correct 
fortunately types primitive combinators designed checks local essentially mechanical 
obvious step reformulate type declarations type algebra find mechanical procedure statically checking inferring types 
semantic framework lens types developed key properties tracked types behavedness totality 
properties lenses want track type system including behavedness obliviousness adherence conventions natural subsumption relation different lens types oblivious lens behaved 
basic mechanized type checking lenses place natural step stratify type system facilitate reasoning refined properties lenses 
number interesting questions related static analysis lenses 
instance characterize complexity programs built combinators 
algebraic theory lens combinators underpin optimization lens expressions way relational algebra algebraic theory optimize relational database queries 
example combinators described property map map map run substantially faster 
optimization algebraic theory play crucial role serious implementation effort 
current prototype performs straightforward translation concrete syntax similar combinator library written ocaml 
fast experimenting lens programming malo built interactive programming environment re applies lenses keystroke small demos calendar lenses process thousands appointments minute apply harmony system applications synchronization biological databases require higher throughput 
additional combinators area investigation design additional combinators 
ones described expressive code large number examples intricate structural manipulations list transformations section application transformations ones needed bookmark synchronizer section areas general forms lenses flexible form xfork splitting recombining trees top level names involves deeper structure lenses expressing global transformations trees including analogs database operations join lenses addressing completely different sorts transformations combinators significant processing edge labels include string processing acm transactions programming languages systems vol 
tbd 
tdb month year 
foster arithmetic 
higher level combinators embodying global transformations trees modeled familiar tree transformation notation xslt interesting possibility 
investigate recursion combinators powerful fix come equipped simpler principles reasoning totality 
combinator map iterates width tree 
think possible go define lenses structural recursion trees 
expressiveness generally limits bi directional programming 
expressive combinators defined 
cover known succinctly characterizable classes computations sense set get parts total lenses built combinators coincide class 
put considerable energy questions moment report challenging 
reason questions expressiveness tend trivial answers phrased semantically 
example hard show surjective get function equipped putback function typically form total lens 
concrete domain recursively enumerable putback function computable 
real problems syntactic conveniently pick putback function wanted situation 
lens inference restricted cases may possible build lenses simpler ways explicit programming generating automatically schemas concrete views inference set pairs inputs desired outputs programming example 
facility part programmer wanting add synchronization support new application schema known example leaving just spots fill 
trees intend continue investigating instantiations semantic framework structures trees particular relations establish closer links existing research view update problem databases 
harmony project begun collaboration yang contributed numerous insights generic material generally form 
owen malo collaborated aspects harmony design implementation particular malo compiler programming environment combinators described contributed enormously 
trevor jim provided initial push start project observing step unison file synchronizer trevor designer synchronizing xml 
conversations martin hofmann ives nitin acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations sanjeev khanna william kate moore penny anderson steve zdancewic helped sharpen ideas 
serge abiteboul ives dan suciu phil wadler pointed related 
peter buneman malo owen michael hicks ives trevor jim kate moore norman ramsey wang tan stephen tse yang anonymous referees helpful earlier drafts 
harmony project supported national science foundation itr principles practice synchronization 
nathan foster supported nsf graduate research fellowship 
abiteboul cluet milo 
correspondence translation heterogeneous data 
international conference database theory icdt delphi greece 
abiteboul cluet milo 
logical view structure files 
vldb journal 
abiteboul mchugh vassalos wiener 
incremental maintenance materialized views semistructured data 
proc 
th int 
conf 
large data bases vldb 
abramov gl ck 
universal resolving algorithm inverse computation functional language 
mathematics program construction backhouse oliveira eds 
vol 

springer verlag 
abramov gl ck 
principles inverse computation universal resolving algorithm 
essence computation complexity analysis transformation mogensen schmidt eds 
lecture notes computer science vol 

springer verlag 
atzeni torlone 
management multiple models extensible database design tool 
proceedings edbt lncs 
atzeni torlone 
mdm multiple data model tool management heterogeneous database schemes 
proceedings acm sigmod exhibition section 

baker 
fortune thermodynamics garbage collection 
proc 
int workshop memory management 
st malo france 
springer lncs 
bancilhon 
update semantics relational views 
acm transactions database systems dec 
barsalou keller wiederhold 
updating relational databases object views 
acm sigact sigmod sigart symposium principles database systems denver colorado 

bennet 
logical reversibility computation 
ibm journal research development 
bohannon vaughan pierce 
relational lenses language updateable views 
acm sigact sigmod sigart symposium principles database systems pods chicago illinois 
appear 
davidson 
xml views relational databases 
webdb 
buneman khanna tan 

propagation deletions annotations views 
acm sigact sigmod sigart symposium principles database systems madison wisconsin 

cosmadakis 
translating updates relational data base views 
thesis massachusetts institute technology 
mit lcs tr 
cosmadakis papadimitriou 
updates relational views 
journal acm 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster dayal bernstein 
correct translation update operations relational views 
tods september 
de paula 
updating relational databases xml views 
proc 
rd int 
conf 
information integration webbased applications services 
dijkstra 
program inversion 
program construction international summer school july august marktoberdorf germany bauer broy eds 
lecture notes computer science vol 

springer 
fogel lane 
oracle database administrator guide 
oracle 
foster greenwald pierce schmitt 
exploiting schemas data synchronization 
database programming languages dbpl 

foster pierce schmitt 
harmony programmer manual 
available www seas upenn edu harmony 
gottlob zicari 
properties update semantics consistent views 
acm transactions database systems tods 
harmony 
harmony synchronization framework heterogeneous tree structured data 
www seas upenn edu harmony 

foundations canonical update support closed database views 
international conference database theory icdt paris france 
springer verlag new york new york ny usa 

order theory updates closed database views 

summary information knowledge systems second international symposium pp 

hofmann pierce 
positive subtyping 
acm sigplan sigact symposium principles programming languages popl san francisco california 

full version information computation volume number april 
available university edinburgh technical report ecs lfcs september 
hu mu takeichi 
programmable editor developing structured documents bi directional transformations 
partial evaluation program manipulation pepm 
international business machines 
ibm db universal database administration guide implementation 
international business machines 
johnson 
view updates semantic data modelling paradigm 
adc proceedings th australasian conference database technologies 
ieee computer society washington dc usa 
keller 
algorithms translating view updates database updates views involving selections projections joins 
acm sigact sigmod symposium principles database systems portland oregon 
keller 
choosing view update translator dialog view definition time 
vldb 
landauer 
irreversibility heat generation computing process 
ibm journal research development 
republished ibm jour 
res 
devel jan mar 
rger 
impact constant complement approach view updating 
acm sigact sigmod sigart symposium principles database systems san diego california 
acm 
lorentz 
oracle database sql 
oracle 

relational database view update translation mechanism 
vldb 
matsuoka takahashi kamada yonezawa 
general framework bidirectional translation pictorial data 
acm transactions information systems october 
acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations mccarthy 
inversion functions defined turing machines 
automata studies annals mathematical studies shannon mccarthy eds 
number 
princeton university press 
medeiros tompa 
understanding implications view update policies 
vldb 
meertens 
designing constraint maintainers user interaction 
manuscript 
microsoft 
creating maintaining databases 
microsoft 
miller hernandez haas yan ho fagin popa 
clio project managing heterogeneity 
march 
mu hu takeichi 
algebraic approach bi directional updating 
asian symposium programming languages systems 
mu hu takeichi 
injective language reversible computation 
seventh international conference mathematics program construction mpc 
podelski 
feature automata recognizable sets feature trees 
tapsoft 

ohori 
polymorphic calculus views object sharing 
acm sigact sigmod sigart symposium principles database systems minneapolis minnesota 
oles 
type algebras functor categories block structure 
algebraic methods semantics nivat reynolds eds 
university press 
pierce schmitt 
lenses view update translation 
manuscript available www cis upenn edu harmony 
pierce schmitt greenwald 
bringing harmony optimism synchronization framework heterogeneous tree structured data 
technical report ms cis university pennsylvania 
ms cis 
pierce vouillon 
unison 
formal specification implementation file synchronizer 
tech 
rep ms cis dept computer information science university pennsylvania 
rowe 
data abstractions views updates 
acm sigmod symposium management data sigmod boston massachusetts 
scholl 
updatable views object oriented databases 
proc 
nd intl 
conf 
deductive object oriented databases dood delobel kifer eds 
number 
springer 

view updates seen lens synchronization 
manuscript 
tatarinov ives halevy weld 
updating xml 
acm sigmod symposium management data sigmod santa barbara california 
wadler 
views way pattern matching cohabit data abstraction 
acm symposium principles programming languages popl munich germany 
winskel 
formal semantics programming languages 
mit press 
xquery 
xquery xml query language working draft 
www org tr xquery 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster behavedness totality continuity proofs appendix contains proofs results development foundations lenses representative behavedness totality continuity proofs primitive derived lenses 
lemma injective 
proof 
choose suppose contradiction 
definition rule putget contradiction 
lemma oblivious 
proof 
straightforward 
lemma oblivious bijection proof 
total empty trivially bijective 
non empty choose arbitrary define inverse 
fact id follows directly putget 
fact id follows obliviousness 
lemma partial order lenses 
proof 
show reflexive transitive antisymmetric 
reflexivity 
immediate 
transitivity 
dom dom dom dom dom dom 
dom dom 
antisymmetry 
suppose dom dom dom dom dom dom dom dom 
lemma 
ln 
increasing chain lenses 
lens defined li li li li undefined upper bound chain 
proof 
straightforward 
lemma 
ln 
increasing chain lenses 

increasing chains subsets acm transactions programming languages systems vol 
tbd 
tdb month year 
behavedness commutes limits combinators bi directional tree transformations 
li ci ai implies ln ci ai 
totality commutes limits 
li ci ai implies ln ci ai 
proof 
ln ci ai 
rely property call defined ci li see ck 
corollary exist lj max definition li lj ci 
similarly property defined ai ci li 
see ak ck 
corollary exists lj 
max definition li lj ai ci 
show satisfies typing conditions get put wellbehaved lenses 
choose defined ci li li ai ci li ai conversely defined ai ci li 
li ai ci li ci show satisfies putget 
calculate follows 
suppose done 
ci li ai aj lj max ak ck 
definition lk lk holds lk holds putget 
suppose done 
ai ci li ci cj lj max ak ck 
definition lk lk putget holds lk putget holds show total li 
ci li defined defined 
ai ci li defined defined 
theorem set behaved lenses cpo bottom 
proof 
lens undefined behaved trivially satisfies equations obviously smallest lens 
write lens second 
ln 
increasing chain behaved lenses lemma upper bound behaved 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster corollary suppose continuous function lenses lenses 
implies fix 
suppose 

increasing chains subsets ci ai implies ci ai fix ci ai 
proof 
recall simple induction implication step fact monotonic yields 
fi fix 
note 
simple induction implication step yields ci ai 
fi ci ai 
fix ci ai 
lemma suppose continuous function lenses lenses 
sequence sets total types 
ti 
implies ti 
increasing instance 

fix proof 

increasing instance 

simple induction implication step yields ti 
lemma theorem conclude fix fn lemma lens sets views proof 
implies prove convention 
similarly 
convention dom implies dom dom implies dom required 
lemma behavedness id proof 
get id put id id id id putget id id id lemma totality id proof 
immediate get putback directions id total functions 
lemma behavedness acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations proof 
get defined get get put defined get convention treatment get functions put put assume defined 
definition underlined expression definition putget assume defined 
definition definition putget putget lemma totality proof 
defined totality defined totality 
conversely defined 
defined defined 
lemma continuity continuous functions lenses lenses 
function 
continuous 
proof 
argue 
monotone 
lenses show 
get direction assume defined 
defined acm transactions programming languages systems vol 
tbd 
tdb month year 
foster putback direction assume defined calculate follows 

monotone 
prove continuous 

ln 
increasing chain behaved lenses 
li 
definition li definition li continuity li corollary get li li definition li li continuity li li corollary get max li li monotonicity li li definition li li corollary get definition li definition li continuity li corollary get li li definition li li continuity li li corollary put li li li definition li li li continuity li li li corollary put max li li li monotonicity li li definition li li corollary put 
acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations lenses li li equal 
lemma behavedness doms doms 

wmap proof 
get suppose defined dom 
dependent type dom dom exists non empty subset elements domain dom 
tree dom element set subset shuffle closed 
wmap put dom possibly 
similar argument dom dom wmap assume wmap defined 
wmap wmap wmap dom dom dom putget assume wmap defined 
wmap wmap wmap dom dom dom putget lemma proof 
prove part lemma directly 
calculate definition cons cells set doms possible domains trees 
calculate doms equal 
calculate definition lists set doms domains trees 
calculate doms acm transactions programming languages systems vol 
tbd 
tdb month year 
foster equal 
lemma behavedness list map proof 
note list map fixed point function wmap corollary states assuming prove fix 
assume show type directly type wmap 
write total function names lenses described maps name id show type assumption id vacuously 
correct type 
type wmap requires shuffle closed doms doms 
condition follows lemma second condition immediate doms doms set 
type wmap conclude corollary fix list map 
lemma totality proof 
pick chains types ci ai list map show induction ci ai ci ai calculate type directly type wmap 
write function maps id analyze subcases 
base case vacuously 
acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations trivially shuffle closed doms doms 
type wmap conclude 
induction step assume ci ai 
facts ci type ai ci ai ci ai ci ai induction hypothesis id ci vacuously 
ai shuffle closed equal domains 
type wmap conclude ci ai finishes case inductive proof 
corollary finishes proof 
list map ci ai ci ai lemma behavedness rotate proof 
note rotate fixed point function acond id rename tmp hoist nonunique fork id rename tmp plunge 
assume prove corollary conclude fix rotate calculate type working top 
outermost lens acond instance 
type acond prove branch type id acm transactions programming languages systems vol 
tbd 
tdb month year 
foster immediate type id similarly show second branch type rename tmp hoist nonunique fork id rename tmp plunge type rename rename tmp tmp type hoist nonunique hoist nonunique tmp tmp show fork lens type fork id rename tmp plunge tmp prove arm type second arm type id rename tmp plunge tmp typing follows type id second types rename plunge composition operator type hypothesis 
entire fork type calculated 
type composition operator conclude second branch correct type 
conclude acond lens type corollary fix rotate type 
lemma totality rotate proof 
prove rotate total corollary 
ci ai chains types 
note rotate fixed point function described behavedness proof 
prove induction ci ai ci ai 
acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations base case show type 
outermost lens acond 
prove branch correct type id rename tmp hoist nonunique fork id rename tmp plunge fact immediate type id second holds vacuously 
type acond finishes case 
induction step assume ai ci 
unwind definition revealing acond lens prove branch correct type 
branch calculate type follows id ci di follows type id case 
second branch prove ai di rename tmp hoist nonunique fork id rename tmp plunge ci ai di analyze subcases 
case type empty 
second branch required lens type vacuously 
case type rename rename tmp tmp type hoist nonunique hoist nonunique tmp tmp show composite lens formed lenses desired type show fork id rename tmp plunge tmp acm transactions programming languages systems vol 
tbd 
tdb month year 
foster show fact type fork show branch type id second branch type rename tmp plunge tmp typing follows type id second types rename plunge composition operator type induction hypothesis 
entire fork total type stated 
type composition operator entire second branch correct type calculated 
type acond ci ai finishes case inductive proof 
corollary conclude fix rotate ci ai di di finishes proof 
lemma behavedness list reverse proof 
note list reverse fixed point function wmap rotate 
outline proof proceeds follows 
assume prove corollary conclude fix list reverse outermost lens combinator composition operator 
show wmap instance type rotate type prove facts 
total function names lenses maps name id show id type id assumption id vacuously 
acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations correct type 
type wmap requires shuffle closed doms doms 
follows lemma 
type just proved rotate rotate type composition operator conclude corollary list reverse type lemma totality list reverse proof 
proof outline follows 

note list reverse fixed point function defined proof 
identify increasing chains types ci ai ci ai 
prove ci ai assuming ci ai 
corollary conclude fix ci ai list reverse ci ai increasing chains types ci ai 
prove ci ai implies ci ai induction base case 
outermost lens composition operator 
show wmap instance type rotate type 
prove id vacuously 
correct type 
type wmap requires shuffle closed doms doms 
facts immediate 
total type proved rotate rotate type composition operator conclude 
induction step assume ci ai 
outermost lens composition operator 
di 
prove lens type ci show ci acm transactions programming languages systems vol 
tbd 
tdb month year 
foster argue follows id ci di di type id ci di di ci induction hypothesis id ci di vacuously 
di di ai di correct type 
type wmap requires ci shuffle closed doms ci doms 
facts follow lemma ci 
total type proved rotate rotate di ai type composition operator conclude ci corollary conclude fix list reverse ci ai di di required 
lemma behavedness group proof 
note group fixed point function acond id acond plunge add rename tmp hoist nonunique fork map xfork add plunge rename tmp plunge acm transactions programming languages systems vol 
tbd 
tdb month year 
ai 
combinators bi directional tree transformations shorten proof abbreviations outline proof proceeds follows 
assume prove corollary conclude fix group outermost combinator acond 
show branch correct type 
id type id second show nested acond lens type type acond show branch nested conditional correct type 
branch show plunge add follows types plunge add composition operator 
second branch prove rename tmp hoist nonunique fork map xfork add plunge rename tmp plunge type rename rename tmp tmp type hoist hoist nonunique tmp tmp calculate type fork lens check types arm 
arm map 
prove map acm transactions programming languages systems vol 
tbd 
tdb month year 
foster checking correct type follows assumption vacuously 
types shuffle closed equal domain sets tree types singleton domain 
type map arm fork correct type 
second arm fork show xfork add plunge rename tmp tmp tmp plunge type composition operator composition xfork plunge lenses type tmp putting pieces fork lens type tmp tmp types calculated previously rename hoist nonunique lenses type composition operator second branch nested acond type required 
type outer acond conclude corollary fix group type lemma totality group proof 
proof outline follows 
note group fixed point function defined behavedness proof 
identify increasing chains types ci ai prove acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations ci ai assuming ci ai 
corollary conclude fix ci ai 
abbreviations behavedness proof 
define chains types ci ai prove ci ai implies ci ai induction base case show acond lens type 
required type branch id immediate type id second branch show nested acond lens type holds vacuously 
type acond finishes case 
induction step assume analyze type outermost acond lens 
show branch correct type 
branch calculate required type id ci di di ai odd case holds vacuously 
similarly calculate required type second branch acond lens follows ci di di ai acm transactions programming languages systems vol 
tbd 
tdb month year 
foster lens acond analyze type branches 
branch plunge add calculate required type case immediate lens type vacuously case follows types plunge add composition operator 
second branch show rename tmp hoist nonunique fork map xfork add plunge rename tmp plunge cases 
lens typing vacuously 
calculate types lens composition 
type rename rename tmp tmp type hoist hoist nonunique tmp tmp type fork verify types arm 
arm map 
prove map di di checking correct type acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations equal reduces calculate follows vacuously holds 
di di ci ai di di ci ai facts follow induction hypothesis 
domain tree source target component lens type want show map types shuffle closed equal domain 
type map arm correct type 
second arm prove xfork add plunge rename tmp tmp tmp plunge type plunge 
type composition operator composition xfork plunge lenses type tmp putting pieces fork lens type tmp tmp tmp tmp type composition operator types proved rename hoist nonunique fork second branch inner acond belongs required 
type composition operator ci ai finishes case inductive proof 
corollary conclude fix group ci ai di di completes proof 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster lemma behavedness concat proof 
note concat fixed point function acond wmap const hd fork id hoist rename tmp fork id rename tmp concat plunge 
assume prove corollary conclude fix concat outermost lens acond 
show branch correct type 
wmap const hd total function names lenses maps const hd name id prove correct type follows const type const hd type hd id vacuously 
additionally source targets types cons cells equal domains shuffle closed lemma 
putting facts wmap type calculated 
second branch prove fork id hoist rename tmp fork id rename tmp plunge calculate type fork 
arm type id acm transactions programming languages systems vol 
tbd 
tdb month year 
second arm type combinators bi directional tree transformations hoist rename tmp tmp types id hoist rename composition operator 
facts type fork fork id hoist rename tmp tmp arm fork id second arm rename tmp plunge tmp types rename plunge type induction hypothesis 
type fork fork id rename tmp plunge tmp tmp required 
typing composition operator second branch acond composition forks type specified 
type conclude corollary fix concat type lemma totality concat proof 
proof outline follows 
note concat fixed point function defined behavedness proof 
identify increasing chains types ci ai prove ci ai assuming ci ai 
corollary conclude fix ci ai 
define chains types ci ai prove ci ai implies ci ai induction base case show outermost lens acond type proving branch correct type 
branch calculate required type follows wmap const hd acm transactions programming languages systems vol 
tbd 
tdb month year 
foster total function names lenses maps const hd name id prove correct type follows const type const hd type hd id vacuously 
additionally source targets types cons cells equal sets domains shuffle closed lemma 
putting facts obtain correct type wmap calculated 
second branch prove fork id hoist rename tmp fork id rename tmp plunge holds vacuously 
type acond finishes case 
induction step assume ci ai show ci ai 
prove outermost lens acond type proving branch correct type 
branch calculate required type follows wmap const hd ci di ai di empty typing vacuously holds lens 
second branch prove fork id hoist rename tmp fork id rename tmp plunge ci ai di di calculate type fork directly 
arm type id acm transactions programming languages systems vol 
tbd 
tdb month year 
second arm type combinators bi directional tree transformations hoist rename tmp tmp types id hoist rename composition operator 
facts type fork fork id hoist rename tmp tmp arm fork id second arm rename tmp plunge tmp types rename plunge type induction hypothesis 
type fork fork id rename tmp plunge tmp di di tmp di required 
typing composition operator second branch acond composition forks total type specified 
ci ai finishes case inductive proof 
corollary conclude fix concat ci ai di di finishes proof 
special types conditional lenses section record additional types conditional lenses inhabit need proof list filter defined section total 
material skimmed reading 
lemma presents alternate total type cond target sets types entire cond lens intersected arbitrary set recall standard type ccond takes lenses type conversion functions produces lens type 
type usually type want 
situations reasoning totality need show fixed instance cond different types 
components types may smaller appear literally syntax ccond instance 
new type allows simplify cases considering lens type intersected type want reducing proof burden 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster lemma cond lens type 



cond 
proof 
prove showing cond lens behaved prove showing lens total total 
abbreviate cond get suppose defined 
brevity write cond 
type 
type 
put suppose defined 
cases consider clause definition result case immediate typing case may 
note particular range falls source fourth clause similarly sixth clause 
suppose defined 
type belongs 
third clause definition 
turn equal 
hand type belongs 
second fourth clause definition 
equal 
putget suppose defined 
cases consider 
type putget 

type putget 

type putget 

types putget 

type putget 

types putget 
acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations 
prove total type total showing get putback functions totally defined domains 
show get function totally defined pick follows defined 
similarly follows defined 
total function 
second prove putback function totally defined 
cases corresponding cases definition putback function defined total 
defined total 
defined total 
defined totally defined function type total 
defined total 
defined totally defined function type total 
total function 
conclude cond 
lemma record types conditional lenses special cases conditional selects lens directions 
situations flexible typing rule assumptions branch 
describes ccond instances second branch taken 
lemma false ccond ccond proof 
argue ccond showing respective get putback functions identical 
empty 
ccond similarly 
definition ccond 
ccond behavedness totality ccond lens follow behavedness totality 
particular need assumptions 
note corresponding true rule 
putback direction tree gets sent 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster lemma behavedness 
inner filter list filter proof 
start note inner filter fixed point function lenses lenses ccond tl wmap id cond const shorten proof abbreviate entire cond instance prove type inner filter corollary 
assume show type 
outermost lens ccond combinator 
show branch correct type 
tl wmap id fact follows type tl composition operator hypothesis type prove second type wmap 
total function names lenses maps id name id show follows id type id argument id vacuously 
tail tag show cond lens lens type 
concrete predicate predicates conditional acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations 
branch const type const 
second hypothesis 
check functions correct types facts immediate 
type cond 
additionally doms doms lemma types shuffle closed equal sets domains 
putting facts wmap instance type required 
type conclude 
corollary fix inner filter type 
proof list filter identical proof type inner filter directly hypothesis type lemma totality 
inner filter list filter proof 
note inner filter fixed point function defined behavedness proof 
outline proof goes follows 
start choosing sequence total type sets 
recall ti set total types total type pair 
prove key property apply lens possessing types ti result lens possessing types ti 
choose increasing instance sequence chain 
ti 
argue limit increasing instance total type want 
conclude lemma fixed point lens inner filter type finishing proof 
proceed details 
define sequence pairs total type sets ti acm transactions programming languages systems vol 
tbd 
tdb month year 
foster calculate elements sequence explicitly proof abbreviations presentation 
abbreviate type argument ccond lens type arguments cond lens 
case inductive proof introduce local definitions source target type typing trying establish prove induction fact needed apply lemma total type ti total type ti 
base case show total type singleton set 
immediate lens type induction step prove total type ti assuming total type ti 
pick arbitrary total type ti 
analyze cases 
case recall set ti 
element set empty total type 
immediately lens type finishing case 
case construction form 
verify type ccond observe 
result ccond selects second branch get putback directions 
false typing ccond lemma suffices show second branch type wmap id total function names lenses maps id name id show follows id type id argument id vacuously 
acm transactions programming languages systems vol 
tbd 
tdb month year 

combinators bi directional tree transformations tail tag show conditional lens 
extended typing cond lemma 
standard type cond requires typing branches component lens type corresponding predicate supplied cond 
example standard typing show second branch type 
unfortunately induction hypothesis gives lens types length list bounded 
notice want show cond instance lens type length list lens type standard type cond requires certainly stronger need 
avoid problem lemma requires typing branch component calculated intersection predicates supplied cond type wish show lens 
instance cond lens concrete predicate predicates prove const 
fact follows type const second immediate induction hypothesis 
show functions correct types 
type wmap lemma states shuffle closed wmap id 
false type ccond conclude finishing case 
case form 
outermost lens ccond lens 
typing rule ccond requires prove branches types tl follows type tl induction hypothesis 
acm transactions programming languages systems vol 
tbd 
tdb month year 
foster second branch show wmap id 
type wmap facts lemma implies shuffle closed set domains trees cons cell types identical 
total function names lenses previous case 
prove follows id type id argument id vacuously 
tail tag show conditional lens type 
extended typing cond lemma 
prove const 
fact follows type const second immediate induction hypothesis 
show functions correct types typings immediate 
putting facts wmap id 
type ccond conclude finishing case inductive proof 
conclude lemma show limit increasing instance elements 
defined acm transactions programming languages systems vol 
tbd 
tdb month year 
combinators bi directional tree transformations ti integer division show limit pair total types want prove set contained 
observe find lifting pairs sets obvious way choosing greater maximum number elements number elements number elements inclusion immediate subset lifting pairs pairs sets twice pointwise 
proof list filter identical proof behavedness total type inner filter 
acm transactions programming languages systems vol 
tbd 
tdb month year 
