secure routing structured peer peer overlay networks miguel castro peter druschel ganesh antony rowstron dan wallach microsoft research thomson avenue cambridge cb fb uk com rice university main street ms houston tx usa druschel cs rice 
edu structured peer peer overlay networks provide sub strate construction large scale decentralized applications including distributed storage group com munication content distribution 
overlays highly resilient route messages correctly large fraction nodes crash network partitions 
current overlays secure small fraction malicious nodes prevent correct message delivery overlay 
prob lem particularly serious open peer peer systems diverse autonomous parties pre existing trust relationships wish pool resources 
studies attacks aimed preventing correct message delivery structured peer peer overlays presents defenses attacks 
describe eval techniques allow nodes join overlay maintain routing state forward messages securely presence malicious nodes 
structured peer peer overlays chord pastry tapestry provide self organizing substrate large scale peer peer ap plications :10.1.1.140.3129:10.1.1.28.5987:10.1.1.16.6554:10.1.1.105.3673
systems provide powerful platform construction variety decentralized ser vices including network storage content distribution application level multicast 
structured overlays low applications locate object cally bounded small number network hops re node routing tables small num ber entries 
systems scalable fault tolerant provide effective load balancing 
fully realize potential paradigm overlay networks able support open environment mutually parties conflicting interests allowed join 
closed system sufficiently large scale may un realistic assume participating nodes compromised attackers 
structured overlays robust variety security attacks including case fraction participating nodes act maliciously 
nodes may mis route cor drop messages routing information 
addi may attempt assume identity nodes corrupt delete objects supposed store behalf system 
consider security issues structured overlay networks 
describe attacks mounted overlays applications support design secure techniques thwart attacks 
particular identify se cure key building block combined existing application specific security techniques construct secure decentralized applications struc tured overlays 
secure routing requires secure node identifiers secure routing table maintenance secure message forwarding 
techniques problems show techniques secure routing main tained efficiently despite malicious partic nodes 
show overhead secure routing acceptable proportional frac tion malicious nodes 
rest organized follows 
section gives background structured overlays spec models assumptions defines secure routing 
sections attacks solutions assignment identifiers nodes routing table nance message forwarding respectively 
section explains overhead secure routing min self certifying data 
section discusses related section provides conclu sions 
background models solution section background struc tured overlay protocols chord tapestry pastry 
space limitations prevent giving detailed overview protocol 
describe usenix association th symposium operating systems design implementation model structured overlay networks keep discussion independent particu lar protocol 
concreteness give overview pastry point relevant differences protocols 
describe models assumptions faulty nodes may 
define secure routing outline solution 
analyses tech niques terms model apply structured overlays noted 
security performance techniques fully evaluated con text pastry full evaluation techniques protocols 
routing overlay model define model structured routing overlay designed capture key concepts common overlays chord tapestry pastry 
model participating nodes assigned uni form random identifiers nodelds large id space set bit unsigned integers 
application specific objects assigned unique identifiers called keys selected id space 
key mapped overlay unique live node called key root 
protocol routes messages key associated root 
route messages efficiently node maintains routing table nodeids nodes sociated ip addresses 
node maintains neighbor set consisting number nodes nodeids near current node id space 
nodeid assignment random neighbor set repre sents random sample participating nodes 
fault tolerance application objects stored node overlay 
replica function maps object key set replica keys set replica roots associated replica keys represents random sample participating nodes overlay 
replica root stores copy object 
discuss existing structured overlay proto cols relate model 
pastry pastry nodeids assigned randomly uniform dis tribution circular bit id space 
bit key pastry routes associated message live node nodeld numerically closest key 
pastry node keeps track neighbor set titles applications changes set 
node state purpose routing nodelds keys thought sequence digits base configuration parameter typical value 
node routing table organized rows columns 
entries row routing table con tain ip addresses nodes nodeids share digits node nodeid lth nodeid digit node column row equals column row corresponds value lth digit local node nodeid remains empty 
routing table entry left empty node appropriate nodeid prefix known 
depicts example routing table 
node maintains neighbor set called leaf set 
leaf set set nodes nodeids numerically closest node nodeld larger smaller nodeids cur rent node id value constant nodes overlay typical value approximately log bn number expected nodes overlay 
leaf set ensures reliable message de store replicas application objects 
message routing routing step node seeks forward message node routing table nodeid shares key prefix digit bits longer prefix key shares node id node message forwarded node nodeid shares prefix key long current node numerically closer key node id appropriate node exists routing table neighbor set current node immediate neighbor message final destination 
shows path example message 
anal ysis shows expected number routing hops slightly log bn distribution tight mean 
simulation shows routing highly resilient crash failures 
achieve self organization pastry nodes cally maintain node state routing table neighbor set presence node arrivals node failures 
newly arriving node new nodeid initialize state asking existing pastry node route special message key 
message routed existing node nodeld nu closest obtains neighbor set constructs routing table copying rows routing tables nodes encountered original route announces pres ence initial members neighbor set turn update neighbor sets routing tables 
similarly overlay adapt abrupt node failure exchanging small number messages log bn small number nodes 
th symposium operating systems design implementation usenix association routing table pastry node nodeld 
digits base represents arbitrary suffix 
chord tapestry briefly describe chord tapestry emphasis differences relative pastry 
tapestry similar pastry differs ap proach mapping keys nodes manages replication 
tapestry neighboring nodes names pace aware 
node rout ing table entry node matches key nth digit message forwarded node higher value nth digit modulo routing table 
procedure called gate routing maps keys unique live node node routing tables consistent 
tapestry direct analog neighbor set think lowest populated level tapestry routing table neighbor set 
fault tolerance tapestry replica function produces set random keys yielding set replica roots random points id space 
expected number routing hops tapestry 
chord uses bit circular id space 
pastry chord forwards messages clockwise direction circular id space 
prefix routing table pastry chord nodes maintain routing table con pointers live nodes called finger table 
ith entry finger table node refers live node smallest nodeld clockwise entry points successor subsequent entries refer nodes repeatedly doubling distances node chord maintains pointers predecessor successors nodeld space successor list represents neighbor set model 
pastry chord replica function maps object key nodelds neighbor set key root replicas stored neighbor set key root fault tolerance 
expected cb alc da routing message node lfc key lc 
dots depict live nodes pastry circular namespace 
number routing hops chord 
routes messages dimensional space node maintains routing table entries node reached routing hops average 
entries node routing table refer neighbors dimensional space 
neigh bor table duals routing table neighbor set model 
tapestry replica function produces random keys storing replicas diverse lo cations 
pastry tapestry chord rout ing table grow network size number routing hops grows faster logn case 
tapestry pastry construct overlay internet topology aware manner reduce routing delays net utilization 
protocols routing table entries chosen arbitrarily entire segment nodeid space increasing expected number routing hops 
protocols exploit initializing routing table refer nodes nearby network topology appropriate nodeid pre fix 
greatly facilitates proximity routing :10.1.1.28.5987
systems vulnerable certain attacks shown section 
choice entries chord routing ta tightly constrained 
routing table en tries refer specific neighboring nodes dimen sion chord finger table entries refer specific points nodeid space 
proximity rout ing harder protects nodes attacks exploit attacking nodes proximity victims 
system model system runs set nodes form lay protocols described previous usenix association th symposium operating systems design implementation section 
assume bound frac tion nodes may faulty 
faults modeled constrained collusion byzantine failure model faulty nodes behave arbitrarily may necessarily operating single conspiracy 
set faulty nodes partitioned independent tions disjoint sets size bounded cn 
faulty nodes may collude cause damage system 
model case nodes grouped multi ple independent coalitions setting members coalition corrupt overlay unaware nodes coalitions 
studied behavior system ranging model different failure scenarios 
assume node overlay static ip address contacted 
ignore nodes dynamically assigned ip addresses nodes network address translation boxes firewalls 
overlays extended address concerns focuses traditional network hosts 
nodes communicate normal internet connec tions 
distinguish types communica tion network level nodes communicate directly routing overlay overlay level messages routed overlay protocols discussed previous section 
cryptographic techniques prevent adversaries observing modifying network level communica tion correct nodes 
adversary complete control network level communication nodes controls 
compromise overlay level communication routed faulty node 
adversaries may delay messages correct nodes assume message sent correct node correct destination overlay route faulty nodes delivered time probability pd secure routing define secure routing primitive combined existing techniques construct secure applications structured overlays 
subsequent sec tions show implement secure routing prim itive fault network models de scribed previous section 
routing primitives implemented current struc tured overlays provide best effort service de liver message replica root associated key 
malicious overlay nodes message may dropped corrupted may delivered mali node legitimate replica root 
primitives construct secure appli cations 
example inserting object appli cation ensure replicas placed le diverse replica roots opposed faulty nodes impersonate replica roots 
applications cryptographic methods authenticate objects malicious nodes may corrupt delete deny access supply stale copies replicas object 
address problem define secure routing prim itive 
secure routing primitive ensures non faulty node sends message key message reaches non faulty members set replica roots rk high probability 
rk defined set nodes contains member set replica keys associated live root node responsible replica key 
pastry instance simply set live nodes nodeids numerically closest key 
secure routing ensures message delivered despite nodes may corrupt drop message message delivered legitimate replica roots key despite nodes may attempt impersonate replica root 
secure routing combined existing security techniques safely maintain state structured overlay 
instance self certifying data stored replica roots byzantine fault tolerant repli cation algorithm bft maintain replicated state 
secure routing guarantees replicas initially placed legitimate replica roots lookup message reaches replica exists 
similarly secure routing build se cure services maintaining file metadata user quotas distributed storage utility 
details services scope 
implementing secure routing primitive requires solution problems securely assigning nodeids nodes securely maintaining routing tables securely forwarding messages 
secure nodeid assign ment ensures attacker choose value nodeids assigned nodes attacker controls 
attacker arrange control repli cas object mediate traffic victim node 
secure routing table maintenance ensures frac tion faulty nodes appear routing tables correct nodes exceed average fraction faulty nodes entire overlay 
prevent correct message delivery relatively small number faulty nodes 
secure message forwarding ensures copy message sent key reaches correct replica root key high probability 
sections describe solutions problems 
secure nodeld assignment performance security structured lay networks depend fundamental assumption th symposium operating systems design implementation usenix association uniform random distribution nodeids controlled attacker 
section dis goes wrong attacker violates assumption problem addressed 
attacks attackers choose nodelds compromise integrity structured overlay needing control particularly large fraction nodes 
ex ample attacker may partition pastry chord lay controls complete disjoint neighbor sets 
attackers may target particular victim nodes carefully choosing nodelds 
example may arrange entry victim routing table neighbor set point hostile node chord overlay 
point victim access overlay network completely mediated attacker 
attackers choose nodelds control ac cess target objects 
attacker choose closest nodelds replica keys particular target object controlling replica roots 
result attacker delete corrupt deny access object 
attackers choose nodelds may able mount attacks obtain large number legitimate nodelds easily 
known sybil attack :10.1.1.28.5987:10.1.1.28.5987:10.1.1.17.1073
previous approaches nodeld assignment ei ther assumed nodelds chosen randomly new node compute nodelds hashing ip address node :10.1.1.10.4919:10.1.1.105.3673
approach secure attacker opportunity choose nodelds necessarily random choose ip address hashes desired interval nodeid space 
par ipv deployed modest attackers potential ip addresses disposal nodes network 
solution certified nodelds solution securing assignment nodelds delegate problem central trusted authority 
set trusted certification authorities cas assign nodelds principals sign nodeld cates bind random nodeid public key speaks principal ip address 
cas en sure nodelds chosen randomly id space prevent nodes forging nodelds 
furthermore certificates give overlay public key suitable establishing encrypted channels nodes 
conventional cas offline reduce risk exposing certificate signing keys 
involved regular operation overlay 
nodes valid nodeld certificates join overlay route messages leave repeatedly involvement cas 
ca infrastructure ca public keys known installed part node software done current web browsers 
inclusion ip address certificate deserves explanation 
protocols tapestry pastry measure network delay nodes choose routing table entries minimize delay 
attacker multiple legitimate nodeld certificates freely swap certificates nodes controls able increase fraction attacker nodes target node routing table 
binding nodeld ip address harder attacker move nodelds nodes 
allow multiple nodeld cates ip address ip addresses nodes may change attackers deny service hijacking victim ip addresses 
downside binding nodelds ip addresses node ip address changes result dynamic address assignment host mobility organizational net changes node old certificate nodeld invalid 
systems ip addresses allowed change dynamically nodeld swapping attacks may unavoidable 
certified nodelds nodes fixed nodelds case chord pastry tapestry 
harder secure nodeld assign ment 
nodelds represent zone dimensional space split half new node joins :10.1.1.140.3129:10.1.1.16.6554
nodeld original node nodeld joining node change process 
sybil attacks nodeld assignment ca ensures nodelds chosen randomly important prevent attacker easily obtaining large number nodeld certificates 
solution require attacker pay money certificates credit card suit able mechanism 
solution cost attack grows naturally size network 
exam ple nodeld certificates cost controlling overlay nodes costs cost rises nodes 
cost targeted attacks higher costs expected ob tain closest nodeld particular point id space overlay nodes 
apart making economically expensive fees fund operation cas 
solution bind nodelds real world iden charging money 
practice differ ent forms cas suitable different situations 
identity ca preferred solution vir tual private overlays run organization ready maintains employment membership records strong identity checks 
open internet deploy usenix association th symposium operating systems design implementation ment money ca may suitable avoids complexities authenticating real world identities 
known solutions nodeld assignment effective overlay network small 
small overlay networks require mem bers network trusted cheat 
network reaches critical mass suf hard attacker resources control significant fraction overlay un trusted nodes allowed join 
rejected distributed nodeld generation cas represent points failure vulnerable technical legal attacks 
net works may cumbersome require users spend money prove real world identities 
desirable construct secure overlays requiring centralized authorities fees iden checks 
unfortunately fully decentralized nodeld assignment appears fundamental security tations :10.1.1.28.5987:10.1.1.28.5987:10.1.1.17.1073
methods aware ultimately prevent determined attacker acquiring large collection nodeids 
techniques may able mini mum moderate rate attacker acquire nodelds 
possible solution require prospective nodes solve crypto puzzles gain right nodeld approach taken address number denial service attacks :10.1.1.22.6538
cost solving crypto puzzle accept able slowest legitimate node puzzle hard sufficiently slow attacker access fast machines 
conflict limits ef technique 
completeness briefly describe relatively simple approach generate certified nodelds com pletely distributed fashion crypto puzzles 
idea require new nodes generate key pair property sha hash public key bits zero 
expected number operations re quired generate key pair properties public key cryptography allow nodes se cure hash public key nodeld 
hash computed sha different ini vector md avoid reducing number random bits nodelds 
nodes prove performed required amount nodeld revealing information allow reuse 
value set achieve desired level security 
possible bind ip addresses nodelds avoid attacks overlays exploit network locality 
idea require nodes consume resources der able nodeid ip address 
requiring nodes find string sha sha ipa nodeld bits equal zero 
nodes required pair nodeld accepted 
possible periodically invalidate nodelds having trusted entity broadcast overlay message supplying different initialization vector hash computations 
harder accumulate nodeids time reuse nodeids computed overlay lay 
requires legitimate nodes periodically spend additional time communication maintain membership overlay 
secure routing table maintenance turn attention problem secure rout ing table maintenance 
routing table maintenance mechanisms create routing tables neigh bor sets joining nodes maintain cre ation 
ideally routing table neighbor set average fraction random entries point nodes controlled attacker called bad en tries 
attackers increase fraction bad en tries supplying bad routing updates reduces probability routing successfully replica roots 
preventing attackers choosing nodelds necessary avoid problem sufficient illustrated attacks discussed 
discuss solu tions problem 
attacks attack aimed routing algorithms network proximity information improve routing ef attackers may fake proximity increase fraction bad routing table entries 
example network model assumed allows attacker control communication faulty nodes controls 
correct node sends probe es delay faulty node certain nodeld attacker intercept probe faulty node closest reply 
attacker controls faulty nodes spread internet nodes controls appear close correct nodes increase probability routing 
tack harder maximal fraction colluding nodes small large 
attack ruled restrictive com munication model nodeld certificates bind ip ad dresses nodelds see section 
example faulty nodes observe messages sent ip address attack prevented 
note rogue isp offices world easily perform attack con th symposium operating systems design implementation usenix association figuring routers appropriately 
attack possible form indirection attacker control mobile ipv 
second attack manipulate proximity br mation 
exploits fact hard de termine routing updates legitimate overlay protocols tapestry pastry 
nodes receive routing updates join overlay nodes join fetch routing table rows nodes routing table periodically patch holes re duce hop delays 
systems attackers easily supply routing updates point faulty nodes 
simple attack causes fraction bad rout ing table entries increase bad routing updates propagated 
precisely routing updates correct nodes point faulty node probability probability high routing updates faulty nodes 
correct nodes re updates correct nodes probability faulty nodes probability probability routing table en try faulty update greater effect cascades subsequent update causing fraction faulty entries tend 
systems strong constraints set nodeids fill routing table slot vulnerable attack 
pastry tapestry impose weak con straints top levels routing tables 
flexibility hard determine routing updates allows systems effectively exploit net proximity improve routing performance 
chord impose strong constraints nodelds rout ing table entries need closest nodeids point id space 
hard ex network proximity improve performance security attackers choose nodeids control probability attacker controls nodeid closest point id space solution constrained routing table enable secure routing table maintenance impor tant impose strong constraints set nodeids fill slot routing table 
example entry slot constrained closest nodeld point id space chord 
constraint verified independent net proximity information manipulated attackers 
solution propose uses routing tables exploits network proximity information ef ficient routing pastry tapestry constrains routing table entries chord 
normal operation routing table forward mes sages achieve performance 
second efficient routing technique fails 
test section detect routing fails 
modified pastry solution 
mal locality aware pastry routing table additional constrained pastry routing table 
locality aware routing table node identifier slot level domain contain nodeid shares digits value st digit 
constrained routing table entry con strained point closest nodeid point domain 
define follows shares digits value st digit remaining digits pastry message forwarding works constrained routing table modifications 
true tapestry 
algorithms initialize maintain routing table modified follows 
overlay routing algorithms rely bootstrap node initialize routing state newly joining node 
bootstrap node responsible routing message nodeid joining node key 
bootstrap node faulty completely corrupt view overlay network seen new node 
necessary set diverse bootstrap nodes large ensure high probability correct 
nodeid certificates task choosing set easier attacker forge nodeids 
newly joining node picks set bootstrap nodes asks route nodeid key 
non faulty bootstrap nodes secure forwarding techniques described section obtain neigh bor set joining node 
node collects proposed neighbor sets bootstrap nodes picks closest live nodeids proposed set neighbor set definition closest proto col specific 
locality aware routing table initialized collecting rows nodes route nodeid 
difference routes picks entry minimal network delay set candidates receives routing table slot 
entry constrained routing table initial ized secure forwarding obtain live nodeid closest desired point id space 
similar done chord 
problem quite expensive recall controls number columns routing table tapestry pastry 
reduce overhead take advantage fact induction constrained routing ta nodes neighbor set point entries close desired point collect routing tables nodes neighbor set initialize constrained routing table 
usenix association th symposium operating systems design implementation set candidates receives entry picks nodeid closest desired point en try 
side effect process informs nodes neighbor set arrival 
exploit symmetry constrained routing table inform nodes need update routing tables reflect arrival checks neighbor set set candidates entry determine candi dates update routing table entries point tt informs candidates arrival 
ensure neighbor set stabilization absence new joins leaves informs members neighbor set changes periodically retransmits information receipt acknowledged 
secure message forwarding certified nodelds secure routing table maintenance ensure constrained routing table neighbor set average fraction ran dom entries point nodes controlled attacker 
routing constrained routing table suf ficient attacker reduce probability successful delivery simply forwarding messages algorithm 
attack effective small show 
section describes efficient solution problem 
attacks structured overlays provide primitive send message key 
absence faults message delivered root node key average routing hops 
routing may fail nodes route sender root faulty faulty nodes may simply drop message route message wrong place pretend key root 
probability routing successfully correct nodes fraction nodes faulty independent ofc 
root node key may faulty 
discussed applications tolerate root faults ing information associated key nodes replica roots 
probability routing successfully correct replica root tj value ofh depends overlay log chord log pastry tapestry 
ran simulations pastry validate model 
model predicts probability success slightly lower probability observed simulations number pastry hops slightly log average error 
plots probability routing correct replica pastry computed model differ percentage nodes compromised io io probability routing correct replica 
ent values 
probability drops quite fast increase 
nodes compromised probability successful routing nodes pastry overlay 
pastry tapestry applications reduce number hops increasing value fewer hops increase probability routing correctly 
example probability successful delivery nodes pastry 
increasing increases cost routing table maintenance high probability routing success requires impractically large value chord currently uses fixed results low probability success probability conditions 
solution detect faults diverse routes results show important devise mechanisms route securely 
want secure routing primitive takes message destination key ensures high probability copy message reaches correct replica root key 
question efficiently 
approach route message efficiently ap ply failure test determine routing worked 
expensive redundant routing failure test returns positive 
detail secure rout ing primitive routes message efficiently root destination key locality aware routing ta ble 
collects prospective set replica roots prospective root node applies failure test set 
test negative prospective replica roots accepted correct ones 
pos itive message copies sent diverse routes various replica roots high probability correct replica root reached 
start ing implement failure test 
explain redundant routing rejected alternate ap proach called iterative routing 
th symposium operating systems design implementation usenix association routing test failure test takes key set prospective replica roots key returns negative set roots correct key 
returns positive 
course routing fail sender receiving set prospective replica roots 
sender detects starting timer sends message 
receive response timer expires failure test returns positive triggering redundant routing 
detecting routing failures difficult coalition faulty nodes pretend legitimate replica roots key 
replica roots de structure overlay node nodeid far key rely overlay routing determine correct set replica roots 
mes sage routed faulty node adversary fabri cate credible route replica root set contain nodes controls 
furthermore case adversary just happens legitimately control actual replica roots 
problem common structured overlay protocols 
routing failure test observation average density nodelds unit volume id space greater average density faulty nodeids 
test works comparing density nodelds neighbor set sender den sity nodeids close replica roots tion key 
describe test detail context pastry simplify presentation generalization overlays straightforward 
overlays dis tribute replica keys key uniformly id space check comparing density sender average distance replica key root nodeld 
pastry set replica roots key subset neighbor set key root node called key root set 
correct node computes aver age numerical distance consecutive nodeids neighbor set 
neighbor set contains live nodes nodes closest nodeids nodes closest nodeids greater 
test prospective root neighbor set rn ido idl key checks 
nodeids rn valid nodeid certificate closest nodeid key middle nodeids satisfy definition neighbor set 
average numerical distance urn con nodeids rn satisfies prn rn satisfies conditions test returns negative returns positive 
test inaccurate ways return false positive prospective root neighbor set correct return false negative prospective set incorrect 
call probability false positives proba bility false negatives 
parameter controls trade cz 
intuitively increasing de creases increases 
assuming live nodes nodeids uni distributed id space length distances consecutive nodeids approximately independent exponential random vari ables mean large holds distances consecutive nodeids faulty nodes collude mean 
interesting note independent depend upper bound fraction colluding nodes faulty nodes know identities faulty nodes collude 
assumptions derived expressions compute see detailed derivation appendix nn fo un le le ct 

expressions compute nu 
computed closed form upper bounds exp log yc number distance samples com pute number distance samples com pute urn test analysis shows independent provided test accuracy improved increasing number distance samples compute means 
easy increase number samples compute augment ing mechanism place stabilize neighbor sets 
mechanism propagates nodeids added removed neighbor set members set extended propagate nodeids omit details due tack space 
hard increase number samples compute urn attacks describe 
keep ran simulations evaluate effectiveness routing failure test 
simulations ran sys tem random nodeids 
plots values different values ofy usenix association th symposium operating systems design implementation iiii 
beta upper bound beta predicted beta measured alpha measured alpha predicted 
alpha upper bound gamma routing failure test probability false pos negatives 
predicted curves indistinguishable simulation measure ments upper bounds tight 
number samples sender num ber root neighbors 
shows pre values computed numerically upper bounds values measured simulations 
predicted curves match measured curves exactly upper bounds tight 
minimum error obtained ot equal case 
attacks attacks invalidate analysis weaken routing failure test 
attacker collect nodeid certificates nodes left overlay increase density prospective root neighbor set 
second attacker include nodeids nodes controls nodeids correct nodes prospective root neighbor set 
attacks reduce probability messages reach correct replica roots 
second attack harder counter overlays distribute replica keys id space replica roots detailed knowledge nodeids close replica keys 
attacks avoided having sender con tact prospective root neighbors determine live nodeid certificate omitted prospective root neighbor set 
implement efficiently prospective root returns sender message list nodeid certificates list secure hashes neighbor sets reported prospective root neighbors set nodeids prospective root neighbor set compute hashes list 
sender checks hashes consistent identifiers prospective root neighbors 
sends tive root corresponding neighbor set hash confirmation 
absence faults root neighbors confirm hashes sender perform density corn 
ff 






ol 

percentage nodes compromised routing failure test minimum error probabil ity nodeid suppression attacks varying num ber samples 
parison immediately 
sufficiently large timeout happens probability binomial distribution num ber root neighbors 
faulty nodes tive root neighbor set routing failure test may re quire communication density check run 
studying best strategy deal case 
currently consider test failed prospective root neighbors don agree redundant routing 
may worthwhile investing addi tional communication reverting redundant rout ing 
addition attacks nodeld suppression attack unavoidable significantly de creases accuracy test 
attacker sup press nodeids close sender leaving lay increases 
similarly attacker sup press nodeids root neighbor set increases 
furthermore attacker alternate modes honest nodes way detecting mode operating 
ran simulations compute minimum error prob ability nodeid suppression different values probability error increases fast higher samples sender 
nodeld suppression attack increases minimum probability error large percentages compromised nodes probability error higher samples sender 
figures show results nodeid suppression respectively 
results indicate routing failure test accurate 
fortunately trade crease achieve target redundant rout ing disambiguate false positives 
ran simulations determine minimum achieved target different values dif ferent numbers samples sender 
shows th symposium operating systems design implementation usenix association iii 


percentage nodes compromised routing failure test minimum error probability nodeid suppression attacks varying number samples 




percentage nodes compromised routing failure test probability false posi tives false negative rate nodeld sup pression attacks varying number samples 
results nodeid suppression attacks 
results show test meaningful target nodeld suppression attacks 
setting samples sender enables routing failure test achieve target 
value nodeld suppression attacks increase 
nodeld suppression attacks value redundant routing required time 
redundant routing redundant routing technique invoked routing failure test positive 
idea simply route copies message multiple routes destination key replica roots 
copies message sent diverse routes replica key correct replica roots receive copy message high probability 
issue ensure routes diverse 
approach ask members sender neighbor set forward copies message replica keys 
technique sufficient overlays dis tribute replica keys uniformly id space tapestry 
sufficient overlays choose replica roots neighbor set key root chord pastry routes con verge key root faulty 
overlays developed technique called neighbor set anycast sends copies message des key reach node key root neighbor set 
uses detailed knowledge node portion id space destination key ensure correct replica roots receive copy message 
simplify presentation describe detail redundant routing works pastry 
correct node sends message destination key routing failure test positive sends messages destination key message forwarded different member neighbor set causes messages diverse routes 
messages forwarded constrained routing table include nonce 
correct node receives messages root neighbor set returns nodeld cer nonce signed private key 
collects set nodeld certificates numerically closest left clos est right 
certificates valid signed nonces added marked pending 
timeout replies received sends list nodelds node marked pending marks nodes done 
correct node receives list forwards original message nodes neighbor set list sends confirmation nodes 
may cause steps repeated 
received confirmation nodes step executed times com set replica roots timeout sufficiently large correct nodes correct node half neighbor set probability reaching correct replica roots ofx approximately equal probability anycast messages forwarded route faults correct node key root neighbor set 
assuming independent routes probability bn binomial distribution suc routes trials probability routing suc trial 
counts neighbor set size chosen ensure high probability usenix association th symposium operating systems design implementation extra hop messages routed neighbor set member 
probability success technique depends independent ran simulations determine probability reaching correct replica roots redundant rout ing technique 
plots predicted probabil ity probability measured simulator nodes 
analytic model matches results high success proba bilities 
results show probability success greater 
tech nique combined routing failure test achieve reliability approximately 
ix predicted percentage nodes compromised model simulation results probabil ity reaching correct replica roots redundant routing neighbor set anycast 
studied versions redundant routing achieve probability success perform dif 
example signed nonces ensure nodeid certificates belong live nodes 
nodes avoid signing nonces peri signing clock reading system loosely synchronized clocks signatures nec essary attacker forge ip source addresses 
exploring design space 
example possible improve performance significantly sending anycast messages time ing version routing failure test 
approach reading self certifying data 
putting performance performance pastry secure routing primitive de cost routing failure test cost redundant routing probability redundant routing avoided 
section presents analysis costs probability 
simplicity assume faulty nodes collude number probes redundant routing equal neighbor set size number samples source routing failure tests number nodes overlay 
cost routing failure test returns tive extra round trip delay messages 
total number bytes messages pss signing nodeid certificates bit modulus bit modulus node pub lic keys nodeid certificate size 
extra bandwidth consumed routing test approximately kb kb plus space message headers 
test returns positive adds number messages bytes extra delay timeout period 
cost redundant routing depends value best case occurs root neighbor set added iteration 
case routing adds log extra message delays log messages 
total number bytes messages log pss signing nonces signed nonce size 
extra bandwidth consumed case kb kb plus space message headers 
attack redundant routing adds delay timeout periods expected number extra messages og bn expected number correct nodes root neighbor set added iteration 
expected number messages 
total number bytes sent attack similar best case value sender sends additional bytes nodeid lists number messages increases 
additional kb kb plus space message headers 
probability avoiding redundant routing probability overlay routes message correct replica root probability faulty nodes neighbor set root false positive rate routing failure test 
assumes routing tables average random bad entries 
assumption holds locality aware routing table absence attacks discussed section holds constrained routing table attacks 
model effect attacks locality aware routing table believe hard mount small values 
th symposium operating systems design implementation usenix association 


percentage nodes compromised probability avoiding redundant routing scenarios 
parameters set de security level expressed prob ability correct replica roots receive copy message 
overlay size assignment val ues parameters implicitly define bound bound exceeded drop 
example saw 
redundant routing invoked time value ofy faults 
trade security improved performance increasing reduce decreasing reduce cost routing failure test redundant routing increase example consider scenarios 
plots probability avoiding re routing scenarios different val ues faults redundant routing invoked time scenario 
common case fraction faulty nodes small routing failure test improves performance sig avoiding cost redundant routing 
rejected checked iterative routing alternative redundant routing iterative routing suggested sit morris sender starts looking hop routing table setting variable point node sender asks hop updates point returned value 
process repeated value root destination key 
iterative routing doubles cost relative tra ditional recursive solution may increase proba bility routing successfully allows sender pick alternative hop fails receive entry node 
strong defense attacker provide faulty node hop 
iterative routing augmented hop tests check hop route correct 
hop tests effective systems chord pastry constrained routing table routing table entry contain nodeld closest specific point id space 
mechanism iden tical nodeld density checking routing failure test 
difference av erage distance consecutive nodelds close sender compared distance nodeld routing table entry desired point ran simulations compute false positive false negative rates approach different values rates independent 
example min imum error hop test equal approx samples compute mean sender 
error high single sample destination hop 
simulations indicate iterative lookups pastry constrained routing table hop check improve probability routing successfully 
example probability routing suc samples compute mean sender improves 
adds extra hops route average false positives 
tried increase number samples having sender fetch entire routing table row iterative routing step revealing index required slot 
unfortunately performs worse obtaining single sample attacker com bad routing table entries obtain high average density 
tried combine checked iterative routing redundant routing technique described fore 
checked iterative routing neigh bor set anycast messages hope improved success probability iterative routes result improvement redundant routing recur sive routes 
visible improvement iterative routes independent recursive routes 
conclude routing failure test combined redundant routing effective solution implementing secure routing 
self certifying data secure routing primitive adds significant overhead conventional routing 
section describe secure routing minimized self certifying data 
reliance secure routing reduced stor ing self certifying data overlay data integrity verified client 
allows clients efficient routing request copy object 
usenix association th symposium operating systems design implementation client receives copy object check integrity resort secure routing integrity check fails response timeout period 
self certifying data help inserting new ob jects overlay verifying object stored overlay 
cases secure routing primitive ensure correct replica roots reached 
similarly node joining requires secure rout ing 
self certifying data eliminate overhead secure routing common cases 
self certifying data systems 
example cfs uses cryptographic hash file contents key insertion lookup file past inserts signed files overlay :10.1.1.110.5867:10.1.1.159.9358
technique extended support mutable ob jects strong consistency guarantees 
system past store self certifying group descrip tors identify set hosts responsible ing object 
group descriptors follows 
object creation time owner object uses se cure routing insert group descriptor lay key identifies object 
descriptor contains public keys ip addresses object replica holders signed owner 
replica group run byzantine fault tolerant replication algorithm bfr initial group membership set replica roots associated key 
setting read write operations performed follows client uses efficient routing retrieve group descriptor overlay checks descriptor signature correct uses informa tion descriptor authenticate replica holders invoke replicated operation 
client fails retrieve valid descriptor fails authenticate replica holders uses secure routing primitive obtain correct group descriptor assert ob ject exist 
procedure provides strong con guarantees linearizability reads writes avoiding routing failure test com mon case :10.1.1.110.5867
changing membership group sible replicating object trivial requires securely inserting new group descriptor overlay ensuring clients reliably detect stale group descriptors 
technique allows groups change membership retaining strong consistency guarantees 
group hosts stores replicas object maintains private public key pair sociated group 
group membership changes host new membership generates new key pair group hosts old mem old keys sign new group descriptor containing new keys delete old keys 
operation performed quorum replica holders bound number faulty group members exceeded old replica holders fail able collude pretend current group form quorum necessary authenticate client 
group descriptors authenticated signature chain starts owner signature signatures quorum replicas subse quent membership change 
chain shortened new signature owner alternatively repli cas proactive signature sharing avoid need chaining signatures :10.1.1.1.4196
related sit morris framework perform ing security analyses networks 
adversarial model allows nodes generate packets arbi contents assumes nodes intercept arbitrary traffic 
taxonomy pos sible attacks 
routing layer identify node lookup routing table maintenance network parti virtualization security risks 
dis issues higher level protocols file storage nodes may necessarily maintain necessary invariants storage replication 
dis various classes denial service attacks includ ing rapidly joining leaving network arranging nodes send bulk volumes data overload victim network connection distributed denial service attacks 
dingledine douceur discuss address spoofing attacks :10.1.1.28.5987:10.1.1.28.5987:10.1.1.17.1073
large number potentially ma nodes system trusted central authority certify node identities dif know trust claimed identity somebody commu 
dingledine proposes address vari ous schemes including micro cash allow nodes build reputations 
bellovin identifies number issues napster gnutella 
discusses difficult limit napster gnutella firewalls leak information users consider pri search queries issue network 
bellovin expresses concern gnutella push feature intended firewalls useful distributed denial service attacks 
considers napster centralized architecture secure attacks requires users trust central server 
worthwhile mentioning elegant alternative lution secure routing table maintenance forward ing rejected 
solution replaces node th symposium operating systems design implementation usenix association group diverse replicas suggested lynch 
replicas coordinated state ma chine replication algorithm bft tolerate byzantine faults 
bft replicate arbitrary state ma chines replicate pastry routing ta ble maintenance forwarding protocols 
additionally algorithm provides strong consistency guar overlay routing maintenance 
disadvantages solution expensive faults resilient solution propose 
routing step expensive requires agreement protocol replicas 
replicas geographically dispersed reduce probability correlated faults agreement latency high 
additionally group replicas nodes faulty 
bound number faulty replicas group relatively low probability successful routing 
probability replica group replicas correct fraction nodes pastry overlay compromised denotes binomial distribution successes trials probability success example probability replica group correct nodes compromised replicas 
example probability routing correctly nodes overlay 
structured peer peer overlay networks previ ously assumed fail model nodes node ac network assumed correctly follow protocol 
nodes malicious con spire possible small number nodes compromise overlay applications built 
design analysis techniques secure node joining routing table maintenance message forwarding structured overlays 
techniques provide secure routing combined existing techniques con struct applications robust presence ma participants 
routing failure test allows efficient proximity aware routing common case resorting costly redundant routing tech nique test indicates possible interference attacker 
show secure routing reduced self certifying applica tion data 
techniques allow tolerate malicious nodes providing performance fraction compromised nodes small 
acknowledgments wish robert morris rodrigo rodrigues fa bien petitcolas shepherd david wetherall anonymous referees helpful comments 
wish adam discussions nodeld assignment problem 
sup ported part texas atp nsf ccr 
bellare rogaway 
exact security digital signatures sign rsa rabin 
advances cryptology eurocrypt lecture notes computer sci ence vol 

verlag 

security aspects napster gnutella 
usenix annual conference boston massachusetts june 
invited talk 
miguel castro peter druschel charlie hu antony row 
exploiting network proximity peer peer overlay net works 
technical report msr tr microsoft research may 
miguel castro barbara liskov 
practical byzantine fault tol erance 
proceedings third symposium operating systems design new orleans louisiana february 
ian clarke oskar sandberg brandon wiley theodore hong :10.1.1.10.4919
freenet distributed anonymous information storage retrieval system 
workshop des ign issues anonymity unobservability pages july 
icsi berkeley california 
thomas cormen charles leiserson ronald rivest 
algorithms 
mit electrical engineering computer science series 
mit press 
frank dabek frans kaashoek david karger robert morris ion stoica :10.1.1.159.9358
wide area cooperative storage cfs 
proc 
acm sosp banff canada october 
drew dean adam 
client puzzles pro tls 
loth usenix security symposium pages wash august 
roger dingledine michael freedman david molnar 
ac countability measures peer peer systems 
peer peer harnessing power disruptive technologies 
reilly associates november 
john douceur :10.1.1.28.5987:10.1.1.28.5987:10.1.1.17.1073
sybil attack 
proceedings fi st international workshop peer peer systems iptps cambridge massachusetts march 
herlihy wing 
axioms concurrent objects 
proceedings th acm symposium principles program ming languages pages january 
herzberg jakobsson jarecki krawczyk yung :10.1.1.1.4196
proactive public key signature systems 
proc 
acm conference computers communication security 
ari juels john 
client puzzles cryptographic defense connection depletion attacks 
society symposium network distributed system security ndss pages san diego california february 
nancy lynch malkhi david 
atomic data access content addressable networks 
proceedings st international workshop peer peer systems iptps cambridge massachusetts march 
ralph merkle :10.1.1.22.6538
secure communications insecure chan nels 
communications acm april 
sylvia ratnasamy paul francis mark handley richard karp scott shenker :10.1.1.140.3129:10.1.1.16.6554
scalable content addressable network 
proc 
acm sigcomm san diego august 
usenix association th symposium operating systems design implementation antony rowstron peter druschel :10.1.1.28.5987
pastry scalable dis tributed object location routing large scale peer peer systems 
proc 
ifip acm middleware heidelberg ger november 
antony rowstron peter druschel :10.1.1.110.5867
storage management caching past large scale persistent peer peer storage utility 
proc 
acm sosp banff canada october 
emil sit robert morris 
security considerations peer peer distributed bash tables 
proceedings st inter national workshop peer peer systems cam bridge massachusetts march 
ion stoica robert morris david karger frans kaashoek balakrishnan :10.1.1.105.3673
chord scalable peer peer lookup service lbr applications 
proc 
acm sigcomm san diego california august 
ben zhao john kubiatowicz anthony joseph 
tapestry infrastructure fault resilient wide area location routing 
technical report ucb csd ley april 
appendix appendix describes analytic model probability false positives negatives routing failure test 
assume exist nodeids distributed uniformly random interval length 
large look nodeids closest arbitrarily chosen loca tion interval location nodeids approximated distribution poisson process rate particular inter point distances approximately independent exponential random variables mean din 
ft denote exponential distribution mean pl exponential distribution mean nf fraction faulty nodes 
suppose yl independent identically distributed iid drawn distributions required identify distribution drawn yt yk prospective set replica roots pastry trying determine set correct contains faulty nodes 
optimal hypothesis test comparing hood ratio threshold writing likelihood ratio see equivalent comparing sample mean denoted py threshold situation unknown samples xl 
xn samples collect nodeids close sender id space 
propose hypothesis test choose threshold form constant accept reject hypothesis yi iid comparing threshold 
compute false positive probability false negative probability test 
denote assume loss generality integer 

define zi yi 
xir note zi iid random variables 
sj denote sum lid exponential random variables mean tq din 
event ty event zi zi ot pt zi sk write denote probabilities yi dis tribution 
recalling sj gamma distribution shape parameter scale parameter tl rewrite ct pt le mx gt jo ill 
fit 
un vk change variables npl obtain equality 
expression compute numerically 
derive simple closed form expression upper bound oz 
bound shows decays exponentially sample size fact captures exact exponential rate decay 
arbitrary chernoff bound exp zi rq exp xt exponential distribution mean log log opt rk log tightest upper bound obtained minimising expres sion right pt 
minimum attained substituting yields bound yp exp log derive expression false negative probability similar lines 
lid distribution exponentially distributed mean pe pt interested event pr px hap pens fail reject hypothesis dis tribution 
zi write denote probabilities yi exponential mean pl case yt distribution distribution xi obtain sn sk allows compute numerically combining obtain closed form upper bound th symposium operating systems design implementation usenix association 
