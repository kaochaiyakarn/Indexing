closing semantic web ontologies boris motik riccardo rosati department computer science university manchester manchester uk dipartimento di informatica sistemistica universit di roma la sapienza rome italy march novel formalism hybrid mknf knowledge bases allows seamlessly integrate arbitrary decidable description logic logic programming rules 
obtain powerful hybrid formalism combines best features description logics ability model taxonomic knowledge logic programming ability perform nonmonotonic reasoning 
extending dls unrestricted rules reasoning undecidable 
obtain decidability apply known dl safety restriction rules applicable explicitly named individuals trade expressivity decidability 
reasoning algorithms different fragments logic corresponding complexity results 
results show cases data complexity reasoning hybrid mknf knowledge bases higher data complexity reasoning corresponding fragment logic programming 
contents preliminaries minimal knowledge negation failure 
description logics 
complexity classes 
quantified boolean formulae 
equivalent transformations mknf formulae equivalent formulae 
adding modal operators theory query 
introducing definitions 
reducing entailment unsatisfiability 
extending dls mknf rules mknf rules 
dl safety 
flat vs rules 
relationship dl log 
example reasoning modally closed mknf formulae overview 
general case 
positive case 
positive nondisjunctive case 
stratified nondisjunctive case 
nondisjunctive case 
reasoning hybrid knowledge bases general case 
positive case 
positive nondisjunctive case 
stratified cases 
data complexity positive nondisjunctive programs 
stratified nondisjunctive programs 
nondisjunctive programs 
positive programs 
general programs 
reusing qbf solvers reasoning mknf obtaining propositional mknf formula 
reducing flat propositional mknf formula qbf past couple years significant body semantic web research devoted defining suitable language ontology modeling 
endeavor resulted web ontology language owl 
owl description logics dls family knowledge representation formalisms order logic exhibiting understood computational properties 
experience gained building practical applications revealed shortcomings owl 
example owl allow defining integrity constraints closed world reasoning 
rule formalisms grounded logic programming repeatedly proposed possible solution adding rule layer top owl nowadays seen important task development semantic web language stack 
logic minimal knowledge negation failure mknf expressive formalism allows integrate open closed world reasoning unifying framework 
generalizes important nonmonotonic formalisms logic programming stable model semantics default logic fixed universe note version default logic different original version reiter 
mknf unifying framework novel formalism hybrid mknf knowledge bases allows extend arbitrary decidable order fragment rules style logic programming 
formalism generalizes existing known approaches extending dls order rules semantic web rule language swrl 
combinations dls rules known undecidable dls achieve decidability apply known concept dl safety trade expressivity decidability 
furthermore employ special approach dealing uniqueness individuals bridging gap logic programs usually assume unique name assumption una dls usually assume 
approach fully compatible logic programming hand dls hand 
algorithms checking entailment different classes mknf knowledge bases 
apart algorithm full formalism additionally consider cases rules positive positive nondisjunctive stratified nondisjunctive nondisjunctive 
analyze data complexity algorithms show combination dl disjunctive datalog rules data complexity disjunctive datalog entailment checking dl data complete conp case expressive dls shiq 
variants algorithm intractable respect data complexity implementing requires advanced heuristic techniques 
similar techniques developed reasoning quanti fied boolean formulae qbf implemented qbf solvers 
enable reusing techniques case dl shiq way encode algorithms quantified boolean formula 
encoding reuses known technique reducing shiq knowledge base positive disjunctive datalog program 
preliminaries minimal knowledge negation failure logic minimal knowledge negation failure mknf extension order logic modal operators strongly related logic minimal belief negation failure 
syntax mknf formulae defined grammar ti order terms predicate 
tn usual 
tn order atom furthermore true false shortcuts respectively 
formula form called modal atom formula form called modal atom collectively modal atoms called modal atoms 
occurrence modal atom mknf formula strict atom occur scope modal operator 
mknf formula sentence free variables ground contain variables modally closed modal operators applied sentences subjective order atoms occur scope modal operator flat occurrences modal atoms strict subjective positive contain occurrences objective contain modal operators 

tn xn denote formula obtained simultaneously replacing free variables xi terms ti denote number symbols needed encode 
call mknf formula form rule generalizes notion rule disjunctive logic programs interpreted stable model semantics 
hk 

set modal atoms head hi called rule head set modal atoms body positive body set modal atoms body called negative body 
say rule nondisjunctive simplify notation denote set head head returns head atom singleton set 
note common case rules atoms head captured nondisjunctive rule head atom false 
call rule fact 
rule safe variable occurs atom body 
flat modally closed mknf formula form ri ri rules called mknf program 
analogy logic programming identify set rules ri write denote conjunct 
mknf program nondisjunctive safe rules nondisjunctive safe 
employ standard names semantics mknf assume apart constants occurring formulae signature contains countably infinite supply constants occurring formulae 
denote herbrand universe signature call domain set 
mknf structure triple herbrand order interpretation nonempty sets herbrand order interpretations satisfying property equality predicate interpreted interpretation congruence relation reflexive symmetric transitive allows replace equals equals see chapter depth discussion issues 
satisfiability mknf sentences mknf structure defined follows 
tn iff 
tn true iff iff iff iff iff mknf interpretation nonempty set herbrand order interpretations 
model closed mknf formula written name suggests models obtained interpreting order modal formula modal logic shortcut 
semantics monotonic nonmonotonic semantics mknf obtained introducing preference relation models 
particular mknf interpretation mknf model model ii mknf interpretation mknf formula valid mknf structure mknf satisfiable mknf model exists mknf unsatisfiable 
mknf formulae mknf mknf satisfiable mknf satisfiable 
furthermore mknf entails written mknf mknf model un satisfiability entailment written defined analogously considering mknf models 
validity defined respect theory sense distinguish mknf cases 
couple comments regarding definitions order 
differences definition mknf 
approach mknf models defined respect countably infinite domain set 
contrast approach lifschitz domain set necessarily infinite set corresponds oneto special set constants called names 
constants indented modeler introduced define semantics quantifiers 
interpretations mknf model defined respect domain set different mknf models different domain sets 
difference approach interpreted congruence relation lifschitz provides true equality interpreted identity 
discuss differences affect consequences logic 
standard names assumption 

original semantics mknf consider mknf interpretation containing order interpretation interpreted name order interpretation interpreted name different 
contain quantifiers obviously 
contrary satisfy variable replaced name hold order models clearly mknf 
corrected rigid designator including interpreted order interpretations name mknf 
data management applications constants typically assumed rigid incorporate rigidity directly semantics mknf identifying names elements herbrand universe 
finite vs infinite models 
consider herbrand models order formulae long ensure herbrand universe large finite formulae suffices set constants signature countably infinite 
important side effect consider infinite models ordinary order logic similar approaches employed new constants called parameters 
names parameters intended modeler 
approaches interpretations defined domain set satisfy preference semantics mknf extend new order interpretation having new domain set isomorphic existing interpretation version mknf lifschitz consider finite models 
note affect order formulae equality equality free order formula satisfiable arbitrary model satisfiable herbrand model signature countably infinite supply constants occurring theorem 
fitting calls models herbrand models parameters 
note formula need skolemized 
equality distinguish models arbitrary interpretation domain consequently distinguish finite infinite models 
treatment equality 
considering herbrand models impossible interpret equality identity syntactically different constants automatically interpreted different objects property known unique names assumption una 
allow equality reasoning despite considering herbrand models provide special predicate interpret congruence relation 
interpretation weaker affect consequences order formulae formula order equality satisfiable model interpreted identity satisfiable model interpreted congruence relation theorem 
order logic distinguish types models 
combining discussion previous paragraph arbitrary models true equality herbrand models equality interpreted congruence relation 
illustrate example 
standard interpretation equality formula constrains domain elements 
interpret model domain interpretation domain contains infinitely elements interpretation partitions equivalence classes 
object equivalence class distinguished objects class name 
change order consequences argue treatment complicated aesthetically unsatisfactory 
discuss treatment yields intuitive nonmonotonic consequences 
equality nonmonotonic negation 
nonmonotonic reasoning considering non herbrand models produces unintuitive consequences 
example 
formula paraphrased able derive formula provides evidence intuitively expect unsatisfiable 
original semantics mknf mknf model take domain set contain name interpret satisfied model clearly satisfies preference semantics mknf 
original semantics mknf entails fact interpretation domain contains element 
consider quite unintuitive want interpret constraint side effects 
similar problems occur nonmonotonic formalisms logic programming formalisms routinely consider herbrand models 
approach get unintuitive consequences explicit evidence unsatisfiable semantics 
consider congruence properties ensure model holds satisfiable mknf model containing order interpretations summary 
version mknf related original mknf way order logic herbrand models related ordinary order logic arbitrary models 
strictly speaking consider order formula rest consider models domain set 
explained previous paragraphs matter additionally consider ordinary order models 
need check satisfiability order formula equivalently consider herbrand arbitrary models 
sections stress difference herbrand arbitrary models 
description logics mknf rules defined section combined fragments order logic dl 
high level overview syntax semantics description logics going details formal definition please refer 
building blocks dl knowledge bases concepts classes representing sets objects roles properties representing relationships objects individuals representing specific objects 
concepts person called atomic 
concept constructors construct complex concepts describe conditions concept membership 
example concept person describes objects related role object concept person 
expressive dls provide rich set concept constructors boolean connectives existential universal quantification number restrictions 
dl knowledge base typically consists tbox abox tbox contains axioms general structure allowed worlds purpose akin database schema 
example tbox axiom states instance concept person related role instance concept person 
abox contains axioms describing structure particular worlds 
example abox axiom states peter person states paul brother peter 
person person person peter peter paul dl knowledge base semantics translating firstorder logic equality 
atomic concepts translated unary predicates complex concepts formulae free variable roles binary predicates 
example axiom represented order formula person person basic reasoning problems owl checking individual instance concept written concept subsumed concept written 
approach applicable description logic dl fulfills requirements knowledge base dl translated formula function free order logic equality ii dl supports aboxes assertions form 
predicate ai constants dl iii checking satisfiability checking entailments form form atomic concept decidable 
checking entailment role equality atoms traditionally considered dl research reduced checking entailment atomic concepts known pseudo nominals technique pa pb new concepts occurring iff pb pb iff pa pb pa pb iff pa pb pa pb inferences supported dls support aboxes approach applicable wide range dls 
complexity classes standard definitions complexity classes 
complexity classes denote class problems solved oracle problems polynomial hierarchy defined inductively follows np pk table equivalences mknf formulae 



true true true false 
false false false true note arbitrary mknf formulae subjective mknf formula 
quantified boolean formulae quantified boolean formulae qbf extend propositional formulae existential universal quantification propositional variables 
firstorder logic quantified boolean formula closed propositional variable occurs scope quantifier 
semantics propositional connectives defined usual 
quantifiers closed formula evaluates true false true evaluates true similarly closed formula evaluates true false true evaluates true 
closed formula evaluates true said valid 
deciding validity arbitrary quantified boolean formula pspace complete problem prenex normal form alterations quantifier prefixes deciding validity th level polynomial hierarchy 
precisely quantifier prefix problem complete quantifier prefix problem complete 
equivalent transformations mknf formulae section transformations transform certain mknf formulae equivalent simpler ones 
simplification rules extensively sections 
results section hold general order mknf formulae 
equivalent formulae easy see de morgan laws order logic hold mknf formulae 
theorem introduces equivalences concerning modal operators 
theorem 
equivalences table valid 
proof 
consider mknf structure 
formula evaluated value evaluated equivalences right column dual ones left column proved way replacing prove just equivalences left column 
implies implies implies 
conversely implies implies 
subjective value depend assume 


conversely assume 

implies 
equivalence follows considerations iff iff iff iff validity follows trivially definition note equivalences derived equivalence true 
furthermore dually equivalence show valid 
consider equivalence equivalence stronger allows delete outer replace formulae equivalent ones changing set models formula 
lemma 
valid equivalence mknf formula containing subformula formula obtained replacing occurrence 
mknf structure 
proof 
proof straightforward induction structure 
equivalences subsection possible eliminate nesting modalities propositional formula 
example formula equivalent allows distributed resulting applying second conjunct obtain 
observe transformation requires translating formula outer conjunctive normal form 
translation cnf incur exponential increase formula size explains difference complexity checking satisfiability flat formulae reported 
note propositional mknf formulae reduced flat ones 
example outer removed inner formula subjective furthermore distributed existential quantifier strategy previous paragraph applicable 
adding modal operators theory query theorem shows introduced front theory changing models theory satisfied theorem 
closed mknf formula mknf interpretation 
mknf model mknf model 
proof 
direction observe implies definition semantics furthermore implies 
mknf model 
direction analogous 
similarly introduce front query affecting entailment theorem 
arbitrary closed mknf formulae 
mknf mknf 
proof 
mknf mknf model clearly 
converse direction analogous 
introducing definitions order logic common practice define names complex subformulae axiom equivalent allowing formulae 
observed introducing definitions mknf change semantics mknf theory 
consider formula clearly model mknf introducing new name mknf formula obtain formula 
analogy order logic expect mknf expect theorems containing name affected 
mknf model mknf equivalences previous subsection help explain phenomenon 
theorem transform expanded simplified 
clearly minimal models holds holds 
succinctly put introducing formula introduces side effect disjunction way intuitively understand issue observe implication kind directional rule allows conclude conclude understood definition order sense 
definitions introduced purely order formulae shown lemma lemma 
mknf formula order formula set free variables predicate occurring 
mknf model corresponds oneto mknf model obtained interpreting atom exactly 
proof 
follows trivially fact contain modal operators 
clear synonym possible replace occurrence changing set mknf models unfortunately new names introduced subjective formulae 
consider propositional mknf formula easy verify mknf model 
introduce new name subformula models 
obtained new symbol completely unrelated mknf projecting reducing entailment unsatisfiability case nonmonotonic formalisms checking entailment mknf reduced satisfiability known transformation 
closed mknf formulae mknf mknf satisfiable converse hold 
example true clearly mknf model containing order interpretations mknf model 
intuitively problem arises adding known model 
shown reduce checking entailment subjective mknf formulae mknf satisfiability 
sake completeness include result 
theorem 
arbitrary closed mknf formula subjective closed mknf formula 
mknf mknf unsatisfiable mknf formula obtained replacing occurrence 
proof 
assume mknf mknf model 
value interpreted set interpretations implies 
assumption 
clearly mknf model 
assume mknf satisfiable mknf model subjective contain occurrences value depend 
mknf model 
furthermore truth value interpreted set interpretations subjective implies 
mknf model satisfy mknf 
extending dls mknf rules define formalism hybrid mknf knowledge bases allows extend description logic dl nonmonotonic rules 
introduce formalism steps 
section definition generalizes currently known proposals combining dls rules 
section syntactic restriction necessary formalism decidable 
section show loss generality consider flat rules 
mknf rules define general variant mknf rules 
definition 
dl description logic dl dl knowledge base 
signature containing equality predicate atomic concepts unary predicates atomic roles binary predicates individuals constants 
order atom 
tn occurs called dl atom atoms called non dl atoms 
denote arbitrary order function free atoms signature hi denote atoms form bi denote atoms form mknf rule form 
hn 
bm usual set atoms hi called rule head set atoms bi called rule body 
mknf rule atoms modal nondisjunctive mknf rule mknf rule called fact 
variable rule occurs body atom rule safe 
program finite set mknf rules 
hybrid mknf knowledge base pair 
size written number symbols needed encode ok denote set constants occurring contain constant add arbitrary constant ok 
usual write define semantics mapping order mknf 
definition 
hybrid mknf knowledge base translation order logic equality 
mknf rule vector variables occurring rule 
extend follows 
hn 
bm hybrid mknf knowledge base satisfiable mknf model exists 
furthermore entails mknf formula written mknf 
say mknf knowledge base subjective flat property holds furthermore nondisjunctive rules nondisjunctive 
couple comments previous definition order 
compatibility dls 
rules contain atoms semantics essentially order equivalences section formula transformed formula entails formulae order formula 
semantics hybrid mknf knowledge bases conservative extension standard order semantics 
compatibility logic programming 
shown stable model disjunctive logic program rules form 
hk 

corresponds mknf model mknf program obtained replacing rule rule form 
semantics hybrid mknf knowledge bases corresponds stable model semantics disjunctive logic programs 
stable model semantics generalizes semantics stratified positive programs approach generalizes known approaches logic programming 
approach currently capture founded semantics shall try address restriction 
relationship rule formalisms 
approach generalizes existing approaches extending dls order rules carin log dl safe rules semantic web rule language swrl 
contains atoms equivalent set swrl rules multiple head atoms interpreted disjunctively 
show section hybrid mknf knowledge bases generalize significant portion dl log family proposals integrating dls rules 
related formalism disjunctive datalog rules contain special atoms interpreted queries dl knowledge base 
semantics hybrid knowledge bases defined generalization answer set semantics 
semantics nonstandard correspond standard semantics order extensions dls rules rules contain atoms negation failure 
relationship nonmonotonic extensions dls 
authors extend dl alc modal operators interpreted mknf semantics 
allows nonmonotonic reasoning existentially introduced individuals usage modal operators restricted significantly obtain decidable logic 
furthermore approach allow general rules 
approach uses una provide equality reasoning 
extension dls default rules achieve decidability authors allow defaults applied named individuals 
approach allows model defaults explicitly named individuals 
approach implements original reiter semantics defaults approach compatible default logic fixed universe 
approach extending dls circumscription 
nonmonotonic extensions dls approach allows nonmonotonic reasoning unnamed individuals achieve decidability nonmonotonic reasoning allowed unary predicates 
dl safety turn attention decidability reasoning hybrid mknf knowledge bases 
clearly reasoning decidable description logic dl decidable 
known combining arbitrary order rules decidable description logics containing just basic dl constructs leads undecidability satisfiability problem 
mknf rules correspond arbitrary order rules result implies undecidability checking satisfiability mknf knowledge base wide range languages dl 
consider case mknf rules flat 
rules semantically equivalent order rules considered undecidability result apply directly 
case reasoning undecidable theorem 
safe hybrid mknf knowledge base ground atom checking undecidable dl allows express axiom proof 
adapt reduction problem turing machine entailment problem 
loss generality assume starts execution empty tape 
problem undecidable implies theorem 
turing machine construct hybrid mknf knowledge base kt follows 
dl knowledge base ot kt contains dl axiom integer furthermore add mknf program pt kt rules false integer succ remaining rules constructed way 
sake completeness repeat construction 
short predicate lt order elements integer concept predicate state denote time state head position predicate tape denote time tape position contains symbol represent states qi including initial state halting state qh symbols empty symbol tape boundary symbol integer constants 
show remaining rules pt reduction uses binary predicates encode state head position single ternary predicate presentation compact 
rules axiomatize lt transitive closure succ lt succ lt succ succ rules specify initial configuration integer state tape tape lt encode transition 
rule updates symbol position head second rule added moves head left third rule added moves head right fourth rule added change head position tape state tape succ state state tape succ succ state state tape succ succ state state tape succ rules copy symbols tape time instant left right head tape state succ lt tape tape state succ lt tape rule detects halting condition halt state qh show kt encodes execution formally halt empty string kt halt 
assume execution halt 
construct model starting elements connected succ role 
elements represent time instants positions tape 
furthermore state execution state head position time respectively 
tape tape contains time symbol position easy see mknf model kt halt 
assume kt mknf model halt 
extension integer equal rule identifies objects exists succ rule ensures successor exists 
starting model contains infinite sequence objects connected succ 
furthermore rules encode movements run empty string extracted halt run halt 
proof essentially differs aspect 
infinite sequence integers obtained integer succ integer 
case produce desired effect existentially introduced individuals differ interpretation mknf model succ individuals 
obtain required sequence employ trick concept integer equivalent ensures integer 
entire domain visible rules pt employ connect individuals appropriately succ rules 
rule safe syntactically integer applicable domain safe semantically 
obtain decidability apply known concept dl safety 
intuitively restriction rules applicable individuals known abox 
discuss practical consequences dl safety section means example 
definition 
mknf rule dl safe variable occurs non dl atom occurring body hybrid mknf knowledge base dl safe rules dl safe 
due dl safety hybrid mknf knowledge base hybrid knowledge base kg obtained replacing mknf rules set ground instances 
definition 
hybrid mknf knowledge base 
knowledge base kg pg pg obtained replacing rule variables constants ok possible ways called ground instantiation lemma 
dl safe hybrid mknf knowledge base kg ground instantiation ground mknf formula 
kg 
proof 
prove lemma showing contrapositive statement mknf kg mknf 
direction mknf model 
ground non dl atom containing constant ok assume contrary consider interpretation obtained adding ground non dl atom containing constant ok interpretation coincides interpretation atoms clearly consider rule ground instance rg 
rg contains constants ok rg values ground non dl atoms containing constants ok coincide rg dl safe contains atom containing constant ok rg 
kb contradicts assumption mknf model 
contains constant ok immediately implies mknf model kg kg mknf 
direction mknf model kg 
clearly prove just need show consider ground instance rg rg contains constants ok rg 
dl safe constant ok occurs ground non dl atom occurring body rg 
assume consider obtained just changing truth value kg contain constant ok kg contradicts assumption mknf model kg 
rg consequently 
furthermore assume mknf interpretation exists 
clearly kg contradicts assumption mknf model kg 
mknf model 
mknf 
lemma holds ground rules respect herbrand universe assume description logic dl corresponds function free fragment order logic 
herbrand universe infinite introduced just function symbol 
kg infinite grounding preprocessing step reasoning algorithms section 
strictly speaking definition generalize notion firstorder dl safety requires variable rule occur atom rule body 
definition simplify presentation 
order dl safe rules considered part dl knowledge base interested nonmonotonic reasoning need rules modal operators head body 
flat vs rules definition allows mknf rule contain modal atoms 
way obtain formalism generalizes known approaches combining dls rules 
show consider flat rules loss generality 
rule written form hi hj bk bm bn kg mknf equivalent kg rules interpreted conjunctively outer occurrence distributed rule 
rule equivalent formula hi hj bk bm bn switch order produces formula hi hj bk bm bn extract objective part formula outside outer occurrence obtain formula hi bk hj bm bn introduce new name hi bk obtain flat mknf rule order definition hj bm bn hi bk definition order formula assuming allowed fragment dl added dl knowledge base practical cases rule dl safe ground formula hi bk ground interpreted order dl safe rule 
known order dl safe rules combined description logic losing decidability straightforward way 
transformation allows reduce reasoning dl safe rules description logic dl reasoning flat dl safe rules description logic dl obtained extending dl order dl safe rules 
decision procedure dl obtained straightforward way decision procedure dl transformation allows consider flat rules sections 
transformation shows dl safety requires variable occur body atom 
variable occurs atom atom occur disjunction hi bk shown previously removed rule 
relationship dl log approaches extending dls nonmonotonic rules generalized formalism called dl log 
show hybrid mknf knowledge bases able capture semantics dl log knowledge bases 
self contained recall definition dl log 
signature dl log knowledge base divided set concept names role names datalog predicates predicates called dl predicates predicates called non dl predicates 
atoms dl log function free order atoms defined usual called dl atoms non dl atoms depending type predicate 
dl log knowledge base consists description logic knowledge base expressed order fragment dl set rules form 
pn 
rm 
sk 
uh atoms pi allowed dl non dl atoms atoms ri ui required non dl atoms atoms si required dl atoms 
dl log generalizes known order extensions dls rules carin reasoning trivially undecidable 
obtain decidability author introduces notion weak safety rule form weakly safe variable atom pi occurs non dl atoms ri 
allow comparing dl log hybrid mknf knowledge bases extend definition dl log rules rule form dl safe variable occurs non dl atoms ri 
clearly weak safety generalizes notion dl safety 
mknf knowledge bases dl log employs standard names assumption definition semantics interpretation corresponds countably infinite set constants signature 
presentation explicit treatment equality achieve compatibility standard semantics dls necessary adopt approach similar treat dl predicate interpreted congruence model 
dl log comes types semantics 
order fol semantics obtained interpreting rule form order implication set free variables rule 
pn 
rm 
sk 
uh define nonmonotonic nm semantics standard definitions datalog programs needed 
pg ground datalog program interpretation gl reduct pg respect written gl pg obtained transforming rule pg follows delete contains negated atom bi bi delete negated body atoms bi bi 
interpretation model ground datalog program pg atoms satisfies rules pg interpreted implications minimal model interpretation model pg 
ground datalog program pg possibly containing atoms interpretation stable model minimal model gl pg 
define nm semantics dl log 
gr ground program obtained replacing rule variables constants possible ways 
interpretation set predicates interpretation obtained restricting predicates furthermore pg ground program pg projection pg respect equal set rules obtained transforming rule pg follows delete head atom hi predicate exists hi delete head atom hi predicate hi delete body atom bi predicate exists bi delete body atom bi predicate hi 
nm model dl log knowledge base fol model stable model gr 
show dl log knowledge base embedded hybrid mknf knowledge base 
definition 
mapping possibly negated dl log atoms mknf atoms follows dl atom ii non dl atom iii negated non dl atom dl log rule mknf rule obtained applying atom set dl log rules set mknf rules obtained applying rule dl log knowledge base 
theorem 
dl log knowledge base nm satisfiable mknf knowledge base satisfiable 
proof 
definition universal quantification dl log mknf claim trivially follows property kg pg nm satisfiable mknf knowledge base kg satisfiable pg gr 
prove 
ground rule pg rdl denote rule obtained deleting non dl atoms 
assume satisfiable model maximal set order interpretations satisfying conditions rdl pg rdl rdl pg rdl non dl atom non dl atom set empty contains interpretation furthermore ground non dl atom similarly pg rdl rdl 
clearly pg 
definition 
show satisfies preference semantics mknf assume mknf interpretation exists pg interpretation coincides dl atoms non dl atom clearly furthermore easy see gl pg contradicts assumption nm model pg 
assume kg satisfiable mknf model interpretation note empty interpretation coincides dl atoms non similarly previous paragraph easy see pg definition assume interpretation exists gl pg 
exactly way done direction construct mknf interpretation show 
contradicts assumption mknf model kg 
hybrid mknf knowledge bases mixed atoms rules semantically generalize dl log rules regardless safety condition 
dl log rules dl safe corresponding mknf rules dl safe furthermore shown section rules mixed atoms converted rules modal atoms 
results provide alternative reasoning algorithms dl safe dl log 
furthermore believe possible extend approach handle weakly safe rules details part 
note approach significant advantage dl log allows dl atoms occur modalities nonmonotonic reasoning table hybrid mknf knowledge base cities church historic cities churches 
church architect churches designed architects 
architects famous citizens cities build churches 
cities famous people interesting 
barcelona barcelona historic city 
barcelona famous church barcelona 
designed antonio 
beach cities beach 
beach recreational recreation 
recreational cities provide recreation 
barcelona barcelona city port 
hamburg hamburg city port 
hamburg hamburg city 
auxiliary rule 
church church architect 
church holy family church 
definition synonyms 
atomic name 
port cities usually 
suggest suggest visit historic cities 
atomic name 
consider take cities known consideration 
note dl predicates start lowercase non dl predicates uppercase letter 
assertion object 
applied equally dl non dl atoms 
dl log state birds fly penguins exception easily possible hybrid mknf knowledge bases 
example glance proposal may difficult understand 
believe mknf rules quite intuitive just read known hold possible hold demonstrate example 
imagine system helping decide go holiday tourism ontology table 
impact dl safety demonstrated axioms 
historic city church architect 
famous citizen interesting city 
normal non dl safe order rule perform inference individuals imply 
variables occur atom predicate applicable individuals known abox name introduced existential quantifier conclude subsumes 
note stated dl allows certain types role chaining inclusion axioms correctly imply subsumption relationship 
dl safety usually restricts subsumption inferences typically impact abox query answering 
specify names church barcelona architect 
variables bound known individuals barcelona derive barcelona 
dl safety compromise provides abox query answering expense subsumption inferences expressivity needed losing decidability 
dl safety crucial nonmonotonic reasoning nonmonotonic logics existential quantification 
consider integrity constraint requiring architect explicitly specified explicitly mentioned church 
intuitively write rule church paraphrased error known church known designer 
rule incorrect variables rules universally quantified rule requires church connected object 
formulate integrity constraint correctly introduce auxiliary rule projects variable result identify churches designer 
nonmonotonic formalisms usually assume una 
moment assume contain 
intuitively expect violated designer specified 
una satisfiable model interpreted object 
fact equal object intuitively read assumed hold semantics una counterintuitive nonmonotonic formalisms usually assume 
contrast dls require una allow explicit equality statements define synonyms 
overcome difference adopt special approach defining semantics hybrid mknf knowledge bases 
roughly speaking assume una level mknf ensure intuitive semantics level dl consider interpreted congruence relation 
subjects nonmonotonic reasoning just predicate individuals assumed equal evidence doing 
returning example synonyms satisfied 
rule asserts common sense knowledge port cities usually allowing conclude barcelona 
allows exceptions atom basically says proven axiom needed atomic concepts occur rules 
hamburg exception located river hamburg suppressed lead contradiction 
rule intended query suggests cities visit 
barcelona derived nonmonotonic reasoning implies monotonic reasoning 
imply barcelona derived standard dl reasoning involving unnamed individuals introduced beach 
suggest barcelona 
shows negation failure logic programming layered open world semantics description logics 
intuitively mknf performs open closed world inferences parallel example hamburg hamburg hold usual dl semantics 
reformulating questions closed world interpretation mind get hamburg hamburg known hamburg hamburg known 
allows conclude consider hamburg know sure hamburg city know opposite worth visit 
intuitively speaking dl part interpreted open world semantics allow user put closed world glasses examine nonmonotonic consequences dl part 
consequences rules enforce new nonmonotonic 
reasoning modally closed mknf formulae develop algorithms reasoning hybrid mknf knowledge bases stages 
section define general algorithms capable handling various types modally closed mknf formulae 
section specialize general algorithms types formulae obtained translating hybrid mknf knowledge bases 
different algorithms reasoning different types modally closed mknf formulae cases differ complexity reasoning 
algorithm handles flat mknf formulae second handles positive mknf formulae third handles positive nondisjunctive mknf formulae fourth handles stratified nondisjunctive mknf formulae fifth handles nondisjunctive mknf formulae 
algorithms closely related algorithms propositional extension multimodal logics knowledge belief 
overview presenting algorithms briefly discuss basic principles 
satisfiability formula usually demonstrated constructing model formula 
mknf model mknf formula set order interpretations infinite 
practical algorithm need appropriate finite representation possible solution represent directly compute firstorder formula exactly set order models usually written 
shown possible general possible modally closed subset mknf consider 
similarly done show uniquely defined partition modal atoms positive negative ones 
formula corresponds objective knowledge written obp computed atoms chosen positive straightforward way 
different fragments mknf adopt different strategies computing 
flat formulae guess partition 
modal atoms general order formulae partition sense 
example 
observe assuming positive negative inconsistent 
eliminate guesses lead inconsistencies 
furthermore check true modal atoms replaced values 
need ensure model defined objective knowledge contained partition satisfies mknf preference semantics 
try guess partition defines model 
stratified nondisjunctive fragment mknf show construct objective knowledge bottom fashion done ordinary datalog 
way eliminate unnecessary guessing obtain better complexity results 
general case definition 
flat modally closed mknf formula 
set atoms written ka smallest set containing modal atoms occurring ii atom modal atom occurring 
disjoint sets modal atoms 
denote formula obtained replacing strict occurrence modal atom true false similarly denote formula obtained replacing strict occurrence modal atom true false denote 
comment technical difference definition similar definitions 
represent values modal atoms considering atoms value negative modal atom represented value dual positive modal atom 
presentation somewhat simpler eliminates obviously inconsistent partitions choosing true 
define objective knowledge implicit set atoms definition 
objective knowledge set flat modally closed atoms order formula obp establish link sets order interpretations partition set atoms 
definition 
set order interpretations induces partition set flat modally closed atoms implies implies 
corollary follows immediately definition definition satisfiability mknf formula mknf structure corollary 
flat modally closed formula mknf interpretation partition ka induced true 
show obp characterizes mknf models lemma 
flat modally closed formula mknf model partition ka induced equal set interpretations obp 
proof 
interpretation set induces partition implies 
clearly obp proves show assume contains interpretation definition 
furthermore induces partition 
atom 
flat value completely defined values modal atoms 
contradicts assumption mknf model 
identify partitions ka contradictory definition 
partition set flat modally closed atoms consistent implies obp 
properties follow immediately definition consistency corollary 
consistent partition set flat modally closed atoms obp 
partition induced corollary 
partition set flat modally closed induced set order interpretations consistent 
define means evaluate modally closed mknf formula partition atoms 
note definition allows contain nested occurrences modal operators modal atoms occurring definition 
set flat modally closed atoms 
flat modally closed atom evaluates true obp similarly flat modally closed atom evaluates true obp 
value nested modally closed atoms defined exhaustively replacing flat modal value value modally closed mknf formula written formula obtained replacing strict modal atom value lemma 
set flat modally closed atoms modally closed mknf formula obp 
obp 
proof 
straightforward induction depth modal atoms show modal atom evaluates true 
immediately implies claim lemma 
procedure entails checking mknf algorithm 
theorem 
flat modally closed mknf formula modally closed mknf formula algorithm entails returns true mknf 
algorithm checking entailment flat mknf algorithm entails input flat modally closed mknf formula modally closed mknf formula necessarily flat output true mknf false partition ka exists 
evaluates true 
obp satisfiable 
obp satisfiable 
partition evaluates false obp unsatisfiable obp unsatisfiable 
obp satisfiable return true return false proof 
entails returns true partition ka satisfying conditions exists 
show obp mknf model 
condition empty 
condition consistent defines truth modal atoms corollary 
condition corollary verify satisfies preference semantics mknf assume exists induces partition ka consistent corollary 
clearly 
implies modal atom implies equivalently represented partition 
lemma obp corollary implies defines truth modal atoms occurring corollary consistent falsifies condition 
obp satisfiable falsifies condition 
furthermore 
corollary true falsifies condition 
assumption condition satisfied partitions exist mknf model 
condition obp lemma conclude mknf 
mknf mknf model exists induces partition ka 
corollary consistent validates condition 
lemma obp corollary implies defines truth modal atoms occurring 
furthermore implies true corollary validates condition 
obp satisfiable validates condition 
lemma obp validates condition 
remains show condition validated 
assume condition falsified 
partition exists conditions falsified 
obp 
clearly condition 
condition consistent defines truth values modal atoms corollary 
condition true corollary clearly obp obp mknf model contradiction 
condition satisfied entails returns true 
proof theorem see entails returns true yields partition obp mknf model invalidating 
estimate complexity algorithm 
theorem 
assuming satisfiability order formulae algorithm decidable complexity complexity algorithm entails np np 
proof 
partition guessed time polynomial condition checked polynomial time conditions verified polynomial number calls oracle running actions performed consider condition 
partition guessed polynomial time condition checked polynomial type conditions falsified polynomial number calls oracle running actions performed condition verified oracle running coe 
computing requires calls oracle running checking condition requires call oracle running entire algorithm runs positive case show algorithm previous section simplified checking entailment positive modal atom positive mknf formula 
note lemma holds arbitrary positive mknf formula necessarily flat modally closed 
algorithm checking entailment positive flat mknf algorithm entails input flat modally closed mknf formula closed order formula output true mknf false partition ka exists 
evaluates true 
obp satisfiable 
obp satisfiable 
obp satisfiable return true return false lemma 
positive mknf formula mknf satisfiable satisfiable 
furthermore mknf order formula 
proof 
claim 
direction follows immediately definition mknf models 
direction simply observe model maximal interpretation exists 
positive mknf model 
check mknf satisfiability suffices find model 
claim 
direction follows immediate definition mknf models 
direction assume model exists positive mknf model clearly mknf 
lemma flat positive modally closed mknf formula order formula define entails shown algorithm 
claim follows immediately lemma theorem 
flat modally closed mknf formula closed order formula algorithm entails returns true mknf 
assuming satisfiability order formulae algorithm decidable complexity algorithm entails np np 
proof 
claim 
proof theorem see condition entails ensures model induced partition ka satisfies preference semantics mknf 
eliminating condition algorithm entails check satisfiability lemma check entailment mknf 
note order formula condition simplification condition entails 
claim 
partition guessed time polynomial condition checked polynomial time conditions verified polynomial number calls oracle running condition verified call oracle running conditions checked positive nondisjunctive case turn attention positive nondisjunctive mknf programs 
programs mknf unsatisfiable mknf satisfiable single mknf model corresponds fixpoint certain operator 
show positive nondisjunctive mknf programs mknf model 
lemma 
positive nondisjunctive mknf program 
sets interpretations 
proof 
consider rule form 
clearly assume clearly assumption get 
previous lemma immediately implies theorem theorem 
mknf satisfiable positive nondisjunctive mknf program exactly mknf model 
proof 
assume mknf models 
obviously lemma contradicts assumption mknf models 
mknf satisfiable positive mknf program unique model lemma represented partition ka 
show compute partition deterministic way 
definition 
positive nondisjunctive mknf program operators defined subsets ka follows contains rule form ka obs intuitively computes immediate consequences respect rules computes immediate consequences respect objective knowledge accumulated point small technical difference definition usual case 
ordinary datalog suffices define set head atoms rules body atoms satisfied necessary explicitly append result set 
case operators interact 
operator may derive facts occur rules definition merely ensures facts lost computing consequences rules 
ensures extensively proofs 
furthermore definition 
observe set modal atoms obs unsatisfiable ka 
property easy prove lemma 
operator monotone lattice subsets ka implies ka 
proof 
observe holds trivially ii contains rule form 
monotone 
monotonicity holds trivially obs implies conjuncts 
monotonicity implies monotonicity 
monotone operator complete lattice subsets ka known knaster tarski theorem unique fixpoint denote usual computed setting computing si si ka finite finite number shall sn sn 
show properties lemma 
positive nondisjunctive mknf program mknf model partition ka induced proof 
corollary partition consistent meaning obp words furthermore exactly subset ka true satisfies rules furthermore holds definition conclude clearly implies lemma 
positive nondisjunctive mknf program subset ka obp 

proof 
implies furthermore definition similarly definition implies partition ka consistent corollary exactly set modal atoms ka true implies rules satisfied 
ready main result subsection theorem 
positive nondisjunctive mknf program 
claims hold single mknf model 
mknf model model equal proof 
claim 
assume 
fixpoint lemma 
show mknf model show satisfies preference semantics mknf 
assume set interpretations exists 
induces partition ka 
lemma furthermore implies ka contradicts assumption fixpoint 
mknf model unique theorem 
claim 
assume mknf model induces partition ka lemma 
show fixpoint 
assume obp 
lemma contradicts assumption mknf model 
lemma 
lemma clear mknf modally closed mknf formula 
estimate complexity algorithm 
theorem 
positive nondisjunctive mknf program 
assuming entailment order formulae encountered computing decidable complexity computing proof 
fixpoint reached ka iterations worst case exactly new atom appended set consequences iteration 
consider complexity iteration 
si computed checking rule body atoms contained si obviously requires time polynomial 
furthermore computing si requires checking ka performed linear number calls oracle running number iterations linear algorithm runs pc stratified nondisjunctive case extend results previous section include class stratified nondisjunctive programs 
programs allowed contain atoms rules program separated strata evaluated separately 
definition generalizes notion stratification datalog programs hybrid mknf knowledge bases 
definition 
nondisjunctive mknf program function assigning rule positive integer 
integer head head 
say stratification conditions hold rule body head obp head obp obp unsatisfiable body head obp head obp obp unsatisfiable 
program stratified stratification exists 
stratification partitions strata sequence strata 
identified called stratification 
conditions definition ensure evaluating stratum values atoms computed evaluating subsequent stratum change values atoms stratum ordinary datalog programs stratification defined strongly connected components dependency graph associated program 
mknf programs contain arbitrary order formulae atoms checking stratification difficult 
consider program dependency graph build usual treating modal atoms opaque suggest stratification comes 
evaluating rules order get result body satisfied derive satisfies body derive 
objective knowledge equivalent body satisfied model minimal 
fact algorithm shows mknf models 
checking stratification difficult general done syntactic means certain natural classes nondisjunctive mknf programs 
example case dl propositional logic stratified stratified usual sense treating modal atoms opaque furthermore propositional letter head rule stratum occurs heads rules strata bodies rules strata stratification checked usual mknf program contains non dl atoms heads dl allows equality unique name assumption additionally required 
important case allows defining constraints dl knowledge bases 
show model stratified mknf program computed processing strata sequentially 
definition 
stratification 
mknf program sequence subsets 
uk ka inductively defined obtained ui ui replacing atom value ui 
uk 
show partition ka induces mknf model stratified program 
doing prove auxiliary lemma shows model positive nondisjunctive program represented head atoms rules lemma 
satisfiable positive nondisjunctive mknf program 
furthermore mknf model inducing partition ka 
subset modal atoms occur head rule 
equal obp 
proof 
clearly assume consider rule clearly head atom head atom false body atom get contradicts assumption mknf model 
theorem 
stratified nondisjunctive mknf program computed specified definition stratification 
claims hold mknf model 
mknf model model equal proof 

stratification compute definition mi positive nondisjunctive program theorem mknf model corresponds mi theorem 
assume mi consider atom occurring body rule 
clearly mi implies mi 
assume mi mi 
subset ui containing atoms occurring head rule lemma mi ob ob 
partition ka induced mi subset containing atoms occur head rule lemma mi obp obp 
mi mi stratified contradiction 
property holds value atoms atoms occurring rule mi mi mi 
similar way show property holds value atoms occurring rule mi mi mi 
property trivial atom occurring head rule mi implies mi 
prove claims theorem inductively corresponding mi 
induction basis trivial consider inductive step 
claim 
assume mi 
clearly mi induction assumption mi mknf model 
properties mi 
furthermore property mi mi mi assume mknf interpretation exists mi 
contradicts fact mi mknf model mi mknf model 
claim 
assume mknf model property mknf model partition ka induced mi 
ui ka ui 
lemma clear mknf modally closed mknf formula 
estimate complexity algorithm 
theorem 
stratified nondisjunctive mknf program 
assuming entailment order formulae encountered computing stratum decidable complexity computing proof 
stratum set computed pc theorem 
formula computed linear number calls oracle running number strata linear computed complexity pc lemma useful estimating complexity entailment negative facts stratified mknf programs lemma 
stratified mknf program closed firstorder formula 
mknf mknf unsatisfiable mknf 
proof 
directions trivial mknf unsatisfiable assume unique mknf model direction mknf mknf 
direction mknf implies implies model mknf 
nondisjunctive case consider case nondisjunctive program stratification 
programs needs guess partition determine objective knowledge positive nondisjunctive mknf program allows check minimality condition explained section possibly leading lower complexity 
idea reflected algorithm 
theorem 
nondisjunctive mknf program modally closed mknf formula nondisjunctive entails returns true mknf 
assuming satisfiability order formulae algorithm decidable complexity algorithm nondisjunctive entails ep np np 
proof 
claim 
proof theorem see condition entails ensures model induced partition ka satisfies preference semantics mknf 
flat formula equivalent checking obp algorithm checking entailment nondisjunctive mknf programs algorithm nondisjunctive entails input nondisjunctive modally closed mknf formula modally closed mknf formula necessarily flat output true mknf false partition ka exists 
evaluates true 
obp satisfiable 
obp satisfiable 

obp satisfiable return true return false mknf model 
positive nondisjunctive program model corresponds theorem 
satisfies preference semantics mknf 
claim 
partition guessed time polynomial condition checked polynomial time conditions verified polynomial number calls oracle running computed polynomial number calls oracle running satisfiability obp computed additional call oracle 
theorem condition checked algorithm runs ep reasoning hybrid knowledge bases section apply techniques section obtain algorithms reasoning hybrid mknf knowledge base particular show check various conditions algorithms section standard dl inferences knowledge base satisfiability knowledge base entailment 
results section show build reasoner hybrid mknf knowledge bases top dl reasoner 
general case dl safe flat hybrid mknf knowledge base formula form ground atom want check 
formula need modally closed apply algorithm entails directly 
compute kg ground instantiation dl safe entails set ground mknf formulae lemma 
size kg exponentially larger size case datalog disjunctive datalog stable model semantics included logic checking satisfiability nonground disjunctive programs complex ground disjunctive programs exponential factor 
sections consider combined complexity focus data complexity hybrid mknf knowledge base data complexity measured size abox number facts kg check mknf entails 
satisfy condition algorithm partition ka similarly falsify condition partition set true advance consider partitions remaining modal atoms denote set ka ka 
clearly ka contains ground atoms 
objective knowledge partition ka formula positive ground atoms obp simplify notation presentation identify pg pg saying pg evaluates true mean pg evaluates true set atoms sdl sdl denote subset dl atoms respectively 
assuming dl supports aboxes case practically relevant dls pdl considered dl abox 
atoms positive dl required support negative abox assertions 
obp rewritten follows obp pdl pdl conjunction positive non dl atoms pdl affect satisfiability obp entailment dl atoms 
pdl affect entailment non dl atoms obp example non dl atom synonym non dl atom partition inconsistent 
ensure consistency check 

bn pdl pdl ai bi 

bn synonyms partition consistent 
procedure entails dl algorithm 
algorithm reasoning general hybrid knowledge bases algorithm entails dl input dl safe flat hybrid mknf knowledge base formula form ground atom output true false kg ground instantiation ok partition ka kg exists 
pg evaluates true 
pdl satisfiable 
pdl 


bn pdl pdl ai bi 
pg partition evaluates false unsatisfiable dl dl dl 
dl 
bn dl dl ai bi 
conditions holds ii return true return false theorem 
dl safe flat hybrid mknf knowledge base ground atom 
algorithm entails dl returns true 
furthermore assuming entailment ground dl atoms dl decidable data complexity data complexity algorithm np np 
proof 
claim 
lemma kg 
discussion section clear conditions entails dl correspond conditions entails kg respectively 
note partition determines value partition ka obp claim theorem follows theorem 
claim 
size nonground rules pg bounded kg computed polynomial time 
proof second claim theorem completely analogous proof theorem 
positive case discussed section entailment mknf coincides entailment positive formulae allows reasoning algorithm find model necessarily minimal 
positive hybrid mknf knowledge base checking performed algorithm entails dl algorithm entails dl condition 
theorem 
positive dl safe flat hybrid mknf knowledge base ground atom 
entails dl returns true furthermore assuming entailment ground dl atoms dl decidable data complexity data complexity algorithm np np 
proof 
claims follow theorems 
positive nondisjunctive case case positive nondisjunctive dl safe hybrid mknf knowledge base apply ideas previous section algorithm positive nondisjunctive mknf programs section 
definition 
positive nondisjunctive dl safe hybrid mknf knowledge base rk dk tk operators defined subsets ka follows rk kg contains rule form bi dk ka sdl 
bn 
sdl sdl si bi tk rk dk denote fixpoint tk ka 
analogous algorithm ordinary datalog require grounding rules applying algorithm 
holds rules component nondisjunctive hybrid mknf knowledge base value rk computed nonground rules exactly done ordinary datalog 
unfortunately computing dk involves examining atoms ka requires computing possible instantiations atoms grounding inevitable formulate rk general way keep presentation simple 
easy see tk corresponds kg leads theorem theorem 
positive nondisjunctive dl safe hybrid mknf knowledge base 
claims hold single mknf model mknf model model equal assuming entailment ground dl atoms dl decidable data complexity data complexity computing pc proof 
follows immediately theorems 
clearly ground atom stratified cases necessarily positive nondisjunctive dl safe hybrid mknf knowledge base 
general checking stratified may quite complicated 
explained section stratified programs deriving atom rule stratum affect values modal atoms strata general dl knowledge base quite difficult 
furthermore dl allows equality allowing number restrictions analysis performed just means concept role names possible atom derived rule stratum derive new equalities change value atoms lower strata 
employs unique name assumption dl employ equality rules contain dl predicates head rules layered top stratification checked usual 
case particularly important allows define constraints dl knowledge bases 
algorithm computing set atoms stratified nondisjunctive dl safe hybrid mknf knowledge base defined straightforward way analogously definition correctness complexity proved theorem lemma 
similarly algorithm computing set atoms nondisjunctive dl safe hybrid mknf knowledge base defined straightforward way analogously algorithm correctness complexity proved theorem 
data complexity investigate data complexity checking entailment ground literals hybrid mknf knowledge bases complexity measured size abox dl knowledge base number facts mknf program 
precise characterization assumptions data complexity checking entailment ground literals underlying fragment dl 
shown checking entailment ground atoms expressive dls shiq data complete conp furthermore expressive fragments horn shiq dl lite data complete analyze complexity mknf knowledge bases cases 
estimate impact adding dl knowledge base logic programs contrast results known results logic programs dl knowledge base 
table summarizes results complexity checking ground atom 
cases complexity differs depending results 
results completeness results 
sections prove results table 
positive nondisjunctive programs dl dl polynomial lower bound follows ordinary datalog upper bound follows theorem fact table data complexity entailment checking hybrid mknf kbs dl dl dl conp conp stratified conp conp conp conp conp consider dl conp 
conp lower bound entailment inherited entailment dl 
positive ground atom conp upper bound follows theorem 
lemma unsatisfiable theorem checks performed conp 
stratified nondisjunctive programs dl dl polynomial lower bound inherited case stratified datalog upper bound follows theorem fact consider dl conp 
conp upper bound immediate consequence theorem lower bound give hardness proof 
consider case positive atoms lemma entailment negative atoms reduced checking entailment positive atoms 
furthermore sufficient consider dl logic disjunctive datalog rules interpreted order semantics entailment logic data complete conp logic dl entailment data complete conp polynomially reduced dl 
theorem 
dl logic disjunctive datalog interpreted order semantics stratified nondisjunctive hybrid mknf knowledge base ground atom 
problem checking hard data complexity 
proof 
proof reduction dags sat 
instance dags sat triple var properties lvar 
vn set linking variables 
direct acyclic graph vertices propositional formulae 

associated unique linking variable vi 
furthermore contain linking variable vj corresponding contain private variables appearing formula 
distinguished result node 
dags sat instance valuation lvar true false defined inductively follows vi true propositional formula obtained replacing linking variables values satisfiable direct acyclic graph induction correctly defined 
dags sat problem deciding true known complete 
loss generality assume formula form forms general propositional formula brought form iteratively replacing nonatomic subformula fresh propositional variable introducing explicit definition form variable 
formula denote private variable corresponding translation form vi denote linking variable corresponding vr linking variable corresponds furthermore pvar denote set private variables instance dags sat construct hybrid mknf knowledge base kd od pd follows 
add od axioms pvar pvar add od fact pvar occurring formula include od fact form fact form fact form add pd fact form formula vi add pd rules formula formula clearly kd linear 
furthermore nonground rules kd fixed size ground instantiation kd polynomial kd dl safe vr kd vr lemma 
computing ground instantiation kd suffices instantiate rules values vi fact occurs pd instantiations clearly true model kd 
denote instantiation kd clearly vr kd vr 
consider order interpretation axioms ensure pvar 
intuitively means assigned value true means assigned value false 
axioms ensure truth values formulae form propagated standard semantics propositional connectives 
md mknf model containing order interpretations satisfying vi vi true vi vi false 
show md mknf model acyclic sequence formulae 
linking variables formula correspond formulae precede sequence 
consider formula linking variables 
true satisfiable 
md contains order interpretation truth assignment private variables md md 
rule instantiated clearly satisfied md 
false unsatisfiable 
md contains order interpretation truth assignment private variables md md 
rule instantiated clearly satisfied md 
inductively considering remaining formulae sequence consider see md satisfies rules satisfies assumption 
show md mknf model md model necessarily invalidate fact head ground instance head ground instance 
md mknf model completely analogous way show md mknf stratified 
polynomial claim theorem follows 
model furthermore previous proof shows nondisjunctive programs dl dl conp lower bound follows conp hardness answering queries nondisjunctive programs negation stable model semantics 
upper bound follows theorem fact np npp np 
dl conp upper bound follows immediately theorem 
lower bound consider case dl logic disjunctive datalog rules interpreted order semantics data complete conp 
theorem 
dl logic disjunctive datalog interpreted order semantics stratified nondisjunctive hybrid mknf knowledge base ground atom 
checking hard data complexity 
proof 
proof reduction qbf problem checking validity qbf 
xn 
ym propositional formula known hard 
proof theorem loss generality assume form form denote propositional variable corresponding encoding 
pvar denote set propositional variables 
xn 
arbitrary qbf construct hybrid mknf knowledge base follows 
add axioms 
variable pvar add axiom pvar uc furthermore encode formula axioms way proof theorem 
variable add axiom ux add axioms computing ground instantiation suffices instantiate rules ux fact occurs instantiations clearly true model 
ground instantiation computed way clearly entail ground formulae 
furthermore number nonground rules bounded polynomial 
observe nondisjunctive mknf knowledge base 
prove valid implies hardness mknf knowledge bases consequently claim theorem 
valid valuation variables xi satisfied valuation variables yi 
set firstorder interpretations satisfying axioms xi true xi false 
clearly satisfies rules furthermore head invalidated 
mknf model 
true value variables yi axioms encode semantics boolean connectives 
conversely mknf model 
clearly variable xi 
furthermore preference semantics mknf contains interpretation valuation variables yi 
implies true valuation variables yi valid 
positive query observe qbf valid mknf knowledge base satisfiable case true 
positive programs dl query form conp lower bound follows conp hardness answering positive queries positive disjunctive datalog programs conp upper bound follows theorem 
positive queries positive knowledge bases sufficient find model necessarily minimal reflected theorem 
dl query form lower bound follows hardness answering negative queries positive disjunctive datalog programs upper bound follows theorem 
minimality test required negative queries 
general programs lower bound follows hardness answering positive negative queries disjunctive datalog stable model semantics upper bound follows theorem 
reusing qbf solvers reasoning mknf reasoning algorithms flat positive fragments sections implemented na way provide performance practice blind guess check strategy 
obtain practical algorithm heuristics required order structure search space 
lot research invested developing techniques evaluating qbf efficiently efficient qbf solvers currently available 
enable applying existing tools optimizations techniques reasoning mknf section algorithm reduces checking entailment ground atom flat hybrid mknf knowledge base validity problem quantified boolean formulae 
reduction trivially modified handle case positive knowledge base positive query 
nondisjunctive knowledge bases reduction qbf produce algorithm optimal consider knowledge bases section 
approach inspired similar idea embedding propositional abduction autoepistemic logic default logic disjunctive logic programming stable models circumscription qbf 
translations implemented prototype shown useful practice 
see www org overview available tools 
www kr tuwien ac research html obtaining propositional mknf formula dl safe hybrid mknf knowledge base formula ground atom goal compute quantified boolean formula valid mknf 
fundamental mismatch exists propositional formula order formula 
step algorithm convert propositional mknf formula mknf 
algorithm embedding arbitrary decidable order fragment dl propositional logic currently known possible set function free clauses 
set function free clauses set ground instances furthermore contain function symbols finite reduction implemented practice 
problem simpler reduce dl logic function free clauses 
authors reduction dl shiq shiq knowledge base show compute disjunctive datalog program dd entails set ground facts 
properties transformation summarized theorem theorem 
algorithm shiq knowledge base computes positive disjunctive datalog program dd properties satisfiable dd satisfiable dd ground atom form atomic concept simple role denote standard entailment order logic equality size rules dd exponential number facts dd polynomial dd computed time exponential size tbox polynomial size abox call atoms preserved atoms call predicates occurring atoms preserved predicates 
positive disjunctive datalog program contain negation failure interpreted order formula 
set free variables rule show replace dd translating hybrid mknf knowledge base order mknf affecting entailments ground mknf formulae 
lemma 
dl safe hybrid mknf knowledge base containing preserved predicates rules ground mknf formula containing preserved atoms dd mknf formula dd dd mknf dd mknf 
proof 
lemma kg kg grounding ok contains preserved predicates rules ground rules kg contain preserved atoms 
kg dd kg 
run algorithm entails order reasoning problems involved checking conditions involve checking satisfiability obp obp ground atom 
condition computing involves checking entailments form obp ground formula checking satisfiability obp ground formula 
difference run entails formula obp contains dd 
assumption rules pg contain preserved atoms contain atoms 
condition entails holds corresponding condition holds entails theorem entails entails return values 
dd kg grounded constants ok lemma 
dl safe hybrid mknf knowledge base containing preserved predicates rules ground mknf formula containing preserved atoms furthermore gr mknf formula obtained dd grounding dd ok gr gr conjunction containing conjuncts ok ok ok ok vectors constants ok predicate formula gr ground interpret propositional mknf formula ground atom corresponds proposition 
mknf gr mknf 
proof 
lemma mknf dd mknf 
clear algorithm entails returns values dd kg gr formula dd contain existential quantifiers safe variable implication occurs antecedent grounding affect satisfiability entailment ground facts furthermore ensures congruence properties equality satisfied usual 
grounding large knowledge bases yield practical results 
current state art answer set solvers dlv smodels address problem intelligent grounding technique identifies part program needs grounded 
enables answer set solvers ground relevant part program significantly reduce size obtained ground program 
extending techniques case focus research 
reducing flat propositional mknf formula qbf flat propositional mknf formula propositional formula form show compute quantified boolean formula flat valid mknf 
atom assign unique propositional variables 
abbreviations set propositional variables modal atoms ka ta ka tb ka 
ta denote mknf formula obtained replacing modal atom ta denote mknf formula obtained replacing modal atom ta ta ta 
analogous definitions tb tb tb 
definition 
flat propositional mknf formula propositional formula form quantified boolean formula flat defined follows flat ta sat ob ka ta sat ob ka tb tb ta ta tb ta tb ka tb ta ka sat ob ob ta tb ka sat ob sat ob sat ob sat ob ka theorem 
flat propositional mknf formula propositional formula form mknf quantified boolean formula flat valid 
proof 
theorem mknf entails returns true 
note partition ka algorithm encoded valuation propositional atoms ta assigning true partition encoded valuation propositional atoms tb analogous way 
valuation ta equivalently partition formula ob equivalent formula obp similarly valuation tb equivalently partition formula ob equivalent formula obp 
furthermore sat clearly evaluates true formula satisfiable 
encodes exactly condition encodes exactly condition encodes exactly condition encodes exactly condition encodes exactly condition encodes exactly condition encodes exactly condition entails 
tb ta ta tb evaluates true clear flat valid exactly conditions algorithm entails satisfied 
observe prenex normal form flat quantifier prefix validity formula decided dl description logic data complete np reasoning hybrid mknf knowledge bases reduction qbf gives algorithm optimal worst case complexity 
gr somewhat simplify flat propositional atoms corresponding grounding dd evaluate true valuation ta 
logic minimal knowledge negation failure lifschitz formalism hybrid mknf knowledge bases seamlessly integrates dl logic programming 
way obtain powerful hybrid formalism combines best features worlds hand provides dl style modeling taxonomic knowledge hand provides lp style constructs negation failure 
formalism decidable apply known dl safety restriction rules applicable explicitly known individuals trading expressivity decidability 
reasoning algorithms different fragments logic 
furthermore analyze data complexity fragment show cases reasoning hybrid mknf knowledge bases harder corresponding fragment logic programming 
enable reusing existing heuristics developed reasoning quantified boolean formulae encode entailment problem hybrid mknf knowledge bases qbf 
encoding applied hybrid mknf knowledge bases shiq description logic reduction shiq knowledge bases disjunctive datalog 
challenging problem define founded semantics formalism 
founded semantics practice polynomial data complexity 
extension nontrivial requires redefining semantics mknf 
feasible building ideas 
abiteboul hull vianu 
foundations databases 
addison wesley 
baader calvanese mcguinness nardi patel schneider editors 
description logic handbook theory implementation applications 
cambridge university press january 
baader hollunder 
embedding defaults terminological knowledge representation formalisms 
journal automated reasoning 
lutz wolter 
description logics circumscription 
doherty mylopoulos welty editors proc 
th int 
conf 
principles knowledge representation reasoning kr pages lake district uk june 
aaai press 
calvanese de giacomo lenzerini rosati 
dl lite tractable description logics ontologies 
veloso kambhampati editors proc 
th national conf 
artificial intelligence aaai pages pittsburgh pa usa july 
aaai press 
eiter gottlob voronkov 
complexity expressive power logic programming 
acm computing surveys 
donini lenzerini nardi schaerf 
log integrating datalog description logics 
journal intelligent information systems 
donini nardi rosati 
description logics minimal knowledge negation failure 
acm transactions computational logic 
eiter tompits 
solving advanced reasoning tasks quantified boolean formulas 
proc 
th national conf 
artificial intelligence aaai pages austin tx usa july august 
aaai press 
eiter faber leone pfeifer 
declarative problemsolving dlv system 
logic artificial intelligence pages 
eiter gottlob mannila 
disjunctive datalog 
acm transactions database systems 
eiter leone pfeifer scarcello 
deductive system non monotonic reasoning 
dix furbach nerode editors proc 
th int 
conf 
logic programming non monotonic reasoning lpnmr volume lnai pages dagstuhl germany july 
springer 
eiter lukasiewicz tompits 
combining answer set programming description logics semantic web 
dubois welty 
williams editors proc 
th int 
conf 
principles knowledge representation reasoning kr pages whistler canada june 
aaai press 
eiter lukasiewicz tompits 
founded semantics description logic programs semantic web 
antoniou boley editors proc 
rd int 
workshop rules rule markup languages semantic web ruleml volume lncs pages hiroshima japan november 
springer 
fitting 
order logic automated theorem proving nd edition 
texts computer science 
springer 
gelfond lifschitz 
stable model semantics logic programming 
proc 
th int 
conf 
logic programming iclp pages wa usa august 
mit press 
gottlob 
np trees carnap modal logic 
journal acm 
horrocks patel schneider 
proposal owl rules language 
proc 
th int 
world wide web conference www pages new york ny usa may 
acm press 
hustadt motik sattler 
reducing shiq description logic disjunctive datalog programs 
dubois welty 
williams editors proc 
th int 
conf 
principles knowledge representation reasoning kr pages whistler canada june 
aaai press 
hustadt motik sattler 
data complexity reasoning expressive description logics 
proc 
th int 
joint conf 
artificial intelligence ijcai pages edinburgh uk july august 
morgan kaufmann publishers 
kutz horrocks sattler 

doherty mylopoulos welty editors proc 
th int 
conf 
principles knowledge representation reasoning kr pages lake district uk june 
aaai press 
levesque 
foundations functional approach knowledge representation 
artificial intelligence 
levy 
rousset 
combining horn rules description logics carin 
artificial intelligence 
lifschitz 
open defaults 
proc 
symposium computational logic esprit basic research series pages bruxelles belgium november 
springer 
lifschitz 
nonmonotonic databases epistemic queries 
mylopoulos reiter editors proc 
th int 
joint conf 
artificial intelligence ijcai pages sydney australia august 
morgan kaufmann publishers 
lifschitz 
minimal belief negation failure 
artificial intelligence 
motik sattler studer 
query answering owl dl rules 
journal web semantics science services agents world wide web 
boris motik 
reasoning description logics resolution deductive databases 
phd thesis karlsruhe th karlsruhe germany january 
papadimitriou 
computational complexity 
addison wesley 
reiter 
logic default reasoning 
artificial intelligence 
reiter 
database know 
journal logic programming 
rosati 
reasoning minimal belief negation failure 
journal artificial intelligence research 
rosati 
minimal belief negation failure multi agent systems 
annals mathematics artificial intelligence 
rosati 
decidability complexity integrating ontologies rules 
journal web semantics science services agents world wide web 
rosati 
semantic computational advantages safe integration ontologies rules 
fages editors proc 
rd int 
workshop principles practice semantic web reasoning volume lncs pages dagstuhl castle germany september 
springer 
rosati 
dl log tight integration description logics disjunctive datalog 
doherty mylopoulos welty editors proc 
th int 
conf 
principles knowledge representation reasoning kr pages lake district uk june 
aaai press 
stockmeyer 
polynomial time hierarchy 
theoretical computer science 
nen niemel 
smodels system 
eiter faber truszczynski editors proc 
th int 
conf 
logic programming nonmonotonic reasoning lpnmr volume lnai pages vienna austria september 
springer 
van gelder ross schlipf 
founded semantics general logic programs 
journal acm 

