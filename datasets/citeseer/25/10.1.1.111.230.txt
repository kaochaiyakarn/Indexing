yacc compiler compiler stephen johnson computer program input generally structure fact computer program input thought defining input language accepts 
input language may complex programming language simple sequence numbers 
unfortunately usual input facilities limited difficult lax checking inputs validity 
yacc provides general tool describing input computer program 
yacc user specifies structures input code invoked structure recognized 
yacc turns specification subroutine handles input process frequently convenient appropriate flow control user application handled subroutine 
input subroutine produced yacc calls user supplied routine return basic input item 
user specify input terms individual input characters terms higher level constructs names numbers 
routine may handle idiomatic features comment continuation conventions typically defy easy grammatical specification 
yacc written portable class specifications accepted general lalr grammars disambiguating rules 
addition compilers apl pascal yacc conventional languages including language desk calculator languages document retrieval system fortran debugging system 
yacc provides general tool imposing structure input computer program 
yacc user prepares specification input process includes rules describing input structure code invoked rules recognized low level routine basic input 
yacc generates function control input process 
function called parser calls user supplied lowlevel input routine lexical analyzer pick basic items called tokens input stream 
tokens organized input structure rules called grammar rules rules recognized user code supplied rule action invoked actions ability return values values actions 
yacc written portable dialect actions output subroutine 
syntactic conventions yacc follow heart input specification collection grammar rules 
rule describes allowable structure gives name 
example grammar rule date month name day year date month name day year represent structures interest input process presumably month name day year defined 
comma enclosed single quotes implies comma appear literally input 
colon semicolon merely serve punctuation rule significance controlling input 
proper definitions ps yacc compiler compiler input july matched rule 
important part input process carried lexical analyzer 
user routine reads input stream recognizing lower level structures communicates tokens parser 
historical reasons structure recognized lexical analyzer called terminal symbol structure recognized parser called nonterminal symbol avoid confusion terminal symbols usually referred tokens considerable leeway deciding recognize structures lexical analyzer grammar rules 
example rules month name month name 
month name example 
lexical analyzer need recognize individual letters month name nonterminal symbol 
low level rules tend waste time space may complicate specification yacc ability deal 
usually lexical analyzer recognize month names return indication month name seen case month name token 
literal characters passed lexical analyzer considered tokens 
allowing specification files flexible 
easy add example rule date month day year synonym july cases new rule slipped working system minimal effort little danger disrupting existing input 
input read may conform specifications 
input errors detected early theoretically possible left right scan chance reading computing bad input data substantially reduced bad data usually quickly 
error handling provided part input specifications permits reentry bad data continuation input process skipping bad data 
cases yacc fails produce parser set specifications 
example specifications may self contradictory may require powerful recognition mechanism available yacc 
cases represent design errors cases corrected making lexical analyzer powerful rewriting grammar rules 
yacc handle possible specifications power compares favorably similar systems constructions difficult yacc handle frequently difficult human beings handle 
users reported discipline formulating valid yacc specifications input revealed errors conception design early program development 
theory underlying yacc described 
yacc extensively numerous practical applications including lint portable compiler system typesetting mathematics 
yacc compiler compiler ps sections describe basic process preparing yacc specification section describes preparation grammar rules section preparation user supplied actions associated rules section preparation lexical analyzers 
section describes operation parser 
section discusses various reasons yacc may unable produce parser specification 
section describes simple mechanism handling operator precedences arithmetic expressions 
section discusses error detection recovery 
section discusses operating environment special features parsers yacc produces 
section gives suggestions improve style efficiency specifications 
section discusses advanced topics section gives 
appendix brief example appendix gives summary yacc input syntax 
appendix gives example advanced features yacc appendix describes mechanisms syntax longer actively supported provided historical continuity older versions yacc 
basic specifications names refer tokens nonterminal symbols 
yacc requires token names declared 
addition reasons discussed section desirable include lexical analyzer part specification file may useful include programs 
specification file consists sections declarations grammar rules programs sections separated double percent marks 
percent generally yacc specifications escape character 
words full specification file looks declarations rules programs declaration section may empty 
programs section omitted second mark may omitted smallest legal yacc specification rules blanks tabs newlines ignored may appear names multi character reserved symbols 
comments may appear name legal enclosed 
pl rules section grammar rules 
grammar rule form body represents nonterminal name body represents sequence zero names literals 
colon semicolon yacc punctuation 
names may arbitrary length may letters dot underscore non initial digits 
upper lower case letters distinct 
names body grammar rule may represent tokens nonterminal symbols 
literal consists character enclosed single quotes 
backslash escape character literals escapes recognized 
ps yacc compiler compiler newline return single quote backslash tab backspace form feed xxx xxx octal number technical reasons nul character grammar rules 
grammar rules left hand side vertical bar avoid rewriting left hand side 
addition semicolon rule dropped vertical bar 
grammar rules yacc necessary grammar rules left side appear grammar rules section input readable easier change 
nonterminal symbol matches empty string indicated obvious way empty names representing tokens declared simply done writing token name name 
declarations section 
see sections discussion 
name defined declarations section assumed represent nonterminal symbol 
nonterminal symbol appear left side rule 
nonterminal symbols called start symbol particular importance 
parser designed recognize start symbol symbol represents largest general structure described grammar rules 
default start symbol taken left hand side grammar rule rules section 
possible fact desirable declare start symbol explicitly declarations section start keyword start symbol input parser signaled special token called endmarker tokens including endmarker form structure matches start symbol parser function returns caller endmarker seen accepts input 
endmarker seen context error 
job user supplied lexical analyzer return endmarker appropriate see section 
usually endmarker represents reasonably obvious status record 
actions grammar rule user may associate actions performed time rule recognized input process 
actions may return values may obtain values returned yacc compiler compiler ps previous actions 
lexical analyzer return values tokens desired 
action arbitrary statement input output call subprograms alter external vectors variables 
action specified statements enclosed curly braces 
example hello abc xxx yyy zzz printf message flag grammar rules actions 
facilitate easy communication actions parser action statements altered slightly 
symbol dollar sign signal yacc context 
return value action normally sets pseudo variable value 
example action return value obtain values returned previous actions lexical analyzer action may pseudo variables refer values returned components right side rule reading left right 
rule example value returned value returned concrete example consider rule expr expr value returned rule usually value expr parentheses 
indicated form expr expr default value rule value element 
grammar rules frequently need explicit action 
examples actions came rules 
desirable get control rule fully parsed 
yacc permits action written middle rule 
rule assumed return value accessible usual mechanism actions right 
turn may access values returned symbols left 
rule effect set value returned actions terminate rule handled yacc manufacturing new nonterminal symbol name new rule matching name empty string 
interior action action triggered recognizing added rule 
yacc treats example written ps yacc compiler compiler act empty act applications output done directly actions data structure parse tree constructed memory transformations applied output generated 
parse trees particularly easy construct routines build maintain tree structure desired 
example suppose function node written call node creates node label descendants returns index newly created node 
parse tree built supplying actions expr expr expr node specification 
user may define variables actions 
declarations definitions appear declarations section enclosed marks 
declarations definitions global scope known action statements lexical analyzer 
example int variable placed declarations section making variable accessible actions 
yacc parser uses names yy user avoid names 
examples values integers discussion values types section 
lexical analysis user supply lexical analyzer read input stream communicate tokens values desired parser 
lexical analyzer integer valued function called function returns integer token number representing kind token read 
value associated token assigned external variable parser lexical analyzer agree token numbers order communication take place 
numbers may chosen yacc chosen user 
case define mechanism allow lexical analyzer return numbers symbolically 
example suppose token name digit defined declarations section yacc specification file 
relevant portion lexical analyzer look yacc compiler compiler ps extern int int 
getchar 
switch 
case case 
case return digit 
intent return token number digit value equal numerical value digit 
provided lexical analyzer code placed programs section specification file identifier digit defined token number associated token digit 
mechanism leads clear easily modified lexical analyzers pitfall need avoid token names grammar reserved significant parser example token names certainly cause severe difficulties lexical analyzer compiled 
token name error reserved error handling naively see section 
mentioned token numbers may chosen yacc user 
default situation numbers chosen yacc 
default token number literal character numerical value character local character set 
names assigned token numbers starting 
assign token number token including literals appearance token name literal declarations section immediately followed nonnegative integer 
integer taken token number name literal 
names literals defined mechanism retain default definition 
important token numbers distinct 
historical reasons endmarker token number negative 
token number redefined user lexical analyzers prepared return negative token number reaching input 
useful tool constructing lexical analyzers lex program developed mike lesk 
lexical analyzers designed close harmony yacc parsers 
specifications lexical analyzers regular expressions grammar rules 
lex easily produce quite complicated lexical analyzers remain languages fortran fit theoretical framework lexical analyzers crafted hand 
parser works yacc turns specification file program parses input specification 
algorithm go specification parser complex discussed see information 
parser relatively simple understanding works strictly necessary treatment error recovery ambiguities comprehensible 
parser produced yacc consists finite state machine stack 
parser capable reading remembering input token called lookahead token 
current state top stack 
states finite state machine small integer labels initially machine state stack contains state lookahead token read 
ps yacc compiler compiler machine actions available called shift reduce accept error move parser done follows 
current state parser decides needs lookahead token decide action done needs calls obtain token 

current state lookahead token needed parser decides action carries 
may result states pushed stack popped stack lookahead token processed left 
shift action common action parser takes 
shift action taken lookahead token 
example state may action shift says state lookahead token current state pushed stack state current state top stack 
lookahead token cleared 
reduce action keeps stack growing bounds 
reduce actions appropriate parser seen right hand side grammar rule prepared announce seen instance rule replacing right hand side left hand side 
may necessary consult lookahead token decide reduce usually fact default action represented reduce action 
reduce actions associated individual grammar rules 
grammar rules small integer numbers leading confusion 
action reduce refers grammar rule action refers state 
shift suppose rule reduced reduce action depends left hand symbol case number symbols right hand side case 
reduce pop top states stack general number states popped equals number symbols right side rule 
effect states ones put stack recognizing longer serve useful purpose 
popping states state uncovered state parser process rule 
uncovered state symbol left side rule perform effect shift new state obtained pushed stack parsing continues 
significant differences processing left hand symbol ordinary shift token action called goto action 
particular lookahead token cleared shift affected goto 
case uncovered state contains entry goto causing state pushed stack current state 
effect reduce action turns back clock parse popping states stack go back state right hand side rule seen 
parser behaves seen left side time 
right hand side rule empty states popped stack uncovered state fact current state 
reduce action important treatment user supplied actions values 
rule reduced code supplied rule executed stack adjusted 
addition stack holding states stack running parallel holds values returned lexical analyzer actions 
shift takes place external variable copied value stack 
return user code reduction carried 
goto action done external variable copied value stack 
pseudo variables refer value yacc compiler compiler ps stack 
parser actions conceptually simpler 
accept action indicates entire input seen matches specification 
action appears lookahead token endmarker indicates parser successfully done job 
error action hand represents place parser longer continue parsing specification 
input tokens seen lookahead token followed result legal input 
parser reports error attempts recover situation resume parsing error recovery opposed detection error covered section 
time example 
consider specification token ding dong dell rhyme sound place sound ding dong place dell yacc invoked option file called output produced human readable description parser 
output file corresponding grammar statistics stripped ps yacc compiler compiler state accept ding shift error rhyme goto sound goto rhyme state accept rhyme accept error state rhyme sound place dell shift error place goto state sound ding dong dong shift error state rhyme sound place reduce state place dell reduce state sound ding dong reduce notice addition actions state description parsing rules processed state 
character indicate seen come rule 
suppose input ding dong dell instructive follow steps parser processing input 
initially current state state 
parser needs refer input order decide actions available state token ding read lookahead token 
action state ding shift state pushed stack lookahead token cleared 
state current state 
token dong read lookahead yacc compiler compiler ps token 
action state token dong shift state pushed stack lookahead cleared 
stack contains 
state consulting lookahead parser reduces rule 
sound ding dong rule symbols right hand side states popped stack uncovering state 
consulting description state looking goto sound obtained state pushed stack current state 
state token dell read 
action shift state pushed stack lookahead token cleared 
state action reduce rule 
symbol right hand side state popped state uncovered 
goto state place left side rule state 
stack contains 
state action reduce rule 
symbols right top states popped uncovering state 
state goto rhyme causing parser enter state 
state input read endmarker obtained indicated output file 
action state endmarker seen accept successfully parse 
reader urged consider parser works confronted incorrect strings ding dong dong ding dong ding dong dell dell minutes spend simple examples probably problems arise complicated contexts 
ambiguity conflicts set grammar rules ambiguous input string structured different ways 
example grammar rule expr expr expr natural way expressing fact way forming arithmetic expression put expressions minus sign 
unfortunately grammar rule completely specify way complex inputs structured 
example input expr expr expr rule allows input structured expr expr expr expr expr expr called left association second right association 
yacc detects ambiguities attempting build parser 
instructive consider problem confronts parser input expr expr expr parser read second expr input seen expr expr matches right side grammar rule 
parser reduce input applying rule applying rule input reduced expr left side rule 
parser read final part input expr reduce 
effect take left associative interpretation 
ps yacc compiler compiler alternatively parser seen expr expr defer immediate application rule continue reading input seen expr expr expr apply rule rightmost symbols reducing expr leaving expr expr rule reduced effect take right associative interpretation 
having read expr expr parser legal things shift reduction way deciding 
called shift reduce conflict may happen parser choice legal reductions called reduce reduce conflict note shift shift conflicts 
shift reduce reduce reduce conflicts yacc produces parser 
selecting valid steps choice 
rule describing choice situation called disambiguating rule yacc invokes disambiguating rules default 
shift reduce conflict default shift 

reduce reduce conflict default reduce earlier grammar rule input sequence 
rule implies reductions deferred choice favor shifts 
rule gives user crude control behavior parser situation reduce reduce conflicts avoided possible 
conflicts may arise mistakes input logic grammar rules consistent require complex parser yacc construct 
actions rules cause conflicts action done parser sure rule recognized 
cases application disambiguating rules inappropriate leads incorrect parser 
reason yacc reports number shift reduce reduce reduce conflicts resolved rule rule 
general possible apply disambiguating rules produce correct parser possible rewrite grammar rules inputs read conflicts 
reason previous parser generators considered conflicts fatal errors 
experience suggested rewriting somewhat unnatural produces slower parsers yacc produce parsers presence conflicts 
example power disambiguating rules consider fragment programming language involving construction stat cond stat cond stat stat rules tokens cond nonterminal symbol describing conditional logical expressions stat nonterminal symbol describing statements 
rule called simple rule second rule 
rules form ambiguous construction input form structured rules ways yacc compiler compiler ps second interpretation programming languages having construct 
associated preceding un example consider situation parser seen looking immediately reduce simple rule get stat read remaining input reduce stat rule 
leads groupings input 
hand may shifted read right hand portion reduced rule get stat reduced simple rule 
leads second groupings input usually desired 
parser valid things shift reduce conflict 
application disambiguating rule tells parser shift case leads desired grouping 
shift reduce conflict arises particular current input symbol particular inputs seen general may conflicts associated input symbol set previously read inputs 
previously read inputs characterized state parser 
conflict messages yacc best understood examining verbose option output file 
example output corresponding conflict state ps yacc compiler compiler shift reduce conflict shift reduce state stat cond stat stat cond stat stat shift reduce line describes conflict giving state input symbol 
ordinary state description follows giving grammar rules active state parser actions 
recall underline marks portion grammar rules seen 
example state parser seen input corresponding cond stat grammar rules shown active time 
parser possible things 
input symbol possible shift state 
state part description line stat cond stat stat shifted state 
back state alternative action described done input symbol mentioned explicitly actions case input symbol parser reduces grammar rule stat cond stat notice numbers shift commands refer states numbers reduce commands refer grammar rule numbers 
output file rule numbers printed rules reduced 
states reduce action possible state default command 
user encounters unexpected shift reduce conflicts probably want look verbose output decide default actions appropriate 
really tough cases user need know behavior construction parser covered 
case theoretical consulted services local guru appropriate 
precedence common situation rules resolving conflicts sufficient parsing arithmetic expressions 
commonly constructions arithmetic expressions naturally described notion precedence levels operators information left right associativity 
turns ambiguous grammars appropriate disambiguating rules create parsers faster easier write parsers constructed unambiguous grammars 
basic notion write grammar rules form expr expr op expr expr unary expr binary unary operators desired 
creates ambiguous grammar parsing conflicts 
disambiguating rules user specifies precedence binding strength operators associativity binary operators 
information sufficient allow yacc resolve parsing conflicts accordance rules construct parser realizes desired precedences 
yacc compiler compiler ps precedences attached tokens declarations section 
done series lines yacc keyword left right followed list tokens 
tokens line assumed precedence level associativity lines listed order increasing precedence binding strength 
left left describes precedence associativity arithmetic operators 
plus minus left associative lower precedence star slash left associative 
keyword right describe right associative operators keyword describe operators operator lt fortran may associate lt lt illegal fortran operator described keyword yacc 
example behavior declarations description right left left expr expr expr expr expr expr expr expr expr expr expr name structure input follows mechanism unary operators general precedence 
unary operator binary operator symbolic representation different precedences 
example unary binary unary minus may strength multiplication higher binary minus lower strength multiplication 
keyword prec changes precedence level associated particular grammar rule 
prec appears immediately body grammar rule action closing semicolon followed token name literal 
causes precedence grammar rule token name literal 
example unary minus precedence multiplication rules resemble ps yacc compiler compiler 
left left expr expr expr expr expr expr expr expr expr expr prec name token declared left right need may declared token precedences yacc resolve parsing conflicts give rise disambiguating rules 
formally rules follows 
precedences recorded tokens literals 

precedence associativity associated grammar rule precedence associativity token literal body rule 
prec construction overrides default 
grammar rules may precedence associativity associated 

reduce reduce conflict shift reduce conflict input symbol grammar rule precedence associativity disambiguating rules section conflicts reported 

shift reduce conflict grammar rule input character precedence associativity associated conflict resolved favor action shift reduce associated higher precedence 
precedences associativity left associative implies reduce right associative implies shift implies error 
conflicts resolved precedence counted number shift reduce reduce reduce conflicts reported yacc 
means mistakes specification precedences may disguise errors input grammar idea precedences essentially cookbook fashion experience gained 
output file useful deciding parser doing intended 
error handling error handling extremely difficult area problems semantic ones 
error example may necessary reclaim parse tree storage delete alter symbol table entries typically set switches avoid generating output 
seldom acceptable processing error useful continue scanning input find syntax errors 
leads problem getting parser restarted error 
general class algorithms involves discarding number tokens input string attempting adjust parser input continue 
allow user control process yacc provides simple reasonably general feature 
token name error reserved error handling 
name grammar rules effect suggests places errors expected recovery take place 
parser pops stack enters state token error legal 
behaves token error current lookahead token performs action encountered 
lookahead token reset token caused error 
special error rules specified processing halts error detected 
yacc compiler compiler ps order prevent cascade error messages parser detecting error remains error state tokens successfully read shifted 
error detected parser error state message input token quietly deleted 
example rule form stat error effect mean syntax error parser attempt skip statement error seen 
precisely parser scan ahead looking tokens legally follow statement start processing beginnings statements sufficiently distinctive may false start middle statement reporting second error fact error 
actions may special error rules 
actions attempt reinitialize tables reclaim symbol table space error rules general difficult control 
somewhat easier rules stat error error parser attempts skip statement skipping 
tokens error shifted discarded 
seen rule reduced cleanup action associated performed 
form error rule arises interactive applications may desirable permit line error 
possible error rule input error printf reenter line input potential difficulty approach parser correctly process input tokens admits correctly error 
line contains error tokens parser deletes offending tokens gives message clearly unacceptable 
reason mechanism force parser believe error fully recovered 
statement action resets parser normal mode 
example better written input error printf reenter line input mentioned token seen immediately error symbol input token error discovered 
inappropriate example error recovery action take job finding correct place resume input 
case previous lookahead token cleared 
statement action effect 
example suppose action error call sophisticated resynchronization routine supplied user attempted advance input valid statement 
routine called token returned presumably token legal statement old illegal token discarded error state reset 
done rule ps yacc compiler compiler stat error mechanisms admittedly crude allow simple fairly effective recovery parser errors user get control deal error actions required portions program 
yacc environment user inputs specification yacc output file programs called tab systems due local file system conventions names may differ installation installation 
function produced yacc called integer valued function 
called turn repeatedly calls lexical analyzer supplied user see section obtain input tokens 
eventually error detected case error recovery possible returns value lexical analyzer returns endmarker token parser accepts 
case returns value 
user provide certain amount environment parser order obtain working program 
example program program called main defined eventually calls addition routine called prints message syntax error detected 
routines supplied form user 
ease initial effort yacc library provided default versions main name library system dependent systems library accessed ly argument loader 
show triviality default programs source main return include stdio char fprintf stderr argument string containing error message usually string syntax error 
average application want better 
ordinarily program keep track input line number print message syntax error detected 
external integer variable contains lookahead token number time error detected may interest giving better diagnostics 
main program probably supplied user read arguments yacc library useful small projects earliest stages larger ones 
external integer variable normally set 
set nonzero value parser output verbose description actions including discussion input symbols read parser actions 
depending operating environment may possible set variable debugging system 
hints preparing specifications section contains miscellaneous hints preparing efficient easy change clear specifications 
individual subsections independent 
yacc compiler compiler ps input style difficult provide rules substantial actions readable specification file 
style hints owe brian kernighan 
capital letters token names lower case letters nonterminal names 
rule comes heading knowing blame things go wrong put grammar rules actions separate lines 
allows changed automatic need change 
put rules left hand side 
put left hand side rules vertical bar 
put semicolon rule left hand side put semicolon separate line 
allows new rules easily added 
indent rule bodies tab stops action bodies tab stops 
example appendix written style examples text space permits 
user mind stylistic questions central problem rules visible action code 
left recursion algorithm yacc parser encourages called left recursive grammar rules rules form name name rest rule rules frequently arise writing specifications sequences lists list item list item seq item seq item cases rule reduced item second rule reduced second succeeding items 
right recursive rules seq item item seq parser bit bigger items seen reduced right left 
seriously internal stack parser danger overflowing long sequence read 
user left recursion reasonable 
worth considering sequence zero elements meaning consider writing sequence specification empty rule seq empty seq item rule reduced exactly item read second rule reduced item read 
permitting empty sequences leads increased generality 
conflicts arise yacc asked decide empty sequence seen hasn seen know 
ps yacc compiler compiler lexical tie ins lexical decisions depend context 
example lexical analyzer want delete blanks normally quoted strings 
names entered symbol table declarations expressions 
way handling situation create global flag examined lexical analyzer set actions 
example suppose program consists declarations followed statements 
consider int declarations prog decls stats decls empty decls declaration stats empty stats statement rules 
flag reading statements reading declarations token statement 
token seen parser tell declaration section ended statements begun 
cases single token exception affect lexical scan 
kind backdoor approach elaborated degree 
represents way doing things difficult impossible 
reserved words programming languages permit user words normally reserved label variable names provided conflict legal names programming language 
extremely hard framework yacc difficult pass information lexical analyzer telling instance keyword instance variable 
user stab mechanism described subsection difficult 
number ways making easier 
better keywords reserved forbidden variable names 
powerful stylistic reasons preferring anyway 
advanced topics section discusses number advanced features yacc 
simulating error accept actions parsing actions error accept simulated action macros 
causes return value causes parser yacc compiler compiler ps behave current input symbol syntax error called error recovery takes place 
mechanisms simulate parsers multiple context sensitive syntax checking 
accessing values enclosing rules 
action may refer values returned actions left current rule 
mechanism simply ordinary actions dollar sign followed digit case digit may negative 
consider sent noun verb noun look sentence 
young young 
noun dog dog young printf 
action word check preceding token shifted young 
obviously possible great deal known precede symbol noun input 
distinctly unstructured flavor 
times mechanism save great deal trouble especially combinations excluded regular structure 
support arbitrary value types default values returned actions lexical analyzer integers 
yacc support values types including structures 
addition yacc keeps track types inserts appropriate union member names resulting parser strictly type checked 
yacc value stack see section declared union various types values desired 
user declares union associates union member names token nonterminal symbol having value 
value referenced construction yacc automatically insert appropriate union name unwanted conversions take place 
addition type checking commands lint far silent 
mechanisms provide typing 
way defining union done user programs notably lexical analyzer know union member names 
second way associating union member name tokens nonterminals 
mechanism describing type values yacc easily determine type 
declare union user includes declaration section union body union 
ps yacc compiler compiler declares yacc value stack external variables type equal union 
yacc invoked option union declaration copied tab file 
alternatively union may declared header file typedef define variable represent union 
header file said typedef union body union 
header file included declarations section 
defined union member names associated various terminal nonterminal names 
construction name indicate union member name 
follows keywords token left right union member name associated tokens listed 
saying left cause values returned tokens tagged union member name keyword type similarly associate union member names nonterminals 
say type nodetype expr stat remain couple cases mechanisms insufficient 
action rule value returned action priori type 
similarly left context values see previous subsection leaves yacc easy way knowing type 
case type imposed inserting union member name immediately 
example usage rule aaa intval bbb fun intval syntax little recommend situation arises rarely 
sample specification appendix facilities subsection triggered particular type turn mechanisms 
fairly strict level checking 
example refer defined type diagnosed 
facilities triggered yacc value stack hold int true historically 
yacc owes stimulating collection users inclination frequently ability endless search feature 
irritating learn things way usually led doing things way time right 
kernighan feldman lesk snyder recognize ideas current version yacc 
contributed error recovery algorithm 
ritchie kernighan harris helped translate document english 
aho deserves special credit bringing mountain mohammed favors 
yacc compiler compiler ps 
kernighan ritchie programming language prentice hall englewood cliffs new jersey 

aho johnson lr parsing comp 
surveys vol 
pp 
june 

aho johnson ullman deterministic parsing ambiguous grammars comm 
assoc 
comp 
mach vol 
pp 
august 

aho ullman principles compiler design addison wesley reading mass 

johnson lint program checker comp 
sci 
tech 
rep 
updated version tm 
johnson portable compiler theory practice proc 
th acm symp 
principles programming languages pp 
january 

kernighan cherry system typesetting mathematics comm 
assoc 
comp 
mach vol 
pp 
bell laboratories murray hill new jersey march 

lesk lex lexical analyzer generator comp 
sci 
tech 
rep bell laboratories murray hill new jersey october 
ps yacc compiler compiler appendix simple example example gives complete yacc specification small desk calculator desk calculator registers labeled accepts arithmetic expressions operators mod operator bitwise bitwise assignment 
expression top level assignment value printed integer begins zero assumed octal assumed decimal 
example yacc specification desk calculator reasonable job showing precedences ambiguities demonstrating simple error recovery 
major lexical analysis phase simpler applications output produced immediately line line 
note way decimal octal integers read grammar rules job probably better done lexical analyzer 
include stdio include ctype int regs int base start list token digit letter left left left left left supplies precedence unary minus rules section list empty list stat list error stat expr printf letter expr regs expr expr expr expr expr expr expr expr yacc compiler compiler ps expr expr expr expr expr expr expr expr expr prec letter regs number number digit base number digit base start programs lexical analysis routine returns letter lower case letter return digit digit characters returned immediately int getchar skip blanks return letter return digit return ps yacc compiler compiler appendix yacc input syntax appendix description yacc input syntax yacc specification 
context dependencies considered 
ironically yacc input specification language naturally specified lr grammar sticky part comes identifier seen rule immediately action 
identifier followed colon start rule continuation current rule just happens action embedded 
implemented lexical analyzer looks ahead seeing identifier decide token skipping blanks newlines comments colon 
returns token identifier 
returns identifier 
literals quoted strings returned identifiers part identifiers 
grammar input yacc basic entities token identifier includes identifiers literals token identifier identifier literal followed colon token number reserved words type type left left token left right token prec type start union token mark mark token mark token mark start spec ascii character literals stand spec defs mark rules tail tail mark action eat rest file empty second mark optional defs empty defs def def start identifier union copy union definition output copy code output file tag nlist token left right yacc compiler compiler ps type tag empty union tag optional identifier nlist nlist nlist identifier note literal illegal type identifier number note illegal type rules section rules identifier prec rules rule rule identifier prec prec empty identifier act act copy action translate prec empty prec identifier prec identifier act prec ps yacc compiler compiler appendix advanced example appendix gives example grammar advanced features discussed section 
desk calculator example appendix modified provide desk calculator floating point interval arithmetic 
calculator understands floating point constants arithmetic operations unary assignment floating point variables 
understands intervals written equal interval valued variables may 
usage similar appendix assignments return value print expressions print floating interval value 
example explores number interesting features yacc intervals represented structure consisting left right endpoint values stored double structure type name interval typedef yacc value stack contain floating point scalars integers index arrays holding variable values 
notice entire strategy depends strongly able assign structures unions fact actions call functions return structures 
worth noting handle error conditions division interval containing interval wrong order 
effect error recovery mechanism yacc throw away rest offending line 
addition mixing types value stack grammar demonstrates interesting syntax keep track type scalar interval intermediate expressions 
note scalar automatically promoted interval context demands interval value 
causes large number conflicts grammar run yacc shift reduce reduce reduce 
problem seen looking input lines 

notice interval valued expression second example fact known read time finished parser go back change mind 
generally necessary look ahead arbitrary number tokens decide convert scalar interval 
problem having rules binary interval valued operator left operand scalar left operand interval 
second case right operand interval conversion applied automatically 
despite evasion cases conversion may applied leading conflicts 
resolved listing rules yield scalars specification file way conflicts resolved direction keeping scalar valued expressions scalar valued forced intervals 
way handling multiple types instructive general 
kinds expression types just number rules needed increase dramatically conflicts dramatically 
example instructive better practice normal programming language environment keep type information part value part grammar 
word lexical analysis 
unusual feature treatment floating point constants 
library routine actual conversion character string double precision value 
lexical analyzer detects error responds returning token illegal grammar provoking syntax error parser error recovery 
yacc compiler compiler ps include stdio include ctype typedef struct interval double lo hi interval interval double double dreg interval vreg start lines union int double dval interval token dreg vreg indices dreg vreg arrays token dval const floating point constant type dval dexp expression type interval expression precedence information operators left left left precedence unary minus lines empty lines line line dexp printf printf lo hi dreg dexp dreg vreg ps yacc compiler compiler vreg error dexp const dreg dreg dexp dexp dexp dexp dexp dexp dexp dexp dexp prec dexp dexp hi lo dexp dexp lo hi lo hi printf interval order vreg vreg hi hi hi lo lo lo dexp hi hi lo lo hi hi lo lo lo hi dexp hi lo lo hi lo hi dexp lo hi yacc compiler compiler ps dexp prec hi lo lo hi define buffer size floating point numbers lexical analysis register getchar skip blanks return vreg return dreg digits points exponents char buf cp buf int dot exp cp buf cp getchar cp continue dot exp return cause syntax error continue exp return cause syntax error continue number break cp cp buf printf constant long truncated ps yacc compiler compiler stdin push back char read dval buf return const return interval double returns smallest interval containing routines interval hi lo hi lo hi hi lo lo hi hi lo lo return interval double interval return hi lo hi lo interval hi 
lo 
printf divisor interval contains return return interval double interval return hi lo hi lo yacc compiler compiler ps appendix old features supported encouraged appendix mentions synonyms features supported historical continuity various reasons encouraged 

literals may delimited double quotes 

literals may character long 
characters alphabetic numeric type number literal defined just literal quotes 
difficult find value literals 
multi character literals mislead unfamiliar yacc suggests yacc doing job done lexical analyzer 

places legal backslash may 
particular left left 
number synonyms left right binary term token prec 
actions may form 
curly braces dropped action single statement 

code permitted head rules section declaration section 
