interprocedural control dependence sinha mary jean harrold georgia institute technology gregg rothermel oregon state university program dependence information useful variety applications software testing maintenance tasks code optimization 
properly defined control data dependences identify semantic dependences 
function effectively programs tools utilize dependence information require information interprocedural dependences dependences identified analyzing interactions procedures 
techniques computing interprocedural data dependences exist virtually attention paid interprocedural control dependence 
analysis techniques fail account interprocedural control dependences suffer unnecessary imprecision loss safety 
article presents definition interprocedural control dependence supports relationship control data dependence semantic dependence 
article presents approaches computing interprocedural control dependences empirical results pertaining approaches 
categories subject descriptors software engineering testing debugging debugging aids testing tools data generators coverage testing software engineering distribution maintenance enhancement restructuring reverse engineering reengineering programming languages language constructs features control structures programming languages processors compilers optimization symbolic algebraic manipulation algorithms analysis algorithms general terms algorithms languages theory additional key words phrases interprocedural control dependence interprocedural analysis semantic dependence program slicing software maintenance article revised expanded version acm sigsoft international symposium software testing analysis harrold :10.1.1.114.5033
authors addresses sinha harrold college computing georgia institute technology atlanta ga email sinha cc gatech edu harrold cc gatech edu rothermel computer science department oregon state university corvallis email cs orst edu 
permission digital hard copy part personal classroom granted fee provided copies distributed profit commercial advantage copyright notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
acm acm transactions software engineering methodology vol 
april pages 
sinha 
program dependence information useful variety applications software testing maintenance tasks code optimization 
information example locate cause software failure evaluate impact modification determine parts program retested response modification identify parts code optimizing transformations applied 
purposes program dependences provide approximate useful information podgurski clarke 
control dependence information captures effects predicate statements program behavior 
information captures effects data interactions program behavior 
tools program control information tasks debugging impact analysis regression testing 
research bilardi pingali cytron ferrante pingali bilardi pollock soffa ryder addressed problems computing utilizing intraprocedural dependences dependences procedures computed analyzing procedures independently 
research considered control data dependence 
function effectively programs techniques require dependence information account interprocedural dependences dependences computed analyzing interactions procedures 
various definitions methods computing utilizing interprocedural data dependences necessity considering dependences interprocedural analyses understood cooper kennedy harrold soffa landi ryder pande reps sharir pnueli 
contrast virtually attention paid definition computation interprocedural control dependence 
search research literature reveals attempt define compute interprocedural control dependence loyall mathisen show section definition approach omit dependences 
furthermore interprocedural analysis techniques explicitly consider effects interprocedural control dependences 
empirical studies indicate failure account interprocedural control dependences may significantly affect analysis results 
analysis techniques utilize dependence information applied programs accounting interprocedural control dependences techniques identify dependences exist lead excessively large solutions analysis problems techniques ignore dependences exist lead errors omission solutions analysis problems 
analyses slicing reverse engineering errors omission may acceptable murphy acm transactions software engineering methodology vol 
april 
interprocedural control dependence notkin analyses slicing program integration errors omission allowable horwitz 
article addresses issues surrounding interprocedural control dependences potential effects interprocedural analysis techniques 
main contributions article description ways control dependences computed inaccurately model control dependences exist programs 
precise definition interprocedural control dependence 
previously definition loyall mathisen definition supports relationship syntactic semantic dependence podgurski clarke hold analyses dependence information model conservatively semantic dependences programs 
approaches computing interprocedural control dependences approach computes precise interprocedural control dependences may inordinately expensive approach summarizes control dependences efficiently obtains conservative safe estimate dependences cost precision 
article provides empirical results pertaining effectiveness efficiency approaches 
remainder article organized follows 
section provides background information necessary support definition interprocedural control dependence 
section demonstrates effects related interprocedural control dependence provides definition interprocedural control dependence 
section presents algorithms calculating interprocedural control dependence section presents empirical results obtained second algorithm 
section reviews related illustrates drawbacks existing definition interprocedural control dependence 
section presents outlines possible 

background demonstrate semantic basis uses program dependences evaluate uses podgurski clarke formal model program dependences 
distinguish types control data dependences describe conditions identification syntactic dependences may may imply identification semantic dependences cases behavior statement affect execution behavior statement 
results show maintenance tool slicer uses control data dependences identify superset statements semantically affect statement omit semantic dependences utilizes inappropriate definitions computations data control dependence information 
acm transactions software engineering methodology vol 
april 
sinha definition interprocedural control dependence builds previous 
section presents definitions drawn directly podgurski clarke prerequisite definition 
control dependences typically defined terms control flow graphs paths graphs postdominance relation 
definition 
control flow graph cfg procedure directed graph contains node statement contains edges represent possible flow control statements contains distinguished nodes representing entry exit respectively predecessors successors 
contains multiple exit points contains edge node represents exit point call site represented call node return node edge call node associated return node 
node reachable reachable node node represents predicate statement called predicate node exactly successors nodes exactly successor 
definition 
path cfg sequence nodes 
definition 
cfg 
node postdominates node nx path contains forms control dependence identified research literature 
restrict attention form control dependence commonly literature described control dependence ferrante direct strong control dependence podgurski clarke classical control dependence bilardi pingali 
definition 
cfg node control dependent node successors postdominates postdominate 
control dependence computation cfg augmented unique predicate node edges labeled true labeled false ferrante 
mechanism nodes control dependent predicate nodes control dependent entry procedure 
podgurski clarke term walk refer sequence adjacent nodes graph 
term path refer sequence standard literature 
acm transactions software engineering methodology vol 
april 
interprocedural control dependence definitions extend cfg model data elements extension define data dependence 
definition 
def graph quadruple du cfg finite set symbols called variables functions 
definition 
def graph node data dependent node exists path ni ni 
definition captures notion nodes def graph may connected chain data control dependences resulting syntactic dependence 
definition 
du def graph node syntactically dependent node sequence nodes 
control dependent data dependent podgurski clarke define semantic dependence relate syntactic dependence 
informally semantics statement may affect execution statement semantically dependent formal definition notions interpretations computation sequences execution histories defined follows podgurski clarke 
definition 
def graph 
assignment partial computable functions vertices function assigned vertex function computed program statement represents maps values variables values variables decision vertex successor definition 
computation sequence program sequence states pairs consisting statement function assigning values variables program induced executing program particular input 
definition 
du def graph 
history vertex sequence ith element assignment values held variables just ith time visited computation 
podgurski clarke define types syntactic dependence weak strong 
restrict attention refer simply syntactic dependence 
acm transactions software engineering methodology vol 
april 
sinha definitions podgurski clarke define semantic dependence follows definition 
node def graph du semantically dependent node du interpretations du differ function assigned input execution history induced differs induced 
semantic dependence demonstrated ways pair interpretations execution histories differ pair corresponding entries pair interpretations execution histories different lengths 
case holds case holds respect finite portions computations semantic dependence said finitely demonstrated necessarily occurs programs halt occur programs 
algorithm determine arbitrary statements semantically dependent podgurski clarke demonstrate appropriate definitions control data dependence exist useful relationships syntactic semantic dependence 
article restrict attention relationship stated theorem theorem 
du def graph ifu semantically dependent semantic dependence finitely demonstrated syntactically dependent theorem significant shows appropriate definitions control data dependence syntactic dependence necessary condition finitely demonstrated semantic dependence 
theorem provides justification algorithms syntactic dependence approximate semantic dependence 
refer desirable relationship syntactic semantic dependence syntactic semantic relationship 

interprocedural control dependence section illustrate effects impact interprocedural control dependences 
define interprocedural control dependence 
podgurski clarke additional definitions control syntactic dependence provide necessary condition semantic dependence programs halt 
proof theorem podgurski sketched podgurski clarke 
course trivial way construct algorithm preserves relationship algorithm simply statement syntactically control data dependent statement 
clearly approach unsatisfactory 
goal algorithm approximating semantic dependencies compute sufficiently tight approximations 
acm transactions software engineering methodology vol 
april 
procedure read sum call endwhile call print sum alternative version noop interprocedural control dependence procedure call sum sum read endif procedure sum halt endif effects impact interprocedural control dependences presents program sum consists procedures entry procedure provide alternative versions lines program alternatives illustrate specific points 
intraprocedural control dependence analysis operates independently individual procedures ignoring context procedure invoked side effects control dependence may caused called procedure 
table illustrates intraprocedural control dependences sum 
considering sum observe ways control dependences computed inaccurately model semantic dependences exist statements program 
consider version sum created substituting alternative versions lines version sum contains call halts assuming normal termination reaching implicit halt statement 
version statement immediately determines statement call executes doing immediately determines statements statement execute 
easy show terms definition statements semantically dependent statement absence data dependences 
preserve syntactic semantic relationship interprocedural control dependence analysis identify statements control dependent statement intraprocedural analysis 
call entry dependence effect 
second consider version sum created substituting alternative version line substituting alternative version line version contains calls halts assuming normal termination reaching statement 
presence second unconditional call statement means assuming normal termination statements necessarily execute execution sum 
statements execute regardless alternative version print error fig 

program sum alternative versions statements 
acm transactions software engineering methodology vol 
april 
sinha evaluation statement 
possible application definition postdominance definition imply statements postdominate statement control dependent statement 
loyall mathisen draw 
despite fact second call guarantees statements execute statement determine number times statements execute 
statements semantically dependent statement absence data dependences 
follows preserve syntactic semantic relationship interprocedural control dependence analysis identify statements control dependent statement 
call multiple context effect 
third consider version sum alternative line substituted case program halt statement 
explicit halt statement far reaching effects control dependences sum effects combine effects complicate program interprocedural control dependences 
example version sum statements depend immediately execution statement explicit halt statement 
easy show terms definition statements semantically dependent statement absence data dependences 
second example statement semantically dependent statement predicate statement true statement executes time fewer predicate statement false 
furthermore statement semantically dependent statement presence halt statement reachable call effect different interpretations function associated statement affect statement reached determine number times executes 
preserve syntactic semantic relationship interprocedural control dependence analysis identify control dependences responsible semantic dependences 
call return dependence effect 
call explicit halt statements cause effect embedded halts distinguish implicit program termination points 
table ii illustrates complete set interprocedural control dependences necessary preserve syntactic semantic relationship sum 
comparison dependences computed see table reveals extensive differences 
intraprocedural interprocedural dependences include common intraprocedural dependences include required interprocedural context interprocedural dependences include detected intraprocedural analysis 
obtain initial data embedded halts practice language supports examined variety nontrivial programs 
table iii summarizes programs examined 
examined programs aristotle analysis system harrold rothermel acm transactions software engineering methodology vol 
april 
interprocedural control dependence table intraprocedural control dependences sum control control statements dependent statements dependent entry entry entry table ii 
interprocedural control dependences sum control control statements dependent statements dependent entry table iii 
presence embedded halts programs program group number programs number programs contain embedded halts aristotle eli empire gcc omega siemens total programs eli text processor generation system empire internet game programs gcc compiler distribution omega data dependence analyzer programs researchers siemens study data flow testing hutchins tool displaying graphs 
halt functionality provided exit system call 
possible aristotle analyze source code inspected analysis information determine function main reached statically program 
ignoring exit statements main able exclude exit statements unconditionally ends programs affect control dependences 
programs aristotle completely analyze determined information manual inspection source code 
table iii illustrates programs examined programs group programs contained exit statements 
study necessary determine extent results generalize results see www cs umd edu projects omega omega html information omega project 
acm transactions software engineering methodology vol 
april 
sinha support hypotheses programs embedded halts frequently frequent consistent range programs 
embedded halts cause return dependence effects 
language constructs statements exception handling constructs java cause effects 
article restrict attention embedded halts 
definition interprocedural control dependence entry dependence multiple context return dependence effects constitute ways intraprocedural control dependence computation fails preserve syntactic semantic relationship respect control dependences programs 
effects may exist 
preserve syntactic semantic relationship definition interprocedural control dependence account effects section provides definition 
definition relies interprocedural inlined flow graph iifg 
iifg graph possibly infinite results inline procedures call sites construct control flow graph resulting program iifg represents control flow program rolled binkley 
invocation graph emami context graph atkinson griswold iifg fully context sensitive accounts calling sequence leads call 
invocation context graphs iifg flow sensitive accounts control flow individual procedures 
define iifg formally follows definition 
program collection cfgs contains procedure inp copy cfg call site calls furthermore set edges set nodes 
interprocedural inlined flow graph iifg directed graph cr hx ce xr hs unique node represents exit cr set edges call nodes corresponding return nodes hx set edges nodes represent embedded halts exit nodes respective cfgs ce set edges call nodes entry nodes xr set edges exit nodes return nodes hs set edges nodes represent embedded halts 
note statement corresponds set iifg nodes calling context statement executed 
denote set nodes statement corresponds nodeset 
depicts iifg program sum 
call site represented call return nodes cfg called procedure inlined call node 
cfgs connected call node entry node exit acm transactions software engineering methodology vol 
april 

enter 
call 
return 


exit 
enter 
sum 
halt 
exit 
sum sum 
read interprocedural control dependence 
enter 
read 
sum 

call 
return 
print sum 
exit exit 
sum 
halt 
enter 
exit node return node edges shown dashed lines 
iifg contains copies cfg procedure corresponding call nodes inlined cfg contains call iifg contains copies cfg 
nodes control exit program nodes connected unique exit node 
definitions paths postdominance control dependence def graphs data dependence syntactic dependence semantic dependence section apply follows definition 
path iifg sequence nodes 
definition 
iifg 
node postdominates node path contains definition 
iifg node control dependent node successors postdominates postdominate 
definition 
def iifg quadruple du iifg finite set symbols called variables functions 

call 
return 
enter 
call 
return 


exit fig 

interprocedural inlined flow graph program sum 

sum sum 
read acm transactions software engineering methodology vol 
april 
sinha definition 
du def iifg node data dependent node exists path du ni ni 
definition 
du def iifg node syntactically dependent node sequence nodes 
control dependent data dependent definition 
du def iifg du assignment partial computable functions vertices du function assigned vertex function computed program statement represents maps values variables values variables decision vertex successor definition 
du def iifg history vertex sequence ith element assignment values held variables just ith time visited computation 
definition 
node def iifg du semantically dependent node du interpretations du differ function assigned input execution history induced differs induced 
definitions theorem holds theorem 
du def iifg ifu semantically dependent semantic dependence finitely demonstrated syntactically dependent proof theorem follows podgurski clarke proof theorem relationship graphs podgurski clarke proof iifg 
see appendix discussion 
theorem syntactic semantic relationship holds iifg definition control dependence definition 
theorem significant reasons similar render theorem significant asserts appropriate definitions control data dependence syntactic dependence necessary condition finitely demonstrated semantic dependence 
theorem applies interprocedural context provides justification measure success interprocedural algorithms syntactic dependence approximate semantic dependence 
acm transactions software engineering methodology vol 
april 
interprocedural control dependence table iv 
programs empirical studies reported article subject description loc aristotle analysis system harrold rothermel user interface dejavu interprocedural regression test selector rothermel harrold diff file differencing tool flex lexical analyzer generator mpeg player maze combat game space parser antenna array description language unzip extract utility 
computing interprocedural control dependences section approaches computing interprocedural control dependences 
approach computes precise interprocedural control dependences may inordinately expensive 
second approach summarizes interprocedural control dependences computes conservative estimate dependences efficiently approach cost precision 
precise computation interprocedural control dependences way compute interprocedural control dependences program build iifg apply existing algorithm described bilardi pingali cytron ferrante pingali bilardi nonrecursive programs approach computes precise interprocedural control dependences 
practice approach may expensive 
iifg construction inlines procedure call site procedure size iifg may exponential size program represents 
recursive program iifg infinite constructed limiting number expansions procedures involved recursion turn limits precision computation iifg 
investigate cost iifg approach examined sizes programs 
table iv describes programs study lists number lines code programs 
table provides data sizes set programs differs set study occurrence embedded halts reported table iii 
objective embedded halt study motivate research study required limited processing programs 
able examine large number programs conclude embedded halts occur practice 
empirical studies reported section required extensive processing programs prototype tools examination results correctness 
selected subset programs study 
includes experimentation additional subjects including table iii 
acm transactions software engineering methodology vol 
april 
sinha table iifg sizes programs recursion expanded iifg size increase recursion expansion subject cfgs nodes cfgs nodes cfgs nodes dejavu diff flex space unzip programs 
programs contained recursion expanded recursive procedures determined increase iifg size caused additional expansion 
data illustrates programs flex exhibited orders magnitude increases iifg sizes sizes respective cfgs 
remaining programs including program contained recursion iifg sizes increased factors sizes respective cfgs 
shows increases iifg sizes bar graph vertical axis shows factor increase iifg size sizes cfgs 
factor increase ranges recursive programs factor increase additional expansion recursive procedures 
nonrecursive programs exhibits largest increase size factor nodes cfgs nodes iifg 
results suggest iifg traditional algorithm bilardi pingali cytron ferrante pingali bilardi compute interprocedural dependences programs may inordinately expensive 
expense weighed practice precision requirements particular applications 
reasonable seek alternative approaches computing interprocedural control dependences sacrifice precision efficiency remaining conservative omit interprocedural dependences exist program 
approach 
efficient conservative computation interprocedural control dependences iifg approach just computes interprocedural control dependences nodes iifg 
program statement may correspond nodes iifg node calling context procedure containing statement execute 
iifg approach computes distinct control dependences calling acm transactions software engineering methodology vol 
april 
iifg nodes cfg nodes dejavu interprocedural control dependence diff flex context statement execute call dependences context interprocedural control dependences 
alternative approach computing interprocedural control dependences ignore distinctions compute dependences summarizing control dependences exist calling context execution statement call dependences statement interprocedural control dependences 
precise definition statement interprocedural control dependence terms iifg nodes nodeset function follows definition 
program iifg statements statement control dependent statement exist nodes nodeset nodeset control dependent statement control dependences summarize control dependences exist different calling contexts encode control dependence information precisely context control dependences 
context control dependences defined iifg preserve syntactic semantic relationship statement control dependences summarize control dependences preserve relationship 
theorem 
statement control dependences preserve relationship 
proof 
proof requires definition means statement semantically syntactically dependent statement 
informally say dependence exists exists calling context 
formally say statement semantically syntactically dependent statement exist nodes du def iifg nodeset nodeset semantically syntactically space unzip fig 

factors increase iifg sizes sizes cfgs 
acm transactions software engineering methodology vol 
april 
sinha dependent 
proof proceeds follows 
suppose semantically dependent 
exist nodes du def iifg nodeset nodeset semantically dependent 
theorem syntactically dependent syntactically dependent 
definition follows compute statement interprocedural control dependences computing context control dependences iifg transforming control dependences nodeset associations 
approach course expensive simply computing control dependences 
efficient algorithm exists require iifg 
algorithm uses representation linear size program compute precisely interprocedural control dependences computed iifg 
algorithm 
algorithm proceeds phases phase identifies call sites control may return due presence embedded halts uses information compute partial control dependences construct augmented control dependence graph procedure phase connects augmented control dependence graphs procedures construct interprocedural control dependence graph program traverses graph compute interprocedural control dependences 
phase computation partial control dependences 
computation partial control dependences performed phase algorithm accounts effects embedded halts 
compute partial control dependences augment cfg placeholder nodes represent potential effects external control dependences nodes cfg call resulting graph augmented control flow graph acfg 
define acfg formally follows definition 
cfg procedure set nodes set edges cn cn cn cn nodes represent call sites control may return called procedures due presence embedded halts rn set return nodes associated call nodes cn 
augmented control flow graph acfg directed graph sx rp cr hx cp pe sx sx unique super exit node represents potential exits rp set return predicate nodes call node cn represent predicates external affect control dependences statements cr set edges call node cn corresponding return node hx set edges nodes represent acm transactions software engineering methodology vol 
april 

enter 
read 
sum 

call 
call 
return 
print sum 
exit 
return interprocedural control dependence super exit embedded halts exit node cp set edges node cn node rp associated pe set edges labeled node rp node rn associated labeled node rp sx sx set edges connect exit node halt node sx 
illustrate displays cfg acfg procedure example program 
acfg contains super exit node representing exit points procedure connected rest graph edge exit super exit 
graph contains return predicate nodes rp representing predicates return call depends rp representing predicates return call depends 
edge rp label represents control returning edge rp super exit label represents control returning edge rp represents fact call predicates called procedures determine control returns procedure graph contains similar edges return predicate node rp 
definitions paths postdominance control dependence apply acfg follows rp 

enter 
read 
sum 
call 
return 
print sum 
exit 
call 
return fig 

control flow graph procedure left augmented control flow graph right 
rp acm transactions software engineering methodology vol 
april 
sinha table vi 
partial control dependences sum computed control control statements dependent statements dependent entry rp rp entry rp entry definition 
path acfg sequence nodes 
definition 
acfg 
node postdominates node sx path contains definition 
ga ea acfg node control dependent node successors postdominates postdominate 
partial control dependences control dependences computed acfg 
intraprocedural control dependence computation ferrante partial control dependence computation adds dummy predicate node ns edge ne labeled true edge labeled false acfg 
table vi shows partial control dependences computed procedures sum 
represent partial control dependences phase algorithm constructs augmented control dependence graph define formally follows definition 
acfg procedure set nodes rp rp rp rp return predicate nodes corresponding return nodes rn rn rn rn 
control dependence graph directed graph rp sx cd cd set edges contains edge partial control dependences include set edges contains edge labeled partial control dependences include set edges contains edge rn rn labeled partial control dependences include rp rn return node associated return predicate node rp node rn predecessor successors nodes rn predecessors 
shows procedure contains edges represent partial control dependences 
source control dependence edge predicate node placeholder node acm transactions software engineering methodology vol 
april 

read 

call 
enter 
sum interprocedural control dependence 
return 
return 
call 
exit 
print sum fig 

augmented control dependence graph procedure placeholder node entry node return node 
node control dependent dummy start predicate contains edge entry node node control dependent return predicate contains edge return node associated return predicate contains return predicate nodes 
example partial control dependences procedure show node control dependent return predicate rp 
exists edge node return node associated return predicate rp node 
illustrates multiple root nodes 
root node represents point corresponding procedure control enters call site calls return site external predicates control statements reached entry 
entry node return nodes represent points procedure appear root nodes 
root node placeholder external predicates 
illustrates disconnected components 
approach computing partial control dependences involves main steps 
step program identify call sites control entering called procedure may fail return caller due presence embedded halt 
step information construct procedures presents algorithm 
algorithm takes input set cfgs cfg cfg cfg procedures respectively program outputs algorithm proceeds steps correspond steps described 
describe step algorithm turn 
step line calls procedure sites identify potentially call sites call sites control may return called procedures due presence embedded halts 
identify call sites requires acm transactions software engineering methodology vol 
april 
sinha fig 

algorithm computing partial control dependences 
information interprocedural flow control sites uses procedure shown identify obtain information procedure line constructs interprocedural control flow graph icfg connects individual cfgs call nodes landi ryder 
define icfg formally follows definition 
program procedures corresponding cfgs set edges set nodes interprocedural control flow graph icfg directed graph hx cr ce xr hx set edges connecting nodes represent embedded halts exit nodes cr set edges connecting call nodes return nodes ce set call node entry node edges call node entry node called procedure xr set exit node return node edges acm transactions software engineering methodology vol 
april 
interprocedural control dependence fig 

algorithm classifying call sites 
return node exit node procedure returned 
statement corresponds unique node icfg depicts icfg program sum 
call site represented call return nodes cfgs connected call node entry node exit node return node edges shown dashed lines 
iifg icfg contains single copy cfg procedure program 
icfg nodes represent halt statements connected unique exit node 
constructing icfg calls procedure line 
calculates pieces data list definitely procedures procedures control statically return due presence embedded halts list nodes icfg reached statically entry node list nodes icfg represent embedded halts reached statically entry node 
calculate data performs depth traversal realizable paths icfg marking nodes reaches unmarked nodes remain 
traversal places halt nodes reaches 
traversal procedure examines exit nodes individual cfgs icfg 
exit node marked indicates procedure exit node belongs definitely places procedure 
unmarked nodes statically unreachable places 
path icfg realizable control leaves procedure normal procedure exit procedure return statement returns procedure invoked 
acm transactions software engineering methodology vol 
april 
sinha 
enter 
read 
sum 

call 
call 
return 
print sum 
exit 
return 
enter 
call 
return 


exit 
sum sum 
read fig 

interprocedural control flow graph program sum 

enter 
sum 
exit call uses remove statically unreachable nodes line icfg cfgs 
algorithm determine 
procedure accomplishing takes input icfg unreachable nodes removed list definitely procedures list halt nodes 
procedure performs reverse depth traversal icfg starting halt nodes nodes represent calls definitely procedures ascending calling procedures descending called procedures 
call site reached traversal called procedure potentially 
algorithm places call nodes 
traversal terminates procedure returns modified cfgs 
illustrate operation consider example program 
called cfgs program creates icfg shown 
determines procedures program definitely nodes icfg reachable adds node 
rcs performs reverse depth traversal icfg node 
traversal algorithm adds call nodes associated call sites potentially 
identification step lines compute shown computes set partial control dependences constructs procedure acm transactions software engineering methodology vol 
april 

halt 
read 
sum 
enter 

call 
call 
return 
return 
exit 
print sum control dependence predicate control dependence placeholder interprocedural control flow interprocedural control dependence 
call 
exit 
enter 
sum sum 
halt 
return 

read 
exit constructs acfg pi lines 
initializes acfg line creates super exit node adds acfg line 
algorithm connects exit node line 
iterates pi lines creates return predicate node adds acfg line removes edge connects call node corresponding return node line connects call node node line creates outgoing edges labeled return predicate node lines 
removes edges connect halt nodes exit node connects halt nodes super exit node lines 
having constructed acfg pi computes partial control dependences pi applying existing technique control dependence computation bilardi pingali cytron ferrante pingali bilardi acfg pi line 
algorithm constructs pi line 
phase computation interprocedural control dependences 
intraprocedural control dependence computation applied acfg produces correct control dependences nodes control dependent nodes acfg control dependences nodes control dependent placeholders entry return nodes adjusted 
phase algorithm performs adjustment computes interprocedural control dependences 
compute interprocedural control dependences algorithm constructs interprocedural control dependence graph icdg 
define icdg formally follows definition 
program procedures gj corresponding pi 

enter 
sum fig 

interprocedural control dependence graph program sum 
acm transactions software engineering methodology vol 
april 
sinha fig 

algorithm computing interprocedural control dependences 
set nodes gi set edges gi interprocedural control dependence graph icdg gd nd ed directed graph nd ed ed ce xr ce set call node entry node edges call node entry node called procedure xr set exit node return node edges return node exit node procedure returned 
shows icdg program sum 
apart edges icdg contains call return edges 
call site call edge connects call node entry node called procedure example call edge connects call node entry node 
call site return edge connects exit node called procedure return node call site example return edge connects exit node return node 
presents computeintercd algorithm phase interprocedural control dependence computation 
computeintercd takes inputs procedures program list nodes control dependent placeholders partial control dependences excluding placeholders node 
algorithm acm transactions software engineering methodology vol 
april 
interprocedural control dependence constructs icdg connecting call return edges line 
algorithm traverses icdg node control dependent placeholder lines 
node algorithm traverses icdg backward paths starting predecessor placeholder identifies closest predicates reachable paths placeholder external predicates reached paths 
identify predicates traversal path terminates reaches control dependence edge source entry node return node 
algorithm uses worklist traverse icdg marks nodes visited 
node control dependent placeholder algorithm initiates icdg traversal marking icdg nodes unvisited line initializing worklist adding placeholder predecessors worklist line 
initialization algorithm traverses icdg removing node worklist processing worklist empty lines 
algorithm removes node worklist line examines predecessors icdg lines 
predecessor predicate node algorithm identified control dependence node algorithm adds set control dependences node line terminates traversal icdg path 
example process node control dependent return node algorithm initializes node worklist 
algorithm traverses path icdg identifies node predicate node control dependent 
example process node control dependent entry node algorithm traverses icdg backward paths starting node identifies node predicate node control dependent 
algorithm processed node control dependent placeholder identified node external predicates node control dependent 
algorithm builds returns set interprocedural control dependences program lines 
complexity algorithm 
cost algorithm computing interprocedural control dependences determined costs phases algorithm computeintercd 
step invokes procedure sites identifies removes unreachable nodes icfg cfgs identifies 
number nodes edges respectively icfg 
procedure identifies performs depth traversal icfg cost 
classify acm transactions software engineering methodology vol 
april 
sinha callsites removes unreachable nodes icfg cfgs accomplished time linear sizes graphs 
list halt nodes call nodes identifies 
procedure identifies traverses icfg halt node call node 
number halt nodes call nodes respectively program 
cost 
step creates acfg computes partial control dependences procedure 
number nodes edges cfg number procedure 
cost constructing acfg 
constructing acfg step calculates partial control dependences applying existing technique control dependence computation bilardi pingali cytron ferrante pingali bilardi acfg procedure 
costs techniques vary linear bilardi pingali pingali bilardi quadratic cytron ferrante size graph applied 
computeintercd traverses icdg node control dependent placeholder traversal linear size icdg 
number nodes icdg number edges icdg pl number icdg nodes control dependent placeholder 
worst case complexity computeintercd pl 
correctness algorithm 
algorithm computes interprocedural control dependences summarizing statement control dependences exist different calling contexts statement iifg 
demonstrate correctness algorithm show algorithm computes statement control dependences computed alternative approach constructs iifg applies traditional algorithm control dependence computation iifg summarizes control dependences statement nodeset relations 
structure proof follows 
classify paths iifg sequences call return edges appear paths 
characterize paths icdg traversed algorithm 
considering types path iifg interprocedural control dependence relation occurs types paths traversed algorithm prove theorem 
appendix provides outline proof details proof sinha 
theorem 
iifg program nodes statements nodeset acm transactions software engineering methodology vol 
april 
interprocedural control dependence nodeset 
control dependent computeintercd identifies control dependent summary approaches computing interprocedural control dependences approach computes context control dependences second computes statement control dependences 
approaches lie spectrum approaches compute interprocedural control dependences various degrees context sensitivity 
context approach expands calling contexts statement computes distinct control dependences statement calling context 
statement approach summarizes calling contexts statement computes single set control dependences statement 
approaches intermediate may selectively expand calling context procedure atkinson griswold compute control dependences varying degrees precision efficiency 
ability approaches compute interprocedural control dependences safely evaluated definition interprocedural control dependence 

empirical evaluation evaluate algorithm conducted empirical studies implementations computeintercd 
obtain cfgs intraprocedural control dependence information required studies analysis tools provided aristotle analysis system harrold rothermel control dependence analyzer aristotle analysis system implements control dependence algorithm described ferrante 
programs listed table iv studies 
efficiency interprocedural control dependence computation goal study evaluate performance computeintercd practice 
recall complexity computeintercd pl npl number icdg nodes partial control dependences include placeholder number nodes edges respectively icdg 
resolve control dependences nodes represented npl computeintercd traverses icdg starting nodes 
presents data percentage nodes partial control dependences include entry return placeholder 
number top bar total number nodes icdg program 
programs diff flex space contain statically unreachable statements programs number icdg nodes number nodes cfgs listed table phase algorithm identifies removes nodes acm transactions software engineering methodology vol 
april 
sinha dejavu diff flex space nodes partial control dependences include placeholder nodes partial control dependences include predicates fig 

percentage nodes partial control dependences include entry return node icdg nodes processed computeintercd 
correspond statically unreachable statements 
percentage nodes partial control dependences include placeholder range flex 
average icdg nodes control dependent placeholder 
second factor cost equation measures percentage icdg traversed computeintercd resolving node control dependent placeholder 
theoretically computeintercd traverse entire icdg processing node practice expect traverse fraction icdg 
test hypothesis gathered data percentage icdg nodes edges traversed algorithm processing nodes partial control dependences include placeholder 
presents percentage icdg nodes edges traversed computeintercd bar represents proportion icdg nodes edges traversed averaged nodes processed computeintercd 
illustrates program computeintercd traverses fewer percent nodes edges icdg average highest low 
result strongly supports belief quadratic worst case performance computeintercd may realized practice computeintercd may scale large programs 
shows percentage icdg traversed average program illustrate distribution percentages 
scatter plot left illustrates distribution percentages shows node processed computeintercd percentage icdg traversed 
data points scatter plot correspond nodes processed computeintercd 
cluster points bottom plot illustrates algorithm traverses small fraction icdg acm transactions software engineering methodology vol 
april 
unzip percentage icdg nodes edges traversed average dejavu diff flex fig 

percentage nodes edges icdg traversed average computeintercd nodes partial control dependences include placeholder 
percentage icdg node edges traversed nodes 
node algorithm traverses icdg nodes edges 
segmented bar right provides different view data partitions nodes percentage icdg nodes edges traversed computeintercd 
shows nodes computeintercd traverses icdg nodes edges 
differences intraprocedural interprocedural control dependences goal second study examine extent interprocedural control dependences computed second approach differ interprocedural control dependence space nodes partial control dependences include placeholder unzip percentage icdg nodes edges traversed fig 

percentage nodes edges icdg traversed computeintercd node partial control dependences include placeholder left percentage nodes computeintercd traverses various percentages icdg nodes edges right 
acm transactions software engineering methodology vol 
april 
sinha dejavu diff flex space statically unreachable nodes intraprocedural control dependences computed applying traditional algorithm computing control dependences bilardi pingali cytron ferrante pingali bilardi cfg program 
intraprocedural control dependence computation consider effects interactions procedures control dependences 
intraprocedural control dependences exclude dependences exist interactions procedures interprocedural control dependences include dependences 
intraprocedural control dependences contain spurious control dependences dependences exist interactions procedures considered interprocedural control dependences exclude dependences 
intraprocedural control dependences include dependences computed interprocedural control dependence computation common control dependences unaffected interactions procedures 
shows percentage icfg nodes control dependences affected interactions procedures nodes different intraprocedural interprocedural control dependences 
numbers top bars number icfg nodes mentioned earlier implementation control dependence algorithm described ferrante empirical studies 
algorithms bilardi pingali cytron pingali bilardi compute control dependences applied cfgs discussion section applies algorithms 
cases intraprocedural control dependence computation identifies statement control dependent entry procedure statement belongs interprocedural control dependence computation identifies statement control dependent entry program 
empirical results reported section considered control dependences common control dependences 
unzip nodes intraprocedural interprocedural control dependences differ nodes intraprocedural interprocedural control dependences fig 

percentage icfg nodes intraprocedural interprocedural control dependences differ 
acm transactions software engineering methodology vol 
april 
dejavu dejavu diff diff flex flex space space interprocedural control dependences missed intraprocedural context interprocedural control dependences computed intraprocedural context control dependence edge unbalanced left control dependence path unbalanced right control dependence path unbalanced right left control dependence path excluding entry exit nodes respective programs 
shows percentage nodes statically unreachable nodes occur diff flex space 
percentage nodes control dependences differ ranges dejavu 
average control dependences nodes differ 
presents data interprocedural control dependences computed programs 
graph top shows percentages interprocedural control dependences computed interprocedural control dependence computation computed intraprocedural control dependence computation 
number top bar total number interprocedural control dependences computed program 
percentage control dependences missed intraprocedural control dependence computation ranges dejavu 
average unzip interprocedural control dependence unzip interprocedural control dependences computed interprocedural context fig 

percentage interprocedural control dependences missed intraprocedural control dependence computation top classification control dependences type path icdg computed bottom 
acm transactions software engineering methodology vol 
april 
sinha interprocedural control dependences missed intraprocedural control dependence computation 
control dependence missed intraprocedural computation computed received input computeintercd computeintercd control dependence path icdg 
intuitively control dependence path icdg path predicate node node control dependent placeholder 
control dependence path crosses procedure boundaries contains call return edges 
sequence call return edges control dependence path contain call edges path unbalanced left control dependence path return edges path unbalanced right path subsequence contains return edges followed subsequence contains call edges path unbalanced right left path 
control dependences computed unbalanced left control dependence paths caused call relations procedures control dependences computed computation unbalanced right unbalanced control dependence paths caused effects 
graph bottom classifies missed control dependences criteria 
shows percentage missed control dependences computed represented control dependence edges icdg computeintercd different types control dependence paths 
number top bar total number missed control dependences program number represented percentage darker segment graph top 
data illustrate small fraction missed interprocedural control dependences identified partial control dependence computation average percentage control dependences 
percentage missed control dependences computed unbalanced left paths ranges 
average missed control dependences computed unbalanced left paths caused call relations procedures 
remaining missed control dependences caused effects computed unbalanced right paths computed unbalanced right left paths 
presents data intraprocedural control dependences computed programs 
data illustrate extent intraprocedural control dependences include spurious dependences 
graph top shows percentages intraprocedural control dependences computed intraprocedural control dependence computation computed interprocedural control dependence computation 
number top bar total number intraprocedural control dependences computed see appendix formal definitions control dependence paths types 
acm transactions software engineering methodology vol 
april 
dejavu dejavu diff diff flex flex space space intraprocedural control dependences computed intraprocedural context intraprocedural control dependences computed interprocedural context intraprocedural control dependences computed intraprocedural context represent program 
percentage spurious control dependences ranges dejavu 
average intraprocedural control dependences spurious dependences exist interactions procedures considered 
graph bottom classifies spurious control dependences semantic interpretation control dependences 
spurious control dependence computed intraprocedural control dependence computation 
statement procedure control dependent control dependence relation spurious 
control dependence relation predicate entry predicate relation clearly spurious provides misleading information control execution entry control dependence relation provide information misleading incomplete 
suppose entry unzip interprocedural control dependence unzip spurious control dependences incomplete control dependences fig 

percentage intraprocedural control dependences computed intraprocedural control dependence computation top classification control dependences bottom 
acm transactions software engineering methodology vol 
april 
sinha intraprocedural control dependence relation equivalent stating control enters procedure definitely reached 
statement valid interprocedural context interprocedural control dependences computed unbalanced left unbalanced right left paths 
cases external predicates control execution valid say control enters definitely reached 
cases intraprocedural control dependence relation provide misleading information provides incomplete information 
graph bottom classifies intraprocedural control dependences spurious incomplete 
graph illustrates diff flex considerable percentage intraprocedural control dependences spurious diff flex 
average intraprocedural control dependences spurious 

related definitions control dependence appear frequently research literature bilardi pingali cytron ferrante loyall mathisen pingali bilardi podgurski clarke 
cases exception definition loyall mathisen discussed definitions stated terms relationships nodes flow graphs described representing programs definitions seldom explicitly describe way graphs represent programs built interacting procedures 
example podgurski clarke state definition control flow graph represent procedural program definition applies class syntactic semantic relationship hold see appendix details 
definition clarifies application podgurski clarke flow graph definitions control dependence interprocedural setting 
various algorithms calculating control dependences exist maccabe bilardi pingali cytron ferrante harrold rothermel loyall mathisen 
algorithms maccabe harrold rothermel operate syntax trees individual procedures strictly intraprocedural 
algorithms operate control flow graphs 
shown algorithms applied independently controlflow graphs individual procedures program accounting context procedures invoked algorithms calculate control dependences manner support syntactic semantic relationship 
alternatively iifg algorithms calculate correct control dependences nonrecursive acm transactions software engineering methodology vol 
april 
interprocedural control dependence programs size iifg may exponential program size application may inefficient 
loyall mathisen define interprocedural control dependence 
define interprocedural walk icfg sequence nodes represent realizable path node said postdominate node interprocedural walk exit node icfg contains control dependence defined manner similar definition 
definition support syntactic semantic relationship 
see refer consider version sum created substituting alternative version line substituting alternative version line version contains calls halts assuming normal termination reaching statement 
consider icfg version sum pictured easily constructed icfg replacing node alternative version adding edge node node 
icfg unconditional calls node node nodes occur realizable path successors node 
loyall mathisen definitions nodes postdominate successors control dependent node 
podgurski clarke definition semantic dependence nodes semantically dependent node condition node determines control call number times statements execute 
case loyall mathisen definitions control dependence support syntactic semantic relationship 
loyall mathisen extend basic definitions summarized account presence embedded halts 
extended definitions utilize icfg halt nodes connected unique icfg exit node believe correctly identify effects halts control dependences cases effect interact multiple context effect 
extended definition circumvent difficulty described extended definition support syntactic semantic relationship 
loyall mathisen provide algorithm calculating interprocedural control dependences nodes statements goal define calculate control dependence procedures definitions interprocedural control dependence nodes define control dependence procedures 
definition procedure control dependent procedure exists node portion icfg associated node portion icfg associated control dependent icfg loyall mathisen form merges call return nodes affect argument 
acm transactions software engineering methodology vol 
april 
sinha loyall mathisen provide algorithm calculating control dependences calculating node level dependences 
procedure level dependence focus observe algorithm drawbacks 
procedure level control dependences calculated loyall mathisen algorithm conflict identified definition 
example applied version sum contain embedded halt loyall mathisen definitions imply nodes control dependent predicate postdominate successors predicate second unconditional call node 
loyall mathisen algorithm identify procedure control dependent procedure basis existence conditional call case believe general algorithm calculating procedure level control dependences accommodate multiple context effect programs contain embedded halts 
second drawback loyall mathisen algorithm accommodate embedded halt effect 
algorithm incorrectly identify control dependences procedures programs contain halts 
example sum second call node control dependent predicate node due embedded halt node node control dependent predicate node 
loyall mathisen definition procedure level control dependence control dependent similar reasoning shows definition control dependent loyall mathisen algorithm identifies procedure level control dependences 

primary contributions article 
article identifies discusses ways control dependences calculated correctly represent control dependences exist programs 
second article presents precise definition interprocedural control dependence supports syntactic semantic relationship 
third article presents approaches computing interprocedural control dependences approach computes precise interprocedural control dependences may inordinately expensive approach efficiently obtains conservative estimate dependences 
interprocedural control dependences useful applications software testing maintenance 
example partial control dependences computed phase algorithm interprocedural slicing algorithm account correctly interprocedural control dependences programs contain embedded halts harrold ci 
example statement interprocedural control dependences computed algorithm calculate dependences loyall mathisen provide higher level acm transactions software engineering methodology vol 
april 
interprocedural control dependence view dependences statement dependences program comprehension debugging impact analysis 
approach computing interprocedural control dependences distinguishes calling context procedure invoked computes distinct control dependences calling context 
compute control dependences approach inlines called procedure call site constructs representation exponential size program 
study effects inlining see shows programs resulting representation excessively large cause approach impractical 
programs representation grows factors program size programs approach may applicable 
experiments study effects procedure inlining evaluate performance traditional control dependence algorithms bilardi pingali cytron ferrante pingali bilardi inlined representations help establish parameters determine feasibility applicability approach 
second approach computing interprocedural control dependences distinguish calling contexts procedure invoked compute control dependences efficiently 
applications computation procedure level control dependence loss information causes imprecision analysis results 
intend investigate precision lost going context approach statement approach effects loss precision analysis techniques 
embedded halts belong generally class constructs cause arbitrary interprocedural transfer control practical programs includes constructs exception handling interprocedural jumps 
definition interprocedural control dependence applies programs contain constructs 
current includes investigation effects constructs interprocedural control dependence computation analysis techniques sinha harrold sinha aim generalizing results article constructs cause arbitrary interprocedural transfer control :10.1.1.24.1219
believe definitions extend weak control dependence podgurski clarke define interprocedural control dependences preserve relationship weak syntactic dependence possibly demonstrated semantic dependence demonstrated podgurski clarke 
investigate extension relationship results generalized control dependence bilardi pingali 
acm transactions software engineering methodology vol 
april 
sinha appendix flow graphs interprocedural control dependence syntactic semantic relationship podgurski clarke define control flow graphs follows 
control flow graph directed graph satisfies conditions maximum degree nodes restriction simplicity 
contains distinguished nodes initial node ne degree zero final node nx degree zero 
node occurs ne nx walk 
podgurski clarke state definition control flow graph somewhat restricted simplify presentation represent procedural program 
employing straightforward representation conventions involving dummy vertices arcs stated definition control flow graph fails exclude class definitions postdominance control dependence syntactic semantic relationship hold 
specifically consider set programs contain unreachable code procedures called twice 
icfg programs meets conditions control flow graphs stated 
podgurski clarke definitions postdominance control dependence applied icfg example program effect described section multiple context effect results nodes semantically dependent node control dependent node postdominate successor node 
closer examination podgurski clarke focusing particularly proof syntactic semantic relationship clear podgurski clarke require additional properties control flow graphs stated definition cited 
authors define context con wv node respect initial walk wv def graph du directed tree represents cumulative flow data refer reader podgurski clarke details idea context node walk wv discussion section drawn directly podgurski clarke 
simplicity reproducing discussion retain term walk discussion refer path 
podgurski clarke term context different sense 
usage pertains sequence procedure calls lead particular procedure call 
avoid unnecessary complications presenting discussion retain usage term 
acm transactions software engineering methodology vol 
april 
interprocedural control dependence similar set symbolic values held variables set node walk wv 
authors define ordinary walk graph infinite walk 
consistent occurrences decision node context followed different successors context node determines values variables set node walk node executed context determines branch taken node executable consistent 
authors define pair reciprocally consistent informally fact diverge pair nodes implies contexts differ nodes node interpretation changed causes difference 
notions consistency reciprocal consistency central podgurski clarke proof syntactic semantic relationship 
properly support notions 
exit nodes predicate nodes may multiple successors 
direction control flow nodes determined solely context nodes determined identity call node exiting procedure invoked 
exit node icfg may occur twice times context case followed different successor 
executable icfg need consistent podgurski clarke proof apply 
contrast iifg procedures inlined support notions consistency reciprocal consistency explicitly depicts control flow exit nodes successors identical flow graphs defined podgurski clarke 
fact possess properties graphs allow podgurski clarke prove theorem implies proofs apply 
state definition iifg interprocedural control dependence corrects deficiencies podgurski clarke unduly strong definition intended exclude natural extension graphs interprocedural context iifg 
appropriate say definitions clarify correct podgurski clarke definitions control dependence application definitions interprocedural control dependence 
proof correctness algorithm computing statement interprocedural control dependences algorithm computes statement interprocedural control dependences summarizing statement control dependences exist different contexts statement iifg 
demonstrate correctness algorithm show algorithm computes statement control dependences computed alternative approach constructs iifg applies traditional algorithm acm transactions software engineering methodology vol 
april 
sinha control dependence computation iifg summarizes control dependences statement nodeset relations 
outline proof details proof sinha 
structure proof follows 
classify paths iifg 
characterize paths icdg traversed algorithm 
show cases control dependence relation occurs certain type path iifg exists corresponding path icdg traversed algorithm algorithm traverses certain type path icdg exists control dependence relation corresponding type path iifg 
classify iifg paths sequences call return edges appear paths previous reps defined paths icfg 
path iifg level path call edge path matched return edge 
level path represents execution sequence begins ends cfg depth call stack path 
path unbalanced left path contains call edge matched return edge 
unbalanced left path represents execution sequence procedure calls completed call stack deeper path 
path unbalanced right path contains return edge preceded matching call edge 
unbalanced right path represents execution sequence procedure calls complete sequence led invocations procedures part path call stack shallower unbalanced right path 
path unbalanced right left path contains unbalanced right subpath followed unbalanced left subpath 
follows definition iifg path iifg level path unbalanced left path unbalanced right path unbalanced right left path 
lemma shows path nodes iifg type 
lemma 
iifg nodes set paths type 
proof 
proof considers types paths shows paths type 
proof uses properties iifg iifg different copy cfg inlined call site iifg contains interprocedural cycles caused recursion sinha 
characterize paths icdg traversed compute 
segment icdg path acm transactions software engineering methodology vol 
april 

read 
sum 
enter 

call 
return 
return 
call 
exit 
print sum control dependence predicate control dependence placeholder interprocedural control flow edge call return edge edge placeholder control dependence edge 
entry placeholder segment placeholder segment call edge entry placeholder 
return placeholder segment placeholder segment return edge return placeholder 
control dependence path icdg path ps ps ps ps placeholder segment edge predicate control dependence edge 
control dependence path composed control dependence edge followed placeholder segments 
illustrates control dependence path icdg sum path consists return placeholder segments 
paths iifg classify control dependence paths calls returns appear paths 
unbalanced left control dependence path contains unmatched call edges placeholder segment path entry placeholder segment 
unbalanced right control dependence path contains unmatched return edges placeholder segment path return placeholder segment 
unbalanced right left control dependence path unbalanced right control dependence path followed entry placeholder segments 
example path shown unbalanced right control dependence path 
lemma shows computeintercd traverses control dependence paths icdg 
notation represents concatenation paths node path node path 
interprocedural control dependence 
call 
exit 
enter 
sum sum 
halt 
return 

enter 

sum 
read 
exit fig 

unbalanced right control dependence path icdg sum 
path consists return placeholder segments 
acm transactions software engineering methodology vol 
april 
sinha lemma 
icdg 
exists control dependence path computeintercd traverses 
proof 
proof states control dependence path incident node control dependent placeholder computeintercd processes node control dependent placeholder 
proof shows processing node control dependent placeholder computeintercd traverses control dependence path incident node 
path traversed computeintercd starts node control dependent placeholder 
depending node control dependent entry return placeholder proof shows properties control dependence path path traversed computeintercd unbalanced left unbalanced right unbalanced right left path sinha 
lemma shows postdominance relation nodes belong cfg iifg preserved corresponding acfg 
lemma 
iifg nodes cfg acfg corresponds nodes correspond respectively 
postdominates postdominates proof 
suppose postdominates show postdominates proof uses contraposition assumes postdominate shows causes postdominate ifu postdominate exists sx path sx appear path 
proof considers cases contains node represents call site shows case exists path exit node contain sinha 
proof shows contrapositive implication true assumes postdominate shows causes postdominate postdominate exists path exit node contain proof considers cases contains call site contains definitely returning call site contains shows case exists sx path contain sinha 
lemma 
gi iifg program nodes gi set paths path level path 
gd icdg nodes gd acm transactions software engineering methodology vol 
april 
interprocedural control dependence correspond respectively 
control dependent exists edge proof 
level path belong cfg acfg lemma postdominance relation nodes equivalent postdominance relation corresponding nodes consequence lemma node belonging postdominate node belonging corresponding nodes relation 
easy show control dependent control dependent equivalently exists edge sinha 
lemma 
iifg program nodes set paths icdg nodes correspond respectively 
path unbalanced right path 
control dependent exists unbalanced right path 
path unbalanced left path 
control dependent exists unbalanced left path 
path unbalanced right left path 
control dependent exists unbalanced control dependence path proof 
suppose control dependent show exists path proof shows induction number unmatched returns exists corresponding path brevity outline basis step proof 
basis step 
contains single unmatched return 
exit node return node respectively source target unmatched return edge 
corresponding icdg nodes 
proof basis step proceeds follows 
proof shows control dependent belong acfg lemma control dependent contains edge 
proof shows exists edge follows lemma construction acfg 
proof shows exists return edge concatenating edges yields unbalanced right control dependence path 
inductive hypothesis acm transactions software engineering methodology vol 
april 
sinha proof assumes contains unmatched returns exists corresponding unbalanced right control dependence path gd inductive step proof shows number unmatched returns increases exists corresponding unbalanced right control dependence path gd sinha 
suppose exists unbalanced right control dependence path node node gd show control dependent gi case proof uses induction number return placeholder segments sinha 
proof proceeds similar manner see sinha details 
proof theorem follows directly preceding lemmas 
control dependence relation control dependent iifg lemma establishes types paths 
proof considers types shows case exists corresponding control dependence edge lemma corresponding control dependence path lemma icdg algorithm traverses edge path sinha 
control dependence relation control dependent computed algorithm relation computed compute computeintercd receives relation input computeintercd control dependence path lemma 
results lemmas proof shows exist corresponding control dependence relation iifg sinha 
acknowledgments jim jones help development implementation computeintercd 
anonymous reviewers provided useful feedback improved article 
atkinson griswold 
design program analysis tools 
proceedings th international conference software engineering icse berlin germany mar rombach chair 
ieee computer society press los alamitos ca 
maccabe 
program dependence graphs rest 
tech 
rep nov university new mexico albuquerque nm 
bilardi pingali 
framework generalized control dependence 
proceedings acm sigplan conference programming language design implementation pldi philadelphia pa may fischer chair 
acm press new york ny 
binkley 
semantic differencing reduce cost regression testing 
proceedings conference software maintenance nov 

cooper kennedy 
interprocedural side effect analysis linear time 
proceedings acm sigplan conference programming language design acm transactions software engineering methodology vol 
april 
interprocedural control dependence implementation pldi atlanta ga june wexelblat ed 
acm press new york ny 
cytron ferrante rosen wegman zadeck 
efficiently computing static single assignment form control dependence graph 
acm trans 
program 
lang 
syst 
oct 
emami ghiya hendren 
context sensitive interprocedural points analysis presence function pointers 
proceedings acm sigplan conference programming language design implementation pldi orlando fl june sarkar ryder soffa chairs 
acm press new york ny 
ferrante ottenstein warren 
program dependence graph optimization 
acm trans 
program 
lang 
syst 
july 
harrold ci 
reuse driven interprocedural slicing 
proceedings th international conference software engineering icse kyoto japan apr 
ieee press piscataway nj 
harrold rothermel 
syntax directed construction program dependence graphs 
osu tr 
ohio state university columbus oh 
harrold rothermel 
aristotle system research development program analysis tools 
osu tr 
ohio state university columbus oh 
harrold soffa 
efficient computation interprocedural chains 
acm trans 
program 
lang 
syst 
mar 
harrold rothermel sinha 
computation interprocedural control dependence 
proceedings acm sigsoft international symposium software testing analysis issta clearwater beach fl mar tracz ed 
acm press new york ny 
horwitz prins reps 
integrating noninterfering versions programs 
acm trans 
program 
lang 
syst 
july 
hutchins foster ostrand 
experiments effectiveness dataflow controlflow test adequacy criteria 
proceedings th international conference software engineering icse sorrento italy may osterweil van lamsweerde chairs 
ieee computer society press los alamitos ca 
landi ryder 
safe approximate algorithm interprocedural pointer aliasing 
proceedings th acm sigplan conference programming language design implementation sigplan san francisco ca june wexelblat ed 
acm press new york ny 
loyall mathisen 
dependence analysis support software maintenance process 
proceedings conference software maintenance sept 

reps 
interprocedural path profiling 
tr sept 
computer science department univ wisconsin madison madison wi 
murphy notkin 
lightweight lexical source model extraction 
acm trans 
softw 
eng 
methodol 

pande landi ryder 
interprocedural def associations programs 
ieee trans 
softw 
eng 
may 
pingali bilardi 
optimal control dependence computation roman problem 
acm trans 
program 
lang 
syst 

podgurski 
significance program dependences software testing debugging maintenance 
ph dissertation 
university massachusetts press amherst ma 
podgurski clarke 
formal model program dependences implications software testing debugging maintenance 
ieee trans 
softw 
eng 
sep 
pollock soffa 
incremental version data flow analysis 
ieee trans 
softw 
eng 
dec 
acm transactions software engineering methodology vol 
april 
sinha reps horwitz sagiv 
precise interprocedural dataflow analysis graph reachability 
papers nd acm sigplan sigact symposium principles programming languages popl san francisco ca jan cytron lee chairs 
acm press new york ny 
rothermel harrold 
safe efficient regression test selection technique 
acm trans 
softw 
eng 
methodol 

ryder 
incremental data flow analysis algorithms 
acm trans 
program 
lang 
syst 
jan 
sharir pnueli 
approaches interprocedural data flow analysis 
program flow analysis theory applications muchnick jones eds 
prentice hall englewood cliffs nj 
sinha harrold 
analysis testing programs exception handling constructs 
ieee trans 
softw 
eng 
sept 
sinha harrold rothermel 
system dependence graph slicing programs arbitrary interprocedural control flow 
proceedings st international conference software engineering icse may 
ieee press piscataway nj 
sinha harrold rothermel 
interprocedural control dependence 
git cc june 
college computing georgia institute technology atlanta ga received january revised september accepted september acm transactions software engineering methodology vol 
april 
