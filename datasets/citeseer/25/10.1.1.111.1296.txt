static inference modes data dependencies logic programs saumya debray university arizona mode data dependency analyses find applications generation efficient exe code logic programs 
example mode information generate specialized unification instructions permissible detect determinacy functionality programs gen erate index structures intelligently reduce amount runtime tests systems support goal suspension integration logic functional languages 
data dependency information various source level optimizing transformations improve backtracking behavior parallelize logic programs 
describes proves correct algorithm static infer ence modes data dependencies program 
algorithm shown quite efficient pro grams commonly encountered practice 
categories subject descriptors software programming languages programming languages processors compilers optimization computing methodologies artificial intelli gence artificial intelligence deduction theorem proving logic programming 
general terms languages algorithms additional keywords phrases dataflow analysis static inference mode data dependency prolog author address department computer science university arizona tucson az 
kinds information particular interest generation efficient code logic pro grams mode information predicates data dependency information literals clause 
concerned static inference properties 
general logic programs directed sense concept input output arguments procedures 
argument may input output argument programs may executed forward backward direction 
case particular program predicate executed direction called particular set arguments bound input arguments set unbound put arguments 
traditionally information supplied programmer called mode declarations 
mode information finds different applications high performance logic programming sys tems 
generate specialized code unification efficient general purpose routines fewer cases take care 
mode information important detecting deterministic functional computations reduce program search effort 
generate index structures predicates intelligently 
systems support goal suspension variable instantiations mu prolog sicstus prolog mode informa tion reduce amount testing required determine goal suspended 
mode information important integrating logic functional programming languages 
data dependency information useful various optimizing transformations logic programs improving backtracking behavior programs parallelizing logic programs 
early mode inference static analysis done mellish cies variables propagate information regarding instantiation 
approach drawback builtin predicates handled precisely aliasing effects resulting unification taken account procedure produced erroneous results 
syntactic approach mode inference simple mode set proposed reddy connection transforming logic programs functional languages 
approach applied restricted class logic programs tended conservative 
accurate treatment global flow analysis described debray warren 
mode inference procedures related described bruynooghe mannila ukkonen 
bruynooghe discuss mode inference interpretation problem akin type inference suggest keeping track aliases variable sets variables sure aliases possible aliases ukkonen simple mode set essentially reddy focus algorithmic aspects analysis 
static inference data dependencies prolog programs investigated chang warren 
describe data dependency information parallelize prolog programs improve backtracking behavior incurring significant runtime overhead 
data dependency analysis investigated ukkonen discuss computational aspects algorithm analysis take mode information account propagating dependencies quite conservative 
ma relationship logic programs attribute grammars reason properties logic programs including modelling data dependencies reduction occur checks treatment reddy mode set input output containing ele ments 
debray considered incremental synthesis control strategies parallel logic programs mode data dependency information 
related includes flow analysis logic pro grams detect situations cyclic terms created unification involves reasoning aliasing behavior programs 
described ideas introduced important innovations 
significant treatment aliasing introduced retrospect safety criteria handle aliasing sound ad hoc overly conservative 
describes uniform treatment aliasing problems 
worst case complexity algorithm analyzed treatment 
suggests variant basic algorithm significantly superior worst case performance cost slight potential loss precision small class programs 
identify class programs called programs bounded variety contains programs encountered practice algorithms significantly better worst case performance 
related treatment aliasing bruynooghe pro pose information aliases variable maintained sets variables representing sure aliases possible aliases 
treatment lead precise analyses principle computational implications having maintain additional information unclear 
remainder organized follows section discusses preliminary concepts 
section discusses flow analysis algorithm section proves soundness discusses complexity 
section sketches variant basic algorithm significantly better worst case performance may precise predicates number different modes alias patterns 
section discusses applications mode data dependency information efficient execution logic programs 
section concludes summary 
formalization analysis interpretation appendix 

preliminaries 
language language considered essentially order predicate logic 
countable sets variables function symbols predicate symbols sets mutually disjoint 
function predicate symbol associated unique natural number called arity function predicate symbol arity said ary symbol 
ary function symbol referred con stant 
term variable constant compound term ary function symbol terms atom form ary predicate symbol terms clause logic program finite set possibly ordered literals atoms negations atoms 
clause called definite exactly positive literal positive literal called head clause remaining literals constitute body clause 
clause negative literals referred goal 
predicate definition assumed consist finite set possibly ordered definite clauses handling constructs negation con sidered 
logic program consists finite set predicate definitions 
meaning clause universal closure disjunction literals program conjunction clauses 
purposes analysis assumed module form exports set predicate definitions exports specifies predicates exported may called outside 
adhere syntax edinburgh prolog write clauses form read 

names variables written starting upper case letters predicate function symbols written starting lower case letters 
addition list head tail tl written tl empty list written 
meaning logic programs usually declaratively terms model theory order logic programs understood procedurally 
view predicate pro cedure defined clauses 
clause provides alternate definition procedure body 
terms head clause correspond formal parameters literal body clause corresponds procedure call 
parameter passing procedure calls generalized pat tern matching procedure called unification 
briefly terms unifiable sub terms variables occurring 
substitution called unifier 
example terms unifiable unifier 
usually general unifier unnecessary substitutions 
fundamental result logic programming terms unifiable general unifier unique upto variable renaming 
result unifying terms term produced applying general unifier 
terms consideration unifiable unification said fail 
implementations logic programming languages typically impose order evaluation clauses defining predicate literals clause 
example execution prolog pro gram follows textual order clauses literals 
execution begins goal query user sequence literals processed left right 
processing literal proceeds follows clauses predicate tried order head unifies literal 
remaining clauses predicate heads unify literal backtrack point created remember 
literals body clause executed textual left right order 
unification fails point execution backtracks backtrack point variables instantiated creation backtrack point tions undone clause tried 
process continues recursively literals processed completely case execution said succeed alterna tives left try case said fail 
remainder assumes prolog control strategy textual ordering clauses literals 
techniques described peculiar prolog adapted control strategies straightforward manner 
assumed predicates program static executable code available analysis compile time 
addition deletion clauses runtime primitives assert retract precluded dynamic construc tion goals executed call 
analysis programs static significantly complicated need estimate possible effects dynamic code issue scope detailed discussion 

modes mode predicate logic program assertion arguments input argu ments output arguments call predicate arising program 
different researchers considered different sets modes edinburgh prolog allows user specify mode argument bound unbound unknown consider modes ground unknown 
precise purposes consider set modes nv closed denotes set ground terms order language consideration don know denotes set terms denotes empty set free denotes set uninstantiated variables nv set nonvariable terms 
set modes slightly larger considered 
set forms complete lattice inclusion nv ordering induced inclusion denoted le corresponding join operation denoted lub set terms necessary specify find instantiation element best describes 
instantiation function defined follows definition instantiation set terms 
set terms containing ground terms instantiation set terms containing uninstantiated variables instantiation 
notice closure operator set terms 

comparing instantiations sets terms execution logic program terms progressively instantiated 
notion instantiated quite straightforward dealing individual terms term instantiated term substitution instance static analysis vari ables associated sets terms necessary lift order sets terms 
define unification sets terms denoted unify follows definition sets terms unify set terms pair unifiable terms general unifier seen terms instantiated result uni fying term define instantiation order sets terms denoted natural extension definition sets terms unify reader may verify defined transitive 
set terms consideration closed unification unifiable general unifier reflexive quasi order easily extended par tial order usual way sets terms relation equivalence relation quotient modulo partial order 
discussion follows concerns partial order 
understanding abuse notation slightly write partial order element mode set closed unification variable renaming follows partial total order nv join operation order written 

analysis framework analysis procedure principles interpretation 
essential idea analysis maintain information variable bindings point program 
information arguments call predicate information propagated clause predicate obtain description bindings call returns 
dataflow information maintained instantiation states representations describe terms variable clause bound point clause possible aliasing sharing information variables point 
reason call return necessary propagate information arguments call caller callee time call callee caller time return 
instantiation states describe bindings different variables clause natural variable names pass information clauses 
clauses variables renamed resolution 
handle somewhat different representation called instantiation pattern represent calls returns 
instantiation pattern tuple terms describes bindings different elements tuple possible dependencies variable names 
instantiation pattern describing call necessary specify compute effects unifying arguments call head clause 
done procedure takes instantiation state instantiation pattern tuple terms updates produce new instantiation state incorporates possible effects unifying tuple terms represented 
computation proceeds considering variables appearing tuple information dependencies variables propagate effects unification variables clause 
analysis assumed user specified predicates may called outside exported predicate instantiation patterns describe may called 
analysis begins calling patterns exported predicates 
predicate calling pattern clauses predicate analyzed propagating instantiation states literals clause 
yields instantiation patterns describing clause may succeed 
order propagate instantiation states clauses necessary analyze predicates called exported predicates 
repeated new calling success patterns predicate program point analysis terminates 
remainder section organized follows section defines notion instantiation states 
section discusses instantiation patterns 
followed section description unification simulated domain 
section describes flow analysis pro cedure 
section considers examples detail 
section sketches control constructs encountered logic programming languages may handled 
formal treatment analysis procedure interpretation appears appendix 

instantiation states execution logic program induces association point clause variables clause sets terms instantiated point 
sets terms arbitrarily large necessary finitely computable approximations static analysis purposes 
done elements mode set describe sets terms 
turns information dependencies variables maintained order handle unification correctly analysis 
behavior program summarized specifying program point description set terms variable clause instantiated point set variables depend 
summaries called instantiation states states short 
finite set variable names appearing clause referred program variables states clause defined program variables clause selected resolution goal variables renamed variable disjoint goal 
means variables runtime general dif ferent program variables compile time 
necessary ensure static analysis takes account possible renamings 
done notion activations clause computation variables renamed ing substitution resolution referred activation term vars set variables occurring definition definition instantiation state point clause mapping satisfying variable activation computation instantiated term point ii variable instantiated term point vars vars notion states extends arbitrary terms straightforward manner state term constant compound term nv domain instantiation states clause fixed specified 
scope confusion subscript dropped name state 
variable maps pair state said instantiation written straightforward abstraction denotational semantics languages see 
inst dependency set written deps 
instantiation component acts con straint terms variable instantiated runtime dependency set acts constraint allowing consider terms depend variables vari ables clause uninstantiated head unified call corresponding initial state variable mapped pair denoted example consider program 


assume called uninstantiated argument 
state program point literals indicating uninstantiated point may share variable subterm similarly 

representing calls returns describing predicate may called call may return necessary specify instantiation argument sharing variables different arguments 
variables clause renamed head unified call variable names natural way propagate sharing information calls returns 
symbolic representation called instantiation patterns patterns 
defined follows definition state tuple terms tn ti instantiation pattern pattern short induced 
pat example consider call state nv 
call represented pattern pat nv nv nv 
indicates argument call free variable shares variables second third arguments second argument non variable term shares variables third arguments 
instantiation patterns length ordered elementwise inclusion obvious way 
upper bound patterns defined similarly init lub lub lub th 
element pattern denoted 
share set written share set instantiation th 
element written inst confusion arise tuple terms state pattern pat inst describes instantiation share gives indices elements shares variables 
pattern call predicate referred calling pattern return call referred suc cess pattern call 
pattern said describe tuple terms instantiations sharing elements tuple terms consistent pattern definition pattern induced state describes tuple terms inst le deps deps 
abstracting unification static analysis bindings variables different points program clause described states 
necessary specify unification simulated states 
con sider variable occurring term instantiation state consideration assume unified term instantiation aliasing effects temporarily ignored instantiation resulting term larger unification 
proper subterm long vari able long instantiated proper subterm term resulting unification variable instantiation change 
set terms set proper subterms elements sub inst tion 
instantiation inherited variable occurring term unification function inherited inst defined follows definition term state inst variable occurring instantiation inherited unified term instantiation inherited inst inst sub inst function sub inst table sub inst nv example suppose term unified ground term variable state consideration 
nv value inherited inst sub inst nv sub inst says term instantiated result unification set denoted notice sound sense unification fail resulting instantiation contained general course simply consider instantiations describing effects unification dependencies variables taken account 
consider patterns representing tuples terms unified 
assume sake sim tuples terms share variables 
consider kth element unification elements shares variables share set share share set unification transitive closure may share relation expressed share sets patterns starting th 
elements 
described notion coupling closure denoted closure indices elements kth 
element may share variables unification closure 
formally defined follows definition consider patterns length coupling clo sure induced written closure defined set satisfying share closure ii closure share closure closure 
example consider unification tuple terms tuple variables uninstantiated aliased variable 
patterns tuples terms nv nv respectively 
value closure set indicating unification arguments share variables 
worth pointing known exactly tuples unified trivial dependencies resulting unification general unifier information easily obtained tuple terms 
analysis tuples consists arguments call return represented pattern 
precise form tuples terms known 
tuple terms partial information available substitutions obtained various program points approximated states 
reason computation coupling closures necessary reasoning unification 
position describe unification 
contexts unification dealt analysis time call unifying arguments call head clause time return call back unifying propagate effects return caller 
calls returns represented patterns cases structure tuples terms unified known represented pattern 
processing unification domain carried fol lows changes variable instantiations resulting unification derived dependencies variables account function unify init changes pro variables functions propagate deps propagates possible changes dependency sets propagate inst propagates possible changes instantiations vari ables dependency sets cleaned information variable groundness 
tn variable occ vars indices ele ments occurs 
function unify init defined follows definition consider state clause tuple terms pattern 
unify init state defined follows variable occ inherited inst occ deps closure pat occ occ 

function unify init returns pair consisting state set program variables state reflects effects unification variables clause account dependencies exist 
set variables returned consists variables tions changed step 
changes propagated account dependencies variables 
state returned unify init program variable clause consideration obtained considering instantiations inherited posi tion occurs tuple terms properties unification follows resulting instantiation inherited upper bound respect tion order possible aliased variable instantiation dependency set changes unification taken account point handled step functions propagate deps propagate inst 
dependency set computed fol lows possible elements share variables unification obtained closure 
indicates share variables jth 
element depended variable unification inferred depend unification 
dependency set unification obtained union dependency sets elements notice computing coupling closure case suffices consider index element occurs closure computes transitive closure starting set elements shares variables shares variable relation symmetric value coupling closure depend particular picked 
step describe propagation changes dependency sets instantiations result ing unification 
simplify presentation decompose step functions propagate deps propagates changes dependency sets propagate inst propagates changes instantiations variables 
changes dependency sets relatively easy characterize unify init state tuple terms pattern 
consider variable dependency set changes unify init computed may variable depends dependency set updated 
change dependency set propagated simply adding deps dependency set changes dependency sets computation unify init obtained coupling closures compute tran closure may share relation suffices repeat variable appearing dependency set necessary compute transitive closure compute updated dependency set function propagate deps defined follows definition state defined set program variables propagate deps state defined defined fol lows deps 
step propagate changes instantiations variables account dependencies variables 
suppose set variables inferred affected unification unify init propagate deps state obtained propagate deps consider variable 
depends subset possibly empty possibilities execution reach point 
possibilities depend variable runtime instantiation unaffected ii depends set variables variables uninstantiated unification instantiation unaffected unification iii depends variable inst variable depend nonvariable term inst nv combining cases follows structure mode set lub inst works 
ground term affected aliasing effects 
nv possibilities depend variable run time instantiation unaffected nv ii depend variables instantiation changes instantiations change case com cases ii follows nv lub nv 
argument similar nv case follows come great surprise case aliasing dependency effects difference variable consideration uninstantiated instantiation possible aliases changes 
case analysis function propagate inst defined follows definition state defined set variables propagate inst state defined defined follows variable inst 
final step clean dependency sets variables 
variable instantiation inferred ground share variables variable dependency set set deleted dependency set variable clause 
described function normalize definition state defined set program variables ground inst 
normalize state domain defined follows ground ground define function update state simulates unification domain state tuple terms pattern describes state resulting unification tuple terms described definition state defined set variables tuple terms variables pattern length update state state defined vc defined update state normalize propagate inst propagate deps unify init 
note propagation dependencies propagate deps depend instantiations variables propagation instantiations propagate inst depends dependency sets vari ables 
necessary ensure dependency sets variables properly updated applying propagate inst 
reason necessary apply propagate deps propagate inst 

propagating flow information module analyzed assumed form exports set predicate definitions exports set pairs cp specifying predicates exported program may called outside program predicate calling pattern cp may called outside program 
note exports may contain entry predicate called different calling patterns 
class queries user may ask program specified exports possible calling patterns fact encountered computations 
static analysis calling patterns predicate admissible 
similarly calling pattern predicate success patterns considered admissible correspond computations predicate starting call described calling pattern 
denote set pairs ary predicate program associate set callpat set admissible calling patterns relation associating calling pattern admissible success pattern 
module exports sets defined smallest sets satisfying exports callpat 
predicate program callpat clause program form 
state point immediately literal init ini tial state clause update state init cp pat callpat cp sp update state sp 
success pattern clause pat 
notice special provision required explicit unification predicate handled simply considering defined 
proceeding 
global data structures maintained algorithm consist worklist needs processing predicates processed predicate program tables callpat 
initially needs processing contains set predicates appearing exports 
exported predicate callpat contains calling patterns specified exports empty initially predicate program ini tially empty 
analysis begins call graph program constructed compute predicate set callers predicates call predicates clause program form 

set callers determine predicates new success pat tern analysis begins calling patterns specified exports proceeds follows predicates mentioned exports analyzed 
turn causes predicates called exported predicates analyzed 
repeated new calling success patterns obtained predicate point analysis terminates 
algorithm illustrated 
function create state set variables returns initial state state domain calling pattern cp cate clauses analyzed procedure analyse pred returns set success pat terns calling pattern 
cp callpat new calling pat tern case added callpat clause analyzed analyse clause 
set success patterns computed returned analyse pred 
cp callpat input program exports output tables callpat giving admissible calling success patterns predicate program respect set exported predicates external calling patterns specified exports 
method starting exported predicates iterate program new calling success patterns inferred predicate 
construct call graph determine predicate defined set callers predicates call 
initialization ary predicate defined create tables callpat initialized empty 
predicate mentioned exports add needs processing cp exports add cp callpat 
analysis needs processing element needs processing needs processing needs processing cp callpat od od 
analyse pred cp results extension table return value ignored algorithm mode data dependency analysis possibilities nonempty set success patterns corresponding calling pattern cp recomputed 
set returned directly 
ii success patterns corresponding calling pattern cp indicates cir possibility successful execution established 
case set success patterns returned 
strategy essentially maintaining extension table remember success patterns computed calling pattern 
shown extension tables leads execution strategy complete finite domains answers computation case implies success patterns corresponding calling pattern predicate computed finite time 
set success patterns computed calling pattern predicate retrieved invocations calling pattern expected time hashing calling pattern 
clause analyzed procedure analyse clause propagates states clause described returns set possible success patterns calling pattern 
actual propagation sets possible states body clause done procedure analyse body 
procedure takes set states clause recursively processes literals body literals left process point returns resulting set states 
processing literal consists state just literal compute calling pattern ii analyse pred compute corresponding success patterns cal ling pattern iii success patterns compute states just literal 
pro analyse pred analyse clause analyse body 
observations procedures worth making description function analyse pred clause predicate analyzed calling pattern 
desired straightforward add third argument function represent ing tuple arguments predicate analyse clauses heads unify tuple 
example consider program 


analyzing literal body clause predicate scheme supply analyse pred third argument representing tuple parameters literal 
analyzing clauses clauses head arguments unify tuple case second clause considered 
principle improve precision analysis somewhat 
experience programs usually encountered practice opinion benefits accruing extension may significant 
notice description analyse clause call function create state 
done primarily simplify presentation practice need create initial state clause repeatedly time analyzed 
created analysis associated clause 
clause processed initial state obtained simple lookup 
procedure analyse clause returns success patterns computed particular calling pattern 
possible consider variant algorithm returns new success pat terns obtained set new sp pseudo code analyse clause 
affect correctness algorithm larger number iterations may necessary compute fixpoint variant leading decreased efficiency 
correctness algorithm independent order elements set needs processing processed 
usually efficient process depth order maintain needs processing stack 
function analyse pred cp predicate analyzed cp calling pattern cp callpat return sp cp sp previously computed success patterns fi 
add cp callpat clause analyse clause cp od return function analyse clause cl cp cl clause analyzed cp calling pattern cl form body init create state set variables appearing cl update state init cp head unification analyse body body sp pat success patterns clause new sp cp sp sp sp cp sp new success patterns new sp fi 
add new sp add callers needs processing return sp function analyse body body body body clause set states body empty return fi 
body form od cp pat calling pattern analyse pred cp success patterns sp add update state sp od return analyse body functions analyse pred analyse clause analyse body 
useful heuristic analysis process non recursive clauses predicate recursive ones process facts unit clauses rules 
recursive clauses looking cycles call graph clause time taken proportional size call graph 
processing clauses manner increases likelihood finding solu tions extension table processing recursive calls need recomputed 
mode predicate computed easily set calling patterns callpat follows lub callpat mode 
compute data dependencies necessary maintain state program point 
literals independent state variable vars case deps vars 
symmetry dependence relation variables implies equivalent saying vars deps vars 

examples illustrate algorithm described give examples 
usual append pro gram illustrates recursion handled extension table second taken illus handling aliasing 
example consider program append append 
append 
assume user specified calling pattern predicate cp 
initially table callpat append contains cp append empty 
suppose clauses processed heuristic mentioned section facts rules nonrecursive rules recursive ones 
processing unit clause init 
state clause resulting unification head call update state init cp cp calling pattern 
show update state works step computation unify init init cp 

set variables instantiations change step 
functions propagate deps propagate inst effect state 
instantiation dependency set state resulting normalize 

success pattern clause sp pat 
tuple cp sp added append recursive clause pro cessed 
state resulting unification head call 
calling pattern literal body pat 
calling pattern callpat append success pattern append pattern sp 
pattern sp taken success pattern literal body state return update state sp 
reader may verify 
success pattern second clause obtained pat 
seen success pattern clause appropriate entry append 
sets calling success patterns change analysis terminates iteration 
mode append 
easy verify results obtained clauses processed opposite order recursive clause processed 
recursive call encountered append empty set success patterns returned 
unit clause processed success pattern entered append analyse clause adds callers append case just append set needs processing 
needs processing nonempty causing top level loop go itera tion 
second iteration success pattern unit clause propagated recur sive clause new success patterns iteration needs processing remains empty iteration algorithm terminates 
results obtained case additional iteration necessary propagate success pattern computed unit clause body recursive clause 
example consider aliasing example program 



assume exported predicate program user specified calling pattern 
pattern inserted callpat 
consider clause state th 
literal head counts th 
literal state resulting unification head call 
calling pattern added callpat 
clause analyzed state resulting unification head clause call success pattern call inferred 
state literal clause 
calling pattern literal success pattern case 
state literal update state 

unify init 
function propagate deps effect state propagate deps computation propagate inst dependency set instantiation instantiation set dependency set set normalization phase 
state 
calling pattern inferred success pattern state clause success pattern 
conservative sound 

handling control constructs connective considered far literals body clause sequential conjunction 
analysis purposes connectives disjunction denoted condition als denoted negation handled simply preprocessing phase transforms clauses form contains 
clause form transformed clause form transformed handling negation naive transformation take clause form yield simple transformation negations conservative success patterns clause considered reality calls negation affect success patterns way creation clause necessary ensure calling patterns obtained correctly 
analysis may sharpened observ ing clause predicate guaranteed fail success pattern set taken 
clause may transformed fail 
case presence fail transformed clause ensures clause affect success patterns 

soundness complexity 
soundness section discusses soundness flow analysis algorithm discussed 
show update state safely describes effects unification certain kinds terms 
followed proof states computed flow analysis procedure described sound 
evident previous section update state purposes unification head clause call back unification arguments return call 
head clause unified call terms unified variable dis joint case back unification return call returning argument tuple instance calling argument tuple contain variable calling clause calling argument tuples 
correctness proof restricts unification terms satisfy criteria referred call compatibility return compatibility 
terms call compatible variable disjoint return compatible respect set variables instance vars vars 
state defined set variables substitution set variables case inst ii vars vars implies deps deps said consistent consistent consistent variables defined said consistent definition lemma state defined set variables tuple terms variables substitution consistent pat describes 
box lemma shows update state correctly simulates unification domain calls returns lemma state defined set variables tuple terms vari ables substitution pattern length tuple terms described call compatible ii return compatible respect consistent unifiable general unifier comp con sistent update state 
proof lemma holds vacuously case unification fails 
assume unification succeeds 
call return compatible suffices consider variables occur ring unify init propagate deps propagate inst normalize update state 
variable 
clearly variable appears unaffected unification 
case comp 
consistent comp trivially consistent case lemma holds 
assume variable occurs inst consistent ground term affected successful unification share variables variable case follows definitions update state lemma holds 
consider case consider dependency set tn 
occurs indices elements share variables contained closure pat 
fol lows variable vars comp vars comp occurs closure pat 
definition update state deps 
occur variable vars comp vars comp ii case easy verify definition update state result unification ground term case consistent vars vars 
follows variable occurring deps dependent result unification 
case argued deps definition propagate deps deps 
propagate inst affect dependency set variable deps 
consider instantiation variable recall considering case inst propagate deps affect instantiations inst inst 
part proof lemma seen variable share variable deps 
case analysis definition propagate inst seen interesting case inst deps inst follows definition propagate inst case inst comp inst 
necessary take account effect function normalize 
definition seen effect normalize inst variable dependency set set deleted dependency set variables 
effect variables ground earlier variables apply state normalize update state 
shows variable comp inst ii vars comp vars comp deps 
comp consistent update state lemma follows 
box considering unification tuple terms tuple described pattern assumed effects unification described considering effects variables occurring propagating effects variables state consideration 
assumption hold compatibility requirements lemma violated 
see consider state consideration 
update state evident describes tuple terms result unifying reflected update state 
reason call compatible 
similarly consider state consideration 
update state unification aliases variables describes aliasing reflected update state 
problem case return compatible 
establish analysis algorithm sound necessary show computation legitimate call exported predicate module call predicate arise described tuple callpat return call described tuple 
follows directly fact established lemma unification calls returns handled correctly theorem soundness callpat represent admissible calling success patterns predicate module exports exports 
computation calling pattern call arise runtime calling pattern callpat describes call succeed arguments bound tuple terms success pattern pair describes proof induction number resolution steps computation 
consider call obtained resolution steps 
base case literal user query query form 
user query conform calling pattern specified exports user specified calling pattern exported predicate describes fol lows definition callpat callpat 
success patterns base case resolution step 
case query unit clause activation unifiable general unifier 
argu ments call success comp 
state head unification update state init 
lemma substitution comp consistent follows lemma success pattern pat describes comp 
comp follows describes theorem holds 
induction case assume theorem holds resolution steps consider call arises steps 
clause predicate called arguments certainly call obtained fewer resolution steps induction hypothesis pattern callpat describes callpat analysis algorithm processed clause calling pattern consider analysis activation clause calling pattern state immediately th 
literal clause head counts th literal substitution variables clause obtained point call sld resolution 
simplicity notation comp call considered 
show induction consistent general unifier arguments call head update state init 
base case follows lemma consistent suppose consistent consider clearly call obtained fewer resolution steps return call 
induction hypothesis theorem pattern cp pat callpat cp describes cp sp sp describes 
follows lemma consistent update state sp 
implies consistent calling pattern inferred pat consistent follows lemma describes part theorem holds 
inductive argument part theorem involving success patterns similar 
box algorithm terminates seen definition update state follows state tuple terms pattern length variable domain inst inst update state 
words instantiations variables nondecreasing 
mode set finite implies instantiation variable increase finite number values 
finite domains states nontermination possible dependency set variable variable enters leaves dependency set repeatedly 
seen definition update state time variable leaves dependency set variable zation step instantiation case instantiations variables ing reintroduced dependency set oscillations possible algorithm terminates 

complexity consider program predicates arity predicate clauses clause literals 
suppose variables clause 
tuple size computing pattern term state involves computing instantiation element tuple determining sharing variables involves determining terms tuple intersecting variable sets 
determining instantiation term may require examination instantiation variable occurring term may take time worst case determining instantiations terms tuple take av time 
pair terms determining dependency sets nonempty intersection take time 
pairs total time complexity pat av 
compute cost update state necessary determine costs unify init propagate deps propagate inst normalize 
worst case cost unify init obtained representing sets variables bit vectors appropriate data structures states instantiation term determined bit vector operations 
follows computation inherited inst takes time processing variable unify init involve computations inherited inst union operations 
done time cost 
computing coupling closure pat operation cost coupling closures computed straightforward transitive closure methods patterns size time taken compute coupling closure argument posi tion worst case 
total cost unify init may involve process ing variables 
propagate deps dependency set variable size worst case necessitating union operations variable operations altogether 
propagate inst dependency set variable may size worst case looking determine instantiation cost 
total cost processing variables 
normalize processing variable may involve unions total cost normalize worst case 
worst case time complexity update state 
processing clause involves applications pat applications update state 
seen cost pat dominated update state 
complexity processing clause la 
cost processing predicate calling pattern cla 
argument position predicate different instantiations possible total number instantiations possible predicate arity number possible share sets predicate number partitions set 
bell number total number calling success patterns possible simplicity notation write quantity 
extension tables predicate processed exactly particular calling success pattern success pattern predicate computed calling pattern invocations predicate calling pattern success pattern recomputed looked time 
total time complexity algorithm predicates program 
size term number symbols term number nodes tree representation 
size largest term clause size clause las size program 
variable clause account node tree representation clause lav las 
time complexity algorithm written na 
worst case complexity misleading reasons 
predicates program rarely exhibit possible calling success patterns 
typically predicate pro gram consistently arguments input arguments output arguments sort consistent usage mode analysis meaningful 
second reason analysis indicates algorithm worse exponential maximum arity predicate program arities predicates commonly encountered tend small big problem practice 
define program bounded variety number calling patterns predicate program bounded constant 
programs tered practice bounded variety 
programs number calling patterns predicate definition complexity algorithm reduces na 
practice arity number variables clause increase size pro gram increases 
practical purposes algorithm takes time linear size pro gram 

trading precision speed flow analysis algorithm developed previous section reasonably efficient programs encountered practice may occasions performs badly 
section discusses algorithm may modified improve worst case behavior 
may involve loss precision experience indicates programs encountered practice loss precision tends insignificant 
modification proposed affects tables callpat managed 
recall patterns le le value set patterns form complete lattice ordering patterns length find lub modified algorithm tables callpat contains entry predicate 
bottom bottom pattern length ini tially entry callpat ary predicate bottom bottom bottom 
call predicate calling pattern encountered entry 
le pattern returned success pattern call entry callpat replaced pattern lub flow analysis carried described calling pattern lub success pattern computed calling pattern entry replaced lub lub 
soundness algorithm follows algorithm described previous sec tion 
worst case complexity computed follows cost update state remains cost processing clauses predicate containing literals cla 
case number different calling patterns analysis carried far fewer predicate arity number different instantiations considered height le triangle flow analysis carried bottom patterns bottom initially callpat tables number different share sets possible predicate 
total number calling patterns may con sidered predicate arity previous case 
predicates program total cost new algorithm worst case na size program 
programs bounded variety number calling patterns complexity reduces na 
difficult set analysis system callpat tables predicates managed old algorithm managed new algorithm directed user 
yield spectrum analysis systems intermediate speed precision described tuned applica tion simple hints user 
point noted case treatment unification predicate defined lead substantial loss precision 
handled specially way head unification 

applications information regarding predicate modes data dependencies literals finds uses static optimization logic programs 
classic application mode information spe unification routines fewer cases test general unification algorithm efficient 
mode information important detecting deterministic functional com information regarding improve search behavior logic programs 
mode information important transformation logic programs functional languages 
mode information improve efficiency programs systems mu prolog sicstus prolog permit suspension certain goals depending instantiation variables runtime ascertained certain arguments predicate instantiated uninstantiated call mode analysis corresponding runtime tests eliminated leading faster code 
mode information generate index structures predicates intelligently example prolog compilers typically generate index argument predicate 
mode predicate indicates argu ment calls predicate uninstantiated argument instantiated intelligent compiler able generate index instantiated argument reducing amount shallow backtracking required 
application mode information clause fusion reduce amount ism predicate 
general clauses identical heads body body possible merge produce clause body body advantages doing body fails arguments call restored choice point unified head second clause index clauses predicate slightly smaller body body contain literals common may factored reduce amount redundant computation 
practice rarely case clauses predicate identical heads 
mode information cases transform heads manner allows fusion carried 
basic idea take output arguments mode move unification head body clause 
illustrated example example consider predicate part 
part part 
part part 
second third clauses predicate merged arguments heads differ 
know part mode clauses transformed produce part part 
part part 
point possible merge clauses 
noticing complementary literals imply bodies mutually exclusive generate transformed predicate defined part 
part part part 
transformed predicate create choice point predicate type test argument suffices discriminate clauses arithmetic comparison discriminate alternatives second clause 
knowledge data dependencies devise semi intelligent backtracking schemes pro grams incur runtime overhead intelligent backtracking 
parallelization programs 
related algorithm synthesize control strategies parallel logic programs 
data dependency information necessary various optimizing transformations logic programs recursion removal loop fusion code motion loops 
example illustrates application example consider predicate compute maximum minimum values binary tree leaves labelled integers maxmin max min maxval max minval min 
maxval leaf 
maxval tree max maxval maxval max max 
minval leaf 
minval tree min minval minval min min 
definition computation maxmin max min tree requires traversals tree 
unfold fold transformations fuse loops definition 
transforma tion begins unfolding literals maxval minval clause maxmin yields maxmin leaf 
maxmin tree max min maxval mx maxval mx max mx mx max minval mn minval mn min mn mn min 
literals shown independent data dependency analysis may rearranged provided relevant considerations termination satisfied 
yields maxmin leaf 
maxmin tree max min maxval mx minval mn maxval mx minval mn max mx mx max min mn mn min 
folding carried original definition maxmin yields definition maxmin leaf 
maxmin tree max min maxmin mx mn maxmin mx mn max mx mx max min mn mn min 
definition computation maxmin max min tree requires traversal predicates maxval minval program may discarded leading decrease code size 
crucial step transformation rearrangement literals data dependency information necessary ensure transformation change behavior program unacceptable ways altering producer consumer relationships literals 

mode data dependency information play important role compilation logic programs efficient executable code 
shows analyses combined 
describes mechanism managing dependencies variables uniform manner uses describe flow analysis algorithm proved sound 
yields algorithm precise efficient programs encountered practice 
variation algorithm described offers significantly superior worst case performance retaining precision efficiency com encountered programs 
applications mode data dependency information logic pro grams described 
comments anonymous referees helped improve contents presentation sub 

bruynooghe janssens interpretation global optimization prolog programs proc 
fourth ieee symposium logic programming san francisco ca sep 

chang despain degroot parallelism logic programs static data dependency analysis digest papers compcon ieee computer society feb 

chang despain semi intelligent backtracking prolog static data dependency analysis proc 
symposium logic programming boston july pp 


cousot cousot interpretation unified lattice model static analysis programs construction approximation fixpoints proc 
fourth annual acm symposium principles programming languages pp 


debray synthesizing control strategies parallel logic programs tech 
rep dept computer science university arizona tucson az may 

debray warren automatic mode inference logic programs logic programming sep pp 


debray unfold fold transformations loop optimization logic programs proc 
acm sigplan conference programming language design implementation atlanta ga june pp 

sigplan notices vol 

debray mishra denotational operational semantics prolog logic programming mar pp 


debray warren functional computations logic programs acm transactions programming languages systems july pp 


debray flow analysis dynamic logic programs logic programming sept pp 


ma relating logic programs attribute grammars logic programming july pp 


dietrich extension tables memo relations logic programming proc 
fourth ieee symposium logic programming san francisco ca sep pp 


janssens bruynooghe instance interpretation integrating type mode inferencing proc 
fifth international conference logic programming seattle aug pp 

mit press 

jones mycroft stepwise development operational denotational semantics prolog proc 
int 
symposium logic programming ieee computer society atlantic city new jersey feb 

mannila ukkonen flow analysis prolog programs proc 
fourth ieee symposium logic programming san francisco ca sep 

mellish automatic generation mode declarations prolog programs dai research dept artificial intelligence university edinburgh aug 

mellish global optimizations prolog compiler logic programming apr 

mellish interpretation prolog programs proc 
third international logic programming conference london july 
springer verlag lncs vol 


naish negation control prolog springer verlag 
lncs vol 


plaisted occur check problem prolog proc 
int 
symposium logic programming ieee computer society atlantic city new jersey feb pp 


reddy transformation logic programs functional programs proc 
int 
symposium logic programming ieee computer society atlantic city new jersey feb pp 


application interpretation logic programs occur check reduction proc 
esop saarbrucken mar 

sicstus prolog user manual swedish institute computer science sweden sep 

tamaki sato old resolution tabulation proc 
rd 
international conference logic programming london july 
springer verlag lncs vol 


van roy willems improving execution speed compiled prolog modes clause selection determinism proc 
tapsoft pisa italy mar 

warren implementing prolog compiling predicate logic programs research reports dept artificial intelligence university edinburgh 

warren hermenegildo debray practicality global flow analysis logic programs proc 
fifth international conference logic programming mit press seattle aug 
appendix mode data dependency analysis interpretation appendix casts mode data dependency analysis interpretation 
actual execution program program point associated set substitutions 
subst set substitutions concrete domain set subst forms complete lattice inclusion 
domain program disjoint sum domains clauses 
domain clause set states state denotes set program variables variables appearing program text simplicity notation discussion follows consider abstraction concretization functions single clause 
extension entire domain tedious conceptually straightforward construction involving usual injection projection operations 
set states state clause ordered follows state le variable inst le inst deps deps forms complete lattice ordering 
recall state defined set variables substitution said consistent inst ii vars vars deps 
abstraction function subst state defined follows definition set substitutions point clause state state consistent concretization function state subst defined follows definition state state subst consistent 
straightforward show monotonic adjoint 
consider sets substitutions definition member consistent implies member consistent 
state member consistent follows le monotonic 
states defined set variables le consider substitution consistent le inst le inst deps deps follows consistent implies 
establishes monotonic 
definition state element set substitutions consistent easy see largest set substitutions elements consistent state follows immediately adjoint 
remains show unification domain defined update state faithful unification concrete domain 
proof essentially lemma repeated 
completes formalization mode data dependency analysis interpretation 
box 
