optimal schedules monitoring anytime algorithms lev finkelstein shaul markovitch computer science department technion haifa israel lev cs technion ac il monitoring anytime algorithms significantly improve performance 
deals problem line construction monitoring schedules 
study model queries submitted monitored process order detect satisfaction goal predicate 
queries consume time monitored process delaying time satisfying goal condition 
formal model class problems provide theoretical analysis class optimal schedules 
introduce algorithm constructing optimal monitoring schedules prove correctness 
continue distribution analysis common distributions accompanied experimental results 
provide theoretical comparison methodology existing monitoring techniques 
example test scheduling problem points robot order test communication 
assume stations attempt communicate laser transmission 
stations visual contact establish direct communication 
decides send receiver transmitter robot hill illustrated 
robot initiate communication stations starting point visual contact stations 
robot order establish communication 
stops point lower able communicate measurements factors robot speed position ascertained precision time required robot arrive evaluated approximately 
robot various points test 
test requires constant time goal generate test schedule minimizes total time required establish communication 
possibility program robot time long guarantee high probability robot passed point problem approach average robot waste lot time traveling alternative approach program robot perform test 
approach allows robot detect reception area earlier time total time required establish communication large due overhead tests 
correct approach lies extremes 
possible compute test schedule guarantees average minimal total time 
example test scheduling problem prolog interpreter 
assume interpreter processes complex query offers solutions user execution 
user visually examines solution responds semicolon continue process period 
time system spends waiting human response adds total execution time 
assume estimate number solutions query time required generate 
assume interpreter extended allow presentation solution time specific solution user looking 
policy provides minimal expected total time processing query 
third example taken field computational learning 
assume goal concept learner pac learn concept probability gamma ffi infer hypothesis misclassification probability ffl 
assume know compute minimal number required examples ffl ffi 
assume learner allowed ask weak form equivalence queries ask teacher current hypothesis correct 
assuming cost query constant policy minimize total learning time 
examples common 
ffl agent executes process purpose satisfying goal predicate 
ffl goal predicate satisfied time lambda satisfied time lambda ffl process queried time goal predicate satisfied 
ffl query execution process halted 
ffl goal agent minimize total time spent process including time spent queries goal predicate known satisfied 
goal research develop algorithms design optimal query policy statistical characteristics process 
defining formal framework markovitch similar information increase efficiency prolog interpreter subgoal reordering 
information learned proving training queries 
learner infer example average number solutions query class parent var const 
regular equivalence queries require negative reply accompanied counterexample 
query scheduling algorithms 
framework assumes statistical profile describes probability goal condition satisfied function time 
profile similar probabilistic performance profiles restricted boolean quality values 
describe sequence intuitive query scheduling algorithms analyze strengths weaknesses 
continue general algorithm line calculation optimal query schedule prove optimality 
follow distribution analysis specializes algorithm uniform exponential normal distributions 
analysis accompanied solutions example problems including formal analysis experimental evaluation simulated data 
idea monitoring received little attention ai research community despite fact monitoring state algorithm significantly affect performance 
monitoring subtopic metalevel reasoning studied primarily context anytime algorithms contract algorithms 
potential benefit monitoring save computational resources monitored process 
monitoring carries cost 
brings interesting question monitoring performed optimize tradeoff costs benefits 
monitoring decisions viewed kind type ii rationality difference performance monitoring corresponds concept intrinsic utility 
dean boddy worked complicated setup sequence anytime algorithms 
assumed run time monitoring place concentrated problem finding fixed resource allocation algorithm starts 
call type monitoring deliberation scheduling 
main input works performance profiles measure tradeoff solution quality computation time 
horvitz studied line monitoring extensively context various application domains reformulation belief networks automated theorem proving 
proposed models process stops expected benefit halting higher expected benefit continuing computation 
domains described works higher degree uncertainty model proposed allowing myopic analysis tradeoffs involved 
protos system horvitz extended myopic horizon evc analysis lookahead fixed depth 
scheme avoids errors caused myopic analysis 
russell wefald describe model rational heuristic search 
propose anytime algorithm evaluating expected utility node expansion 
algorithm includes stopping criterion enhanced monitoring procedure tests stopping criterion fixed number node expansions 
instance class problems introduced 
detailed analysis approach section 
latest works zilberstein hansen provide theoretical framework wide range monitoring problems model multiple value quality high degree uncertainty 
section analyzes compares approach 
rest organized follows 
section describes intuitive approaches monitoring problem 
section formulates general framework 
sections describe algorithms generating optimal schedules 
section contains distribution specific analysis offers solutions problems experimental evaluation simulated data 
section shows results problem real data 
section discusses related section presents 
intuitive approaches problems described human produce common sense strategy 
assume facing scheduling problem query cost upper bound time goal reached 
section intuitive strategies show weaknesses 
output proposed methods sequence time points queries submitted 
possible methods representing schedule 
specify internal run time process include query processing time 
case point view expressed process 
method specify total elapsed time expressing point view external observer 
schedule represented method ht tni equivalent ht tn gamma second method 
adopt method representing schedules 
note regardless representation chosen goal minimize total elapsed time 
query strategy simplest common strategy query allocated time exhausted 
strategy requires total time approach problematic ffl input maximum allowed time ffl output ht query algorithm 
expected time satisfying goal predicate example classification learning algorithms accept set examples process get classifier 
learning time greater testing time required quality may achieved smaller set examples query algorithm may produce sub optimal behavior 
query delta strategy problem approach possible late detection goal condition 
alternative approach submit query delta time units delta small desirable 
delta get query strategy 
extreme query atomic operation algorithm 
policy solve problem late detection goal condition 
query cost high small delta detrimental benefit early detection goal criterion outweighed added costs queries 
notable exception windowing strategies proposed quinlan 
hypothesis generated portion examples 
learning continued classifier desired quality 
ffl input maximum allowed time interval delta ffl output delta delta delta delta ti 
query delta algorithm approach example prolog interpreters ask user confirmation solution 
extreme approach taken internet search engines usually return results user chunks 
query best times strategies querying carries danger late detection querying atomic operation carries risk high cumulative query cost reasonable strategy optimal number queries 
distribution function time goal predicate satisfied find number queries minimizes expected total time 
algorithm implementing approach call shown 
strategy especially ineffective ffl input maximal allowed time ffl algorithm 
denote tn tn tn gamma tn 
perform global minimization expected elapsed time 

set optimal value 
return tn tn amore formally minimize tn 
defined equation section 
strategy probability goal predicate satisfied uniformly distributed 
cases schedule non equal intervals yield better results optimal equal step schedule 
example distribution skewed reasonable query approaching case handled strategy equalizes probability goal predicate satisfied subsequent queries ti gamma ti gamma strategy call described 
problem approaches inability handle tasks limited time 
problem schedules produced methods optimal 
sections propose methodology constructing optimal schedules handle tasks 
ffl input maximal allowed time ffl algorithm 
denote tn df gamma gamma gamma gamma 
perform global minimization expected elapsed time process 

set optimal value 
return df gamma gamma strategy framework line query scheduling section formalize intuitive description query scheduling problem 
set states 
time variable non negative real values 
random process realization trajectory represents mapping goal predicate corresponds alse corresponds rue 
say monotonic trajectory function dga non decreasing function 
assumptions dga step function discontinuity point 
dga describes behavior goal predicate function time particular realization random process 
scheme resembles anytime algorithms 
goal predicate viewed special case quality measurement anytime algorithms requirement non decreasing value standard requirement algorithms 
trajectories correspond conditional performance profiles 
nature problem requires cost function utility function commonly anytime algorithms literature 
assume monotonic non decreasing function 
monotonic definitions show behavior trajectory described single point bta point goal predicate true bta 
dga say bta defined 
define random variable ia trajectory bta defined corresponds bta behavior described distribution function 
points differentiable probability density 
important note practice trajectory leads goal predicate satisfaction infinitely large time 
means set trajectories ta undefined necessarily measure zero 
define probability success probability bta defined 
problems time limit running time process 
call way express possibility process profiles approach gamma 
prefer explicitly order distribution function satisfy limt 
problems time limited 
call problems time unlimited define 
definition query procedure applied time performs actions 
suspends process 
computes goal predicate 
dga query resumes algorithm 
stopped 
time algorithm suspended denoted cost additional resources required single query application denoted assume expressed units 
current model assume non negative constants 
definition define schedule non decreasing sequence time points ht tni ht tk infinite case 
schedule way time point ti schedule query applied process starting 
goal predicate satisfied ti process stops 
process resumes 
procedure stops process stopped query case finite schedules tn passed 
framework assumes satisfying goal predicate useful detected query 
require element schedule time limited case implies tn addition definition query tn gamma process tn gamma 
observations lead constraints schedules time unlimited problems tn gamma tn definition define stopping time schedule respect process realization point lambda dga lambda lambda satisfies condition say lambda 
definition follows cost ua schedule process realization stopping point lambda tk ua tk ko kc note necessarily linear expression replaced tk 
ht tni finite schedule 
denote start time process 
distribution function probability success 
probability goal predicate satisfied time segment ti gamma ti equal ti gamma ti gamma 
cost associated event ti io ic 
probability goal predicate satisfied tn gamma pf tn case infinite schedules analyzed 
associated cost tn nc 
expected cost schedule respect eu eu tn nx ti io ic ti gamma ti gamma gamma pf tn tn nc denote eu 
convenient alternative formulation obtained simple regrouping terms eu tn tn nc gamma gamma ti gamma ti io ti goal find schedule minimal expected cost 
means choose number time schedule ht tni minimal 
minimize constraints 
definition schedule tn optimal respect minimizes value constraints tm gamma tm call corresponding value optimal expected value denote 
global optimal expected value defined inf 
exists schedule tn realizes tn call tn global optimal schedule denote topt 
schedule defined ffl optimal gamma ffl 
differentiable rewrite form eu tn nx ti ti gamma io ic dt gamma pf tn tn nc form specific case equation eu tn nx ti ti gamma ti dt gamma pf tn tn tn corresponding case depend example penalty set missing exact moment goal predicate holds 
lower limit expected schedule cost determines upper limit possible savings obtained setting 
tn dt gamma pf tn case represents pure line control queries resources 
section algorithm finding ffl optimal schedule time limited problems 
section describes similar algorithm time unlimited problems 
optimal scheduling algorithm time limited problems section algorithm finding ffl optimal schedule 
start proving necessary conditions schedule optimality continue theorem sufficient conditions existence global optimal schedule 
specify method finding element globally optimal schedule recursive formula construct rest sequence 
algorithm combines recursive formula standard single variable optimization method prove algorithm guaranteed find ffl optimal schedule 
properties optimal schedules analysis assume derivatives monotonic increasing function 
appendix show weaken assumptions 
addition assume zero 
assume probability success positive 
zero sense querying process 
assumption strictly smaller exists constant segment sense querying means condition strong 
necessary conditions schedule optimality proceed main theorem prove properties optimal schedules 
lemma ht tni optimal schedule 
conditions hold ti ti gamma ti ti gamma tn intuitively lemma means goal predicate satisfied time points need query points 
proof want show eliminating single point schedule affects expected cost 
ht ti gamma ti tni schedule obtained eliminating ti 
see difference expected costs schedules written gamma delta ti io ic ti gamma ti gamma ti ti gamma ti gamma ti io ic ti gamma ti gamma nx tj jo gamma tj gamma tj gamma tj gamma assumptions subsection condition tn gamma tn immediately follows tn gamma tn 
proves case gamma 
global optimal schedule exists schedule improved adding new queries 
assume exists gamma ti gamma ti 
choose largest satisfying condition ti eliminated 
fact ti gamma ti obtain gamma delta ti gamma ti io ti gamma ti gamma nx tj jo gamma tj gamma tj gamma tj gamma delta nx tj jo gamma tj gamma tj gamma tj gamma see increasing function positive tn tn gamma gamma 
words eliminating ti improves schedule contradicts optimality ends proof 
follows immediately 
show tn know tn see part affected tn written tn nc tn gamma tn gamma gamma pf tn tn nc tn nc gamma pf tn gamma due fact increasing function immediately obtain tn substituting tn decrease 
proves part lemma 
corollary equation follows immediately 
dt gamma pf theorem provides set tight constraints optimal schedules 
theorem main theorem ht tni optimal schedule respect gamma equation holds ti gamma ti io ti io ti gamma ti gamma ti proof optimal minimizes eu tn polyhedral defined borders specified equations ti gamma ti 
optimization performed gamma variables tn gamma 
ti gamma ti 
differentiability eu tn equations hold points minimum de dti gamma differentiation obtain pu ti io ti gamma ti gamma gamma ti ti ti io ic ti order shift value 
differentiable due differentiability positive reordering terms get ti gamma ti io ti ti gamma ti gamma ti io monotonic increasing function ti io 
fact obtain optimal schedules fixed ti allows rewrite 
theorem implies method generating optimal schedules follows 
theorem point optimal time schedule rest points reconstructed unique way formula ti gamma ti io ti gamma ti gamma ti io gamma gamma proof proof theorem follows immediately 
uniqueness gamma implied monotonic increasing function 
tt denote sequence obtained applying 
denote family sequences theorem claims optimal sequence belongs possible show members necessarily monotonically increasing may legal schedules defined 
proposition allows easily identify non schedules proposition necessary sufficient condition sequence increasing tn tn gamma tn 
proof obvious condition necessary 
prove contradiction sufficient 
assume tn gamma tn exists ti gamma ti 
applying mean value theorem conclude exist points ti io ti ti gamma ti ti gamma ti ti io ti gamma ti gamma ti ti gamma ti ti ti io ti gamma ti gamma gamma gamma fact ti positive obtain ti gamma ti ti ti 
induction rest sequence decreasing contradiction assumption 
show important features optimal schedules 
proposition states optimality preserved linear combination 
gamma need defined range 
optimal schedules theorem gamma applied correctly 
see section example 
proposition distribution function time cost function linear combination cu 
ht tni optimal schedule expected cost optimal expected cost ce 
proof follows immediately equations 
commonly time cost function propositions hold case 
proposition loss generality consider 
proof equation ti ti ti gamma ti gamma gamma substituting reduces problem case 
proposition describes features shifted distribution proposition distribution function shifted distribution function gamma 
ht tni optimal schedule expected cost schedule ht tn optimal expected cost 
proof follows previous proposition equations 
sufficient conditions schedule optimality definition defines global optimal expected value infimum optimal expected values respect fixed number queries 
note may realized schedule 
possible schedule improved adding new queries 
case exists sequence schedules costs form decreasing sequence converging 
note ffl exists global ffl optimal schedule 
theorems specify sufficient conditions existence global optimal schedule schedule realizes 
theorem problem minimization constraints fixed solution 
proof assumptions continuous function 
constraints describe convex area theorem achieve minimum maximum values area 
theorem exists global optimal schedule 
proof proof contradiction 
assume global optimal schedule exists 
sequence fe tn ti optimal schedule respect non increasing converges 
recall ti contain queries 
obtain tn expected costs tni grown infinity ni 
fact obtain tn nx ic ti gamma ti gamma nf tn gamma gamma ti gamma tn gamma ti tn obtain tn gamma tn gamma ti ffl tn number queries ti tn gamma ti ffl nffl due fact tn optimal schedules large queries tn nffl grouped arbitrarily small neighborhood taylor theorem ti gamma ti ti gamma gamma ti ti ti gamma gamma ti 
large schedules large number queries holds ti gamma ti gamma ti ti gamma ti gamma ti gamma ti gamma hand ti gamma ti ti ti gamma ti ti gamma ti ti obtain ti gamma ti ti gamma ti cu gamma ti gamma ti gamma ti gamma ti gamma ti ti gamma gamma ti ti gamma ti ti gamma ti gamma gamma cu ti maxt right part equation strictly negative constant 
left part order ffl arbitrarily small 
contradiction proves theorem 
theorem conditions hold 

limt 
ffi gamma ffi 
exists global optimal schedule 
proof proof contradiction 
scheme similar previous theorem show majority time points schedules large number queries concentrated near part similar previous proof 
limt tn tn nx ti io ti gamma ti gamma limt ffl exists number nffl nffl ti io ffl large tn nx tn ffl ti gamma ti gamma tn tn gamma tk ffl fact tn optimal solutions tn obtain tn gamma tk ffl means previous case queries tn nffl grouped arbitrarily small neighborhood ti gamma ti gamma ti ti gamma ti gamma ti gamma ti gamma right side equation large form ti gamma ti io ti io ti gamma ti io ti io ti gamma ti io ti io ti io gamma ti io ti io ti gamma ti io ti io ti gamma ti ti gamma ti ti gamma ti ti gamma ti ffi obtain ti gamma ti ti gamma ti gamma ti ti gamma ti gamma ffi previous proof leads contradiction 
point third condition strong 
essentially states utility function behave reasonably 
clarity condition stated range 
proof shows weaken condition neighborhood points form io large condition holds convex functions gamma point functions increasing function 
functions satisfying gamma ffi satisfy third condition 
easy see example rule functions ln time cost functions satisfy third condition 
clear proof third condition replaced condition limt algorithm computing optimal schedules way building algorithm finding optimal schedule write procedure computing optimal schedule respect fixed optimize expected cost equations form system equations variables 
section uses method case uniform distribution 
equations non linear method infeasible cases 
way obtain solution fact determines rest schedule see theorem minimize variables algorithm requires minimization function dependent variables get integer values 
optimization conditions unstable 
rectify problem transform method minimization variable function 
define function value time point returns expected cost member starting 
function starts works iteratively 
iteration ti satisfy necessary conditions optimal schedules ti gamma defined argument ti ti gamma declare time sequence non optimal assign 
ti define ti gamma 
say case schedule ht ti gamma produced initial time point 
calculate value ti equation increase repeat process 
algorithm shown 
function 
repeat ti satisfy necessary conditions optimal schedules return ti return ti gamma calculate value ti equation repeat algorithm finding value 
want prove theorem depends implicitly boundary conditions 
theorem problem global minimization equivalent global minimization 
words provides minimal value corresponding time sequence ht ht sequence providing minimal value proof optimal sequence satisfy equation 
provides minimal value hand constructed 
optimal sequence proves theorem 
lists general algorithm calculating optimal time schedule 
arg mint computed standard optimization methods see example 
theorem algorithm guaranteed find global ffl optimal schedule 
necessarily exact global minimum exists due computation errors minimization process 

arg mint 

ti calculate ti ti ti gamma formula 

tn optimal schedules tn equal computation error may give slightly different result 
return schedule ht tni 
algorithm finding optimal schedule algorithm finding optimal schedule respect need add calculation additional stopping condition query scheduling algorithm time unlimited problems scheme extended handle cases time limit 
exists point algorithm probability point 
reduces problem time limited case 
assume 
case schedule finite finite schedule positive probability submitting query goal predicate satisfied 
infinite schedule finite expected cost 
substituting conditions obtain expected cost case eu ti io ic ti gamma ti gamma eu ti io ti gamma ti gamma gamma second case 
cases series converge 
optimality schedules equivalent finite analogs 
theorem generalization theorem time unlimited problems 
theorem ht tn optimal schedule 
equation holds ti gamma ti io ti io ti gamma ti gamma ti proof proof contradiction 
suppose optimal equation hold 
look time limited problem tk 
theorem sequence ht tk optimal violates equation 
ht optimal schedule time limited problem respect 
lemma tk 
time limited problem io ic gamma gamma ti io ic ti gamma ti gamma equations follows changing sub sequence ht tk ht lower expected cost 
optimal schedule proves theorem 
time limited problem theorem follows theorem theorem equation hold optimal sequences infinite case 
easy see theorem propositions finite case correct infinite case 
adapt algorithm previous section time unlimited case define function analogous 
expected cost represented series algorithm implementing provided convergence divergence criterion 
criteria get prefix series 
example convergence criterion test elements differ ffl 
example divergence criterion test element greater large number 
define function iteratively way 
set set 
initial value set 
ti satisfy necessary conditions optimal schedules ti gamma defined argument ti ti gamma declare time sequence non optimal assign calculation 

divergence criterion holds set calculation 

convergence criterion holds set ti calculation 

calculate value ti formula increase return step 
theorem holds time unlimited case correctness convergence divergence criteria 
algorithm time unlimited case similar algorithm time limited case 
obviously implement algorithm returns infinite schedules 
assume time points returned request 
algorithm shown 
time limited case quality solution depends minimization method theoretically global ffl optimal solution ffl 

arg mint 

new time point required calculate ti ti ti gamma formula 

return ti current query 
time limited problem time points returned 
algorithm finding optimal strategy time unlimited problems distribution analysis sections analytical approach problem optimal scheduling 
approach reduces optimization problem space schedules variable optimization solved standard numerical methods 
section perform deeper analysis standard distributions show experimental results 
analysis section assume common case pure time minimization problem 
due propositions consider 
uniform distribution subsection full analytic solution uniform distribution model 
show application solution prolog example described 
formal solution assume random variable representing time goal predicate true uniformly distributed interval distribution function density function 
theorems specify optimal schedule case uniform distribution 
proofs appendix 
theorem ht tni member 
time points satisfy ti gamma 
necessary sufficient condition sequence non decreasing nmax 
expected cost tn gamma gamma gamma easiest way optimize right side assuming domain continuous 
theorem optimal value right side continuous opt gamma gamma gamma gamma special case opt gamma optimal number queries approximated comparing value sequences obtained equation having values max min nmax look optimal schedule respect take minimum 
fact right part achieve minimum points zero derivative boundaries 
prolog example example monitoring problem context prolog 
assume query associated set solutions bindings denoted sol 
assume user interested exactly solution lambda recognized observed 

probability lambda member sol denoted 
assume interpreter presents sol chunks possibly variable length 
user observes proposed set solutions quits process desired solution 

assume cost producing chunk length cost testing user cost solution overhead chunk 

assume estimate past experience expected number solutions mq query 
assume sol arbitrarily ordered 
goal endow interpreter decision algorithm determining sizes chunks user order minimize total time process 
show general framework previous sections reach goal 
item conclude case instance uniform distribution model 
loss generality substitute zero making problem instance general case fixed easy see mq 
algorithm returns optimal schedule terms time points 
division allows easily translate chunk lengths 
problem parameters discrete model assumes continues data assume solution parameters continuous round results 
simulation results illustrate analysis assigned reasonable values parameters computed optimal schedules strategies discussed previous sections 
expected size sol set 
set set second seconds seconds 
computed results follows ffl human views results regular prolog model expected total time sec 
ffl human views results time sec 
ffl optimal schedule optimal number queries time points expected time sec 
test flaws computation ran simulation location lambda sequence randomly generated 
average cost runs seconds confirms correctness analysis 
advantage optimal method obvious small large expected cost schedule generated optimal strategy close gamma gamma delta checking result constant value large small check allowed average cost optimal method gamma gamma delta case checking result 
experiment tested effect independent variables expected cost fixed 
graphs show results obtained optimal query methods 
graph stands fixed value seen graphs optimal strategy better performance query strategy 
advantage optimal strategy diminishes small queries submitted wasted process fails 
advantage grows smaller small cost query enables condensed schedule detects satisfaction goal condition earlier 
optimal strategy small advantage strategy 
exponential distribution start discussion formal properties specific case exponential distribution continue solution computational learning example time limited time unlimited problems 
formal analysis exponential distribution described density function gamma expected total cost cost single query optimal strategy strategy expected total cost cost single query optimal strategy strategy expected total cost cost single query optimal strategy strategy expected total cost cost single query optimal strategy strategy expected total cost cost single query optimal strategy strategy expected total cost cost single query optimal strategy strategy expected total cost cost single query optimal strategy strategy expected total cost cost single query optimal strategy strategy graphs shows performance various scheduling methods function cost single query 
time set 
graphs show results different values probability success 
distribution function form gamma gamma theorem describes behavior optimal schedules exponential distributions theorem denote ex gamma gamma gk gk gamma 
fixed optimal schedule ht tni described formula ti ti ti gamma ti gamma gamma gamma gamma single root equation gamma gi corresponding expected cost process gamma gamma gn gamma gamma proof theorem appendix 
utilize theorem basis alternative method finding optimal schedule exponential distribution minimization corollary root equation gamma gamma sequence intervals queries increasing decreasing constant 
proof obtain lengths time intervals satisfy condition delta delta gamma gamma assume delta delta 
delta delta gamma gamma delta gamma gamma delta induction delta produce decreasing sequence 
proof cases delta delta delta delta similar 
computational learning example section apply algorithm computational learning problem described 
monitored process learning examples pac learning algorithm 
assume framework learning weak form equivalence queries teacher acknowledges declines correctness current hypothesis 
learning algorithm stops soon get positive reply query 
assume learning example costs unit time cost equivalence query units time 
goal monitoring process design query schedule minimizing time spent learning goal concept 
apply framework problem need distribution function assume computational learning literature gives upper limit number examples required pac learning upper limit ffl ffi vc dimension concept class 
dependencies infer distribution function describing behavior goal predicate time limit assume concept class set axis aligned rectangles euclidean plane examples points drawn 
authors show learning ffl ln ffi examples probability model ffl correct gamma ffi 
formulate probability ffl correct function ffl gamma ffi gamma gamma ffi probability gamma ffi 
right part inequality equal positive positive ln ffl rewrite equation gamma ffi gamma gamma ffl gamma assumptions ffl better estimation assume tight lower bound learning smaller number examples assumed insufficient 
gamma ffi 
ffl suppose continuous range denote 
total number learned examples usually large assumption continuity significant effect solution 
define distribution function needed framework gamma ffi gamma gamma ffl gamma ln ffl ffl ffi easily compute maximal number required examples ffi ffl ln ffi problem specific case exponential distribution solved methods described section described section 
framework allows design monitoring strategy case ffi stands time unlimited case described section 
simulation results ran set experiments test effect independent variables ffl ffi expected total cost 
test run different scheduling strategies optimal algorithm strategy strategy query strategy 
addition absolute expected total cost show speedup factor optimal method query method 
varied default value 
ffl ffi varied default value 
results shown figures 
experiments software brent optimization written oleg available netlib public access repository www netlib org 
expected total cost cost single query optimal strategy strategy speedup factor cost single query expected total cost function cost single query various scheduling strategies 
speedup factor sophisticated methods relative query method function expected total cost delta optimal strategy strategy expected total cost epsilon optimal strategy strategy expected total cost function ffl 
expected total cost function ffi 
describes total expected cost function see small optimal method achieves speedup factor query method 
interesting note method produces results equivalent achieved optimal method 
characteristic left skewed distributions overhead extra queries tail offset low probability occurrence 
shows cost function ffi ffl 
see large ffi speedup factor declines ffi determines increasing ffi decreases relative weight compares results time limited time unlimited cases 
graphs cases similar meaning overhead requiring guaranteed ffi ffl correct solution low 
note optimal method able handle time unlimited case 
expected total cost cost single query time bounded optimal unbounded optimal schedule expected total cost function time limited time unlimited cases 
normal distribution section show formal properties optimal schedules normal distribution supply numerical solution communication problem simulation results 
formal solution normal distribution mean value deviation oe described density function gamma gamma oe distribution function gamma gamma gamma oe dx truncated normal distribution distribution density gamma delta gamma gamma oe distribution function gamma delta gamma gamma gamma oe dx gamma gamma gamma gamma oe dx experiments large allow neglect standard normal distribution 
prove proposition behavior time sequences normal distribution 
proposition ht tni sequence delta ti gamma ti gamma 
normally distributed mean value standard deviation oe inequalities hold ffl max ti gamma ti delta delta gamma 
ffl delta delta gamma ti ti gamma delta delta conditions mean intervals queries form decreasing sequence point increasing sequence point 
proof inequality follows fact increasing function 
obtain points ti gamma ti ti gamma ti gamma delta gamma delta fi gamma fi gamma gamma fi gamma gamma fi gamma gamma delta gamma gamma delta gamma ti ti gamma ffl 
ffl ti ti gamma gamma 
delta gamma delta gamma delta gamma gamma delta gamma gamma delta gamma delta gamma communication example suppose stations want communicate help receiver transmitter robot described see 
assume probability robot reach point time distributed truncated normal law mean value standard deviation oe 
assume distribution parameters known theoretical analysis previous experience 
cost single communication attempt 
assume time limit desired success probability gamma ffi 
second case compute formula gamma gamma gamma oe dx ffi error permitted ffi case time unlimited problem 
goal design schedule minimal expected time communication established 
simulation results conducted set simulation experiments average time moving robot point set 
oe set 
ffi set corresponds 
tested effect independent variable expected total cost 
test run different scheduling strategies optimal algorithm strategy expected total cost cost single query optimal strategy strategy speedup factor cost single query normal distribution expected total cost function cost single query various scheduling strategies 
normal distribution speedup factor sophisticated methods relative query method function strategy query strategy 
varied default value 
results shown 
see advantage optimal method methods 
observe advantage method method yields schedules areas 
conducted experiment results identical obtained time limited case 
note methods able handle time unlimited case 
experimentation real problem previous section showed experimental results simulated data 
test framework real world problem distribution function externally supplied 
assume task generate hard solvable search problems search space 
problem defined pair states initial state goal state 
assume possess heuristic function estimates cost shortest path states 
assume define hard problem pair states heuristic distance operators reversible possible methods generating problems generate random goal state perform random walk goal state 
operator application check current heuristic distance 
hitting state distance equal greater process 
approach intuitive may carry unnecessarily high costs heuristic function expensive 
show monitoring generation process efficient 
monitoring schedule context specifies number operator applications successive calls heuristic function 
generating problems learn distribution function number steps required achieving goal 
sufficient data accumulated start applying monitoring algorithm design optimal schedules 
frequency number steps satisfying goal predicate histogram describing distribution function estimated puzzle domain past problems 
implemented approach generating problems theta sliding tile puzzle domain sum manhattan distances heuristic estimator 
cost applying heuristic applying single operator 
run experiment testing algorithm theta puzzles required threshold distance 
problems estimating distribution function obtained histogram shown 
applied algorithm obtained schedule 
tested resulting schedule generating problems 
table shows results obtained 
comparison added results strategies described section 
scheduling method total cost standard deviation query query delta optimal table results obtained generating hard theta problems various scheduling methods 
seen table optimal strategy performs better approaches 
note problem satisfy assumptions binary quality measurement monotonic 
method able handle problem quite nicely 
related section compare method existing works 
section discuss monitoring scheme designed russell wefald section framework described hansen zilberstein 
fixed step monitoring dt lambda russell wefald describe search algorithm dt lambda implementing decision theoretic control method 
algorithm finds node expanded estimating potential information gain expected expanding node 
estimation performed anytime local search procedure continues run long expected beneficial 
test benefit continuation analogous query satisfaction goal predicate 
performing test step procedure russell wefald propose test performed grain size steps denoted reducing number times test performed 
average number node expansions search denoted average number tests ratio cost test cost node expansion ae 
authors assumption half final node expansions wasted 
prove optimal grain size aea 
scheme corresponds strategy section 
russell wefald explicitly assumption type distribution involved 
assumption wasted nodes indicates assume uniform distribution 
reasonable assumption search problems type deal 
framework russell wefald generalized general distribution certain constraints theorem 
theorem distribution function cost function maximal allocated time time required single query probability algorithm success 
define gamma pn gamma 
assume independent dependency neglected optimal number queries strategy written approximately gamma proof schedule ht tni equal intervals time points meets ti tn 
definition equal step schedule tn substituting values ti fact see proposition obtain gamma gamma gamma gamma notation authors 
due possible discretization error 
opening parentheses obtain gamma tn gamma gamma gamma section perform minimization expression assuming continuous 
independent necessary condition local extremum form de dn gamma gamma yielding single solution expressed 
second derivative strictly positive convex solution global minimum 
assumption invariant holds automatically uniform distribution gamma gamma gamma gamma gamma delta gamma assumption holds large law large numbers 
unfortunately small values distributions violate assumption 
terms dt lambda algorithm grain size viewed notation definition represents interval queries 
ratio parameter ae corresponds measure time expanded nodes 
show average number node expansions search approximated gamma uniform distribution approximation correct 
distributions show correctness large ns approximate value expressed formula ss nx ti ti gamma ti gamma gamma pf nx ti gamma ti gamma gamma pf nf gamma gamma gamma pf gamma gamma gamma fn ss gamma similarly average number tests approximately gamma substituting values right part gives ae ag formula 
particular case described russell wefald assume nodes uniformly distributed optimal number queries optimal grain size gopt tn opt pt aea result russell wefald 
theorem implies corollaries 
corollary distribution satisfies conditions theorem density skewed close large 
density skewed close small 
corollary formalizes intuition better ask case monitored event occur early ask case occur late 
corollary cost function uniform distribution expected elapsed time strategy tn gamma optimal number queries gamma proof substituting obtain gamma gamma gamma simplifying expression get 
expression obtained substituting note equations resemble optimal schedule section 
repeated experiments described previous section method 
cases assumptions hold exhaustive optimization results uniform distribution slightly worse results obtained optimal scheme 
exponential distribution strategy optimal 
normal distribution optimal strategy outperformed strategy 
dynamic monitoring zilberstein hansen proposed monitoring strategy dynamic programming 
subsection prove unifying assumptions optimal schedules obtained method equivalent generated 
analysis adopt definitions zilberstein hansen 
refer method dynamic method static method 
dynamic method looks monitoring policy quality level qi time step tk provides monitoring decision delta delta represents additional amount time allocate anytime algorithm binary variable stands options delta perform monitoring 
optimal monitoring policy dynamic programming methods rule qi tk max delta delta qj tk delta delta qj tk delta gamma monitor tk query time point qj quality level delta monitoring decision utility function query cost value function optimized 
qj delta conditional probability getting solution quality qj running algorithm additional delta time current solution quality qi 
probability called dynamic performance profile algorithm 
facilitate comparison methods transform equivalent form qi tk max delta qi tk delta qj tk delta gamma monitor form assumes monitoring decision refers current step 
additional term action intended compensate extra call monitoring procedure 
main differences model ffl dynamic method markovian predicts quality information current quality level allocated time 
static method hand assumes quality depends time spent process 
reason probabilistic performance profiles dynamic performance profiles 
ffl assume query types associated costs resource cost time cost zilberstein hansen assume resource cost query model delays finishing time process dynamic method 
want rewrite terms model described 
dynamic model support probability success query delay assume 
static model equivalent tn dynamic 

model goal predicate boolean partitions set states equivalence classes 
loss generality assume states available final state 
assume process reaches leave 
requirement natural anytime algorithms 

assume monitoring process tk add information goal predicate satisfied 
fully determines prediction 
dynamic model hand prediction determined previous state delta unify approaches extension dynamic performance profile qj tk delta stands probability quality qj obtained tk delta tk quality level qi 
replace qj delta extended form 

define utility function follows qi gamma gamma means monitoring required goal predicate satisfied time limit exceeded utility opposite cost 
denote qi probability quality qi achieved terms model gamma process leave goal state jq tk delta jq tk delta means formula goal state achieved non zero contribution sum tk form tk max delta tk tk delta gamma monitor gamma non increasing function nonincreasing case optimal solution set delta immediately 
case goal achieved tk form tk max delta tk jq tk delta tk delta jq tk delta tk delta gamma monitor tk qi tk gamma tk process stopped immediately reasons 
tk gamma monitoring option available 
tk jq tk delta tk delta jq tk delta tk delta gamma jq tk delta stands probability process remain state delta time observed tk 
definition conditional probability write jq tk delta gamma tk delta gamma similarly jq tk delta stands probability process switch state delta time observed tk 
jq tk delta tk delta gamma tk gamma tk gamma tk delta gamma delta delta gamma tk gamma tk tk delta gamma gamma tk delta gamma tk tk tk gamma tk gamma tk tk gamma gamma tk gamma tk tk tk gamma tk gamma tk tk gamma gamma tk gamma tk denote tk fk tk uk 
computing gives gamma gamma gamma gamma substituting formula yields gamma gamma gamma gamma gamma gamma gamma inductive reasons write general case gamma fn tn nx fi gamma fi gamma ui gamma nx gamma fi assuming process stops steps tn tn value function rewritten gamma fn un nx fi gamma fi gamma ui gamma nx gamma fi gamma fn un nx fi gamma fi gamma ui gamma nx gamma fi gamma hand see nx gamma fi gamma nc gamma nx fi gamma nc gamma fn nx fi gamma fi gamma gamma fn un nx fi gamma fi gamma ui gamma nx fi gamma fi gamma gamma nc nx fi gamma fi gamma ui gamma gamma fn un gamma nc nx ti gamma ti gamma gamma ti gamma gamma tn gamma tn gamma nc obtain gamma tn proves models equivalent unifying assumptions 
dynamic model advantage able effectively additional information obtained monitoring disadvantage requiring rich statistical data 
high complexity due dynamic programming involved 
denote size set possible time values jtj complexity jtj 
static model advantage efficiency time consuming module minimization function 
dumb minimization algorithm tests set time points static method require fewer operations 
test point requires number operations proportional schedule size smaller jtj 
practice smooth distribution functions minimization methods cheap 
advantage static method dynamic ability handle queries consume time monitored process 
significant looks methods advantages interesting combine 
discussion studies problem monitoring anytime processes 
took approach attacking limited defined monitoring problem performing thorough theoretical study solution 
assume anytime process queried binary goal condition processing query consumes time monitored process 
goal design optimal query schedule 
querying significantly increases overhead delays time takes goal predicate satisfied 
querying infrequently hand delays time takes detect satisfaction goal predicate 
introduce algorithm generating optimal schedules prove properties 
algorithm inductive formula builds entire optimal schedule time point query 
method reduces problem variable optimization studied problem analytical numerical solutions 
describing general algorithm proving properties perform analysis problem conduct set experiments simulated data confirm analysis 
experimental results show advantage optimal method default monitoring strategy querying process 
achieved positive results applying algorithm real problem 
approach requires probability distribution goal predicate satisfied 
requirement weaker need dynamic performance profile assumed works monitoring anytime algorithms stronger requirement allows line monitoring better expected results 
possible ways obtaining information practice 
possibility distribution function externally supplied 
case distribution type known parameters need estimated 
possibility algorithm monitored solves sequence similar problems assumption commonly colt community 
case past experience approximate distribution function 
experiments show schedules produced approximated distribution function may optimal provide significant gains 
minimizing expected cost possible goal 
minimizing standard deviation risk desirable 
allowing tradeoff expected total cost variance monitoring context interesting open research problem 
believe contributes foundations meta reasoning general monitoring particular 
providing rigorous mathematical analysis problem solution applicable algorithm applied real problems 
ehrenfeucht haussler warmuth 
learnability vapnik chervonenkis dimension 
journal acm 
huberman example investigated setup goal reduce expected cost variance solving different instances problem running multiple trials solving instance 
boddy dean 
decision theoretic deliberation scheduling problem solving time constrained environments 
artificial intelligence 
john breese eric 
horvitz 
ideal reformulation belief networks 
proceedings sixth conference uncertainty artificial intelligence pages 
brent 
algorithms minimization derivatives 
prentice hall englewood cliffs new jersey 
dean boddy 
analysis time dependent planning 
proceedings seventh national conference artificial intelligence pages minneapolis minnesota 

integrative windowing 
journal artificial intelligence research 

principles rationality 
editors foundations statistical inference pages 
holt rinehart winston toronto 
hansen zilberstein 
monitoring progress anytime problem solving 
proceedings th national conference artificial intelligence pages portland oregon 
hansen zilberstein 
monitoring anytime algorithms 
sigart bulletin 
horvitz 
reasoning beliefs actions computational resource constraints 
proceedings workshop uncertainty artificial intelligence seattle washington 
horvitz 
computation action bounded resources 
phd thesis stanford university 
horvitz 
models continual computation 
proceedings th national conference artificial intelligence 
horvitz cooper heckerman 
reflection action scare resources theoretical principles empirical study 
proceedings eleventh international conference artificial intelligence pages 
eric horvitz adrian klein 
reasoning metareasoning mathematical truth studies theorem proving limited resources 
proceedings eleventh conference uncertainty artificial intelligence montreal august 
bernardo huberman rajan lukose tad hogg 
economic approach hard computational problems 
science january 
michael kearns umesh vazirani 
computational learning theory 
mit press cambridge massachusetts 
markovitch 
divide conquer subgoal ordering algorithm speeding logic inference 
journal artificial intelligence research 
markovitch 
learning investment functions controlling utility control knowledge 
proceedings fifteenth national conference artificial intelligence pages madison wisconsin 
william press saul teukolsky william vetterling brian flannery 
numerical recipes art scientific computing 
cambridge university press 
quinlan 
induction decision trees 
machine learning 
russell wefald 
optimal game tree search rational metareasoning 
proceedings eleventh international conference artificial intelligence pages 
russell wefald 
right thing studies limited rationality 
mit press cambridge massachusetts 
russell 
rationality intelligence 
artificial intelligence 
russell zilberstein 
composing real time systems 
proceedings twelfth national joint conference artificial intelligence ijcai sydney 
morgan kaufmann 
herbert simon 
behavioral model rational choice 
quarterly journal economics 
vapnik chervonenkis 
uniform convergence relative frequencies events probabilities 
theory probability applications 
zilberstein 
operational rationality compilation anytime algorithms 
ph dissertation computer science division university california berkeley 
zilberstein russell 
efficient resource bounded reasoning ralph 
proceedings international conference ai planning systems pages college park maryland 
appendix weakening smoothness assumptions assume time cost function distribution function 
definition non decreasing functions 
assume derivative possible exception countable number discontinuity points type points gamma 
suppose number intervals constant countable 
requirements quite natural real problems 
goal construct differentiable functions close desired 
addition monotonic increasing function 
show smoothing process 
smoothing performed similar way 
fx xm set discontinuity points 
ffl arbitrarily small number 
define new utility function way 
ffl neighborhood discontinuity points si xi gamma ffl xi ffl 

ffl neighborhood define smooth increasing function gamma ffl gamma ffl ffl ffl 
resulting function smooth differ arbitrarily small set points 
easy see effect smoothing expected cost arbitrarily small 
want monotonically increasing 
suppose smoothed procedure 
constant intervals xk xk 
ffl ffi arbitrarily small numbers 
define equal outside intervals smooth increasing function xk gamma ffl xk ffl xk gamma ffl xk gamma ffi xk ffl xk ffi 
constructed arbitrarily close 
appendix formal proofs proof theorem want prove 
uniform distribution equation form ti gamma ti ti gamma gamma tn tridiagonal system equations 
easily show induction ti ti gamma gamma gamma suppose holds gamma get expression gamma tk tk gamma tk tk gamma gamma tk tk tk finishes proof 
show correctness formula descending induction 
base induction derived immediately gamma 
assume holds gamma get tk tn gamma tk gamma gamma gamma tn gamma gamma proves 
ti tn gamma gamma gamma ni gamma due proposition inequality necessary sufficient condition time sequence increasing 
restriction follows immediately solution 
large minimized function obtain minimum border exists ti ti leading redundant queries 
want find value time points ti satisfy 
see uniform distribution tn pt nx ti io ti gamma ti gamma gamma substituting values ti defined get tn pt nx gamma io theta theta gamma gamma gamma gamma gamma gamma gamma gamma pt nx tn gamma tn gamma gamma tn nx nx io gamma nx gamma gamma 
gamma nx nx io gamma nx gamma nx 
gamma gamma nx gamma gamma nx gamma gamma nx gamma nx nx gamma gamma gamma gamma gamma gamma gamma gamma see tn gamma gamma gamma gamma gamma gamma simplifying equation gives 
proof theorem extension real domain corresponding right part 
obtains optimal minimal value ded 
show optimal value general case 
formula see 
calculate optimal de gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma sigma rio gamma gamma gamma sigma gamma gamma sigma gamma delta gamma sigma gamma gamma gamma sigma gamma gamma looking local minimum gamma easy see gamma gamma gamma meets requirement 
want prove value second value valid local minimum 
show 
inequality equivalent gamma gamma gamma square sides inequality obtain gamma gamma gamma gamma eliminating equal members obtain true inequality 
want prove previous case formula obtain equivalent inequality gamma gamma gamma square sides inequality obtain gamma gamma gamma gamma eliminating equal members obtain true inequality gamma gamma true 
value represents single optimal solution problem 
integer approximation restrictions nmax 
function smooth andd real optimal values provide approximation 
proof theorem easy see exponential distribution formula form ti ti ti gamma ti gamma gamma gamma gamma prove induction formula ti ti gi gamma trivial 
assume correctness gamma 
obtain tk tk tk gamma tk gamma gamma gamma tk gk gamma gamma gamma tk gk gamma tk gk easy prove induction tk gamma gi lemma tn formula follows immediately previous equation 
denote dependency see dv dt gamma iy gamma gamma ep gamma gj monotonic function unique solution 
theorem solution produced point global minimum 
equation show induction dv dtp function convex 
fact shows solved easily numerical methods convergence fast 
calculate value point gamma gamma ti gamma ti ti gamma gamma ti gamma ti gamma ti gamma ti gamma ti gamma tn gamma gamma gamma ti gamma ti gamma gamma gamma ti gamma gamma gamma ti gamma gamma gamma tij 
gamma gamma gamma tn gamma gamma gamma gamma gn gamma 
