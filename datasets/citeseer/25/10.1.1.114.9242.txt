fable language enforcing user defined security policies nikhil brian michael hicks university maryland college park bjc cs umd edu presents fable core formalism programming language programmers may specify security policies reason policies properly enforced 
fable security policies expressed associating security labels data actions protect 
programmers define semantics labels separate part program called enforcement policy 
fable prevents policy circumvented allowing labeled terms manipulated enforcement policy application code treat labeled values abstractly 
features facilitate straightforward proofs programs implementing particular policy achieve high level security goals 
fable flexible implement wide variety security policies including access control information flow provenance security automata 
implemented fable part links web programming language call resulting language 
report experience build substantial applications wiki line store equipped combination access control provenance policies 
knowledge existing framework enables enforcement wide variety security policies equally high level assurance 
years computer security researchers explored techniques ensuring software system correctly enforces security policy result software exhibits desirable security property 
notable success goal defining programming language techniques enforcing information flow security policies 
common form information flow policy defines set security levels ordered lattice sensitive data program assigned label derived lattice 
correct enforcement policy implies program exhibits flavor noninterference states information visible level leaked channel visible level including notion security label programming language types show correctly typed program certain enforce security policy 
approach implemented successfully jif languages 
information flow policies useful important styles policy common including access control type enforcement tainting perl taint mode provenance tracking stack inspection forms security automata :10.1.1.10.3979
approach verifying correct enforcement policies encode information flow policies programs written jif 
cases access control type enforcement tainting encoded conjunction jif declassification operators scale 
example jif noninterference baseline property attendant restriction implicit flows program control flow cumbersome 
jif fix format security labels complicates means interface external infrastructure policy management systems databases want programming language enforce wide range policies including limited information flow providing assurance jif programs enforce policies correctly 
step goal presents fable core language writing programs enforce variety security policies 
key observation security policies associating labels data preprint appear ieee symposium security privacy label expresses security policy data 
varies policies specification interpretation labels terms actions permitted denied 
observation embodied fable respects 
programmers define custom security labels associate data protect dependent types 
example programmer define label low integer value protected label type int low 
example programmer define label acl alice bob integer type int acl alice bob meant accessed alice bob 
second programmers define interpretation labels special enforcement policy functions separated rest program 
example semantics access control label implemented enforcement policy function policy access simple acl lab int acl member user acl function takes label acl alice bob argument integer protected acl second argument 
current user represented variable user member acl function member shown returned label removed expressed syntax accessed main program 
membership test fails returns value released 
fable guarantee security policy correctly implemented fable design greatly simplifies proof fact 
particular fable type system ensures labeled data data type treated abstractly main program terms labeled type constructed examined changed enforcement policy code 
fable type system ensures main program sever forge association label data protects 
effect fable ensures complete mediation user label policy data accessed consulting correct security policy 
demonstrate fable flexibility encode range policies including access control static dynamic information flow forms declassification provenance tracking policies security automata 
experience soundness fable proofs security properties difficult arguably simpler proofs similar properties specialized languages 
demonstrate fact proofs correctness access control policies provenance policies static information flow 
fable opens possibility partially automating proofs lines user defined type systems leave exploration possibility 
knowledge existing framework enables enforcement wide variety security policies equally high level assurance 
evaluate fable practicality implemented fable part links web programming language 
call resulting language security enhanced links 
build substantial applications line secure blog wiki inspired implements combined access control provenance policies line commerce application provided links distribution extended access control policy 
general fable label security policies lacking burdensome modular separation enforcement policy permitted reuse policy code applications 
remainder fable core language defining enforcing custom security policies section 
show fable define range security policies fable design simplifies proofs policies implemented correctly section 
section discuss implementation fable building web applications experience building 
section discusses related section sketches concludes 
fable system labels section presents syntax static semantics operational semantics fable 
section illustrates fable flexibility presenting policies expressed proofs attendant security properties 
syntax defines fable syntax 
notation stand list elements form context clear treat set elements 
expressions extend standard polymorphic calculus system 
standard forms include integer values variables abstractions term application fixpoint combinator fix type abstraction type application 
expressions fix fable specific match pi ei types int fable specific lab lab 
syntax fable 
patterns pre values app 
values policy values pol pol type abbreviation typename binding polymorphic function def 
fix policy function def 
policy fix dependent tuple type dependent tuple 
dependent tuple projection te te 
syntactic shorthands 
syntactic constructs specific fable distinguished 
expression label represents arbitrary constructor ei label acl alice bob acl ary label constructor alice bob ary label constructors 
labels examined pattern matching 
example expression match acl evaluate alice run time value acl alice bob 
explained earlier fable introduces notion enforcement policy separate part program authorized manipulate labels type 
grossman bracketed expressions delimit policy code main program 
practice code signing java ensure untrusted policy code injected program illustrated earlier expression removes label type adds discuss operations detail 
labeling operations may occur policy code 
standard types include int type variables universally quantified types functions dependent type names argument may bound 
illustrate usage types shortly 
labels type lab singleton type lab describes label expressions equivalent example label constructor high type lab type lab high 
singleton types useful constraining form label arguments enforcement policy functions 
example write specialized form previous access simple function policy access pub acl lab acl world int acl fable type checker ensures function called expressions evaluate label acl world call access pub acl alice bob rejected 
effect type checker performing access control compile time constraint embodied type 
show section constraints powerful encode information flow policy checked entirely compile time 
dependent type describes term type associated label association syntax example high expression type int high 
conversely association broken syntax example high type int 
illustrate dependent function types 
function access simple type acl lab int acl int indicates argument acl serves label second argument writing appear simply omit 
access simple type written acl lab int acl int 
operational semantics section distinguish application policy values order ensure policy code inadvertently undue privilege application functions 
application values app consist pre values integers labels containing values type term abstractions labeled policy values wrapped brackets 
values policy code pre values preceded zero relabeling operations 
encodings 
examples readable syntactic shorthands shown 
shorthands standard 
policy keyword designate policy code brackets 
dependent pair type allows name element bound type second policy login user string pw string token match user pw user user failed token token policy member lab lab match acl true acl tl member tl false 
enforcing simple access control policy 
policy access lab user cap int acl lab data acl match member acl true data halt access denied element 
example arguments access pub function packaged dependent pair type acl lab acl world int acl inhabited terms acl world acl world 
dependent pairs encoded dependently typed functions 
extend shorthand function application policy function definitions type abbreviations tuples multiple type term arguments obvious way 
write wildcard don care pattern variable 
phantom label variables 
extend notation polymorphic functions way permits quantification expressions appear type 
consider example policy add int int policy function takes labeled integers arguments adds result having type int 
unusual thing function label normal term argument quantified label 
reason sense fable un labeling operations merely hints type checker dis associate label term type 
operations types erased runtime affecting result computation 
erasing types example policy add clearly function mention reason treat add polymorphic labels called pair integers label irrespective label 
express kind polymorphism writing phantom label variable normal type variables list follows function name 
example phantom variable add listed course label arguments phantom 
instance access simple function section acl label argument passed runtime 
simplicity formalize phantom variable polymorphism 
technical report model phantom variables contains associated proof soundness 
example access control policy 
illustrates simple complete enforcement policy access control 
protected data label listing users authorized access data 
particular data type acl acl encodes acl label 
policy login function calls external function authenticate user checking password 
authentication succeeds pattern returns label user unique identifier user 
login function returns pair consisting label integer labeled pair serves runtime representation principal 
access function takes elements pair arguments 
fable enforces policies produce labeled values assured term type int user produced login 
access function arguments consist protected data label acl data data 
access function calls member function see user token acl 
successful label true returned case access returns data acl label removed 
typing defines typing rules fable 
main judgment types expressions 
index indicates part policy application 
policy terms permitted relabeling operators 
records kinds information maps variables types records bound type variable records assumption matches pattern checking branches pattern match 
rules int var fix tab tap standard polymorphic lambda calculi 
abs app standard dependently typed language 
abs introduces dependent function type form 
app types application dependently typed function 
usual require type argument match type formal parameter function 
may occur return type expression type environment color environments substitutions colors pol app fix fix ei lab lab lab abs lab lab int int tab hide lab pn dom xi fv pi dom xi lab pi lab xi lab pi ei match pn en pol pol lab pol pol pol app lab lab match var tap show pol pol conv types convertible te id type contexts term label contexts lab te sym te ctx dom fv lab te reduce te refine type formed environment int int pol lab tvar lab lab fun 
static semantics fable 
pol lab lab slab type application substitute actual argument 
example consider application access simple function having type acl lab int acl int term acl alice bob 
app resulting expression function type int acl alice bob int indicates function applied integer labeled precisely acl alice bob 
key feature dependent typing type system ensures associations labels terms protect forged broken 
rule lab gives label term singleton label type lab long component ei type lab 
rule acl alice bob type lab acl alice bob 
matter expression lab high type lab lab high requirement value 
rule hide allows singleton label type subsumed type labels lab 
rule show converse allowing type label precise 
rule match checks pattern matching 
premise confirms expression matched label 
second line premises describes check branch match 
patterns differ patterns say ml respects 
second premise second line requires xi lab pi lab indicating patterns fable allowed contain variables defined context 
second pattern variables may occur pattern 
features convenient pattern matching check term equality 
example expression alice match acl branch evaluated runtime value label variable acl alice alice 
key feature match final premise second line states body branch expression ei checked context including assumption pi states matches pattern pi 
assumption refine type information checking similar typecase rule conv illustrate shortly 
match requires branch leaks variables bound patterns final type match ensured second premise confirms formed top level environment including pattern bound variables 
simplicity require default case pattern matching expressions third premise requires pattern single variable occur 
implementation check matching complete standard techniques 
rule types operation 
expression type strips label type produce expression type conversely adds label type pol index rules indicates operations admissible policy terms 
index introduced pol checking body bracketed term 
example expression int public app int public int typed index pol pol 
rule conv allows type assuming type convertible written rules te id te sym define convertibility reflexive symmetric 
rule te ctx structurally extends convertibility type contexts syntax denotes application context type defines type results replacing occurrence hole example context int type int 
course rule te ctx applied times relate larger types 
interesting rules te refine te reduce consider types contain labels constructed applying context expression 
rule te refine allows structurally similar types considered equal embedded expressions equated pattern matching recorded constraint match 
see consider example tok cap login joe xyz match tok user access tok cap halt give login function type string string lab int type access defined lab user int type check access tok rule app requires function parameter formal argument type tok type lab access expects type lab user 
call access occurs branch match context includes refinement tok user due match 
show give tok type lab tok applying te refine lab tok lab user tok type lab user required 
similarly access tok cap check type int tok cap convertible int user presence assumption 
rule te reduce allows fable types considered convertible expression component reducible expression component reduction defined shortly :10.1.1.47.155
example int lab low int low lab low low 
complication type level expressions may contain free variables 
example suppose wanted show lab int lab int 
intuitive types considered convertible lab value 
handle case rule permits types convertible typed substitution free variables 
captures idea precise value immaterial reductions typed substitutions reduce value substituted satisfying obligation exhaustively considering possible substitutions obviously intractable 
additionally guarantee expression appearing type converge value 
type checking fable undecidable 
uncommon dependent type system type checking cayenne undecidable 
dependently typed systems impose restrictions usage recursion type level expressions ensure type level terms terminate 
explore option full system appendix additionally possible decision procedures partially decide type 
simplification attempt show closed types small step chromatic reduction rules evaluation contexts ec vc vc match pi ei ec ec ctx pol app vc vc app tap fix fix fix vc pi vc match vc pn en match app blab app bint app app pol pol nest expression matches pattern substitution var ei pi 
dynamic semantics fable 
con pol free variables 
implementation fable combination techniques 
type information 
free type declared type lab information substitute similarly type context includes assumption form checking branch pattern substitute type level expressions typically manipulate labels pattern matching simple heuristic determine branch take pattern matching expressions free variables 
techniques suffice examples applications 
technical report discusses decision procedures greater detail proves sound 
judgment states formed 
rules int tvar lab standard fun defines standard scoping rules names dependent function types defines standard scoping rule universally quantified type variables 
slab ensure expressions appear types lab type 
notice type level expressions typed pol context 
fable enjoys type erasure property un labeling operations appearing types pose security risk 
feature effect section protect sensitive information may appear labels 
operational semantics defines fable operational semantics 
define pair small step reduction relations app pol application policy expressions respectively 
rules form apply policy application expressions 
values kind expression different parameterize evaluation contexts ec color expression context app pol expression reduced 
rule ctx uses evaluation contexts ec similar type contexts enforce right evaluation order call value semantics 
policy expression reduction pol takes place brackets pol 
rules app tap fix define function application type application fixed point expansion respectively terms substitutions standard 
rule match relies standard pattern matching judgment defined true label value matches pattern 
match determines pattern matches expression reduces match expression matched branch body applying substitution 
con rule pattern matching judgment non trivial rule 
explained section pattern variables may occur pattern con propagate result matching earlier sub expressions matching subsequent sub expressions 
example pattern matching fail attempting match acl alice bob acl 
achieved con matching alice alice var try match bob alice impossible 
applied policy function eventually reduce bracketed policy value 
form brackets may removed value application code 
blab bint handle label expressions integers respectively 
maintain invariant un labeling operators appear policy code rules tabs binders respectively bracketed abstractions allowing reduced app tap 
brackets removed labeled values application code preserve labeling invariant 
hand brackets removed expression policy code nest 
useful reducing expressions produces steps nest combination pol remove inner brackets 
allows operation annihilate top relabeling operation 
notice expressions relabeling operation evaluated runtime relabelings affect types purely compile time entities 
types appear tap usual system soundness state standard type soundness theorems fable 
addition ensuring typed programs go wrong get stuck put soundness result proving security policies encoded fable satisfy desirable security properties 
discuss section 
appendix contains proofs theorems extension fable includes substructural types section 
theorem progress 
vc vc 
theorem preservation 
example policies fable section demonstrates fable flexibility encode security policies 
prove typed program policies enjoys relevant security properties program sure enforce policy correctly 
space constraints preclude presentation encodings explored focus kinds policies access control provenance static information flow 
sketch extensions fable support substructural types useful enforcing state policies security automata 
conclude discussing fable design eases construction proofs policy correctness 
access control policies access control policies govern programs release information information released control 
prove access control policy implemented correctly show programs authorized access information learn information way bypassing policy check uncommon production systems employing kind covert channel 
call security condition non observability 
intuitively state non observability follows 
program allowed access resource having label program identical replaced resource having type label evaluate way produce result take steps way producing result 
true assuming reduction deterministic inferring information protected resource 
intuition formal show evaluations programs bisimilar difference value protected resource 
express define equivalence relation called similarity analogous definitions low equivalence holds terms differ sub terms labeled intention label restricted resources 
definition similarity 
expressions identified renaming similar label relation second rule important 
states arbitrary expressions considered similar label labeled parts program structurally identical stated remaining congruence rules shown full relation appendix 
extend similarity bisimulation follows similar terms bisimilar reduce similar subterms indefinitely reduction possible notion bisimulation timing termination sensitive 

typename prov lab auditors policy apply lf prov mx prov lf mx lm union auditors lm lm policy flatten prov prov inner inner lm union auditors lm lm 
enforcing dynamic provenance tracking policy 
definition bisimulation 
expressions bisimilar label written exists non observability theorem states program contains policy bracketed terms just application code substitution may refer access control functions access member free variables capability user free variable cap 
capability gives program authority user user 
program may refer protected resource label acl authority user insufficient access access control policy member user acl false 
conditions show typed vi substitute substitution resulting programs bisimilar reduction independent choice vi 
theorem non observability 
free expression ta tm cap int user acl app te acl user label constants substitution access member cap user 
type respecting substitutions vi app vi acl member user acl false acl 
notice theorem indifferent actual implementation acl label member function 
example policy fairly simplistic far sophisticated model 
instance chosen labels stand rbac rt style roles member invoke decision procedure determining role membership 
likewise theorem concerned origin user capability function sophisticated login relied cryptography 
important point fable ensures second component user credential lab user int unforgeable application code 
straightforward extend theorem speak policies provide access resource single membership test code policy access cap lab user cred int acl lab match member acl true acl fail caller presents user credential access control label acl resource labeled label 
membership check succeeds function type acl returned 
function immediately resource authorized label 
useful policy queries expensive 
useful encoding form delegation releasing user credential user release function uses credential limited effect 
course may undesirable policy known change frequently accommodated 
variations combine static dynamic checks possible 
dynamic provenance tracking provenance information recording source derivation history information 
provenance relevant computer security reasons 
provenance useful auditing discover data inappropriately released modified 
second provenance establish data integrity carefully accounting document sources 
section describes label provenance tracking policy constructed fable 
prove policy implemented correctly show programs accurately capture dependences sense information flow value produced computation 
presents provenance policy 
define type prov describe pair component label records provenance second component 
policy agnostic actual form provenance labels represent things authorship ownership channel information received policy lub lab lab match high high high low policy join lub policy sub lab lub policy apply 
enforcing static information flow policy 
interesting aspect prov provenance label labeled ary label constant auditors 
represents fact provenance information subject security concerns confidentiality integrity 
intuitively think data labeled auditors label accessible members group called auditors course complex policy 
note provenance label labeled having type lab auditors incorrect write second component type requires type lab 
appears type second component 
explained section operations types pose security risk types erased runtime 
policy function apply wrapper tracking dependences function applications 
idealized language fable sufficient limit attention function application policy full language define wrappers constructs 
argument apply provenance labeled function lf called second argument mx 
body apply decomposes pair lf label function likewise argument mx 
applies function stripping label argument 
provenance result combination provenance function argument 
write label pair union associated final result 
notice strip auditors labels combining add label label final result 
policy defines function flatten convert value type prov prov type prov extracting nested labels lines collapsing union third line associated inner pair labeled component fourth line 
example client program uses provenance policy client prov prov prov apply apply function takes labeled argument function argument arguments calls apply twice get result type prov 
tuple component labeled provenance label form union union lf lx ly second component value labeled provenance label 
label lf provenance label function argument lx ly provenance arguments respectively 
note caller client instantiate type variable type prov int 
case type returned value prov prov int flattened necessary 
prove provenance information tracked correctly cheney 
intention value type prov influences computation value type prov provenance label mention provenance label provenance tracked correctly change affect values values program unchanged 
express similarity relation defined section relates values differ sub terms type prov provenance label mentions application program compiled policy executed contexts differ choice tracked value label compute results differ sub terms colored theorem dependency correctness 
free expression ta prov app substitution apply flatten 
type respecting substitutions vi app vi prov case implies app app static information flow policies discussed far rely runtime checks 
section illustrates fable encode static lattice information flow policies require runtime checks 
static information flow type system labels run time witness appear types 
labels ordered relation typically forms lattice 
ordering lifted subtyping relation labeled types 
assuming lattice ordering fixed execution typed programs proven adhere policy defined initial label assignment appearing types 
illustrates policy functions small sample program 
encoding define point security lattice atomic labels high low protected expressions labeled types high 
ordering low high exemplified lub upper bound operation lattice 
join function similar flatten function combines multiple labels type single label 
interesting thing label attached label expression lub label value high 
type rule conv show term type int lub high low type int high lub high low high 
critical able type programs policy 
policy includes subsumption function sub takes arguments term type label allows type lub 
restatement subsumption rule implies 
types erased sub essentially identity function optimized away 
policy function apply function order call adds label computed result 
consider client program example usage static information flow policy 
client int high int high low int low sub int high join int apply int high int high function client calls function expects parameter type int high type int low 
call type check program uses sub coerce type int lub low high convertible int high 
call apply returns value type int high low 
call join collapses pair labels client return type int lub high low converts int high 
proved fable programs policy enjoy standard noninterference property appendix 
shown fable static information flow policy permissive information flow policy implemented functional subset core ml formal language appendix 
appendix shows dynamic provenance tracking static information flow policies combined enforce dynamic information flow 
tracking side effects fable far security policies apply purely functional programs 
enforcing policies take side effects account challenging side effects conduits information 
consider small program 
program assignment occurs 
contents contain information zero nonzero 
usual strategy information flow type systems prevent leaks add label type mutable pointers ref 
extending prior information flow policy try write wrapper assignments follows policy update ref effect client int ref update int update function returns value type int effect witnesses side effect label effect reveals side effect involving occurred computation 
requiring application functions side effects include effect witnesses returned values design policy limits information leaks effects 
fable system prevents application program ignoring returned effect 
consider client application program 
function updates location obtains effect witness update policy discards 
give client type int ref int 
calling function clearly produces side effect write location labeled type function reflect fact type function int ref int effect 
indicates correctly calling effect may influenced returned value 
full fable calculus addresses problem embedding language substructural type system 
type system return type update relevant type enforces returned value 
setting occurs value passed policy code 
type system fail type check client discards relevant value 
space constraints preclude discussion full language appears appendix proofs progress preservation theorems 
addition relevant types show appendix policies encoded full fable track memory effects 
appendix shows affine types kind substructural type values affine type may program enforce arbitrary safety properties encoded security automata manner similar walker 
proofs security properties fable mentioned fable guarantee typed programs implement particular security policy semantics correctly 
said fable designed facilitate proof theorems 
illustrate chose different techniques correctness results reported 
conclude experience metatheory fable provides useful repository lemmas naturally applied showing correctness various policy encodings 
believe task constructing correctness proof fable policy onerous possibly considerably simpler corresponding task special purpose calculus enforcement single security policy 
remainder section report experience proofs discuss preliminary progress reasoning proofs involving multiple policies 
proofs key features fable play central role 
dependent typing fable allows policy analyst assume policy checks performed correctly 
instance calling access function access value type acl label expressing security policy acl 
type system ensures application program construct label say acl public trick policy believing label acl protects dependent typing rules confused 
second restriction application code directly inspect labeled resources ensures policy function mediate access protected resource 
assuring complete mediation unique fable zhang check operations sensitive objects preceded policy checks fraser 
analysis instances ensures policy check taken place necessarily correct 
techniques vulnerable flaws due confused 
combined insights proof non observability access control policy appendix particularly simple 
essence fable system ensures value labeled type treated abstractly application program 
observation proof proceeds manner similar proof value abstraction 
general semantic property languages fable support parametric polymorphism types 
policy implemented language ml features 
instance integer labeled access control list represented ml user list integer pair type string list int 
policy module export pair type preventing application code inspecting value directly provide function expose concrete type successful policy check 
encoding suffice simple policy idioms function access cap section reveals structure label avoid need additional checks 
types insufficient support static checking policies case information flow security automata 
show dependency correctness appendix followed proof technique tse zdancewic 
technique involves defining logical relation relates terms set provenance labels include label recall goal theorem show prov related substitutes provenance labeled value vi crux proof involves showing logical relation preserved substitution form substitution lemma logical relation 
constructing infrastructure define logical relation requires strategic applications standard substitution lemma fable discharge proof difficulty 
possible reuse infrastructure dependency correctness proof show noninterference result static information flow policy tse zdancewic choose technique due pottier simonet appendix 
technique involves representing pair executions fable program syntax single program showing subject reduction property holds true 
logical relations proof constructed infrastructure technique proof easy consequence fable preservation theorem 
correctness theorems impose condition application program free 
theorems apply situations single policy effect program 
practice multiple policies may conjunction reason interactions policies result violations intended security properties 
characterize conditions policy definitely composed defined simple type criterion satisfied policies implies policy interfere functioning policy applied tandem program 
intuitively policy composable enclosing labels unique top level label constructor treated namespace 
policy manipulates labels labeled terms belong namespace safely composed policy 
main benefit compositionality modularity multiple composable policies applied program reason security entire system considering policy isolation 
policy designers able encapsulate policies namespace package policies libraries reused policy libraries 
notion composition noninterference property policy deemed composable shown depend influence functioning policy 
noninterference properties contexts condition restrictive realistic examples policies design interact 
find policies compose definition perform kind declassification endorsement allowing labeled terms exit unlabeled terms enter policy namespace 
conjecture vast body research declassification brought bear order recover degree modularity interacting policies 
appendix contains formal statement proof policy noninterference theorem discussion applicability condition 
fable applied web programming implemented fable extension links functional web programming language call extension security enhanced links 
section briefly describes implementation presents experience build applications wiki line store 
links new programming language designed web programming easier 
allows programmer write entire multi tier web application single links program compiler split program components run database sql server local fragment links code client javascript 
extending links fable label security policies build applications police data tiers level trust tiers 
test applications assume server database trusted client 
links functional programming language equipped standard features recursive variant types datatypes pattern matching parametric polymorphism higher order functions 
fable policies far naturally 
difference define special type lab fable allow values certain recursive variant types treated labels pattern matched standard links syntax 
legal variants consist nullary constructors constructors types refer legal variants 
policy functions designated qualifier policy examples native support dependent products 
consists lines code 
constructed mimic set webbased document management systems designed promote information sharing sixteen agencies comprise united states intelligence community 
document represented tree type definition typename doc node doc doc leaf string labeled doc labeled constructor allows nodes security label dependent pair doc 
type alias define security labels documents 
defines access control policy typename group authors auditors administrators typename acl read list group write list group type includes single constructor acl applied tuple maintain list groups authorized read document list allowed modify document 
groups authors document authors members auditors group users trusted audit document administrators include system administrators 
implement authentication credentials terms type credential shown 
type similar type credentials produced login fable access control policy credential includes additional useful information user identifier name 
possible document modifications mediated write access policy function type policy write access 
credential function allows caller pass user credential function intended modify resource labeled access control label write access determines user writer group function applied policy modified document access control label original 
added revision history tracking policy similar spirit provenance tracking policy section 
track provenance operations alter document enforcing access control policy 
redefine type contains provenance labels typename create modify copy delete restore relabel typename oper user user typename composite acl prov list prov component composite constructor records provenance information list 
records operation performed identity authorizing user 
tracked operations type 
operations include document creation modification copy pasting documents deletion restoration documents completely deleted document relabeling 
authorized users interface alter access control labels protect document 
policy functions enforce composite policy fairly modular set access control provenance 
projects appropriate component composite label considering remaining labels 
addition building extended wine store commerce application comes links creating labels represent users associating labels orders shopping cart order history 
helps ensure order accessed customer created 
user id stored credential order information defined 
policy functions view add items order implemented simple wrappers read write access policies 
typename order list experience write applications quite positive 
access control policies easy define policy code consisting roughly lines code total including helper functions 
access control login policy code modular shared entirety applications 
provenance policy consists lines code straightforward 
provenance policy section provenance labels essentially track direct data flows documents 
easier program far fewer program operations need mediated policy 
support richer policies easing programming burden investigating approach program rewriting policy specification automatically transforms program insert appropriate label manipulations 
related dependently typed languages wide variety applications 
context security zheng myers formalize support dynamic security labels associated data express information flow policies 
technical machinery associating labels terms system similar 
main differences 
security policy information flow policy particular label model expressed directly type system fable security policy label model customizable 
discussed section dynamic labels information flow policies encoded fable combination dynamic provenance static information flow policies 
second fable allows non values appear types lub 
permits combination static dynamic policy checking cost potentially undecidable type checking 
implementation uses heuristics ensure type checking diverges 
walker type system expressive security policies dependently typed 
labels walker language uninterpreted predicates arbitrary expressions 
walker system enforce policies expressed security automata capture safety property 
kind policy enforceable fable extended substructural types 
walker system policy enforced means runtime check 
order recover amount static checking walker suggests user add additional rules type system specific done 
additional rules proved correct respect desired security property 
observed dependent types express kind customized type system fable policy functions fit description 
example sub function policy effectively introduces subsumption rule type system 
researchers explored user defined type systems supported directly customizable type qualifiers 
shankar lattice type qualifiers track dataflow properties taintedness zhang fraser qualifiers check complete mediation access control systems 
millstein developed approach programmers indicate data invariants custom type qualifiers intended signify 
cases able automatically verify invariants correctly enforced custom type rules 
invariants relatively simple ultimately develop framework similar vein correctness properties fable enforcement policies partially automated 
marino proposed proof assistants purpose plan explore idea context fable policies 
li zdancewic show encode information flow policies haskell 
define meta language control flow structure program available inspection program 
enforcement mechanism relies lazy evaluation strategy haskell allows control flow graph inspected information leaks prior evaluation 
encoding permits custom label models show encoding information flow policy 
clear system encode range policies discussed 
technique separating enforcement policy rest program grossman colored brackets 
brackets model type abstraction ensure privilege relabeling terms mistakenly granted application code 
result need specially designate application code may arise policy terms keeping things bit simpler 
plan investigate different colored brackets distinguish different enforcement policies grossman support multiple agents 
inasmuch targeted links web programming language platform build fable related swift sif jif projects aim secure web applications 
technique permits web application split policy javascript code runs client java code server framework build secure servlets 
discussed section links provides similar functionality additionally integrates database access code framework 
new security checking features swift practical verified security multi tiered applications reach 
fable core formalism programming language programmers may specify security policies reason policies properly enforced 
shown fable flexible implement wide variety security policies including access control provenance static information flow policies 
argued fable design simplifies proofs programs policies correctly 
implemented fable part links web programming language resulting language call build substantial applications secure wiki secure online store 
remains fully satisfactory platform knowledge existing framework enables enforcement wide variety security policies equally high level assurance 
noble millstein 
framework implementing pluggable type systems 
oopsla proceedings st annual acm sigplan conference object oriented programming systems languages applications pages new york ny usa 
acm press 
anonymous 
fable language enforcing user defined security policies technical report 
technical report july 
aspinall hoffmann :10.1.1.47.155
advanced topics types programming languages chapter dependent types 
mit press 
augustsson 
cayenne language dependent types 
icfp proceedings third acm sigplan international conference functional programming pages new york ny usa 
acm press 
badger sherman walker 
domain type enforcement unix prototype 
computing systems 
bertot cast ran 
interactive theorem proving program development 
coq art calculus inductive constructions 
texts theoretical computer science 
springer verlag 
biba 
integrity considerations secure computer systems 
technical report esd tr usaf electronic systems division 
bishop 
computer security art science 
addison wesley 
buneman chapman cheney 
provenance management curated databases 
sigmod 
cheney ahmed 
provenance dependency analysis 
database programming languages pages 
chin millstein 
semantic type qualifiers 
pldi proceedings acm sigplan conference programming language design implementation pages new york ny usa 
acm press 
chong liu myers qi vikram zheng zheng 
secure web application automatic partitioning 
sosp proceedings acm sigops symposium operating systems principles pages new york ny usa 
acm 
chong myers nystrom zheng zdancewic 
jif java information flow 
software release 
located www cs cornell edu jif july 
chong vikram myers 
sif enforcing confidentiality integrity web applications 
usenix security proceedings sixteenth usenix security symposium 
cooper lindley wadler 
links web programming tiers 
groups inf ed ac 
uk links papers links esop pdf 
tool adding type qualifiers www cs umd edu 
denning 
lattice model secure information flow 
communications acm may 
fournet gordon 
stack inspection theory variants 
proceedings th acm sigplan sigact symposium principles programming languages pages 
fraser nick 
applying flow sensitive verify authorization check placement 
plas 
acm press 

girard 
interpr tation fonctionelle des coupures de arithm ordre sup 
phd thesis universit paris vi 
gong 
inside java platform security architecture api design implementation 
addison wesley longman publishing boston ma usa 
grossman morrisett zdancewic 
syntactic type abstraction 
acm trans 
program 
lang 
syst 
harper morrisett 
compiling polymorphism intensional type analysis 
popl proceedings nd acm sigplan sigact symposium principles programming languages pages new york ny usa 
acm press 
hicks king mcdaniel hicks 
trusted declassification high level policy security typed language 
plas proceedings workshop programming languages analysis security pages new york ny usa 
acm press 
landwehr 
best available technologies computer security 
ieee computer july 
li mitchell winsborough 
design role trust management framework 
ieee symposium security privacy 

integrating flexible support security policies linux operating system 
proceedings freenix track usenix annual technical conference pages berkeley ca usa 
usenix association 
marino chin millstein tan simmons walker 
mechanized metatheory user defined type extensions 
acm sigplan workshop mechanizing metatheory 
mitchell 
foundations programming languages 
mit press 
myers liskov :10.1.1.101.441
protecting privacy decentralized label model 
acm transactions software engineering methodology 
neumann boyer levitt robinson 
provably secure operating system system applications proofs 
technical report csl sri international computer science laboratory may 
perl documentation :10.1.1.10.3979
perl org html 
pottier simonet 
information flow inference ml 
acm transactions programming languages systems toplas jan 
role access control 
csrc nist gov rbac 
reuters october 
intelligence spy version wikipedia 
sabelfeld myers 
language information flow security 
ieee journal selected areas communications jan 
sabelfeld sands 
dimensions principles declassification 
ieee computer security foundations workshop csfw june 
securityfocus access control bypass vulnerabilities 
search securityfocus com sbm query access control bypass 
shankar talwar foster wagner 
detecting format string vulnerabilities type qualifiers 
proceedings th usenix security symposium washington aug 
su 
essence command injection attacks web applications 
popl conference record rd acm sigplan sigact symposium principles programming languages pages new york ny usa 
acm press 
hicks tse zdancewic 
managing policy updates security typed languages 
proc 
computer security foundations workshop csfw pages july 
tse zdancewic 
run time principals information flow type systems 
ieee symposium security privacy 
volpano smith irvine 
sound type system secure flow analysis 
journal computer security 
wadler 
implementation functional programming languages chapter efficient compilation pattern matching 
prentice hall 
walker 
type system expressive security policies 
popl proceedings th acm sigplan sigact symposium principles programming languages pages new york ny usa 
acm press 
walker 
advanced topics types programming languages chapter substructural type systems 
mit press 
xi 
applied type system extended 
post workshop proceedings types pages 
springer verlag lncs 
xi pfenning 
dependent types practical programming 
conference record popl th acm sigplan sigact symposium principles programming languages san antonio texas pages new york ny 
zdancewic 
encoding information flow haskell 
csfw proceedings th ieee workshop computer security foundations page washington dc usa 
ieee computer society 
zhang edwards jaeger 
static analysis authorization hook placement 
usenix security 
zheng myers 
dynamic security labels noninterference 
proceedings nd international workshop formal aspects security trust fast toulouse france august 
policy flow src lab dest lab oracle src dest flow src dest policy low oracle low policy sub src dest cap unit flow src dest src dest policy app join client lb lab bool lb lx lab lx ly lab ly join lx ly fx flow lx fy flow ly match fx fy flow lx flow ly sub sub tmp app app tmp 
flow allowed oracle lattice 
enforcing dynamic information flow policy 
policy flow src lab dest lab oracle flow src dest flow src dest oracle enc src dest enc src dest dynamic information flow downgrading policy aes enc src des cap unit enc src dest data bytes src key bytes dest dest key data 
trusted explicit policy 
realistic information flow policies rarely simple section 
example security label data may known run time label may complex simple atom drawn dlm higher level policy language rt :10.1.1.101.441
shows dynamic security labels associated data information flow policy enforced combination static dynamic checks 
label lattice defined external oracle function enforcement policy interfaces policy function flow expects labels src dest arguments determines oracle permits information flow src dest 
representation labels policy depends implementation oracle 
flow function type src lab dest lab lab unit 
oracle permits flow flow function returns capability similar provided login function 
sub function takes capability argument proof type src may coerced type dest 
low function appeal oracle acquire bottom label lattice 
main program example high level behavior static case branches boolean returns security labels arguments statically known 
argument lb label term specifies security level similarly lx ly previously encoding booleans requires branch type including security label 
case program arranges branches type join lx ly 
lines main expression flow function attempt obtain capabilities witness flow lx ly join lx ly 
match inspects labels returned flow case flow 
final premise match permits type fx refined lab fx lab flow lx type refined unit flow lx similarly 
remainder program similar static case requires uses subsumption known statically labels 
type inferred program 
lb lab bool lb lx lab lx ly lab ly join join lx ly lb downgrading policies pure information flow policies strong programs 
realistic policies include provision downgrading information higher lower security levels 
shows simple practical downgrading policy form trusted encoded 
enhance flow function previous example may produce kind capability 
oracle flow defines label lattice src dest flow src dest capability returned previously 
oracle enc function decides encrypted flow data labeled src permissible destination labeled dest flow returns enc src dest capability 
case policy defines particular encryption function aes enc requires enc src dest capability argument encrypts data level src level dest 
type function precise state encrypted downgrading src dest permissible key known dest 
ensures downgraded data decrypted dest importantly ensures dest receives data encrypted key secret dest ensuring information secret key released 
including implementation aes enc function policy beneficial clearly establishes trusted component application 
embedding substructural type system summary appendices refer functional core fable section fable stand full system summary toto appendix far security policies apply purely functional programs 
wider variety security properties enforced add substructural typing framework 
instance side effects straightforward add enforcing policies take side effects account challenging additional support type system 
section informally discuss inadequate enforcing policies track side effects 
sketch extension type system add relevant types values relevant type program show example information flow policy correctly tracks effects 
kinds substructural types useful 
appendix shows affine types values affine type may program enforce arbitrary safety properties encoded security automata manner similar walker 
expression type effect environment relevant assumptions list relevant assumptions var pol pol pol rel rel rel rel ref subr drf rel ref unit asn fv pol abs pol type kind environment rel pol lab lab 
static semantics fable 
selected judgments attempting track effects pol lab language information flow policies account leaks occur due side effects 
instance assignment variable occurs context control dependent secret value contents contain information secret 
usual strategy prevent leaks label locations secrecy level prevent assignments locations security level lower label try write policy function permits assignment labeled 
look policy update ref unit low effect ref function returns labeled unit value witness side effect label indicates side effect occurred computation produced result 
prevents program ignoring captured effect application program type check int ref 
update int function type int ref int 
calling function clearly produces side effect write location labeled return type function reflect fact 
fact relevant types reject program incorrect discards effect witness 
adding relevant types 
fable augments adding supporting relevant types 
syntactic extensions summarized extension syntax 
expressions 
rel pre values 
effects types 
ref kinds 
expressions include memory locations dereferencing assignment pre values augmented include locations 
addition provide policy code ability designate certain values relevant extending form relabeling operator optionally include rel qualifier 
expressions side effects careful ensure expressions appear types pure 
static semantics fable coarse grained type effect system assigns effect expression may access memory 
type language extended include effect annotations appear function arrows 
include ref type importantly include type qualifies type relevant 
extend language type kinds include kind classification relevant types 
shows main elements fable language full semantics appendix addition properties fable type system enforces main invariants 
tracks effects expressions ensure type level expressions pure 
second ensures value relevant type passed policy function consumed manner chosen policy function 
machinery relevant types hand policy ensure term generated witness side effect type rel unit low effect hidden away program value produced function part returned value say component tuple passed policy decide propagate effect information 
main typing judgment form 
form 
context component records set typed variables effect records effect 
list assumptions denote splitting disjoint lists 
judgment app system ensure possible control paths assumption 
want exempt policy expression restrictions policy trusted manipulate relevant values effect witnesses manner choosing 
type rules var enforce requirement 
var variable uses single relevant assumption require larger 
restriction apply typing policy code relevant assumption treated intuitionistically policy code 
provides policy way introducing typed values similar 
subr type treated relevant type 
typing abstraction ensure relevant assumptions body abstraction reflected type function 
similarly effects body reflected type 
second premise policy update ref rel low effect policy combine lab lab match fx fx lub glb fx fx policy seq unit rel unit rel rel combine 
tracking effects relevant types fable 
abs argument function relevant type record function argument relevant assumption 
third premise body effect record effect function arrow 
relevant assumptions body function ensure relevant value runtime give function relevant type rel 
ensures function applied 
drf records side effect recording 
rule asn records assignments side effect 
standard substructural system permitted split set relevant assumptions ensure ei discharges assumption ai 
simplicity allow relevant values escape heap 
system system attempts track say resource usage useful lift restriction 
purposes additional complication provide obvious benefit 
leave investigation issue 
pol type policy term pol colored context 
additional restriction relevant assumption occur body ensures application function mistakenly hide relevant value policy 
consider example application program example effect rel unit ensure effect witness argument effect policy 
requiring effect appear free policy expression ensure function applied witness witness passed policy expression restriction possible witness forgotten function applied 
shows kinding judgments 
gives kind relevant type encodes sub kinding relation ensure type level expressions effect free additionally ensures kind kind kind hierarchy appendix contains proofs standard progress preservation theorems fable theorems theorem stated 
addition proved programs terminate typed value application program eventually passed policy code theorem 
straightforward prove type erasure property reduction rules inspect types 
theorem progress 
formed memory vc vc 
theorem preservation 
formed memory 
tracking effects fable equipped relevant types write policy accurately tracks effects program 
strategy label values composite label describes standard confidentiality label value represents effect computation produced value result 
policy shown includes function update assign labeled returns typed labeled unit witness side effect 
allow imperative style programming side effects policy provides seq function sequence effectful computations 
function takes arguments produce values type respectively values protected label recording confidentiality effect computation 
body seq executes computation sequence returns result second computation 
seq careful record effects label result 
label combine assert confidentiality result component effect greater effect component 
notice relevant type body seq seq policy function free ignore type variables seq kind ensures variables instantiated type high effect low hiding effect policy 
encoding security automata affine types relevant types useful tracking effects substructural types useful 
briefly sketch affine types encode policies expressible security automata walker 
suppose wish enforce policy program read data files file system file tagged label indicating security level 
long program read data high security file free send data network 
program reads high security file subsequently send data low security network 
shows encoding policy fable 
notation represents affine type contrast relevant assumptions discharged affine assumptions may discharged 
types easily added semantics simply permit affine assumptions dropped forcing 
rest system unchanged 
strategy enforce kind policy follows 
model current state security automaton affine dependent product type abbreviate state state affine duplicated ensures single object program represents current state 
expression label expression describing current state automaton 
functions types state function requires current state argument furthermore type expresses precondition current state described expression fable type checker ensure function type called states satisfy state precondition 
shows policy 
begins giving representation state object affine pair 
function delta encodes transition relation automaton 
argument object representing current state state acceptable 
second argument label intended label function 
instance function reads file system label read network send function label send 
third argument label say message sent network send function 
body function encodes automata state start state function read file read label high state state read 
label denotes current state transition read state occurs function called argument importantly delta function includes clause stating read state executing send function argument results bad state 
legal program states represented labels top level constructor state 
turn app function ensures function preconditions expressed type state argument met called 
function takes current state argument 
second argument app function label lf read send followed function 
arguments lx labeled argument type key 
state precondition called state calling argument results legal state top level constructor state label state bad 
apply app provide evidence fable type checker precondition met 
invoking delta current state labels inspecting state automaton 
state bad evidence precondition provided state lab unit policy delta state lab lab 
match fst state start read high state read state start state start state read send bad state read state read bad policy app state lf lab 
state state lf lf 
lx lab lx 
lt delta lf lx match lt bad halt state lf lx state state lf 
security automaton fable affine types 
unit variable label abstraction application type abstraction type application fix match pi ei rel fixed point matching relabeling relevant ascription policy brackets locations assignment deref patterns unit lab lab rel ref unit var universal function label labeled relevant type type variables effects unlabeled labeled relevant kinds 
full syntax fable 
program halts 
legal state results type state refined adding assumption premise match evidence call provided 
soundness fable definition formed environment 
formed names bound distinct ii 
iii 
rel lab rel lab iv 
definition store typing 
store modeled environment true 
dom dom ii ref ref iii range vn iv ref ref app theorem progress 
formed memory dom dom proof 
induction structure 
case var assumption dom dom 
var applicable value irreducible 
case subr trivial induction hypothesis 
case unit value 
case fix takes step fix 
case vc evaluation context form ec induction hypothesis applicable ri empty 
ctx goal established 
case straightforward application induction hypothesis premise 
case abs tab value 
case tap vc 
case induction hypothesis apply ctx show 
second case second premise tap vc inversion get vc form tap types form 
case app vc applying induction hypothesis third fourth premises respectively get result ctx 
vcv pol inversion third premise app application abs inversion principle tap 
vc app applicable 
app vc legal value 
case reduction proceeds bapp 
case asn induction hypothesis second premise respectively result ctx 
vc assumption dom dom asn vc app take step pol depending kind value vc take step mutually exclusive complete rules 
additional syntactic forms judgments variable bindings type variables refinement assumptions context track relevant assumptions typing context triple bindings relevant assumptions effect pol app color index expression type environment var rel rn ri ei rel lab rel lab rel lab rel lab rel lab rel lab subr tu tu rel tu rel abs tab unit unit unit fix rn ri ei lab lab lab lab xi fv pi dom xn pn xde xde te rel lab lab te xi te pi rel lab xi te pi ei match pn en fv pol pol pol pol rel lab lab tap rel pol pol asn match drf pol pol rel rel fix app conv splitting relevant assumptions rn app rn ip relevant rn rn pol esc type kind environment unit um rel lab pol rel lab sec pol rel lab rel lab lab pol rel lab lr pol rel lab lab rel rel types convertible rel lab te id dom fv ei ei ei pol te sym te reduce 
static semantics fable 
te ctx te refine additional syntactic forms judgments memory finite map locations values ec vc evaluation contexts match pi ei vc pre values application values pre values labeled bracketed abstractions policy values pre values labeled values small step chromatic reduction rules ec ec ctx pol app pol vc vc app tap fix fix fix vc pi vc match vc bi pi ei match app blab app app bloc app app pol nest pol rel pol pol app pol expression matches pattern substitution var ei 
operational semantics fable 
con case drf induction hypothesis premise take step ctx 
argument identical asn step possible 
case match match just induction hypothesis fifth premise match ri result ctx 
match vc pi ei show reduction match applicable 
establish note third premise match requires pn xde suffices show vc xde label typed values vc fifth premise type rel lab lab 
proceed inversion fifth premise establish syntactic form vc sub terms sub case lab rel lab impossible value reduced strip 
sub case impossible value reduced xl 
sub case impossible reduction nest possible 
sub case var succeeds value 
case pol induction hypothesis premise 
pol reduce nest 
pol pol sub case case reduction possible 
sub case case reduction blab possible 
sub case case reduction bloc possible 
sub case case reducible value 
sub case case reduction possible 
sub case case application value 
case clearly case pol 
induction hypothesis second premise result ctx 
pol premise pol pol 
pol form pol reduction proceed 
case clearly case pol 
induction hypothesis second premise result ctx 
pol definition value 
case clearly case pol 
induction hypothesis second premise result ctx 
rel pol reduction value possible 
case conv straightforward induction hypothesis premise 
lemma preservation formedness 
formed contains sub derivation form formed 
similarly contains sub derivation form formed 
proof 
straightforward induction structure expression typing type kinding derivations 
lemma sub coloring derivations 
formed app pol lemma substitution 
formed formed formed 
conditions true rx rx rx 
proof 
induction structure assumption iii 
free assume dom case var consider case 
sub cases depending dom 
sub case form rx sub cases sub case 
case fv dom form sub case ii 
initial know 
form 
sub case form rx 
trivial 
furthermore dom formedness 
show premise var 
establish weakening permissible 
consider case 
sub cases depending dom 
sub case form rx rx ry singleton 
proceed cases assumption manner identical var sub case 
sub case form rx 
proceed similar var sub case 
time conclude rx requires single relevant assumption context 
weakening adding reach 
case subr straightforward induction hypothesis premise 
case unit trivial 
case induction hypothesis premises obtaining ri ei rel lab ith premise 
note obtain rel lab desired result noting ri rn 
relevant assumptions partitioned manner induction hypothesis applicable 
case similar 
case straightforward induction hypothesis premise 
case fix dom 
fix fix 
induction hypothesis second premise establish 
case tab dom induction hypothesis premise 
careful rx initially 
restore type rel subr necessary 
case abs goal show abs dom mention premise ry 
context form formed lemma 
induction hypothesis applicable obtain ry reach goal judgment premise abs 
ry rx conclude application subr ensure preserves relevant qualifier function type similar tab 
case tap lemma proved simultaneous induction lemma establish 
induction hypothesis second premise straightforward 
case app assumption conclude rx 
induction hypothesis premise establish rx rel similarly second premise obtain rx get 
dom fv range substitutions commute give necessary 
case asn straightforward application induction hypothesis premises noting relevant assumptions case drf straightforward application induction hypothesis 
case fx straightforward application induction hypothesis 
case match app rx premises trivial re establish dom include xi 
fifth premise induction hypothesis restore te 
sixth seventh premises established induction hypothesis 
final premise rely companion lemma 
case conv applying induction hypothesis premise obtain proceed cases structure second premise show sub case te id trivial 
sub case te ctx induction 
sub case te refine 
sub case te reduce construction case pol pol premise 
pol induction hypothesis establish pol conclude pol 
app lemma proceeding 
case induction hypothesis premise 
lemma substitution kinding judgment 
formed formed formed 
conditions true rx rx rx 
proof 
simultaneous induction cases lemma structure assumption iii 
case trivial 
case 
case induction hypothesis premise formed case induction hypothesis premise 
case um induction hypothesis 
case ih lemma proved simultaneously show rel lab 
form app lemma proceeding 
case similar 
case induction hypothesis premise similar second premise 
corollary contraction assumptions 
formed true lab ii 
iii 
dom 
proof 
contain sub derivation application conv te refine assumption redundant conclude 
contain application te refine substitution lemma establish result 
lemma construction pattern matching assumption ii 
relevant application te refine concludes replaced application te id result lemma type substitution 
formed formed formed 
conditions true proof 
induction structure 
case var formedness free var 
case subr induction hypothesis 
case unit trivial 
case fix second premise form applying induction hypothesis premise sufficient fix establish goal lemma premise 
fix case fx induction hypothesis 
case tab lemma 
induction hypothesis sufficient establish goal tu tu tab case tap rel induction hypothesis right side left side sufficient establish goal 
case abs induction hypothesis premise ih premise sufficient conclude rel tap case asn drf app match induction hypothesis 
case conv induction hypothesis premise 
establish abs te reduce establish lab induction hypothesis erasure type substitution affect reduction 
te refine proceed similarly var cases appears case pol induction hypothesis 
note statement lemma impose restrictions color derivation 
case induction hypothesis 
proceed case case trivial 
case assumption 
case um rel induction hypothesis 
case sec induction hypothesis left side disjunct 
lemma strong normalization type level expressions 
proof 
type level expressions pure system fix 
result follows girard proof strong normalization system 
theorem preservation 
memory 
proof 
induction structure derivation 
examine side effect free cases obligation satisfied assumption 
case inversion subtyping judgments applicable 
treat subtyping cases uniformly separately 
case tap inversion conclude application tap 
inverting second premise tap find application tab form 
order re establish typed show straightforward application type substitution lemma lemma empty 
case fix inversion concludes fix 
applying substitution lemma second premise fix fix 
premise fix fv 
desired result 
case app inversion concludes application app form fourth premise app rel 
inverting find application abs 
second premise abs fifth premise 
goal show 
substitution lemma lemma applicable empty 
case match inversion application match match 
third premise gives premise get tv lab sub terms values type tv 
fv tv 
repeated application substitution lemma second premise rel lab 
show 
establish application corollary 
premise noting dom dom goal 
case 
case blab inversion pol premise 
non trivial case show pol rel lab omega app rel lab straightforward induction sub term pre value form base case app lab 
case bloc var 
case conclude show fv pol interesting case rel satisfy premise show fv true construction fv free case trivial 
case pol inversion pol pol premise 
induction hypothesis establish pol sufficient form app case nest inversion pol instance pol pol premise sufficient 
case inversion conclude nested premise pol pol case inversion conclude pol pol pol pol pol pol rel pol pol rel subr case inversion premise 
formedness case inversion asn 
establish formedness clause iv formedness show type 
app 
case similar pol pol construct app pol case similar 
case ctx proceed cases syntactic structure evaluation contexts 
case completed 
sub case judgment form 
induction hypothesis establish lab replace appropriate premise 
lab ej induction hypothesis establish lab 
fv 
re establish conv premise te ctx te reduce second premise 
sub case inversion instance app 
re establish hypothesis apply app 
induction hypothesis 
assumption unchanged remaining premises unchanged 
sub case similar previous case induction hypothesis second premise app 
sub case straightforward induction hypothesis 
sub case straightforward induction hypothesis 
sub case match top level typing judgment match 
induction hypothesis sixth premise 
premises unchanged 
sub case trivial induction hypothesis 
case case possible top level typing judgment subr conv subtyping judgments static semantics 
sub case subr conv trivial induction hypothesis 
sub case induction hypothesis premise easy establish lab fv 
sub case ctx establish conv te reduce premise 
lemma 
formed app fv 
proof 
induction structure typing derivation 
interesting case var 
fv 
theorem discharging relevant assumptions 
formed tx tx el tx expression app app tx value containing sub term ii contains sub derivation form ev bapp sub term iii contains subterm subterm proof 
induction structure 
case var tx irreducible 
clause formedness tx assumption tx case subr induction hypothesis premise 
case unit impossible unit requires 
case fix inverting third premise find application abs assumption requires rel impossible 
fixed point combinator applicable context non empty relevant assumptions 
case 
value lemma sub term produces type rel lab appears ith subterm diverge ith premise ensure reduction sequence contains necessary sub derivation 
case similar 
case fx straightforward induction hypothesis 
case tab value show holds 
side condition ensures lemma free contains sub term 
case tap app premise 
contains necessary sub derivation done 
substitution lemma lemma theorem app converse lemma app inverting find form 
possibility handled trivially pol requires fv condition iii satisfied 
second premise application tab 
conclude constructing necessary derivation starting tap lemma followed induction hypothesis case abs similar tab 
case app 
free reduction sequence contains necessary sub derivation done 
likewise free reduction sequence 
substitution lemma lemma theorem app converse lemma app inversion form 
sub case fourth premise application abs 
proceed cases structure 
definition 
applying induction hypothesis fifth premise find app second premise app 
construct necessary derivation app lemma followed induction hypothesis applied relevant assumption 
proceed previously time applying induction hypothesis relevant assumption 
form app induction hypothesis directly applicable 
solve consider app formed substitution lemma apply induction hypothesis 
sub case application pol trivially satisfies condition iii tx 
lemma sub term 
app satisfying condition ii 
case induction hypothesis second third premise necessary 
case drf conv induction hypothesis 
case match induction hypothesis fifth premise 
match pn en theorem guaranteed je premises match app repeated application substitution lemma app je jt apply induction hypothesis 
case lop inapplicable color index pol 
case pol premise fv 
satisfies condition iii 
policy login user string pw string token match user pw user user failed token token correctness access control policy policy member lab lab match acl true acl tl member tl false 
enforcing simple access control policy 
policy access lab user cap int acl lab data acl match member acl true data halt access denied reproduces access control policy section 
section prove correctness policy respect non observability condition 
definition similarity 
expressions identified renaming similar label relation fix fix ei fi pi qi match pi ei match qi fi dom dom ei ei interesting case definition similarity second judgment 
arbitrary expressions considered similar label long preceded labeling operator gives label remaining rules congruences 
full relation appendix extend similarity relation bisimulation standard manner 
definition bisimulation 
expressions bisimilar label written ei notice definition bisimulation timing termination sensitive 
require reducible identical number steps similarity true intermediate term final values 
define security property access control enforcement policy 
lemma similarity substitution 
substitutions 
proof 
construction definition substitution 
theorem non observability 
label constants acl user app vi acl free expression ta tm cap unit user acl app te type respecting substitutions access member cap user vi member user acl false acl proof 
induction structure typing derivation 
case unit trivial acl value 
acl case var interesting case form app acl 
case 
inverting assumption vi acl definition gives acl 
vi irreducible get acl 
case get 
case fix fix value fix fix fix fix fix fix acl acl case tab values bisimilarity fix 
acl case tap acl lemma 
type substitution lemma lemma ta tm cap unit user acl app te bisimilarity induction hypothesis applied judgment 
case abs similar tab 
case app interesting case viv cases induction hypothesis ctx 
sub case vi free form ta tm cap unit user acl conclude show app 
app acl hypothesis acl induction hypothesis acl 
immediately lemma 
conclude bisimilarity substitution lemma lemma establish acl ta tm cap unit user acl app te apply induction hypothesis judgment get bisimilarity 
sub case vi free case unable induction hypothesis establish bisimilarity pol 
app hypothesis applies app context judgments 
assumption free 
assuming form result application apply ta apply proceed cases syntactic form sub case lab user cap step reduction get cap apply closed term cap cap 
lemma cap acl cap establish bisimilarity side reduces step values cap acl cap sub case cap user application unit assumption free 
application ei unit user user reduces previous subcase similar values 
sub case acl lab similar previous sub case 
sub case tl acl application assumption free 
application ei acl vi reduces step match member user acl true data halt access denied typename prov lab auditors policy apply lf prov mx prov lf mx lm union auditors lm lm policy flatten prov prov inner inner lm union auditors lm lm 
enforcing dynamic provenance tracking policy 
assumption member user acl false 
cases program halts maintaining bisimilarity 
case lab app lab reduce ith subterm ctx establish result induction hypothesis 
fv vi subterm lab typed 
impossible vi labeled type permitted app context 
case hide show induction hypothesis 
case match interesting case matched expression fact value cases conclude ctx induction hypothesis 
premise lab acl type lab implies 
reduce pattern branch conclude induction hypothesis 
case inapplicable assumption app context 
case pol inapplicable assumption free 
case conv induction hypothesis 
dynamic provenance tracking reproduces provenance policy section 
defines logical relation parameterized label order relate terms similar provenance 
lemma substitution type shape relation 
formed proof 
straightforward induction structure substitution free variables change shape lemma substitution logical relation 
formed app free proof 
induction structure 
case int trivial int case var assumption subst premise 
case fix fix handled standard labeled reduction mitchell section 
note expr concerned terminating computations 
case tab induction hypothesis premise show app tab 

suffices establish univ 
case tap app app tap interpretation labels sets def union def prefixing relation types related types parameterized provenance color vi ti ei pol ti ti ei auditors int int int ei ti ei vi vv vi ti lab lab lab lab lab ti conv lab expr abs univ lab lab lab lab vi ti lab dom dom dom dom subst types related shape kind rt id lab ei lab lab ti ei rt lab rt labeled ti vi ti ti rt fun rt univ 
logical relation dynamic provenance tracking 
limited second premise induction hypothesis establish univ 
premise tap lemma 
conclude required 
case abs app abs goal establish abs 
abs show app follows directly substitution lemma lemma 
show expr requires showing app equivalent showing vi 
follows induction hypothesis applied premise 
case app app goal show expr induction hypothesis applied premises value inversion instance expr value previous implication directly 
inverting relation instance abs derive similarly inverting conclude diverge establish result trivially expr guard implication premise false 
diverges instantiating respectively 
case lab hide show induction hypothesis premise concluding lab reusing premise lab conclude lab 
case match applying ih premise get lab lab lab pn dom xi fv pi dom xi lab pi lab xi lab pi ei match pn en match inverting find instance expr lab 
concerned case reduce values respectively match match 
vacuously expr substitution lemma 
case converge consider premise expr instance lab 
lab lab iff 
xi lab corollary xi lab furthermore lab repeatedly necessary 
xi lab xi lab xi lab xi lab induction hypothesis 
case impossible statement applies app case pol impossible statement applies free terms 
case conv induction hypothesis applied app conv second premise definition te reduce iff 
establish conv 
note relation permits terms different types related 
instance suppose lab auditors int int int auditors union red auditors red 
clearly lab auditors lab auditors 
lemma states substitution requires showing int union red int red int union red int union red int red int red result justified easily ways int union red int red int union red int red 

guard impossible satisfy inversion potentially applicable rule disjunction premise satisfied 

assuming guard show result expr app side reduces resp 
resulting implication tautology 
lemma state prove main result section 
theorem dependency correctness 
free expression ta prov app type respecting substitution apply flatten 
app vi prov prov vi app app policy lub lab lab match high high high high med med med med low policy low low policy join lub policy sub lab lub policy def lab sub low policy app lub policy app typename bool client bool high low med sub med tmp app app tmp 
enforcing static information flow policy 
proof 
suffices show apply apply ta flatten flatten establish ta prov lemma 
case apply interesting case apply apply ta amounts showing apply apply ta prov prov 
write convenient notation dependent tuples 
auditors auditors lab auditors lab auditors auditors auditors prov prov premise instance followed labeling auditors 
proceed cases structure second premise 
inverting find instance 
case case premise 
apply apply values type prov establish relation abs 
inspection apply find apply terminates value form li prov li 
established hat establish prov prov form 
case app app inverting third premise find instance abs premise 
establish gv apply apply notice expressions diverge left side reduces union right side union gv 
establish goal reuse second premise 
case flatten argument similar apply concluding auditor labeled terms considered equivalent relation 
correctness static information flow policy reproduces policy expanding point lattice showing example program client 
assist proof annotated relabeling operator unique index corresponding location source program 
annotations similar allocation site indices commonly pointer analyses 
gives semantics extension spirit core ml pottier simonet technique representing multiple program execution syntax single program 
lemma progress necessary establish augmented operational semantics sufficiently expressive capture evaluation pair programs 
relies indices relabeling operation 
lemma progress 
formed tapp types policy free program value additional syntactic forms 
bracketed expressions represent multiple executions vc 
vc vc vc vc extensions values ec 
evaluation contexts additional type rules el lub el high ei bracket additional reduction rules vi proj vi proj app vx vx vx bapp vx vx 
semantics 
bapp proof 
induction structure relying theorem cases 
limited functional core case unit var subr trivial theorem appealing evaluation context 
proj case follow theorem appealing evaluation context necessary 
definition value 
case app bracketed values follow theorem 
bracketed bracket premise app unlabeled type unlabeled type 
proceed cases possible indices 
case evaluation context vx reduction rule applicable context structure app expand context similarly vx vx vx cases bapp applicable reduction possible 
observe impossible 
source program note term introduced 
reduction case handled bapp bapp app specifically rules case 
inspection bapp vx step reduction definition vx term immediately 
similarly bapp 
impossible appear left side application 
argument straightforward establish app rules case step possible bapp 
case match tap fix cases consider possibility expression redex position form 
note bracketed term prefixed operator bracket labeled type premises rules require unlabeled types operators program labeled examination app shown unlabeled bracketed terms immediately 
case ruled rely theorem 
lemma subject reduction 
formed lemma free program proof 
induction structure consider additional rules relying theorem cases 
case app remains lambda abstraction case change analysis required 
contains bracketed sub term extend substitution lemma handle bracket case 
straightforward substitution lemma lemma fourth fifth premises relying premise establish ei nested bracketed values 
ix expressions unit types ml ml ix ml ml case bapp left side reduction typed subtyping guards unit ml unit ml unit ml ml var ml abs ml sub sub id ml ml ml 
core ml syntax typing functional fragment 
bracket vx sub fn ml app straightforward show type third fourth premises bracket 
similarly vx vx type 
critical point show typed protected level high 
type 
bracket case high 
ei type just established guarded high sufficient evidence show typed bracket satisfy premises 
case bapp similar previous case show ei typed 
provide evidence bracket order type 
inspection policy function app appears conclude tx label 
previously lub tx type vx 
bracket conclude tx guarded level high guarded high type 
sufficient bracket 
theorem noninterference 
high low free vi high 
type respecting substitutions vi policy proof 
straightforward substitution lemma lemma lemma construction guarded high implies 
completeness static information flow policy section show information flow policy appendix complete respect purely functional fragment pottier simonet core ml 
reproduces syntax static semantics minimal functional fragment core ml 
definition non degeneracy core ml typing 
core ml type non degenerate non degenerate unit non degenerate 
typing derivation ml non degenerate sub derivation non degenerate 
non degeneracy condition assures function typed expressions types permit application note third premise ml app requires type function non degenerate 
programs may degenerate type applied 
straightforward transform typing derivation programs non degenerate derivation 
shows translation core ml typing derivations programs theorem completeness static information flow 
ml non degenerate policy 
proof 
induction structure translation 
case trivial 
case trivial 
case abs induction hypothesis establish fix followed abs induction hypothesis applicable third fourth premises abs 
case app app induction hypothesis ii type app type app tl 
case app specifically lab acceptable translation core ml type unit 
case app type specifically lab lab acceptable translation 
apply join type lub obtain lub lab lab 
conclude final premise ml app asserts requires lub lab lab 
translation core ml types environment lab unit unit el low med high unit unit el env env env lab low lab med lab high lab translation core ml labels terms translation derivations expressions 
ml unit ml ml ml ml ml ml ix fix abs tl join app app unit app app ml sub translation subtyping judgment translation typed expression sub id def sub fn el el el join app 
translation core ml derivation 
case case sub proceed induction structure subtyping derivation induction hypothesis establish 
wish establish sub id case trivial 
examine type sub fn 
assumption type el 
ascription lambda binding 
inductive hypothesis 
type app case app conclude app type el 
application join conclude type lub el el 
non degeneracy assumption type el 
type induction hypothesis establish type arrive type abs 
type def lab sufficient establish type el translation goal 
secure policy composition theorem 
app te free te en pol ei ti composes ti fm gm pol fi si pol gi si composes si en fm en gm vg vg proof 
encoding application static information flow policy degenerate lattice incomparable 
result follows theorem 
composes policy term wraps types namespace composable composes unit composes composes composes 
type composability criterion 
composes composes composes 
