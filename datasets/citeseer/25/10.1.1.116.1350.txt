automatic recognition gestures dean harris rubine december cmu cs submitted partial fulfillment requirements degree philosophy computer science carnegie mellon university 
thesis committee roger dannenberg brad buxton university toronto copyright cfl dean harris rubine gesture interfaces user specifies commands simple freehand drawings offer alternative traditional keyboard menu direct manipulation interfaces 
ability specify objects operation additional parameters single intuitive gesture systems appealing novice experienced users 
unfortunately difficulty building gesture systems prevented systems adequately explored 
dissertation presents attempts alleviate major difficulties construction gesture classifiers integration gestures direct manipulation interfaces 
example gesture applications built demonstrate gesture systems require classifiers distinguish possible gestures user may enter 
past classifiers hand coded new application difficult build change maintain 
dissertation applies elementary statistical pattern recognition techniques produce gesture classifiers trained example greatly creation maintenance 
single path gestures drawn mouse stylus multiple path gestures consisting simultaneous paths multiple fingers may classified mips workstation class single path recognizer takes milliseconds train examples entered classification takes milliseconds typically achieving accuracy 
method classifying gesture soon unambiguous 
dissertation describes grandma toolkit building gesture smalltalk model view controller paradigm 
grandma associates sets gesture classes individual views entire view classes 
gesture class specified entering examples class typically 
semantics gesture class specified runtime simple programming interface 
allowing easy gesture interfaces grandma sports novel input architecture capable supporting multiple input devices multi threaded dialogues 
notion virtual tools shown arise naturally grandma approach 
ii acknowledgments foremost wish express enormous gratitude advisor roger dannenberg roger needed failing come fresh idea 
retrospect 
roger problems solutions simple elegant 
try follow roger example usually falling far short 
roger insight 
sorry long 
incredibly lucky brad myers showed cmu working research seminar user interface software gave knowledge breadth needed approach problem software architectures gesture systems 
furthermore extensive drafts document improved immensely 
merit due 
brad 
am grateful bill buxton dario criticism excellent suggestions course 
paul influence led thesis topic met dissertation compiler technology 
paul source ideas thesis really second idea paul spent multiple years pursuing 
ideas easily life hundreds researchers 
paul 
wife ruth sample deserves credit existence dissertation 
fed laugh motivated finish tolerated time 
honey love 

done love support parents shirley stanley uncle donald grandma 
years encouraged doctor bit kind doctor wanted 
just year turned 
folks re best 
love 
friends dale amon josh bloch burks paul ken goldberg klaus gross gary keim charlie krueger kenny nail eric nyberg barak pearlmutter todd tom marie serra ellen kathy paul peter brad white helped innumerable ways technical assistance making life worth living 
peter klaus deserve special time aid 
mark john howard provided valuable criticism helped prepare oral examination 
am grateful 
iii iv wish dog feet design implementation writing efforts opinions 
strongly objects dissertation focus human gesture wish acknowledge excellent environment cmu computer science provides possible support 
particular habermann faculty supporting long dear friends sharon burks sylvia berry cathy 
contents example gesture application gdp user perspective grandma design gdp gestures glossary summary contributions motivation gestures primitive interactions anatomy gesture gestural motion gestural meaning gesture systems states interaction comparison handwriting systems motivation research criteria gesture systems meaningful gestures specifiable accurate recognition evaluation accuracy efficient recognition line real time recognition general quantitative application interface immediate feedback context restrictions efficient training handling misclassifications device independence device utilization outline covered vi contents related input devices example gesture systems approaches gesture classification alternatives alternatives direct manipulation architectures object oriented toolkits statistical single path gesture recognition overview single path gestures features gesture classification classifier training deriving linear classifier estimating parameters rejection discussion features training considerations covariance matrix eager recognition overview algorithm incomplete subgestures attempt constructing recognizer discussion multi path gesture recognition path tracking path sorting multi path recognition training multi path classifier creating statistical classifiers creating decision tree path features global features improvement alternate approach path clustering contents vii global features path sorting multi path recognition single path classifier clustering creating decision tree discussion architecture direct manipulation motivation architectural overview example pressing switch tools objective notation hierarchies models views event handlers events raising event active event handlers view database passive event handler search continues passive event handlers semantic feedback generic event handlers drag handler summary grandma gesture recognizers grandma note terms gestures mvc systems gestures view class hierarchy gestures view tree grandma gesture subsystem gesture event handlers gesture classification training class gesture class gestureclass class class classifier manipulating gesture event handlers runtime gesture semantics gesture semantics code viii contents user interface interpreter implementation applications gdp gdp gestural interface gdp implementation models views event handlers gestures gdp gscore brief description interface design implementation mdp internals mdp gestures semantics discussion evaluation basic single path recognition recognition rate rejection parameters coverage varying orientation size variability recognition speed training time eager recognition multi finger recognition grandma author experience grandma user uses gscore grandma directions contributions new interactions techniques recognition technology integrating gestures interfaces input object oriented user interface toolkits directions contents ix final remarks code single stroke gesture recognition training feature calculation deriving linear classifier undefined functions contents list figures gesture buxton gdp gesture drawing program gdp view class hierarchy associated gestures manipulating gesture handlers runtime adding examples delete gesture macintosh finder apple sensor frame dataglove dexterous hand master proofreading symbols coleman note gestures buxton button box gesture spreadsheet wolf recognizing flowchart symbols sign language recognition tamura copying group objects kurtenbach buxton fels hinton basic gestures carr shaw picture description language example gestures feature calculation feature vector computation different gestures identical feature vectors potentially troublesome gesture set eager recognition overview incomplete complete subgestures attempt determining ambiguity subgestures step computing complete incomplete sets step moving accidentally complete subgestures accidentally complete subgestures moved step building auc xi xii list figures step tweaking classifier classification subgestures multi path gestures inconsistencies path sorting classifying multi path gestures path clusters grandma architecture event hierarchy grandma gesture subsystem passive event handler lists gesture event handler window examples gesture class interpreter window editing gesture semantics empty message selector browser attributes gesture semantics gdp gestures gdp class hierarchy gscore cursor menu gscore palette menu gscore gestures gscore session gscore class hierarchy example mdp session mdp internal structure mdp gestures gscore gesture classes evaluation recognition rate vs number classes recognition rate vs training set size misclassified gscore gestures looped corner rejection parameters counting correct incorrect rejections correctly classified gestures correctly classified gestures recognition rates various gesture sets classes study variable size orientation recognition rate set containing classes vary mistakes variable class test testing program user gesture shown list figures xiii pv misclassified gestures author set pv gesture set performance eager recognizer easily understood data performance eager recognizer gdp gestures pv task pv result xiv list figures list tables speed various computers testing speed feature calculation speed classification speed classifier training xv xvi list tables grandma xvii xviii list tables chapter people naturally hand motions communicate people 
dissertation explores human gestures communicate computers 
random house defines gesture movement body head arms hands expressive idea opinion emotion general definition characterizes generally thought gesture 
eventually possible vision machines interpret gestures defined real time 
currently approach state art computer science term gesture usually restricted connotation context human computer interaction 
gesture refers hand markings entered stylus function indicate scope commands 
buxton gives fine example reproduced 
dissertation gestures referred single 
input devices able track paths multiple fingers come 
frame dataglove examples 
human computer interaction community naturally extended term gesture refer hand motions commands scope entered multiple finger input devices 
referred multi path gestures defining gesture precisely point section describes gesture buxton chapter 
gdp gesture drawing program example application gestural interface 
technical definition gesture section 
example gesture application grandma toolkit create gesture systems 
built author detail pages follow 
grandma create gdp gesture drawing editor loosely dp 
gdp provides creation manipulation lines rectangles ellipses text 
section gdp example gesture system 
gdp operation followed description grandma gestural interface 
gdp user perspective gdp operation user point view described 
gdp design implemen tation detail section intent give reader concrete example gesture system embarking general discussion systems 
furthermore description gdp serves illustrates grandma capabilities 
new interaction technique combines gesture direct manipulation single interaction description 

example gesture application shows snapshots gdp action 
started gdp presents blank window 
panel shows rectangle gesture entered 
gesture drawn user begins gesture positioning mouse cursor pressing 
user draws gesture moving mouse 
gesture shown screen entered 
technique called provides valuable feedback user 
shown dotted lines gesture may distinguished objects drawing 
gdp done lines disappears soon gesture recognized 
rectangle gesture indicated ways 
user simply mouse button immediately drawing rectangle created corner start gesture button pressed opposite corner ofthe gesture button released 
way gesture moving mouse amount time seconds works pressing mouse button case rectangle created corner start gesture opposite corner current mouse location 
long button held corner dragged mouse enabling size shape rectangle determined interactively 
panel shows rectangle created ellipse gesture 
creates ellipse center start gesture 
point ellipse tracks mouse gesture recognized gives user interactive control size ellipse 
panel shows created ellipse line gesture 
similar rectangle ellipse gesture determines endpoint newly created line mouse position gesture recognized determines endpoint allowing line panel shows shapes encircled pack gesture 
gesture packs groups objects encloses single composite object manipulated asa unit 
panel shows copy gesture composite object copied copy dragged mouse panel shows rotate scale gesture 
object rotate starting point gesture point object dragged mouse allowing user size orientation object 
panel shows delete gesture essentially drawn single stroke 
object atthe gesture start deleted shown panel 
brief description gdp illustrates number features gesture systems 
striking feature gesture corresponds high level operation 
class gesture determines operation attributes gesture determine scope operands additional parameters 
example delete gesture specifies object deleted pack gesture specifies objects combined line gesture specifies endpoints ofthe line 
convenient describe single path gestures handwritten letters 
meant imply gesture systems recognize alphabetic symbols usually recognize alphabetic symbols ways gesture systems distinct handwriting recognition systems enumerated section 
chapter 
view text pack dot ellipse rect line edit delete 
gdp view class hierarchy associated period indicates point gesture 
possible control positional parameters gestural attributes 
example version gdp uses length pixels line gesture control thickness new line note gesturing direct manipulation combined new phase interaction technique 
phase collection gesture ends user stops moving holding button 
time gesture recognized number parameters application command determined 
recognition manipulation phase entered user control additional parameters interactively 
addition gestural interface gdp provides traditional click drag interface mainly compare styles interface discussed section 
gestural interface grafted top click drag interface explained 
grandma design gdp gestures current gesture designer creates gestural interface application click drag interface application 
click drag interface application built object oriented toolkit grandma 
gesture designer way input handled leaving output mechanisms untouched 
system built grandma utilizes object oriented programming paradigm rep resent windows graphics objects displayed windows 
example shows gdp view class hierarchy hierarchy shows relationship classes concerned 
task gesture designer determine classes associated gestures view class design set gestures intuitively expresses operations view 
shows sets gestures associated gdp classes 
collectively purposes hierarchy shown simplified version actual hierarchy 
details follow simplified 
section tells truth gory detail 

example gesture application handle nil mouse mode dock trash gc gc new class gc gc manipulating gesture han runtime normal delete dump semantics delete adding examples gesture refers line rectangle ellipse shapes represents window inwhich gdp runs 
grandma model view controller system 
grandma input controller mvc terms may associated view class shared instances class including instances subclasses 
adds flexibility major overhead smalltalk mvc controller objects associated view object expects input gesture designer adds gestures gdp initial click drag interface runtime 
step create new gesture handler associate class easily done grandma 
shows gesture handler window number gestures created new class button shows window delete gesture entered 
fifteen examples gesture class typically suffice 
gesture vary size orientation examples reflect clicking semantics button brings window designer uses specify semantics gesture handler set 
window structured editing simple objective interpreter designer enters expressions recog evaluated gesture recognized manip evaluated subsequent mouse points evaluated mouse button released 
case delete semantics simply change mouse cursor delete cursor providing feedback user delete gesture aimed 
expressions entered objective syntax 
view delete sends delete message object referred variable view 
handler mousetool sends mousetool message variable handler passing value variable argument 
see section information objective notation 
chapter 
recog seq handler mousetool view delete manip nil done nil designer may immediately try delete gesture 
designer repeats process create gesture handler set gestures class view refers window gdp runs 
gestures create graphic objects pack gesture creates set enclosed graphic objects dot gesture repeats command handled gesture handler cursor operating directly graphic object 
attributes gesture directly available gesture semantics 
example semantics line gesture recog seq handler mousetool view manip recog done nil semantic expressions execute rich environment example view view gesture directed case handler bound current gesture handler 
note seq executes arguments sequentially returning thevalue case newly created line 
bound recog manip expression example shows gesture attributes shown angle brackets useful semantic expressions 
attributes coordinates point determine endpoint line mouse coordinates determine endpoint 
gesture attributes useful semantics 
line semantics control thickness line maximum speed total path length gesture 
rectangle semantics initial angle rectangle gesture determine rectangle 
attribute enclosed especially noteworthy contains alist views enclosed gesture example pack gesture 
convenient semantics simulate input click drag interface directly application objects views shown 
point gesture gesture handling view unionof set gestures recognized handler priority foremost views 
example gesture gdp necessarily 
delete gesture graphic object handled bythe line gesture place handled 
set union occurs gestures conceptually inherited hierarchy 
example gesture designer create new gesture handler class containing unpack gesture 
set gestures recognized 
glossary consist unpack gesture gestures handled 
glossary section defines clarifies terms dissertation 
skipped referred back needed 
terms click drag common usage human computer interaction community pick move drop definitions solely 
class dissertation class ways 
gesture class refers set gestures intended treated example class delete gestures 
dissertation names gesture classes shown sans serif typeface 
job ofa gesture recognizer example gesture determine class see gesture 
class object oriented sense referring type loosely speaking object 
clear context meanings intended 
click click consists positioning mouse cursor pressing releasing intervening mouse motion 
macintosh click generally select object screen 
click drag click drag interface direct manipulation interface objects onthe screen operated mouse clicks drags double clicks 
direct manipulation direct manipulation interface user manipulates underlying data pointing moving appropriate device mouse buttons 
double click double click clicks rapid succession 
drag drag consists locating mouse cursor pressing mouse button moving cursor holding mouse button releasing mouse button 
drag interactions click drag interfaces example move objects 
drop final part drag click interaction mouse button released 
eager recognition kind gesture recognition gestures recognized gesture having explicitly signaled 
ideally eager recognizer recognize gesture soon seen determine class unambiguously 
gesture essentially freehand drawing indicate command parameters 
de pending context term refer example gesture class gestures delete gesture means example gesture belonging class delete gestures usually gesture refers part interaction input recognized chapter 
number possible gesture classes entire interaction manipulation phase recognition referred gesture 
move component drag interaction mouse moved mouse held 
presence move distinguishes click drag 
multi path multi path gesture input device allows indicated simultaneously multiple pointers 
may multi path gestures sensor frame multiple finger touch pad dataglove name devices 
line considering algorithm sequence operations line algorithm subsequent operations producing output current operation 
line line algorithm output operation produced operations read 
pick initial part drag click interaction consisting positioning mouse cursor atthe desired location pressing mouse button 
press refers pressing mouse button 
real time real time algorithm line algorithm operation processed intime bounded constant 
release refers releasing mouse button 
segment segment approximately linear portion stroke 
example letter segments vertical horizontal 
single path single path gesture drawn input device mouse stylus capable specifying single point time 
single path gesture may consist multiple strokes character 
single stroke single stroke gesture single path gesture stroke 
drawing single stroke gesture 
dissertation single path gestures considered single stroke gestures 
stroke stroke unbroken curve single movement pen stylus mouse 
generally strokes explicit user actions pen pen mouse button mouse button 
summary contributions dissertation contributions areas new interaction techniques new algorithms recognition new way integrating gestures user interfaces new architecture input object oriented toolkits 

motivation gestures new interaction technique phase combination single stroke gesture collec tion followed direct manipulation mentioned previously 
gdp example discussed boundary phases interval 
eager recognition sec ond new interaction technique eliminates interval recognizing single stroke gesture entering manipulation phase soon gesture seen ously making entire interaction smooth 
third new interaction technique phase interaction applied multi path gestures multi path gesture recognized individ ual paths fingers possibly including additional fingers involved making recognized gesture may assigned manipulate independent application parameters simultaneously second contribution new trainable single stroke recognition algorithm tailored recognizing gestures 
classification meaningful features addition useful recognition suitable passing application routines 
particular set features shown suitable different gesture sets 
restricted features updated incrementally constant time input point arbitrarily large gestures may handled 
single stroke recognition algorithm extended eager recognition eager recognizers automatically generated example gestures multi path gesture recognition third new paradigm creating gestural interfaces 
seen example starting click drag implementation interface gestures classes views display objects set gestures recognized particular screen location dynamically determined set overlapping views location class hierarchy view 
classification attributes gestures map directly application operations parameters 
creation deletion manipulation gesture handlers gesture classes gesture examples gesture semantics occur runtime enabling quick easy experimentation gestural interfaces fourth grandma object oriented user interface toolkit contributions area input handling 
event handler objects associated particular views entire 
single event handler may shared different objects eliminating major overhead mvc systems 
multiple event handlers may associated single object object support multiple interaction techniques simultaneously including multiple input devices 
furthermore single mechanism handles mouse tools delete cursor clicked objects virtual tools delete icon dragged dropped objects delete 
additionally grandma provides support semantic feedback enables runtime creation manipulation event handlers 
motivation gestures point reader idea scope 
stepping back section begins general discussion gestures examining motivation studying gesture interfaces 
discussion buxton 
computers get faster bitmapped displays produce increasing information rates speech chapter 
macintosh finder apple music generated real time input just little improvement paul words useful information world resides humans computers 
people interact computers spend time entering information 
due input bottleneck total time tasks hardly improve computers infinitely fast 
improvements major factor improving productivity computer users general 
course progress 
input progressed batch data entry editors dimensional screen editors mouse systems bitmapped displays 
pointing mouse proved useful interaction technique applications 
drag interfaces user directly manipulates graphic objects screen mouse intuitive 
direct manipulation interfaces despite difficult build 
consider macintosh generally regarded having direct manipulation interface shown screen number graphic objects including file icons folder icons sliders buttons pull menu names 
generally rectangular region may clicked double clicked dragged 
macintosh finder may access macintosh applications documents entirely interaction techniques click double click interactions single object location parameter 
drag obviously discussion ignores keyboard entry text commands 

motivation gestures interaction parameters object location mouse button pressed object location release point 
having interaction techniques reason macintosh simple operate 
cost application express operations terms interaction techniques 
application provides operations object design alternatives 
exemplified finder relies heavily selection 
finder click interaction selects object double click opens object meaning depends object type drag moves object meaning object type specific 
opening object double click means invoking object opening document starts application document 
dragging adjusting sliders scroll windows size position moving files folders selecting menu items 
operations done steps object operated selected desired operation chosen menu 
example print object selects click chooses print appropriate menu drag move text selects drag chooses cut drag selects insertion point click chooses paste drag 
cost having interaction techniques operations necessarily performed interactions 
user adjust mental model thinks terms component operations 
alternative selection click drag approach modes 
drawing program 
user palette offering choices line text rectangles circles 
clicking line icon puts program line 
drag operation drawing window cause lines drawn 
drag operation program reverts back selection mode 
dp program similar remains current mode explicitly changed 
mistakes occur user believes mode 
claim interfaces derive power modeless really true 
direct manipulation interfaces simply modes visible helps alleviate modal interfaces 
sole click double click drag interactions macintosh necessarily causes conceptually primitive tasks divided sequence primitive interactions 
intent gestural interfaces avoid division packing basic parameters necessary complete entire transaction 
ideally primitive task user model application executed single gesture 
interfaces current called modeless interfaces 
macintosh previous section somewhat oversimplified 
variations basic interaction techniques example shift click holding shift key clicking mouse adds object current set selected objects 
allow different mouse buttons indicated different operations 
tradeoff having small number large number consistently applied interaction techniques 
results system primitive operations easy learn perform recall single natural chunk may divided sequence operations 
case primitive chapter 
operations harder learn entire natural chunk 
motivation gestural interfaces may apply interfaces combine modalities speech pointing 
gestures potential benefit multi modal interfaces different modalities allow parameters specified simultaneously eliminating modes 
put system example 
primitive interactions discussion far vague exactly may considered primitive 
macintosh click double click drag 
interesting ask criteria judging proposed interaction techniques buxton suggests physical tension criterion 
user starting relaxed state begins primitive interaction muscles 
interaction user muscles 
buxton cites evidence periods tension accompanied heightened state improved performance 
macintosh satisfy concept primitive interaction 
presumably user remains tense double click time clicks short buxton primitive interaction musical phrase 
consists period tension followed return state new phrase may introduced 
human phrase accomplish chunk task 
goal chunks primitive task user model application domain 
gesture attempts 
anatomy gesture section technical definition gesture developed syntactic semantic gestures discussed 
dictionary definition gesture expressive motion seen 
notion gesture form suitable sensing processing captured 
gestural motion motion aspect gesture formalized follows gesture consists paths time 
points question conceptually affixed parts body perform gesture 
hand gestures points tracked include fingertips palm wrist hand 
course gesture point traces path space 
assuming points attached body appropriate places paths contain gestural motion 
computer appropriate hardware rapidly sample positions paths conveniently capturing gesture idea gesture motion multiple points time generalization pointing 
pointing may considered simplest gesture specifies single position instance 
anatomy gesture time 
generalized allow movement point time path 
admits multiple paths movement multiple points time current gesture sensing hardware limits number points may dimensionality space points travel 
gestures limited motion single point referred single path gestures 
previous focused gestures stylus tablet mouse single finger touch pad 
gestures may devices dimensional single path gestures additional feature existing hardware points tracked times 
example touch pad determine finger position finger touching pad 
path point finger contact finger lifted 
apparent limitation certain gesture sensing hardware may delineate start possibly gesture necessary function gesture systems 
mouse buttons may similar effect reported gesture including manipulation phase recognition primitive interaction 
gesture begins user going relaxed state oneof muscular tension ends user relaxes 
assumed tension relaxation user directly indicated aspect sensing hardware 
user considered state tension mouse button pressed 
current double click considered gesture 
certainly limitation removed example having minimum time button needs released user considered relaxed 
added complication explored space points gesture move typically physical space path represented set points consisting spatial cartesian coordinates 
devices measure non spatial gestural parameters gestures consisting paths space coordinates lengths 
example touch pads sense force hardware gesture path consist set points force measurement time formalization gesture multiple paths just possible representations 
representation coincides nicely existing gesture useful form efficient processing 
multiple snapshot representation snapshot gives position multiple points single instant possibility sense may considered dual multiple paths 
representation suitable gestural data derived hardware video cameras dissertation 
gestural meaning addition physical aspect gesture content meaning consider 
generally speaking gesture contains kinds information categorical configuration multiple points single instance time may termed posture 
posture recognition commonly dataglove buxton presents model discrete signaling capabilities various pointing devices list signaling requirements common interaction techniques 
chapter 
parametric 
consider different motions people meaning come prohibiting gestures keep going encouragement gestures 
different categories classes gestures 
class gesture indicate 
example parameter gesture urgency request hurry take time 
general category gesture determined interpreted 
parametric information comes forms 
kind information canbe culled time gesture classified 
example position size orientation gesture fall category 
second kind parametric gestural information 
gesture recognized user kind parametric information continuously communicate information 
example directional information commu gestures person helping driver back truck 
example gdp see section line created user continuously endpoint 
term gesture exactly correspond normally gesture 
gestures currently processed machine due limitations existing gesture sensing hardware 
consider referred direct 
person turning knob normally considered gesturing 
similar motion manipulate graphic image knob drawn computer display gesture 
difference illusory real person knob turning gesture person effect asking turn knob 
simply point broad class motions considered gesture 
notion gesture developed general multiple paths practice hitherto limited finger hand motions 
furthermore paths largely restricted dimensions 
concentration dimensional result available gesture sensing hardware 
course hardware built believed hand fingers capable accurate diverse gesturing practical detection facial body motions 
appearance new input devices dimensional gesturing parts body possible 
dissertation concentrates largely dimensional hand gestures assuming viewing gesture simply multiple paths described applied non hand gestures generalized apply gestures dimensions 
gesture systems gesture interface term user specifies gesturing 
typically gesturing consists drawing freehand motions 
excluded class gesture interfaces input done solely keyboard menu click drag interactions 
words pointing sense basic gesture interfaces pointing form gesture considered interfaces 
gesture system program set programs user interacts gesture interface 

gesture systems simplest gesture systems user may enter gesture belonging different gesture categories classes different classes refer different commands system 
important component gesture systems gesture recognizer classifier module job classify user gesture step inferring meaning 
dissertation addresses implementation gesture recognizers incorporation systems 
states interaction user interaction gesture systems considered dissertation may state model 
states wait collect manipulate execute sequence interaction 
ffl wait state quiescent state system 
system waiting user gesture 
ffl collect state entered user begins gesture 
state gestural data input hardware anticipation classifying gesture 
gesturing hardware explicit start action pressing mouse button gesture causes system enter state 
ffl manipulate state entered gesture classified 
occurs 
gesture indicated explicitly releasing mouse button 
gesture indicated implicitly timeout indicates moved mouse say milliseconds 
system initiates classification believes seen classify unambiguously eager recognition 
manipulate state entered system provide feedback user tothe classification gesture update screen objects accordingly 
state user manipulate screen objects motions 
ffl execute state entered user completed role interaction releasing mouse button 
point system performs final actions implied user gesture 
ideally state lasts short time display updated reflect current state system system reverts back wait state 
model sufficient describe current systems pointing devices 
keyboard input ignored 
depending system collect may omitted cycle 
handwriting interface usually omit classifying collected characters executing resulting command 
conversely chapter 
direct manipulation system omit collect state attendant classification 
example described collect manipulate phases 
result phase interaction technique mentioned earlier 
comparison handwriting systems section frequently asked question gesture systems differ addressed 
handwriting systems may broadly grouped classes line line 
recognition simply means characters recognized drawn 
usually characters drawn stylus tablet recognition process takes input listof successive points line segments 
problem considerably different line handwriting recognition characters drawn optically represented dimensional rasters 
suen mori review literature line line handwriting systems suen give line handwriting systems 
intention contrast gesture systems line handwriting recognition systems closely related gesture systems common systems employ line handwriting recognition input 
freehand drawing primary means user input recognizers interpret input 
important differences classes systems differences illustrate merits gesture systems ffl gestures may motions dimensions handwriting necessarily dimensional 
similarly single path multiple path gestures possible handwriting single path 
ffl alphabet handwriting system generally known fixed users lifelong experience writing alphabet 
gestures users preconceptions extensive experience 
ffl addition command single gesture specify parameters command gesture discussed excellent example 
example due buxton gscore section musical single stroke indicates location pitch duration note added score 
ffl stated command parameters may specified single gesture 
phys ical relaxation user completes gesture reinforces conceptual completion command 
ffl gestures class may vary size orientation 
typical handwriting recog expect characters particular size oriented usual manner successful systems necessarily able cope small variations size 
gesture commands may size orientation specify 
motivation research parameters gesture recognizers able recognize gestures size occur 
kim discusses augmenting handwriting recognition system allow recognize gestures independently size orientation 
chapter discusses approach taken 
ffl gestures dynamic component 
handwriting systems usually view static picture 
gesture system stroke may different meanings drawn left right right left quickly slowly 
gesture recognizers may directional temporal information recognition process 
summary gestures may potentially deal dimensions commonly drawn unusual alphabets specify entire commands vary size orientation dynamic component 
ideas line handwriting recognition gesture recognition handwriting recognizers generally rely assumptions inadequate gesture recognition 
ideal gesture recognition algorithm new gestures dimensions additional features variations size orientation produce parametric information addition classification 
unfortunately generality gesture recognizer handwriting recognition accurate recognizer built tuned specifically handwriting recognition 
motivation research spite potential advantages gesture systems handful built examples include button box editing symbols char rec tool spreadsheet application built ibm 
gesture discussed section 
gesture recognition existing systems done writing code recognize particular set gestures system 
code making systems set gestures accepted difficult create maintain modify 
difficulties reasons gesture systems built 
goal eliminate hand coding way create gesture recognizers gesture classes specified giving examples gestures class 
examples recognizers automatically constructed 
particular gesture class size orientation examples class reflect 
similarly making examples class size orientation system learns gestures appear size orientation examples 
half dissertation concerned automatic construction gesture recognizers 
gesture recognition difficult build direct manipulation systems gestures 
motivation second half dissertation describes grandma gesture recognizers automated novel direct manipulation architecture 
chapter 
criteria gesture systems goal research produce tools aid construction gesture systems efficacy tools may judged tools resulting gesture systems satisfy criteria 
meaningful gestures specifiable meaningful gesture may complex involving simultaneous motions number 
complex gestures easily specifiable 
methods specification possible specification example specification description 
training session examples different gestures submitted system 
result training representation gestures system recognize drive actual gesture recognizer run part application 
method specification description gesture written gesture formal language syntax gesture specified 
example set gestures may specified context free grammar primitive motions straight line segment gestures non terminals composed terminals non terminals equal author considers specification example superior specification description 
order specify gestures description necessary specifier description language 
conversely order specify example specifier need able gesture 
system gestures specified example possibility users train system directly replace existing gestures ones liking system improve recognition accuracy adapting user gestures 
potential drawback specification example difficulty specifying gestures class 
description language straightforward declare gestures class may size orientation 
conveyed specify example system having multiple examples single class vary size orientation 
system infer size orientation agiven gesture class irrelevant classification gesture 
training classifiers may take longer recognition may accurate examples specifications means necessarily 
similar issues arise demonstrational interfaces 
accurate recognition important characterization gesture recognition system frequency fail recognized recognized incorrectly 
obviously desirable numbers small possible 
questions pertaining amount inaccuracy people difficult answer objectively 
tradeoffs complexity gestures number different gestures disambiguated time needed recognition accuracy recognition 

criteria gesture systems speech recognition problem accuracy recognition decreases population grows 
analogous problem gesture recognition easy gauge 
different people speak words differently due inevitable differences 
way person says word largely determined encounters speech recognition system 
contrast people preconceptions way machine 
people able adapt gesturing ways machine understands 
recognition system may similarly adapt user gestures 
interesting outside scope dissertation study fraction incorrectly recognized gestures function person experience system 
evaluation accuracy possible gesture system monitor performance respect recognition 
necessarily easy general impossible know gesture user intended 
gesture system method user easily inform system gesture classified incorrectly 
ideally method integrated undo abort features systems lerner gives alternative subsequent user actions monitored determine user satisfied results system heuristics 
efficient recognition goal enable construction applications gestures input gesture input enhance human computer interaction 
speed recognition important slow system frustrating hinder enhance important factor success failure user interfaces general 
baecker buxton state chief determinants user satisfaction interactive response time 
poor performance direct manipulation system particularly bad noticeable delay destroys feeling directness 
rapid recognition essential gesture medium human computer interaction achieving means sacrificing certain features limited amount recognition accuracy 
line real time recognition possible recognition system attempt match partial inputs possible gestures may desirable inform user soon possible input match possible gesture 
line real time matching algorithm desirable properties 
recognition algorithms discussed chapters small bounded amount new input point line real time algorithms 
general quantitative application interface application specify happens gesture recognized 
take callback application specific routine 
opportunity relay chapter 
parametric data contained gesture application 
includes parametric data derived gesture recognized manipulation data follows 
immediate feedback certain applications desirable application informed immediately recognized completed 
example turning knob system recognizes user gesturing turn knob monitor exact details gesture relaying quantitative data application 
application respond immediately continuously varying parameter knob controls example volume 
context restrictions gesture sensing system able single application sense different sets different contexts 
example context particular area display screen 
different areas respond different sets gestures 
set gestures variable time application program entering new mode potentially cause different set gestures sensed idea contexts closely related idea gestures manipulate graphic objects 
associated picture object screen area screen refer object 
gesture recognition system allow application program association explicit 
efficient training ideal system allow user experiment different gesture classes adapt tothe user gestures improve recognition accuracy 
desirable system responded immediately changes gesture specifications system took hours platform experimentation 
handling misclassifications misclassifications gestures fact life gesture systems 
typical system recognition rate 
means gestures misunderstood 
gesture system prepared deal possibility typically providing easy access abort undo facilities 
device independence certain assumptions form input data necessary gesture systems built previously stated assumption input device supply position function time input path supply data convenient calculate 
path may thought continuous curve drawn single finger 
form 
outline data supplied sensor frame single finger case mouse supply similar data 
recognition systems recognition position versus time data way input devices may benefit research 
device utilization particular brand input hardware gesture sensing characteristics brands hardware 
unfortunate take advantage special features hardware 
example sensor frame compute finger angle velocity device independence may desirable gesture matching depend value inputs facility passing parameters tothe application specific code application desires 
baecker states case strongly portability facilitated device independence interactivity usability device dependence 
outline chapter describes previous related gesture systems 
divided sections section discusses various hardware devices suitable gestural input 
section discusses existing gesture systems 
section reviews various approaches order determine potential gesture recognition 
section examines existing software systems toolkits build direct manipulation interfaces 
systems generalized order incorporate gesture recognition systems 
chapter focuses various aspects gesture interface built author 
tool easy specify create classifiers associate gestures classes meanings graphic objects 
goal addressed chapters 
discussion implementation gesture recognition begins chapter 
classifying single path dimensional gestures tackled 
chapter assumes start gesture known uses statistical pattern recognition derive classifiers 
training classifiers example gestures covered 
chapter shows classify single path gestures chapter shows 
problem recognizing gestures explicit indication gesture 
approach taken define construct classifier classifier intended solely discriminate ambiguous unambiguous subgestures 
chapter extends statistical approach recognition multiple path gestures 
thisis useful utilizing devices sense positions multiple fingers simultaneously particular sensor frame chapter presents architecture object oriented toolkit construction systems 
systems architecture model view describes sensor frame originally envisioned 
hardware capable producing bits finger velocity angle information date attempted 
chapter 
controller paradigm 
compared previous toolkits input model considerably preparation incorporation gesture recognition direct manipulation system 
notion virtual tools input may generated software objects hardware input devices introduced 
semantic feedback shown arise naturally approach chapter shows gesture recognizers incorporated direct manipulation architecture chapter 
gesture handler may associated particular view anobject screen level view hierarchy 
manner different objects respond different sets gestures 
communication parametric data gesture application examined 
chapter discusses gesture systems built techniques gdp gscore mdp 
gdp gscore mouse gestures 
gdp mentioned drawing editor dp 
gscore musical score editor buxton 
mdp drawing editor operates multi path gestures sensor frame 
design implementation system discussed gestures foreach shown 
chapter evaluates number aspects 
particular recognition algorithms recognition accuracy 
measurements performance gesture classifiers applications 
informal user study assessing utility gesture discussed 
chapter concludes dissertation 
contributions dissertation dis cussed directions 
covered dissertation attempts cover topics relevant gesture systems 
particular issues involved ergonomics suitability systems applied various task domains studied 
opinion issues studied tools available allow easy creation experimentation systems 
intent current tools 
research needed determine tools create usable gesture systems possible course choices implementation tools 
avoiding problem determining kind gesture systems best opens possibly throwing baby bath water 
claim general system produced capable implementing systems comparable existing gesture systems example applications implemented see chapter support claim 
furthermore places restrictive choices dimensional gestures indicated scalable methods linear discrimination possible 
major limitations current 
single path multi handwritten characters handled 
existing gesture systems single path multi stroke gestures 
second limitation start gesture 
covered explicitly indicated 
rules glance devices lack buttons explicit signaling hardware 
result current apparent limitations give rise certain advantages gestural interfaces 
example limitations enforce buxton notion tension release mentioned 
gestural output generating gesture response query covered 
gestural output ask author taken long complete dissertation 
chapter 
chapter related chapter discusses previous relevant gesture recognition 
includes suitable gestural input existing gesture systems pattern recognition techniques software systems building user interfaces delving details worth mentioning general attempts define gesture technique interacting computers 
samuels examines gestural lexical commands discusses problems advantages gestural commands 
wolf integrate gesture general taxonomy interactions 
wolf discuss general terms human factors concerns gestural interfaces hardware software issues gesture interaction technique justified number studies 
wolf performed experiments showed gestural interfaces compare favorably keyboard interfaces wolf showed different people naturally gestures text editing context 
hauptmann demonstrated similar result image manipulation task people prefer combine gesture speech modality 
input devices number input devices suitable providing input gesture recognizer 
devices provide position points time data easily converted representation 
intention list types devices potentially gesturing 
techniques developed dissertation applied directly generalization devices mentioned large variety devices may dimensional single path gesturing devices 
graphical input devices mice tablets light pens joysticks thumb wheels single finger touch screens common years 
common foot controllers knee controllers eye trackers tongue 
may potentially gestural input better suited gesturing 
baecker buxton buxton buxton hill rowley discuss suitability devices various tasks 
buxton points chapter 
related different joysticks example may different properties respect task 
gesturing pointing useful device signaling capability pointer 
example mouse usually buttons pressing indicate start gesture 
similarly tablets usually indicate breaks contact tablet tablet possible carefully position screen cursor contact 
device signaling capacity necessary simulate 
exactly done large impact device suitable gesturing 
space system developed polhemus navigation sciences division mc douglas electronics device measures position orientation stylus inch cube magnetic fields 
polhemus sensor called degree freedom sensor returning rectangular coordinates azimuth altitude roll angles 
potentially useful single path gesturing positional dimen sions 
considering angular dimensions dimensional gestures may entered 
possible angular dimensions signaling purposes 
bell laboratories produced prototypes clear plate capable detecting position fingers 
position information dimensional third dimension finger pressure 
author seen device reliably track 
pressure detection may signaling purposes third dimension gesturing 
inventor multi finger touch plate invented device sense position multiple antennae dimensions 
date antennae embedded tips drum sticks name glove containing antenna device suitable detecting hand gestures 
sensor frame frame mounted workstation screen 
consists ofa light source frames screen optical sensors corner 
sensor frame computes dimensional positions fingertips plane parallel screen 
net result similar multi finger touch screen 
author sensor frame verify multi finger recognition algorithm described chapter 
cube device similar sensor frame capable sensing finger positions dimensions 
currently construction 
sensing technology designed capture parametric gestural data 
dataglove glove worn hand able produce positions points hand dimensions 
output relative positions 
combination polhemus sensor absolute finger positions 
device translate gestures complex american sign language multi path form suitable processing 
dataglove similar dexterous hand master power glove shown 
dataglove comes hardware may trained recognize certain static config glove 
example dataglove hardware trained recognize fist 
input devices offset region image display terminal light source light source light source sensor sensor frame frame mounted computer display consisting rectangular light source sensors corner 
capable detecting fingers field view 
drawing 
dataglove dexterous hand master dataglove dexterous hand master glove input devices capable measuring angles various hand finger joints 
chapter 
related proofreading symbols coleman operations intended follows delete text single line insert text swap text move text join delete space insert space scroll scroll delete multiple lines 
marks convey additional parameters operation text moved deleted 
signaling host computer fist 
static hand positions gestures involve motion 
glove hardware recognizes posture gesture distinction posture static snapshot pose gesture time 
elegant way add signaling capability device buttons switches input device constrained form video input 
consists translucent glass top 
desk light source desk video camera 
user hands placed desk 
diffuses light net effect camera receives image silhouette hands 
detect track user fingertips 
researchers investigated attachment point light sources various points onthe body hand get position information function time 
output camera pair cameras dimensional input input gesture sensor 
example gesture systems section describes number existing gesture systems described 
system classify gestural input information class parametric information included survey 
order roughly chronological 

example gesture systems note gestures buxton single gesture indicates note duration shape stroke shown pitch starting time determined position start gesture 
coleman created text editor hand drawn symbols commands 
example sideways indicated sets characters interchanged characters delimited halves input device touch tablet gesture classification done hand coded discrimination net loop free flowchart buxton built musical score editor small amount gesture input mouse 
system simple gestures indicate note durations scoping operations buxton considered system character recognition system gesture system characters taken alphabet musical symbols 
information derived classification characters positions author considers gesture system true sense 
buxton technique incorporated commercial music scoring program 
lamb buckley describe gesture music editor usable children margaret minsky implemented system called button box uses gestures selection movement path specification provide complete logo programming environment 
input device clear plate mounted front display 
device sensed position shear forces single finger touching plate 
proposed gesture input experimented actual multiple finger input device 
minsky system buttons logo operation displayed screen 
button caused execute touching button dragging caused moved 
classification needed distinguish touch tap programmed hand 
buttons copying buttons grouping sets buttons 
path drawn series buttons touching path caused constituent buttons sequentially 
system 
stated silhouette hands monitored 
hand placed pointing posture tip index finger curiously research done coleman graduate student carnegie mellon 
coleman apparently received ph cmu years cmu graduate student topic gesture recognition 
chapter 
related button box tapping displayed button causes execute assigned function touching button dragging causes moved 
gesture spreadsheet wolf interface project produces systems combine gesture handwriting 
input shown selects group cells requests moved cell location 

example gesture systems recognizing flowchart flowchart symbols murase 
system takes entire freehand drawing flowchart left recognizes individual flowchart symbols right producing flowchart nodes edges flowchart picture freehand symbols replaced machine generated line drawings drawn alphabet symbols 
system shows interface pattern recognition detection gestures characters 
may menu selection 
selection fingertips may manipulated controlling points spline curve 
group ibm doing research gestural human computer systems produced gesture spreadsheet application 
somewhat similar coleman editor user manipulates spreadsheet gesturing stylus tablet 
example deletion done cell selection moving selected cells arrow tip indicates destination move 
application interesting combines isolated letters numbers gesturing 
example handwriting user enter numbers text cell keyboard 
portion classifies letters numbers gestures fixed size orientation presumably trained example standard handwriting recognition techniques 
gestures vary size orientation requires hand coding 
murase describe system freehand drawn flowcharts symbols machine 
tamura kawasaki system recognizes sign language gestures video input 
hits mcc university arizona systems construct gesture interfaces 
author seen system built hits similar chapter 
related sign language recognition tamura system processes image video camera order recognize form japanese sign language 
murase entire control panel drawn freehand freehand symbols classified replaced icons 
similar discussed martin mcc 
common grandma system described dissertation mentioned sections 
systems tend similar created grandma gesture commands executed soon entered 
kurtenbach buxton implemented drawing program single 
program study things issues scope gestural systems 
author interesting attribute shown 
gesture recognizer hand coded 
glove talk system uses dataglove control speech synthesizer 
described chapter glove talk performs eager recognition gesture recognized acted indicated explicitly 
weimer describe system combining dataglove gesture speech recognition 
circling gesture alternative means selection considered jackson 
system start circling gesture detected automatically mouse buttons 
circling selection system 
number computer products offer stylus tablet sole primary input device systems include grid systems active book new portable computer scenario toshiba sony palmtop laptop system system go system 
details interface systems hard systems released author suspects gestures 
reading please see 

example gesture systems copying group objects kurtenbach buxton note compound gesture initial closed curve selection final indicates data copied moved 
fels hinton connects dataglove speech synthesizer neural networks 
gestures indicate root words shown modifiers 
reversing direction hand motion causes word synthesizer indicating start gesture 
chapter 
related basic gestures carr prototypes go system demonstrated 
notebook sized computer flat display 
sole input device stylus gestures handwriting display 
shows basic depending context additional gestures handwriting recognized 
seen gestures may consist multiple strokes 
algorithms internally time user add new gestures existing set 
hardware able sense pen proximity near stylus tablet help detect multi stroke gestures characters 
applications include drawing program word processor form data entry system systems combine gesture direct manipulation interface 
example appears treat mouse input gestural begun background window objects mouse input begins object 
combine gesture direct manipulation interaction 
exception uses dot gesture touching tablet moving recognition indicated drag graphic objects 
button box similar dragging objects 
uses eager recognition idea approaches gesture classification fu states problem pattern recognition usually denotes discrimination classifica tion set processes events 
clearly gesture recognition input considered event classified particular set gestures problem pattern recognition 

approaches gesture classification dissertation known techniques pattern recognition applied problem 
general pattern recognition problem consists subproblems pattern decision making 
implies architecture general pattern recognition consists main parts 
representer takes raw pattern input outputs representation pattern 
decider takes input output representer outputs classification description pattern 
section reviews pattern recognition relevant gesture recognition 
particular line recognition handwritten characters discussed possible closest solved problem gesture recognition 
overview handwriting systems see suen 
review divided parts alternatives alternatives alternative briefly explained usually existing system uses approach 
advantages disadvantages alternative discussed particularly apply single path gesture recognition 
alternatives representer module takes raw data input device transforms form classification decider 
case single path gestures line raw data consists sequence points 
representer outputs features input pattern 
may grouped terms kinds features output 
features templates global transformations zones geometric features 
single representer may combine different kinds features discussed outputs kind feature 
clearer differences kinds features 
practice depend largely single kind feature 
templates 
templates simplest features compute simply input data raw form path template simply consist sequence points path 
recognition systems templates require decider difficult matching template input pattern stored example templates class 
templates obvious advantage features simple compute 
size feature data grows size input making features unsuitable input certain kinds 
template features sensitive changes size location orientation input complicating classifiers attempt allow variations class 
examples template systems mentioned discussion matching 
chapter 
related global transformations 
problems template features addressed global transformations 
transformations mathematically defined invariant rotation translation scaling input data 
example fourier transform result respect rotation input pattern 
global transformations generally output fixed number features smaller input data set fixed features allows greater variety choice obviously invariance properties allow variations class 
unfortunately way turnoff invariances order disallow intra class variation 
global transformations generally take input dimensional raster making technique awkward transformed raster data 
furthermore computation transformation may expensive resulting features usually useful sense section requiring separate pass data gather parametric information 
zones 
zoning simple way deriving features path 
space divided number zones input path transformed sequence zones path traverses 
variation scheme incorporates direction zone entered encoding 
templates number features fixed certain may 
major advantage zoning schemes simplicity efficiency recognition size invariant zoning schemes generally require input normalized ahead time 
making zoning scheme rotationally invariant difficult 
impossible compute zones incrementally input data received 
small changes pattern cause zones missed entirely resulting misclassification features usually hold useful parametric information 
geometric features 
geometric features commonly handwriting recognition 
path total length total angle number times crosses represent global properties path 
local properties sequence basic strokes may 
possible combinations geometric features invariant transforma tions input pattern 
example initial angle path may feature features invariant respect rotation input 
fashion potentially created allow different variations class basis 
geometric features carry useful parametric information total path length feature potentially useful parameter 
geometric features fed expect fixed number features global geometric features expect sequence features local features 

approaches gesture classification geometric features tend complex compute types features listed care computation efficient incremental 
reasons current concentrates global geometric features single path dissertation see chapter 
alternatives vector sequence features output representer job decider class input pattern features 
general methods may enumerated template matching dictionary lookup discrimination net statistical matching linguistic matching connectionism ad hoc 
methods suitable kind representer generally applicable 
template matching 
template matching decider compares input template prototypical expected class 
typically decider function measures similarity dissimilarity pairs templates 
input classified member prototype similar 
usually similarity threshold input rejected belonging possible classes similarity metric may computed correlation function input prototype 
dynamic programming techniques may efficiently warp input better match points input template prototype 
template systems advantage prototypes simply example templates system easy train 
order accommodate large variations example orientation gesture number different prototypes various orientation specified unfortunately large number prototypes template matching prohibitively expensive input pattern compared template presents variation template matching recognizing gestures 
scheme training example considered different resolutions giving rise multiple example 
algorithm similar multiscale algorithms image processing 
applied multiscale technique stroke data angle filter inwhich different resolutions correspond different thresholds applied angles gestures 
represent gesture resolution points discarded remaining angles threshold 
classify input gesture highest resolution representation conceptually compared template resolution 
successively lower resolutions ofthe input tried turn exact match 
multiple matches decided favor template resolution closest current resolution input 
dictionary lookup 
input features sequence tokens taken small alphabet lookup 
zoning features classified 
advantage efficient chapter 
related recognition binary search similar algorithms may lookup patterns 
allowance non exact matches classification sensitive small changes input 
dictionary systems due features employed sequences zones 
course dictionary initially created example training input 
simple matter add new entries dictionary system adapt user 
discrimination nets 
discrimination net called decision tree basically flowchart loops 
node contains boolean condition features connected nodes true branch false branch 
leaf node labeled class name 
featureset classified starting root note evaluating condition encountered appropriate branch stopping outputting classification leaf node reached 
discrimination nets may created hand derived example inputs 
appropriate classifying fixed length feature vectors sequences arbitrary length result accurate efficient classifiers 
discrimination nets trained tend unwieldy number examples grows 
statistical matching 
statistical matching statistics example feature vectors derive classifiers 
typi cally statistical matchers operate feature vectors sequences 
typical statistics average feature vector class class variances individual features features 
method statistical matching compute distance input feature vector average feature vector class choosing class clos est 
method uses statistics derive class discrimination functions features 
discrimination functions evaluation functions discrimination function applied tothe input feature vector class determined largest result 
fisher showed create discrimination functions simply linear combinations input features efficient 
statistical classification fourier features line handwriting recognition chapter uses statistical classification 
statistical classifiers fisher classifier assumptions features class multivariate normality tend perform poorly assumptions violated 
classifiers assumptions attempt form training examples 
classifiers tend require training examples function adequately 
approach adopted feature set carefully chosen violate assumptions underlying distribution drastically 

approaches gesture classification pdl primitives ur dr ur dr pdl descriptions shapes ur dr dr ur ur ur dr dr pdl operations shaw picture description enables line drawings coded string form making possible apply textual parsing algorithms recognition line drawings 
component line segments combining operations shown onthe left right shows letter described primitives 
linguistic matching 
linguistic approach attempts apply automata formal language theory problem recognition 
representer outputs sequence tokens composed set pattern primitives composition operators representing relation primitives 
grammar possible pattern class 
takes input sentence attempts parse respect pattern class grammar 
ideally exactly parses pattern classified 
useful side effect syntax analysis parse tree parse trace reveals internal structure pattern linguistic recognizers may classified form representer output 
output string standard language recognition technology regular expressions free grammars may parse input 
error correcting parser may order robustly deal errors input 
alternatively output representer may atree graph case decider graph matching algorithms parse 
token sequence come zoning representer representer local output lower level classifier 
hybrid approach example statistical recognition classify paths path segments linguistic classify relationships paths 
approach similar taken fu number applications shaw picture description language pdl see successfully describe classify line drawings 
system stallings uses composition chapter 
related operators left surrounds describe relationships strokes 
major problem linguistic recognizers necessity supplying grammar class 
usually represents considerably effort simply supplying examples class 
research done automatically deriving grammars examples research appears sufficiently advanced gesture recognition system 
linguistic systems best patterns substantial internal structure gestures atomic 
connectionism 
pattern recognition neural nets received research attention 
neural net configuration simple processing elements version neuron 
number methods exist training neural network examples 
different kinds features listed serve input neural net best results achieved vectors 
statistical discrimination functions may implemented simple neural networks 
neural nets applied successfully recognition line drawings characters dataglove gestures 
unfortunately tend require large amount processing power especially train 
appears neural networks method gesture recognition 
chief advantage neural nets template approaches able take raw sensor data input 
neural network learn features classification 
disadvantage labeled examples thousands needed training 
statistical classification method discussed dissertation may considered network 
advantage multilayer neural networks may trained quickly relatively examples class typically 
rapid training time important ina system prototyping gesture systems allows system designer easily experiment different sets gestures application 
ad hoc methods 
set patterns recognized simple classifier may programmed hand case gesture systems mentioned section 
having program recognizer hand difficult gesture set difficult 
author believes difficulty creating recognizers major reason gesture systems built dearth experiments effect varying gestures systems built 
major goal dissertation building gesture systems easy making recognizers example incorporating easy direct manipulation framework 

direct manipulation architectures direct manipulation architectures direct manipulation system user manipulates graphical representations task domain directly usually mouse pointing device 
words shneiderman central ideas visibility object interest rapid reversible incremental actions replacement complex command language syntax direct manipulation object interest term direct manipulation 
examples mentions display editors video games computer aided design automobile 
application domains direct manipulation paradigm results programs learn 
course tasks direct manipulation appropriate due fact nature task domain easily mapped concrete 
example direct manipulation systems task programming difficult design progress intended debate merits drawbacks direct manipulation systems 
merely noted direct manipulation increasingly important style user interface 
furthermore existing gesture systems may considered direct manipulation systems 
reason graphical objects screen natural gesture commands updating objects intuitive way feeding back user effect gesturing 
section existing approaches constructing direct reviewed 
chapters shown approaches may extended incorporate gestural input direct manipulation systems easy difficult kinds interface construct 
great interest software tools creating interfaces myers gives excellent overview various tools proposed purpose 
sufficient divide user interface software tools levels lowest software level potentially seen direct manipulation system programmer usually window manager 
example window managers include news display postscript see myers overview 
current purposes sufficient consider window manager providing set routines output textual graphical input keyboard mouse device 
programming direct manipulation interfaces window manager level usually avoided large amount need redone application menus implemented 
building scratch way probably result different interfaces application making total system difficult recall 
software level user interface toolkit 
toolkits come forms non object oriented object oriented 
toolkit provides set procedures objects constructing menus scroll bars standard interaction techniques 
toolkits come programmer decide components 
toolkits notably come partially assembled making easier customize structure fit application 
reason authors chapter 
related referred systems user interface management systems grouped withthe toolkits 
non object oriented toolkit simply set procedures creating manipulating techniques 
saves programmer effort involved programming interaction techniques directly added benefit systems created single look act similarly 
problem non object oriented toolkits usually give support programmer wishes create new interaction techniques 
programmer typically reuse existing code finds bogged low level details input screen management 
procedures object oriented toolkits provide class object type ofthe standard interaction techniques 
interaction techniques interface programmer creates instance appropriate class 
inheritance mechanism ofthe object oriented programming language programmer create new classes behave existing classes modifications specified programmer 
subclassing programmer method customizing interaction technique particular application 
provides assistance programmer wishing create new interaction techniques subclass existing class usually easier programming new technique scratch 
problem object oriented toolkits complexity needs familiar large part class hierarchy understand functionality single class 
user interface management systems uimss form software level toolkits uimss systems provide method specifying aspect user interface higher level simply base programming language 
example rapid uses state transition diagrams specify structure user input system uses context free similarly cousin system uses declarative language systems encourage enforce strict separation user interface specification application code 
having modularity advantages increasingly separation may appropriate direct manipulation interfaces 
uimss employ direct graphical specification interface components popular 
systems uims direct manipulation system 
user interface designer uses direct manipulation specify components direct desires build 
interface builder andrew development environment workbench allow placement properties components specified direct manipulation 
new interface components programmed object oriented toolkit provided 
addition direct existing interface components enable new interface components created direct graphical specification 
uimss generally built top user interface toolkits 
uimss support con struction direct manipulation interfaces ones direct graphical specification tend built object oriented toolkits 
object oriented toolkits currently pre vehicle creation direct manipulation systems dissertation concentrates problem integrating gesture toolkits 
preparation architectures 
direct manipulation architectures existing object oriented toolkits reviewed 
object oriented toolkits object oriented approach construction direct manipulation systems object oriented programming techniques graphical objects screen correspond quite naturally software objects internal system 
ways manipulated correspond messages corresponding software object responds 
assumed reader dissertation familiar concepts object oriented programming 
cox stefik bobrow horn goldberg robson excellent overviews topic smalltalk system object oriented system ran personal computer mouse bitmapped display 
system emerged model view controller mvc paradigm developing direct manipulation interfaces 
mvc literature appear print mvc paradigm directly influenced object oriented user interface architecture creation 
reason review object oriented architectures direct manipulation systems begins discussion smalltalk system 
terms model view controller refer different kinds objects role representation single graphic object direct manipulation interface 
model object containing application specific data 
model objects encapsulate data computation ofthe task domain generally user interface 
view object responsible displaying application data 
usually view associated asingle model communicates model order acquire application data render screen 
single model may multiple views potentially displaying model 
views implement look user interface 
controller object handles user interaction input 
depending input communicate directly model view 
controller object generally paired view object controller handles input model view handles output 
internally controller view objects typically contain pointers associated model may directly send messages model 
controllers implement feel user interface 
application programmer codes model object modularity purposes include particular view 
result separation application models user interface views controllers 
connection model view view notified state model changes 
connection accomplished modular fashion dependencies 
dependencies follows object may register dependent object typically view object created registers dependent model object 
generally list dependents associated object way multiple views may single model 
object potentially dependents changes state sends message self changed 
dependent object get sent message chapter 
related update informing object dependent changed 
model communicate views fact changed referring views explicitly views display rectangular regions screen 
view may subviews typically results object displayed rectangular region parent view 
may subviews recursively giving rise view hierarchy 
typically subview display clipped wholly appear rectangular region 
subview generally occludes part parent view 
common criticism mvc paradigm objects view controller implement user interface model suffice 
argument goes inefficient modular 
implement look feel separately practice go 
reply criticism states useful occasionally control look 
discusses usefulness single view having interchangeable controllers implementing different user abilities intermediate advanced controllers having system adapt user ability runtime example 
examples may persuasive important application controllers ability handle multiple input devices 
chapters explore benefits accrued separation views controllers simplicity combining views controllers single object giving rise object oriented toolkits data view dv paradigm 
terminology varies andrew toolkit news development environment interviews dv paradigm 
paradigm data application specific data identical mvc models view objects combine functionality mvc view controller objects 
dv systems look feel tightly coupled detailed assumptions input hardware button mouse get built view object oriented toolkits vary method determine controller objects get informed particular input event details communication typically input events mouse clicks passed view hierarchy view querying subviews recursively see wishes handle event handle event 
variations scheme possible 
controllers may written methods messages 
convenient programmer effect wiring details input hardware system 
passes input events general form 
generalized chapters 
controllers general mechanism handling input 
garnet modern mvc takes different approach called interactors 
key insight interactors different kinds interactive behavior parameterizable built 
user interface designer needs choose appropriate interactor interaction technique creates gestural input currently handled existing interactors 
interesting see 
direct manipulation architectures interactor concept garnet general handle gesture interactor 
unfortunately author largely unaware garnet project time began research described chapters 
different method incorporating gestures manipulation systems described created 
system considerably general input mechanism mvc far 
grandma system discussed dissertation integrates gesture object oriented toolkit 
developed simultaneously independently grandma similar input architectures 
systems compared detail chapter 
chapter 
related chapter statistical single path overview chapter address problem recognizing single path gestures 
single path gesture input single pointer mouse stylus single finger touch pad 
assumed start input gesture clearly delineated 
mouse start gesture indicated pressing mouse button release button 
similarly contact stylus tablet finger withthe touch screen delineate endpoints gesture 
baecker buxton warn mouse gestural input device 
research described chapter author chosen ignore warning 
mouse pointing device readily available began 
furthermore pointing device widely available important consideration allows utilize 
addition probably case trainable recognizer mouse input better devices suitable gesturing stylus tablet particular mouse labeled dec model vs ea revision 
buttons top metal trackball coming bottom 
moving mouse flat surface trackball roll 
inside mouse trackball motion mechanically divided components mouse sends pulse computer time components certain amount 
windowing software host implements mouse acceleration meaning faster mouse moved distance farther mouse cursor travel 
metal rolled table resulting termed hostile system studying gestural input described chapter developed digital equipment microvax ii software written runs top mach operating system microvax trademark digital equipment 
chapter 
statistical single path gesture recognition 
example period indicates start gesture 
actual mouse points gestures indicated 
unix bsd compatible 
window system layer software designed code easy port window systems 
single path gestures gestures considered chapter consist dimensional path single point overtime 
gesture represented array time stamped sample points gp xp yp tp points time stamped tp typical interface gestural input devices particularly mice deliver input points regular intervals 
dissertation dimensional gestures considered methods described may generalized dimensional case 
input point close previous input point ignored 
input results features reliable especially gesture eliminated 
result large increase recognition accuracy particular mouse majority close meant pixels 
threshold empirically determined produce optimal recognition rate anumber gesture sets 
similar complicated preprocessing done pittman recognition system 
difference preprocessing system current stems largely difference input devices indicating preprocessing done input device basis 
shows example gestures gdp drawing editor 
point gesture indicated period 
subsequent point connected line segment tothe previous point gamma 
time stamps shown gesture recognition problem stated follows set gesture classes numbered gamma 
classes may specified description done unix trademark bell laboratories 

features example gestures class 
input gesture problem determine belongs class members 
classifiers reject option sufficiently different belong gesture classes rejected 
features statistical gesture recognition done steps 
set features extracted 
set represented feature vector 
ff 
prime denotes vector transpose 
feature vector classified possible 
set features chosen criteria number features small 
scheme amount time takes gesture feature vector proportional product size feature vector number features number different gesture classes 
efficiency reasons number features kept small possible able distinctly represent different classes 
feature calculated efficiently 
essential calculation expensive amount time update value feature input point gp received bounded constant 
particular features previous points examined new input point disallowed 
manner large gestures consisting points recognized efficiently 
practice incremental calculation features achieved computing classification 
example feature average value input points auxiliary feature consisting sum values computed require constant time addition input point 
feature vector needed classification average value feature computed constant time sum number input points 
feature meaningful interpretation 
simple handwriting systems systems built features classification parametric information 
example drawing program initial angle orient newly created rectangle 
possible extract gestural attributes independent classification potentially efficient 
meaningful features provide useful information designer set gesture particular application 
understanding set features designer better idea kind gestures system distinguish design gestures classified accurately 
chapter 
statistical single path gesture recognition individual features gaussian distributions 
classifier described chap ter optimal things class feature gaussian distribution 
class essentially represented mean feature vector example takes place approximation determining class mean feature vector closest example 
classification may suffer class example bimodal distribution tends different values 
requirement satisfied feature stable meaning small change results small change value feature 
general rules features small integers presumably small change gesture cause step feature 
possible features depend thresholds avoided similar reasons 
ideally feature real valued continuous function 
note input preprocessing essentially thresholding operation seemingly small change gesture cause big changes feature vector 
eliminating preprocessing allow noise inherent input seriously affect certain features 
thresholding ruled se tradeoffs considered 
alternative multiple thresholds kind multiscale representation input avoiding problems inherent single threshold 
particular set features evolved creation classifiers subset gdp gestures second recognizer upper case letters handwritten author 
current version recognition program thirteen features employed 
depicts graphically values feature calculation 
features cosine sine initial angle respect axis cos ff gamma df sin ff gamma gamma gamma length bounding box diagonal max gamma xmin ymax gamma ymin xmax xmin ymax ymin maximum minimum yp respectively 
angle bounding box 
features ff fi xp gamma yp gamma xp yp yp xp gamma yp gamma xmin ymin xmax ymax feature shown relevant lengths angles labeled intermediate variables compute features features possible 
arctan ymax gamma max gamma xmin distance point gamma gamma yp gamma gamma cosine sine angle point cos fi xp gamma gamma sin fi yp gamma gamma total gesture length delta xp xp gamma xp delta yp yp gamma yp chapter 
statistical single path gesture recognition gamma delta delta total angle traversed derived dot cross product definitions arctan delta xp delta yp gamma gamma delta xp gamma delta yp delta xp delta xp gamma delta yp delta yp gamma gamma gamma pj gamma maximum speed squared delta tp tp gamma tp gamma max delta delta delta path duration tp gamma gamma features allow gesture recognition temporal factors dynamic component simply static pictures 
features sines cosines angles depend angles directly require inverse trigonometric functions compute 
needed compute function take numerator separate parameters returning angle gamma ss ss 
efficient recognition desirable just single feature represent angle sine cosine 
recognition algorithm requires feature approximately poses problem small change gesture causes large change angle measurement due discontinuity near sigma ss 
mattered initial angle start point gesture angles represented sine cosine 
bounding box angle ss discontinuity 

gesture classification features dependent angle successive input points occurs gesture stroke turns back 
practice due gestures changes recognition process significantly hampered bythe potential discontinuity see section 
feature measure total gesture consisting clockwise loops feature value near ss gesture clockwise loop followed counterclockwise loop close zero feature accumulates absolute value instantaneous angle loop gestures near ss 
feature measure sharpness gesture shows value features function input point gestures 
note particular value sharpness increases angles 
feature values rightmost input point ones classify gesture 
intent graph show features change new input point features computed incrementally constant amount done new input point 
utilizing table lookup square root inverse trig functions computation input point quite small 
number features tried features 
example sharpness metric initially count number times exceeded 
idea count sharp angles 
worked fairly continuous measure sharpness give better results 
general features discrete counts continuous features attempt quantify phenomena 
reason probably continuous features closely satisfy criterion 
words error deviation discrete count tends significant error deviation continuous metric appendix shows code incrementally calculating feature vector gesture 
gesture classification feature vector computed input gesture classification algorithm efficient 
associated gesture class linear evaluation function features 
gesture class weights ci number features currently 
class variables written superscripts hats indicate class 
confused exponentiation 
evaluation functions calculated asfollows ci xi value evaluation class classifier simply determines maximum classification gesture possibility rejecting discussed insection 
practitioners pattern recognition recognize classifier classic linear discriminator 
correct choice weights ci linear discriminator known optimal class feature vectors multivariate normal distribution chapter 
statistical single path gesture recognition input point number input point number feature vector graphs show feature vectors change new input point 
left graphs refer features gesture right graphs gesture 
final values features gesture ones classification 
instantaneous angle included part feature vector 

classifier training class feature covariance matrices equal 
exactly means discussed section 
continuous distributions linear discriminant functions optimal investigated cooper 
conditions hold sets gesture classes feature set described weights calculated assuming conditions optimal linear classifiers optimal linear classifier outperformed linear classifiers conditions satisfied 
set features linear discriminators computed conditions valid acceptably practice 
classifier training decision linear discriminators problem remains weights example gestures class 
known training problem methods computing weights tried 
multiclass perceptron training procedure described sklansky 
hope method depend aforementioned conditions choose weights perform better methods 
method initial guess weights classify example 
class evaluation function scored higher correct class weight reduced amount proportional corresponding feature correct class weights increased amount 
similar back propagation learning procedures neural nets 
manner examples tried multiple times desired 
method advantage simple needing example achieve reasonable results 
behavior classifier depends order examples training values initial weights proportionality difficult determine advance large effect success training efficiency method 
number iterations examples optimum value difficult determine 
serious problem single bad example seriously corrupt classifier eventually perceptron training method abandoned favor plug estimation method 
plug estimation method usually performs approximately equally trained classifiers vagueness associated perceptron training 
method means features class estimated example gestures isthe common feature covariance matrix classes assumed 
estimates approximate linear weights optimal assuming true 
deriving linear classifier derivation plug classifier detail james 
james explanation particularly unfortunately derivation typos chapter 
statistical single path gesture recognition errors 
gives similar derivation errors multivariate analysis 
derivation summarized convenience 
consider class gestures drawn starting top left 
example gesture 
easy generate examples class 
gives rise feature vector considered column vector real numbers 
ff gamma 
random vector vector random variables representing feature class gestures say gestures 
assume multivariate normal distribution 
multivariate normal distribution generalization vectors single variable 
single variable univariate normal distribution specified mean value variance 
analogously multivariable normal distribution specified vector covariance matrix sigma multivariate normal distribution vector element feature univariate normal distribution mean vector simply vector consisting means individual features 
variance features form diagonal diagonal elements represent correlations features 
univariate normal distribution density function familiar bell shaped curve analog variable bivariate case dimensional bell shape 
case lines equal probability cross sections bell concentric ellipses 
axes parallel feature axes variables uncorrelated 
analogy higher dimensional cases distribution hyper bell shape hypersurfaces 
depth discussion properties multivariate normal distribution far afield 
reader unfamiliar subject asked rely analogy univariate case refer text multivariate normal probability density function multivariate analog bell shaped curve 
written conditional probability density density probability vector comes multivariate distribution variables mean matrix sigma ss gamma sigma gamma gamma gamma sigma gamma gamma note expression involves determinant inverse covariance matrix interested reader verify reduces standard bell shaped curve univariate case sigma oe univariate case determine probability value random variable lie interval simply integrate probability density function interval analogously multivariate case interval variables perform multiple integral integrating variable interval determine probability vector 
preparation derivation linear classifier 
assume example classified 
denote event random feature vector class event denote event random feature vector value interested probability particular feature vector group reasonable classification rule assign class probability greater classes rule assigns example 
classifier training class highest conditional probability known bayes rule problem determine classes bayes theorem tells substituting assignment rule assign class terms form priori probabilities random example vector class gesture recognition system prior probabilities depend frequency command application 
lacking better information assume gestures equally resulting rule assign class conditional probability form known likelihood respect assuming equal priors essentially replaces bayes rule gives maximumlikelihood 
assume multivariate normal mean vector covariance matrix sigma substituting multivariate normal density functions equation probabilities assignment rule assign class ss gamma sigma gamma gamma gamma sigma gamma gamma 
ss gamma sigma gamma gamma gamma sigma gamma gamma natural log sides canceling multiplying gamma reversing gives rule assign class ln sigma gamma sigma gamma gamma discrimination function class applied quadratic discrimination quadratic elements features 
discriminant computation involves weighted sum pairwise products features terms linear features term 
making assumption class covariances matrices equal sigma sigma sigma assignment rule takes form assign class ln sigma gamma sigma gamma gamma ln sigma gamma sigma gamma gamma distributing subtractions multiplying gamma gives rule assign class forall sigma gamma gamma sigma gamma note discrimination functions linear features elements weights sigma gamma constant term gamma sigma gamma 
chapter 
statistical single path gesture recognition comparing equations seen optimum classifier take cj sigma gamma ij ci gamma ci ci classes possible know sigma estimated described section 
result ci estimates optimal weights 
possibility tie largest discriminant far neglected 
clear classifier may arbitrarily choose class ofx 
prime case rejecting gesture altogether ambiguous 
kind rejection generalized section 
estimating parameters linear classifier just derived optimal assumptions sense probability correct classification 
parameters needed operate classifier class mean vectors common covariance matrix sigma known priori estimated training examples 
simplest approach plug estimates statistics 
equations follow need programmed notation discarded favor writing sums explicitly terms components 
cei ith feature eth example gesture class number training examples class plug estimate mean feature vector class denoted ci simply average features class ci gamma cei cij plug estimate sigma feature covariance matrix class cij gamma cei gamma ci gamma cj convenience step usual gamma factor included cij 
cij averaged give sij estimate common covariance matrix sigma sij pc gamma cij gamma pc gamma 
rejection plug estimate common covariance matrix sij inverted result gamma ij 
estimates optimal evaluation functions 
weights cj computed estimates follows cj gamma ij ci gamma ci ci mentioned assumed gesture classes equally occur 
terms may adjusted priori probabilities gesture class known advance author necessary results 
derivation ofthe classifier carried assuming equal probabilities net result class add ln similar correction may constant terms differing class costs misclassification taken account estimating covariance matrix involves estimating elements 
matrix example approximately examples computation 
feature may zero variance class 
cases classifier underconstrained give inappropriate response underconstrained attempt fix singular covariance matrix 
zero diagonal element replaced number 
matrix singular search eliminate unnecessary features search starts empty set features 
iteration feature added set covariance matrix features set constructed theta covariance matrix rows columns features set 
matrix singular feature removed set kept 
feature tried turn 
result covariance matrix inverse dimensionality smaller theta inverse covariance matrix expanded size theta adding rows columns feature 
resulting matrix compute weights 
appendix shows code training classifiers classifying feature vectors 
rejection input gesture classification algorithm calculates evaluation class class evaluation larger presumed class cases cause doubt correctness classifier 
gesture ambiguous similar gestures class 
may outlier different expected gesture classes desirable get estimate sure classifier input gesture unambiguously class intuitively expect close chapter 
statistical single path gesture recognition classifier unsure classification picked intuition expression probability feature vector class 
features equal covariances equal prior probabilities substitute multivariate normal density function equation bayes theorem equation 
gamma gamma sigma gamma gamma gamma gamma gamma sigma gamma gamma common factor ss gamma sigma gamma canceled numerator denominator 
may factor cancel gamma sigma gamma substitute equation yielding gamma substituting estimates incorporating numerator denominator yields estimate probability correct class gamma gamma value computed recognition compared threshold tp 
threshold accepting class rejected 
effect varying chapter 
tradeoff wanting reject ambiguous gestures possible wanting reject unambiguous gestures 
empirically tp value number gesture sets see section 
expression bears intuition classes evaluate result gesture ambiguous 
cases denominator significantly larger unity 
note denominator unity due term sum 
terms exponents gamma negative classified class virtue fact may computed efficiently table lookup exponentiation 
extensive time gamma sufficiently negative gamma say negligible 
practice case linear classifier give indication outlier 
outliers unambiguous measure test outlier separate metric needed compare typical gesture class approximation mahalanobis distance works purpose 
gesture feature vector mahalanobis distance class ffi gamma sigma gamma gamma 
discussion note ffi exponent multivariate normal probability density function equation 
plays role gamma oe plays univariate normal distribution ffi essentially measures square number standard deviations mean 
sigma gamma happens identity matrix mahalanobis distance equivalent euclidean distance 
general mahalanobis distance normalizes effects different scales features presumably show different magnitudes variances ii elements common covariance matrix 
mahalanobis distance normalizes away effect correlations pairs features diagonal elements 
possible approximate mahalanobis distance feature class substituting plug estimators population statistics writing matrix multiplications explicitly gives gamma jk xj gamma xk gamma order reject outliers compute approximation mahalanobis distance fromthe feature vector computed class distance greater certain threshold gesture rejected 
section evaluates various settings noted compromise accepting obvious outliers rejecting 
underlying mechanism rejection explained question arises desirable rejections 
answer depends application 
applications easy undo abort facilities reject option probably completely 
failure mode rejection misclassification user redo gesture probably amount cases turning merely increases number gestures redone 
applications deemed desirable rejection question arises behave gesture rejected 
system may prompt user error message possibly listing top possibilities class judging discriminant functions asking user pick 
system may choose ignore gesture subsequent input user indicates interaction 
proper response presumably dependson application 
discussion goal research enable implementor gesture system recognizers need resort hand coding 
original plan try number pattern recognition techniques increasing complexity powerful 
author pleasantly surprised technique tried linear discrimination produced accurate efficient classifiers 
chapter 
statistical single path gesture recognition 
different gestures identical feature vectors efficiency linear recognition great asset gestures recognized virtually system scales 
incremental feature calculation new input point resulting bounded small amount computation essential efficiency system handle large gestures efficiently small ones 
features particular feature set reported worked fine discriminating gestures sample applications simple drawing program uppercase letters alphabet simple score editor 
tests gesture set score editor application significant recognizer developed tested 
chapter studies effect training set size number classes performance recognizer 
classifier gestures classes recognition rate trained examples class rate trained examples class 
misclassifications control recognizer problems mouse gesturing device problems user process non real time system unix collect data desirable show feature set adequate representing differences gestures encountered practice 
measurements chapter show results number different gestures sets means proof adequacy features 
mapping gestures sequences points 
fact easily demonstrated apparently different gestures give rise feature vector 
shows pair gestures features feature set depend order angles gesture encountered gestures alike respect identical 
obviously classifier current feature set find impossible distinguish gestures course particular deficiency feature set fixed adding feature depend order angles 
possible generate gestures angles order differ say segment lengths angles give rise feature vector 
new feature added handle way sure exist different gestures giving rise feature vector adding features way deal gesture sets containing ambiguous 
discussion classes 
eventually number features grow point inefficiently happens algorithms chooses subset features applied 
done contribution classifier statistical techniques principle components analysis analysis variance 
coverage features features extremely grossly different gestures similar feature vectors encountered practice 
recognition time proportional thenumber features clear feature recognizer entail significant processing burden modern hardware large class gesture sets 
may employ fewer features possible example reduce number training examples required problem detecting classifier trained ambiguous classes great practical significance determines classifier perform poorly 
method isto run training examples classifier noting classified incorrectly 
unfortunately may fail find ambiguous classes classifier naturally biased training examples correctly 
alternative compute pairwise mahalanobis distance class means potentially ambiguous classes near 
training considerations potential problem training classifiers intended classes 
problem arises class training examples sufficient variability features irrelevant recognition class example consider distinguishing classes rightward horizontal segment upward vertical segment 
suppose training examples rightward short upward segment class long 
resulting classifier asked classify long rightward segment significant probability misclassification surprising 
training examples way classifier know rightward segment important feature class length irrelevant 
training examples just indicate elements class short segments problem varying length training examples trainer give system significant information produce desired classifier 
clear problem impress people doing training need vary irrelevant features class 
covariance matrix important problem linear recognition comes assumption covariance class identical 
consider classifier meant distinguish gestures classes named 
examples class look letter class look letter assume example gestures drawn similarly chapter 
statistical single path gesture recognition 
potentially troublesome gesture contains examples classes varies orientation depend orientation distinguished 
theoretically problem recognizing gestures current algorithm practice shown case 
initial orientation 
examples class strokes may occur orientation 
point set gesture classes initial orientation essential gestures ignored case gestures 
information contained class covariance matrices 
particular consider variance feature class proportional 
initial angle example gesture sc close zero 
similarly su close 
examples class different orientations si zero 
unfortunately information variance lost class estimates cij averaged give estimate common covariance matrix sij equation 
initially suspected cause problem resulting significantly rates practice effect noticeable 
classifier problem distinguishing gestures correctly 
extensive test gestures vary size orientation depend orientation recognized section 
recognition rates achieved show classifier special difficulty handling gesture sets 
plan experiment improving linear classifier say iterations perceptron training method 
worked quadratic discriminator equation possible area exploration 

chapter discussed linear statistical pattern recognition techniques problem classifying single path gestures 
techniques implementors gesture systems longer write application specific gesture recognition code 
itis hoped making gesture recognizers easier create maintain promising field gesture systems widely explored 
chapter 
statistical single path gesture recognition chapter eager recognition chapter algorithm classifying single path gestures 
algorithm entire input gesture known start gesture clearly delineated 
applications restriction problem 
need gesture user interface awkward need 
consider mouse gestures gdp drawing editor section 
create user presses mouse button corner rectangle enters gesture stops holding button waits rectangle appear positions 
natural user system recognized rectangle gesture user making created rectangle allowing drag corner 
began gesture changes interaction explicit signal timeout example mentioned previously manipulation image knob screen 
suppose knob responds gestures may turned may tapped awkward user order turn knob needed turn knob entering turn gesture turning asking system recognize turn gesture continue turning knob getting feedback system image knob rotates 
better system soon user gesture unambiguously indicate intention turning knob begins turn knob 
author coined term eager recognition recognition gestures soon unambiguous 
henry mention system similar grandma build applications perform eager recognition mouse gestures 
information published gesture recognition eager recognition implemented 
similar recognition dataglove gestures 
deceleration hand indicate gesture progress recognized 
utilizes neural networks recognizes deceleration gesture indicated 
eager recognition automatic recognition gesture 
applications chapter 
eager recognition ask auc gesture ambiguous get input gesture classify gesture eager recognition recognition works collecting points gesture unambiguous point gesture classified techniques previous chapter manipulation phase entered 
gesture seen far ambiguous done auc ambiguous unambiguous classifier 
problem indicate start gesture explicitly pressing mouse button example attempt solve problem determining start gesture 
recognizing start gesture automatically especially important gesture input devices explicit signaling capability polhemus sensor dataglove 
device sudden changes speed direction indicate gesture 
complex techniques determining start gesture outside scope dissertation automatic recognition start gestures 
jackson system recognizes start circling gesture 
user gesturing gesture indicates start 
related automatic segmentation characters handwriting systems especially online recognition cursive writing 
overview algorithm order implement eager recognition module needed answer question gesture entered seen may unambiguously classified 

insight view classification problem classify gesture progress called subgesture ambiguous unambiguous gesture prefix 
essentially approach taken independently 
recognition techniques developed chapter build ambiguous unambiguous classifier auc 
main problems need solved approach 
training data needed auc 
second auc powerful accurately discriminate ambiguous unambiguous subgestures 

incomplete subgestures training data problem solved explicitly labeling snapshots progress 
gesture average snapshots samples dataglove polhemus sensors 
gestures snapshot indicating time recognize gesture indicated 
clearly significant amount trainer system order avoid tedious tasks system constructs training examples auc gestures train main gesture recognizer 
system considers subgesture ofeach example gesture labels ambiguous uses labeled subgestures training data 
chicken egg problem order create training data needs perform task trying create classifier 
creation training data system access crucial piece information problem tractable determine subgesture ambiguous system examine entire gesture subgesture came training data created classifier constructed 
particular difficulty reasons 
classifier trained indicated sensor data similar different gesture classes 
neural networks hidden layers better suited recognizing classes non 
system training data auc consists sets ambiguous subgestures 
distribution feature vectors set unambiguous subgestures wildly non gaussian member subgestures different gesture classes 
example gdp unambiguous delete subgestures different unambiguous pack gestures feature vectors unambiguous set 
similarly distribution feature vectors ambiguous set non gaussian 
linear discriminator previous chapter surely adequate discriminate classes ambiguous unambiguous subgestures 
done turn class problem ambiguous unambiguous multi class problem 
done breaking ambiguous subgestures multiple classes approximately normal distribution unambiguous subgestures similarly partitioned 
details creation training data construction classifier 
failed attempt algorithm considered aforementioned problems uncovered 
working version algorithm 
incomplete subgestures chapter set gesture classes number examples ce number examples class algorithm described chapter produces function subgesture returns subgesture unambiguous respect gesture classes 
function indicates subgesture unambiguous recognition algorithm described chapter classify gesture 
chapter 
eager recognition uu uu uu uu uu uu uu 
du dddd dd uu dd dd ddd uu ddd ddd 
dd uuu ddd incomplete complete subgestures character indicates classification full classifier subgesture 
uppercase characters indicate complete subgestures meaning subgesture larger subgestures correctly classified note horizontal segment subgestures ambiguous subgestures complete 
classification algorithm previous chapter showed gesture feature vector linear discriminator classify class chapter classifier considered function 
words computed classifier chapter 
function produced statistics example gestures class ce algorithms described chapter best example gestures fact computed classifier 
chapter assumed ce example gestures ce practice achieved ignoring training examples incorrectly classified denote number input points gesture jgj particular points gp xp yp tp jgj 
ith subgesture denoted defined gesture consisting points gp jg subgesture simply prefix jgj 
term full gesture necessary distinguish gesture proper subgestures jgj 
term full classifier classifier full gestures example gesture class ce subgestures classified correctly full classifier 
subgesture termed complete gesture jgj 
remaining subgestures 
complete subgesture classified correctly full classifier larger subgestures gesture classified correctly shows examples gestures classes start horizontal segment gestures upward segment gestures downward segment 
inthis simple example clear subgestures include horizontal segment ambiguous subgestures include corner unambiguous 
gesture labeled character indicating classification subgesture ends point 
upper case label indicates complete subgesture lower case 
notice incomplete subgestures ambiguous unambiguous subgestures complete complete subgestures ambiguous horizontal segment 
attempt dd dd 
attempt determining ambiguity class classifier built distinguish incomplete complete subgestures hope classified complete unambiguous classified incomplete ambiguous 
resultant classifier differed training examples 
horizontal segment gestures classified incomplete fortuitous error horizontal segment classified complete 
grave mistake gestures ambiguous horizontal segment premature full classifier attempt recognize gesture points 
examples 
attempt eager recognition subgestures unambiguous recognized gesture 
stated approach build auc classifier distinguishes ambiguous unambiguous subgestures 
notice set incomplete approximate set ambiguous unambiguous subgestures respectively 
author naive attempt eager recognition partition subgestures gestures classes incomplete complete 
linear classifier produced method described chapter 
classifier attempts discriminate incomplete subgestures 
function simply returns false reports incomplete true classifier claims complete 
shows output computed classifier examples points corre sponding subgestures labeled classifier error sense classification agree training data shown 
worst possible error classifier indicate complete gesture happens incomplete occurred right stroke gesture approach eager recognition successful 
inadequate indicated strongly numerous errors tried example containing gesture classes contain germ idea statistical classification may determine gesture ambiguous 
detailed examination problems attempt leads working eager recognition algorithm 
chapter 
eager recognition attempt eager recognition number problems ffl distinction incomplete complete subgestures exactly distinction ambiguous unambiguous subgestures 
example subgestures consisting points right stroke complete eventually turn incomplete gestures turn subgestures essentially identical features 
training classifier conflicting bound give poor results 
example long right stroke progress gesture ambiguous 
happens complete gesture artifact classifier happens choose right stroke 
ffl subgestures examples placed categories complete 
case multiple gesture classes categories subgestures form clusters 
example complete subgestures apart complete subgestures 
gesture classes clustering occur 
distribution complete subgestures normal 
furthermore incomplete subgestures similar complete gestures class incomplete subgestures classes 
holds complete subgestures 
linear discriminator give results separating complete incomplete subgestures 
ffl classifier computed may errors 
severe error reporting complete fact ambiguous 
final classifier tuned avoid errors cost making recognition process eager 
constructing recognizer consideration problems step approach adopted classifiers able distinguish unambiguous ambiguous gestures 
compute complete incomplete sets 
partition example subgestures sets 
sets named class complete subgesture placed class incomplete subgesture placed class 
sets termed incomplete sets sets complete sets 
note thatthe class set name refers full classifier classification set elements 
case incomplete subgestures class example gesture subgesture prefix 
shows pseudocode perform step 
seen shows step subgestures class labeled class labeled class labeled class labeled practice labeling incomplete subgestures lowercase 
constructing recognizer gamma initialize sets incomplete set complete set gamma class gamma training example jg ce subgestures largest smallest ce ce ce complete ce fg ce gamma subgesture misrecognized full classifier subgestures incomplete 
ce incomplete ce fg ce gamma step computing complete incomplete sets letters complete subgestures uppercase letters continued 
move accidentally complete elements 
measure distance subgesture complete set mean set 
sufficiently close incomplete sets removed complete set placed close incomplete set 
manner example accidentally considered complete right stroke gesture grouped incomplete right strokes class case 
perform operation 
quantifying exactly meant sufficiently close turned difficult mahalanobis distance metric turns applied naively 
problem depends estimated average covariance matrix covariance matrix individual classes 
classes malformed step moving accidentally complete elements place 
example class accidentally complete subgestures covariance matrix indicate large standard deviations number features total angle case 
effect inverse covariance matrix measure distance chapter 
eager recognition large differences features map small distances 
unfortunately features needed decide subgestures accidentally complete 
alternatives exist 
average covariance matrix full gesture set subgestures 
possible average covariance matrix incomplete classes 
attempt scale effect different sized units features apply euclidean metric 
entire regrouping problem approached different direction applying clustering algorithm training data 
alternative average covariance matrix full gesture set creation classifier chapter chosen matrix easily available 
metric chosen mahalanobis distance covariance matrix gesture set deciding move subgesture complete class incomplete class difficult 
method tried measure distance subgesture current complete class distance mean class 
subgesture moved closest incomplete class distance distance 
resulted moves mean complete class biased computed accidentally complete subgestures 
threshold computed distance complete subgesture complete class threshold subgesture moved 
fixed threshold threshold computed follows distance mean class mean incomplete subgesture class computed minimum 
distances threshold included avoid trouble incomplete subgesture looked full gesture different class 
case addition third gesture simply right stroke 
threshold minimum 
complete subgestures full gesture tested accidental completeness full gesture smallest 
subgesture determined accidentally complete remaining smaller complete subgestures moved classes 
shows classes subgestures example accidentally moved 
note incomplete subgestures lowercase labels ambiguous 
build auc classifier attempts discriminate partition sets 
training data containing complete classes indicating unambiguous sub gestures incomplete classes indicating ambiguous subgestures simple matter run algorithm previous chapter create classifier discriminate classes 
classifier compute function follows subgesture incomplete class false judged 
constructing recognizer gamma complete subgesture fm class incomplete set closest gamma fif distance distance gif distance threshold gamma fgg step moving accidentally complete distance function threshold value described text 
apparent code distance function incomplete set change elements added set 
complete classes case true 
shows pseudocode classifier 
evaluate tweak classifier 
important subgestures judged unambiguous wrongly 
case cost misclassification unequal classes subgesture erroneously classified ambiguous merely cause recognition eager erroneously classified unambiguous result gesture recognizer misclassifying gesture seen classify unambiguously avoid constant terms evaluation function incomplete classes incremented small amount ln relative cost kinds misclassification 
reasonable value misclassifications unambiguous costly misclassifications ambiguous 
effect bias classifier believes ambiguous gestures times unambiguous gestures choose ambiguous class unsure 
incomplete subgesture tested new classifier 
time subgesture belonging complete set serious mistake constant term evaluation function corresponding complete set adjusted automatically just plus keep happening 
shows classification final classifier subgestures example 
example eager recognizers section 
chapter 
eager recognition 
uuu uu uuu uuu uuu uu uuu 
dddd dd dddd ddd ddd accidentally complete subgestures seen subgestures horizontal segment gestures incomplete 
step ambiguous subgestures incomplete 
gamma gamma gamma step building functions called build classifier returns new classifier object adds example class 
called generate functions examples added 
functions described detail appendix notation indicates generation class name concatenating string thevalue discussion algorithm just described determine subgesture ambiguous set full gestures 
presumably soon decided subgesture unambiguous passed full classifier recognize application level ofthe system react accordingly 
eager recognition works depends number things critical gesture set 
easy design gesture set lend eager recognition example benefit trying eager recognition buxton gestures 
note gestures longer notes subgestures note gestures shorter notes considered ambiguous 
designing set gestures application intuitive amenable eager recognition general hard problem 

discussion add small constant constant term evaluation function incomplete class order bias classifier conservatively 
gamma ln sure ambiguous training example classified complete 
gamma gamma gamma gamma ffl step tweaking small constant added constant term incomplete class ambiguous subgestures bias classifier conservative eager 
ambiguous subgestures accidentally classified complete constant term evaluation function complete class adjusted avoid 
uu ddd uu uuu ddd uu dd du du ud ddd ddd uu 
dddd dddd dd ddd dd dd classification subgestures shows results running auc training examples 
seen auc performs conservatively indicating subgesture unambiguous unambiguous subgesture 
training eager recognizer orders magnitude training corresponding classifier full gestures 
largely due number training examples full gesture example typically gives rise subgestures 
processing training example large 
addition computing feature vector training example number passes training data subgestures incomplete complete move accidentally complete subgestures build auc ensure auc eager 
full classifier second train eager recognizer take substantial portion minute making satisfying experiment interactively 
seen chapter full classifier trained time user gestures display object 
possibility full classifier eagerness training auc background activating eager ready 
chapter 
eager recognition running time eager recognizer costly full classifier 
feature vector needs calculated input point eliminates benefit auxiliary features section bought 
course auc run data point takes cf multiply adds auc classes 
input points usually come faster milliseconds cf computational load usually problem today typical workstation class machine 
current system multiply adds done floating point necessary recognition 
slight defect algorithm construct auc relies totally 
particular subgesture considered unambiguous classified correctly full classifier 
see suboptimal consider full classifier classes gdp single segment line gesture segment delete gesture 
full classifier classify subgesture initial segment delete line 
classify segment subgestures delete line gestures presence segments implies gesture unambiguously delete 
resulting eager recognizer eager possible classify input gesture unambiguously delete immediately second segment gesture begun classifiers eager recognition auc decides subgesture unambiguous full classifier classifies unambiguous subgesture 
may classifiers implementation auc subgesture classified unambiguous unambiguously class classified just return classification bothering query full classifier 
main reasons 
full classifier having classes discriminate auc classes 
second final tweaking step auc adjusts constant terms assure ambiguous gestures classified unambiguous assure classified unambiguously correct class 
adjustment constant terms typically degrades auc sense 
decade practical neural networks 
occurs part chapter concerned building class linear classifier obsolete class neural network presumably job part chapter shows construct training examples classifier full gestures useful eliminates hand labeling necessary 
eager recognizer able classify gesture soon gesture conclude gesture unambiguous 
chapter presents algorithm automatic construction eager recognizers single path gestures examples full gestures 
algorithm gesture systems natural 
chapter multi path gesture recognition chapters discussed recognition single path gestures stylus 
chapter addresses problem recognizing multi path gestures input device dataglove capable tracking paths multiple fingertips assumed start multi path gesture known 
eager recognition multi path gestures left particular input device test ideas chapter sensor frame 
sensor frame discussed section frame mounted crt display 
frame mounted display silicon graphics iris personal workstation 
frame detects xy positions fingertips plane approximately half front display 
defining problem multiple path gesture recognition quite natural attempt algorithms single path gesture recognition developed chapter 
recognition algorithm described chapter combines information culled number path classifiers global feature classifier order classify multiple path gesture 
particular algorithm discussed issue mapping raw data returned input sensors form suitable processing recognition algorithm addressed 
sensor frame processing consisted stages path tracking 
path tracking sensor frame currently operates delivers coordinates fingers view time polled maximum rate snapshots second 
information supplied particular correspondence fingers current previous communicated 
example previous snapshot indicated finger current snapshot left host program determine fingers previously seen just entered field view 
similarly previous current snapshots indicate fingers host program determine current snapshot finger previous snapshot 
chapter 
multi path gesture recognition multi path mdp gestures sensor frame 
start path labeled path index indicating path position canonical ordering 
gesture mdp edit gesture single finger 
gesture parallel finger parallelogram gesture mdp finger pinch gesture moving objects mdp finger undo gesture parallel finger motions smooth noise due sensor frame position detection seen examples 
problem known path tracking groups raw input data number paths time path having definite 
path tracking algorithm quite straightforward 
snapshot read distance matrix containing euclidean distance squared finger current snapshot previous computed 
possible mapping previous fingers error metric consisting sum squared distances corresponding fingers calculated 
mapping smallest error metric chosen 
efficiency possible number fingers previous snapshot list possible mappings precomputed 
sensor frame detects zero fingers lists needed 
symmetry previous considered lists needed 
low level tracking software labels finger position path identifier 
fingers sensor frame field view path identifier variable set zero 
finger current snapshot previous snapshot indicated bythe chosen mapping path identifier set value path identifier incremented 
possible single finger generate multiple paths new path identifier time leaves field view sensor frame identifiers increase long finger remains field view frame 
simple tracking algorithm described 
finger paths crossed arrive practice 
partly gestures fingers single hand making awkward paths cross 
enhancements velocity acceleration finger previous snapshot predict expected current snapshot needed examples tracking algorithm operation shown 
start 
path sorting path labeled path index defined section points connected line segments 
shows uncommon case path tracking algorithm failed causing paths switched 
path sorting multi path recognition algorithm described works classifying path inthe gesture second combining results classify entire gesture 
possible single classifier classify paths option discussed insection 
classifiers tend better fewer classes sense create multiple classifiers path gesture second 
raises question path gesture path second path sorting problem result sorting assigns number path path index 
important feature path sorting technique consistency 
similar multi essential corresponding paths index 
note path identifiers discussed previous section adequate purpose assigned paths appear 
consider example gesture thumb right hand held apart horizontally brought right moves left 
sensor frame thumb path assigned path identifier zero gesture entered view plane assigned path identifier gesture case entered view plane fraction second 
order multi path gesture multiple classifiers give results necessary thumb motions sent classifier training recognition path identifiers path indices give results 
multi path input devices attached hand body problem determining path corresponds finger 
possible build classifier thumb paths paths device question path sorting arise 
sensor frame tablets tell fingers 
priori solution path sorting 
solution adopted impose ordering relation paths 
consistency required ordering relation ordering corresponding paths similar gestures primary ordering criterion path starting time 
avoid aforementioned timing problem paths start milliseconds considered simultaneous secondary ordering criteria 
path starts msec path considered path show path sorting secondary ordering criterion initial coordinate 
window sensor frame length units inch paths considered start causing tertiary ordering criterion applied 
outside window path chapter 
multi path gesture recognition inconsistencies path intention path sorting corresponding paths similar gestures path index 
similar gestures hold path changed 
smaller initial coordinate appear path sorting assuming 
tertiary ordering criterion initial coordinate 
window sensor units applied 
outside window path coordinate appear earlier path ordering 
initial coordinate differ units difference largest ordering path coordinate smaller appears earlier path ordering shows sorting multi path gestures labeling start path index 
note consistency criteria maintained panels corresponding paths gestures different indices 
order paths determined secondary ordering criterion paths began simultaneously ordering determined tertiary ordering criterion paths began simultaneously close coordinates 
generally set ordering rules initial point path generate inconsistent 
practice possibility inconsistencies problem 
ordering set stable near vertical near horizontal finger configurations unstable angle initial points fingers causes unit threshold tobe crossed knowing easy design gesture sets consistent path orderings 
robust solution compute path ordering relation actual gestures train system 
stated multiple finger sensing devices dataglove require sorting 
dataglove input multi path gesture recognizer described approach taken compute paths space time fingertip measured angles various hand joints 
result sorted paths finger suitable input multi path recognition algorithm 
course lack explicit signaling dataglove leaves problem determining start retrospect unit windows sorting complicated need 
coordinate difference largest simultaneous paths algorithm predictable inconsistent initial points paths form angle close gamma ffi horizontal 

multi path recognition gesture 
multi path recognition single path recognizers described chapter multi path recognizer trained number examples gesture class 
recognizer consists number single path classifiers global feature classifier 
classifiers algorithm developed chapter 
differences mainly sets features described section 
single path classifier discriminates gestures particular sorting index 
classifier path gesture second path third path 
current implementation ignores paths third takes number paths account 
multi path gesture system classification paths sorted described path classified classifier resulting sequence single path classes 
sequence path classes results submitted decision tree 
root tree slots pointing subnodes possible class returned path classifier 
subnode corresponding class path chosen 
node slots pointing possible class returned second path classifier 
slots may null indicating expected gesture second path classes 
case gesture rejected 
subnode corresponding class second path chosen 
process repeated third path class 
entire sequence path classes considered possibilities 
unexpected multi path gesture rejected node corresponding sequence exists decision tree 
node exist multi path classification may meaning multi class gesture corresponds particular sequence single path classes 
may number multi path gestures correspond path classes 
case global feature vector encompasses information paths computed classified global feature classifier 
class subnode decision tree result multi path gesture classified individually rejected 
intent needed global feature class sequence path classes care necessary insure global feature classes confused path classes 
shows example decision tree classify multi path gestures 
path classifier recognizes classes 
class composed paths 
possible classes path path classes similar paths similarly similar second paths distinct possibilities path 
identical path components global classifier discriminate adding level decision tree 
classification example input indicated dotted lines 
chapter 
multi path gesture recognition decision tree path classifier global classifier path classifier gp gr gq gs gq gs multi path gesture classes path chosen gesture classifying multi path top examples path gestures expected classifier left path gesture classified 
path gesture classified path classifier path path path classifications traverse decision tree shown dotted lines 
tree node reached ambiguous having children global features resolve discrepancy andthe gesture recognized class 
training multi path classifier training multi path classifier training algorithm multi path classifier uses examples multi path gesture class typically examples class create classifier 
creation multi path classifier consists creation global classifier number path classifiers 
creating statistical classifiers path classifiers global classifiers created statistical algorithm described 
paths example sorted paths sorting index class forming class train path classifier index example consider training multi path classifier discriminate multi path gesture classes consisting paths 
gesture class consists path classes subscript indicating sorting indices paths 
similarly class consists classes 
path examples form class 
train path classifier discriminate path classifier discriminate 
global features create nominally able discriminate classes global features bg sorting index quite possible legitimate paths different gesture classes indistinguishable 
example path classes may straight 
presumably distinguishable second paths global features 
case examples class misclassified vice versa 
desirable ambiguities path classifier combining classes mistaken single class number approaches taken detecting removing ambiguities statistical classifier 
possible approach compute mahalanobis distance classes merging threshold 
approach involves applying clustering algorithm examples merging classes members just examples classes 
third approach evaluate actual performance classifier attempts distinguish possibly ambiguous classes classifier indicate classes merged 
approach pursued naive approach evaluating performance classifier construct classifier set examples testing performance classifier examples 
approach obviously underestimates ambiguities classes classifier biased correctly classifying training examples 
constructed small number examples typically class uses remaining examples evaluate constructed classifiers 
misclassifications indicate classes ambiguous merged 
practice thresholds established single small percentage misclassifications cause merger mathematically combining classes simple operation 
mean vector combined class computed average mean vectors component classes weighted chapter 
multi path gesture recognition relative number examples class 
similar operation computes composite matrix covariance matrices classes combined 
algorithm removes ambiguities combining classes applied global classifier 
remains construct decision tree multi path classifier 
creating decision tree decision tree node fields mclass pointer multi path gesture class pointer array pointers subnodes 
construct decision tree root node allocated 
class phase multi path gesture class considered turn 
foreach sequence path classes sort index order global feature class appended constructed 
nodes created decision tree way leaf node mclass value current multi path gesture class reached 
creates decision tree correctly classify multi class gesture component paths correctly classified 
example phase example gesture considered turn 
paths classified global features 
sequence constructed class gesture added decision tree location corresponding sequence 
normally global features gesture classified correctly node tree corresponding sequence 
paths global gesture classified incorrectly new node may created decision tree classification mistake result correct classification 
attempting add class sequence components misclassifications possible decision tree node reached non null mclass field referring different multi path gesture class example currently considered conflict resolved ignoring current example warning message printed 
ignoring instance sequence insures sequences generated class phase take precedence generated example phase 
course conflict occurring class phase indicates serious problem pair multi path classifier unable discriminate 
decision tree construction nodes global feature class entry mclass value set gesture class mclass value subnode words sequences classified referring global feature class marked 
avoids extra potential error global feature classification 
path features global features classification individual paths global features multi path gesture multi path gesture recognition algorithm discussed far 
section describes particular feature vectors detail 

improvement classification algorithm classify paths global features statistical chapter criteria feature selection discussed section addressed 
particular features gaussian distributions considered 
path features include features mentioned chapter 
additional feature starting time path relative starting time gesture 
example gesture consisting fingers enter field view simultaneously move right parallel distinguished gesture single finger enters field moving right second finger brought moves right 
particular classifier second sorting index able discriminate path begins start gesture begins path start time path sorting described section 
main purpose global feature vector discriminate multi path corresponding individual component paths indistinguishable 
example gestures consisting fingers moving right having fingers oriented vertically horizontally 
having fingers half inch apart inches apart 
global features duration entire gesture length bounding box diagonal bounding box diagonal angle ss wrap problems length sine cosine point path point path referring path sorting order length sine cosine point path point path 
multi path gesture attribute may considered global feature paths gesture 
number paths included list included vector input statistical classifier 
required gestures agiven class number paths 
number paths match exactly gesture classified class 
restriction additional advantage knowing number paths simplifies specifying semantics gesture see section 
global features crude appear cases enable effective gesture classes classified solely basis constituent paths 
improvement mentioned multi path classifier path classifier sorting index 
path path needs distinguish gestures consisting single path path gestures having paths 
similarly second path discriminate second path path gestures second path path gestures 
places unnecessary burden path classifiers gesture classes different numbers paths confused need path classifier able discriminate constituent paths 
observation leads toa improvement multi path recognizer 
improvement having single multi path recognizer discriminating path gestures differing numbers paths multi path gesture recognizer chapter 
multi path gesture recognition described possible number paths 
multi path recognizer path path gestures maximum number paths expected 
path classifier deals paths sorting gestures number paths 
result path classifiers fewer paths deal improve recognition ability accordingly course input devices number paths fixed dataglove improvement apply 
alternate approach path clustering multi path gesture recognition implementation sensor frame relies heavily 
path sorting decide paths submitted classifiers global feature calculation 
errors path sorting similar gestures having different places path ordering potential source misclassifications 
thought multi path recognition method avoided path sorting accurate 
global features path sorting step create global feature set rely path sorting 
usual criterion small change gesture result small change global features 
features depend largely precise order paths paths start simultaneously may appear order 
features weighted difference starting times successive paths paths change order 
approach avoids problem create global features depend say pair paths immune problems sorting 
global features previous global features discussed 
relied path ordering features 
previous feature weighted path start time differences 
example feature length path point path multiplied difference start times second path multiplied difference start times ofthe path 
second sum feature pair path sum length start points pair paths 
sine sum absolute values 
multi path recognition single path classifier path sorting allows number different path classifiers path 
avoid path sorting single classifier classify paths 
referring example section single classifier distinguish 

alternate approach path clustering paths gesture classified class information needs combined classification gesture 
decision tree 
path sorting eliminated apparent order classes sequence submitted decision tree 
remedy path class assigned arbitrary distinct integer training 
path class sequence sorted global feature classification remains sequence decision tree examined 
net result node decision tree corresponds set path classifications 
explained node corresponds multiset essence recognition algorithm simple lone path classifier determines classes paths gesture set path classes global feature class determines class gesture 
unfortunately explanation glosses serious conceptual difficulty order train path classifier known instances path class required 
path sorting possible know paths instance gesture class 
paths example arbitrarily called done paths examples class asked answer question straightforward 
path second instance similar path previously called called 
gesture class hasn paths goal divide set paths training examples class groups group containing exactly path example 
ideally paths forming similar words correspond 
note path sorting produces exactly set groups 
examples class paths sorting index form group 
purpose endeavor build multi path recognizer path sorting resort training phase 
errors sorting example paths get built path classifier beneficial effects avoiding path sorting recognition way proceed analogy 
gesture class paths example compared example corresponding paths identified 
conceivably feature path location timing path 
approach tried retrospect simplest 
clustering grouping similar paths attempted 
definition similarity feature vector path 
particular relative location paths ignored 
group similar paths solely basis feature vectors known hierarchical cluster analysis applied 
step cluster analysis create triangular matrix containing distance pair samples case samples path example class 
distance computed normalizing feature dividing standard deviation typical normalization step subtracting feature mean omitted effect difference instances feature 
distance pair chapter 
multi path gesture recognition example path feature vectors calculated sum squared differences features 
matrix clustering algorithm produces cluster tree dendrogram 
den binary tree additional linear ordering interior nodes 
clustering algorithm initially considers individual sample group cluster giving distances pair groups 
similar groups pair corresponding smallest entry matrix combined single group new group created dendrogram subnodes refer constituent groups 
distance matrix updated replacing rows columns groups single row column representing composite group 
distance composite group group calculated function constituents group 
combining functions possible particular group average method computes distance group group average weighted group size constituent groups group 
matrix updated process repeated smallest matrix corresponding groups combined matrix updated 
continues group left representing entire sample set 
order node creation gives order dendrogram nodes nodes created early having subnodes groups similar nodes created 
shows dendrogram paths path clasp gestures slightly right index middle fingers move left 
leaves dendrogram labeled numbers paths examples 
notice right strokes example left strokes example 
dendrogram original samples broken arbitrary andthe number samples number groups 
get groups simply discards top gamma dendrogram 
example get groups root node discarded groups represented branches root node 
turning back problem finding corresponding paths examples multi path gesture class step compute dendrogram paths examples gesture 
dendrogram traversed bottom post order fashion histogram indicates count number paths example computed 
computation straightforward leaf node path count zero path came interior node element histogram sum corresponding elements subnode histogram 
ideally nodes tree histogram indicates paths come different examples example represented exactly 
practice things nicely 
errors clustering group example grouping path example 
case easily handled setting threshold accepting nodes paths appear exactly cluster 
second difficulty fundamental 
possible paths quite similar remember relative path location ignored 

alternate approach path clustering path shows result clustering applied paths path clasp gestures shown 
clasp gesture short rightward moving path similar long leftward moving paths 
clustering algorithm groups similar paths groups paths 
height interior node indicates similarity groups lower nodes similar 
note right subtree ofthe root contains paths multi path gesture 
termed cluster indicated circle graph constituent paths correspond 
left subtree containing paths gesture cluster 
descendants cluster containing approximately paths gesture concluded paths gesture different corresponding paths clusters 
happened descendant left subtree cluster concluded paths similar treated examples single path class 
chapter 
multi path gesture recognition common sensor frame gestures performed moving elbow shoulder wrist fingers rigid 
paths just paths example grouped corresponding paths different examples 
histogram shows path example ideally node histogram containing paths example 
case call node histogram indicating equal equal number paths example cluster 
search clusters proceeds top 
root node cluster examples path gesture class root node histogram indicate paths example gesture 
descendants root node indicates paths gesture similar 
clusters root fewer examples path root indicates paths ofthe gesture similar 
path example say subnode root node cluster path example paths form distinct path class different path classes gesture class 
subnode root cluster paths example 
exist descendant node path example indicates gesture paths classes similar 
clusters node indicate path class gestureclass different 
cluster analysis somewhat path sorting indicates paths example gesture class correspond 
clusters indicated circles occasionally stragglers paths clusters identified analysis 
attempt put stragglers appropriate group 
single easily placed group lacking example class 
example contains currently ignored 
desired apath classifier discriminate clusters created classify stragglers 
done current implementation stragglers 
path classes gesture class identified clustering technique apath classifier trained distinguish path class gesture class 
note possible path class formed paths example class cluster analysis indicated paths similar 
analogy techniques separate class multiple path example classes resulting ambiguously classify paths 
case ambiguities possible different gesture classes may similar gesture paths 
section ambiguities removed fromthe classifier combining ambiguous classes single class 
unambiguous class recognized path classifier numbered establish canonical order class sequences training recognition 
creating decision tree single path global classifiers trained decision tree constructed class phase multi path gesture class unambiguous classes constituent path enumerated 
paths single gesture class may similar enumeration classes may list single class may considered 
discussion multiset 
list classes sequenced canonical order global feature class appended andthe resulting sequence add multi path class decision tree 
conflict due fact different gesture classes multiset path classes fatal comes example phase 
paths example gesture classified single path classifier resulting sequence canonical order global feature class appended add class example decision tree 
usually needs done sequence add class usually class phase 
paths sequence misclassified adding decision tree improve recognition misclassification may occur 
conflicts fatal simply ignored assumption sequences added class phase important added example phase 
discussion multi path gesture recognition algorithms described referred path sorting path clustering methods 
situations uncertainty path index information dataglove sensors attached hand sorting method certainly superior 
input devices sensor frame path sorting done heuristically increases likelihood recognition error path clustering method avoids path sorting associated errors 
sources misclassification introduced 
single path classifier discriminate classes system recognize large number classes 
error rate classifier increases number classes path classifier path clustering perform path sorting algorithm 
second source error clustering errors cause errors classifier training data cause path classifier degrade 
way cluster paths hand having computer perform automatically 
needed done gesture sensor frame glitches tracking hardware clustered reliably practice path sorting method performed better 
poor performance path clustering method generally due noisy sensor frame data 
difficult general gesture sets methods tested designed path sorting algorithm mind 
easy design set gestures sorted paths 
possibility parameterizable algorithm sorting paths choose parameters gesture set sensor frame significant source classification errors 
fingers sensed inadvertently break sensing plane causing gesture typically rejected 
fingers sensing plane easily occlude respect sensors making difficult determine finger location 
sensor frame hardware usually knew history fingers best estimate positions resulting data glitches degraded classification confusing chapter 
multi path gesture recognition tracking algorithm 
additional preprocessing paths improve accuracy 
sensor frame development possible glitches eliminated hardware area apply single path eager recognition described chapter eager recognition multi path gestures 
presumably simply matter recognizing path combining results decision tree 
works remains seen possible apply multi path algorithm recognition multi stroke gestures 
path sorting case simply order strokes arrive 
date tried 
chapter methods multi path gesture recognition discussed compared 
paths gesture individually uses decision tree combine results uses global features resolve ambiguities 
method path sorting builds path multi path gesture 
order determine path submit classifier physical input device needs able tell finger corresponds path sorting algorithm numbers paths 
second method path clustering avoids path sorting arbitrary component classifier classify paths 
general path sorting method proved superior 
details algorithm known possible design set gestures poorly recognized due errors path sorting 
knowledge design gesture sets run path sorting problems 
chapter architecture direct manipulation chapter describes grandma system 
grandma stands gesture novel direct manipulation architecture 
chapter concentrates solely architecture system gesture recognition 
design gesture recognizers grandma subject chapter 
grandma object oriented toolkit similar discussed section 
model view controller mvc paradigm 
grandma borrows ideas event user interface systems squeak grandma implemented objective dec microvax ii running unix window system 
motivation building object oriented user interface toolkit large task undertaken lightly furthermore toolkits peripherally related topic hand gesture systems 
decision create grandma requires justification single idea motivated author object oriented toolkits construct gesture systems gestures associated objects screen 
just object messages understands author believed class determine gestures object understands 
ideas inheritance overriding apply gestures 
analogy gestures messages central idea systems portion current desirable integrate gestures existing object oriented toolkit build scratch 
time began smalltalk mvc pascal ran unix environment available preferred author 
author 
existing object oriented user interface systems tend low level input models device dependencies spread system 
example systems require views respond messages event structures chapter 
architecture direct manipulation represent input fixed small set devices 
general output models received attention input models 
goal grandma investigate new architectures input processing 
architectural overview shows general overview architecture grandma system 
order architecture reader response typical input event traced 
brief description system components order grandma model view controller mvc paradigm 
models application objects 
concerned semantics application userinterface 
views concerned displaying state models 
model changes responsibility model view relay change user 
controllers objects input 
grandma controllers take form event handlers single passive event handler may associated view objects input initiated view oneof view passive event handlers may activate copy handle input 
example pressing switch consider display consisting toggle switches 
toggle switch model object containing boolean variable 
model messages set retrieve value variable view display state toggle switch bythe event handler change state toggle 
mouse cursor moved switches say left mouse button window manager informs grandma raises input pick event 
object groups information event fact mouse event button pressed significantly coordinates mouse cursor raising event causes active event handler list searched handler event 
turn event handler list asked wishes handle event 
handlers interested event handler list called handles event 
happens case pressing 
able process event location events coordi 
handler searches view database constructs list views event words views event location 
search simple rectangular region included event location rectangle view added list 
switch example list views consists indicated toggle followed view representing window toggle switch drawn 
distinction controllers event handlers way interacts underlying layer generates input events 
activated controllers loop continually calling input layer input events interaction completes 
words controllers take control forcing user complete interaction initiating 
contrast event handlers essentially called input layer input occurs 
interact simultaneously multiple event handlers example multiple devices 

architectural overview event display view db input event list handlers grandma grandma user actions cause events raised pressing mouse button raises pick event handler active event handler list asked order wishes handle event 
list asked previous active handlers event 
event screen location mouse event uses determine views screen location asks view front back wishes handle event 
answer view consults list passive event handlers associated withthe view associated view class superclasses see interested event 
passive handler may activate typically placing copy active event handler list 
enables subsequent events handled efficiently short circuiting elaborate search handler initiated 
event handler consumes interested allowing events propagate event handlers 
chapter 
architecture direct manipulation views queried starting foreground view 
view asked view gives opportunity non rectangular view respond events directly 
event view view asked handle input event 
search proceeds view wishes handle event views event declined 
example toggle switch view handles event propagated window view 
view respond directly query handle input event 
request passed view passive event handlers 
associated view list event handlers handle input view single passive event handler shared views system 
passive event handlers asked input turn search stops decides handle input 
example toggle switch event handler list passive handlers handle pick event passive event handler decided handle event may activate copy instance place copy instance active event handler list 
may choosing doall associated event gets event 
example toggle switch may change state immediately mouse button pressed switch may changing state button released switch 
case need activate event handler passive handler change state 
case passive handler activates copy highlights switch monitors subsequent input watch cursor remains view 
cursor moves away view active event handler turn highlighting switch depending kind interaction wanted deactivate 
mouse button released switch active event handler view toggle state associated model deactivate 
noted active handlers asked events view database searched passive handlers queried 
switch example subsequent mouse movements button held release mouse button handled active handler head active event handler list 
tools tool component grandma architecture mentioned example 
object raises events events tools operate views models system 
event handler may considered mechanism view 
interaction means unidirectional event handlers cause views operate tools 
addition operating views directly event handlers raise events seen 
event associated tool typically refers device generated event example system mice mousetool objects identify mouse caused pick event 
asked handle event active handler typically checks event tool caused handler 
objective notation activated place 
manner active event handler ignores events 
tools involved device emulates 
example sensor frame mouse having active handler consumes events tool raising events tool mousetool response 
mousetool correspond real mouse allows sensor frame masquerade mouse tools necessarily refer hardware devices 
virtual tools software objects typically views act input hardware may generate events 
example file views icons virtual tools implementing macintosh finder grandma 
dragging file view cause events raised tool file view 
passive folder directory views programmed activate event tool file view dragged folder 
grandma mechanism mouse cursor dragged views mouse drag view views typical case tool semantic action operates views tool dropped handled gracefully grandma 
associated view passive 
tool dragged view responds tothe tool action associated view activates highlighting view 
dropping tool view causes action occur semantic feedback easy achieve virtual tools see section 
concludes brief overview grandma architecture 
discussion grandma system follows 
reader wishing avoid details may proceed directly section summarizes main points comparing grandma 
objective notation mentioned grandma written objective language augments oriented programming constructs 
part dissertation program fragments written objective objective variables functions values objects declared type id id aset variables type id really pointers refer objective object value nil 
pointers variables need initialized refer object aset set new lambda create set object lambda expression send message object termed receiver selector 
similar function call returns value type depends selector 
objective comes supplied number factory objects known classes 
set isan example factory object factory objects responds message new related case tool dragged view acts tool trash handled 
chapter 
architecture direct manipulation newly allocated instance messages may parameters id rectangle origin corner aset add message selector concatenation parameter labels origin corner case add second 
cases parameter colon 
factory fields methods declared example rect object int origin int int corner int int self self new return self gamma int int return self declares factory rect subclass factory object root 
note factory declaration begins token 
method declared defines message sent directly factory object methods allocate instance factory 
method declared defines message sent directly instances class 
variable self accessible method declarations object message sent receiver 
self set instance object class defined fields object referenced directly 
corner method step factory method reassign self instance factory initialize fields instance 
usage self new rect new allows method applied subclass rect case self refer factory object subclass 
types methods left unspecified assumed id typically methods return self better return void returning 
describing method class fields methods omitted rect 
gamma int area return abs gamma lambda gamma gin objective messages selectors class objects assigned passed parameters sent objects 
construct selector message selector object type sel runtime representation message selector id rect origin corner sel op flag selector area selector height printf perform op rectangle sent area height message depending state flag 
perform message sends message indicated passed sel object variants form perform allow additional parameters sent 
class nature message selectors distinguishes objective static object oriented languages notably 
analogous pointers functions sel values 
hierarchies may considered pointers messages 
objective includes functions converting sel values strings method inquiring runtime object responds arbitrary message selector 
seen objective features grandma implementation interest simplicity debugging code memory management code removed code fragments shown course needed practice 
code explained text comments removed brevity 
hierarchies far important hierarchies object oriented user interface toolkits hinted prudent confusion discussing 
known class hierarchy 
class hierarchy tree subclass superclass relationships single inheritance system objective objective class object class hierarchy grandma classes model view subclasses object subclasses subclass 
entire tree referred class hierarchy particular subtrees referred qualifying term class name 
particular view class hierarchy class view root subclasses view subnodes root 
second hierarchy referred view hierarchy view tree 
view object rectangular region display window 
view may subviews control subareas parent view rectangle 
example dialogue box view may radio buttons 
subviews usually foreground parent views words subview usually obscures part parent view 
course subviews subviews entire structure known view tree 
grandma root view tree view corresponding particular window display program windows view tree 
important confuse view hierarchy view class hierarchy refers subview relation subclass relation 
models model view controller system naturally important classes model view grandma term 
discussion grandma divided sections classes 
class model considered models objects contain application specific data 
model objects encapsulate data computation task domain 
mvc paradigm specifies methods contain user interface specific code 
model typically respond messages inquiring state 
manner view object may gain information order display representation model 
chapter 
architecture direct manipulation number mvc systems specific class named model 
object may act model 
grandma smalltalk single class named model subclassed implement application objects 
existing classes directly serve models 
advantage ease implementation ability easily distinguish models objects tenets mvc paradigm model objects independent views intent user interface application able changed modifying application semantics 
effect desire modularity model subclass views 
state model changes mechanism needed inform views ofthe model update display accordingly 
way accomplished model list dependents 
objects views wish informed state register dependents model 
convention model object sends modified message changes results dependents getting sent message time act accordingly heart implementation model class grandma simple instructive model object id dependents gamma dependents nil dependents new dependents add return self gamma dependents nil dependents remove return self gamma modified dependents nil lambda send dependents lambda dependents selector return self model subclass object additional field dependents 
model created dependents field automatically set nil 
time added sending message dependents field set new instance class representing lists objects 
dependent list removed message 
model class intended instantiated directly 
simple example model boolean variable view boolean model bool state gamma bool getstate return state 
views gamma setstate bool state state state return self modified gamma toggle state state return self modified boolean object state changes sends modified message results dependents getting sent message 
views class view mentioned handles display models 
easily grandma system lines code currently implements factory methods instance methods including inherited object 
brevity methods mentioned mentioned passing 
views number instance variables fields view object id model id parent children id picture highlight short id box int state model variable view connection model 
views model model nil 
fields parent children implement view tree parent view children list subviews view fields picture highlight refer graphics draw highlight view respectively 
graphics drawn respect origin specified constrained rectangle object box 
state field set bits indicating current state view set grandma system desired state view controllable view user 
illustrate view methods toggle switch view model described 
view gto create toggle switch view id boolean new id method class view allocates new view object case sets model instance variable add model dependents model self graphics switch implemented 
gamma id self chapter 
architecture direct manipulation rectangle model getstate rectangle self return self intention draw empty rectangle pixels size switch model state false put smaller rectangle switch model state true 
view methods deal picture 
prefix method names convention indicating messages sent subclasses view 
creates initializes object returns 
graphics directed picture whichis essence display list graphics commands 
note model state queried model instance variable inherited class view 
done efficiency purposes way accomplish thing self model getstate 
method gets called indirectly view method view 
gamma self update state notify children lambda propagate kids lambda children selector return self gamma update return self state bit notify children settable creator view determines messages propagated subviews 
bit turned subclass view overrides update method order propagate certain subviews 
example view model list subview element list displayed left right element deleted list arrange subviews right deleted redrawn 
typical case subclass implements method reflect state model 
switch displayed needs subview descendant wallview 
abstraction window display 
instance wallview created window program requires id wallview name gdp fragment creates window named gdp 
string gdp looked database case file administered window system determine initial location window 
switch added subview wall view displayed coordinates newly created window 

event handlers ends discussion major methods class view 
need arises discussed 
ironic dissertation largely concerned input effort expended output 
initial intention keep output code simple usable 
unfortunately thousands lines code required get point 
event handlers grandma analogue mvc controllers event handlers 
input occurs event raised 
raising event results search active event handler handle event 
events handler active list catch function search views event location 
view asked wishes handle event view asks passive event handlers handle event 
mentioned single passive event handler may associated different views 
passive event handler may activate copy instance response 
warning readers due dissertation focus input necessarily 
events event handlers discussed detail helpful concrete exactly event 
events instances subclass event event object id instigator gamma instigator return instigator gamma instigator instigator instigator instigator return self instigator event object posting event 
window manager events instance class wall shows event class hierarchy 
instigator class event variable shown method set method retrieve value 
important subclass event associated window usually raised grandma interface window manager 
generated character typed user 
generated window manager requests window redrawn 
subclasses class raised window manager mouse event 
cases tool field instance subclasses 
mouse button pressed generated 
field loc instigator tracing debugging 
occasionally quick check active event handler wishes insure handling events raised object raised event activated place 
active handlers bother check content simply check tool instigator 
chapter 
architecture direct manipulation id wall int character id event id loc id tool id tool id loc event event hierarchy point object indicating location mouse cursor mouse object referred tool field indicates button pressed 
mouse moved currently mouse button pressed generated 
mouse button released generated classes discussed chapter 
raising event wallview object represents root view tree window 
associated object wall object implements interface grandma window manager 
associated wallview object window object 
wallview view id handlers id id wall name str name self self nil wall wall create name wallview self handlers new new handlers add wallview self return self gamma raise event return handlers raise event gamma return retrospect probably represent points rectangles structures separate coordinates point rectangle objects associated overhead 

event handlers wall object grandma geometry win win id pictures id wallview gamma raise event fif event self redraw return wallview raise event raised particular window raise message 
redraw events handled wall wall maintains list picture objects currently hung redraw easily accomplished 
redraw special case really just old code simple replace code redraw event handler 
events passed wall gamma raise int self gamma gamma self event break return self gan just add remove messages sent add remove active event handlers 
add message adds handlers list raise iterates list backwards asking element list order wishes handle event 
handlers activated asked events activated earlier 
possible install active event handler arbitrary position methods grandma 
note thing wallview object created activate handler list tried declined process event 
active event handlers active event handler respond event message returning boolean handled event 
object gamma bool event return bool self event method placeholder actual method implemented differently subclass 
method object 
method simply prints error message stating subclass receiver implemented method note event message sent active event handlers views 
event handler activated generally stores view tool caused chapter 
architecture direct manipulation activation refer decide handle event 
handling event active event handler typically sends view messages find model view refers previously mentioned active event handler tried 
handler atypical exists passive state 
id wallview wallview wallview self self new wallview wallview return self gamma bool event id views seq tool 
selector loc return views wallview loc tool tool seq views seq tool event return return gan instantiated activated wallview created see section 
wallview recorded handler access current database views views view subtree wallview 
retrospect efficient store handle database directly wallview 
asked handle event event message checks see event responds message loc 
currently subclasses respond loc conceivably change handler generally possible 
points major benefits objective inquire object responds message attempting send message example seen section 
going look views location event obviously deal events locations objective term false case view database consulted returning views bounding box contains point 
views returned sorted foremost background depth view tree deepest 
order view queried wishes handle event stopping view says 
test explained section suffice say typical case tool kind equal view view wishes handle event returns 
handler active event handler tried says event ignored 
desired simple matter activate handler tried purpose handle events printing message effect events ignored 
shown section passive event handlers asked handle events event view message parameter event handler gets tool view 

event handlers example event handler section said active 
view database function view database determine set views location window object oriented ui toolkits function combined event propagation events propagate view tree corresponding controller tree directly idea separate view database comes 
separating view database data structure efficient algorithms looking views point bentley dual range trees may applied 
unfortunately optimization completed retrospect having keep view database synchronized view effort worth 
set gamma enter object rectangle return self replace object object rectangle depth object depth id lambda lambda return lambda depth gamma lambda depth gamma id seq array result new int seq self seq nil contains array qsort array sizeof id result add array object return result rectangle id object unsigned depth object rect depth unsigned self self new object depth return self origin rect origin corner rect corner gamma object return object gamma unsigned depth return depth gamma unsigned hash return object hash gamma bool object gamma object chapter 
architecture direct manipulation set objects element rectangle object kind view grandma depth 
view objects grow sure register new locations view database wall lie 
currently done automatically sync method class view updating display view changes 
hash methods define objects equal respective object fields equal 
passive event handler search continues view object list passive handlers associated 
association implicit passive handlers associated view directly class view superclasses view class 
example directly associated class view appears view list passive event handlers 
view 
gamma bool event id seq 
self loc return seq self seq event view self return return gamma id new id class self class self class class object class class superclass class return return getvalue self handlers gamma return getvalue self handlers view asked wishes handle event asks event location view 
implementation method class view simply returns 
non rectangular subclasses view see section override 
assuming event location view passive event handler associated sent event view message asks passive handler wishes handle event 
search stops soon handlers says handlers tried method returns ordered sequence handlers associated view 
sequence concatenation handlers directly associated view object associated view class associated view superclass including associated class view 
associations stored 
event handlers global property list 
passive event handler associated view object class handlers property lies advantage objective object superclasses may traversed runtime case enabling simulation inheritance passive event handlers 
difficult achieve possible access class hierarchy runtime 
passive event handlers passive event handler returns event view message wishes handle directed view 
side effect passive event handler may activate copy instance handle additional input incurring cost search 
objective classes class objects system known factory objects factory object subclass may play role passive event handler activate handler factory instantiate place new instance active event list 

bool event view return bool self gas example consider handler toggle switch discussed earlier id view tool bool event view return tool mousetool return self self new view tool tool view wallview activate self view highlight return gamma bool event bool jj tool tool return view loc jj view view wallview deactivate self view model toggle factory objects passive event handlers restrictive instance factory object class 
customization factory passive event handler difficult 
section regular non factory objects may passive event handlers 
chapter 
architecture direct manipulation return event handler associated mouse pressed view handler event view method called instantiates handler highlights view 
events typing character moving mouse button pressed view ignored passive handler 
mouse events including respond tools kind mousetool mousetool subclass 
reason explained section 
handler activated gets priority incoming events 
event method insures responds mouse events generated mouse initially caused handler activated 
valid events handler checks location event mouse cursor view view method 
note passive event dispatch efficient method point event location known bounding box view bounding box check method event handlers see events determined views 
mouse longer switch mouse button released view turned handler deactivated 
case mouse view button released view model toggle executed 
clause view model returns model associated switch presumably class boolean toggle message 
course result switch picture getting changed reflect model new state case returning active event handler indicates handled event attempt propagate 
typically get associated follows 
initialize return self initialize factory method invoked class program method objective runtime system program started 
case factory method create list containing single ele ment associate class handlers property note simple changes radically ter behavior switch 
example view model toggle executed switch pressed event view method switch mo toggle switch 
similarly changing initial check mouse moves switch deactivating handler moving mouse back switch button pressed instance switch re activate handler 
handler changed deactivate 
event handlers raised button grabs mouse meaning objects events long button pressed 
clear different behaviors possible simply changing event handler grandma easily allows flexibility programming behavior individual widgets interaction techniques control multiple widgets tandem difficult program example radio buttons clicking set buttons causes turned rest set turned implemented having individual buttons new parent view new handler parent view take care mutual exclusion 
alternatively parent view handle mutual exclusion providing individual buttons call pressed case parent necessarily provides radio button interface rest program 
semantic feedback semantic feedback response user input requires specialized information objects 
example macintosh finder dragging file icon folder icon causes folder icon highlight dropping file icon folder icon cause moved folder 
dragging file icon file icon causes highlighting dropping file file effect 
highlighting semantic feedback grandma general mechanism implementing views objects react views objects dropped highlighting objects 
views called buckets grandma 
view may bucket simply associating passive expects respond messages discussed 
view semantic feedback described happen automatically 
bucket view causes action view dropped trash bucket tool object causes action dropped view delete cursor tool 
mentioned tool corresponds physical possible view tool 
case view referred virtual tool buckets tools quite similar main difference buckets action associated stationary views tools action associated view dragged implementation tools considered 
similar implementation buckets described 
tool object gamma sel action return sel gamma return nil gamma bool return self action gamma event perform self action self self chapter 
architecture direct manipulation return self tool responds messages 
default imple mentation tool action runtime encoding message selector action parameter arbitrary object 
example way create tool deleting objects tool gamma sel action return selector delete method checks see view passed parameter responds tool case delete 
method performs action passing action parameter event tool additional parameters ignored case 
associated view view 
initialize self id tool view bool event view return tool return self self new tool tool view view highlight view wallview activate self return gamma bool event return tool tool return view loc view view wallview deactivate self tool view event return view view wallview deactivate self return 
event handlers passively operates simply checking view acts view 
view highlighted semantic feedback handler activates instantiation 
subsequent events checked see tool 
tool view event handled tool act view 
tool view highlighting turned handler deactivates returns handlers may handle event test tool see section prevents view virtual tool attempting operate 
generic event handlers story far know event handlers shown passive handler implemented factory class object responds event view messages 
necessary passive handler activates instantiation 
having factory objects passive event handlers changed runtime 
example passively responds 
passively responded change implementation affecting behavior toggle switch view subclass doing necessary duplicate event view method change putting event view method method sothat subclasses 
case changing simple item kind event handler passively responds difficult need order event handlers parameterizable passive event handlers regular objects factory objects 
response problem event handlers 
id id view wall tool env passive return self new gamma return self gamma return self gamma return gamma bool env return eval env gamma return self gamma return gamma bool env return eval env chapter 
architecture direct manipulation gamma return self gamma return gamma bool env return eval env gamma bool event view env env new str event value str view value self env self return return gamma event self self copy view wallview activate self view wall view wallview tool tool self return self gamma bool event tool nil tool tool return env env new str event value str view value view self env self wall deactivate self self env self return return gamma return self gamma return self gamma return self ga new passive handler created sending kind 
generic event handler object settable predicates 
predicates expression objects essentially runtime representations expressions 
objective interpreter built grandma discussed section convention predicates evaluated environment event bound tothe event consideration view bound view location event 
course result evaluating predicate boolean value 

event handlers passive method typically overridden subclasses order provide default values 
predicate events passive handler reacts 
class allows easy specification simple predicates call self new mousetool sets start predicate check event kind tool 
results passive event check hard coded factory check may easily modified runtime message tells passive event handler activate predicate satisfied 
note clone handler activated due tothe statement self self copy possible single passive event handler activate multiple instances simultaneously 
active handler responds satisfies predicates 
case active event handler deactivated predicates satisfied generic event message respectively 
main subclasses done methods event allows passive handler activated externally typical way having satisfied event view method 
case parameter usually nil 
example application wishes force user type text dialogue box proceeding activate text handler manner purpose generic event handlers grandma similar interactors garnet pluggable views smalltalk 
grandma comes number useful generic event handlers application programmers need write 
may customize generic handlers setting parameters suit 
parameters generic event handler common predicates ones modified 
grandma subsystem allows modified runtime user drag handler example generic event handler consider 
associated witha view allows view moved dragged mouse 
desired moving view result new events raised 
allows view tool discussed section 
parameterizable view moved absolute coordinates view copied copy moved messages sent move view 
reasonable defaults supplied parameters 
bool relative sel typically interface designer user facility 
chapter 
architecture direct manipulation bool deactivate int passive self super passive self self new mousetool self new self new relative selector sel return self lambda changing default parameters lambda lambda causes view copied copy dragged lambda gamma return self lambda handler raise events lambda gamma return self lambda handler send move message coordinates deltas current position lambda gamma relative selector move lambda sets message sent event terminates drag lambda gamma sel sel sel return self lambda sets message sent point drag lambda gamma sel sel sel return self gamma id loc relative view gamma view gamma view view view flash 
event handlers return self gamma int relative loc loc view perform gamma gamma loc loc view perform wall raise class tool view loc newloc wall wall instigator self time time return self gamma wall raise class tool view loc loc wall wall instigator self time time view perform return self passive factory method creates instance variables set parameters 
parameters changed messages please refer comments code description function parameters 
example associated class follows 
initialize self passive new mousetool dragged mouse clicking directly start predicate changed 
generate events chapter 
architecture direct manipulation dragged sent handler general tools items deposited buckets 
course subclasses instances may passive event handlers override behavior passive gets event satisfies start predicate method invoked 
location information saved view copied need view flashed rapidly highlighted user feedback 
subsequent event satisfies predicate cause method invoked 
events satisfy handle predicate cause invoked 
moves view typically message new coordinates arguments possibly raises new event view playing role tool event 
view tool raising event handler activated previously discussed 
note event raised created determining class object factory event default predicates case class asking class create new event passed event 
new event attributes copied verbatim old attributes tool instigator changed 
sophisticated event location designated hot spot view moved simply location passed event 
simplicity shown method possibly raises new event possibly sends message stored variable 
example set selector delete set 
mouse button pressed view view created 
moving mouse drags copy mouse button released copy deleted creating new drag handler associating view view class required view view inherits message 
shown grandma facility creating handlers making association runtime 
summary grandma concludes detailed discussion grandma 
discussion concentrated distinguish grandma mvc systems system discussed 
mentioned facilities described sufficiently powerful number useful view controller classes 
particular standard items popup views menus sliders buttons switches text fields list views implemented 
chapter shows applications 
grandma innovations come input model 
summary main points ofthe input architecture 
input events full blown objects 
event hierarchy imposes structure events device dependencies 

summary grandma 
raised events propagated active event list 

unhandled events screen locations automatically routed views 

view object may number passive event handlers associated class superclass events automatically routed appropriate handler 

passive event handler may shared views activate copy events aimed particular view 

event handlers predicates describe events respond 

generic event handler simplifies creation dynamically parameterizable event han 
input architecture grandma number novel features 
compared systems appropriate 
grandma support different input devices simultaneously 
due item grandma support different input devices addition just single keyboard mouse 
device needs integrate set event classes raises event hierarchy 
flexibility possible example sensor frame device raise single describing current set fingers frame separate finger tool case 
item possible write event handlers new device comes 
contrast existing user interface toolkits hard wired limitations devices support 
example systems macintosh toolbox library fixed structure describes input events easily altered 
systems go far advocate building device dependencies views example event handlers labeled cox system views respond messages 
similarly systems single controller view input events different devices 
hand general object classification scheme describing input events 
grandma supports emulation device 
grandma get device necessary event handlers respond events device associated view needs 
event handlers available itis possible write event handler emulates device 
example active handler catch raise mousetool response 
rest program tell getting real mouse data responds getting actual mouse input 
chapter 
architecture direct manipulation grandma handle multiple input threads simultaneously 
passive handlers acti copies views refer handler get input simultaneously 
input events simply propagated active event handler list active handler handles events expects 
grandma system mice simply mousetool objects easily 
normally passive handler activate receive input single tool mouse case allowing input mice handled independently directed view 
possible write event handler explicitly dealt events mice desired 
event systems squeak able deal multi threaded dialogues 
grandma similarity systems gives similar power 
contrast systems smalltalk activated loops polling events allow controllers receive events deactivated 
grandma provides virtual tools 
general structure input events require ment generated window manager 
event handlers raise events 
events tools associated example mouse associated 
tools may views objects 
messages action tool known effect objects dragged 
handler associated view system handle interaction tool certain action dragged object accepts action 
tools virtual correspond directly input hardware may send arbitrary messages views interact 
grandma supports semantic feedback 
handlers test run time arbitrary tool able operate arbitrary view dragged highlight view tool 
special code required tool 
tool views operates 
sole connection able send message able receive 
course default behavior may easily overridden 
tool arbitrary view model order decide wish operate view 
event handling grandma general efficient 
generality comes active handler handles event views location event 
views consult list passive event handlers potentially may handle different kinds events 
single passive event handler may shared views eliminating overhead controller object view 
time efficiency handles event may activate receives events immediately going elaborate dispatch 

summary grandma priority list dispatch agents similar grandma active list 
agents receive low level events window manager attempt translate higher level events received interactor objects views 
interactor agents register high level events interested 
architecture similar grandma difficult precisely difference 
high level events play role similar messages view may receive events view passive event handlers expect 
grandma registering implicit objective runtime implementation messages understood object need specified explicitly limited small set 
object may ask recognizes message sending 
translation low level high level events example emulate device 
particular possible translate low level events device 
grandma distinction low level high level events 
grandma distinguishes events messages events propagated active event handler list event handler handler may raise new events send messages views models 
grandma supports gestures 
grandma general input mechanism major design able support gestural input 
seen chapter gestures recognized collect mouse events set gestures recognize depending views initial point gesture recognized translate gesture messages models views 
handles gestural input somewhat grandma gesture event capture low level events produce high level events 
designers claim object oriented structure number different gesture tailor recognizer application bits application 
true grandma course intention half thesis sufficient generality accuracy recognition algorithms typically required 
claim recognizers excuse provide 
driving forces belief gesture recognizers sufficiently difficult build programmers hand code recognizers gesture set major reason hardly applications gestures 
necessary provide general order gesture interfaces explored 
recognizer integrated object oriented toolkit subject chapter 
course grandma disadvantages 
mvc systems multitude classes programmer needs familiar decide best implement particular task 
elaborate input architecture problem large number possible combinations views event handlers tools chapter 
architecture direct manipulation considered programmer new interaction technique 
grandma solving common problem faced mvc system deciding functionality goes view goes model 
problem event handlers views meant general event handlers initialized arbitrary message selectors communicating view practice written intention communicate particular event handlers really right claim specifics input truly factored views 
chapter gesture recognizers grandma chapter discusses gesture recognition may incorporated systems manipulation interfaces 
particular design implementation gesture handlers grandma shown 
emphasis grandma system methods generally applicable object oriented user interface construction tool 
note terms discussion explanation needed help avoid confusion 
discussed section important confuse view hierarchy tree determined subview relationship view class hierarchy subclass relationship 
grandma view hierarchy corresponding window root view class hierarchy class view root potentially ambiguous term class 
usually term object oriented sense refers type loosely speaking object 
term gesture class result gesture recognition process 
words gesture recognizer known gesture classifier discriminates gesture classes 
example consider able discriminate written digits 
example digit represents class presumably recognizer trained number class 
matters confusing grandma class object oriented sense named gesture object class represents particular gesture instance list points single gesture 
class named gestureclass objects ofthis class refer individual gesture classes example digit recognizer different gestureclass objects term gesture refer entire gesture class times refers single instance gesture 
example said recognizer discriminates aset gestures meant recognizer discriminates set gesture classes 
conversely user enters gesture refers particular instance 
cases follow chapter 
gesture recognizers grandma intent obvious context 
gestures mvc systems discussed chapters object oriented user interface systems typically consist models application objects views responsible displaying state models screen controllers responsible responding input sending messages views models 
view controller systems smalltalk view object controller object model object displayed screen section describes gestures integrated grandma providing example gestures integrated mvc systems 
gestures view class hierarchy central variations object oriented user interface tools view class 
view objects handle display models 
notion views central object oriented user interface tools views provide focal point adding gestures tools simply stated idea integrating gestures direct manipulation interfaces view responds particular set gestures 
intuitively obvious example controlled different set gestures dial 
ability simply easily specify set gestures associated semantics easily associate set particular views primary design goal adding gestures grandma 
course view respond distinct set gestures 
general expect similar views respond similar sets gestures 
fortunately object oriented user interfaces concept similarity built view class hierarchy 
particular usually sense view objects class respond set gestures 
similarly intuitively appealing view subclass respond gestures class possibly responding new gestures specific subclass 
intuitions essentially apply notions class identity inheritance oriented sense gestures 
seen gestures analogous messages 
objects class respond set messages just respond set gestures object subclass inherits methods superclass similarly object respond gestures superclass responds 
continuing analogy subclass may methods add new methods understood superclass similarly subclass may override interpretation existing gestures recognize additional gestures 
object oriented languages allow subclass disable certain messages understood superclass common analogously possible subclass may wish disable gesture superclass 
close parallel gesture classes messages possible way semantics kind view implement method gesture class expects 
classifying input gesture result class particular message sent implements sees fit 
subclass inherits methods superclass may 
gestures mvc systems override methods 
scheme subclass understands gestures superclass understands may change interpretation gestures 
close association gestures messages done grandma felt tobe 
objective methods specified compile time adding new gesture classes require program recompilations 
quite easy add new runtime unfortunate additions required recompilations 
goals grandma permit rapid exploration different gestures sets semantics forcing recompilations system tedious experimentation 
solution adopted small interpreter built grandma 
interpreted code associated gesture class code executed gesture recognized 
code interpreted straightforward add new code time specified modify existing code runtime 
glance building interpreter grandma quite difficult expensive objective explained section 
gestures view tree consider number views displayed window 
grandma systems pressing mouse button pointing particular view usually directs input view 
words view gets input usually determined time initial button press due view tree views may overlap screen initial mouse location may point number views simultaneously 
typically views queried order foremost determine gets handle input 
similar approach may taken gestures 
point gesture determines gesture directed 
determining overlapping views target gesture usually impossible just point seen 
entire gesture collected determination 
consider simplification gdp 
wall view views set creating graphic objects 
straight stroke gesture creates line gesture creates rectangle 
graphic object views respond different set gestures deletes copies graphic object 
gesture say existing rectangle immediately clear directed rectangle background 
gesture directed existing rectangle wall view 
clearly determination just point gesture seen quite true 
conceivable graphic object views handle gestures normally directed wall view 
practical 
example creating new graphic object existing include lining vertices objects 
nice option general idea force view explicitly handle gestures directed views covers chapter addressed problem classifying gesture set gesture classes 
seen set gestures necessarily set associated single view union gesture sets recognized views initial point 
chapter 
gesture recognizers grandma technical difficulties involved doing 
general quite inefficient classifier possible union view gestures sets 
necessary classifiers constructed unions occur 
current implementation classifier set gesture classes time set appears classifier cached possible view initial point responds gesture class 
cases preference topmost view 
result kind dynamic scoping similarly way subclass override gesture class recognized superclass may considered kind static scoping 
grandma gesture subsystem grandma gestural input handled objects class 
subclass easily complex event handler grandma system 
addition lines code implement various methods sole user grandma subsystems 
include gesture classification subsystem interface user modify gesture handlers example adding new gesture classes runtime objective interpreter gesture semantics user interface classes solely gesture handler 
getting details overview grandma various gesture related components 
shows relations objects classes associated gestures grandma 
main focus 
event handlers acti view object model wall view wall view activate raise set timeouts handlers draw gesture associated gesture event handler set objects 
gesture class object class gestureclass expressions subclasses expr 
gestureclass objects represent particular gesture classes recognized event handler 
expressions comprise semantics associated gesture class event handler 
expression evaluated gesture recognized subsequent input event handled gesture handler recognition manipulation phase see section third manipulation phase ends associated gestureclass object set gesture objects 
gestures class training classifiers recognize class 
gestureclass object contains aggregate information examples mean vector covariance matrix examples features construction classifiers determines gesture classes rules described previous section asks classifier class recall wall view root view tree represents window screen 

grandma gesture subsystem gesture gesture expr attributes expr model gestureclass gestureclass gestureclass expr view wallview classifier grandma gesture passive associated view view class expects gestural input gestural input begins handler activated refers directly view gesture directed shown 
object gesture 
uses timeout mechanism indicate change collection manipulation state 
object exists gesture expected handler object associating class semantics 
gestureclass object described set example gestures view objects examples class asa allow displayed 
gesture semantics represented expr objects may edited 
chapter 
gesture recognizers grandma classifier object capable doing discrimination 
normally classifier case existing classifier simply returned 
possible gesture classes set changed case existing classifier retrained recalculated occasionally set gesture classes seen case new classifier created set returned cached components related gesture event handler enabling user see alter various facets event handler 
predicates starting handling stopping collection gesture input may altered user 
gesture classes may created deleted copied gesture event handlers 
examples class may examined individual examples may added deleted semantics associated gesture class may altered interface objective interpreter 
gesture event handlers details class described 
static bool str name id gesture id picture id classes id env int id short id struct id view lambda int id class set bool manip phase bool classify bool ignoring id mousetool settable factory method enables gesture handlers application 
provides simple method application provide interfaces gesture 
gesture handler ignore events 
application gesture event handlers 
typically remaining event handlers provide traditional click drag interface application 

gesture event handlers particular handler turned setting ignoring instance variable ignore message 
grandma compare say completely different ges tural interfaces application switching runtime turning appropriate handlers instance variable name name gesture handler 
handler named canbe saved gesture classes semantics examples file 
obviously necessary avoid having user enter examples gesture class time application 
name passed passive method creates passive gesture handler 
passive str name file lambda self super passive classes new self self new mousetool self new self new self name name classify self openfile null self read return self typical gesture handler activates response mouse handles mouse events deactivates mouse button released 
course kind generic event handler default behavior easily overridden done discussed section 
default gesture event handler plans classify gestures directed classify 
changed gesture event handlers collect gestures training handlers 
default meaning milliseconds tenths second 
isthe duration mouse input cease mouse remain gesture recognized 
user may change default affecting gesture event handler 
interval may changed handler basis feature useful mainly comparing feel different intervals event satisfies handler start predicate handler activates called 

gamma gesture gesture new chapter 
gesture recognizers grandma picture create view hang picture loc loc env env new env str gesture value gesture env str value copy env str value copy env str handler value self manip phase active rec self sel selector wall activate wall timeout classify class set set new struct lambda malloc lambda sizeof struct wall handlers raise instigator self event env env new str event value return self passive handler allocates new gesture object sent input events 
initial event sent immediately 
picture allows gesture handler ink gesture display class pictures displayed drawn normal class requires pictures completed 
env variable holds environment gesture semantics executed environment interpreter variables gesture handler bound appropriately see section boolean manip phase true entire gesture collected manipulation phase see section 
created activated 
handler handler send arbitrary message timeout event parameter arbitrary object 
current case message sent active 
retrospect general functionality needed easily receive process directly overhead 

gesture event handlers code wall timeout causes wall raise input wall milliseconds 
zero disables raising 
previously mentioned gesture considered complete mouse button held long mouse moved milliseconds 
implement behavior gesture collected intended classified set possible gesture classes constructed set object allocated purpose 
recall section multiple views location start gesture accepts certain gestures 
array structures allocated associate possible gesture classes corresponding view 
raised instigator current gesture handler having current event additional field raising initiates search possible gesture classes 
recall sections view initial point considered top bottom view gestures associated directly view class superclasses added order 
note exactly search sequence find passive event handlers events active handler wants see section 
handled passive event handler mechanism correct order 
passive gesture handler handled initial event sends message gesture handler raised indicating set gesture classes recognizes view associated note views point gesture queried 
case gesture naturally expressed view targeted handled 
example desirable knob turning gesture go knob directly 
knob view area larger actual knob graphic insure starting point gesture knob view background view includes knob subview handle knob turning gesture 
case gesture semantics complicated background view needs explicitly determine knob gesture directed 
henry notes problem suggests gesture handler hand gesture progress handler determines initial point gesture misleading exactly unclear 

gamma bool event view classify jj ignoring return classify self env str view value instigator classes classes view return chapter 
gesture recognizers grandma return super event view overrides event view method check directly 
check included default start predicate require programs modify predicate include check unnecessary complication 
state ignoring switches checked handler operate turned 
reason classify checked allow gesture handlers gestures collect gesture examples training purposes operate gestures disabled system seen handler checks classifies gestures handled start event see section 
environment evaluating start predicate constructed event view bound handler asked handle initial event 
handler handled event set gesture classes associated handler view handler note special case needed handler raised handler receive respond propagate handlers 
propagation occurs simply event view method returns handle event 

gamma classes gesture classes view id seq gesture classes seq class set lambda added new element 
lambda view return self gesture handler handled initial event sends gesture handler handle initial event classes view message 
handler adds gestureclass class set 
gesture class previously associated passed view array 
membership test assures gesture class view initial point topmost view associated gesture class time finished propagating class set variable elements gesture classes objects initial event 
variable instigator associate gesture class view affected gesture entered turns class 

gesture event handlers search set valid gesture classes may relatively expensive especially area significant number views initial event view number event handlers associated 
substantial fraction second consumed search lower level window manager interface resulted increase recognition errors 
queried low level window manager software returns latest mouse event discarding intermediate mouse events occurred queried 
time interval second point gesture times larger subsequent pairs points 
importantly larger second points gesture examples train classifier 
details lost features initial angle significantly different 
substantial delay sampling second point gesture caused classifier degrade 
number possible solutions problem 
window manager software discard intermediate mouse events resulting similar data actual training gestures 
result large additional number mouse events processing costs making system appear sluggish user events processed fast arrived 
search gesture classes postponed gesture collected 
result substantial delay gesture collected making system appear sluggish user 
solution adopted poll manager raising 
interest clarity code polling shown 
running received input events rate training improving recognition performance considerably polling resulted new mouse events raised propagated 
result kind pseudo multi threaded operation typical problems arise concurrency possibility 
somewhat example explicitly deal possibility gesture seen set possible gesture classes calculated event handling methods reentrant 
omitted code shown tend program difficult understand gesture indicated timeout event resulting sent predicate satisfied message sent handler 
third alternative eager recognition chapter integrated grandma gesture handler tested non grandma applications see section 

gamma self gesture gesture self deactivate return nil gamma env str value copy chapter 
gesture recognizers grandma 
manip phase self gesture gesture return self methods result gesture message sent gesture 
gesture message returns nil gesture semantics evaluated manipulation phase 
checked method handler simply deactivates immediately 
typically gesture classes recognition semantics change mouse tool delete gesture changes mouse cursor toa delete tool timeout deactivates gesture handler immediately allowing mouse function tool long mouse button held code arranges deactivate message sent imme message need method explicitly send deactivate 
environment changed semantic expression evaluated deactivate method executes 
gesture method called handler gesture collection phase gesture indicated releasing mouse button timeout 

gamma deactivate id manip phase eval done expr env typeid return super deactivate gesture method sets field object 
done expression semantic expressions evaluated immediately gesture handler deactivated 

gamma bool event return ignoring super event gamma lambda new mouse point lambda env str value copy manip phase id lambda manipulation phase lambda eval manip expr env typeid lambda collection phase lambda int loc loc gesture lambda update feature vector lambda view picture line lambda ink lambda return self 
gesture event handlers activated functions just handle events ignoring flag set 
active event handler different things depending gesture handler inthe collection phase manipulation phase 
case current event location added gesture line connecting previous location current drawn 
case manipulation expression associated gesture second semantic expressions evaluated 

gamma gesture lambda called gesture collection phase complete lambda double id id classifier register struct lambda ga id class id manip phase wall timeout wall deactivate view picture lambda erase lambda picture discard picture nil lambda inform interested views training session lambda view selector gesture view gesture classify lambda find classifier set create necessary lambda classifier classifier class set lambda run classifier feature vector collected gesture lambda class classifier classify fv distance nil class nil jj jj maxdist return self reject lambda rejected lambda lambda find class gesture array lambda ga ga ga ga gamma class break ga return self error chapter 
gesture recognizers grandma lambda entry gives view gesture lambda lambda directed semantic expressions gesture lambda ga gamma env str view value ga gamma view env str value env eval recog expr env typeid manip expr nil val nil eval env typeid lambda raise event lambda ignoring mousetool tool mousetool wall raise done expr nil jj val nil return nil return self gesture method called entire gesture collected 
sets variable manip phase indicate handler manipulation phase gestural input cycle deactivates timeout event handler erases gesture display 
view associated handler responds gesture sent message collected gesture 
mechanism example gestures collected training handler collects gesture sends view typically kind wallview devoted training gesture adds gestureclass trained 
typical case gesture classified 
classifier factory method named called find gesture classifier discriminated class set 
classifier method calculates caches 
lookup creation possibly done pseudo thread point gesture time lookup finds classifier cache worth additional complication loss modularity classifier creation code 
returned classifier classify gesture 
addition class probability classification ambiguous distance ofthe example gesture mean calculated class returned 
compared thresholds check possible rejection gesture see section 

gesture classification training elements array searched find gesture class classifier 
determines semantics recognized gesture view gesture directed 
field set object recognized gesture recognition expression semantic expressions evaluated environment view appropriately bound 
exists manipulation expression evaluated immediately evaluating 
manipulation expression current event assumption tool may wish operate view 
ignoring flag set active handler doesnot attempt handle event raise 
furthermore semantics gesture may changed current mouse tool 
tool field current event incorrect changed new tool event raised 
order gesture semantics wish change current mouse tool sending mousetool message tothe gesture handler directly wallview 

gamma mousetool mousetool mousetool mousetool return super mousetool mousetool gesture method returns nil manipulation done semantics recognized gesture class 
seen signal handler deactivated immediately gesture recognized 
gesture classification training section implementation classes support gesture classification chapter discussed 
lowest level class gesture 
gesture object represents single gesture 
objects created manipulated normal gesture recognition occurs application gesture classes training classifiers 
class gesture internally gesture object array points consisting time coordinate instance variable gestureclass object example gesture non example specified training 
intermediate values calculation example feature vector feature vector stored 
arbitrary text may associated gesture object 
brevity detailed listing code gesture class avoided 
interesting part feature vector calculation specified detail chapter code chapter 
gesture recognizers grandma shown appendix listing code explanation message respond 
new gesture allocated initialized gesture new 
adding point objects done sending message simply results call loc loc time 
method adds new point list points incrementally calculates various components feature vector see section 
call fv returns vector 
methods class class text text respectively set get class text instance variables gesture object dump file save file stream pointer file initialize file dump read 
save numberof gesture objects may dump sequentially single file read back time read 
examples gesture class stored single file 
call contains returns boolean value indicating gesture connecting point point contains point 
useful testing example view encircled gesture enabling gesture indicate scope command 
algorithm testing point gesture described atthe section class gestureclass class gestureclass represents gesture class 
gesture class simply set presumably alike considered purposes classification 
input gesture classifier training method set gestureclass objects result gesture gestureclass object 
gestureclass id examples vector sum average matrix int state str text gestureclass subclass subclass model 
model views enabling new gesture classes created manipulated runtime 
please confuse gestureclass objects gestureclass serves represent class gestures handles input 
augments capabilities model adding functions facilitate reading model file 
models read way cached model asked input read 
important gesture class objects object may constituent different classifiers necessary classifier recognizing particular class refer gestureclass object 

gesture classification training gestureclass instance variable examples set examples 
field sum vector sum feature vectors example class average sum divided number examples 
covariance matrix class may dividing matrix number examples 
classifiers slightly efficient matrices covariance matrices see chapter 
code calculate matrices incrementally shown appendix state instance variable set bit fields indicating average date 
text field allows arbitrary text string associated gesture class method adds gesture set examples gesture class incre mentally updating sum field 
method deletes passed class updating sum accordingly 
examples method returns set examples class average returns estimated mean feature vector examples inthis class returns number examples returns unnormalized estimated covariance matrix 
class id id recog manip done objects named models enabling referred reading writing disk automatically cached read 
purpose objects associate gesture class set semantics 
separate class gestureclass may set semantics associated 
addition methods setting getting field methods reading objects disk 
uses objective read write semantic expressions recog manip done 
availability filer advantage objective 
typical interpreter substantial amount coding required read write intermediate tree form program disk files 
filer allows writing disk having pointers strings ids instance variables save interpreter expressions disk 
semantics disk file contains gestureclass object referred 
reading name read associated gestureclass 
gestureclass gestureclass object distinct gesture class 
chapter 
gesture recognizers grandma class classifier classifier class encapsulates basic gesture recognition capabilities grandma classifier object set gesture classes discriminates 
classifier object contains linear evaluation function class chapter inverse average covariance matrix calculate discrimination functions calculate mahalanobis distance gesture classes gesture example gesture classes 
classifier object id int nfeatures vector lambda lambda discrimination functions lambda matrix int classifier classes returns classifier discriminates tween gesture classes passed collection classes 
method caches classifier objects creates subsequently passed set gesture seen returns classifier set having recompute 
search existing classifier set gestures facilitated calculated xoring object ids particular set 
necessary method creates new classifier object instance variable sends train message 
implements training algorithm chapter 
gamma train register int int denom id seq register matrix vector avg double det lambda eliminate gesture classes examples lambda self lambda calculate average covariance matrix unnormalized covariance matrices gesture classes 
lambda nfeatures nfeatures seq seq denom gamma 
gesture classification training nfeatures nfeatures denom self error examples nfeatures nfeatures denom lambda invert average covariance matrix lambda nfeatures nfeatures det det self lambda calculate discrimination functions weight jth feature ith class 
constant term ith class 
lambda allocate vector avg average lambda avg lambda lambda nfeatures avg gamma lambda avg method removes gesture classes set examples 
estimated average covariance matrix computed attempt invert 
singular method called creates covariance matrix described section 
code fixing classifier shown appendix inverse covariance matrix discrimination functions class calculated specified section 
weights features class computed inverse average covariance matrix average feature vector class constant term computed negative half weights applied class average 
gives optimal classifiers assumptions classes equally misclassifications classes equal cost assumed multivariate normality chapter 
gesture recognizers grandma common covariance matrix 
classifier class provides class allows constant terms class adjusted application desires 
call classifier classes causes classifier objects gestures includes gestures set classes retrained sending message 
useful training examples added deleted classifiers depending class recalculated 
generally classifier may quarter second section presents training times detail 
classifying example gesture done classify distance method 
method passed feature vector example gesture evaluates discrimination function class choosing maximum 
desired probability unambiguous mahalanobis distance example gesture calculated class computed allow callers classification method options choose 
gamma classify vector fv double lambda ap distance double lambda dp double disc register int double denom exp id class disc fv disc disc class ap lambda calculate probability non gamma ambiguity lambda denom denom exp disc gamma disc lambda ap denom dp lambda calculate distance mean chosen class lambda lambda dp class fv fv return class 
manipulating gesture event handlers runtime classifier objects respond numerous messages mentioned 
causes example gestures class classified recognition rate classifier may estimated 
course procedure testing classifier examples itwas trained results evaluation useful 
sending particular gesture classes examples text messages result evaluation fed backto user see examples class classified incorrectly 
high rate misclassification usually points ambiguity indicating poor design set gestures tobe recognized 
ambiguity typically fixed modifying gesture examples gesture classes 
incorrectly classified examples indicate gesture designer classes need revised 
classifier objects respond messages save restore classifiers files aswell messages cause internal state classifier printed terminal debugging purposes matrix mahalanobis distances class pairs printed gesture designer get measure confusable set gestures 
manipulating gesture event handlers runtime goal provide platform allows experimentation different application 
grandma designed allow gesture recognizers manipulated runtime 
gesture classes may added deleted training examples may added deleted semantics gesture class respect particular handler may specified runtime 
addition gestures particular gesture may turned runtime allowing example easy comparison gesture click drag interfaces application program 
section discusses grandma presents user facilitates manipulation gesture handlers runtime view class implements method 
sent creates new window exist shown 
top row set pull menus 
subsequent row lists passive event handlers view class superclass class hierarchy view class 
event handlers order queried events top bottom row left right 
mouse mode menu item controls mouse cursor currently active window normal mouse indicated arrow user able drag individual event handler boxes rearrange order 
mode edit handler discussed shortly 
may dragged trash box case removed list handler associated view view class 
handler may dragged dock remain visible handler lists different view accessed 
handler dragged dock reappears original list dock allows event handlers different objects different classes 
create handler menu item results pull menu classes respond message 
runtime new handlers may created associated view object class 
example drag handler may created attached object chapter 
gesture recognizers grandma ad ab create handler view mouse mode passive event handler lists dragged mouse 
new gesture handlers may created way mouse cursor edit handler may clicked passive event handler 
results new window created shows details particular edit handler 
shows window typical gesture handler 
top left window mouse mode pull menu wishes examine handlers views window 
right name event handler constructed concatenating class handler internal address rows show objects starting predicate stopping predicate gesture handler 
item predicate display button shows pop menu simple matter change predicates runtime example start predicate may changed matching matching 
kind tool expected may changed runtime attributes ofthe tool particular mouse button may specified 
desired entire predicate expression may replaced completely new expression 
cases changes take effect immediately window contents far discussed common 
ones particular 
set buttons new class train evaluate save 
squares representing gesture handler 
square miniaturized example gesture text associated class small rectangle names class 
text typically shows result ofthe evaluation particular gesture recognizer set classes run examples train 
small rectangles may dragged copied dock 
particular gesture class 
rectangles dock remain gesture handler edited 
may dragged gesture class square existing class 
typically rectangle dock dragged empty class square created new class button way multiple gesture handlers recognize class clicking gesture class squares class name rectangle brings 
manipulating gesture event handlers runtime wrong trash dock gc ok gc ok ok gc ok gc ok gc gc ok ok gc gc ok new class gc gc ok mousetool mouse mode start handle gesture event handler normal delete semantics delete window examples gesture class 
chapter 
gesture recognizers grandma window example gestures shown 
square window contains single miniaturized example gesture class 
examples training classifier 
new example may added simply gesturing window 
example may deleted delete button left changes mouse cursor delete cursor clicking example 
user wishing change gesture liking delete examples class easily done delete button enter new example gestures 
train button cause new classifier built evaluate button cause examples run newly built classifier 
incorrectly classified examples indicated displaying mistaken class name example square examine example see malformed ambiguous 
semantics button window examples causes semantics gesture class tobe displayed 
subject section 
gesture semantics grandma contains simple objective interpreter allows semantics gestures runtime 
grandma semantics gesture determined program fragments gesture class handler 
program fragment labeled recog gesture recognized particular class 
second fragment manip input event handled activated gesture handler gesture recognized 
third fragment done executed just handler deactivates 
sequence executions described detail section section concerned contents specification program fragments 
gesture semantics code mentioned semantics gesture defined expressions recog manip done 
kinds expressions practice may loosely grouped level ofthe grandma system access 
semantic expressions deal directly models directly application objects typically easiest code understand 
example gscore application discussed section sharp gesture 
gscore editor musical scores 
gscore making gesture note score causes note indicated musical notation placing sharp sign note 
class note model application methods acc sets accidental note flat natural sharp 
sharp gesture performed making semantics recog view model acc sharp manip nil done nil semantics note object model object directly sent acc message sharp gesture recognized 
model changes internal state 
gesture semantics reflect new accidental calls self modified eventually result updated add sharp note 
note semantic expressions evaluated context certain names bound 
example obviously view sharp bound code 
section described creates environment view bound view gesture directed initial event gesture bound event gesture event just gesture classified bound event typically manipulation phase 
particular application may globally bind application specific symbols sharp example order facilitate semantic expressions 
dealing directly model semantics gesture may send messages view object 
score editor example delete gesture handler associated semantics recog view delete manip nil done nil actual semantics slightly complicated change mouse cursor see section details 
delete method typical view just sends delete doing housekeeping 
semantic expressions gesture invoked messages models views seen far typical different kinds event handlers 
thing event handlers see particular section raise events 
reasons handler 
raises events order view dragged considered virtual tool 
mentioned previously handler raise events order simulate 
example imagine responds raising tool current simulate mouse sensor frame 
main purposes having active event handler list list passive events handlers associated view allow flexibility 
smalltalk mvc system pairing single controller view really constrains view deal single kind input mouse input 
grandma view number different event handlers may able deal different input devices methods grandma gesture applications typically written debugged traditional menu driven click drag direct manipulation interface 
gestures top existing structure level gesture semantics may written 
level gesture semantics emulate example mouse input give behavior 
words gesture translated click drag interaction gives desired result example score editor placement note score 
drag interface adding note score involves dragging note appropriate duration chapter 
gesture recognizers grandma palette notes desired location musical staff 
implemented having virtual tool sends message objects respond 
note dragged raises event tool processed handler note gesture interface gesture class possible note duration recognized handler associated class 
semantics gesture gives eighth note recog manip nil done nil symbol bound view notes palette moved starting location gesture 
ended gesture copied tool field set copy note view andthe resulting event raised 
moving note raising new event exactly effect simulate dragging note particular location 
note moved starting point gesture necessarily gesture handler invoked 
handle event location note view determine pitch location score 
possible semantics simulate mouse clicked note palette dragged appropriate place staff 
case done needlessly complex 
point due grandma input architecture writer gesture semantics address system levels abstraction simulated input directly dealing application objects example semantics seen far recog expressions evaluated recognition time 
example implements semantics gesture line allows line illustrates manip recog view endpoint manip recog endpoint done nil example view assumed background view typically wallview drawing editor program section discusses gdp gesture drawing editor 
sending message results new line created window endpoint start gesture 
endpoint line moves mouse gesture recognized effect manip expression 
note recog variable hold newly created line object 
desired semantics programmer may create communicate different semantic expressions 
user interface grandma allows specification gesture semantics done runtime 
semantics specified runtime facility hardwiring 
gesture semantics semantic expressions gesture application 
currently semantics gestureclass read file examples gesture class time application started 
semantics gesture may created modified user interface section 
gesture semantics currently specified limited set expressions 
expression constant expression integer string variable assignment message send 
expression obvious effect constant evaluates variable evaluates current environment assignment evaluates evaluation right hand side side effect setting variable left hand side message send receiver expression argument expression sends specified message resulting arguments receiver 
value message expression value receiver returns 
programming convenience integer string objects converted needed types arguments receiver message send match expected selector 
shows window activated semantics button gesture class pressed top window row buttons creation various kinds expressions 
follows new message new message button creates template message send slot message selector 
expression may dragged receiver rec slot 
clicking selector box causes dialogue box displayed 
users browse class hierarchy find message selector desire selected 
buttons may factory instance methods 
starting point browsing set class receiver determined 
selector slot argument expected selector shown 
expression may dragged argument slots 
particular gesture attributes see 
new int button creates box integer may typed 
new string button creates box string may typed 
new variable button creates template value 
assigning variable name variable may typed 
expression may dragged value slot 
entire assignment expression may dragged sign 
attempting variable name left hand side copies variable name allowing dragged resulting expression simply name variable may value variable needed 
factory button generates constant expression object identifier class known factory 
pressing button pops browser allows user walk class hierarchy select desired class 
chapter 
gesture recognizers grandma manip dock recog seq cy cx mousetool rect bm mousetool handler recog trash value done new message trace int interpreter window editing gesture semantics 
gesture semantics superclass type choose selector selector subclass move ok fx fy edit delete edit point moved cancel move rec selector 
view selector empty message selector browser chapter 
gesture recognizers grandma back cancel cancel attribute duration enclosed gesture view wall handler move view arg 
arg 
pathlength sharpness height width attributes gesture semantics 

gesture semantics attribute clicking button generates menu useful subexpressions semantics 
shows pages attributes 
expressions variable names named messages 
expressions named messages variable names angle brackets small box name 
clicking box reveals underlying expression name refers 
note angle brackets shown list attributes appear attribute selected 
contains examples attributes 
attributes list refer characteristics current gesture gesture semantics evaluated 
attributes refer current view wall event handler events set objects enclosed gesture 
examples gesture semantics covered chapter 
having attributes gesture available writing semantics gesture central idea idea thesis 
idea meaning gesture may depend classification features particular instanceof gesture 
example drawing program simple matter tie length line gesture thickness resulting line 
addition gesture endpoint line example gesture attributes useful gesture semantics 
cursor button displays menu available cursors 
cursors consists icon read file tool sends 
cursors useful example semantic expressions wish provide feedback user changing cursor gesture 
trace button turns tracing interpreter evaluation loop prints expressions subexpressions evaluated 
helps writer gesture semantics debug code 
middle mouse button brings menu useful operations 
normal restores default cursor drags expressions 
copy changes cursor copy cursor drag expressions causes copied 
hide hides semantics window large typically obscures application window 
various remaining editing commands useful examining event handlers associated various objects userinterface really general interest writer gesture semantics 
interest attempted add gestural interface interpreter expression dragged dock slot remains gesture class changed 
dock provides useful mechanism sharing code different gesture classes gesture class different handlers 
expression dragged trash course deleted described interface semantics usually slower straightforward textual interface 
straightforward textual interface require parser simpler better current click drag interface 
hand chapter 
gesture recognizers grandma click drag interface possible syntax error 
main reason built exercise facilities grandma system 
project began author suspected click drag interface programming language awkward surprised 
consider possibility building gesture interface interpreter significantly efficient drag interface 
possible time add gesture interface interpreter recompiling date author attempt 
interpreter implementation interpreter internals implemented straightforward manner 
class subclass model subclass type expression discussed 
objects fields hold respective subexpressions objects fields constant object name variable respectively 
expression evaluation expressions evaluated environment simply association names objects 
evaluating objects done looking variable returning value objects evaluated adding modifying environment associate named variable value 
addition passed expression evaluated global environment 
name passed environment looked global environment interpreter number types deal 
type represented subclass class type 
instance subclasses value type 
type classes typeid 
typeid represents arbitrary objective object represent corresponding type 
consider implementation type int int initialize super register int super register long set int int return super new set int void lambda result void lambda lambda int lambda return void lambda return self set int lambda int lambda gamma set int int int return self gamma int return int gamma short return short int gamma char return char int gamma unsigned return unsigned int 
gesture semantics gamma str str sprintf int return gamma int plus int return int gamma int minus int return int gamma gamma int times int return int lambda gamma int int return self error division zero int gamma int mod int return self error mod zero int gamma int clip int int return int int int gamma int times int plus int return int lambda initialize method declares type represents types int long 
information reading files objective compiler writes describe return types message selectors 
sample line files id int int line says method implemented view example takes arguments returns id object 
objective type signature classes provide corresponding methods 
interpreter reads line creates selector object records fact expects second argument returns typeid 
selector object selector evaluated arguments converted machine integers method invoked 
knowledge conversions embodied result methods 
intent freely convert values represented characters values represented objects 
int id set int call result sets rto 
conversely sets newly created object class int field note ability arithmetic embodied ability integer types string type 
evaluating expression node environment done calling eval eval expr env type id expr env type void lambda eval function takes argument expression object environment object pointer place put result 
eval function takes care printing tracing information necessary simply sends expr eval result message 
expression class responsible knowing evaluate able convert return value appropriate type interesting case evaluation expression id sel lambda selector object lambda id rec lambda unevaluated receiver object lambda chapter 
gesture recognizers grandma id arg lambda unevaluated arguments lambda gamma void lambda eval env rt result void lambda id id rec arg int int nargs sel nargs sel sel sel sel id sel eval rec env typeid rec nargs eval arg env sel arg msg rec sel arg arg arg arg arg rt lambda need convert lambda lambda id lambda lambda hack assumes id equal size lambda return return rt result pointer cheating going arguments sent receiver object stored array ids necessarily objects 
relies hardware code runs microvax ii pointers long integers short integers characters represented byte values passed functions sel variable selector object get number types return value selector 
eval called recursively evaluate receiver message result type necessarily typeid receiver message objective object 
argument expressions evaluated result stored arg array 
type returned result expected argument sent 
function msg low level message sending function lies heart objective passed receiver selector arguments returns sending message specified selector arguments specified receiver 
result converted correct type 
message selector known return thesame type desired conversion necessary value simply copied correct place 
returned value converted object invoking method known return type converted object desired return type result method 
typical case rt typeid conversions object significant 
reason passing return type eval having eval return object converting returned objects machine integers characters strings needed 
gesture semantics efficiency 
current scheme nested message expressions inner expression returns say integer expected argument type outer expression overhead converting intermediate result object immediately back integer note automatic conversion objects allows arithmetic done relatively 
example add coordinate view view plus view returns machine integer intended receiver plus message converted typeid object case instance 
plus method expects argument machine integer represent constant object converted machine integer result type argument 
plus method invoked returns machine integer may may converted object depending onthe context program fragment 
example specified efficiently gesture semantics plus view 
case conversions avoided rep resented object plus expects machine integer argument exactly returned view thing shown implementation garbage collection 
expression evaluation objects freely created discarded important released discarded 
current implementation interpreter point lax attitude management grandma 
interface implementation expression nodes subclasses model corresponding subclass display screen 
expression views act virtual tools tools act empty argument receiver slots trash 
implementing grandma exercise grandma facilities especially interesting covered detail 
control constructs control construct currently implemented seq allows list expressions tobe evaluated order 
seq turns implemented extra mechanism required creation seq class class methods simply returned argument seq object grandma primitive return return return return return chapter 
gesture recognizers grandma arguments evaluated order desired effect control constructs implemented easily need arose 
simple implementation technique subclasses classes right number arguments 
simplicity normal message expression display code display expressions new code new eval result methods desired effect 
attributes cursors important consideration allowing gesture semantics specified runtime exactly application programmer visible gesture semantics programmer 
number means application programmer feature available hinge making visible objects receivers relevant messages attributes lists provides way giving semantics writer easy access application objects features 
done creating expressions attribute 
grandma entries accessible gesture attributes features 
illustrative example attributes specified implemented consider handler enclosed 
handler attribute simply refers gesture handler currently executing 
enclosed attribute refers list view objects current gesture 
selecting enclosed attribute list results named message clicking box reveals message handler enclosed internally str handler lambda statement adds handler list attributes interpreter window declared value type 
value set evaluated 
lambda sel selector enclosed rec str enclosed lambda statement adds enclosed attribute list 
gesture semantics enclosed attribute result handler enclosed executed 
lambda added list interpreter attributes list handler enclosed respectively 
expressions evaluates objective object message records expected class object 

gesture semantics recorded class selector browser starting point choosing message sendto attribute 
handler attribute evaluated looking string handler environment 
section described environment semantic expressions evaluated initialized bind handler current event handler 
evaluating results enclosed message sent current handler 
gamma enclosed id seq int xmin ymin xmax ymax gesture xmin xmin ymin ymin xmax xmax ymax ymax wall xmin ymin xmax ymax seq seq 
gesture remove return interpreter evaluation enclosed attribute results call method method determines bounding box current gesture consults view database list views contained bound 
object polled see enclosed removed list 
list returned 
default implementation view class simply tests bounding box enclosed gesture 
test may overridden views rectangular views wish ensure edge entirely contained gesture 
view 
gamma bool int self calc new box box left box top box right box bottom return contains contains contains contains gesture class implements contains message tests point gesture 
current implementation closes gesture conceptually connecting point starting point counts number times line point point outside gesture crosses gesture 
odd number crossings indicates point enclosed gesture attributes similarly code tends simpler enclosed 
particular attributes feature discussed section tributes named messages implemented handler gesture corresponding index feature vector cursors added list cursors available semantic expressions simply sending public message 
application programmer create available chapter 
gesture recognizers grandma cursor prove useful semantics writer 
gesture subsystem grandma consists gesture event handler low level modules user interface allows modification gesture handlers gesture examples gesture classes interpreter evaluating semantics gestures 
ofthese parts discussed detail 
chapter demonstrates grandma build gesture applications 
chapter applications chapter discusses gesture applications built author 
gdp drawing editor drawing program dp 
second gscore editor musical scores 
third mdp implementation gdp drawing editor finger gestures 
gdp gscore written objective run dec microvax ii 
gesture applications built grandma system discussed chapters 
gestures single path gestures drawn mouse 
grandma window system interface written author 
runs different processors microvax ii sun ibm pc rt different andrew 
grandma runs microvax years system available author ran objective port grandma unix environment ran objective date done mdp written objective runs silicon graphics iris personal workstation 
mdp responds multiple finger gestures input sensor frame 
gscore mdp built top grandma 
reason functioning sensor frame attached mentioned iris objective compiler exists 
desirable interesting integrate sensor frame input multi path gesture recognition grandma see section 
gdp gdp gesture drawing program dp 
dp current mode determines meaning mouse clicks drawing window 
single letter keyboard commands popup menu may change current mode 
current mode bottom drawing window actions mouse buttons 
example current mode line left mouse button drawing vertical lines middle button arbitrary lines right button lines gravity 
dp commands cause dialogue boxes displayed useful changing chapter 
applications parameters current thickness lines current font text gesture handlers turned gdp loosely emulates dp 
current mode indicated cursor 
example line cursor displayed clicking mouse button window causes new line created endpoint fixed position mouse 
long mouse button held line follows mouse fashion 
user releases mouse button second endpoint line desired location dp gdp support sets multiple graphic objects may grouped subsequently function single object 
created set translated rotated copied unit 
set may include sets components allowing hierarchical construction drawings 
dp pack command creates new set objects selected user unpack command selected set object transformed back components 
gdp functions similarly selection method dp 
gdp attempt emulate aspect dp 
particular various treatments ofthe different mouse buttons supported 
features implemented doing tangential purpose author demonstrate 
unimplemented features conceptual problems implementation grandma author chose expend effort 
gdp gestural interface gdp gesture operation briefly described section 
expanded repeated 
figures show rectangle ellipse line pack gestures gdp window graphic objects 
class text gesture cursive dot gesture entered pressing mouse button subsequent 
text gesture causes text cursor displayed initial point gesture 
user may enter text keyboard 
dot gesture causes command indicated bythe current mode repeated 
example delete gesture dot gesture existing object cause object deleted figures show copy rotate delete gestures act directly graphic objects 
move gesture simple arrow similar 
gestures graphic object initial point gesture 
gestures recognized gdp window begun graphic object 
case cursor changed corresponding mode underlying dp interface takes 
particular dragging cursors graphic object causes corresponding operation occur 
gdp implementation gdp built top grandma implementation followed mvc paradigm shows position class hierarchy new classes defined gdp 

gdp gestures 
delete edit move copy rotate delete edit text copy pack dot gestures gdp period indicates start gesture 
ellipse model object gdp class hierarchy chapter 
applications models implementation gdp centers class subclass model 
drawing 
entire drawing implemented asa graphic object 
text objects objects lines rectangles ellipses objects implement set concept instance variables parent object member trans transformation matrix mapping object drawing 
member exactly set set represents drawing top level objects member set part drawing 
objects single instance variable thickness controls thick ness lines line drawing 
subclasses rectangle ellipse represent graphics drawing 
associated subclass list points specify sequence line segments object 
points list normalized significant point object lies origin significant point point 
lines endpoint 
point list rectangles specifies square corners 
ellipse represented line segments approximate circle center passes point 
transformation matrix map list points object drawing window coordinates 
object contains set objects set 
order display set transformation matrix set composed multiplied constituent objects 
composition happens recursively deeply nested objects displayed correctly 
text objects contain font text string displayed 
views immediate subclasses corresponding subclass 
object responsible displaying object model screen 
similarly objects display 
respond message order redraw 
simply asks model lists points proceeds connect lines 
model provides appropriate thickness lines 
note necessary provide view classes classes taken care 
draw models character time order accommodate model 
transformations unit scale factor shrinking dilation rotation component cause text drawn horizontally determined widths current font 
current implementation scaling rotation effect character size orientations rotate scale characters effect character positions 
views model component objects subviews 

gdp update method view automatically propagate update messages subviews method required class overrides move method view 
recall section method simply changes location view translating view dimensions method example drag handler section cause views move mouse cursor 
purpose overriding default method dragging model changed reflect new coordinates object drawing 
model changed sending message returns model matrix calling function modifies matrix reflect additional translation sending model message causes matrix recorded model 
course model sends modified message causes model view redraw model new location 
implements delete message sending free mes sage things removes parent subview list sending model delete message 
overrides default methods sections return objects top level drawing 
subclass implements invoked object top level 
outermost window view 
instance subclassof 
representing entire drawing 
event handlers gdp required addition new event handler generality incorporated standard set grandma event handlers 
purpose implement typical interaction 
example clicking line cursor drawing window causes new line created endpoint constrained location click endpoint stays attached cursor mouse button released 
produce behavior parameterizable starting predicate handling predicate stopping predicate section 
order activated tool activating event operate view handler attached section 
ifthe tool operates view event satisfies starting predicate handler activated 
activated tool allowed operate view operation expected object receiver subsequent messages 
example line tool operates drawing window view result newly created line object 
handler sends new object message parameters location coordinates 
actual message sent parameter passive event handler example message 
subsequent event handled results sent message containing coordinates event example 
chapter 
applications gestures gdp section describes addition gestures implementation described 
gesture classes example gestures gesture semantics added runtime allowing tested immediately 
admit cases necessary features directly existing code recompile 
partly due fact grandma gesture subsystem developed time application due gesture semantics wanting access models views methods ones provided reasons readability efficiency shows gesture classes recognized gdp gesture handlers 
note gestures expected subset expected allowing gesture class recognized multiple handlers allows semantics gesture depend view directed gestures line rect ellipse text cause graphic objects created 
gestures recognized top level view covers entire window 
example line gesture straight stroke line created endpoint gesture start second endpoint tracks mouse fashion semantics line gesture recog seq handler mousetool mousetool manip recog cx cy done expression assumed nil 
line gesture recognized handler sent mousetool message passing mousetool parameter 
handler sends message view wall cursor shape changes 
internally handler changes tool instance variable new tool 
line created message sent top view new line sent message endpoint starting point gesture 
identifiers enclosed angle brackets gestural attributes discussed section message seq expressions sequentially returns parameter case newly created line assigned recog subsequent mouse input manip expression evaluated 
sends newline referred recog message scale keeping center point location mapping endpoint 
semantics rect ellipse gestures similar line resultant cursor shape creation message sent 
start gesture controls corner rectangle subsequent mouse events control corner 
start ellipse gesture determines center ellipse mouse manipulates point ellipse 
rectangle created sides parallel window 
similarly ellipse created axes horizontal 
manipulations creation gestures recognized effect orientation created object 
single mouse position continuous control degrees 
gdp freedom impossible independently alter orientation angle size aspect ratio object 
design choice modify size aspect ratio creation gesture rotate gesture may subsequently modify orientation angle possible features gesture control additional attributes graphic object 
changing recog semantics line gesture recog seq handler mousetool thickness pathlength clip causes thickness line length gesture divided constrained pixels inclusive 
length gesture determines thickness created line subsequently continuously manipulated length 
dot gesture user simply presses mouse moving 
recognized gesture handler turns immediately enabling events propagate past allowing cursor displayed tool 
dp notion current mode accessible dot gesture 
pack gesture semantics recog seq handler mousetool pack mousetool pack list enclosed attribute enclosed alias handler enclosed 
recall section message returns list objects enclosed gesture 
list passed creates set 
long mouse button held pack tool pack message sent object touches objects execute parent pack self implementation pack method add current set copy move rotate edit delete gestures simply bring corresponding cursors aimed background view 
interesting semantics 
copy gesture example causes recog seq handler mousetool mousetool copy view move manip seq copy move minus minus illustrates gesture semantics mimic essential features section 
semantics move gesture identical copy 
simpler way kind thing events shown semantics ofthe gscore program discussed 
delete gesture semantics chapter 
applications gscore cursor menu recog seq handler mousetool delete mousetool view delete edit gesture semantics similar 
rotate gesture semantics recog nil manip seq handler mousetool rotate mousetool view cx cy message causes point view coordinate indicated keeping point indicated cx cy constant 
gesture drags endpoint graphic object 
better able drag arbitrary point done mdp discussed 
gscore gscore gesture musical score editor 
design particular program gesture set influenced sssp score editing tools ii score editor 
brief description interface gscore interfaces gesture 
shows non gesture interface action 
initially staff lines user 
user may call 
gscore gscore palette menu additional accessing staff tool cursors menu shown user displayed number palettes drag musical symbols staff 
seen user placed number symbols staff 
tie tool indicate phrases beam tool add beams connect notes tools clicking mouse starting note touching 
tie tool adds tie initial note touched beam tool beams notes touched interaction dragging note staff determines starting time follows note dragged approximately location note start time chord 
note begins time note rest just 
score objects positioned notes palettes accessed palette menu shown 
palettes may dragged convenient user 
button hides palette retrieved menu 
delete cursor deletes score events 
mouse button pressed dragging objects may deleted causes highlighted 
releasing button highlighted object causes deleted 
individual chord notes may deleted note heads entire chord clicking stem 
beam deleted notes revert state gestural interface provides alternative palette interface 
shows sets gestures recognized gscore objects 
largest set associated staff result note readers unfamiliar common music notation tie curved line connecting adjacent notes pitch 
tie indicates connected notes performed single note duration equals connected notes 
curved line adjacent differently pitched notes slur performed connecting second note intermediate breath break 
nonadjacent notes curved phrase mark indicates group notes musical phrase shown 
gscore tie tool enter ties phrase marks 
beam thick line connects stems see 
grouping multiple short notes beams serve emphasize metrical rhythmic structure music 
chapter 
applications 
key 
bar delete staff gestures nat sharp flat beam move note gestures score event gestures dot gscore gestures 
gscore staff events created 
gestures move delete operate events 
additional gestures manipulating notes 
gesture staff creates note rest clef bar line time signature key 
object created placed staff near initial point gesture 
notes coordinate determines starting time coordinate determines 
gesture class determines actual note duration note half note quarter note note sixteenth note note direction stem note gestures remaining staff gestures initial coordinate determine staff position created object 
rest gestures generate rests various durations 
gestures generate may dragged palette 
gesture generates time signature 
gesture recognized user controls time signature changes coordinate mouse denominator changes similarly key gesture recognized user controls number flats mouse 
bar gesture recognized bar line placed staff cursor changes bar cursor 
mouse button held newly created bar staff touched mouse cursor 
note specific gestures manipulate notes 
placed note flat natural gestures 
beam gesture causes notes 
note beam gesture begins notes beam extended touched gesture recognized 
gestures operate similarly 
dot gesture causes duration note typically dot added note 
note score event exists staff gesture begins note note specific sharp score event specific delete directed staff note gestures 
time gesture note gesture sets classifier created discriminate described section 
shows example session gscore 
design implementation shows classes defined gscore fit grandma class hierarchy 
model class created corresponding view class displaying 
new event handlers needed created gscore grandma existing ones proved adequate 
generally useful views new views general utility development gscore 
row buttons acti popup menu 
provides functionality similar macintosh menu bar 
implements palette objects copied dragged 
single section associates object palette 
drag handler sent message gives palette functionality 
chapter 
applications gscore shows blank staff gesture entered 
panel show created treble clef key key signature gesture 
recognition number flats manipulated bythe distance mouse moves staff staff respectively 
panel shows created key signature flat time signature gesture 
recognition horizontal distance fromthe recognition point determines numerator time signature vertical distance determines denominator 
panel shows resulting time signature quarter note gesture stroke 
note upward stem 
initial point gesture determines pitch note vertical position starting time note 
panel shows created note eighth note gesture 
quarter note gesture gesture class determines note duration gestural attributes determines note stem direction start time pitch 
panel shows sixteenth note gestures combining steps 
panel shows beam gesture 
gesture begins note gestures mentioned far staff 
gesture recognized user touches notes order beam 
panel shows notes flat gesture drawn note 
panel shows resulting added note eighth rest gesture drawn staff 
panel shows resulting rest delete gesture rest 
panel shows quarter note gesture drawn quarter note symbols gscore rectangular input regions result chord shown panel 

gscore object view dll accidental note rest model score beam chord tie staff gscore class hierarchy palette implement arbitrary action dragged objects dropped 
palettes score events notes rests special action taken 
copied view subview dragged staff 
modifiers dots triplets tools send messages objects takes care updating state creating duration modifiers needs 
copies dragged palette part ofthe score automatically deleted dropped 
gscore models exception new classes created implementation gscore specific score editing 
score object represents musical score 
contains list staff objects doubly linked list class dll 
time field indicating score begins list maintained time order subclass includes classes associated single staff may connect staff maintains set instance variable 
similarly chord may contain notes different may tie beam 
attached directly staff note beam responsibility mapping time coordinate staff rests mainly score object methods map coordinates times times coordinates respectively 
score method adding events list erase deleting erasing events 
erase kind soft delete object removed list score events deallocated way disturbed 
chapter 
applications typical erase object change time field add score time 
subclass implements message orders score occur simultaneously 
important determining position score events bar lines come come key signatures 
order events appear staff important maintain canonical ordering score events relied code particular classes straightforward implementations 
note contain pitch raw duration excluding duration modifiers actual duration stem direction back pointers chord beam contain pointers accidental objects apply 
messages setting maintains consistency dependent variables 
notes able delete gracefully removing beams chords participate deleting duration modifiers attached deleting score score events behave similarly 
sending time message changes start time results informed 
score takes care move correct place list events 
accomplished erasing event score adding internal representation scores editing quite interesting topic right tangential main topic gesture systems 
described detail implementation user interface gesture semantics appreciated 
described 
gscore views expected mvc paradigm view subclass corresponding 
provides backdrop 
surprisingly instances subviews 
surprisingly objects subviews 
simplicity various classes drawn 
simplifies screen update need traverse nested structure search objects need updating necessary view access related views example needs communicate objects 
views keeps pointers related views instance variables 
common mvc systems pointers views explicitly mimic relations 
task programmer keep pointers consistent model objects added deleted modified sense costs associated mvc paradigm 
reasons modularity mvc dictates views models separate models views indirectly model list dependents 
benefit models may written cleanly may multiple views 
unfortunately separation results best structure maintained pointers models pointers views inconsistency worse structures get sync 

gscore changes model relationship models requires parallel changes 
duplication noticed initial construction gscore contrary ideals object oriented programming techniques inheritance utilized toavoid duplication effort 
grandma attempts address problem mvc general way 
problem taboo prevents model explicitly referencing view 
grandma maintains taboo provides mechanism inquiring view model 
order possibility multiple views single model query sent context object context model view 
implementation requires context kind object view 
gamma lambda associates model lambda gamma lambda returns view associated lambda implementation done association list context context message associates view model context 
objective object uses hashing internally typically operates constant time independent number associations 
result kind inverted index mapping views 
gscore single context view model convenience parent objects 
longer keep consistent set pointers related objects 
example needs query model list note beam ask models view parent 
instance variable parent refers subview 
problem keeping parallel structures consistent eliminated 
drawback necessary maintain inverted index created deleted 
problem views access related views solved redisplay ing view straightforward 
recall section model modified sends modified message results dependents particular view get ting message 
default implementation sent view subviews section 
normally method directly responsible querying model graphics 
overrides task producing graphics score event relegated new method implemented subclasses 
sends additional discussed shortly example consider happens pitch note changed 
sent message changes pitch updates internal state sends modified message 
changing pitch result accidental objects deleted score possibility ignored 
note get sent query model score staff objects model chapter 
applications determine kind position note head stem direction needed 
head selected music font drawn staff lines necessary determined location 
reason sending test ina single place possibility view may moved time drawn 
particular coordinate right edge view bounding box changed score events repositioned 
score object sent message effect takes care changing position affected models reason extra step creating pictures recursive message attempts create picture currently created possibility certain cases 
adding deleting causes score object send 
doing creates record indicating exactly changed 
notified object request record creating deleting required uses association list associate view classes model classes send message appropriate factory 
function virtual tools performing action default overridden operate 
class handles 
version different discussed section associated class 
version kind parameterizable discussed earlier 
instance associated parameters set performs soon tool dragged view accepts action normal behavior providing immediate semantic feedback performing action dropped view 
action dragged immediately gets sent message tool parameter 
step erase score possible 
sends model score message parameter coordinate 
time returned time model added score 
subsequent drag event results message sent process repeated 
user drags score continuously updated drag immediately reflected display 
different actions operate similarly 
explain functionality inthe non gesture interface section discusses semantics gestural interface gscore 

gscore gscore gesture semantics gesture semantics rely heavily palette interface described 
palettes created view placed palette named accessible attributes button gesture semantics window see sections 
simple matter inthe gesture semantics simulate dragging copy view staff see section 
example consider semantics gesture creates eighth note stem recog name refers view eighth note stem placed program initialization 
view copied results model copied moved starting location gesture attribute attribute view tool location event location 
simulates actions guaranteed staff semantics executed effect place eighth note score 
similar semantics difference view copied note gestures rest gestures clef gestures 
semantics bar gesture similar note gestures difference thata mouse tool virtual view tool 
recog handler mousetool mousetool gesture creating time signatures interesting 
recognized mouse control numerator denominator time signature respectively recog seq sx sy manip recog model minus sx clip minus sy clip note recog expression similar view palette copied staff tool event 
manip expression contrast operate level simulated drags 
accesses model newly created directly sending message sets numerator 
division means mouse move pixels order change unit 
clip message ensures result inclusive 
probably better powers denominator unfortunately tothe message implemented simple 
chapter 
applications key signature gesture key works similarly coordinate control number key signature recog seq sy manip recog model sy minus clip minus positive value key signature indicates number negative negation number flats 
awkward minus author failed allow negative numbers new int button 
gestures recognized staff 
delete move gestures recognized 
semantics delete recog seq handler mousetool delete mousetool view delete changes cursor deletes view gesture began 
effect achieved code simpler move gesture simply restores normal cursor starting location gesture relying fact non gesture interface score events may mouse recog handler mousetool normal mousetool addition gestures apply recognizes 
gestures adding notes sharp flat natural access note object directly 
example semantics sharp gesture recog view model acc sharp beam gesture changes cursor beam cursor simulates clicking beam cursor initial point recog handler mousetool mousetool tie gestures implemented similarly 
variation semantics causes mouse cursor revert normal cursor mouse released gesture recog seq handler mousetool mousetool mousetool manip mousetool done seq mousetool handler mousetool normal mousetool 
mdp dot gesture accesses note raw duration multiplies changes result 
note add appropriate dot score receives new duration recog seq view model dur times manip recog manip recog statement virtue non nil gesture handler relinquish control mouse button released 
statement mouse cursor tool happens operate view dot gesture recognized 
mdp mdp gesture drawing program takes multi finger sensor frame gestures input primarily demonstration multi path gesture recognition mdp shows gestures incorporated cheaply quickly non object oriented system 
contrast merits requires great deal mechanism object oriented user interface toolkit appropriate hooks gestures incorporated user interface mdp similar gdp 
user gestures results various geometric objects created manipulated 
main differences due input devices 
addition classifying multiple finger gestures mdp uses multiple fingers manipulation phase 
allows example graphic object rotated translated simultaneously 
shows example mdp session 
note gesture recognized additional fingers may brought picture manipulate various parameters 
multiple finger tracking phase interaction power single path phase interaction 
internals shows internal architecture mdp 
lines indicate main data flow various modules 
gesture systems built grandma mdp started set training examples read file 
train multi path classifier described chapter 
mdp provides facility creating modifying 
separate program purpose 
sensor frame integrated window manager iris making input difficult handling mouse input 
particular coordinates returned sensor frame absolute screen coordinates arbitrary scale window expects window relative coordinates 
fortunately iris windowing system supports general coordinate transformations window basis mdp uses follows started mdp creates window screen reads alignment file determine coordinate transformation mapping window coordinates screen coordinates chapter 
applications example mdp consists snapshots video mdp session 
panels apparent 
panel shows single finger line gesture essentially gdp line gesture 
gdp start gesture gives endpoint line endpoint dragged gesturing finger gesture recognized 
additional fingers may control line color thickness 
panel shows created line rectangle gesture gdp 
gesture recognized additional fingers may brought sensing control rectangle color thickness filled property shown panel 
panel shows circle gesture works analogously 
panel shows finger parallelogram gesture 
recognized gesturing fingers control corners 
additional finger 
mdp fig continued sensing plane control third corner allowing arbitrary parallelogram entered panel shows edit color gesture newly created parallelogram 
gesture recognized parallelogram color filled property may dynamically manipulated 
panel finger pack group gesture 
pack interaction object touched fingers grouped single set 
line rectangle circle grouped cart 
panel shows copy gesture 
gesture recognized object indicated point gesture case cart dragged gesturing finger shown panel 
additional color edge thicknesses filled property copy manipulated shown panel 
circle rectangle gestures shown create additional shapes 
panel shows finger rotate gesture 
recognized fingers attached respective points touched designated object 
moving fingers apart rotating hand moving hand object may simultaneously scaled rotated translated shown panel 
fingers touching object due delay getting input data screen 
panel shows delete gesture delete rectangle 
shown deletion creation gestures leaving drawing state shown panel 
panel finger undo gesture 
recognition creation deletion undone 
moving fingers causes operations undone moving fingers allows redone interactively 
panel shows state interaction operations undone 
implementation creations deletions position changes 
explains panel cart items remain undo back panel items position assumed panel 
chapter 
applications single path classifier multi path classifier decision read training examples receive data action routines action table window graphics output graphics state calculate features sensor frame input mdp internal structure 
mdp window coordinate system identical sensor frame coordinate system 
position seen indicated alignment file user forced go alignment dialogue proceeding occurs window resized 
dots displayed corner window user asked touch dot 
data read window coordinates exactly match sensor 
transformation window coordinates screen coordinates done iris software considered rest program 
parameters alignment file avoid having repeat procedure time mdp started initialized mdp begins read data sensor frame 
current sensor works polling typically returns data rate approximately snapshots second 
receive data module performs path tracking see section records consisting current time number fingers seen frame tuples finger finger location frame 
path identifier path tracker 
intent value represents finger successive snapshots normally mdp wait state polling indicates fingers frame 
fingers enter field view frame collect entered 
successive snapshot passed calculate features module performs incremental feature calculation 
collect state ends user removes fingers fromthe frame stops moving milliseconds 
timeout interval settable user milliseconds 
mouse user difficult frame users hold fingers perfectly threshold decide user moved 
words threshold determines amount movement successive snapshots count moving 
done comparing threshold error metric calculated path tracking sum squared distances points successive snapshots 
gesture collected feature vectors passed multi path classifier returns gesture class 
recognition action associated class looked action table executed 
long finger remains field view action class executed 
grandma ideas specifying gesture semantics mdp 
full blown interpreter table specifying recognition action manipulation action class 
possible tables constructed currently table compiled mdp 
row entry class consists finger specification name function call execute row constant pass function 
finger specification determines finger coordinates pass additional arguments function consider table entries mdp line gesture similar gdp line gesture action int line moving resizing window requires alignment procedure repeated problem course fixed production version program 
chapter 
applications start action action current current current line gesture recognized action executed 
line results inthe call line executed 
means row particular finger finger coordinates passed 
line results called initial point finger gesture 
snapshot line gesture recognized action 
line causes called location finger finger 
line causes called current location second finger 
similarly third line causes called fingers named line action field view frame line ignored 
example line gesture mdp gdp single 
immediately recognition finger seen frame finger zero lines current current executed 
inserted current current lines snapshot 
initial finger removed current line longer executed finger placed assignment finger numbers done follows gesture recognized finger assigned index path sorting see section 
manipulation phase finger removed number freed numbers remaining fingers stay 
finger enters assigned smallest free number semantic routines communicate shared variables 
functions defined single file shared variables declared top 
fingers call function initialize shared variables 
mdp shared variables initialized follows interface modeless 
system state retained calls example current selection maintained way functions manipulate drawing elements package routines 
implementation routines similar implementation gdp objects 
go detail underlying routines summarized 
mdp declares types typedef enum line rect circle type 
mdp typedef struct lambda 
lambda lambda element typedef struct lambda 
lambda lambda trans assume declarations purposes element lambda graphic object lambda type type lambda type graphic object lambda int lambda coordinates lambda int lambda point number lambda int thickness color bool trans tr lambda transformation matrix lambda element pointer structure representing element drawing line rect circle 
element structure includes array element types need 
line points endpoints rect points representing corners rect parallelogram circle points center point circle 
contains list component elements single composite element 
element type adds new element passed type drawing handle 
initially points element marked uninitialized 
element uninitialized points drawn exception rect objects drawn parallel axes point uninitialized 
changes point element 
returns point sets point element returns false iff point point uninitialized 
deletes object drawing 
object filled true unfilled 
circles rectangles borders drawn unfilled colored 
sets thickness borders applies circles rectangles lines 
color changes color color index standard colormap 
set members changed 
tr applies transformation tr general tr cause transla tions rotations scalings combination 
void special case translates vector 
chapter 
applications adds identical copy drawing returned 
isa set elements recursively copied 
returns element drawing point null 
topmost element returned elements created top elements created earlier 
thickness filled ness element considered determining element 
turns highlighting true 
highlighting implemented blinking object 
turns highlighting objects drawing 
void draws entire picture display 
double buffering changes 
saves current state drawing restored 
changes drawing previously checkpointed state true 
call true returns previous state picture state picture program started reached 
false performs redo undoing effect true 
successive calls false eventually restore drawing latest checkpointed state 
trans allocates transformation initialized identity transforma tion 
tr sets tr transformation con rotation followed scaling followed translation net effect map line segment endpoints points 
transformation creation functions exist directly gesture semantics 
color text draws passed text string screen passed color atthe point 
text erased call 
mdp gestures semantics basic primitives mdp described actual gestures implementation discussed 
shows typical examples mdp gestures 
described turn 
line line gesture creates line endpoint start gesture finger gesture recognized 
finger brought gesture recognized controls thickness line follows point 
mdp line rectangle circle edit color delete copy move parallelogram undo pack rotate mdp gestures finger enters displayed screen thickness line difference coordinate finger current point initial point 
finger controls color line similar manner 
color represented simply index color map 
action table entry line listed previous section 
listed arg arg true arg gx gy arg gx gy arg gx gy int tx gamma tx gx ty gy return arg abs tx gamma gx abs ty gamma gy scale red tx ty arg tx ty chapter 
applications red gx gy arg gx gy int color fill return gamma gx gy fill scale gamma gx gamma fill color scale gamma gy gamma color color gamma color color color color green cf color fill green gx gy cf scale num den low high int lambda num int den gamma gamma den return low low high high function sets null sets tx ty 
calls true false 
functions provide feedback user text tx cf respectively indicates location finger entered 
lower case text cf drawn appropriate fingers indicating user finger controlling parameter 
rectangle rectangle gesture works similarly line gesture 
gesture recog rectangle created corner starting point gesture opposite corner tracking finger 
fingers control thickness color line gesture finger controls rectangle filled left initially entered rectangle filled 
action int rect start action action current current current action 
mdp circle circle gesture causes circle created starting point gesture point circle controlled finger 
fingers operate rectangle gesture 
semantics circle gesture identical shown 
edit color gesture lets user edit color filled ness existing object 
gesture object edits object 
user moves finger touches object edit 
selected finger determines color fill properties finger previous gestures 
action start action action current current action arg gx gy gx gy px gx py gy arg gx gy arg gx gy copy copy gesture picks element copied manner edit color 
copied finger drags new copy finger adjust color thickness copy 
action start action action current current current current action interest brevity routines longer listed similar seen 
chapter 
applications move move finger gesture 
object picked previous gestures tracks finger 
action start action action current current action delete delete gesture picks object just previous gestures deletes action start action action current current action parallelogram parallelogram gesture finger gesture 
corner determined initial location fingers adjacent corner tracks finger opposite corner tracks finger 
adding third finger finger moves initial point 
action int rect start action action current current current action rotate rotate finger gesture 
object picked finger 
time finger attached point picked object 
finger drags respective point object rotated rotating fingers scaled moving apart translated moving fingers parallel 
action start start action 
mdp action current current current current action pack pack gesture finger gesture 
objects touched fingers newly created 
action action action current current current action undo undo gesture finger gesture basically parallel 
recognized moving finger causes edits undone moving finger causes edits redone 
action current action action current action discussion mdp system known author uses non dataglove multiple finger gestures brief discussion gestures warranted 
mdp single finger gestures taken directly gdp 
recognition additional brought sensing plane control additional parameters 
additional finger brought sensing plane position gives current value ofthe parameter finger controls position finger relative initial position determines new value parameter 
relative control felt author possible schemes course needs studied thoroughly 
chapter 
applications multiple finger gestures designed intuitive 
parallelogram gesture forexample fingers making rectangle gesture parallel 
move gesture meant pinch object touched grabbed dragged 
finger allows distinct points object selected carefully 
manipulation phase points tracks finger allowing intuitive translation rotation object 
finger undo gesture intended simulate eraser blackboard sensor frame perfect device gestural input 
problem sensor frame sensing plane slightly surface screen 
difficult precisely pull changing position 
results parameters carefully adjusted manipulation phase interaction changed accidentally interaction ends problem happens multiple finger gestures due problems sensor frame removing finger may change reported position fingers moved 
difficult pull finger carefully fingers kept sensing plane 
take long arm sensor frame attached vertically mounted display 
mdp phase interaction technique applied context multiple fingers 
finger position represents degrees freedom multi path interactions allow parameters manipulated single path interactions 
people finger multiple fingers potentially allows natural gestures 
fingers enter recognized part gesture additional fingers utilized manipulation phase 
result new interaction technique needs studied 
chapter described major applications built demonstrate ideas 
gdp gscore built top grandma show single path gestures may integrated mvc applications 
third mdp demonstrates path gestures shows gestures may integrated quick dirty fashion non objected oriented context 
chapter evaluation previous chapters report algorithms systems construction gesture applications 
chapter attempts evaluate algorithms systems 
possible quantitative evaluations 
subjective anecdotal evidence 
basic single path recognition chapter presents algorithm classifying single path gestures 
section algorithm measured variety ways 
recognition rate classifier measured function number classes number training examples 
gestures misclassified various sources errors uncovered 
effect rejection parameters classifier performance studied 
classifier number different gesture sets 
tests determine classifier trained person recognizes gestures 
recognition rate recognition rate classifier fraction example inputs correctly classifies 
recognition rates number classifiers trained algorithm chapter measured 
gesture classes drawn gscore section 
reasons testing set gestures discussed dissertation 
consists fairly large set gestures real application 
second gscore development debugging classification software unbiased respect grandma provides facility examples train classifier classified classifier 
running training examples classifier useful gestures determining approximately classifier expected perform way measure recognition rates 
trainable classifier recognizing training examples correctly 
tests described set chapter 
evaluation 
bar key nat sharp dot flat 
beam gscore gesture classes evaluation example gestures train classifier entirely distinct set examples evaluate performance 
shows examples gesture classes test 
entered mouse computer system described chapter 
examples class entered formed training set 
author entered examples ofeach class formed testing set 
sets special attempt gesture carefully obviously poor examples eliminated classification test examples entered words feedback provided correctness example immediately entered 
user tend adapt system improve recognition input 
test designed eliminate effect adaptation recognition rate performance statistical gesture recognizer depends number factors 
chief number classes discriminated number class 
effect number classes studied building recognizers subset classes 
experiment class size refers classifier attempts classes 
similarly effect training set size studied varying number examples class 
value means trained examples training data classes 
plots recognition rate number classes various training set 
point result classifying examples classes testing set 
number correct classifications divided total number classifications attempted give recognition rate 
rejection turned experiment 
shows results experiment plotted recognition rate versus various values 
basic single path recognition correct number classes examples examples examples examples theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta examples examples recognition rate vs number classes correct training examples class classes classes classes classes theta theta theta theta theta theta theta theta theta theta classes classes recognition rate vs training set size chapter 
evaluation general data surprising 
expected recognition rate increases training set size increases decreases number classes increases 
classes examples class recognition rate 
rate 
gives rate rate practical significance grandma users number training examples needed give results 
examples class gives results large number 
recognition rate marginally improved examples class significant improvement occurs 
results poor performance classes 
know grandma system designed allow experimentation gesture interfaces performs examples class 
trainable classifiers require hundreds thousands examples class precluding casual experimentation 
analysis errors enlightening examine test examples misclassified experiments shows examples kinds misclassifications classifier 
misclassification shown representative label indicates example labeled class set classified classifier 
indicates number times classified types errors observed 
misclassifications result combination types 
poorly drawn gestures 
mistakes simply result bad drawing part ofthe user 
may due awkwardness mouse draw 
examples include sharp delete 
dot due accidental mouse click delete mouse button released prematurely 
example key delete error caused mouse ball properly table 
delete extraneous points gesture outside range normally eliminated preprocessing drawn corner stroke looped causes accumulated angle features far expected value see section 
poor mouse tracking 
errors due poor tracking mouse 
typically long time mouse point gesture second 
occurs mouse point causes system page process collecting gesture take substantial amount time 
underlying window manager interface queues mouse event involving press release button queue movement events choosing keep 
mouse movements missed process paged 

basic single path recognition delete delete delete nat 

sharp 
delete key delete key 
beam 
move dot 
delete misclassified gscore gestures chapter 
evaluation looped left magnification misclassified shown previous 
portion gesture enclosed rectangle copied aspect ratio changed resulting 
seen corner simple angle looped 
resulted angle features having values significantly different average gesture misclassification 
point initial point corner probably due paging 
interacts badly features cosine sine initial angle 
features third point usually results better measurement second point 
cases results poor measurement corner 
nat result long page author got impatient mouse 
ambiguous classes 
classes similar 
misclassifications example 
may considered examples poor mouse tracking points lost top gesture caused confusion 
mistakes examples ambiguity 
ideally gesture classes application designed possible 
nearly ambiguous classes essential input device reliable sound possible features able express differences decider able discriminate 
properties inevitable substantial confusion classes 
inadequacy feature set 
examples second mouse point corner way features inadequately represent classes 
example sharp examples appear system simple left strokes 
small error results large error feature 
occurs stroke doubles back small change results large difference angle features andf see 
mistakes delete category 
uas point places features may improved 

basic single path recognition mapping gestures features certainly invertible different feature vector current scheme 
results ambiguities due entirely similarities classes due feature set unable represent 
example key illustration albeit great 
inadequacy linear statistical classification 
differences classes feature vector may possible classes separated linear discrimination functions 
typically comes class severely non multivariate normal distribution 
current feature set happens class gesture folds back discussed earlier causing entire feature vector bimodal distribution 
averaging covariance matrix essence implies feature classes 
class initial angle features deemed important classifier 
compounded errors tracking leads bad examples beam move 
possible linear classifier express class importance features linear classifier essence whatis done neural network training procedures back propagation stochastic gradient proportional increment perceptron training 
inadequate training data 
drawing tracking errors occur training set set 
examples effect bad examples estimates average covariance matrix mean feature vectors negligible 
number examples class small 
bad insufficient training data causes bad estimates classifier parameters turn causes classification errors 
classified correctly classifier incorrectly classifier examples 
analyzing errors fashion leads number suggestions easy improvements 
timing distance information decide compute usingthe points third points gesture 
mouse events queued improve performance presence paging 
new features added face errors particular cosine sine final angle gesture stroke help avoid number errors 
modification left author time desire redo evaluation examples different gesture set error revealed tests seen practice misclassification due premature timeout phase interaction 
results gesture classified 
rejection parameters section considered possibility rejecting gesture choosing classify 
potentially useful rejection developed 
estimate probability gesture classified unambiguously derived values class evaluation chapter 
evaluation mahalanobis distance class mean estimated probability unambiguous classification rejection parameters functions 
estimate mahalanobis distance determine close gesture isto norm chosen class 
nice thresholds rejection parameters neatly separate example incorrectly classified examples 
clear impossible perfect job delete illustrates system need read user mind 
incorrectly classified gestures rejected rejecting correctly classified gestures little thought shows rejection rule solely ambiguity metric average reject correctly classified gestures incorrectly classified gestures 
reasonable conjecture average ambiguous gesture classified correctly 
assumes gesture equally close 
practice assumption true 
scatter plot shows value rejection parameters gscore test set 
plus sign indicates gesture classified correctly triangle indicates gesture classified incorrectly represented 
correctly estimated unambiguity probability close accounting dark mass points right graph 
correctly classified examples 
basic single path recognition number rejected ambiguity rejection threshold counting correct incorrect rejections chapter 
evaluation bar bar move beam correctly classified gestures delete key delete flat correctly classified gestures 
interval contained incorrectly classified examples shows correctly classified incorrectly classified gestures rejected function threshold examining exactly incorrect examples interesting 
garbled nat left stroke sharp decimal places 
retrospect thisis surprising gestures far class happen unambiguously closest single class 
borne gestures graph sharp gesture 
mistakes 
inthis category delete gestures go ambiguity look chosen classes expected rejected 
interesting correctly classified test examples candidates rejection basedon values 
shows gscore gestures examples move beam abnormal virtue fact larger 
basic single path recognition normal 
bar examples endpoints funny places things examples fairly 
algorithm classify correctly bad reject 
shows gestures 
examples caused corner mouse points 
delete corner looped 
gestures look prototypes bad reject mahalanobis estimate mainly useful rejecting gestures deliberately entered poorly 
silly sounds user may decide course gesture operation time extend gesture rejected possible improvement class covariance matrix chosen class mahalanobis distance calculation 
compared average covariance matrix presumably result accurate measurement input gesture differs norm chosen class 
coverage shows performance single path gesture recognition algorithm sets 
classifier set trained fifteen examples class tested additional fifteen examples class 
set coleman editor variation class training testing examples 
remaining sets variation class 
rates demonstrate single path algorithm performs quite satisfactorily number different gesture sets 
varying orientation size feature distinguishes gesture handwriting orientation size gesture agiven class may application parameter 
gestures classes recognized independent orientation size 
recognition completely orientation size independent classes may depend orientation size distinguish straightforward indicate classes gestures vary size orientation simply vary size orientation training examples 
goal gesture recognizer irrelevant features classes matter feature classes theoretically having classes vary size orientation depend size orientation correct classification problem statistical classifier onthe assumptions multivariate normal distribution features class classes having common covariance matrix 
class size variable sure different size remains relatively constant may said orientation 
suspect classifier chapter perform poorly situation 
surprisingly case 
chapter 
evaluation 
union name 
insert delete 

digits coleman 
zero 
move join letters recognition rates various gesture set trained examples class tested additional examples class 

basic single path recognition 







classes study variable size orientation chapter 
evaluation correct number classes examples examples examples examples examples examples recognition rate set containing classes vary shows classes vary size vary orientation depend size orientation distinguishable 
training set consists examples class variations size orientation reflected training examples 
testing set examples class similarly prepared 
shows recognition rate plotted number classes various examples class training set 
seen performance correct classes trained examples class 
examples class results rate 
shows mistakes classifier 
mistakes appear size orientation gesture confused 
mistakes quite similar seen previously 
gesture classifier surprisingly classes variable size orientation discriminated basis size orientation 
variability 
basic single path recognition 
mistakes variable class test right wrong wrong mistaken delete testing program user gesture shown chapter 
evaluation gestures shown far author 
deemed necessary current demonstrating gestures person recognized 
questions come mind recognition rate achieved author gestures classifier trained author gestures rate improved allowing person train classifier gestures 
setup preparation author gscore application see section gscore gesture set evaluation 
hardware hardware majority dec microvax ii running unix andx 
simple testing program prepared training evaluation 
trial gesture class randomly chosen displayed screen start point indicated 
user attempts enter gesture class 
gesture classified andthe results fed back user 
training mode system error trial repeated 
evaluation mode trial independent subject pv music professor professional musician experienced music 
experienced computer user familiar macintosh computers 
procedure subject half hour practice testing program training mode 
copy instructed take notes discretion 
half hour tester put evaluation mode trials run 
test repeated warmup 
subject instructed create gesture set borrowing set knew liked 
examples gesture class recorded evaluation trials run new set 
results initial training confusion subject part regarding hand 
subject normally uses right hand left handed writes music left 
minutes subject opted left hand gesturing initial evaluation trial system classified correctly gestures 
subject felt better allowed second run gestures classified 
admission second run generally making gestures faster 
average recognition rate test subject commented felt difficulty due fact mouse left hand particular mouse felt 
felt performance improve additional practice 

basic single path recognition flat sharp nat bar delete key sharp sharp sharp 
delete key delete nat beam 

delete nat pv misclassified gestures author set notes interesting 
subject particular knowledge cases notes refer particular features algorithm 
gestures sharp wrote start don vertically respectively noting importance correct initial angle 
wrote short bar wrote large delete wrote quickly 
wrote sharp angle 
subject commented places gesture classes conform strokes 
example stated loop flat goes wrong way 
explained music symbols written strokes said prefer system multiple stroke symbols 
test repeated week subject warmup achieved score 
shows misclassified gestures 
subject unsure hand left hand author 
subject created gesture set examples shown 
set consisting examples class entered 
running training set resulting classifier resulted low recognition rate comparison author training set classifier train yielded 
low rate due ambiguity classes flat frequently confused classes corners looped seen section causing bimodal distributions problems new gesture set pv ran trials tester onthe new set 
able get score 
time writing pv attempt remove ambiguities gesture set careful sharp corners 
chapter 
evaluation key bar 
beam flat nat sharp move 
delete 
pv gesture set difficult draw data subject 
author expected rate higher pv trained system gestures author set 
actual rate slightly higher convincing people better gestures slightly convincing evidence section 
retrospect pv created training set copied author attempting significantly modify gesture set 
author gesture set turned better designed pv sense having inherent ambiguities tended advantage pv gained gestures 
pv new gesture set merit contrary number 
new delete gesture quick long leftward stroke gives user impression throwing objects side screen 
new move gesture delete followed minute change mind 
flat gesture closer way pv writes symbol leftward half rests gestures 
stylized clever relates key 
pv bar gesture economical author 
experiments indicate person classifier trained person moderately results 
indicated people create interesting gesture sets 
modification feature set desirable mainly features 
basic single path recognition sensitive looped corners 
useful give feedback gesture design classes confusable 
simple simply examining mahalanobis distance pair classes 
recognition speed known user interface respond quickly order satisfy users gesture systems speed recognition important factor usability system 
section reports measurements speed components recognition process statistical gesture recognizer described chapter designed speed mind 
feature incrementally calculated constant time done mouse point number features 
gesture mouse points takes pf time compute feature vector 
classification computes linear evaluation function classes classification take cf time 
feature calculation datatype fv encapsulate feature calculation follows fv allocates object type fv 
classifier generally call program initialization 
fv initializes fv object type fv 
fv called gesture points added 
fv adds point occurs time gesture performs incremental feature calculation 
called mouse point program receives 
thirteen features calculated 
vector fv returns feature vector array double precision floating 
performs necessary calculations needed transform incrementally calculated auxiliary features feature set classification 
called 
function represents entire computing feature gesture memory fv fv lambda allocated lambda vector register gesture register point fv gamma point gamma point gamma fv gamma gamma gamma chapter 
evaluation processor time sec relative ii vax microvax iii pmax table speed various computers testing processor milliseconds microvax ii microvax iii pmax table speed feature calculation return fv gto obtain timings testing set section read memory gesture passed 
processors dec microvax ii majority reported dissertation dec microvax iii dec pmax get idea performance modern system 
unix profiling obtain times 
cases times virtual times time spent executing program processor 
tests run unloaded systems real times virtual times 
timing code related gesture recognition code fragment cc timed number processors microvax ii vax microvax iii pmax order compare speed processors tests vax register int double lambda lambda gamma gamma times fragment shown table 
note code fragment pmax runs times faster 
typical code usually runs times faster 
testing set averaged points gesture 
timings routines shown table 
cost mouse point incrementally process mouse point small fraction slowest processor 
mouse points typically come faster 
basic single path recognition processor computation time milliseconds max total class classes microvax ii microvax iii pmax table speed classification second small fraction processor consumed incrementally calculating 
substantially processor consumed communicating window manager receive mouse point perform 
classification feature vector calculated classified 
involves computing function features classes 
rejection parameters desired takes additional estimate ambiguity estimate mahalanobis distance 
computation times shown table get times runs 
gesture testing set classified run 
run calculate rejection parameter 
average time classify classes reported maxv column column computed time 
column gives time compute evaluation function single class multiply number classes estimate classification time particular classifier 
computed classification difference time max time reported column 
third run computed reported similarly 
fourth run computed average time gesture reported total column 
class discrimination rejection parameters gesture entered takes microvax ii milliseconds finish calculating feature vector classify 
acceptable albeit fantastic performance 
gesture indicated mouse motion timeout interval classification timeout interval expires result ignored user moves mouse 
currently arithmetic done double precision floating point numbers 
reason evaluation functions computed integer arithmetic suitably rescaling features lose precision 
resulting classifier run faster processors 
tried 
eager recognition running classification occur mouse point numberof classes 
puts ceiling number classes eager recognizer discriminate real time 
microvax ii cost mouse point includes msec plus msec plus class evaluation classes 
mouse points come maximum rate milliseconds classes entire processor 
practically chapter 
evaluation probably maximum reasonably expected eager recognizer microvax ii today processors computation time limiting factor lower recognition rate large number classes approach tried increase number classes eager recognizers subset features 
improved response time system performance idea abandoned 
point getting wrong answer quickly 
training time stated goal thesis provide tools allow user interface designers gesture systems 
factor impacting usability tools amount time takes gesture recognizers retrain changes examples 
trainable character recognizers deleting single training example requires training redone scratch 
technologies notably retraining may take minutes hours 
system conducive experimenting different gesture sets contrast statistical classifiers kind described chapter trained rapidly 
training classifier scratch requires ef compute mean feature vectors ef calculate class covariance matrices cf average invert average cf compute weights evaluation functions 
average singular algorithm run deal problem 
fair amount reused retraining change training examples adding deleting example class requires incrementally update class class mean vector incrementally update class covariance matrix retraining involves repeating steps starting computing average covariance matrix 
retraining dependency total number examples eliminated 
function number examples added deleted 
objective implementation attempt incrementally update class ance matrix example added 
averages kept incrementally class covariance matrix recomputed scratch 
involves cf class changed number training examples class results worse performance small number examples changed better performance class deleted new set entered 
operation common experimenting gesture systems author implemented objective versions single path classifier 
maintaining class covariance matrices incrementally version differs store list examples train 
necessary store list add remove examples mean vector covariance matrix updated incrementally efficient need maintain lists examples 
objective set class implemented hashing maintain lists version 
overhead separate objects examples classes classifiers objective version see section 

basic single path recognition processor time milliseconds call classes classes microvax ii microvax iii pmax table speed classifier training version ported pmax timings 
feature computation gesture recognition timings cases objective methods straightforward translations corresponding 
cases methods merely call corresponding function 
functions encapsulate process training classifier sclassifier allocates returns handle new classifier 
classes examples 
type function names refers single path corresponding types functions multi 
sclassifier sc char classname vector adds feature vector named class classname passed classifier 
created seen 
linear search find class name optimized successive calls name 
incrementally maintains class mean vectors covariance matrices 
sclassifier sc char classname vector removes ex ample assumed added earlier named class 
class mean vector covariance matrix incrementally updated 
sclassifier sc trains classifier current set examples 
average covariance matrix inverts fixing singular computes weights 
sclassifier sc vector double classification non null probability ambiguity estimated non null estimated mahalanobis distance computed class 
function timed previous section 
functions exercised adding example training set training looping removing re adding consecutive examples retraining 
singular covariance matrix due large number examples 
table performance various routines 
microvax ii training class classifier examples quarter second 
grandma able produce classifier immediately chapter 
evaluation time gesture set views combined gesture set see sections 
user wait wait long 
eager recognition section evaluates effectiveness eager recognition algorithm single sets 
recall eager recognition recognition gesture explicit indication gesture 
ideally eager recognizer classifies soon seen unambiguously see chapter 
order determine eager recognition algorithm works eager recognizer classify gestures classes shown 
class named direction segments ur means right 
gestures ambiguous unambiguous corner turned second segment begun 
eager recognizer trained examples classes tested examples class 
shows test examples class includes examples misclassified comparisons interest gesture set eager recognition rate versus recognition rate full classifier eagerness recognizer versus eagerness 
eager recognizer classified gestures correctly compared correct full classifier 
eager recognizer errors due degrees sharp degrees appeared eager recognizer second stroke going opposite direction intended 
indicates eager recognizer indicates misclassification full classifier 
average eager recognizer examined mouse points gesture gesture unambiguous 
hand author determined gesture number mouse points start corner turn concluded average mouse points gesture needed seen gesture unambiguously classified 
parts gesture unambiguous classification occurred indicated thick lines 
shows performance eager recognizer gdp gestures 
trained examples gesture classes tested examples class shown 
gdp gesture set slightly altered eagerness group gesture trained clockwise counterclockwise prevented copy gesture eagerly recognized 
gdp gestures correct recognition rate compared eager recognizer 
average gesture examined eager recognizer 
set attempt determine minimum average gesture percentage needed seen unambiguous classification tests conclude trainable eager recognition algorithm performs acceptably plenty room improvement recognition rate eagerness 
computationally eager recognition quite tractable modest hardware 
fixed amount 
eager recognition unambiguous determined hand ur ur ur ur ur ur ur ur ur ur lu lu lu lu lu ef lu ru lu lu ru ru ru ru ul ul ul ul ul 
ul ul ul ul ul lu ru ru ru 
ru misclassified full classifier indicates gesture eager recognizer ru example number includes class name places gesture classified eager recognizer name example indicates gesture thickness indicates gesture seen gesture classified thick line indicates eager recognizer failed eager ambiguous part start period indicates line medium point gesture thin line seen number hand recognizer classified gesture minimum numberof mouse points needed total number gesture number points seen eager ru key ld ld ld ld ld ld ld ld ld eld rd rd rd rd rd rd rd rd rd dl dl dl dl dl dl dl dl dl dr dl dr dr dr dr dr dr dr dr dr rd 
cross stroke indicates 
performance eager recognizer easily understood data chapter 
evaluation move move move rotate scale rotate scale rotate scale rotate scale rotate scale 
copy copy copy copy copy dot dot dot dot dot delete delete delete delete line line line delete line line edit edit edit edit edit group group group group rect group rect rect rect rect 
move text text text 
text text ellipse ellipse ellipse ellipse ellipse performance eager recognizer gdp transitions thin thick lines indicate eager recognition occurred 

multi finger recognition computation needs occur mouse point feature vector updated msec dec microvax ii vector classified auc msec class msec case gdp 
multi finger recognition multi finger gestural input significant innovation 
unfortunately evaluation multi finger recognition impossible irrelevant 
sensor frame input device multi finger recognition tested 
unfortunately functioning sensor frame existence damaged multi finger recognition running formal testing 
fortunately videotape mdp action sensor frame working 
progress repairing sensor frame year testing impossible eventually sensor frame repaired sensor frame went business shortly afterward making detailed evaluation irrelevant 
owner sensor frame left device 
informal estimate multi finger recognition accuracy may estimated videotape author mdp 
version mdp uses path sorting multi finger recognition algorithm section 
shown mdp recognizes gestures gestures finger gestures finger gestures 
videotape author gestures appear misclassified rejected correct recognition rate 
processing time appears negligible 
misclassifications result sensor frame seeing fingers intended 
due fingers gesture accidentally penetrating sensing plane counted additional fingers 
distinct classifiers single finger finger finger gestures incorrect number fingers inevitably leads misclassification 
possible imagine methods errors recognition main cause problem ergonomics sensor frame small gesture set examined recognition rate errors due extra fingers eliminated 
expected small number gestures numberof fingers 
expected multi path classifier operating finger gestures perform single path classifier algorithms essentially identical 
single classes discriminate shown mouse data perform cases 
operating finger gestures expected thatthe performance recognition algorithm similar single path classifier twice number classes 
possible paths similar paths set merged single class training algorithm section 
number unique paths twice numberof finger gesture classes performance may expected improve accordingly 
similarly finger gesture classifier may expected perform single path classifier times number finger gesture classes depending chapter 
evaluation number unique paths class set factor consider mouse data tends noisy sensor frame data 
triangulation sensor frame erratic especially multiple fingers 
example horizontal segments parallelogram gesture straight lines 
problem solved expected recognition rates gesture sets suffer 
grandma evaluating grandma subjective evaluating low level recognition rates grandma may evaluated levels effort required build new interaction techniques build new applications add gestures application change application application perform task 
attempt formally evaluate 
order get statistically valid results necessary run carefully designed experiments number users author time space inclination qualifications 
furthermore wish claim grandma superior existing object oriented toolkits particular task 
grandma simply platform ideas input object oriented toolkits explored 
grandma significance influence toolkits direct results section informally reports author experience building gesture systems grandma 
author tried program 
order confirm grandma author section reports observations subject trying gscore grandma due tasks 
author experience grandma grandma took approximately months design develop 
consists approximately lines objective code 
additional lines code implement graphics layer feature vector calculation 
gdp took additional lines code implement 
gdp developed time grandma primary application test grandma initially gdp gestures test grandma gesture handler associated utilities 
working took days add remaining gestures gdp time spent writing objective methods semantic expressions 
methods needed existing direct manipulation interface gscore consists lines objective code 
took weeks design implement gscore including palette interface 
time spent details common music notation mechanisms displaying music notation producing usable music fonts 
palette interaction technique exist grandma took hours implement 
took weeks add gestural interface gscore 
grandma pv task pv result including writing additional methods 
time spent experimenting semantics gestures 
section lists features grandma important incorporate support gestures 
user uses gscore grandma sections informally reports subject pv see section attempts 
task enter music shown 
music chosen exercise gscore gestures 
pv experienced music took seconds write music shown copying earlier attempt gestures author able enter score seconds minutes 
total gestures give desired results 
misclassifications notes gestures note created having wrong pitch due cursor start gesture turning gestures palette interface took author seconds eleven minutes 
mistakes needed undone trial pv attempt gscore program trained author gestures 
pv gained experienced set gestures study variation pv practiced half hour gscore program attempting task 
author coached pv time documentation help available pv took seconds minutes complete task 
total gestures immediately undone 
appeared author silently observing recover misclassification 
shows product labor 
pv turned gestures palette interface enter example 
completed seconds minutes 
chapter 
evaluation pv entered gestures place author 
particular gestures classes delete move beam bar entering examples 
total time including incremental testing gestures periodic saves disk minutes 
pv attempt emulate author gestures forms created earlier see section done pv repeated experiment 
took seconds minutes enter music 
gestures undone pv interviewed tests comments biggest problem stated mouse tracking gscore program sluggish inthe recorder tester 
accurate time required gscore events created consumed adds significant overhead mouse tracking 
overhead due 
pv characterized system sluggish 
bad tracking especially start gesture contributed significantly number misclassifications pv stated thought system intuitive entering notes 
described interface excellent compared palette system asked interface compared writing replied 
mouse gesturing believed stylus tablet better difficult draw informal study user 
pv performance improve tailored gestures liking practicing 

things clear grandma easy experiment new gesture sets gscore moderate practice gesture interface improved task performance bya factor palette interface 
gesture interfaces generally improve task performance non gesture interfaces question requires study 
chapter directions chapter summarizes contributions thesis indicates directions 
contributions thesis contributions areas ffl new interaction techniques ffl new recognition related algorithms ffl integrating gestures interfaces ffl input object oriented toolkits discussed turn 
new interactions techniques major contributions invention exploration new 
phase single stroke interaction phase interaction enables gesture direct ma integrated single interaction combines power 
phase collection points gesture collected 
case collection phase indicated motion timeout classification occurs second phase manipulation entered 
manipulation phase mouse manipulate parameters application 
particular parameters manipulated depend classification collected gesture 
collection phase entry handwriting interfaces manipulation phase drag interaction direct manipulation interfaces 
generally operation operands parameters chapter 
directions determined phase transition gesture recognized allows additional parameters set presence application feedback 
eager recognition eager recognition modification phase single stroke phase transition gesturing manipulation occurs soon gesture seen may classified unambiguously 
result combines gesturing direct manipulation single smooth interaction 
phase multiple finger interaction gesture direct manipulation may combined path inputs way similar phase single stroke interaction 
multiple finger input opportunities exist expanding power phase interaction allowing multiple fingers collection phase repertoire possible gestures greatly increased multiple finger gesture allows parameters gesture recognized 
similarly finger gesture additional fingers may brought manipulation phase 
phase multiple finger interaction allows large number parameters specified interactively manipulated 
recognition technology thesis discloses new algorithms general utility construction 
automatic generation single stroke gesture recognizers training examples efficient algorithm generating gesture recognizers developed tested 
gesture represented vector real valued features standard pattern generate linear classifier discriminates vectors different gesture classes 
training algorithm depends aggregate statistics class empirically shown usually fifteen examples class needed produce accurate recognizers 
simple incorporate dynamic attributes average speed gesture feature set 
algorithm shown classes vary size orientation depend size recognized 
recognizer size independent number training examples recognition training times shown small 
meaningful extensible potentially allows algorithm adapted input devices requirements 
incremental feature calculation calculation generate features input points ofa gesture incremental meaning takes constant time update features new input point 
allows arbitrarily large gestures processed delay processing 
rejection algorithms algorithms rejecting ill formed gestures developed 
estimates probability correct classification enabling input gestures ambiguous respect set gesture classes rejected 
uses normalized 
contributions distance metric determine close input gesture typical gesture class allowing outliers rejected 
automatic generation eager recognizers training examples eager recognizer classi fies gesture soon unambiguous alleviating need gesture explicitly indicated 
algorithm generating eager recognizers training developed tested 
algorithm produces class classifier run input point determine gesture entered unambiguous 
automatic generation multi path gesture recognizers single stroke recognition extended number single stroke recognizers may combined gesture recognizer 
described algorithm produces multi path recognizer examples 
relative path timing information considered recognition global classification attempted individual path classifications class multi path gesture 
dealing problems arise multi path input devices priori determine path path sorting path clustering explored 
resulting algorithm demonstrated sensor frame multi finger input device 
integrating gestures interfaces paradigm integrating gestures object oriented interfaces developed demon 
key points gesture set associated view view class 
class object user responds different set gestures 
example notes respond different set gestures gscore music editor 
gesture set dynamically determined 
point gesture system dynam ically determines set gestures possible 
point determines possible views gesture directed 
views inheritance class set gestures handles 
sets combined need classifier resulting union dynamically created 
gesture class attributes map application operation operands parameters gestures powerful contain additional information class gesture 
attributes gesture size orientation length speed point area mapped parameters including operands application routines 
phase interaction gesture recognized opportunity input application parameters presence application feedback 
gesture handlers may manipulated runtime 
order encourage exploration gesture systems aspects gestural interface specified application running 
new gesture handler may created runtime associated view classes 
gesture classes may added deleted copied handlers 
chapter 
directions examples gesture class entered modified runtime 
gesture class entered modified runtime 
semantic expressions specifiable evaluated gesture recognized evaluated mouse point evaluated interaction completes 
input object oriented user interface toolkits number new ideas area input object oriented user interface toolkits arose 
passive active event handlers single passive event handler may associated 
input occurs view handler usually activates copy 
active passive dichotomy eliminates need controller object view expects input major expense mvc systems 
event handlers may associated view classes having associate handler instance view handler may associated view classes 
view may multiple handlers associated handlers queried determine handler handle particular input 
unified mouse input virtual tools input devices tools desired single may times different tools way implement modes interface 
tools may software objects views virtual tools 
tools action allows operate views respond action 
test view responds tool event handler associated view allows semantic feedback occur automatically explicit action part view tool 
automatic semantic feedback just mentioned feedback tool view dragged happens automatically 
example objects respond delete message automatically highlight delete tool 
desired object elaborate processing determine truly responds tool object may check user permission delete indicating responds delete tool 
runtime creation manipulation event handlers event handlers may created asso ciated views view classes runtime 
example drag handler may associated object allowing object dragged position changed 
addition handlers may modified runtime example change predicate activates handler 
directions section directions discussed 
directions include remedies current extensions 

directions single stroke training recognition algorithm robust tested part ofthe current current form probably suitable commercial applications 
number simple modifications improve performance 
sections contain suggestions additional features modifications existing features implemented 
tracking mouse presence paging proved problem improvement recognition rate achieved real time response mouse events guaranteed simple extend algorithm dimensional gestures 
required add features capture motion extra dimension 
algorithm linear classifier untouched extension 
alternatives rejection explored 
estimated probability useful result rejections gestures correctly classified 
estimated mahalanobis distance matrix really useful rejecting deliberately garbled gestures 
mahalanobis distance class covariance matrix fares somewhat better requires training examples 
obvious false assumption equal class covariance matrices classifier perform gesture sets classes vary size orientation 
practice gesture classes unambiguous tended perform 
presumably case gesture sets 
area exploration method calculating common covariance particular weighing class contributions number examples class challenge handle gesture sets giving linear classification closed form training formula 
candidate relies minimum squared error pseudoinverse matrix examples 
explored potential alternative classifiers rely estimates common 
interesting explore possibility allowing user indicate gesture classes vary size orientation 
handled simply generating additional training examples varying user supplied examples accordingly alternatively may possible augment training algorithm evaluation functions certain classes constrained ignore certain features relaxing requirement closed form exist class feature weights allows iterative training methods considered 
ignored dissertation expensive training time tend require training examples 
processor speed increases iterative methods practical tool experimenting interfaces 
similarly relaxing requirement classifier linear discriminator opens possibilities 
quadratic discrimination various non parametric discrimination algorithms 
expensive require training examples recognition technologies require expensive training may production chapter 
directions system cheaper technology developed prototyping 
analogous fast compiler development optimizing compiler production 
time writing neural networks soon common gesture recognition application 
additional attention problem detecting ambiguous sets useless features 
triangular matrix mahalanobis distance pair gesture classes useful starting point determining similar gesture classes 
multivariate variance techniques determine features contribute classification features irrelevant 
techniques support design new features 
eager recognition needs explored 
classifiers generated algorithm eager possibly due conservative choices 
hand labeling ambiguous unambiguous subgestures explored fully imagine interface labeling relatively painless give better results current automatic labeling 
possible improvement comes eager recognition full classifier classify subgestures trained 
worth trying retrain full classifier 
better new classifier trained newly complete subgestures complete point substituted full classifier 
needs extended multi path gestures 
algorithms automatically determining start gesture useful devices discrete signaling capability notably dataglove 
current gestures considered atomic essentially having discernible structure 
easy separate gestures select copy move delete concatenated single interactions select move select delete 
raises segmentation question gesture 
specifying allowable combinations gestures opens possibility gesture grammars interesting area study 
dissertation concentrated single path gestures restricted single strokes reasons explained previously 
utility multiple stroke gestures needs examined thoroughly 
multiple stroke gesture relaxation strokes ruin correspon dence mental physical tension interaction 
need segmentation system responsive 
eager recognition incorporated system multiple stroke gestures 
questions require research 
due interest multiple stroke recognition question arises single stroke algorithm extended handle multiple stroke gestures 
segmentation problem grouping strokes gestures needs addressed 
way done add determine gesture 
distance stroke previous stroke 
sequence strokes determined single gesture treated asingle stroke exception additional feature records number strokes gesture 
single stroke recognition algorithm may applied 
multi path recognition really infancy 
recognition algorithms chapter compare 
methods multi path 
directions recognition need explored 
said author somewhat wary multiple finger gesture research concentrate devices exclusion single path devices 
unfortunate single path devices prevalent foreseeable users potentially benefit availability single path gesturing 
thorough understanding issues involved path gesturing solving difficult problems encountered multi path case advent pen computers leads question single stroke recognition described may combined handwriting recognition 
approach pass input recognizer rejected handwriting recognizer 
context stroke drawing window text window determine invoke handwriting recognition stroke recognition 
start single stroke gesture determine set possible gestures possible objects gesture directed 
may desirable explore possibility gesture directed object indicated point indicated hot point gesture intersection point delete gesture 
similar ambiguity occurs input multiple finger gesture fingers determine object gesture directed 
case union gestures recognized objects indicated finger possibility conflict remains problem gesture systems usually indication possible gestures accepted system difficulty potentially prevent novices usingthe system 
approach animation indicate possible gestures effects user asks see animation remains open question daunting beginners timeout interval indicate collection manipulation 
typically beginner presses mouse button andthen thinks time system classified gesture dot 
timeout totally disabled way enter manipulation phase forsome gestures 
scheme timeouts long seconds novices decrease desirable 
possibility eliminating timeout totally gestures disallowing dot gestures 
current suffers lack formal user evaluation 
additional studies determine classifier performance function training examples user classifier trained 
general costs benefits fixed verses strategies need studied 
usability eager recognizers interest 
recognizers gradually adapt users need studied 
recognizer user indicate gesture misclassified system 
lerner demonstrated potentially applicable scheme system monitored subsequent actions see satisfied result applied heuristic 
dangers inherent doubly adaptive systems system adapts user user system aiming thrashing possible 
current approach requires user explicitly replace kurtenbach say gesture interfaces non revealing interesting solution unifies gesturing pie menu selection 
chapter 
directions existing training examples workable solution 
low level recognition thesis quite usable current state may incorporated systems warranted 
grandma useful base development 
purely research system built platform experimenting input interface toolkits 
output facilities totally inadequate real applications 
grandma built solely author plans maintain 
important concepts gestures integrated object oriented user interface tools 
obvious step integrate gestures existing user interface construction tools issues technical suitability important paramount deciding system 
chosen system supported maintained reasonable system survive 
furthermore chosen system widely distributed order technology gesture recognition available experimenters possible 
number existing systems candidates incorporation gestures 
ap plication kit technically ideal platform programmed objective appropriate hooks capture input right level order associate gestures 
probably worth effort implement entire interpreter entering gesture semantics runtime user typically manipulate 
graphical control semantics constraints interesting addition 
general simpler way mapping gestural attributes application parameters needs determined 
andrew toolkit atk system gestures may incorporated 
object oriented programming language top runtime representation class hierarchy straightforward add 
atk loading objects running programs possible compile gesture semantics load running program restarting program 
unfortunately overhead views tend large objects atk individual notes score editor separate views atk making difficult associate different gestures objects interest interface 
scott hassan different approach added author gesture recognizer atk text object creating interface allows text editing marks 
integrating gestures garnet possibility 
required gesture analogous gesture event handler grandma 
garnet interactors routinely specify semantics constraints escape lisp available unusual cases 
specifying ges ture semantics problem garnet 
james landay begun integrating author recognizer garnet 
gestures added 
widely runs macintosh historically run process time virtual memory changed system software release 
points sound real time operation needed track mouse reliably easy achieve 
implemented object pascal minimal meta objects available runtime 
particular message selectors class objects object pascal possible ask object responds message runtime 
final remarks runtime representation class hierarchy 
things happen automatically written objective need explicitly coded 
desirable additional attributes gesture available 
notably missing current set locations path intersects locations sharp corners stroke 
kinds attributes pointing allow multiple points indicated single path gesture 
having numerical attributes available scaled form zero simplify parameters application functions 
final remarks utility gesture interfaces derives ability communicate entire transaction single gesture 
possible gesture needs classified determine operation performed attributes gesture mapped operation 
parameters may culled time gesture recognized best manipulated presence feedback application 
phase approach gesture recognition followed manipulation phase allows continuous adjustment parameters presence 
outset goal provide tools allow easy creation gesture applications 
research led prototypes tools laid groundwork building tools 
goal achieved integrated existing user interface construction tools maintained highly available 
involves development marketing research important gesture systems 
chapter 
directions appendix code single stroke training appendix contains actual code recognize single stroke gestures 
feature classifier training algorithm linear classifier 
code may obtained free charge anonymous ftp andrew cmu edu subdirectory gestures available part andrew contribution distribution 
feature calculation lowest level code deals computing feature vector sequence mouse gesture 
type fv pointer structure holds feature vector results calculation features 
function allocates fv initialized processing points gesture 
input point gesture returns feature vector gesture points entered 
sample code fragment demonstrating functions include matrix include fv vector static fv fv int long vector lambda typically called program invocation 
lambda fv null fv appendix code single stroke gesture recognition training lambda prototypical loop compute feature vector read window manager lambda fv gesture fv fv return returned vector passed classify gesture remainder section shows header file fv defines fv type vector interface 
interface implemented fv shown 
lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda fv gamma create feature vector useful gesture classification sequence points mouse points 
lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma compile time settable parameters gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma lambda lambda set runtime see fv lambda undef time lambda define time enable duration maximum lambda lambda velocity features 
defined may passed lambda lambda time 
lambda define dist sq threshold lambda lambda points sqrt dist sq threshold lambda lambda ignored eliminate mouse jitter lambda define se th lambda lambda se theta features cos sin lambda lambda angle point lambda lambda scaled distance lambda lambda points sqrt se th lambda lambda gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma interface gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma lambda typedef struct fv lambda fv lambda gesture collection fv holds lambda lambda intermediate results lambda lambda calculation single feature vector lambda 
feature calculation fv lambda lambda void lambda fv fv lambda void lambda fv fv lambda void lambda fv fv int long time lambda vector lambda fv fv lambda lambda gamma gamma gamma gamma gamma gamma internal data structure gamma gamma gamma gamma gamma gamma lambda define lambda maximum number features occasionally useful array bound lambda lambda indices feature vector returned lambda define pf init cos lambda initial angle cos lambda define pf init sin lambda initial angle sin lambda define pf bb len lambda length bounding box diagonal lambda define pf bb th lambda angle bounding box diagonal lambda define pf se len lambda length start points lambda define pf se cos lambda cos angle start points lambda define pf se sin lambda sin angle start points lambda define pf len lambda arc length path lambda define pf th lambda total angle traversed lambda define pf ath lambda sum abs vals angles traversed lambda define pf lambda sum squares angles traversed lambda ifndef time define nfeatures define pf dur lambda duration path lambda define pf maxv lambda maximum speed lambda define nfeatures endif lambda structure holds intermediate results feature vector calculation lambda struct fv lambda calculating features lambda double lambda starting point lambda long starttime lambda starting time lambda lambda set points left lambda appendix code single stroke gesture recognition training double initial sin initial cos lambda initial angle axis lambda lambda updated incrementally point lambda int lambda number points path lambda double dx dy lambda differences gamma gamma lambda double lambda dx lambda dx dy lambda dy lambda double lambda point added lambda long endtime double minx maxx miny maxy lambda bounding box lambda double path path th lambda total length rotation radians lambda double abs th lambda sum absolute values path angles lambda double sharpness lambda sum squares path angles lambda double maxv lambda maximum velocity lambda vector lambda actual feature vector lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda fv gamma creates feature vector useful gesture classification sequence points mouse points 
lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda include stdio include math include matrix lambda contains vector associated functions lambda include fv lambda runtime settable parameters lambda double dist sq threshold dist sq threshold double se th se th define eps gamma lambda allocate fv struct including feature vector lambda fv 
feature calculation register fv fv fv sizeof struct fv fv gamma nfeatures fv return fv lambda free memory associated fv struct lambda void fv fv fv fv gamma free char lambda fv lambda initialize fv struct prepare incoming gesture points lambda void fv register fv fv register int fv gamma fv gamma initial sin fv gamma initial cos fv gamma maxv fv gamma path fv gamma path th fv gamma abs th fv gamma sharpness fv gamma maxv nfeatures fv gamma lambda update fv struct reflect new input point lambda void fv register fv fv int long double dx dy appendix code single stroke gesture recognition training double th ifdef pf maxv long endif fv gamma fv gamma lambda point initialize vars lambda fv gamma starttime fv gamma endtime fv gamma fv gamma fv gamma minx fv gamma maxx fv gamma fv gamma fv gamma miny fv gamma maxy fv gamma fv gamma return dx gamma fv gamma dy gamma fv gamma dx lambda dx dy lambda dy dist sq threshold fv gamma gamma gamma return lambda ignore point close point lambda fv gamma minx fv gamma minx fv gamma maxx fv gamma maxx fv gamma miny fv gamma miny fv gamma maxy fv gamma maxy ifdef pf maxv fv gamma endtime endif fv gamma endtime sqrt fv gamma path lambda update path length feature lambda lambda calculate initial theta third point seen lambda fv gamma double dx dy recip dx gamma fv gamma dy gamma fv gamma dx lambda dx dy lambda dy dist sq threshold lambda find angle positive axis 
lambda 
feature calculation recip sqrt fv gamma initial cos dx lambda recip fv gamma initial sin dy lambda recip fv gamma lambda update angle gamma features lambda th atan dx lambda fv gamma dy gamma fv gamma dx lambda dy dx lambda fv gamma dx dy lambda fv gamma dy gamma fv gamma path th th fv gamma abs th fv gamma sharpness th lambda th ifdef pf maxv lambda compute max velocity lambda fv gamma endtime fv gamma endtime gamma fv gamma maxv fv gamma maxv endif lambda prepare iteration lambda fv gamma fv gamma fv gamma dx dx fv gamma dy dy fv gamma return lambda calculate return feature vector lambda vector fv register fv fv double factor fv gamma return fv gamma lambda feature vector zeros lambda fv gamma pf init cos fv gamma initial cos fv gamma pf init sin fv gamma initial sin appendix code single stroke gesture recognition training lambda compute length bounding box diagonal lambda fv gamma maxx gamma fv gamma minx fv gamma maxy gamma fv gamma miny fv gamma pf bb len lambda bounding box angle defaults small gestures lambda lambda dist sq threshold fv gamma pf bb th atan fv gamma maxy gamma fv gamma miny fv gamma maxx gamma fv gamma minx lambda compute length angle points lambda fv gamma gamma fv gamma fv gamma gamma fv gamma fv gamma pf se len lambda points close angle muted satisfy stability criterion lambda factor lambda se th factor factor factor eps factor fv gamma pf se cos fv gamma gamma fv gamma lambda factor fv gamma pf se sin fv gamma gamma fv gamma lambda factor lambda remaining features computed lambda fv gamma pf len fv gamma path fv gamma pf th fv gamma path th fv gamma pf ath fv gamma abs th fv gamma pf fv gamma sharpness ifdef pf dur fv gamma pf dur fv gamma endtime gamma fv gamma starttime lambda endif ifdef pf maxv fv gamma pf maxv fv gamma maxv lambda endif return fv gamma 
deriving linear classifier deriving linear classifier type sclassifier points object represents classifier able discriminate aset gesture classes 
gesture class represented type 
functions read write classifier file 
function new empty classifier 
training example added 
explicitly add new class classifier 
example new class added new class created automatically 
train classifier added examples call trained classify feature vector classes optionally computes rejection information example fragment creating new classifier entering new training examples writing resulting classifier file 
functions timed described section 
include stdio include math include bitvector include matrix include sc define sclassifier sclassifier sc vector char name int printf enter class name newline exit gets name null jj name break printf enter example name sc name sc fopen classifier sc return sc appendix code single stroke gesture recognition training classifier created classifier gestures follows sc sclassifier sc vector scd double distance printf enter gesture scd sc distance printf gesture classified scd gamma name printf probability unambiguous classification printf distance class mean distance follows header file code implement statistical classifier 
lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda sc gamma create single path classifiers feature vectors examples classifying example feature vectors 
lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda define lambda maximum number classes lambda typedef struct sclassifier lambda sclassifier lambda classifier lambda typedef int lambda gamma class index lambda typedef struct lambda lambda gamma class information lambda struct lambda gesture class information classifier lambda char lambda name lambda name class lambda number lambda unique index small integer class lambda int lambda number training examples lambda vector average lambda average training examples lambda matrix lambda covariance matrix examples lambda 
deriving linear classifier struct sclassifier lambda classifier lambda int nfeatures lambda number features feature vector lambda int lambda number classes known classifier lambda lambda lambda array pointers class data lambda vector lambda constant term discrimination function lambda vector lambda lambda array coefficient weights lambda matrix lambda inverse covariance matrix lambda sclassifier lambda lambda sclassifier lambda file lambda lambda void lambda file lambda sclassifier sc lambda void lambda sc lambda void lambda sc char lambda classname vector lambda void lambda sc lambda lambda sc lambda lambda sc double lambda ap double lambda dp lambda lambda sc classname lambda double lambda vector matrix sigma lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda sc gamma creates classifiers feature vectors examples example feature vectors 
lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda include stdio include math include bitvector include matrix include sc define eps gamma lambda singular matrix check lambda lambda allocate memory associated new classifier lambda sclassifier register sclassifier sc appendix code single stroke gesture recognition training sclassifier sizeof struct sclassifier sc gamma nfeatures gamma sc gamma sc gamma lambda lambda sizeof sc gamma null return sc lambda free memory associated new classifier lambda void sc register sclassifier sc register int register scd sc gamma scd sc gamma scd gamma name free scd gamma name free scd sc gamma sc gamma sc gamma scd gamma scd gamma scd gamma average scd gamma average free sc gamma sc gamma free sc gamma sc gamma sc gamma sc gamma sc gamma free sc lambda string name class return gamma class information lambda sc classname register sclassifier sc register char lambda classname register int register scd static sclassifier static 
deriving linear classifier lambda quick check class name lambda sc gamma name classname return lambda linear search classes name lambda sc gamma scd sc gamma scd gamma name classname return sc scd return null lambda add new gesture class classifier lambda static sc classname register sclassifier sc char lambda classname register scd sc gamma sc gamma scd sizeof struct scd gamma name classname scd gamma number sc gamma scd gamma scd gamma null sc gamma return scd lambda add new training example classifier lambda void sc classname register sclassifier sc char lambda classname vector register scd register int double appendix code single stroke gesture recognition training double nm scd sc classname scd null scd sc classname sc gamma nfeatures gamma sc gamma nfeatures scd gamma scd gamma average sc gamma nfeatures scd gamma average scd gamma sc gamma nfeatures sc gamma nfeatures scd gamma sc gamma nfeatures funny vector sc gamma nfeatures return scd gamma nm double scd gamma gamma scd gamma scd gamma lambda incrementally update covariance matrix lambda sc gamma nfeatures gamma scd gamma average lambda upper triangular part computed lambda sc gamma nfeatures sc gamma nfeatures scd gamma nm lambda lambda lambda incrementally update mean vector lambda sc gamma nfeatures scd gamma average nm lambda scd gamma average lambda 
deriving linear classifier lambda run training algorithm classifier lambda void sc register sclassifier sc register int int int ne denom double register matrix register matrix double det register scd sc gamma error classes lambda covariance matrices class lambda number examples gamma compute average common covariance matrix lambda sc gamma nfeatures sc gamma nfeatures ne sc gamma scd sc gamma ne scd gamma scd gamma sc gamma nfeatures sc gamma nfeatures denom ne gamma sc gamma denom printf examples denom denom return denom sc gamma nfeatures sc gamma nfeatures appendix code single stroke gesture recognition training lambda lambda invert avg covariance matrix lambda sc gamma sc gamma nfeatures sc gamma nfeatures det sc gamma fabs det eps sc lambda compute discrimination functions lambda sc gamma vector lambda sc gamma lambda sizeof vector sc gamma sc gamma sc gamma scd sc gamma sc gamma sc gamma nfeatures scd gamma average sc gamma lambda product lambda sc gamma sc gamma gamma lambda sc gamma scd gamma average lambda add log class lambda return lambda classify feature vector lambda sc fv return sc fv null null lambda classify feature vector possibly computing rejection metrics lambda sc fv ap dp sclassifier sc vector fv double lambda ap double lambda dp double disc 
deriving linear classifier register int double denom exp register scd double sc gamma null error trained classifier sc sc gamma disc sc gamma fv sc gamma sc gamma disc disc scd sc gamma ap lambda calculate probability non gamma ambiguity lambda denom sc gamma lambda quick check avoid computing negligible term lambda disc gamma disc gamma denom exp lambda ap denom dp lambda calculate distance mean chosen class lambda lambda dp fv scd gamma average sc gamma return scd lambda compute mahalanobis distance vectors lambda double sigma register vector register matrix sigma register static vector space double result appendix code single stroke gesture recognition training space null jj space space space space space gamma result space sigma return result lambda handle case singular average covariance matrix removing features lambda sc register sclassifier sc matrix int double det bitvector bv matrix lambda just add features discarding matrix non gamma invertible lambda clear bit vector bv sc gamma nfeatures bit set bv bv bv det fabs det eps bit clear bv bv bv det fabs det eps error fix classifier bv bv sc gamma 
deriving linear classifier lambda write classifier file lambda void outfile sc file lambda outfile sclassifier sc int register scd fprintf outfile classes sc gamma sc gamma scd sc gamma fprintf outfile scd gamma name sc gamma scd sc gamma outfile scd gamma average outfile sc gamma outfile sc gamma outfile sc gamma lambda read classifier file lambda sclassifier infile file lambda infile int register sclassifier sc register scd char buf printf reading classifier stdout appendix code single stroke gesture recognition training sc buf infile buf error printf classes stdout fscanf infile buf scd sc buf scd gamma name buf printf scd gamma name stdout sc gamma allocate sc gamma vector sc gamma scd sc gamma scd gamma average infile sc gamma infile sc gamma infile sc gamma infile printf return sc lambda compute pairwise distances classes print closest ones clue gesture classes confusable lambda sc register sclassifier sc register matrix sc gamma sc gamma register int double min max int mi mj printf gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma printf closest pairs classes sc gamma gamma average sc gamma gamma average sc gamma max max 
undefined functions min max mi mj gamma ffor min min mi mj mi gamma break printf sc gamma mi gamma name sc gamma mj gamma name mi mj sqrt mi mj mi mj max gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma undefined functions code uses functions definitions included appendix 
classes standard library functions including math library utility functions bitvector functions vector matrix functions standard library calls discussed utility functions returns false iff strings equal 
returns copy string error format arg 
prints message causes program exit 
nbytes calls malloc dying error message memory 
appendix code single stroke gesture recognition training bit vector operations efficient set functions accessing array bits 
clear bit vector bv resets entire bit vector bv zeros bit set bv sets ith bit bv bit clear bv sets ith bit bv zero 
vector matrix functions declared matrix objects type vector matrix accessed dimensional arrays respectively contain additional information size dimensionality object accessible macros ndim 
obvious names functions 
remaining functions double vector matrix computes quantity mv prime denotes transpose operation 
matrix matrix bitvector bitvector creates new matrix consisting rows columns set respectively 
matrix matrix double fill bitvector bitvector matrix result sets element result fill element result row number set corresponding element input matrix smaller result fill result copy legal values parameters 
auxiliary functions version gdp available partof ftp distribution mentioned 
bibliography apple 
inside macintosh 
addison wesley 
apple 
macintosh system software user guide version 
apple computer 
okada masuda 
line recognition handwritten characters 
proceedings th international joint conference pattern recognition pages 
baecker 
characterization graphical interaction 
editor methodology interaction pages 
north holland 
baecker buxton 
readings human computer interaction approach 
morgan readings series 
morgan kaufmann los altos california 
ronald baecker ian small richard mander 
bringing icons life 
chi pages 
acm april 
bentley 
multidimensional binary search trees associative searching 
commu acm 

learning syntactic recognition symbols drawn 
computer graphics image processing 
block dannenberg 
polyphonic accompaniment real time 
music conference cambridge mass 
computer music association 

personnel communication 

mathews schloss 
radio drum synthesizer controller 
international computer music proceedings pages 
computer music association november 
bolt 
human interface people computers meet 
lifetime 
bibliography 
recognition line cursive handwriting case multi perception 
phd thesis state university new york buffalo march 
buxton 
chunking phrasing design human computer dialogues 
processing north holland 
elsevier science publishers buxton 
interaction meets eye issues manual input norman draper editors user centered systems design new perspectives human computer interaction pages 
lawrence erlbaum associates hillsdale 
buxton 
smoke mirrors 
byte july 
buxton 
state model graphical input 
proceedings interact august 
buxton hill rowley 
issues techniques touch sensitive tablet input computer graphics 
buxton myers 
study handed input 
proceedings chi pages 
acm 
buxton reeves baecker 
user hierarchy instance ina data structure computer music 
curtis roads john editors foundations computer music chapter pages 
mit press cambridge massachusetts 
buxton reeves patel baecker 
evolution score editing tools 
curtis roads john editors foundations computer music chapter pages 
mit press cambridge massachusetts 
card moran newell 
keystroke level model user interactive systems 
communications acm 
cardelli pike 
squeak language communicating mice 
siggraph proceedings april 
carr 
point pen 
byte february 
michael coleman 
text editing graphic display device hand drawn 
nievergelt editors pertinent concepts computer graphics proceedings second university illinois conference computer graphics pages 
university illinois press urbana chicago london 
cooper 
hyperplanes hyperspheres decision boundaries 
tou wilcox editors computer information sciences pages 
spartan washington 
bibliography brad cox 
message object programming evolutionary change programming tech nology 
ieee software january 
brad cox 
object oriented programming evolutionary approach 
addison wesley 
dannenberg 
structure representing displaying editing music 
proceedingsof international computer music conference pages san francisco 
computer music association 
duda hart 
pattern classification scene analysis 
wiley interscience 
economist 
digital 
economist september 

reach touch data 
byte july 
english engelbart berman 
display selection techniques text lation 
ieee transactions human factors electronics hfe 
fels geoffrey hinton 
building adaptive interfaces neural networks talk pilot study 
technical report crg tr university toronto toronto canada 
fisher 
multiple measurements taxonomic problems 
annals 

specifying complex dialogs 
sigchi gi proceedings april 
fu 
syntactic recognition character recognition volume mathematics engineering 
academic press 
fu 
hybrid pattern recognition 
fu kittler pau editors pattern recognition theory applications nato advanced study institute pages 
reidel 
fu 
syntactic pattern recognition applications 
prentice hall 
fu yu 
statistical pattern classification contextual information 
image processing series 
research studies press new york 
gettys newman 
xlib language interface 
technology 
dario 
dp command set 
technical report cmu ri tr carnegie robotics institute october 

startup pound stylus pc 
pc week august 
bibliography adele goldberg david robson 
smalltalk language implementation addison wesley series computer science 
addison wesley 
goodman 
complete hypercard handbook 
bantam books 
granlund 
fourier preprocessing hand print character recognition 
ieee transac tions computers february 
guyon albrecht le cun denker hubbard 
design neural recognizer touch terminal 
pattern recognition 
hand 
kernel discriminant analysis 
pattern recognition image studies series 
research studies press division john wiley sons new york 
hauptmann 
speech gestures graphic image manipulation 
chi pro ceedings pages 
acm may 
frank hayes 
true notebook computing arrives 
byte pages december 
hayes szekely lerner 
design alternatives user interface experience cousin 
chi proceedings pages 
acm april 
henry hudson newell 
integrating gesture snapping userinterface toolkit 
uist pages 
acm 
higgins 
line cursive script recognition 
shackel editor human computer interaction interact ifip pages north holland 
elsevier science publishers hill 
supporting concurrency communication synchronization human 
acm transactions graphics july 
hollan rich hill grudin human interface laboratory 
hits human interface tool suite 
technical report aca hi microelectronics computer technology austin texas 
bruce horn 
object oriented programming inheritance 
technical report cmu cs carnegie mellon university computer science department 
toussaint donaldson 
results obtained sim ple character recognition procedure munson data 
ieee transactions computers february 
bibliography hutchins hollan norman 
direct manipulation interfaces 
norman draper editors user centered system design pages 
lawrence erlbaum associates hillsdale 
software control stroke pen 
siggraph video review edited compilations chi 
acm 
itakura 
minimum prediction residual principle applied speech recognition 
ieee trans acoustics speech signal processing assp 
jackson 
circling method mouse button presses 
chi proceedings pages 
acm may 
mike james 
classification algorithms 
wiley interscience 
john wiley sons newyork 
johnson 
model view controller 
november unpublished manuscript 
dan olsen jr graphical user interface generator 
computer graphics july 
morse jr world 
byte august 
kernighan ritchie 
programming language 
prentice hall 
kim 
gesture recognition feature analysis 
technical report rc december 
nancy 
variations model view controller 
journal object oriented program ming september october 

feature extraction optical character recognition machine 
ieee computers 
glenn krasner stephen pope 
description model view controller userinterface paradigm smalltalk system 
journal object oriented programming august 

artificial reality 
addison wesley reading ma 

artificial reality 
inproceedings chi pages 
acm 

advanced engineering mathematics 
wiley 
fourth edition 

principles multivariate analysis user perspective 
science series 
clarendon press oxford 
bibliography kurtenbach buxton 
test bed editing contiguous gestures sigchi bulletin pages 
martin lamb veronica buckley 
new techniques gesture dialog 
shackel editor human computer interaction interact ifip pages north holland 
elsevier science publishers brooks newell 
line acquisition handwritten shorthand means rapid data entry 
shackel editor humancomputer interaction interact ifip pages north holland 
publishers barbara staudt lerner 
automated customization user interfaces 
phd thesis university 
linton vlissides calder 
composing user interfaces interviews ieee computer february 
james 
trainable gesture recognizer 
pattern recognition 
ibm tech report rc 
lyons 
go gains ground pen software race 
pc week july 
gale martin james pittman kent wittenburg richard cohen 
sign please 
byte july 
maxwell 
mockingbird interactive composer aid 
master thesis mit 

sensor frame gesture device manipulation 
available sensor frame pittsburgh pa december 

telltale gestures 
byte july 
margaret minsky 
manipulating simulated objects real world gestures position sensitive screen 
computer graphics july 
samuels 
clarifying distinction lexical gestural commands 
inter national journal man machine studies 
muller 
high music notation interactive editing input keyboard 
proceedings international computer music conference pages san francisco 
computer music association 
hiroshi murase toru 
online hand sketched recognition 

myers buxton 
creating highly interactive graphical user interfaces 
computer graphics 
bibliography myers 
new model handling input 
acm transactions information systems 
myers dannenberg vander zanden marchal 
garnet comprehensive support graphical user interfaces 
ieee computer nov 
myers vander zanden dannenberg 
creating graphical objects demonstration 
uist proceedings acm siggraph symposium user interface software technology pages 
acm november 
brad myers 
taxonomy user interfaces window managers 
ieee applications 
brad myers 
encapsulating interactive behaviors 
human factors pages austin tx april 
proceedings sigchi 
brad myers 
user interface tools survey 
ieee software january 
brad myers 
demonstration interfaces step direct manipulation 
cmu cs carnegie mellon school computer science pittsburgh pa august 
brad myers 
taxonomies visual programming program visualization 
journal languages computing march 
nakatani 
personal communication bell laboratories murray hill january 

manual 
information technology center pittsburgh pa 
newman sproull 
principles interactive computer graphics 
mcgraw hill 

system manual 

norton wayne 
coding approach pattern recognition 
kittler fu pau editors pattern recognition theory applications nato advanced study pages 
reidel 
barron 
time get fired 
byte august 
hansen kazar sherman stern bader peters 
andrew toolkit overview 
proceedings usenix technical conference pages dallas february 
bibliography pc computing 
featherweight division 
pc computing december 

touch sensitive screens application 
man machine studies 
probst 
blueprints building user interfaces open look toolkits 
technical report august 
james catherine wolf 
gestural interfaces information processing ap plications 
technical report rc ibm watson research center ibm box yorktown heights ny september 
rosenberg hill miller 
uimss threat chi pages 
acm 
rubine 

international computer 
computer music association september 
rubine 
programmable finger tracking instrument controllers 
journal 
scheifler gettys 
window system 
acm transactions graphics april 

application framework 
byte august 
kurt 
object oriented programming macintosh 
hayden book com 
shaw 
parsing graph representable pictures 
jacm 
shneiderman 
direct manipulation step programming languages 
ieee com puter pages august 
john sibert william hurley teresa 
object oriented user system 
siggraph pages 
acm august 
jack 
pattern classifiers trainable machines 
springer verlag new york 
stallings 
recognition printed chinese characters automatic pattern analysis computer graphics image processing 
mark stefik daniel bobrow 
object oriented programming themes variations ai magazine winter 
jess stein editor 
random house dictionary english language 
random house cambridge mass 
bibliography martin sternberg 
american sign language comprehensive dictionary 
harper new york 
stone 
touch screens intuitive input 
pc magazine pages august 
suen mori 
automatic recognition characters art 
proceedings ieee april 
sun 
programmers guide 
sun mountain view ca 
sun 
news preliminary technical overview 
sun mountain view ca 
tamura kawasaki 
recognition sign language motion images 

suen toru 
state art line 
ieee transactions pattern analysis machine intelligence august 

man machine 
byte september 
tevanian 
mach basis unix development 
technical report cmu cs carnegie mellon university computer science dept pittsburgh pa 
touretzky pomerleau 
hidden hidden layers 
byte august 

automatic recognition words 
int 
man machine studies 
waibel hampshire 
building blocks speech 
byte august 
wasserman 
extending state transition diagrams specification human 
ieee transactions software engineering se august 
weimer 
synthetic visual environment hand gesturing input 
chi proceedings pages 
acm 

note method calculating corrected sums squares products technometrics august 
witkin 
scale space filtering 
proceedings international joint conference intelligence pages 
wolf 
comparative study gestural keyboard interfaces 
proceedings factors society nd annual meeting 
bibliography wolf 
taxonomic approach understanding direct manipulation proceedings human factors society st annual meeting 
catherine wolf 
people gesture commands 
technical report rc april 
xerox 

siggraph video review issue chi compilation acm 
