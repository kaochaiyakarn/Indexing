new page table bit address spaces computer architectures moving bit virtual address spaces 
discuss change impacts conventional linear hashed page tables 
introduce new page table data structure clustered page table viewed hashed page table augmented 
specifically associates mapping information pages sixteen single virtual tag pointer 
simulation results workloads show clustered page tables memory alternatives adversely affecting page table access time 
physical address space increasing computer architects new techniques superpages complete increase memory mapped translation lookaside buffer tlb 
techniques completely ineffective page table support look extending conventional clustered page tables support 
simulation results show clustered page tables support superpage subblock tlbs especially 
mark hill khalidi computer sciences department sun microsystems laboratories university wisconsin garcia ave mtv madison wi usa mountain view ca usa cs wisc edu madhu eng sun com long standing computer trend programs memory usage doubles year 
theoretically systems support paged virtual memory increase virtual physical address sizes linearly year 
practice primarily supported national science foundation presidential young investigator award mips sun microsystems external research 
experiments performed equipment donated sun microsystems 
copyright association computing machinery 
acm ty issues force address spaces grow discontinuously especially virtual addresses 
industry currently undergoing discontinuity processor architectures moving bit virtual addresses modestly increasing size physical addresses 
things equal increasing address space size adversely affects page table translation lookaside buffer tlb cost performance 
explores effect bit addresses page tables 
address virtual address explicitly identify physical address 
page table stores translation protection attribute status information virtual addresses huck chan levy lee 
information page called page table entry pte 
tlb handler accesses page table tlb load appropriate pte tlb 
ideal page table facilitate fast tlb handler little virtual physical memory flexibly support operating systems page table modifications 
section reviews conventional page tables linear forward mapped hashed discusses challenges extending conventional page tables support bit address spaces 
explains linear hashed page tables viable bit addresses page tables probably impractical tlb requires memory 
processors support tlb handling software mips kane alpha site parc yung 
page table design operating system issue explore alternate operating system data structures storing page tables servicing tlb misses 
section introduces central contribution clustered page table 
new page table data structure viewed hashed page table augmented simple effective technique hardware caches tlbs hill tall 
hashed page tables associate tag pte 
clustered page tables associate single tag aligned group consecutive pages sixteen kb pages called page block 
clustered page tables effective spatial locality consecutive pages contemporaneous 
assumptions section example clustered page table pages page block uses memory hashed page table pages populated 
experimental results show clustered page tables memory best conventional page tables linear page tables dense address spaces hashed page tables sparse address spaces 
hardware designers increasing effectiveness tlbs bit systems techniques superpages tall kane tall 
techniques effective improving tlb performance reducing number tlb misses providing average execution time speedup upto workloads tall 
support page table store ptes tlb handler traverse page tables tlb techniques completely ineffective 
page tables support conventional single page size tlbs superpage subblock techniques reduce page table size order magnitude get better cache performance 
sections second contribution extending page tables support superpage subblock ptes 
suggest replicating ptes base site way extend conventional page table support new pte formats affecting tlb penalty 
alternate solutions drawbacks usable specific situations 
section shows clustered page tables ideal supporting medium superpages subblocks result smaller page tables retaining fast tlb handling time flexibility 
section gives preliminary performance numbers simulating bit workloads 
show clustered page tables memory page table faster access superpage subblock ptes 
clustered page tables example memory required hashed page tables workloads 
simulate tlb page table organizations calculate estimated page table access time 
appendix includes formulae estimating number cache misses tlb handling page table size different page tables 
section includes discussion tradeoffs extensions optimizations page table organizations described 
section reiterates contributions 
extensions conventional page tables bit address spaces section reviews commonly page tables linear forward mapped hashed discusses extending support bit virtual addresses 
detailed description huck hays huck 
page table designs bit address mapping information require bytes physical addresses restricted bits 
illustrates example mapping information contains valid bit bit ppn bit physical address kb pages bits software hardware attributes reserves pad bits 
little endian notation number bits significant bit bit 
pad ppn attr example pte format bit address spaces linear page table conceptually stores ptes process single array 
array indexed virtual page number vpn depicted 
complete linear page tables large partially populated 
consequently reside virtual address space page faults dynamically populate table vax levy mips kane 
consequently ptes allocated page time space overhead high address space sparsely 
separate data structure stores mappings page table 
hardware software searches data structure nested tlb attempting access linear page table virtual address 
multi level tree linear page tables commonly ultrix uses level tree osf uses level tree mips nagl 
straightforward extension linear page tables bit addresses uses virtual array entries level tree 
design practical portion tlb reserved mappings page tables nagl tree rarely traversed 
alternatively data structure store mappings linear page table hashed page table forward mapped page table described 
virtual address vpn offset linear page table kb page size forward mapped page tables store ptes ary trees level tree indexed fixed address fields vpn 
leaf nodes store ptes intermediate nodes store pointers level sparc mmu spar 
extending bit address space extends number levels 
page tables impractical bit address spaces overhead memory accesses tlb acceptable 
techniques short circuit levels guarded page tables region lookaside buffers chan partially effective require levels 
base vpn page table base address data structure mappings page tables root level table pointer pb tb offset 
forward mapped page table array ptes large address space systems hashed inverted page tables lee chan rose huck 
simplest implementation uses open hash table hash function maps vpn bucket 
pte hash table stores mapping information page tag identifying vpn pointer 
hash tables chaining handle overflows 
page table look level tables ptp page table pointer pte page table entry physical address level tables ptes hash function indexes array hash nodes elements hash buckets traverses hash bucket pte tag matching faulting address 
ptr hash table vpn ptr null ptr ptr tag match ptr faulting tag return ptr mapping virtual address vpn offset hash hash base open hash table vpn tag hashed page table entry format pad ppn attr byte words hashed page table extending hashed page tables bit addresses straightforward 
drawback tag pointers bytes resulting sixteen bytes overhead bytes mapping information 
variations hashed tables include inverted page tables software tlbs 
inverted page tables ibm system ibm hash array pointers dereferenced obtain element hash bucket 
software tlbs huck tsb yung bala powerpc page table eliminate hashed page table pointers pre allocating fixed number ptes bucket 
named viewed memory resident level tlbs overflow handled ways 
innovations develop hashed page tables applicable inverted page tables software tlbs 
due space constraints describe hashed page tables 
inverted page tables software tlb variations described tall 
multi level linear page tables page tables ary trees important differences 
multi level linear page tables accessed bottom fashion require intermediate node page accessed virtual addresses 
forward mapped page tables accessed top fashion different branching factors intermediate nodes accessed physical addresses 
page table bit systems 
linear page tables ptes page page table perform poorly sparse address spaces 
hashed page tables fixed overhead regardless address space dense sparse overhead sixteen bytes bytes 
low overhead linear page tables common case dense address space retaining graceful degradation hashed page tables sparse 
introduce clustered page tables achieve goal 
clustered page table central contribution clustered page tables 
variant hashed page tables store mapping information consecutive pages sixteen single tag pointer 
dense address space spatial overheads hashed page tables 
sparse address space overheads linear page tables sixteen kb mappings need allocated 
addition clustered page tables perform ideally cases consecutive pages medium sized objects buffers 
section introduces clustered page tables pages single page size kb base pages 
section extends superpage subblock tlbs 
clustered page table uses extend hashed page table 
node hash table stores tag stores mappings multiple base pages belong page block aligned group consecutive pages 
number base pages page block subblock factor 
shows format clustered pte subblock factor open hash table constructed 
page tables effective programs store mappings groups contiguous virtual pages 
programs map objects address space pages long 
objects may scattered address space 
address space programs bursty arbitrarily sparse mappings isolated base pages 
clustered page tables exploit property storing mappings set contiguous virtual pages single pte hash table support sparse distribution objects 
virtual address hash base tag pad ppn pad ppn pad ppn pad ppn offset attr attr attr attr open hash table format clustered pte subblock factor clustered page table page table operations clustered page table similar hashed page table 
page table lookup example virtual page number split virtual page block number block offset 
participates hash function block offset indexes array mappings pte matching tag 
tlb handling identical hashed page table traversing hash list differs finding pte matching tag ptr hash table ptr null ptr ptr tag match ptr faulting tag return ptr mapping uses subblock factor simplify illustration 
real implementations larger subblock factor sixteen determined issues 
larger subblock factors reduce overhead entries increase overhead mappings sparse 
second larger subblock factors pack mappings consecutive pages close improving spatial locality potentially reducing cache misses servicing tlb misses 
size block mappings larger cache line may place tag mapping information different cache lines potentially causing additional cache tlb compare clustered hashed page tables 
clustered page tables amortize pte overhead potential mappings 
page table size smaller mappings 
subblock factor sixteen example clustered page table uses memory hashed page table mappings third memory 
clustered page tables require memory hashed page tables address space sparse 
choice subblock factor take account degree sparseness 
support address spaces varying degree sparseness clustered page tables generalize include ptes varying subblock factors small increase page table access time extra instructions tlb handler better memory utilization tall 
clustered page tables store mappings multiple base pages single pte 
reduces number ptes page table results shorter hash table lists hash table fewer buckets 
shorter hash table lists reduce hash table search time tlb misses knut 
clustered page tables worse page table access time cache performance tlb misses worse tag mapping information reside separate cache lines 
clustered page table support page table manipulations page tables support operations 
emphasizes supporting address translation tlb misses 
section qualitatively discusses advantages disadvantages clustered page tables relative hashed page tables operations important operating systems including adding mapping changing mappings virtual address range synchronization multi threaded operating systems 
quantitative evaluation possible simulation methodology section await full fledged operating system implementation 
page tables support adding mapping 
hashed page tables adding mapping incurs fixed overhead memory allocation list insertion tag initialization pte added page table 
clustered page tables amortize overhead allo memory pte inserting hash list multiple pte insertions page block 
important benefit programs show spatial locality access patterns 
second operation operating systems modifying ptes virtual address space range 
hashed page tables requires searching hash table base page 
clustered page tables require searching hash table page block efficient 
page tables support multi threaded operating systems synchronization protocol coordinate concurrent page table operations 
synchronization protocol significantly affect performance 
hashed clustered page tables may associate lock hash bucket 
executing range operation clustered page tables require operating system acquire single lock entire page block base page hashed page tables 
allows efficient range operations restrict concurrent page table lookups neighboring base virtual pages tlb handling multiprocessor system 
critical tlb handlers typically access page tables update modified bits acquiring locks 
powerpc example defines synchronization algorithm page table updates accounts unorthodox behavior tlb handlers may 
systems require tlb handlers acquire locks readers writer locks allow multiple tlb lookups parallel 
review proposals new tlb techniques require page table support effective 
discuss extending page tables support tlbs 
demonstrate additional advantages clustered page tables 
adapting conventional page tables superpage subblock ptes section section second contribution discussing page table changes needed superpage subblock tlbs described effective 
potential advantages adding support 
new tlbs reduces number tlb misses provides average execution time speedup upto workloads tall 
second superpage partial subblock ptes described store mapping information compactly conventional ptes decreasing page table memory usage 
review new tlb techniques examine adapting conventional page tables support superpages partial prefetching complete subblock tlbs 
superpage subblock tlbs tlb cache entries hold ptes mile 
conventional tlb entry vpn process id tag physical page number ppn protection information page modified bit data 
bit addresses hardware designers increasing effectiveness tlbs support superpages tall tall 
superpages linear address space conventional paging sizes multiples base page size aligned virtual physical memory tall 
processors support superpages mips kane ultrasparc yung alpha site powerpc supporting superpages easier supporting segments dimensional address space may arbitrarily long may start arbitrary physical addresses orga 
mips kane example supports kb base page size superpages kb kb kb mb mb mb 
large superpages kb larger useful kernel data frame buffer database buffer pools usually large superpages mappings may setup limited changes existing operating systems 
medium superpages kb kb require substantial operating system changes provide mechanisms support policies choosing appropriate page sizes tall rome 
associates multiple tlb tag tall 
subblock factor sixteen kb pages example tag covers aligned kb block virtual addresses 
mips kane processors support subblock factor tlb 
effective spatial locality consecutive pages contemporaneous 
disadvantage tlb data area larger conventional tlbs data contains multiple 
way reduce area store single ppn require physical pages mapped single tlb entry placed single aligned block physical memory properly placed 
pages properly placed multiple tlb entries 
call tlb design partial complete refer subblock design tall 
partial subblock tlb entry superpage tlb entry allows subset base page mappings valid specified valid bit vector bottom 
superpage base pages valid properly placed partial subblock pte base pages memory fifteen sixteen pages memory resident 
superpages partial effective operating systems properly place virtual pages physical memory 
proposed algorithm page reservation described tall tall 
superpages partial require support page table store mappings tlb handler traverse page tables 
page tables support finding pte tlb faulting address knowing page size starting access significantly increasing tlb penalty 
best knowledge current commercial operating systems include memory allocation page table support rendering hardware tlb extensions useless 
sz pad ppn attr superpage mapping power size sz pad ppn attr partial subblock mapping unused bits ppn subblock factor superpage partial subblock mapping format naive way supporting superpage subblock tlbs single page size page table construct superpage subblock ptes tlb handler ptes compatible new tlb formats 
requires tlb handler search page table ptes base virtual pages virtual page block faulting virtual address 
hashed page tables expensive ptes neighboring base virtual pages different hash buckets 
linear forward mapped clustered page tables ptes stored contiguously compatibility check expensive tall 
efficient way modify page tables store superpage partial subblock ptes 
proposed partial subblock tlbs aware commercial processors implement today 
operating system 
subsections show ways modify conventional page tables 
section show additional advantages clustered page tables storing superpage partial subblock ptes 
supporting superpages discuss adapting conventional page tables support superpage ptes top 
solutions supporting superpages page table replicate ptes multiple page tables 
replicate ptes 
solution stores superpage pte page table site base page pte covered superpage 
information kb superpage gets repeated sixteen base pte sites 
tlb handler finds mapping address contained base page ends loading mapping superpage 
solution satisfactory 
simple 
facilitates better tlb performance conventional tlb permitting superpage ptes reduce frequency tlb misses having affect tlb penalty 
drawbacks 
allow superpages page tables smaller 
second replicated ptes adding atomic update superpage ptes complex multi threaded operating systems 
multiple page tables 
solution creates page table page size set page sizes 
tlb handler accesses page tables 
mapping examines page table 
page tables probably sequenced page size cause tlb smallest largest page size 
solution appears solution 
principal disadvantage tlb handling slower tlb misses go page size 
furthermore spatial overhead supporting page tables mitigates potential improve page table size 
linear page tables ptes different page sizes share page table pages 
hashed page tables hash buckets set page size 
simple variation multiple page table approach uses page table store ptes different page sizes examines multiple times different page sizes 
feasible hashed clustered page tables logical page tables share buckets cost longer hash chains 
ptes linear page table definition page size multiple page tables combined 
superpage strategies specific page tables 
linear intermediate nodes 
linear page tables multi level tree structure store superpage ptes intermediate tree nodes 
kb base pages byte ptes example entry level intermediate nodes points page ptes 
solution allows intermediate node entry point superpage covering virtual space mb kb 
solution supports superpages modest increase tlb handling time decide intermediate node superpage pte points level 
tlb handler access base pte site incur nested tlb key disadvantage lack flexibility 
supports page sizes correspond intermediate nodes example mb gb gb tb pb 
particular supports medium size superpages 
forward mapped intermediate nodes 
page tables multi level tree structure store superpage ptes intermediate tree nodes sparc mmu spar hal chan support fixed superpage sizes fashion 
possible extend page tables support arbitrary superpage size varying tree branching factor dynamically 
software traversed forward mapped page table flexible support linear page tables number ptes page fixes branching factor hardware traversed page tables fixed branching factors 
solution may increase levels tree long tlb handling time forward mapped page tables longer 
superpage index hashed 
way support superpages conventional hashed page table assume specific superpage size hash function associate bucket appropriate superpage base page ptes 
tall describe similar scheme hardware tlbs set associative tlbs support page sizes superpage index 
hash kb superpages example find particular kb region mapped kb superpage sixteen kb base pages kb superpages base pages result sixteen ptes chained bucket ptes mapping bucket 
solution longer hash chains increase tlb handling time 
addition superpages larger size selected hashing handled way 
summary replicate pte method probably best method far supporting superpages conventional page tables decreases frequency tlb misses increasing tlb penalty 
large superpages mb hand may handled ad hoc basis mappings tlb 
supporting partial subsection applies superpage page tables supporting partial subblock ptes bottom 
advantages supporting partial subblock ptes superpage ptes fold 
partial subblock tlbs effective superpage tlbs tall 
second partial subblock ptes reduce page table size effectively superpages 
third partial requires simpler operating system support superpages tall 
fourth partial subblock pte natural intermediate format page tables construct superpage ptes incremental fashion 
disadvantage large subblock factors larger practical due limited number valid bits pte 
page table support partial subblock ptes similar supporting base page size medium superpage size equal base page size times subblock factor 
partial subblock pte resides page table exactly corresponding superpage pte resided 
page blocks partial subblock ptes base page ptes 
complex optimizations possible tall 
extensions described section superpage ptes applicable storing ptes 
differences include replicated ptes adding deleting mapping part partial subblock pte requires modification multiple ptes superpage ptes tend explicit operating system directed page promotion demotion 
multiple page tables order searching page tables favor partial subblock ptes base page table partial subblock ptes accessed base page ptes 
superpage index hashed page tables partial subblock ptes reduce length hash lists 
superpages multiple base page ptes added hash bucket typically partial subblock ptes replace base page ptes 
prefetch support complete subblock tlbs hardware technique increasing memory mapped tlb complete 
complete subblock tlb entry tag subblock factor number attribute fields similar clustered pte 
complete subblock tlb requires special operating system page table support 
tlb handler merely searches page table base page pte loads tlb exactly size system 
closer look complete subblock tlbs reveals block misses subblock misses 
block misses allocate new tlb entry replacing old entry associated mappings 
subblock misses add new ppn attribute information existing tlb entry causing replacement 
subblock misses eliminated block loads prefetches mappings associated tag mips ptes kane 
example tlb virtual address tlb handler mips prefetch mappings virtual pages 
subblock prefetching tlb replacing useful mappings causes extra replacements hill reduces number tlb misses significantly tall 
drawback subblock prefetching increased time service tlb block misses 
penalty large hashed page tables multiple hash probes needed 
penalty reasonable linear forward mapped clustered page tables additional mappings reside adjacent page table memory 
addition penalty reduced modifying clustered pte format match format corresponding complete subblock tlb entry exactly 
partial subblock superpage ptes clustered page tables section examines incorporating clustered page tables 
step natural node clustered page table base pages resembles complete subblock tlb entry 
section incorporates superpages clustered page tables 
tag pad ppn attr pad ppn attr pad ppn attr pad ppn attr clustered pte complete subblock pte tag pad ppn attr partial subblock pte tag sz pad ppn superpage pte attr clustered pte variations match partial subblock tlbs clustered page tables best subblock factor 
top illustrates clustered pte subblock factor array base page mappings 
clustered page table essentially complete subblock hashed page table clustered pte called complete subblock pte 
center illustrates partial subblock pte 
shows partial subblock pte fits clustered page table 
tlb handler hashes walks hash chain usual 
match handler consults new field reads appropriate mapping 
field subblock superpage distinguishes partial subblock superpage discussed pte base page ptes reside page table 
key tlb handler sees difference regular clustered page table traversing hash list matching tags differs reading mapping 
able service tlb misses partial subblock base page ptes increasing tlb penalty memory partial subblock ptes 
ptr hash table ptr null ptr ptr tag match ptr faulting tag return ptr mapping ptr mapping ptr mapping hash base offset virtual address open hash table storing partial subblock superpage ptes clustered page tables superpage support straightforward 
bottom illustrates support superpage size virtual page block 
superpage pte similar partial subblock pte valid bit 
smaller superpages supported sz field identify 
example allow node kb superpages 
support kb superpage kb base pages kb page block nodes hash chain kb superpages valid base pages valid 
support requires tlb handler continue searching hash chain tag match fails find valid mapping tall 
larger superpages supported ways 
replicate ptes solution replicate clustered pte base page pte 
subblock factor sixteen example clustered page table supports large superpages factor sixteen overhead conventional page tables 
second continue ad hoc method previously developed conventional page tables particular multiple page table approach reasonable tlb misses large superpages frequent 
supporting superpages partial subblocks clustered page tables offers advantages extending hashed page tables 
hash chain remains short hashed page tables require longer hash chains base pages 
second partial subblock superpage ptes reduce hashed clustered page table size clustered page tables increase tlb penalty hashed page tables 
adding superpage partial subblock ptes clustered page tables change hash table structure modify size ptes 
hashed page tables hand require multiple page tables probes suboptimal hash functions storing superpage partial subblock ptes 
third clustered page tables simplify incremental creation superpage ptes storing mappings consecutive base pages 
operating system notices base page mappings node valid decide promote superpage 
gathering information page tables efficient 
summary clustered page tables base pages memory hashed page tables combining mappings neighboring base virtual pages nearly identical tags single pte single tag 
section took clustered page table step support superpages partial combining mappings neighboring base virtual pages nearly identical single pte 
straightforward support superpages partial clustered page table tall 
performance evaluation section presents simulated performance results page tables discussed far 
estimates page table size page table access time tlb penalty metrics 
numbers approximate example compute cache misses saved smaller page table 
find clustered page tables space accessed faster conventional page tables 
performance relative conventional page tables improves supporting superpages partial 
simulation methodology metrics ultimate measure performance program execution time 
unable measure execution time real system reasons 
requires implementing different page table organizations commercial operating system 
implementing single page table organization multi man year project scope 
second evaluating tlbs page tables support medium sized superpages complete partial subblock tlbs 
access sparc machine supports medium sized superpages current processor includes subblock tlbs study 
include tlb simulator kernel simulate tlbs count number tlb misses 
perform study running solaris 
modified operating system ways 
implemented policies mechanisms operating system support medium sized superpages partial subblock tlbs 
dynamic page size assignment policy chooses base page size kb superpage size kb detailed description available tall tall 
physical memory allocation algorithm page reservation allocates aligned physical pages virtual pages detailed description available tall tall 
memory allocation partial subblock tlbs effective superpage creation efficient 
second added mechanism trap tlb misses trap driven simulation 
mechanism drive tlb simulator counts number tlb misses different target tlbs tlb configurations different hardware tlb 
third include page table simulator builds hashed clustered page tables 
counts number cache lines accessed hardware tlb identical target tlb simulated page table fully implemented kernel 
note replace solaris native page table implementation new page tables 
base cases assume entry fully associative tlbs kb base pages appropriate subblock factor sixteen superpage size kb 
assume byte level cache line size accessing page tables 
assume hash buckets hashed clustered page tables 
discuss sensitivity analysis assumptions space limitations prevent full presentation tall 
study page table size 
page table size significant affect cache behavior page tables smaller available physical memory affect page faults negligible 
smaller page tables expected result higher cache hit rate lower cache pollution significantly improve system performance 
yoo rogers yoo example observed improvement execution time due cache tlb effects reducing page table size commercial database workload 
private address space model process page tables smaller page table size process large server system thousands active processes translates significant savings 
metric page table size page table size normalized hashed page table size 
estimate page table size step process 
take snapshot workload mappings point near program maximum memory 
second information generate alternate page tables additional assumptions 
mapping information takes bytes 
linear page tables minimum possible level tree 
show level numbers assume intermediate nodes stored data structure takes zero space 
forward mapped page tables level tree 
hashed clustered page tables overhead sixteen bytes pte store tag pointers 
compute page table size multiprogrammed workload sum page table sizes constituent programs 
study page table access time 
regrettably simulation environment allow measure directly 
average number cache lines accessed handle tlb indirect metric 
metric proportional page table access time level cache rarely contains page table data overheads minimal 
drawbacks metric 
important ignores page table data may cache particularly page tables smaller store ptes exploit spatial locality 
expect access times clustered page tables page table memory better results report 
second metric ignores initial overhead tlb penalty independent page table type 
third neglects time execute tlb handler instructions 
allows metric account hardware tlb handlers typically take time proportional number memory accesses 
software tlb handling instruction overhead hand coded tlb handlers expected small generation superscalar processors execute instructions cycle compared main memory access cycles 
estimate average number cache lines accessed tlb follows 
modified operating system simulate hashed clustered page tables 
tlb evaluation system traps operating system providing faulting address 
page table traversal calculate number cache lines accessed 
estimate cache lines assuming pte starts cache line boundary 
linear page tables access cache line occasionally access higher tree levels 
approximate reserving tlb entries higher tree level mappings assuming tlb remaining entries accesses cache line 
bit workloads reserved tlb entries sufficient take nested trap assume forward mapped page tables access cache line tree level 
storing superpage partial subblock ptes assume linear forward mapped page tables replicate pte approach hashed page tables separate page tables kb kb page blocks kb page table searched 
normalize number cache lines accessed number tlb misses incurred entry tlb independent page table type 
linear page tables estimate number cache lines accessed tlb entries normalize number tlb misses entry tlb 
metric includes opportunity cost reserved tlb entries 
workloads selected bit workloads spend significant time tlb handling 
nasa compress wave spice gcc spec suite spec nas benchmark bail operating matrix mp pthor uniprocessor versions splash benchmark suite sing coral rama deductive database executing nested loop join ml executing stress test garbage collector 
compress gcc multiprogrammed workloads 
programs negligible tlb ratios benefit page table enhancements 
emphasizing workloads tlb handling important results overestimate potential benefit workloads small processes 
expect bit workloads object oriented programs larger sparser address spaces 
workloads tlb page table effects important hashed clustered page tables attractive 
workload total time user time seconds user tlb misses user time tlb handling memory hashed page table coral kb nasa kb compress kb kb wave kb mp kb spice kb pthor kb ml kb gcc kb kernel space kb table workload characteristics 
save reserved tlb entries context switches 
table displays workload data workloads sorted percent user time spent tlb handling 
column gives total execution time user time parenthesis showing workloads spend time user mode 
columns give number user tlb misses entry fully associative single page size tlb percent user time spent servicing misses assuming cycle tlb penalty showing user tlb handling time significant 
column shows amount memory hashed page table map workload 
results discuss page table size 
displays relative page table sizes normalized hashed page table size various workloads single pagesize system base page size kb 
truncates values 
important observation clustered page tables asterisk marked memory best conventional page tables workloads 
dense address spaces coral ml kernel clustered page tables comparable better linear page tables 
sparse address spaces gcc compress clustered page tables memory hashed page tables 
coral nasa compress wave linear level linear level mp spice pthor ml gcc kernel forward mapped clustered page table size single page size page tables 
normalized hashed page table size 

gcc compress multiple processes sh script small sparse address spaces 
workloads measure page table usage main program 
zeroes page tables memory hashed page tables normalized page table size 
adds variations superpages partial store mappings multiple base pages single pte 
superpage ptes clustered page tables reduces memory usage upto comparing circles asterisks partial subblock ptes upto comparing triangles asterisks 
superpage mappings similarly improves hashed page table size squares 
corresponding improvements possible linear forward mapped page tables assume replication ptes 
coral nasa compress wave hashed superpage clustered superpage mp spice pthor ml gcc kernel clustered partial subblock clustered hashed clustered page table sizes kb base pages kb superpages subblock factor 
normalized hashed page table size 
discuss page table access time tlb misses various workloads page tables coarse metric average number cache lines accessed tlb graph assumes different fully associative entry tlb design 
assumes single page size tlb tlb support superpages subblocks 
results show forward mapped page tables perform unacceptably designs similar 
surprising metric reward compact clustered page tables 
clustered page tables shorter hash lists relative hashed page tables reducing number accesses cases ml 
results linear page tables optimistic due assumptions discussed section 
coral coral nasa compress wave mp spice pthor ml gcc single page size tlb kb kb superpage tlb nasa compress wave mp spice pthor ml gcc partial subblock tlb subblock factor complete subblock tlb subblock factor linear forward mapped hashed clustered average number cache lines accessed tlb entry fully associative tlbs results tlb page tables support superpages 
shown superpages reduces tlb frequency tall main reason supporting superpage ptes page table 
shown number cache lines accessed remaining misses 
results modestly worse linear page tables opportunity cost fewer tlb entries higher unchanged forward mapped worse hashed page tables 
hashed page tables take longer access superpage ptes search kb page table kb page table poor performance hashed page tables coral due higher fraction tlb misses superpage ptes gcc 
results clustered page tables continue close showing handle remaining tlb misses increasing tlb penalty 
coral coral nasa nasa compress compress wave wave mp mp spice spice pthor pthor ml ml gcc gcc presents results partial subblock tlb 
order similar results superpage tlb 
workloads partial subblock entries superpages hashed page tables worse performance 
workloads proper operating system support doing page traversals reverse order kb page table followed kb page table better option 
gives complete subblock tlb results assuming prefetching described section 
expected hashed page tables perform terribly due high cost multiple probes sixteen 
note uses different scale graphs 
linear clustered page tables continue close place mappings consecutive base pages nearby 
summary clustered page tables improve significantly hashed page tables supporting superpage subblock tlb architectures increasing tlb penalty 
clustered page tables sensitive cache line size 
superpage partial subblock clustered pte occupies bytes clustered pte occupies bytes subblock factor sixteen span multiple cache lines 
increase average number cache lines accessed clustered ptes byte cache lines byte cache lines 
news superpage partial subblock ptes clustered page table irrespective hardware tlb eliminates penalty tall 
solution smaller subblock factor space time tradeoff increasing memory usage reduce tlb penalty 
discussion increasing popularity software tlb handling page table design completely operating system issue 
transition bit address spaces need supporting superpages gives reasons reevaluate traditional hardware page table designs 
linear page tables generally acceptable solution fast simple tlb handling 
hashed page tables better suited sparse address spaces bit address spaces expected 
clustered page tables improve memory overhead hashed page tables efficiently supporting medium size superpages 
emphasize important support tlbs reduce number tlb misses dramatically large working set sizes 
important limitation workloads stress tlb multiprogrammed workloads multiprogramming increase number tlb misses tlb handling significant 
multiprogramming affect physical memory allocation superpage partial subblock systems 
physical memory demand high operating system may able superpages partial effectively simulations show 
multi level linear page tables scale bit address spaces due high overhead upper levels level tree sparse level numbers 
linear page tables 
compress runs processes parallel 
gcc multiprogrammed runs multiple processes sequentially 
attractive low overhead dense address spaces fast page table access mappings hit reserved tlb entries 
level numbers average number cache lines accessed estimates section assume optimistic assumption 
practice possible efficiently store data structure mappings linear page tables hashed page table 
result performance slightly worse reported section 
processors support superpage size mips processor supports pages sizes kb kb kb kb mb mb mb kane 
quantitative measurements include effect page sizes kb kb clustered page tables support multiple page sizes effectively page tables 
superpage ptes page sizes smaller page block size kb clustered page table replication accessed increase tlb penalty section 
superpage ptes page sizes larger page block size involve space time tradeoff conventional page tables efficient 
replicate pte approach clustered page tables better large superpage size ptes replicated fewer kb superpage ptes sixteen times kb ptes 
multiple page table approach clustered page tables require fewer tables 
clustered page tables suffice page sizes kb mb example clustered page table stores mappings page sizes kb kb larger page sizes upto mb 
conventional page tables may require page tables number page sizes supported mips 
performance hashed clustered page tables improved ways 
load factor hash table reduced increasing number hash buckets 
reducing load factor reduces average number hash nodes searched traversal slightly increases amount memory buckets empty 
second constructing hashed clustered page tables software tlb reduce number cache lines accessed 
describe clustered page table techniques applied software tlbs tall 
disadvantage hashed clustered page tables unpredictability hash table distribution depends state current set active processes 
solution process process group page table single shared page table 
section described set associative software tlbs alternate native page table structure page tables powerpc type 
software tlbs thousands entries effective cache translations may reside tlb native page table 
reduce tlb penalty single memory access hit increase tlb penalty software tlbs reduces frequency page table accesses importance page table access time determining performance 
software tlb allows choice larger subblock factor clustered page tables cache line size dictates practical slower page table huck 
flexibility efficiency implementing operating system page table algorithms section overriding factor choosing page table structure 
typical multiprogramming operating system unix thom maintains page table process associates process id pte shared page table 
page table techniques described equally applicable single address space systems opal monads rose segmented systems global effective virtual addresses hp lee single shared page table 
hashed clustered page tables especially suited single address space segmented systems tend sparse bursty address space 
set experiments finite variations hybrid page table implementations possible study discuss detail 
example hashed page tables optimized packing tag pointer bytes shorter pointer storing tag bits inferred indexing table huck 
reduces hashed page table size 
change results clustered page tables effective page table size reductions unoptimized hashed page table 
average number cache lines tlb accessed optimized version remains unchanged 
shorter pointer restricts page table placement memory operating system flexibility 
computer industry transition bit bit systems tlbs page tables affected 
linear hashed page tables practical forward mapped page tables accessing slow 
linear page tables significant memory overhead tlb pollution sparse address spaces 
hashed page tables logical choice sparse bit address spaces large pte memory overhead 
key contributions area page table design 
central contribution new page table organization clustered page table augments hashed page tables address disadvantages 
specifically clustered page tables hashed page tables store mapping information consecutive pages sixteen single tag pointer 
clustered page tables memory page table organizations faster access tlb handling flexible support custom operating system needs 
second contribution study store superpage partial subblock ptes different page tables 
hardware architects considering superpages tlbs increase memory size mapped tlb entry 
tlb enhancements largely useless page tables operating system support proper memory allocation tlb handling 
showed exists straightforward way store mappings page table replicate mappings uses new tlb architectures reduce number tlb misses increase tlb penalty 
show clustered page tables support medium superpage partial subblock tlbs increasing tlb penalty time reduce page table size 
remains seen commercial operating systems incorporate memory allocation page size assignment support needed new tlbs 
suggest superpage partial subblock ptes page table tlb require support 
advantage mappings result smaller page tables faster access 
clustered page tables provide natural support store ptes get memory savings increasing tlb penalty 
clustered page tables native page tables solaris commercial operating system ultrasparc computers 
acknowledgments dock williams vikram joshi inventors patent covering clustered page tables tall joshi designed implemented clustered page tables solaris johnson kong yung sun microsystems role design page table tlb ultrasparc seshadri reppy providing coral ml workloads larus callaghan reviewers comments 
bibliography agarwal horowitz hennessy 
cache performance operating systems multiprogramming workloads 
acm trans 
computer systems november 
andrew appel david mcqueen 
standard ml new jersey 
proc 
third international symposium programming language implementation logic programming pages august 
bail david bailey john barton thomas horst simon 
nas parallel benchmarks 
intl 
journal supercomputer applications fall 
bala bala frans kaashoek william weihl 
software prefetching caching translation lookaside buffers 
proc 
symposium operating system design implementation osdi pages november 
chan albert chang mark mergen 
storage architecture programming 
acm trans 
computer systems february 
chan david chih wei chang microarchitecture hal memory management unit 
compcon digest papers pages march 
chase levy feeley lazowska 
sharing protection single address space operating system 
acm transactions computer systems november 
peter denning 
virtual memory 
computing surveys september 
kleiman barton faulkner smith stein weeks williams 
multiprocessing multithreading sunos kernel 
proc 
summer usenix conference pages june 
james goodman 
cache memory reduce processor memory traffic 
proc 
tenth annual international symposium computer architecture pages stockholm sweden june 
john hennessy david patterson 
computer architecture quantitative approach 
morgan kaufmann publishers 
hill mark hill alan jay smith 
experimental evaluation chip microprocessor cache memories 
proc 
th annual international symposium computer architecture pages ann arbor mi june 
hill mark hill 
aspects cache memory instruction buffer performance 
ph thesis university california berkeley november 
huck jerry huck jim hays 
architectural support translation table management large address space machines 
proc 
th annual international symposium computer architecture pages may 
ibm ibm system technical developments 
ibm 
order 
kane gerry kane joe heinrich 
mips risc architecture 
prentice hall 
khalidi michael nelson dock williams 
virtual memory support multiple page sizes 
proc 
fourth workshop workstation operating systems pages october 
khalidi vikram joshi dock williams 
study structure performance mmu handling software 
technical report tr sun microsystems laboratories 
knut donald knuth 
art computer programming volume 
addison wesley 
second printing 
lee ruby lee 
precision architecture 
ieee computer january 
levy levy lipman 
virtual memory management vax vms operating system 
ieee computer march 
jochen liedtke 
address space sparsity fine granularity 
operating systems review january 

structural aspects system model part ii cache 
ibm systems journal 
may may ed rick simpson hank warren 
powerpc architecture 
morgan kaufman publishers may 
mile milan milenkovic 
microprocessor memory management units 
ieee micro april 
morris 
scatter storage techniques 
communications acm january 
nagl david nagle richard uhlig tim stanley stuart trevor mudge richard brown 
design tradeoffs software managed tlbs 
acm trans 
computer systems august 
orga organick 
multics system examination structure 
mit press cambridge ma 
rama raghu ramakrishnan divesh srivastava sudarshan praveen seshadri 
implementation coral deductive database system 
proceedings acm sigmod international conference management data 
john reppy 
high performance garbage collector standard ml 
bell labs technical memo 
rome ted romer wayne anna karlin brian bershad 
reducing tlb memory overhead online superpage promotion 
proc 
nd annual international symposium computer architecture pages june 
rose rosenberg abramson 
monad pc capability workstation support software engineering 
proc 
th hawaii international conference system sciences pages 
ed 
powerpc architecture ibm risc system technology volume ii 
ibm 
sing pal singh wolf dietrich weber anoop gupta 
splash stanford parallel applications shared memory 
computer architecture news march 
site richard sites 
alpha axp architecture 
communications acm february 
spar sparc international sparc architecture manual version 
spec spec 
spec newsletter december 
tall shing kong mark hill david patterson 
tradeoffs supporting page sizes 
proc 
th annual international symposium computer architecture pages may 
tall khalidi dock williams vikram joshi 
virtual memory computer system address translation mechanism supports multiple page sizes 
patent application filed serial sun microsystems october 
accepted 
tall mark hill 
surpassing tlb performance superpages operating system support 
proc 
sixth international conference architectural support programming languages operating systems pages october 
tall 
superpages address translation hierarchy 
ph thesis university wisconsin madison computer sciences august 
technical report 
alan knowles 
high performance memory management scheme 
ieee computer pages may 
thom thompson ritchie 
unix time sharing system 
communications acm page table type term definition explanation linear variations july 
yoo yoo tom rogers 
unix kernel support oltp performance 
winter usenix conference pages january 
yung robert yung 
ultrasparc spitfire architecture 
technical report sun microsystems april 
appendix formulae appendix includes formulae approximating number cache accesses tlb handling page table size different page tables table 
note results section formulae results simulations 
assume kb base pages byte mapping information pte bit virtual addresses bit pointers 
formulae average number cache lines accessed searching hashed clustered page tables assumes random uniform distribution virtual addresses knut 
practice spatial locality causes non random insertion lookup patterns 
number virtual address regions size base pages valid mappings page table tlb ratio accesses translations level linear page table average number cache lines accessed tlb level linear page table multi level linear number levels page table tree forward mapped number base pages mapped node level page table tree forward mapped ni number ptes node level page table tree hashed load factor hash table buckets clustered variations clustered superpage partial subblock page table type load factor hash table buckets subblock factor fss multi level linear linear hashed average number cache lines accessed tlb fraction page blocks superpage partial subblock clustered ptes page table size bytes notes hash table byte ptes stores translations level linear page table forward mapped pb pb hashed pte bytes clustered clustered superpage partial subblock kb pb kb fss fss table formulae pb 
