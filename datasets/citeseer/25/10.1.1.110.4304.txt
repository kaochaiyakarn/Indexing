flora implementing efficient dood system tabling logic engine 
yang michael kifer department computer science suny stony brook stony brook ny cs sunysb edu 
reports design implementation flora powerful dood system incorporates features logic hilog transaction logic 
flora implemented translation xsb tabling logic engine known efficiency known system extends power prolog equivalent magic sets style optimization founded semantics negation important features 
discuss features xsb help effort areas falls short needed 
describe solutions optimization techniques address problems flora efficient known dood systems logic 
deductive object oriented databases abbr 
dood attracted attention early difficulties realizing ideas performance problems initial enthusiasm 
second half decade witnessed experimental systems 
proliferation web developments rdf standard fueled renewed interest dood systems particular systems logic processing object oriented meta data 
new field processing semistructured data emerging address specialized segment research dood systems 
report flora practical dood system successfully build number sophisticated webbased information systems reported 
practical mean dood system high expressive power built strong theoretical foundations offers competitive performance convenient software development environment 
supported part new york state program strategic partnership industrial resurgence xsb nsf award nsf int www org rdf flora logic hilog transaction logic incorporated single coherent logic language lines described :10.1.1.52.7860:10.1.1.52.7860:10.1.1.115.3586:10.1.1.115.3586:10.1.1.51.1249
developing deductive engine logic ones developed florid chose utilize existing engine xsb implement flora source level translation xsb 
apart benefits saving considerable amount time choice xsb motivated considerations 
xsb augments old resolution tabling extends wellknown magic sets method offering goal driven top evaluation data driven bottom evaluation 

mapping logic hilog predicate calculus known :10.1.1.52.7860:10.1.1.115.3586

xsb known order magnitude faster similar logic systems ldl coral 

xsb compile time optimizations particularly suited source level translation specialization unification factoring trie indexing permits indexing multiple arguments predicate 
best knowledge functioning logic prototype source level translation approach flip 
flip served starting point inspiration 
fortunately plenty left flip translation essentially identical described naively relying ability xsb apply right optimizations :10.1.1.115.3586
result implementation flip suffered number serious problems 
particular 
compiler optimization xsb specialization apply programs obtained direct translation logic :10.1.1.115.3586
hilog terms flip occur program 

fundamental evaluating logic programs tabling discretion 
tabling cases cause unnecessary overhead 
second tabling databases updates 

flip consistent object model limited support path expressions functional attributes meta programming 

flip provide module system basically confined users single program file making serious software development difficult 
discuss problems resolved flora 
full performance results compare flora systems implement logic 
preliminaries section review technical foundations flora logic hilog transaction logic describe naive translation wrapper predicates :10.1.1.52.7860:10.1.1.52.7860:10.1.1.115.3586:10.1.1.115.3586
discussion forms basis understanding architecture flora optimizations built 
logic logic subsumes predicate calculus syntax semantics defined object oriented terms 
hand logic viewed syntactic variant classical logic implementation source level translation possible 
basic syntax 
logic uses prolog ground variable free terms represent object identities abbr oid john father mary 
objects scalar single valued multivalued boolean attributes instance mary spouse john children 
mary children married 
spouse john says mary scalar attribute spouse value oid john children says value multivalued attribute children set contains oid alice nancy 
emphasize contains sets need specified 
instance second fact says mary child jack 
attribute married second fact boolean value true example 
attributes object specified explicitly facts attributes defined inference rules 
instance derive john children nancy help rule children fcg gamma spouse children fcg 
adopt usual prolog convention capitalized symbols denote variables symbols lower case letter denote constants 
logic objects methods functions return value set values appropriate arguments provided 
instance john grade cs courses fcs cs 
says john scalar method grade value arguments cs multivalued method courses value argument set oid contains cs cs 
attributes methods defined rules 
wonder purpose sign method specification 
write grade cs 
purpose enable metaprogramming meta logic 
sign trick methods objects variables range 
instance rules methods fmg gamma 
methods fmg gamma 
symbol denotes new unique variable define new method methods object collects object methods take arguments 
sign just syntactic permits logic stay boundary order logic syntax avoids having deal terms variable 
better hilog discussed shortly :10.1.1.52.7860
note logic specify class membership john student subclass relationship student person types person name string things peripheral subject 
translation predicate calculus 
general translation technique called flattening described :10.1.1.115.3586
small fixed assortment wrapper predicates encode different types specifications 
instance scalar attribute specification mary age encoded fd age mary multivalued method specification john courses fcs cs encoded courses john cs courses john cs 
problem indexing advantage lost due small number wrapper predicates prolog systems index predicate names 
thought think problem easily avoided encoding method attribute names predicates general wrappers 
case variables allowed occur place method names translated program second order 
recursion presents serious difficulty 
naive translation scheme produce rules highly recursive due small number wrapper predicates 
instance consider rule earlier naive translation follows children gamma fd spouse children 
general evaluating rules regular prolog style engine go infinite loop logically finite number possible answers 
contrast rules problems tabling logic engine xsb uses memorization terminate unnecessary loops evaluation 
completeness note class membership translation isa john student subclass relationship subclass student person 
type specifications translation 
addition set axioms added enforce various properties logic 
instance ensure scalar attributes yield value object subclass relationship transitively closed subclass membership contained superclass membership 
non monotonic part logic inheritance directly translated predicate calculus encoded prolog style rules computed xsb efficient implementation founded semantics negation 
hilog seen certain amount meta programming logic owing sign 
rules show method names collected trick easy collect method invocations methods plus arguments 
experience flora shows convenient treat method names method invocations uniformly objects sign trick error prone people tend forget write sign logic grade cs different grade cs 
fortunately extension hilog problems disappear :10.1.1.52.7860:10.1.1.52.7860
illustrate hilog examples 
simplest unusual definition standard prolog meta predicate call call gamma means hilog distinguish function terms atomic formulas variable range 
variables range function symbols 
query form gamma boundaries hilog 
syntax hilog terms extends classical logic 
instance perfectly fine 
course powerful syntax sparingly people important uses features see :10.1.1.52.7860
obviously hilog suitable replacement sign 
hilog extension users write say methods fmg gamma 
rules shown earlier 
trivial appear hilog completely eliminates need special meta syntax flora reduces danger programming mistakes 
addition underlying conceptual object model consistent 
hilog extension implemented upcoming flora 
section discusses techniques developed optimize translation 
encoding predicate calculus 
turns semantics hilog inherently order encoded standard predicate calculus :10.1.1.52.7860
translation subtle defined just recursive transformation functions omit steps irrelevant main subject translating formulas translating terms 
variable 
function symbol 
tn tn 

call hilog atomic formula 


instance encoded apply apply apply call note naive hilog encoding uses essentially wrapper predicate arity 
prolog style implementation poses greater challenge logic predicate level indexing lost 
overcome problem kinds compiler optimizations unification factoring specialization 
source level transformations aimed improving predicate level indexing 
techniques discussed section 
transaction logic important aspect object oriented language ability update internal states objects 
respect logic partly object oriented just query language 
address problem introduced techniques preserving history object states different object states distinguished extra state argument 
techniques support modular design 
instance define complex update transactions previously defined subroutines 
view subroutines fundamental programming practical proposal dealing updates logic programming language address issue 
transaction logic proposal provides comprehensive theory updates logic programming 
utility transaction logic demonstrated various applications ranging database updates robot action planning reasoning actions workflow analysis 
flora logic transaction logic integrated lines proposal corresponding implementation issues described section 
transaction logic actions transactions queries represented predicates 
context logic transactions expressed object methods 
underlying transaction logic just basic ideas 
execution truth 
execution action tantamount true path sequence database states represent execution trace 

elementary updates 
building blocks constructing complex transactions 
behavior specified separate program language set axioms 
shall types elementary updates insert delete 

atomicity updates 
transaction execute entirely case true execution path 
common databases behavior typical logic programming assert retract backtrackable 
program flora adaptation block stacking program 
action stack defined boolean method robot 
sign marks transactional methods change database state 
stack gamma robot 
stack gamma robot move stack 
move gamma block clear clear wider del ins clear ins del clear 
informally program says stack pyramid blocks top block robot find block move stack blocks top move clear block top wider conditions satisfied database updated accordingly ins del elementary insert delete transactions respectively 
note non backtrackable nature prolog updates assert retract translate ins del transactions program properly 
backtrackable updates implemented efficiently xsb engine level due xsb tries special data structure storing dynamic data 
transaction logic provides semantics type updates 
implementation issues transactions tabling environment mentioned section translation logic predicate calculus requires tabling wrapper predicates flattening 
turns tabling database updates fundamentally odds tabling effect query repeated evaluated previously computed answers returned 
subsumed query necessarily need evaluated 
answers computed answers corresponding subsuming query 
obviously hurts semantics update transactions procedures side effects 
see problem consider program gamma table 
gamma write 
time called system print return answer 
called second time system answer side effect printed 
problem implies update transactions transaction logic translated tabled predicates 
tabled predicate depend directly indirectly update transaction semantics dependency call execute subsequent calls 
flora check regular logic methods attributes depend update transactions 
special syntax introduced help flora perform proper translation transactional methods preceded sign distinguish regular logic methods 
primitive update transaction insertion deletion look special ins smith professor teach fall cse del cse taught spring david difficult problem arises transaction changes base facts tabled predicate depends 
case changes propagate answers tabled predicate 
similar view maintenance problem databases overhead associated database view maintenance methods unacceptable fast memory logic engines 
currently flora takes drastic approach tables letting subsequent queries rebuild 
problem specific flora efficient solution developed xsb engine level 
problems naive translation hilog logic choice points indexing 
section described naive translation logic hilog classical predicate calculus 
translation basis practical implementation 
problem naive translation lays choice points top execution tree causes excessive backtracking 
consider program encoding apply predicate consider translation hilog illustrates problem dramatically gamma 
apply gamma apply apply 
gamma 
apply gamma apply 
apply evaluated unify rules unification rule bound fail 
large programs cause serious performance penalty 
degradation indexing source performance penalty 
typically deductive system indexes predicate name plus arguments 
naive translation predicate level indexing lost predicates 
instance example translated program indexing mechanism corresponding indexing predicates original program 
problems new logic programming 
tackle xsb developed compiler optimization techniques known specialization unification factoring perform source source transformation 
specialization takes place goal unify subset candidate rules 
replacing goal predicate different predicate unify heads rules specialization throws unnecessary choice points 
instance performing specialization translated program yields efficient program occurrences predicate apply replaced apply apply gamma apply apply 
apply gamma apply 
apply gamma apply apply 
contrast specialization unification factoring driven patterns rule heads 
idea factor common function symbols save unification achieve better indexing 
consider program apply gamma 
apply gamma 
query apply 
unification apply take place rule head 
repeated unification avoided goal executed transformed program apply gamma 
apply gamma apply 
apply gamma 
apply encode hilog terms common functors example occur frequently translated flora program 
turns native xsb unification factoring performs quite programs 
xsb specialization exhibits subtle problems 
double tabling 
problem specialization tabling 
hilog translation clear tabling directive gamma table translated 
flora handles tabling apply xsb specialization may cause double tabling situation certain predicates tabled unnecessarily 
instance consider program computes transitive closure naive encoding gamma table 
gamma table apply 

apply 

apply 
gamma 
apply gamma apply 
gamma 
apply gamma apply apply 
xsb specialization translated program yield gamma table apply 
gamma table apply 
gamma table apply 
apply 
apply gamma apply 
apply 
apply gamma apply apply 
apply 
apply gamma apply 
apply 
apply gamma apply apply 
essentially copy apply tabling tuples apply redundant caching needed guarantee termination specialized program 
size compiled code considerably larger original 
meta programming 
problem due meta programming tends produce programs preclude xsb specialization 
see effect meta rules xsb specialization consider program naive translation 
apply 

apply 
gamma apply gamma gamma 
apply gamma apply 
xsb specialization previous translated program looks follows apply 
apply 
apply 
apply 
apply gamma apply gamma apply gamma apply 
program predicate apply unify apply facts rules 
unification repeated indexing argument original program lost 
note far illustrating xsb specialization problems hilog logic exhibits problem 
consider logic program naive translation atta 
fd atta 
atta 
fd atta 
gamma atta 
fd gamma atta 
fxg gamma atta 
gamma fd atta 
easy see translation just version previous hilog program xsb specialization just badly 
section proposes new kind specialization called skeleton specialization flora optimize source level translation logic hilog 
system designed way skeleton specialization xsb specialization compliment 
solutions explained section major problem naive translation logic hilog loss indexing xsb unification factoring performs translated programs specialization fails yield improvements cases cause unnecessary overhead 
section propose skeleton specialization supplements native xsb specialization fixes problems 
skeleton specialization algorithm definition skeleton 
hilog term skeleton skel view syntactic structure skel defined follows 
skel constant 

skel variable 

skel skel tn 
example skeletons hilog terms 

skel 
skel 
skel algorithm describes flora skeleton specialization 
applies logic hilog translation separately set wrapper predicates logic translation disjoint wrapper predicates hilog predicates 
explain algorithm context hilog translation 
takes flora program input yields equivalent program predicate logic algorithm steps input flora program consisting rules including facts output xsb program encodes hl fl literal rule head fg bl fl literal rule body fg hs hlg bs blg skeleton hs bs seq unique integer rule gamma input program flatten skel literal flatten skel output rule gamma literal hl naive flatten skel output rule gamma literal bl rule gamma input program unifies mgu skel skel flatten skel literal skel bs flatten skel flatten skel output rule gamma fig 

skeleton specialization algorithm skeleton analysis lines 
collect literals rule heads set hl literals rule bodies set bl algorithm computes set skeletons hs bs literal hl bl respectively 
unique skeleton union hs bs assigned unique sequence number 
rest algorithm consists main tasks flattening trap rule generation instantiation 
flattening lines 
purpose flattening eliminate unnecessary wrapper predicates unification 
nk hilog literal assumed functor part arity 
propositional constants treated ary literals 
constant form tn nk 
transformation procedure flatten sequence number assigned skeleton wrapper predicate encode hilog literal apply unique hilog translation 
constant nk lines skeleton argument flatten literal argument lines skeleton subsumes literal flatten yields apply en nk 
hilog term flatten return apply en nk eij tij respectively naive encoding hilog terms described section 
instance sequence number assigned skeleton flatten produce apply 
reason functor symbol omitted encoded sequence number skeleton 
trap rule generation lines 
steps generate rules trap naive encoding literals 
translation outputs rule head naive encoding original rule head body result flattening head 
instance trap rule gamma body apply apply gamma apply 
trap rule generation indispensable inter module communications flora 
specialization principle knowledge modules calls referring modules encoded naive translation 
due space limits elaborate topic 
instantiation lines 
literals unify encodings unify flattening 
instance unify flattened forms apply apply respect skeletons respectively unify 
instantiation ensures preserved specialization 
idea body literal unifies head rule mgu literals different skeletons new rule generated 
instance consider program gamma 
gamma 
flattened apply apply 
unifies gamma rule instantiated substitution yielding gamma 
specializing rule yields apply gamma apply ensures semantics original program preserved 
rule instantiation generate body literals new skeletons seen original program 
instantiation applied new body literals 
opens possibility infinite instantiation process 
instance program gamma 
gamma 
second rule instantiated mgu new rule gamma generated 
literal completely new skeleton 
flattened respect rule gamma instantiated mgu 
new skeleton emerge 
lines algorithm designed ensure termination instantiation process 
solution simple quality specialization traded termination 
literal new skeleton shows newly instantiated rule skeleton extend skeleton literal instantiation 
flatten instantiated literal respect skeleton original literal 
preserved translation 
instance specializing example yields program trap rules omitted apply gamma apply 
apply gamma apply 
apply gamma apply 
apply gamma apply apply 
putting translated program computes transitive closure result skeleton specialization follows gamma table apply 
apply 
apply gamma apply 
apply 
apply gamma apply apply 
program result skeleton specialization program shown apply 
apply gamma apply 
apply 
apply gamma apply gamma note illustrate idea skeleton specialization hilog translation algorithm applies logic translation 
fact translation views logic literals just kind hilog literals just happen different wrapper predicates 
instance slight variation naive logic translation convert hilog literal convert predicate logic wrapper predicate fd apply 
likewise converted predicate calculus wrapper 
skeleton specialization performed hilog logic independently 
part algorithm needs changed prefix construct wrappers 
instance apply fd 
result applying skeleton specialization program trap rules omitted fd 
gamma fd 
fd 
fd gamma atta atta 
fd gamma atta 
experiments show small programs discussed section flora skeleton specialization speed programs factor xsb native specialization reduces execution time factor 
detailed comparison reported full version 
said earlier flora specialization intended replace xsb specialization 
line optimization technique 
flora translated program optimized native xsb specialization unification factoring 
observation flora specialization better quality specialization possible detailed skeleton representation 
considering hilog terms trees define skeletons view structures depth level 
example level skeleton 
subtle relationship amount detail preserved skeletons quality specialized programs 
detailed skeletons normally mean better specialized programs better performance longer compilation time larger program size 
discusses techniques building efficient dood systems translation lower level prolog syntax utilizing existing tabling logic engine xsb 
feasibility approach demonstrated logic flora system delivers encouraging performance 
performance results included full version 
discuss compiler optimization techniques achieve performance just native xsb optimizations designed specifically flora 
due lack space omitted number implementation issues flora module system performance optimizations related handling path expressions 
details www cs sunysb edu papers ps hasan sagonas ramakrishnan david warren patience explaining intricacies xsb optimization techniques 
grateful bertram lud anonymous referees helpful comments 

abiteboul buneman suciu 
data web 
morgan kaufmann san francisco ca 

paton williams 
design implementation rock roll deductive objectoriented database system 
information systems 

beeri ramakrishnan 
power magic 
journal logic programming april 

berners lee 
semantic web road map 
www org designissues semantic html september 

berners lee 
semantic toolbox building semantics top xml rdf 
www org designissues toolbox html may 

bonner kifer 
transaction logic programming 
int conference logic programming pages budapest hungary june 
mit press 

bonner kifer 
overview transaction logic 
theoretical computer science october 

bonner kifer 
transaction logic programming logic declarative procedural knowledge 
technical report csri university toronto november 
www cs toronto edu bonner transaction logic html 

bonner kifer 
logic programming database transactions 
chomicki saake editors logics databases information systems chapter pages 
kluwer academic publishers march 

bonner kifer 
results reasoning updates transaction logic 



chen kifer warren 
hilog foundation higher order logic programming 
journal logic programming february 

kifer ramakrishnan ramakrishnan 
logic modeling analysis workflows 
acm symposium principles database systems pages seattle washington june 

yang kifer ramakrishnan 
design implementation physical layer experience 
int conference computational logic dood stream july 

dawson ramakrishnan ramakrishnan sagonas skiena swift warren 
unification factoring efficient evaluation logic programs 
acm symposium principles programming languages 

decker brickley saarela angele 
query inference service rdf 
ql query languages workshop december 

freitag decker kifer voronkov editors 
transactions change logic databases volume lncs 
springer verlag berlin 

th 
lausen 
florid prototype logic 
proc 
intl 
conference data engineering icde exhibition program 
ieee computer science press 

guha lassila brickley 
enabling inferencing 
ql query languages workshop december 

gupta lud 
knowledge integration neuroscience data sources 
th intl 
conference scientific statistical database management ssdbm berlin germany july 
ieee computer society 

jarke jeusfeld staudt stefan 
conceptbase deductive object base meta data management 
journal intelligent information systems february 

kifer 
deductive object oriented data languages quest integration 
int conference deductive object oriented databases volume lecture notes computer science pages singapore december 
springer verlag 
keynote address int conference deductive object oriented databases 

kifer lausen wu 
logical foundations object oriented languages 
journal acm july 

lausen lud 
updates reasoning states 
nd international east west database workshop klagenfurt austria september 

liu 
deductive object base language 
information systems 

lud 
tour de flip 
flip manual 

lud gupta 
mediator system model information integration 
int conference large data bases cairo egypt 
system demonstration 

lud oder lausen may 
managing semistructured data florid deductive object oriented perspective 
information systems 

mozilla rdf enabling inference 
www mozilla org rdf doc inference html 

sagonas swift warren 
xsb efficient deductive database engine 
acm sigmod conference management data pages new york may 
acm 

sagonas warren 
efficient execution hilog wam prolog implementations 
int conference logic programming 

swift warren 
machine slg resolution definite programs 
int logic programming symposium cambridge ma november 
mit press 

tamaki sato 
old resolution tabulation 
int conference logic programming pages cambridge ma 
mit press 

van gelder ross schlipf 
founded semantics general logic programs 
journal acm 


integrated knowledge base management system 
proceedings int conference fifth generation computer systems pages june 
