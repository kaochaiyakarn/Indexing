tackling awkward squad monadic input output concurrency exceptions foreign language calls haskell simon peyton jones microsoft research cambridge simonpj microsoft com research microsoft com users simonpj th april functional programming may beautiful write real applications grapple awkward real world issues input output robustness concurrency interfacing programs written languages 
lecture notes give overview techniques developed haskell community address problems 
introduce various proposed extensions haskell way offer operational semantics explains extensions mean 
tutorial marktoberdorf summer school 
appears book engineering theories software construction marktoberdorf summer school ed car hoare broy nato asi series ios press pp 
version errors corrected compared published version 
change summary apr examples added section 
march substantial revision lots books functional programming haskell :10.1.1.100.9674
tend concentrate beautiful core functional programming higher order functions algebraic data types polymorphic type systems 
lecture notes bits usually aren written 
write programs useful beautiful programmer confront awkward squad range un beautiful crucial issues generally concerning interaction external world input output 
error detection recovery example program time happen time 
concurrency program react timely way independent input sources 
interfacing libraries components written language 
call value strict family functional languages generally taken pragmatic approach questions adopting similar approach taken imperative languages 
want print 
problem ll just side effect printing character 
course isn really function side effect practice approach works just fine provided prepared specify order evaluation part language design just programming languages fortran java functional ones lisp standard ml 
call need lazy languages haskell wear hair shirt evaluation order deliberately unspecified 
suppose extend haskell adding side effecting functions 
consider list xs square brackets commas denote list haskell 
earth mean 
sml evaluating binding print followed 
haskell calls executed elements list evaluated 
example xs call length xs printed length touch elements list 
bottom line laziness side effects practical point view incompatible 
want lazy language pretty purely functional language want side effects better strict language 
long time situation embarrassing lazy community input output story purely functional languages weak error recovery concurrency years surprising solution emerged monad 
say surprising exotic name monad derived category theory branches mathematics useful red programmers 
functional programming way apparently exotic theory direct practical application monadic story example 
monads structure programs perform input output effect imperative programming want want 
monad unifying theme notes 
standard version haskell haskell comes library uses monadic approach 
haskell rich deal rest awkward squad exceptions concurrency extended haskell number experimental ways adding support concurrency exceptions foreign language interface :10.1.1.33.8720:10.1.1.26.1040
far developments documented scattered research papers purpose lectures gather coherent account 
follows refer haskell mean haskell earlier versions language specified 
motivating example explore issues involved writing web server haskell 
interesting case study involves member awkward squad intensive 
requires concurrency 
requires interaction pre existing low level libraries 
requires robustness 
dropped connections time possible reconfigure server dropping running connections errors logged 
haskell web server case study remarkably small 
uses lines haskell implement standard 
robust run continuously weeks time performance broadly comparable widely apache server 
apache handles connections sec machine haskell web server handles connections sec 
bit apples oranges comparison hand apache functionality haskell web server little performance tuning applied 
began saying confront awkward squad write useful programs 
mean useful programs awkward 
judge believe monadic approach programming actions class values interesting beautiful modular 
short haskell world finest imperative programming language 
input output response return haskell program request stream model member awkward squad input output tackle 
problem unsafeperformio ac return apparently fundamental conflict 
purely functional program implements function side effect 
ultimate purpose running program invariably cause side effect changed file new pixels screen message sent 
bit call input output awkward 
raison tre program 
program observable effect whatsoever input output useful 
side effect functional program outside 
example functional program function mapping input character string output string main string string wrapper program written 
get input string specified file example standard input apply function store result string file standard output 
functional programs remain pure locate wrapper 
trouble sin leads 
want read file 
write file 
delete files open sockets sleep specified time 
alternative adopted version haskell enrich argument result type main function main response request program takes argument lazy list values produces lazy list request values 
informally request says please get contents file response say contents wanted email today 
concretely request ordinary algebraic data types type string data request readfile string data response string 
wrapper program 
repeatedly takes request result list acts request attaches appropriate response argument list 
clever deal fact function applied list responses responses list isn problem lazy setting 
request response story expressive adopted main input output model version haskell defects hard extend 
new input output facilities added extending request response types changing wrapper program 
ordinary users able 
close connection request corresponding response 
extremely easy write program gets step 
program remains step easy accidentally evaluate response stream eagerly block emitting request response request arrived won elaborate shortcomings move swiftly better solution monadic hudak give useful survey approaches purely functional input output describes pre monadic state play 
monadic big breakthrough input output purely functional languages came learned called monads general structuring mechanism functional programs 
key idea value type io action performed may input output delivering value 
statement surprised means moment 
concrete way looking actions type io world world type definition says value function applied argument delivers result 
idea program centric program takes state entire world input delivers modified world result modified effects running program 
say section don think view io actions functions entirely satisfactory generates right intuitions 
may visualise value world io result world fed left result emerge char char right 
general call value action just action 
literature find called computations 
getchar putchar types familiar operations supplied primitive getchar getchar io char io char putchar char io putchar char io getchar action performed result reads character standard input char having effect world outside program returns program res result action 
function takes putchar character returns action io invent act performed world prints output external world world returns trivial value 
pictures actions look box discard world takes extra input argument getchar putchar getchar char getchar io char char io getchar putchar haskell response program char putchar putchar request unsafeperformio ac return suppose want read character print character read 
need glue char compound action getchar return invent world return act result discard world unsafeperformio act getchar getchar char char getchar putchar echo io return echo getchar putchar char putchar io io io putchar getchar io char putchar char io invent world return act discard world unsafeperformio act achieve glue function combinator provided primitive combinator pronounced bind 
implements sequential composition passes result performing action parameterised second action 
precisely compound action performed performs action takes result get new action performs new action 
example getchar putchar performs yielding character haskell suppose wanted program response perform echo twice request succession 
say echo echo expects function second argument action 
want throw away result 
convenient define second glue combinator terms io io io term haskell notation lambda abstraction 
particular abstraction simply consumes argument throws away 
write io echo echo pronounced read right hand side echo 
practice common second argument explicit lambda abstraction 
example read character print twice io getchar putchar putchar parentheses example optional lambda abstraction extends far right possible see laid io getchar putchar putchar io result world fact looks bit sequence imperative actions coincidence exactly wish specify 
section introduce special syntax mirror imperative program closely 
char char write action reads characters returns 
getchar putchar start getchar io char char io char putchar char io getchar getchar char put part 
char char getchar putchar done input output required 
need combinator invent act world return io discard getchar putchar action return action immediately returns unsafeperformio having side effects 
may draw picture easily return io char char getchar getchar return haskell realistic action program response reads line input request getline io char getline getchar return getline cs return cs return example haskell notation empty list infix constructor list constructor 
complete haskell program defines single big action 
program executed performing action 
example program reads complete line input reverses prints output main io main getline cs reverse cs char io leave exercise 
notice operation combines composes actions treats world single threaded way 
takes world produced action passes second action 
world duplicated thrown away matter code programmer writes 
property allows io primitives performing operation right away sort update place 
say implementation section 
worry unbounded number possible primitives putchar getchar right 
operations defined terms existing ones 
needed course way call arbitrary libraries supplied operating system topic discuss detail section 
notation write programs stylised form section haskell provides special syntax dubbed notation monadic computations 
notation follows io char char getchar getchar return leave part want throw away result action char char io putchar putchar syntax convenient lambdas practice uses notation intensive programs haskell 
just notation 
compiler translates notation calls just 
translation rules simple follows translation statement binds variable assign case imperative program 
variable name twice left hand side bind distinct variables 
example haskell allows form indo notation omit brevity 
getchar char putchar return line binds character returned getchar 
second line feeds putchar binds value returned 
example demonstrates scope 
expression appear expression long correctly typed 
example indo notation uses expression getline io char getline getchar return cs getline return cs control structures monadic lets imperative programming corresponds control structures imperative languages loops loops 
fact need add get build functions 
example initialisation web server goes infinite loop awaiting service requests 
easily express infinite loop combinator forever io io forever forever forever action repeats forever iteration achieved recursion 
suppose want repeat action specified number times 
want function int io io action performed repeat times 
easy define return notice forever take action arguments 
ability treat action class value allows define control structures 
loop io io idea ns fa apply function fa element ns turn case giving action actions combined sequence 
fa return ns fa fa ns fa print numbers print haskell notation list integers io 
way ns fa sequence map fa ns map element giving list actions combines actions sequence 
type sequence io io sequence foldr return sequence reminds throws away results sub actions returning 
call function sequence close cousin beautiful type sequence io io takes list actions returning result single compound action returning result type 
easily defined sequence return sequence rs sequence return rs notice happening 
having fixed collection control structures provided language designer free invent new ones application specific need arises 
extremely powerful technique 
io operations far allow write programs input output imperative fashion 
natural ask model pervasive feature imperative languages mutable variables 
inspiration ml ref types proceed data ioref type io ioref ioref io ioref io value type ioref mutable cell holding value type new cell allocated supplying initial value 
cells read written 
small loop compute sum values imperative style count int io int count loop loop ioref int int io int loop loop just comparison look count int int return absolutely terrible example 
start program longer purely functional style 
purports need io monad really require side effects 
io monad enables imperative program haskell want better imperative language place 
ioref useful track state external world object 
example haskell provides direct analogy standard library functions opening reading writing file openfile string io handle handle char io handle io char hclose handle io suppose wanted record characters read written file 
convenient way arrange increment mutable variable suitably 
held modified handle type handle ioref int define variant openfile creates mutable variable opening file returning variants take modify mutable variable appropriately 
example string io fn mode openfile fn mode return string io cs length cs cs example mutable variable models part state file written tracking number characters written file 
file effect external mutable variable surprising internal mutable variable appropriate model state 
leaving safety belt home careful introduce monad data type type collection operations type 
particular return io io io io getchar io char putchar char io operations characters openfile char io handle operations files io ioref operations 
key feature data type prevents permits 
particular notice operations action result take argument 
operation combines actions 
monad sticky operation takes argument type returns result non io type 
restrictions 
example suppose wanted read configuration file get options program code string lines readfile config wrong 
bool optimise elem lines string string standard function breaks string constituent lines eq bool tells argument member second argument 
alas code type correct readfile type readfile io string produces string consumes 
solve giving type io string type io bool plus changes code 
means test monad inconvenient 
want way get string tostring thing monad 
reason reading file action principle matters read file relative operations program 
case confident change program run really doesn matter read 
sort thing happens haskell implementations offer unsafe primitive unsafeperformio io write string lines unsafeperformio readfile config 
combinator deliberately long name 
promising compiler timing operation relative operations program matter 
undertake proof obligation compiler unsafe prefix means 
just point clearer plumbing diagram need careful read file time tested boolean 
char char getchar putchar char putchar putchar io char putchar char io invent world see invent world thin air discard 
unsafeperformio dangerous weapon advise extensively 
best regarded tool systems programmers library writers casual programmers 
input output encapsulates happen unpredictable moments need know doing 
obvious defeat haskell type writing function cast see 
unsafeperformio mis force imperative program purely functional setting 
bit chain saw repair wrong tool job 
programs invariably restructured cleaner functional form 
haskell program proof obligations satisfied unsafeperformio extremely useful 
request practice encountered common patterns usage act result discard world unsafeperformio act performing run input output 
allocating global mutable variable 
example ioref int unsafeperformio emitting trace messages debugging purposes quick review trace string trace unsafeperformio putstrln return summarise learned far complete haskell program single large action 
big actions built gluing smaller actions 
action class value 
passed function argument returned result function call consider example 
similarly stored data structure consider argument example 
fact actions passed freely easy define new glue combinators terms existing ones 
monads originally invented branch mathematics called category theory increasingly applied describe semantics programming languages 
eugenio moggi identified usefulness monads describe composable computations :10.1.1.26.2787
moggi brilliant faint 
practical programmers breakthrough came phil wadler comprehending monads described usefulness monads programming context :10.1.1.33.5381
wadler wrote readable papers monads highly recommend :10.1.1.100.9674
built directly write monadic :10.1.1.100.9674
general monad triple type constructor functions return types return quite satisfy algebraic laws return return box ones names simply convenient way refer laws running text 
rules bind easier understand written indo notation correct implementation monad return satisfy properties 
notes monad monad single program may different monads type constructor operators 
haskell type class mechanism allows overload functions return monad notation likewise monad 
wadler papers cited give examples monads space pursue topic 
implementation notes difficult compiler writer implement monad 
main alternatives 
keep monad right 
technique carries io monad right compiler code generator 
functional language compilers translate source program intermediate form closely lambda calculus apply optimising transformations intermediate form generate code 
entirely possible extend intermediate form adding monadic constructs 
simply add return primitives transformation easier adds notation directly primitive function 
compare forms bind rule previous section 
approach taken benton kennedy mlj implementation ml :10.1.1.57.4184
functional encoding 
second approach glasgow haskell compiler ghc adopt functional viewpoint monad formed basis earlier pictorial descriptions type io world world represent world argument un token directly return io return io io io case un token stands world 
definition see world returned action passed second just picture section 
implement operations different implementing primitive operations addition integers 
approaches better 
keeping monad explicit principled means optimisation pass deal explicitly new constructs 
ghc approach economical 
example laws section regarded optimisations simple consequences need special attention 
say think ghc approach bit hack 

relies correctness fact compiler duplicates redex 
consider expression getchar putchar putchar ghc definitions translate case getchar case putchar putchar compiler entirely justified replacing code case getchar case putchar putchar fst getchar replaced second call bad things happened incoming world token duplicated second calls 
happens assumption single threadedness longer holds efficient update place implementation 
catastrophe 
functional language clean system built explicit world passing style 
single threadedness world ensured clean uniqueness type system verifies values single threaded notably world single threaded way 
haskell monad maintains world single threadedness construction programmer err principle possible compiler 
practice ghc careful duplicate expression duplication give rise extra redex duplicate call way 
ariola sabry shown formally compiler duplicates redexes implementation strategy safe 
ghc approach sound uncomfortable apparently semantics preserving transformation preserve semantics 
observation leads neatly question want discuss give semantics awkward squad 
mean 
thing give precise semantics language feature 
give semantics monad 
section describe best way know answer question 
introduce notation go need prior experience operational semantics understand section 
safely skip section 
urge formal framework explain semantics concurrency exceptions 
denotational semantics 
approach semantics take functional viewpoint described earlier type io world world view meaning action just function 
story bit unsatisfactory regarded function program loop io loop loop denotation bottom 
alas program io putchar unfortunately denotation programs regarded highly distinguishable user loops prints 
problem restricted erroneous programs programs server processes example may designed run essentially forever wrong say meaning simply consider haskell programs running parallel sending output web server web browser example 
output form part world input 
possible deal fixpoint operator complicated un intuitive anyway 
approach scale add concurrency section 
problems may soluble remaining denotational framework producing sequence returning set traces 
give idea trace approach type io set trace type trace event data event putchar char getchar char 
program reads character echoes back screen semantics getchar putchar getchar putchar getchar putchar 
values return putchar getchar terms evaluation contexts syntax values terms 
return set traces trace contains details inputs outputs trace possible input 
set traces describes behaviours program 
example getchar putchar excluded 
approach give semantics csp roscoe 
adopt operational semantics standard approaches semantics process calculi 
ultimately think approaches similar power find operational approach simpler easier understand 
operational semantics semantics stratified levels inner denotational semantics describes behaviour pure terms outer monadic transition semantics describes behaviour computations 
consider simplified version haskell language usual features lazy functional language lambda abstraction application data structures case expressions augmented constants corresponding operations 
elements syntax relevant semantics aspects represent lists write case expression aid comprehension semantics 
range terms language ranges values 
value term considered inner purely functional semantics evaluated 
values include constants lambda abstractions usual unusual ways treat primitive operations values 
example putchar value 
done term purely functional world time hand outer monadic semantics 
way getchar values 
values arguments arbitrary terms values 
example appear 
putchar value putchar chr term 
putchar strict data constructor 
reason choice evaluating putchar argument done purely functional world done output operation take place 
give semantics describing program state evolves new program state making transition 
model program state simply term write curly braces remind program state 
labelled transitions transition program state may may labelled event write transition events represent communication external environment input output 
initially just events standard output 
means program state standard input 
means program state transition rules 
move writing character move reading character putchar return getchar return rule says program consisting transition labelled 
program consisting 
second rule similar 
programs consist single action 

answer question introduce evaluation contexts 
putchar return getchar return return evaluation contexts basic transition rules getchar transition rule program consists 
example consider program main getchar putchar toupper action performed 
getchar course 
need way say action perform left 
may look left 
consider slightly artificial program main getchar getchar return action performed 
general find action look left branch tree nodes 
formalise arm waving established notion evaluation context :10.1.1.44.5122
syntax evaluation contexts evaluation context term hole written 
example possible evaluation contexts return ord case indicates location hole expression 
write denote result filling hole term examples various ways filling holes print hello getchar true print hello getchar return ord true toupper char char converts lower case character upper case leaves characters unchanged 
notation evaluation contexts give real rules putchar getchar 
general give transition rule give name putc getc easy 
rule putc example read occurs action context program transition emitting character replacing call 
holds evaluation context see transitions example program main getchar putchar toupper rule getc evaluation context putchar toupper assuming environment delivers character response transition getchar putchar toupper return putchar toupper choose correct evaluation context 
best way see try choosing 
context chose formed syntax allows transition rule fire 
example context certainly formed force term hole getchar putchar toupper rule matches 
context simply reaches left branching chain combinators reach left action ready execute 

law section expressed new transition rule return rule transition return putchar toupper putchar toupper need ordinary purely functional evaluation 
express lifting inner denotational semantics transition system fun stands functional term value computed denotational semantics replace active site 
function mathematical function term returns value function defines semantics purely functional part language called denotational semantics language 
denotational semantics described books study simply think value obtained evaluating side condition just prevent rule firing repeatedly making progress rule fun allows transition normal beta reduction making transition notice produced value putchar putchar toupper 
discussed section model putchar strict constructor 
putchar toupper putchar rule emit character putchar return program finished 
referring back difficulties identified section distinguish program loop simply loops forever repeatedly prints forever 
programs denotation simple denotational semantics section different behaviours operational semantics repeatedly transition label happens 
put way happens rule fun simplest thing say value fun fire 
rule applies program stuck 
constitutes observably different sequence transitions lastly leave topic evaluation contexts note term rule fun type evaluation context action hole 

hole evaluation context program left argument need explain program say true behaves ill typed 
ioref main program named holding parallel composition dealing restriction return return return extensions operational semantics 
modifications need add new sort value primitive 
add new sort value ioref identifiers ioref identifier value returned think address mutable cell 
extend program state main thread zero associated identifier syntax program states initially surprising 
vertical bar join main thread program state 
example program state am bit sloppy denotational semantics yields mathematical value term original language fact important swept carpet 
technical point view may simpler adopt operational semantics inner purely functional part distraction 
notice valuation function denotational semantics usually environment rule fun requires value closed term environment empty 
observable mean observable looking labelled transitions labelled transitions constitute interaction program environment 
may argue say gets stuck infinite loop 
example return infinite loop external interactions infinite sequence unlabelled transitions 
prefer add variant fun un labelled transition unchanged state infinite sequence un labelled transitions 
just matter taste 
structural congruence structural transitions 
program far allocated called think running active program containers containing respectively 
rules reading respectively parallel passive rule says action main program main program parallel ioref named containing action replaced return transition quite similar getchar transition unlabelled internal program remember labelled transitions represent interaction external environment 
return return tiresome details fix 
originally said transitions program states part program state example 
second main program adjacent relevant ioref 
want say adjacent 
formalise matters give structural rules 
rule par example says move parallel move parallel short non participating pieces program state unaffected 
equivalence rules comm assoc say associative alert reader notice duplicates term models call name call need 
straightforward model call need adding heap operational semantics launchbury showed 
doing adds extra notational clutter main point tutorial 
tutorial take simpler path modelling call name 
commutative equiv says free equivalence rules bring parts program state 
rules take range events 
empty label 
literature see empty event written formal game 
read papers operational semantics see rules worth comfortable 
aren optional want conduct water tight proofs happen important specify system formal way 
rule return action main program create transition new state main program parallel newly created suitably initialised ioref named arbitrary name constraint evaluation context side condition means means free names example working semantics program main program allocates reads increments contents writes back new value 
semantics works saved space abbreviating new similarly new read write return read write read write 
read write return write write write return clear naming name bad thing 
reason side condition rule says mentioned program state remember may threads running parallel considering 
purpose part restricts scope having introduced way need number structural rules move 
notably lets move outside 
may need alpha change mind name chose come name clash 
outside don get way 
concurrency web server works listening connection requests particular socket 
receives request establishes connection engages bi directional conversation client 
early versions protocol limited conversation utterance direction please send page ok versions allow multiple exchanges take place 
web server service multiple clients deal concurrently client 
simply acceptable deal clients time 
obvious thing fork new thread kind new client 
server concurrent haskell program 
sharp distinction parallelism concurrency parallel functional program uses multiple processors gain performance 
example may faster evaluate evaluating parallel add results 
parallelism semantic impact meaning program unchanged executed sequentially parallel 
furthermore results deterministic possibility parallel program give result run different result different run 
contrast concurrent program concurrency part specification 
program run concurrent threads independently perform input output 
program may run processors implementation choice 
behaviour program necessarily design non deterministic 
parallelism concurrency substantial semantic impact 
focus notes exclusively concurrency parallelism 
interested parallel functional programming book gives comprehensive coverage 
concurrent haskell extension haskell designed support concurrent programming turn design 
threads main loop web server config socket io config socket forever conn accept socket forkio config conn defined forever section infinite loop repeatedly calls accept haskell function calls unix procedure name mechanisms discuss section accept new connection accept returns part result communicate client 
accept socket io connection type connection handle read peer details having established connection fork fresh thread config conn service connection 
type forkio forkio io io threadid takes action arranges run concurrently parent thread 
call forkio returns immediately returning result identifier forked thread 
see section 
notice forked thread doesn need passed parameters common threads packages 
forked action full closure captures values free variables 
case forked action config conn obviously captures free 
thread may go sleep specified number microseconds int io forkio dangerous similar way unsafeperformio dangerous section 
actions performed parent thread may interleave arbitrary fashion actions performed forked thread 
fine threads painting different windows screen times want threads operate closely 
support operation need synchronisation mechanism discuss 
communication suppose want add sort throttling mechanism threads running server different stops accepting new connections 
implement need keep track total number active forked threads 

obvious solution counter forked thread increments begins decrements done 
course careful 
lots threads hitting counter sure don get race hazards 
increments decrements indivisible 
concurrent haskell supports synchronised version called data mvar io mvar takemvar mvar io putmvar mvar io ioref mvar mutable location contain value type empty 
creates mvar created empty 
putmvar fills value takes contents leaving empty 
empty place call takemvar blocks thread fills 
call full blocks empty aid easy implement counter config socket io config socket count putmvar count forever conn accept socket forkio count config conn dec count dec mvar int io count takemvar count putmvar count dec count takemvar count putmvar count presumably extra code inspect value counter take action gets large 
update counter performed dec indivisible brief moment read counter written back counter location empty 
thread tries moment simply block 
represents change earlier version concurrent haskell putmvar full mvar program error 
mvar threadid forkio putmvar takemvar forkio thread called called containing called return return return putmvar return takemvar semantics return extensions support concurrency advantages operational semantics set section readily extended support concurrency 
necessary extensions add new values represent new operation name mvar thread integer argument extend program states adding form full state empty state form named thread provide transition rules new primitives 
rules fork newm similar way rule described section 
particular identical fashion control new names required 
rules similar leaves empty fills 
time semantics program non deterministic 
threads want take contents mvar semantics leaves deliberately unspecified wins 
emptied rule thread progress thread fills 
rule delay deals 
express delay invented extra event means microseconds elapse 
recall event indicates interaction external world section am modelling delay interaction external clock 
satisfactory events presumably queued clock ticks gives general idea 
notice explicit rule blocking thread tries take contents mvar empty 
happens valid transition rule involving thread stays unchanged program state trying take filled 
channels thread created parent thread independently perform input output 
think state world shared mutable object race conditions course arise 
example threads foolish write file say bad things happen 
want threads write file merging writes suitable level granularity 
precisely behaviour needed web server want log errors client service threads single error log file 
simplest thing create single thread business write error log file log error client service thread need send message error logging thread 
just pushed problem different place mean send message 
define new type buffered channels implement section type channel io channel channel io channel io permits multiple processes write read safely 
error logging thread repeatedly write value receives file client service thread wanting log error send error message error logger 
value channel item item item read write second value third value channel unbounded buffering possible implementation illustrated 
channel represented pair drawn small boxes thick borders hold read write buffer type channel mvar stream read mvar stream write hole mvars channel required channel put get operations atomically modify write read channels respectively 
data buffer held stream empty case data holds data type define shortly type stream mvar item just pair element holding rest data data item stream thought list consisting terminated hole consisting 
write channel points hole 
creating new channel just matter creating read write mvars plus empty mvar stream read write hole putmvar read hole putmvar write hole return read write putting channel entails creating new empty stream hole extracting old hole replacing new hole putting old hole 
read write val new hole old hole takemvar write putmvar write new hole putmvar old hole val new hole getting item channel similar 
code follows notice may block second takemvar channel empty process 
read write head var takemvar read val new head takemvar head var putmvar read new head return val worth noting number processes safely write channel read 
values written merged non deterministic scheduling dependent arrival order value read go exactly process 
variants readily programmed 
example consider multi cast channel multiple readers see values written channel 
required add new operation channel io channel idea channel returned read independently original sees data written channel call 
implementation simple amounts setting separate read pointer initialised current write pointer read write new read hole write putmvar new read hole return new read write forkio io io threadid int io sleep microseconds data mvar io mvar created empty io mvar initialised takemvar mvar io blocking take putmvar mvar io blocking put mvar io non blocking take mvar io bool non blocking put mvar io bool test emptiness important concurrent operations code clearer auxiliary function reads value leaves full mvar io var val takemvar var putmvar var val return val watch 
need modify 
particular change call takemvar head var head var 
mvars bottom row block consumer catches producer 
consumers essential march stream 
concurrent programming tricky 
easy modification left exercise reader add inverse channel io summary haskell leads qualitative change sorts applications write 
extensions simple describe operational semantics readily extended describe 
lists main operations concurrent haskell including discussed 
probably noticed close similarity section mvars section 
necessary 
probably 
practice find seldom slightly different semantics empty easy simulate vice versa 
expensive implement 
ioref fundamentally unsafe concurrent program prove thread access time 
notes mainly presentational device allowed discuss idea updatable locations operational machinery support getting concurrency 
primitives simple undoubtedly primitive 
mvars surprisingly useful especially holding shared state low level device 
provide raw material fashion sophisticated abstractions higher order language haskell suited purpose channels example abstraction give 
karlsen thesis describes substantial application programming workbench implemented concurrent haskell numerous concurrency abstractions 
purpose notes undertake proper comparative survey concurrent programming leave section mentioning developed approaches concurrency declarative setting 
erlang strict functional language developed ericsson programming telecommunications applications purpose extremely successful 
erlang widely concurrent functional language world 
concurrent ml cml concurrent extension ml notion class events synchronisation constructs 
cml events similar ways haskell io actions 
cml lays particular emphasis concurrency abstractions described reppy excellent book 
exceptions timeouts member awkward squad robustness error recovery 
robust program collapse unexpected happens 
course tries write programs way fail approach insufficient 
firstly programmers fallible secondly failures simply avoided careful programming 
web server example cease file write fails disk full 
client requests seldom service code takes head empty list divides zero 
client vanishes client service thread time log error 
error thread go infinite recursion grow stack limit 
events hopefully rare unpredictable 
case web server recover error continue offer service existing new clients 
offer level robustness facilities described far 
check failure file operation tedious 
try avoid dividing zero know bug 
timeouts loops entirely inaccessible 
course exactly exceptions invented 
exception handler enclose arbitrarily large body code guarantee give programmer chance recover errors arising code 
exceptions haskell languages haskell io monad offers simple form exception handling 
operations may raise exception goes wrong exception caught handler 
primitives haskell offers string ioerror ioerror ioerror io catch io ioerror io io raise exception calling ioerror passing argument type ioerror 
construct ioerror string 
catch exception 
call catch action performed attempts perform return results 
exception thena abandoned returned exception 
exception ioerror catch catch ioerror catch ioerror catch return ioerror return extensions exceptions example extend main web server loop config socket io config socket forever conn accept socket forkio service conn service connection io service conn catch config conn handler conn handler connection exception io handler conn config hclose fst conn forked thread service conn exception handler wrapped goes wrong handler invoked 
handler logs error presumably sending message error logging thread channel held config closes connection 
gives extra semantics required support haskell exceptions style familiar 
extra evaluation context says evaluate inside catch 
rule ioerror says call ioerror propagated corresponds popping stack typical implementation 
rules catch describes happens exception meets passed handler 
lastly catch explains catch execution protected code terminates normally return haskell design falls short ways handle things go wrong purely functional code ex ception raised monad 
pattern match failure division zero brings entire program halt 
address problem section deal asynchronous exceptions 
synchronous exception arises direct result executing piece code opening non existent file example 
synchronous exceptions raised defined places 
asynchronous exception contrast raised thread environment timeout user interrupt asynchronous exception 
useful treat resource exhaustion stack overflow way 
asynchronous exception strike time harder deal synchronous cousins 
tackle asynchronous exceptions section synchronous exceptions pure code haskell allow program raise exception purely functional code 
reason input output haskell unconstrained order evaluation hard say program means 
suppose invented new primitive raise exception throw exception throw differs lacks result type 
difficulties consider expression length throw ex expression raise 
evaluate elements argument list answer presumably 
exception raised depends evaluation takes place 
exception expression raise ex 
throw ex throw ex answer clearly depends order arguments evaluated 
exception raised depends evaluation order 
input output right back section possibility fully define evaluation order reject alternative 
pattern match failure occurs function defined pattern matching applied value pattern matches 
example head empty list 
imprecise exceptions best approach take hint denotational semantics 
purely functional part language straightforward denotational semantics requires answer question value return 
answer exceptional value 
divide world values denotations ordinary values true exceptional values 
new idea 
ieee floating point standard defines certain bit patterns numbers 
nan returned floating point operation fails way division zero 
intel ia architecture extends idea arbitrary data types thing nat values represent result speculative operations failed 
terminology nan nat exceptional value 
simply constructs exceptional value 
perfectly behaved value provided evaluate exception raised 
situation similar divergent non terminating expression lazy language 
useful programs may contain values program diverge evaluates divergent term 
deals point 
solution say denotation expression single ordinary value set exceptions 
making denotation set exceptions finesse question exception raised 
return troublesome example throw ex throw ex denotation expression exceptional value consisting set exceptions ex 
saying need say evaluation order 
am suggesting implementation construct set exceptions 
idea implementation entirely conventional exception handling mechanism evaluates exceptional value rolls back stack looking handler 
effect chooses single member set exceptions act representative 
catching imprecise exception describe scheme imprecise exceptions deliberately imprecise exception chosen representative 
catch handle exception 
try non io version exception bogus evaluates argument ordinary value just returns exceptional value applies exception 
problematic exceptional value contains set exceptions member set chosen 
trouble compiler decided change evaluation order optimisation switched different exception encountered behaviour program change 
better approach separate choice exception throw business evaluate io evaluate evaluates resulting value ordinary value evaluate behaves just just returns value 
returns exceptional value evaluate chooses arbitrary member say set exceptions behaves just ioerror throws exception example consider actions io evaluate print evaluate head print return head print xs evaluate div print length xs simply evaluates binds prints equally written return 
second evaluates head finds exceptional value throws exception io monad print executes 
contrast returns exceptional value ignores prints 
lastly evaluates list div binds xs takes length prints result 
list contains exceptional value top level argument look inside recursive structure example section 
consider case argument set exceptions example evaluate throw ex throw ex action typet reason suppose choose member set exceptions time run program 
free perform input output consult external oracle raining say decide member set choose 
concretely suppose catch exception catch evaluate throw ex throw ex recall semantics defined section applied way tell 
toevaluate decide 
different non deterministic choice action evaluate pure function 
actions required return result input pure functions 
practice evaluate really non deterministic decision really taken evaluation order chosen compiler compiles argument toevaluate 
throwto evaluate evaluate evaluate return ioerror notice done ioerror catch return extensions exceptions ioerror exception raised including purely functional code 
tremendously useful 
example pattern match failure raise exception bringing execution halt 
similarly haskell provides error string called string printed execution comes halt 
extended version haskell error raises exception gives rest program chance recover failure 
exception caught catch io monad 
confines recovery monadic layer program ml say catch exception 
view restriction great semantic benefits 
particular confining non deterministic choice monad prevented non determinism infecting entire language 
semantics imprecise exceptions approach synchronous exceptions haskell described detail :10.1.1.33.8720
particular describes extend standard denotational semantics include exceptional values treated formally 
discuss lack space content saying meaning function returns ordinary value exceptional value non empty set exceptions 
example semantics addition addition function defined semantic domain values equation deals normal case 
second third deal case arguments throws exception 
equation handles case arguments throw exception case takes union exceptions thrown arguments 
point commutative gives extra semantics 
argument toevaluate ordinary value evaluate just returns value eval value exceptional value evaluate chooses arbitrary member set exceptions throws exception 
deliberately unconstrained choice non determinism shows operational semantics 
changed rule fun 
place semantics forces recognise forgotten 
rules fun fun replace fun 
fun says action perform exceptional value just propagate monad exception 
behave just fun 
example shows importance change catch recovery code catch perform action argument evaluate case evaluating gives divide zero exception rule fun propagates 
exception data type really ioerror ioerror appropriate name 
keep things simple just say ioerror synonym 
summarise primitives type ioerror exception throw exception evaluate io ioerror ioerror io catch io exception io io asynchronous exceptions turn attention asynchronous exceptions 
asynchronous exceptions add new primitive throwto threadid exception io allows thread interrupt 
far interrupted thread concerned situation just abruptly called ioerror exception raised propagated innermost enclosing catch 
threadid forked thread really useful handle send interrupt thread 
thread raise exception returned 
thread danger interruption parent parent passes thread 
asynchronous exceptions throwto implement variety abstractions inaccessible 
example program races argument actions parallel 
soon terminates kills result returned winner 
io io io implement 
mvar contain result 
spawn threads race fill result mvar succeed second block 
parent takes result mvar kills children io io io forkio child forkio child takemvar throwto kill throwto kill return child putmvar implement simple timeout timeout int io io idea timeout longer complete value returned bya timeout int io io timeout return just return want answer questions happens thread interrupted throwto executing timeout 
say sure give semantics 
semantics asynchronous exceptions express behaviour nicely semantics thread target thread abandon current action replace catch throwto return ioerror int short interrupt 
conditions line essential ensure context maximal includes 
clear external interrupts user pressing control modeled way 
write semantics answer questions 
control interrupt thread just designated thread 
thread get designated 
questions forced answer really difference programmer 
having semantics helpful answering questions happens thread interrupted blocked waiting mvar 
semantics thread simply stuck takemvar active site int cause takemvar replaced 
blocked doesn thread receiving interrupt 
say happens thread executes sub computation timeout interrupted throwto waiting sub computation complete 
parent thread receives interrupt blocked takemvar inside section abandons wait proceeds handler 
means threads spawned killed probably want 
go back fix 
fact turns tricky sure window parent spawned child thread set handler kill child parent interrupted 
programming presence asynchronous exceptions notoriously difficult modula example simply 
behaved threads regularly poll alert flag commit suicide set 
haskell differs modula ways relevant 
fewer side effects fewer windows vulnerability worry 
second large parts purely functional code able interrupt safely polling mechanism undesirable 
considerations led define new primitive combinators allow thread mask un mask external interrupts 
complicates semantics result write code chance proving race hazards 
details 
summary section exceptions experimental main themes 
papers give great deal detail design introduced outline :10.1.1.33.8720:10.1.1.26.1040
aspects asynchronous exceptions design flux time writing 
adding exceptions undoubtedly complicates language semantics desirable 
allow qualitative change robustness program 
pattern match failure code web server system recover cleanly 
exceptions failure fatal 
interfacing programs programming language world rule survival simple dance die 
beautiful language 
easy programs written beautiful language interact programs written languages 
java huge useful libraries available 
example web server extensive socket libraries written fruitless reproduce libraries haskell want easy call 
similarly want plug small haskell program large project necessary enable programs call haskell 
expect haskell part top 
haskell specify way call foreign language procedures lot progress front years survey section 
particular proposal emerged haskell language extension support foreign language interfacing 
call proposal haskell foreign function interface ffi proposal documented athttp haskell org definition ffi 
calling haskell haskell call procedure haskell ffi proposal foreign import ccall putchar char io foreign declaration brings scope haskell function putchar specified type 
function called effect call procedure called putchar 
simple eh 
complete syntax 
points worth noting foreign import foreign export ccall safe unsafe calling conventions 
io int float double char bool ptr int int int int word word word word haskell type synonym haskell ffi proposal syntax usual monad result type indicate may perform side effect 
foreign procedures may purely functional semantics 
example function really function side effects 
case extremely tiresome force monad 
haskell ffi allows keyword omit io return type foreign import ccall unsafe sin float float case unsafeperformio section unsafe indicates programmer takes proof obligation case foreign procedure genuinely functional 
keyword ccall indicates calling convention arguments passed registers stack result returned 
currently defined calling convention moment win platforms 
foreign procedure name haskell counterpart example start capital letter illegal haskell functions specify foreign name directly foreign import ccall putchar putchar char io foreign procedures may take arguments 
haskell type curried usually case multi argument haskell functions side arguments passed usual foreign import ccall int int io strictly limited range haskell types arguments results atomic types float double 
pass structured types strings arrays 
address question section 
implementation ffi proposal provide collection new atomic types 
particular ptr type uninterpreted machine addresses example pointer structure procedure 
type phantom type allows haskell programmer enforce distinction say foo baz 
actual values involved 
foreign import lets call procedure haskell 
dually foreign export lets expose haskell function procedure 
example foreign export ccall foo foo int int foreign export ccall bar float io float declarations valid module defines imports haskell specified types 
exported function may type bar 
module compiled expose procedures foo called dynamic calls quite common indirect call external procedure supplied address procedure wants call 
example dynamic dispatch method call object oriented system method table object 
indirect call haskell keyword foreign import ccall dynamic foo int io int int io int argument type taken machine address external procedure called 
case type simply express distinction pointers procedures different types 
way export dynamic haskell value uninterpreted sense treated simply bit patterns 
haskell garbage collector follow pointer 
foreign import ccall wrapper int io int io int io int declaration defines haskell function 
arbitrary haskell function type int io int returns function pointer type int io int called typically passed program subsequently uses call haskell function indirect call 
marshalling transferring control ways easy bit 
transferring data border harder 
atomic types int float clear structured types matters 
example suppose wanted import function operates strings foreign import ccall uppercase string string question data representation 
decide alter haskell language implementation string representation identical translate string representation run time 
translation conventionally called marshalling 
haskell lazy second approach required 
case tremendously constraining try keep common representations languages 
example terminates strings null character languages may keep length field 
marshalling expensive serves separate implementation concerns different languages 
come questions allocation lifetime 
put translated string 
static piece storage 
large block allocate 
safe re block call 
haskell heap 
called procedure triggers garbage collection transformed string moved 
called procedure hold string returns 
heap 
get deallocated 
expensive 
procedures accept pointer parameters strings 
reflected haskell side interface 
example sensible called string returns string haskell type foreign import ccall uppercase string string 
bottom line somewhat arbitrary choices marshalling parameters haskell vice versa 

choices consider arbitrary languages 

consensus haskell community define language extension small possible build separate tools generate marshalling code 
foreign import foreign export declarations constitute language extension 
embody just part foreign language calls done haskell 
example suppose want import procedure draws line prototype look void float float float float ideally import procedure haskell signature 
type point float float point point io ffi proposal directly 
marshalling case unpacking pairs type point float float point point io dl help foreign import ccall dl help float float float float io writing marshalling code get tedious especially adds arrays enumerations parameters passed null pointers 
tools available take specification interface input haskell code output 
notably green card pre processor haskell reads directives embedded haskell module replaces directives marshalling code 
green card write type point float float point point io call float float float float code green card specific doesn handle foreign export side things 
haskell reads haskell module special directives binding hooks standard header file emits new haskell module marshalling code added :10.1.1.26.5605
advantage compared green card information need specified binding hooks green card directives 
direct reads description interface written interface definition language idl emits haskell module containing marshalling code 
idl huge hairy language haskell specific specific 
direct deals import export read java class files idl files generate code interface com java 
scope notes give detailed tools 
cases key point tools haskell compiler implements declaration 
fact tools stresses range possible design choices benefit clear separation 
memory management major complications involved multi language programs memory management 
context haskell ffi main issues foreign objects 
procedures return pointer handle expect client longer useful 
example opening file returns file handle closed creating bitmap may allocate memory freed graphical user interface opening new window new font returns handle closed 
case resources allocated memory file descriptors window descriptors released client explicitly says 
term describe steps carried resource longer required 
problem procedure imported haskell program know handle returned procedure 
stable pointers 
dually may want pass haskell value world passing parameter foreign import returning result foreign export 
danger value live long die soon haskell garbage collector know value needed 
furthermore know garbage collector move live objects disaster address old location object away data structure 
section briefly survey solutions difficulties 
foreign objects solution problem simply require haskell programmer call appropriate procedure just fine tiresome procedures unacceptable foreign libraries purely functional semantics 
example encountered application library manipulate bit maps 
offered operations filtering thresholding combining example bit maps bmp bitmap bmp bitmap bitmap bmp allocates new bit map contain combined image leaving unaffected 
bmp haskell data bitmap bitmap phantom type foreign import ccall unsafe bmp ptr bitmap ptr bitmap io ptr bitmap notice way fresh haskell type bitmap help ensure give bmp address address bitmap 
difficulty way know finished particular bit map 
result call bmp example stored haskell data structure 
time sure bitmap longer needed haskell garbage collector finds longer reachable 
ask garbage collector track wrap foreign pointer ptr io io takes world address action returns 
garbage collector discovers longer accessible runs action 
unwrap foreign pointer ptr io io simply unwrap function io ptr foreign pointer unreferenced unwrapping call called done 
bmp foreign import ccall unsafe bmp bmp help ptr bitmap ptr bitmap io ptr bitmap foreign import ccall free bmp ptr bitmap io bmp bitmap bitmap io bit bmp bmp help free bmp function bmp argument calls bmp help get done wraps result back 
stable pointers wants write haskell library called program situation reversed compared foreign objects 
haskell library may construct haskell values return caller 
program directly representation depends haskell implementation may manipulate haskell functions exported library 
mentioned earlier simply return pointer haskell heap reasons haskell garbage collector know object longer required 
program holds pointer object collector treat object garbage way know haskell pointers held program 
haskell garbage collector may move objects ghc collector certainly address object stable way refer object 
straightforward solution problems provide way convert haskell value stable pointer io io io takes arbitrary haskell value turns stable pointer key properties stable unaffected garbage collection 
passed parameter result foreign import foreign export 
side looks int 
program subsequently pass stable pointer haskell function get original value 
second calling registers haskell value garbage collection root installing pointer stable pointer table spt 
called kept alive indefinitely spt ifv longer reachable 
die 
removes entry spt die referenced way 
incidentally alert reader may noticed foreign import wrapper described section stable pointers 
example section turns haskell function value address callable procedure 
follows stable pointer code pointed garbage collector follow refer 
wait minute 
free stable pointer embedded inside 
function addr io implementation notes relatively easy implement import declaration 
code generator needs taught generate code call appropriate calling conventions marshalling parameters small fixed range types required ffi 
dynamic variant foreign import harder 
major implementation benefit libraries built top foreign imports need code generator say primitive 
matters harder export code generator produce procedure called foreign language marshalling parameters appropriately 
foreign import wrapper generate single static address encapsulates full haskell closure 
way emit little machine code run time details summary related far concentrated exclusively interfacing programs written progress languages software architectures com microsoft component object model language independent binary interface composing software components 
language independence com attractive target haskell 
direct directly supports calling com objects haskell implementing com objects haskell 
foreign import wrapper called foreign export dynamic ture changed slightly 
corba addresses similar goals com different balance design choices 
direct read corba flavour idl generate relevant marshalling glue code 
corba interface functional logic language mercury described 
offers collection haskell libraries easy write marshalling code calling called java programs 
offers tool reads java class files emits idl fed direct generate marshalling code 
ongoing extending declaration construct support java calling conventions 
actual haskell ffi differs slightly give particular operations omitted 
details flux 
useful doing mixed language working languages support including java dylan python scheme 
hayes gives useful survey workshop gives details glasgow haskell compiler design 
section notably thorough precise earlier sections 
flavour issues tackled detailed treatment 
plain fact interfacing foreign languages thoroughly hairy enterprise matter hard build nice abstractions undoubtedly complicated 
details taken care important aspects differ operating system operating system variety interface definition languages header files idl java class files variety tools area moving quickly announcement microsoft net architecture 
lost plot 
discussed monadic approach detail may asking question added imperative looking input output concurrency shared variables exceptions simply re invented old procedural programming 
lost plot forgotten original goals functional programming 
believe 
differences conventional procedural programming monadic functional style remain substantial clear distinction enforced type system actions may side effects functions may 
distinction worth making software engineering point view 
function understood independent entity 
affect caller result returns 
called arguments deliver result 

contrast interaction action caller complex 
may read write mvars block raise exceptions fork new threads things explicit type 
reasoning laws lost monadic added 
example remains unconditionally true side conditions side effects 
important caveat am confident claim true proved 
admittedly limited experience haskell programs consist entirely functions actions small monadic skin surrounds large body code 
certainly possible write haskell program consists entirely unusual 
actions class values 
passed arguments functions returned results stored data structures 
gives unusual flexibility programmer 
question io monad sort sin bin want breaks purely functional paradigm 
bit refined 
particular argue know type expression side effects useful express type limits side effects may cause 
variant io allowed exceptions concurrency 
answer technically course 
long history research called effect systems track kind effects expression 
effect systems expressed monadic way married monadic type system 
overhead programmer greater know language uses system interesting challenge remains devise refined system practical promising direction :10.1.1.57.4184
argue simple pure impure distinction offers excellent cost benefit tradeoff 
summary surveyed haskell monadic system significant language extensions easy extend language 
extensions 
just smart compilers type effect systems guide different programmer visible type system 
describe language extensions significant impact haskell syntax type system impact semantics implementation ad hoc set responses ad hoc set demands 
new demand lead new extension 
effect achieved simpler elegant 
shall leave judgments gentle reader 
notes constitute status report developments haskell community time writing 
extensions described cover needs large class applications believe reached plateau landscape 
resulting language complicated monadic parts imperative feel 
find way simpler declarative 
extensions certainly practical describe implemented glasgow haskell compiler build real applications 
find great deal information haskell web haskell org find language definition tutorial material book reviews pointers free implementations details mailing lists 
notes improved conversations tony hoare 
tony 
want peter ken anderson richard bird paul callaghan andy cheese chen olaf javier tyson conal elliott pal kristian tony finch finne richard gomes john stefan richard kuhns ronald phil andy moran anders lau olsen andy pitts tom martin daniel russell george russell tim julian seward christian dominic steinitz jeffrey simon thompson mark tullsen richard don wakefield extremely helpful feedback 
allison practical denotational semantics 
cambridge university press cambridge england 
ariola sabry correctness monadic state imperative call need calculus 
th acm symposium principles programming languages popl san diego jan acm 
armstrong virding williams concurrent programming erlang nd edition 
prentice hall 
barendsen smetsers uniqueness typing functional languages graph rewriting semantics 
mathematical structures computer science 
benton kennedy monads effects transformations 
higher order operational techniques semantics third international workshop electronic notes theoretical computer science elsevier pp 

benton kennedy russell compiling standard ml java bytecodes :10.1.1.57.4184
icfp pp 

bird wadler functional programming 
prentice hall 
chakravarty haskell interfacing tool 
koopman clack 
felleisen hieb revised report syntactic theories sequential control state 
theoretical computer science 
finne leijen meijer peyton jones direct binary foreign language interface haskell 
icfp pp 

finne leijen meijer peyton jones calling hell heaven heaven hell 
icfp pp 

hammond michaelson eds 
research directions parallel functional programming 
springer verlag 
hayes finalization collector interface 
international workshop memory management cohen eds lecture notes computer science 
springer verlag st malo france sept pp 

hudak haskell school expression 
cambridge university press 
hudak expressiveness purely functional systems 
tech 
rep yaleu dcs rr department computer science yale university mar 
hughes donnell expressing reasoning non deterministic functional programs 
functional programming glasgow davis hughes eds 
workshops computing springer verlag pp 

hutton ed 
proceedings haskell workshop montreal sept 
tr technical reports 
acm sigplan international conference functional programming icfp baltimore sept acm 
acm sigplan international conference functional programming icfp paris sept acm 
jeffery somogyi corba binding mercury 
practical applications declarative languages san antonio texas gupta ed lecture notes computer science springer verlag pp 

jouvelot gifford algebraic reconstruction types effects 
th acm symposium principles programming languages popl orlando 
acm jan 
karlsen tool integration functional programming language 
phd thesis university bremen nov 
koopman clack eds 
international workshop implementing functional languages ifl netherlands lecture notes computer science springer verlag 
launchbury natural semantics lazy evaluation 
popl pp 

launchbury lewis cook embedding microarchitectural design language haskell 
icfp pp 

leijen hook haskell automation controller 
third international school advanced functional programming afp braga portugal lecture notes computer science springer verlag 
marlow writing high performance server applications haskell 
hutton 
marlow peyton jones elliott stretching storage manager weak pointers stable names haskell 
koopman clack 
marlow peyton jones moran asynchronous exceptions haskell 
acm conference programming languages design implementation pldi snowbird utah june acm pp 

meijer finne haskell better java 
hutton 
milner communicating mobile systems pi calculus 
cambridge university press 
moggi computational lambda calculus monads :10.1.1.26.2787
logic computer science california 
ieee june 
nelson ed 
systems programming modula 
prentice hall englewood cliffs nj 
nordin peyton jones reid green card foreign language interface haskell 
haskell workshop amsterdam launchbury ed 
peyton jones gordon finne concurrent haskell 
rd acm symposium principles programming languages popl st petersburg beach florida jan acm pp 

peyton jones meijer leijen scripting com components haskell 
fifth international conference software reuse los alamitos ca june ieee computer society pp 

peyton jones reid hoare marlow henderson semantics imprecise exceptions :10.1.1.33.8720
acm conference programming languages design implementation pldi atlanta may acm pp 

peyton jones wadler imperative functional programming :10.1.1.100.9674
popl pp 

poole public report project safety assurance diagnostic laboratory imaging 
tech 
rep mrc human genetics unit edinburgh mar 
th acm symposium principles programming languages popl jan acm 
reppy concurrent programming ml 
cambridge university press 
roscoe theory practice concurrency 
prentice hall 
schmidt denotational semantics methodology language development 
allyn bacon 
thompson haskell craft functional programming 
addison wesley 
tolmach optimizing ml hierarchy monadic types 
workshop types compilation kyoto mar lecture notes computer science springer verlag pp 

trinder hammond loidl peyton jones algorithm strategy parallelism 
journal functional programming jan 
wadler comprehending monads :10.1.1.33.5381
mathematical structures computer science 
wadler essence functional programming 
th acm symposium principles programming languages popl 
acm albuquerque jan pp 

wadler monads functional programming 
advanced functional programming jeuring meijer eds vol 
lecture notes computer science 
springer verlag 
wadler declare imperative 
acm computing surveys 
wadler marriage effects monads 
icfp pp 

wright felleisen syntactic approach type soundness 
information computation nov 

