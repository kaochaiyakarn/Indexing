quantifying behavioral differences programs brad calder dirk grunwald benjamin zorn department computer science campus box university colorado boulder usa cu cs january university colorado boulder technical report cu cs department computer science campus box university colorado boulder colorado copyright brad calder dirk grunwald benjamin zorn department computer science campus box university colorado boulder usa quantifying behavioral differences programs brad calder dirk grunwald benjamin zorn department computer science campus box university colorado boulder usa grunwald cs colorado edu january improving performance programs topic great interest years 
hardware technology compiler optimization research applied effort programs execute faster 
application domains language replacing programming language choice 
measure empirical behavior group significant programs attempt identify quantify behavioral differences 
goal determine optimization technology successful programs successful programs 
furthermore identify behavioral characteristics programs suggest optimizations applied programs 
results show programs exhibit behavior significantly different programs 
results interest compiler writers architecture designers designing systems execute object oriented programs 
design computer architecture typically driven needs various programs programming languages 
significant amount research compiler optimization architecture design conducted specific goal improving performance existing conventional programs 
early studies program behavior guided architectural design importance measurement simulation architectural design philosophy 
particular berkeley stanford risc guided studies fortran programs 
studies spec program suite 
set programs widely benchmark new hardware platforms compiler implementations consists mixture fortran programs :10.1.1.121.1786
object oriented programming specifically language replacing procedural languages number application areas including data structure libraries scientific computing operating systems 
language superset additional features provided language support programming style different conducting research reported hypothesis programs exhibit behaviors measurably different programs confirms hypothesis 
seek quantify differences identify existing hardware software optimizations support support 
hardware designers optimizing compiler writers information programs behave exploit behavior effectively 
example register windows included risc architecture observed programs tended small set stack frames long periods time 
quantitative measurements program behavior great value compiler writers hardware designers 
measured behavior large programs large programs including programs provided specint benchmark suite 
measured dynamic execution programs including function size basic block size instructions conditional branches call stack depth indirect function calls memory operations measurements cache locality 
highlight differences programs break measurements subcategories comparing behavior methods versus non methods 
results indicate programs measured behave significantly differently aspect behavior 
furthermore differences indicate hardware software optimizations effective programs effective programs 
conclude new optimizations considered necessary programs appropriate programs 
hardware designers compiler writers results construct new generation systems execute programs significantly efficiently 
section describes related area program behavior measurement 
section describes tools collect measurements programs measured 
section includes basic data gathered interpretation section discusses implications results 
summarize section 
background section describe related investigating empirical behavior programs 
falls roughly categories measurements different aspects program behavior measurements instruction set usage particular architectures 
program behavior measurement large numbers studies various aspects behavior different kinds programs 
knuth measured static dynamic behavior large collection fortran programs 
things concluded programmers poor intuition parts programs time consuming execution profiles significantly help improve performance programs 
area program behavior measurement prior summarized describing dhrystone benchmark 
results create small benchmark program dhrystone intended simulate average systems program behavior reported previous 
updated dhrystone benchmark creating version version dhrystone measure 
measurements number aspects program behavior appeared 
spec benchmark suite years compare performance new computer architectures investigated terms instruction set usage cache locality studies called suite :10.1.1.121.1786
mention measurements measurements include specint programs compared directly previous results 
area concentrated behavior programs written single language focus comparing relative behavior programs written closely related languages 
particular interested measuring aspects behavior exploited better hardware aggressive software optimizations 
instruction set architecture measurement area related measurement instruction set architectures 
practice commonly architecture designers understand features hardware 
clark levi report instruction set vax conclude different programs different parts large vax instruction set 
investigates compilers vax instruction set 
similarly sweet reports static instruction set usage mesa instruction set mcdaniel reports dynamic instruction set usage mesa 
analyses conducted give architecture designers insight improve generation architecture 
approach architecture design familiar method described popular textbook computer architecture quantitative approach 
published measurements kind concentrated spec benchmark programs 
spec benchmarks widely compare system performance workstations compiler writers architects study similar programs detail 
modifying compilers architectures information spec suite lead spec performance may improve programs 
example prior spec program suite manufacturers original dhrystone program compare system performance 
numerous compiler optimizations primarily optimizing string operations occur frequently dhrystone program implemented optimizations greatly benefited dhrystone performance dramatically improve programs different behavior 
measurements include aspects instruction set usage indicate differences hardware designers see programs 
furthermore programs collected serve initial set benchmarks way specint specfp benchmarks currently 
methods section describe methods collect data section 
specifically describe programs measured tools collect measurements format data 
application programs measured large programs large programs dhrystone benchmark 
programs include specint benchmark suite 
large program suite precluded investigating additional programs fortran programs specfp benchmark suite studies provide comparisons 
function programs input datasets described tables 
cfront conversion program version 
input provided part implementation preprocessed 
congress interpreter prolog language 
input examples distributed congress configuration management 
doc interactive text formatter interviews library 
input involved interactively browsing page document editing capabilities program 
dump dump scans representation program converting textual form 
groff groff version version ditroff text formatter 
input collection manual pages second page 
inputs ditroff 
interactive structured graphics editor interviews library 
input involved drawing editing simple 
structured graphics morphing demonstration interviews library 
input morphed running man example distributed program 
rt advanced ray tracing program indiana university featuring extensive templates 
ray tracing shell interactive ray tracing environment tcl tk user interface graphics library 
input small ray traced image distributed program 
idl sample backend interface definition language system distributed object management group 
input sample idl specification graphics library 
table general information programs 
ditroff version ditroff text formatter 
input collection manual pages second page 
inputs groff 
interactive dvi file 
input interactive session page document viewed forwards backwards 
xfig interactive structured graphics editor version 
input involved drawing editing simple 
interactive dvi version 
input interactive session page document viewed forwards backwards 
compress file compression program version uses adaptive lempel ziv coding 
test input required compressing byte file 
eqntott translator logic formula truth table version 
input file int pri eqn 
espresso logic optimization program version minimizes boolean functions 
input file example provided release code cps 
li lisp interpreter adaptation xlisp written david michael 
input measured solution queens problem 
sc spreadsheet program version 
input involved cursor movement data entries file handling computation 
gcc benchmark version gnu compiler version 
measurements show execution cc phase compiler 
input preprocessed line file stmt 
dhrystone version small synthetic benchmark program intended mimic observed behavior systems programs 
program require input 
table general information programs 
program size kbytes total instr total func calls total calls compiled cfront att congress gnu doc gnu dump gnu groff gnu groff gnu gnu gnu rt att gnu ditroff gnu cc ditroff gnu cc gnu cc xfig gnu cc gnu cc compress gnu cc espresso gnu cc eqntott gnu cc li gnu cc sc gnu cc gcc gnu cc dhrystone gnu cc idl dec table information program executions 
total calls indicates number indirect function calls executed program 
programs compiled gnu gnu cc compiled version compiler 
idl compiled version dec compiler 
cases optimization enabled 
measurements conducted mips decstation workstation 
sought large programs terms source code size terms executable size possible selected programs widespread familiar broad audience users 
sought programs measurement studies conducted specint programs met requirement 
sought programs written provide similar functionality 
example measure ditroff troff processor written groff troff processor written 
particular case input files provided programs exactly 
programs paired way xfig picture drawing programs doc document doc way editor capabilities gcc cfront translators 
included programs written object oriented style language 
sought programs representing range object oriented programming styles 
familiar origin history development programs measured insight programming style 
information program executions measured provided table 
note cases ditroff groff information runs different inputs 
include results give indication sensitivity measurements different input sets 
information table important characteristics test programs apparent 
important observation cfront written indirect function calls 
behavior immediately conclude virtual methods defined cfront program dynamic dispatch important characteristic object oriented paradigm 
leads believe cfront take advantage benefits object oriented paradigm closer behavior programs programs 
measurements cfront confirm observation 
explanation behavior cfront bootstrap translator developers advantage subset full set features translator 
result presenting summaries programs include means medians includes cfront 
programs note doc interactive windows applications implemented interviews class library 
interviews large class library evolved changed evolution 
note mark linton designer interviews active user years instrumental shaping design language 
familiar features provided interviews library reflects knowledge 
early interviews program implemented version library 
interviews graphical objects larger encompassing functionality object 
interviews larger graphical objects replaced small glyphs simple objects composed form complex objects 
example provide single button object multiple parameters define button user creates object wraps object handles input events 
library software reuse encouraged constructing small objects composing 
programs doc considerable software reuse primitive object composed variety functions 
interestingly table shows eqntott program performs large number indirect function calls 
behavior explained fact main computation eqntott sorting execution time spent library 
function compare values routine passed argument called indirectly 
tools metrics section results including average function size average basic block size percentage stores loads 
measurements dynamic execution programs collected modified version qpt program operation trace generator :10.1.1.14.8824
instrumented programs executed decstation workstation megabytes memory 
qpt able identify function calls basic block transitions instruction fetches data loads stores operations occur program execution 
modifications able determine indirect function calls occur target function indirect call 
identify distinguish functions methods functions invoked 
function function compiled compiler function compiled conventional compiler 
methods functions associated objects 
information allows classify behavior basic block size type function basic block occurs 
break measurements way 
cache performance measurements report obtained modified version associativity cache simulator 
modification involved making stand program callable library linked instrumented executable 
allows measure performance caches different simultaneously simulated direct mapped caches byte cache lines 
program term term meth meth indirect direct cfront congress doc dump groff groff rt ditroff ditroff xfig compress espresso eqntott li sc gcc dhrystone idl mean mean cfront table percentage invocations measurements dynamic program execution perform static analysis program unable determine functions program leaf functions contain function calls 
able determine functions function calls particular input dataset call functions terminal functions distinguish leaf functions 
clearly leaf functions subset terminal functions 
explanation data section results measurements application programs uniform way 
tables quite complex describe format detail 
understand format consider table shows function calls applications classified 
table contains row program measured programs appearing programs 
specint programs separated programs numbered 
bottom tables measurements dhrystone benchmark mean program measurements mean program measurements separate rows 
row bottom shows mean including cfront application 
rows appear separate inputs groff ditroff average inputs included final means 
row table divided columns column program name 
columns break data pairs alternatives 
final column presents value program breakdown 
example table shows kinds functions called test programs 
pairs columns table represent comparisons columns comparison behavior functions methods defined versus functions defined functions called functions programs libraries 
distinguish methods functions functions looking function name 
comparison meaningful programs obviously invoke functions 
table see approximately function invocations programs methods functions functions 
columns comparison behavior terminal term versus non terminal term functions 
table see programs average calls terminal functions average calls terminal functions 
columns comparison behavior methods meth versus non methods meth 
programs contain methods distinction meaningful programs 
table see programs average function calls methods 
furthermore programs doc percentage higher 
cfront performs significantly fewer method calls average programs 
columns comparison behavior functions invoked indirectly versus directly 
part programs perform indirect function calls columns interest programs 
table see average function calls programs indirect calls indirect 
furthermore see average heavily influence eqntott benchmark mentioned 
see cfront unusual program performing essentially indirect function calls 
dhrystone benchmark program included results show emulates behavior programs measured 
note program idl appears bottom table 
include idl currently unable distinguish method calls function calls function calls idl due compiled dec compiler 
result versus columns method versus non method columns correct idl 
reason include idl mean row 
measures execution idl correct include provide data additional program 
provide insight specific behavior programs include table presents fraction method calls top line function calls second line function calls third line applications 
note table indicates percentage calls particular type function 
example cfront table shows calls methods versus non methods calls methods 
table illustrates doc method intensive programs cfront 
results section intentionally resisted urge summary information means believe important reader able consider behavior program term term meth meth indirect direct cfront congress doc dump groff groff rt table percent method calls function calls function calls program term term meth meth indirect direct cfront congress doc dump groff groff rt ditroff ditroff xfig compress espresso eqntott li sc gcc dhrystone idl mean mean cfront table mean number instructions invocation individual programs information valuable 
example believe doc program represents application written object oriented style readers may interested drawing behavior program 
dynamic function size section investigate average size instructions functions methods called program 
note report dynamic measure function size number instructions executed function counted time called 
function size important small functions proportionally greater fixed function call overhead saving registers setting arguments 
benefit optimizations inlining 
see function size probably significant effect instruction cache performance 
table contains data 
table shows size terminal functions versus non terminals methods versus non methods significant result notice table dynamically functions methods shorter functions average instructions versus instructions 
fact functions programs counted column mean see average size functions methods instructions times smaller average function 
useful consider functions methods count functions part program repeatedly refer column mean row exclusive mean 
table see methods smaller non methods versus instructions 
likewise terminal functions smaller non terminals 
program term term meth meth indirect direct cfront congress doc dump groff groff rt ditroff ditroff xfig compress espresso eqntott li sc gcc dhrystone idl mean mean cfront table mean number instructions basic block specific programs worthy note 
compress performs entire file compression single non terminal function average instructions non terminal higher programs 
cfront displays appears similar programs programs average instructions invocation 
explanation smaller functions lies object oriented approach implementing program functionality class methods method performs relatively small specific function class 
decomposing large program approach appears result programs invocations small functions 
basic block size table shows dynamic mean number instructions basic block test programs 
larger basic blocks offer opportunity architecture specific optimizations instruction scheduling 
case see programs tend significantly instructions basic block programs 
difference mean instructions exclusive mean instructions striking 
cfront exclusive mean higher instructions 
table shows basic blocks larger methods instructions non methods instructions 
table shows functions called indirectly instructions basic functions called directly versus instructions 
believe main reason observed behaviors dispatched methods replace conditionals object oriented programs 
testing conditionals execute sequence instructions done procedural programs object oriented programs perform dynamic dispatch method object type 
furthermore method entered execution context instructions percentage breaks cond branches program breaks cb ij uj pc ret ft cfront doc groff idl ditroff xfig compress espresso eqntott li sc gcc mean mean table percentage breaks program 
note programs shown 
programs dump rt measured time 
completely determined result methods contain straight line code resulting larger basic blocks 
breaks program execution section investigate frequency different kinds breaks program control flow 
results related previous results showing size basic blocks functions 
table column shows percentage branch instructions cause break control flow graph 
columns decompose number branches classes conditional branches cb indirect jumps ij unconditional branches ub procedure calls pc procedure returns ret 
table shows percentage conditional branches fall ft percentage conditional branches taken 
programs tend breaks control flow programs 
table shows programs execute times indirect jumps programs probably due entirely virtual function calls 
actual ratio probably higher due fact eqntott program executes inordinate number indirect function calls sort routine 
modern pipelined architectures rely predictable sequence instructions type break control predicted different mechanisms 
direction branch destination indirect call return stall processor instruction cycles modern architectures 
conditional branch prediction studied number researchers lilja mcfarling smith surveys 
emma showed hardware return stack effectively predicted destination procedure returns 
related shown indirect functions effectively predicted programs 
table examine conditional branches common type branch 
table shows average number instructions conditional branch instructions test programs 
table see relation saw comparing basic program term term meth meth indirect direct cfront congress doc dump groff groff rt ditroff ditroff xfig compress espresso eqntott li sc gcc dhrystone idl mean mean cfront table mean number instructions conditional branch block sizes 
exclusive mean instructions twice large mean indicating programs tend fewer conditional branch statements 
trends follow seen basic block size results 
specifically see methods tend fewer conditional branches non methods functions called indirectly tend fewer conditional branches functions called directly 
fact virtual functions methods called indirectly average instructions basic block average instructions invocation indicated presence conditional branch function average 
table examine conditional branches indirect jumps 
table shows average number instructions types unpredictable breaks program control flow 
consider returns tables returns accurately predicted return stack pose problems modern architectures 
programs dynamic dispatch virtual functions conditional logic 
architecturally substitutes indirect function calls conditional branches 
expect difference number instructions conditional branches programs reduced indirect function calls considered conditional branches table see case 
average number instructions break reduced exclusive mean instructions mean remains instructions 
results confirmed reconsidering table 
breaks programs arise conditional branches comprise breaks programs 
implies handling indirect jumps returns properly increasingly important increasing popularity 
indirect jumps frequent researchers examining methods reduce program term term meth meth indirect direct cfront congress doc dump groff groff rt ditroff ditroff xfig compress espresso eqntott li sc gcc dhrystone idl mean mean cfront table mean number instructions break program including indirect function calls conditional branches overhead :10.1.1.48.715
language designed efficient introducing additional costs specific features dynamic dispatch 
example careful design produced numerical library efficient related fortran library efficient operating systems written 
cases eschew expensive features dynamic dispatch achieve efficiency 
feel eliminate reduce costs simplify software design 
call stack depth measured mean median variance call stack depth applications 
median interquartile range th percentile minus th percentile 
measurements mean show results included median variance metric uses interquartile range easier relate median 
table shows median call stack depth table shows interquartile range 
tables illustrate striking difference programs 
table medians see median call stack depth programs averages functions programs functions 
doc dump programs illustrate extreme cases behavior twice deep mean programs 
course depth call stack application input dependent case li lisp interpreter solving queens problem recursive invocations create deeply nested call stack program 
li appears program term term meth meth indirect direct cfront congress doc dump groff groff rt ditroff ditroff xfig compress espresso eqntott li sc gcc dhrystone idl mean mean cfront table median call stack depth 
li included mean extreme outlier 
quite applications 
conclude program call stacks deeper program call stacks 
behavior explained smaller functions composed implement complex task fewer opportunities inline function expansion 
difference variance call stack depth programs striking 
table see interquartile range functions interquartile range functions 
mentioned earlier motivation register window architectures programs displayed relatively small variance call stack depth 
results confirm observation programs suggest programs benefit hardware 
memory operations measured compared frequency memory operations programs results provided table loads table stores 
modern computer architectures sensitive number memory operations hardware mechanisms caches seek mask problems 
tables show fraction load store instructions test programs 
see significant differences programs tables 
particular performs greater percentage loads exclusive mean versus mean greater percentage stores exclusive mean versus mean 
adding numbers see code programs perform greater memory operations programs performing equivalent tasks versus 
program term term meth meth indirect direct cfront congress doc dump groff groff rt ditroff ditroff xfig compress espresso eqntott li sc gcc dhrystone idl mean mean cfront table variance quantile quantile call stack depth 
li included mean extreme outlier 
see tables higher fraction memory operations methods non methods functions called indirectly directly 
feel results may explained ways 
significant contribution high rate memory operations probably due register saves restores function calls 
seen deeper call stack variance characteristics result register saves restores 
reason explain increased percentages loads stores observed roughly equal loads stores 
additional loads may occur due virtual functions functions called indirectly require additional memory load function address object dispatch table 
dynamic storage allocation section investigate dynamic storage allocation performed test programs 
table records number allocations distribution size objects allocated 
previous showed memory allocation time consuming operation easy optimize resulting performance improvements 
table shows absolute number allocations calls calls performed test program number instructions allocations metric commonly modeling memory allocation algorithms 
table shows mean median object size test programs 
program term term meth meth indirect direct cfront congress doc dump groff groff rt ditroff ditroff xfig compress espresso eqntott li sc gcc dhrystone idl mean mean cfront table percent loads program term term meth meth indirect direct cfront congress doc dump groff groff rt ditroff ditroff xfig compress espresso eqntott li sc gcc dhrystone idl mean mean cfront table percent stores number alloc size program frees mean median frees cfront congress doc dump groff groff rt ditroff ditroff xfig compress espresso eqntott li sc gcc dhrystone idl mean mean cfront table information allocation deallocation memory 
alloc size shows mean median size objects allocated bytes 
table see programs deallocate memory allocate 
surprising may programs act way due semantics unix free operation specifically allows null pointers passed 
applications careful values passed free pass null pointers unintentionally 
unintentional frees harmless point view correct execution waste machine cycles 
table see striking differences programs 
programs appear allocate far fewer objects programs average number order magnitude smaller programs 
see extreme outliers programs compress ditroff allocate handful dynamic objects 
programs skew mean instructions allocation measure programs excluded clear average instructions allocations remaining programs significantly higher programs 
frequency allocation clearly higher relative size allocated objects clear 
mean object size significantly smaller mean mean heavily influenced programs compress li eqntott allocate large objects small objects 
likewise mean medians heavily influenced programs 
specific programs mean see median object size programs tends smaller programs allocate objects espresso 
results indicate programs allocate objects heap objects small objects range bytes size 
programs allocate heap objects sizes objects quite large byte objects buffered 
important draw data efficient correct dynamic storage allocation quite important programs 
correct deallocation objects hard note extra frees program programs benefit forms automatic storage management 
example interviews library doc provides automatic counting interviews objects 
conservative garbage collection algorithms shown effective programs 
interesting question arises heap allocation programs 
undoubtedly reasons summarize possibilities important reason object oriented languages stress creation reusable components return heap allocated objects result 
kind interface results higher memory usage reduces complexity interface lifetime objects created constrained 
trade offs flexibility memory efficiency changed dramatically existing libraries written 
important reason differences may historical 
programs originally constrained execute small address space stack allocation important environment 
newer language machines longer tight memory constraints machines 
furthermore programmers include programmers include lisp smalltalk programmers languages heap allocation common 
important difference support languages provide heap allocation 
provided simple library interface supports allocation deallocation syntactic semantic conveniences constructors destructors new delete 
david ungar eliot moss john ellis mario wolczko thoughts matter 
cache performance program cfront congress doc dump groff groff rt ditroff ditroff xfig compress espresso eqntott li sc gcc dhrystone idl avg cfront table rates direct mapped instruction cache section investigate instruction data cache rates different test programs 
cases discuss rates direct mapped caches ranging kilobytes kilobytes size 
associativity cache simulator measured caches multi way associativity 
results caches greater associativity mirror direct mapped cache results 
instruction cache instruction cache rate measure locality instruction fetches program 
table shows instruction cache rates test programs caches different sizes 
tables clearly show cache rate programs usually significantly lower programs caches sizes 
means table programs require caches approximately times larger programs achieve similar rates 
text size executable affect cache rate surmise increase cache rate correlated size executable 
fact programs large executables megabyte greater includes ditroff ditroff cache rate near average rate 
srivastava showed programs tend contain considerable number unreachable functions 
caused language semantics software development environment 
subclass redefines method provide body method final program determined method called 
information determined program linking link time optimizations commonly implemented 
program cfront congress doc dump groff groff rt ditroff ditroff xfig compress espresso eqntott li sc gcc dhrystone idl avg cfront table rates directed mapped data cache initially felt differences rate attributed sampling error 
programs execute short periods time suffer disproportionate number cold start cache misses 
examining programs execute similar durations hypothesis 
example comparing table table shows programs execute comparable number instructions programs lower rates compare xfig ditroff cfront groff 
cause poor rates increased functional composition perform complex tasks seen indications behavior data collected 
executing large monolithic functions perform task case programs programs tend perform calls small functions 
programs benefit spatial locality larger cache blocks suffer function call overhead 
note occurs applications performing similar functions 
example table shows groff larger rate ditroff table shows groff executes fewer instructions accomplish task 
fact feel smaller function size programs shown table causes instruction cache rates 
instruction caches sizes range kb mb 
particular function instruction conflict cache locations 
comparison programs containing small functions may suffer instruction cache conflicts example mutually recursive functions may aligned memory cache addresses constantly displace cache 
programs larger functions done particular function leading fewer conflicts 
data cache data cache rate measure locality program access data stack static data segment heap 
table shows data cache rates test programs caches different sizes 
data cache rates see differentiation programs 
small caches differences negligible large caches programs appear higher rate see 
averages quite similar notable differences programs 
important note programs compress sc significant outliers strongly influence mean especially cases larger caches 
programs included mean mean rate kilobyte cache drops close mean 
probably important difference programs illustrated table higher variance data cache rate applications ranging kilobyte cache applications rates range size cache 
applications interviews library commonly counting simplify reuse specific object instances 
example doc application document editor 
editor representation word foo instances information concerning specific letters structured linked list elements forming 
sharing reduces amount data needed possibly reducing data cache rates 
programs employ mechanism object oriented languages simplify bookkeeping 
lack significant difference means increased heap allocated data appears result significant increase data cache rate 
comments dhrystone benchmark previous tables include results measuring dhrystone systems programming benchmark 
previous discussion failed mention dhrystone results relate programs measured summarize relation 
dhrystone fails capture behavior test programs metrics measured 
particular dhrystone mean number instructions invocation smaller means versus versus mean number instructions basic block smaller means versus versus mean number instructions conditional branch program breaks close versus median call stack depth far smaller versus versus variance call stack depth far smaller versus versus loads stores executed programs dhrystone mean close mean dynamic data allocated close behavior programs data instruction cache rates lower actual programs 
measurements appears dhrystone captures conditional statement behavior programs reasonably fails capture important aspects program behavior fraction memory operations call stack depth function size 
implications presentation measurements previous section discussed believe reasons certain behavioral differences programs 
section hope synthesize material illustrate implications differences compiler writers architecture designers 
noted instructions executed functions programs measured programs 
section showed programs larger basic blocks programs 
noted programs fewer conditional branches significantly indirect jumps 
noted programs larger load images 
short programs tend shorter procedures reached indirect function calls resulting deeper variable call stacks 
combination characteristics poses challenges opportunities compilers architects 
procedure inlining promising difficult accomplish due larger number indirect function calls interprocedural data flow analysis :10.1.1.48.715
studies shown procedure inlining problematic improve program performance 
attribute procedure inlining removes procedure calling overhead overhead obviously larger percentage small procedures 
automated procedure inlining decisions benefit programs programs inlining procedures result code expansion promising candidates inlining 
relevant area done self language :10.1.1.121.1786
related considerable opportunity similar optimizations programs particular profile directed multi version procedure inlining may perform 
dynamic type checks inlined procedures expand frequently executed methods runtime checks may eliminated compile time type analysis :10.1.1.48.715
procedure inlining reduces calling overhead reduce number load store operations 
observations imply traditional intraprocedural optimizations called global optimizations effective programs programs subroutines contain fewer instructions 
traditional optimizations performed procedure global register allocation constant propagation slightly effective 
balanced slightly larger basic blocks programs 
larger basic blocks imply instruction scheduling simpler importance conditional branch prediction decrease cost mispredicted branches amortized larger number instructions 
addition related programs tended predictable conditional branches traditional branch prediction mechanisms effective similar set programs 
part occurs programs tend fewer branches reducing demands extant resources 
benefits substituting fewer branches indirect function calls dependent underlying architecture fact attempts reduce number indirect functions substituting conditional branches existing architectures provide architectural support conditional branches 
despite presence branches easier predict slightly larger basic blocks feel programs benefit programs architectures offering instruction level parallelism 
architectures schedule instructions concurrently 
vliw architectures compiler performs scheduling superscalar architectures compiler architecture cooperate schedule parallel instructions 
take advantage vliw superscalar techniques programs compilers able analyze target dynamic method dispatches 
likewise architectures able resolve target method dispatch early possible 
case compiler architecture require predictable control flow occurs frequently programs programs 
programs programs dynamically allocate small objects heap 
implies improvements memory allocation customizing memory allocator application effective programs 
negligible difference data cache performance shown implies specific optimizations data cache locality necessary 
comparison optimizations instruction caches possibly virtual memory systems important programs programs 
notable observations programs instrumented programs deeper call stacks variation call depth stack depth programs 
procedure activation calling conventions core architectural optimizations example berkeley risc architecture proposed rotating register windows part project relied compiler implementations dated wide time 
research indicated register windows advantageous sophisticated compile link time analysis performed 
initially felt register windows benefit programs programs complexity interprocedural analysis presence indirect function calls reduce effectiveness link time optimizations 
register window underflow overflow bane register window implementations 
windows allocate existing windows flushed likewise windows may need loaded memory 
overflows underflows occur frequently variance call stack depth increases actual impact particular configuration depends myriad options number register windows spill policy fill policy 
space limitations preclude pursuing subject detail topic research 
feel erratic behavior programs coupled relatively short procedures recorded indicates variable sized register windows offering considerable windows containing variable number registers increasingly promising 
furthermore presence register windows link time optimizations proposed wall important 
object oriented languages allow programmers extend class hierarchy affecting functionality previously compiled procedures 
means programmer class compile modules interface class 
time class declared subclass 
original programs operate instances class class optimizations permitted class detected 
general optimizations detected program link time code bodies associated program assembled 
complete class hierarchy visible compiler specific optimizations considered 
example subclasses class may inherit particular method say foo 
method may called absence information full class hierarchy compiler encode calls method dynamic dispatch 
direct function call inlined function expansion possible call foo call foo 
related indirect function calls similar programs eliminating simple link time optimization 
short object oriented languages employing object oriented features force program optimizers perform optimizations total program available typically link time 
feel link time analysis allows programs possibly statically typed object oriented languages execute efficiently architectures designed conventional languages fortran 
general optimizations benefit programs written traditional languages fortran incremental benefit apparent languages 
comparison optimizations essential object oriented languages 
sur highly optimizing compilers object oriented languages typically perform optimizations full program available :10.1.1.121.1786
ideally optimizations reduce propensity programmers emerging technology micro optimize existing applications 
example prior development efficient register scheduling algorithms number computer languages provided hints compiler indicate variables stored registers programmer intuition incorrect 
similarly believe current design languages heavily influenced extant compiler infrastructure dearth systems effective link time optimizers led language designers employ series complicate language design software engineering process 
summary collected instrumented number programs order empirically quantify differences programs 
measured number parameters interesting compiler writers computer architects 
empirical studies programs programming languages fraught problems analyze programs produce meaningful results manage great quantity generated data 
caveat results concluded may dependent programs measured feel notable differences programs programs execute fewer conditional branches programs approximately times indirect function calls functions shorter larger basic blocks programs tend perform procedure calls programs issue loads stores programs programs worse instruction cache locality programs allocate approximately times objects heap objects smaller programs 
measured performance dhrystone benchmark version different ways programs 
measurements expect optimization architectural features perform worse local optimization non interprocedural fixed sized register windows interprocedural analysis call chains deeper indirect calls efficient implementations dynamic storage allocation 
measurements believe new approaches optimizations architectures successful improving program performance better interprocedural register allocation techniques minimize register save restore traffic increased support indirect call prediction support automatic dynamic storage allocation garbage collection 
owe great debt james larus supporting creating maintaining qpt study possible time tools developed 
alex wolf supplying dump program numerous discussions software metrics 
similarly mark linton assistance interviews applications comments concerning history 
peter shirley contributed rt ray tracing application 
lastly developers internet create tool uniquely qualified significant amounts shared software available measurement 
partially supported digital equipment external research number 
abu kuck lawrie 
performance enhancement paging systems program analysis transformation 
ieee transactions computers may 
alexander 
static dynamic characteristics programs 
ieee computer pages november 
jean baer 
segmentation optimization programs cyclic structure analysis 
proc 
afips pages 
brad calder dirk grunwald 
fast accurate instruction fetch branch prediction 
st annual international symposium computer architecture april 
appear 
brad calder dirk grunwald 
reducing indirect function call overhead programs 
acm symposium principles programming languages january 
appear 
campbell russo johnston 
design multiprocessor operating system 
proc 
usenix workshop 
craig chambers david ungar 
customization optimizing compiler technology self object oriented programming language 
proceedings sigplan conference programming language design implementation pages portland june 
douglas clark henry levy 
measurements analysis instruction set vax 
ninth annual symposium computer architecture pages austin tx april 
cmelik kong kelly 
analysis mips sparc instruction set utilization spec benchmarks 
th international conference architectural support programming languages operating systems pages santa clara ca april 
john cocke peter markstein 
measurement program improvement algorithms 
information processing pages 
ifip north holland publishers 
jack davidson anne holler 
subprogram inlining study effects program execution time 
ieee transactions software engineering february 
david detlefs benjamin zorn 
memory allocation costs large programs 
software practice experience 
appear 
david 
register allocation free stack machine 
proceedings symposium architectural support programming languages operating systems pages palo alto ca march 
jack dongarra david walker 
lapack design overview object oriented extensions high performance linear algebra 
proceedings supercomputing pages 
ieee press november 

numerical profile pl programs 
software practice experience 
domenico ferrari 
improving locality critical working sets 
communications acm 
joseph fisher 
trace scheduling technique global microcode compaction 
ieee transactions computers july 
dirk grunwald benjamin zorn 
efficient synthesized memory allocators 
software practice experience august 
hall brien 
performance characteristics architectural features ibm risc system 
th international conference architectural support programming languages operating systems pages santa clara ca april 
hartley 
compile systems 
ieee transactions software engineering 
gerald 
program virtual memory 
ibm systems journal 
john hennessy david patterson 
computer quantitative approach 
morgan kaufman publishers 
mark hill 

university wisconsin madison wi 
unix manual page 
mark hill 
aspects cache memory instruction buffer performance 
phd thesis university california berkeley berkeley ca november 
appears tech report ucb csd 
urs lzle craig chambers david unger 
dynamically typed object languages polymorphic inlined caches 
proc 
springer verlag july 
david philip emma 
branch history table moving target branches due subroutine returns 
th annual international symposium computer architecture pages 
acm may 
manolis 
reduced instruction set computer architecture vlsi 
acm doctoral dissertation award series 
mit press 
brian kernighan dennis ritchie 
programming language 
software series 
prentice hall 
englewood cliffs nj 
donald knuth 
empirical study fortran programs 
software practice experience 
james larus thomas ball :10.1.1.14.8824
rewriting executable files measure program behavior 
technical report computer sciences department university wisconsin madison madison wi march 
david lilja 
reducing branch penalty pipelined processors 
ieee computer pages july 
mark linton john vlissides paul calder 
composing user interfaces interviews 
ieee computer february 
lam smith horowitz 
efficient superscalar performance boosting 
proceedings th symposium architectural support programming languages operating systems pages boston mass october 
acm 
gene mcdaniel 
analysis mesa instruction set dynamic instruction frequencies 
proceedings symposium architectural support programming languages operating systems pages palo alto ca march 
scott mcfarling 
program optimization instruction caches 
proceedings rd symposium architectural support programming languages operating systems pages 
acm 
scott mcfarling john hennessy 
reducing cost branches 
th annual international symposium computer architecture pages 
acm 
wen mei hwu chang 
achieving high instruction cache performance optimizing compiler 
th annual annual international symposium computer architecture sigarch newsletter pages 
acm acm 
pande ryder :10.1.1.48.715
static type determination 
technical report lcsr tr rutgers univ february 
mark hill 
cache performance integer spec benchmarks risc 
computer architecture news june 
ramakrishna rau joseph fisher 
instruction level parallel processing history overview perspective 
journal supercomputing 
david rosenblum alexander wolf 
representing semantically code 
proceedings rd conference pages 
usenix april 
smith 
study branch prediction strategies 
th annual international symposium computer architecture 
acm 
amitabh srivastava 
unreachable procedures object oriented programming 
letters programming languages systems 
appear 
amitabh srivastava david wall 
practical system intermodule code optimizations link time 
journal programming languages march 
available dec wrl tr 
standard performance evaluation fairfax va spec cfp technical manual release edition 
standard performance evaluation fairfax va spec cint technical manual release edition 
steenkiste hennessy 
simple interprocedural register allocation algorithm effectiveness lisp 
acm transactions programming languages systems january 
richard sweet jr james 
static analysis mesa instruction set 
proceedings symposium architectural support programming languages operating systems pages palo alto ca march 
andrew tannenbaum 
implications structured programming machine architecture 
communications acm march 
carl waldspurger william weihl 
register relocation flexible contexts multithreading 
th annual annual international symposium computer architecture sigarch newsletter pages 
acm acm press may 
david wall 
register windows vs register allocation 
proceedings acm sigplan conference programming language design implementation volume pages atlanta ga june 
david wall michael powell 
mahler experience intermediate language machine description 
second international conference architectural support programming languages operating systems pages 
acm october 
reinhold 
dhrystone synthetic systems programming benchmark 
communications acm october 

case study vax instruction set usage compiler execution 
proceedings symposium architectural support programming languages operating systems pages palo alto ca 
benjamin zorn 
measured cost conservative garbage collection 
software practice experience july 
benjamin zorn dirk grunwald 
evaluating models memory allocation 
acm transactions modelling computer systems 
appear 

