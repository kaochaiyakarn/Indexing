usenix association proceedings th symposium operating systems design implementation boston massachusetts usa december advanced computing systems association usenix association rights reserved information usenix association phone fax email office usenix org www www usenix org rights individual papers remain author author employer 
permission granted noncommercial reproduction educational research purposes 
copyright notice included reproduced 
usenix acknowledges trademarks 
cmc pragmatic approach model checking real code david park andy chou dawson engler david dill system errors emerge intricate sequence events occurs 
practice means systems errors trigger days weeks execution 
model checking effective way find subtle errors 
takes simplified description code exhaustively tests inputs techniques explore vast state spaces efficiently 
unfortunately model checking systems code wonderful done practice building models just hard 
take significantly time write model write code 
furthermore checking abstraction code code easy errors 
contribution new model checker cmc checks implementations directly eliminating need separate description system behavior 
major advantages reduces effort model checking reduces missed errors time wasting false error reports resulting inconsistencies description actual implementation 
addition changes implementation checked immediately updating high level description 
second contribution demonstrating cmc works real code applying implementations ad hoc demand distance vector aodv networking protocol 
distinct errors roughly bug lines code including bug aodv specification 
experience building supported marco sa jb supported national science foundation graduate research fellowship madan acc engler dill cs stanford edu computer systems laboratory stanford university stanford ca systems appears approach contexts especially networking protocols 
complex systems complex errors 
real systems variety corner cases triggered intricate sequences events 
practice leaves residue errors cause system crashes days weeks continuous execution 
detected problems difficult diagnose errors reproducible sequence events leading reconstructed 
formal verification methods possible way find diagnose deep errors 
option explicit model checking systematically enumerates possible states system 
basic model checker starts initial state recursively generates successive system states executing nondeterministic events system 
states stored hash table ensure state explored 
process continues state space explored model checker runs resources 
works style state graph exploration achieve effect impractically massive testing avoiding redundancy occur conventional testing 
conventional model checkers usually assume design described high level abstracts away details actual implementation 
verifying actual code tool requires reconstructing description code 
process requires great deal manual effort hampering model checking actual system design 
human errors manual abstraction process result missing bugs cause false alarms verification increasing cost reducing usefulness model checking 
errors introduced constructing model result drift actual system evolves :10.1.1.29.3872
reasons notable curiosity software model checked everyday occurrence 
introduce cmc model checker address issues 
cmc works unmodified implementations explores large state spaces efficiently storing states 
traditional model checkers cmc achieves equivalent executing astronomical numbers tests reasonable time 
cmc require writing separate high level model code extracting model implementation 
importantly finds bugs implementation implementation bugs omitted model waste user time bugs appear model implementation 
idea model checking actual implementation code advocated small number tools 
verisoft instance systematically executes implementation code store states 
software model checking tools specialized certain classes java programs 
cmc designed combine effective techniques various research efforts verification community apply software written predominant programming languages industry 
ultimate goal check systems code general initial focus networking code 
code naturally follows eventdriven execution model fit model checkers 
correctness networking protocol implementations especially important core services target external security attacks 
unfortunately network protocols difficult design implement test involve complex interactions multiple machines network deal various network failures packet losses link failures difficult control test environment 
model checkers excel checking interactions 
cmc works real code demonstrated results applying implementations aodv networking protocol 
imple mentation mad hoc released years ago active development 
second implementation kernel aodv derives mad hoc implementation released year ago 
third implementation aodv uu released year ago 
aodv specification active development version came subsequently undergone revisions 
difficult measure quality absolutely measure formal group devoted testing aodv implementations testbed check mad hoc aodv uu implementations 
cmc unique errors total date publication rate roughly bug lines code 
bugs non trivial ones difficult find method 
ironic twist model checking implementation bug specification aodv error confirmed authors aodv specification 
protocol implementations similar aodv cmc enhancements broaden applicability concurrent systems 
reason believe cmc useful systems difficult debug means 
model checking overview fundamentally explicit state model checking systematic search error states state graph represents behavior system 
usually best generate graph fly search find report errors state graph large search completely 
especially important state graphs systems errors larger correct systems 
search algorithms newly discovered states stored queue 
policy depth breadthfirst best states removed queue successors generated expanded enqueued usually multiple successors nondeterminism system 
states searched stored hash table successors expanded 
model checking prove system satisfies specified property 
usually practical bug finding method 
model checking applicable effective conventional testing dis covering bugs exploring state space system including corner cases overlooked 
model checking efficient random testing searches state 
code model check necessary model environment relevant aspects network operating system calls 
environment model necessary avoid false error reports resulting illegal inputs state changes occur actual system execution 
parts environment model necessary unit testing 
system checked put model checker apparent problems model checking relatively small system description result huge state graph 
called state explosion problem 
addressed ways including various methods suppressing details input description abstraction various optimizations save time importantly space 
state explosion problem remains serious difficulty applications model checking 
note state pruning randomized testing typically fare significantly worse situations 
addressing issues described presents approach pragmatically apply model checking actual implementation code find bugs 
implemented tool called cmc find bugs network protocol implementations described sections 
design cmc cmc model checker generates state space system directly executing implementation 
section describes design cmc description tool infrastructure 
steps required set system checking described illustrated example 
actual model checking algorithm follows 
techniques cope state explosion problem discussed 
cmc infrastructure cmc models system collection interacting concurrent agents called processes 
process runs unmodified code implementation cmc model checker responsible scheduling executing processes system checked 
cmc processes system run single operating system process 
operating system cmc tries search possible system states reached alternative scheduling decisions nondeterministic events 
search different possibilities cmc able save restore complete state modelled system 
process system executes heap stack 
instant state process consists copy global static variables heap stack context registers 
processes communicate shared memory accessible context processes 
state system defined union states processes contents shared memory 
scheduled process allowed execute deterministic non blocking set instructions defined transition 
transition atomic step system take determines degree interleaving processes 
protocols cmc applied follow eventdriven execution model set event handler routines process incoming events packet arrivals timeouts 
event driven protocol event handler mapped transition cmc 
event handler preserves state stack registers global variables heap need saved restored 
protocols written event driven style event driven model may restrictive may 
feasible save restore full states including stack modelled processes 
feature implemented currently evaluated necessary results reported 
creating cmc model implementation shows skeleton event driven implementation routing protocol similar aodv protocol checked see section 
implementation running example discussion 
main function implementation calls initialization function line enters event dispatch loop line 
depending input event calls event handlers defined lines 
handler processes event user request route destination request node response node previous requests timer event requiring protocol invalidate old routes 
subsection describes steps user perform apply cmc protocol 
steps essentially provide unit test scaffold required test environments running implementation simulator 
step additional requirement cmc 
step specifying correctness properties 
system tested user specify correctness properties 
properties domain independent example program access illegal memory leak memory 
domain specific properties specified assertions particular points implementation example protocol return invalid route line 
cases careful implementer placed assertions code long cmc applied 
properties inherently global requirement loops routing table 
properties specified boolean functions written access datastructures process contexts 
step specifying environment 
user build test environment adequately represents behavior actual environment protocol executed 
networking protocols environment model operating system outside protocol necessary function 
decision part system checked environment decided user 
environment model collection substitute api functions data structures emulate state 
environment modelled little detail possible superfluous states generated model environmental behavior irrelevant checking protocol 
functions replaced simple stubs example gettimeofday return constant contain counter 
example model requires network exchanging routing packets 
simple network modelled unordered queue bounded length 
model include versions interface functions broadcast request function sends packets network 
environment may contain processes 
ex event handlers user request dest ip route table route dest ip return route dest ip broadcast request dest ip recv request dest ip route table route dest ip send response route dest ip broadcast request dest ip recv response route install route route table route needs forwarded send response route timeout route route table route old remove route route table init route table null insert self route ip main init event dispatch loop depending event call user request 
recv request 
recv response 
timeout 
simple routing protocol implementation 
void malloc size return nondeterministic failure alloc bytes heap return implementation malloc cmc 
malloc nondeterministically fails allocate memory 
ample process nondeterministically removes packet network model lossy network 
represent nondeterminism environment cmc provides function similar toss verisoft 
takes integer argument returns integer range 

arbitrarily selects possibilities environment 
example shown malloc implementation allocate requested memory cmc heap fail returning null 
cm choices 
cmc attempt try possible return values call 
calls cmc choose appear environment code implementations standard system functions malloc select generally necessary modify actual implementation 
providing environment model time consuming 
important reduce modelling effort required apply cmc previously unchecked protocol 
obvious step engineer models re usable possible reducing incremental effort checking new protocol 
especially beneficial related protocols checked large part reason checks different implementations protocol 
finding ways reduce cost environmental modelling interesting area 
step identifying initialization functions event handlers 
event driven system user provide initialization functions event handlers process system 
user provide guard function event handler boolean function determines event handler enabled state 
instance guard function recv request handler returns true request pending particular process network 
cmc model checking algorithm model system built described cmc explores state space system executing various traces interleaving transitions 
pseudocode algorithm shown 
algorithm maintains data structures hash table states seen search queue states seen successors generated 
hash table guarantees algorithm explores subgraph rooted state 
generating initial state cmc computes initial state follows 
starting copy global variables initialized linker cmc calls initialization function process 
initial state consists states processes immediately initialization functions called values initialized shared memory 
generating successor states generate state graph fly cmc needs able compute set possible immediate successors state 
state state space system may successors nondeterminism arises sources choice process execute choice enabled transition process execute nondeterministic values returned calls 
state cmc chooses process enabled event handlers schedule 
cmc restores context process copying contents heap global variables process state 
event handler called 
function eventually returns guaranteed atomic 
point context process state saved yielding new system state 
cmc generates successors state repeating process nondeterministic choices 
checking correctness properties model checking cmc checks range correctness properties simple pointer access void contains network processes initial current successor queue hash build initial state 
forall processes pid call pid initial pid call initial insert initial current pop add current repeat forall nondeterministic choices forall processes pid forall event handlers pid forall return values calls set proc context current pid current enabled continue call event handler construct state successor successor pid forall processes pid pid state change successor pid current pid successor continue successor fails assertions generate error insert successor pseudocode cmc model checking algorithm 
violation errors complex protocol bugs 
execution event handler cmc runs implementation code directly automatically catching errors pointer access violations program assertion failures code 
addition cmc detects free bugs overwriting freed memory random value 
state generated cmc checks violations user provided system invariants absence global routing loops 
cmc detects memory leaks generated state 
achieved standard mark sweep algorithm find reachable memory algorithm implemented cmc 
case study cmc detects memory leaks follows starting copy current state cmc calls various cleanup functions implementation 
heap memory left allocated reported leaked 
approach requiring additional manual effort potentially find bugs cleanup code 
cmc approach easily coupled dynamic debugging tools purify stackguard 
tools catch run time errors uses uninitialized memory stack overflows tools effective cmc ordinary testing cmc achieve greater effective test coverage level user effort conventional software testing methods 
handling state space explosion serious problems model checking practice called state explosion problem state space system large infinite 
outset impossible explore entire state space limited resources time memory 
cmc provides various techniques search state space efficiently running resources 
unable formally prove correctness implementation cmc able catch wide range errors including errors involving intricate interactions multiple processes 
model checkers memory critical resource time 
model checking memory consumed hash table containing states visited queue states successors generated 
cmc uses hash compaction reduce mem ory requirements hash table orders magnitude 
state cmc computes small signature usually bytes 
storing entire state order kilobytes signature stored hash table 
compacting states lead conflicts hash table different states compute signature 
state spaces order states practical hash table sizes megabytes probability missing single state due signature conflict reduced lower 
states queue compacted information needed compute successor states 
queue locality swapped disk model checking 
successive states queue usually lot commonality compressed 
instance transition cmc changes process state sufficient store difference generating successor state 
standardizing data structures cmc default interprets states streams bits 
equivalent data structures memory different representations 
example states differ order objects allocated heap considered effectively 
cmc automatically transform states deterministically traversing pointer data structures arranging objects heap order visited 
signature transformed state saved state table 
process performed simultaneously mark sweep algorithm detect memory leaks 
automatic tool traversal development mc framework 
case study discussed section traversal code written manually 
may additional equivalences states depend particular data structures program 
example implementation uses linked list store unordered collection objects behavior implementation independent order objects list 
case user provide function sort list automatic standardization transformations applied 
effective reductions state space achieved methods risk missing errors benefit catching remaining ones efficiently 
scaling obvious approach reduce scale system described 
instance model restrict number routing nodes network say 
hard find bugs usually involve complex interactions small number processes preserved 
course may bugs occur larger instances system 
abstraction states addition standardizing distinct equivalent states possible eliminate information user judges unimportant properties checked 
abstraction process done ignoring certain memory locations computing hash signature state 
abstracting states possible errors 
abstraction done hash computation actual concrete state produce false positives 
heuristics exhaustive checking entire state space infeasible fails cmc act automated testing framework large number scenarios checked intelligently 
mere fact cmc able cache states prevents redundant simulations 
goal exercise interesting scenarios possible memory exhausted 
done preliminary heuristics prioritize state space search 
class heuristics involves dropping states altogether deemed uninteresting 
second class heuristics involves exploring interesting states best search 
cmc contains module monitor state variables keep history state bits changed checking 
basic idea number bit positions changed initial state suddenly increases variables take values state considered interesting explored earlier 
heuristic tends bias search cases outliers occur states diverge norm 
idea adapted tool flags divergent cases reports user program testing 
preliminary results indicate errors discovered heuristics discovered simple depth search 
heuristics accelerated discovery errors produced shorter examples executions leading error 
experimentation various heuristics needed wider range protocols arrive reliable 
sections describe application results cmc check aodv protocol implementations 
description aodv protocol aodv ad hoc demand distance vector loop free routing protocol ad hoc networks 
designed self starting environment mobile nodes variety network behaviors node mobility link failures packet losses 
section describes aodv protocol brief reader referred complete details protocol 
node aodv maintains routing table 
routing table entry destination contains essential fields hop node sequence number hop count 
packets destined destination sent hop node 
sequence number acts form time stamping measure freshness route 
hop count represents current distance destination node 
suppose nodes hop destination suppose sequence number hop count routes respectively 
aodv protocol maintains property times words newer route shorter route equally 
partial order constraint protocol guaranteed free routing loops 
aodv nodes discover routes request response cycles 
node requests route destination broadcasting rreq message neighbors 
node receives rreq message route requested destination turn broadcasts rreq message 
remembers reverse route requesting node forward subsequent responses rreq 
process repeats rreq reaches node valid route destination 
node destination responds rrep message 
rrep unicast reverse routes intermediate nodes reaches original requesting node 
request response cycle bidirectional route established requesting node destination 
node loses connectivity hop node invalidates route sending rerr nodes potentially received rrep 
receipt aodv messages rreq rrep rerr nodes update hop sequence number hop counts routes way satisfy partial order constraint mentioned 
aodv model section describes aodv model implementations aodv protocol mad hoc version kernel aodv version aodv uu version 
mad hoc implementation runs user space daemon contains approximately lines code 
kernel aodv implementation built nist mad hoc implementation 
contains lines code runs loadable kernel module linux arm pdas 
aodv uu implementation runs user space daemon linux ported ns simulator 
contains roughly lines code 
aodv model reused minor modifications implementations 
model built follows correctness properties table lists correctness properties checked aodv model 
apart generic assertions checked cmc model contains global invariant checks routing loops 
model performs sanity checks routing table entries network messages range violations fields 
environment environment model consists network modelled bounded length unordered message queue 
model simulates message loss nondeterministically dequeuing message 
message queue shared nodes models completely connected topology 
implementations wrapper function send network packets 
model provides alternate definition wrapper function copy packets network model 
additionally kernel aodv implementation model provides implementations kernel functions types checks examples generic assertions segmentation violations memory leaks dangling pointers 
routing loop invariant routing tables nodes form routing loop 
assertions routing table entries routing table entry destination 
route self aodv uu implementation 
hop count route self 
hop count infinity number nodes network 
assertions message fields reserved fields set 
hop count packet infinity 
table properties checked aodv 
enabling condition event invalid route destination initiation route request pending message network receipt aodv message pending message network message loss valid route routing table timeout route enabled detection link failure enabled node reboot table set event handlers aodv model checking 
user space version socket buffer library 
initialization functions event handlers implementations event dispatch loop calls various event handlers 
initialization functions model obtained executing code event dispatch loop 
model maps event handler called dispatch loop transition 
model simulates node reboot calling initialization function implicitly resets contents routing table 
list transitions respective enabling conditions shown table 
table shows lines code implementations executed framework lines code model 
correctness specifications shared implementations 
aodv uu uses different representation routing table required additional correctness specifications 
network model environment shared implementations 
dealing state space explosion state space aodv protocol essentially infinite 
protocol allows arbitrary number nodes network 
node types unbounded counters sequence number mea sure freshness route broadcast id incremented node broadcast 
effective search infinite state space necessary bound search 
experiments aodv model run processes 
model discarded state sequence numbers broadcast ids exceeded predefined limit 
size message queue network bounded sizes 
processes may cause cmc errors 
applying bounds remaining state space contained interesting behavior uncover numerous bugs section 
time values stored state source state space explosion 
instance route response rrep contains lifetime field determines freshness route 
receipt packet node adds lifetime current clock value determine time route stale 
absolute value stored routing table increase state space size 
aodv model gets problem modelling route timeouts nondeterministic events setting time variables predefined constants 
environment model contains definition gettimeofday function returns constant value 
handling time model timing related errors protocol checked correctness environment state code specification network stubs canonicalization mad hoc kernel aodv aodv uu table lines implementation code vs cmc modelling code 
potentially lead false positives error reported caused sequence timeouts impossible real protocol 
aodv model contains hand written code traverse routing table implemented linked list mad hoc kernel aodv implementations hash table aodv uu implementation 
traversal code created canonicalized representation routing table global variables formed state aodv node model 
amount lines required traversal code shown column table 
results table summarizes set bugs cmc aodv implementations 
bugs range simple memory errors protocol invariant violations 
total bugs unique 
kernel aodv implementation bugs shown parenthesis table instances bug 
aodv specification bug causes routing loop implementations 
currently cmc stops finding bug model 
prints failed assertion trace events starting initial state error state 
bug fixed cmc run find bugs iteratively 
bugs minutes model checking time longest took roughly minutes 
describe bugs high level give feel breadth coverage focus interesting bugs give feel depth 
memory errors 
error classes illustrate dynamically allocated memory checking allocation failure errors freeing allocated memory errors memory freeing errors 
implementations checked pointer re aodv aodv recv message msg dst cnt tp malloc sizeof tp break skip packet tp msg dst msg dst tp 
bug assumes msg dst cnt buffers allocated 
rec rerr info msg msg free list structs sent rec rerr msg dst cnt bug null malloc failed 
tp msg dst msg dst msg dst free tp malloc failure malloc fails loop exit allocating msg dst cnt buffers 
errors code assumes msg dst cnt buffers allocated 
lead segmentation faults 
turned malloc null 
functions call malloc indirectly return null pointers allocations fail 
code checked cases 
cmc directly executes implementation errors manifested segmentation faults 
memory related bugs straightforward 
interesting errors code correctly check allocation failure recovery code broken 
gives representative error 
code attempts allocate msg dst cnt temporary message buffers 
correctly checks malloc failure breaks loop 
code loop assumes msg dst cnt list entries allocated 
assumption leads bugs 
intraprocedural error mad hoc kernel aodv aodv uu malloc failures memory leaks free invalid routing table entry unexpected message generating invalid packets program assertion failures routing loops total table number bugs type implementations aodv 
figures parenthesis show number bugs instances bug mad hoc implementation 
attempts dequeue msg dst cnt buffers msg dst list order free 
list fewer entries expected code attempt null pointer get segmentation fault 
second interprocedural error rec rerr similarly tries walk msg dst cnt list entries seg faults list short 
memory leaks similarly caused allocation failures 
commonly code attempt memory allocations allocation succeeded second failed return error leaking pointer 
unexpected messages 
cmc detected places unexpected messages cause mad hoc crash segmentation violation 
shows errors 
error happens aodv encodes state messages 
error 
current node receives route request rreq message node req requesting route node dst 

node inserts reverse route req routing table 

looks route dst routing table 

route re broadcasts rreq message 
rreq message contains ip address destination node dst requesting node req 

response request route response rrep message includes route dst ip address req 

node inserts new route dst routing table 
attempts relay route req looking route req 
normal case lookup return reverse route inserted step 
step causes error 
code assumes normal case uses result routing table lookup req checking null 
lookup fail reasons 
machine rebooted implementation start empty routing table 
old rrep message arrives reboot lookup req return null pointer 
second attacker send bogus rrep node address exist crashing router 
invalid messages 
cases invalid packets created cases uninitialized variables detected gcc wall cases invalid routes send routing updates violating aodv specification gives representative example 
cmc detected instances integer overflow resulted program assertion failures 
implementations bit integer store hop counts represent hopcount infinity 
error cases infinite hopcount erroneously incremented 
routing loops 
cmc routing loops 
bugs caused implementation errors 
third routing loop due error aodv protocol specification 
routing loop caused implementation fails increment sequence number processing specific rerr messages 
loop caused implementation performs sequence number comparison subsequent increment aodv specification requires comparison done increment 
rrep rec rrep 
destination rrep forward rrep src ip info ip pkt ip 
get entry source rt 
rt src rrep src ip bug rt src may exist 
add precursor rt src rt nxt hop 
send gratuitous rrep destination bug rt src invalid rt src hop cnt check 
rrep hop cnt rt src hop cnt send datagram info rrep sizeof rrep 
bugs unexpected message invalid route response 
unexpected rrep message causes return null crashing machine 
route returned invalidated hopcount 
code check sends message 
specification bug 
bug involved handling rerr route error messages 
node receives rerr hop sets sequence number route sequence number rerr message 
normal conditions right thing 
underlying link layer reorder messages rerr message outdated sequence number resulting node setting sequence number older version 
ultimately result routing loop 
bug mentioned authors protocol suggested fix 
bug fix accepted protocol authors 
gives error fix 
specification bug running aodv nodes depth search state space 
cmc came error trace length 
best search possible find traces short 
performing breadth search state space give shortest trace 
breadth search aodv ran resources finding bug 
carefully hand crafted simulation bug required transitions 
complex error difficult catch conventional means testing 
rerr rec rerr 
get pointer route table destination ip tmp tmp dst dst ip tmp null 
bug uses sequence number incoming message tmp dst validation 
check tmp dst seq tmp dst dst seq return tmp dst seq tmp dst dst seq specification bug sequence number incoming message validation causing time go backwards messages reordered 
fortunately error obvious surviving rounds specification revisions fix trivial 
related proposes initial approach systematically efficiently verify large class software having create models different language 
compares cmc efforts traditional model checking software model checking static analysis 
traditional model checking basic idea state graph search verify network communication protocols quite old dating back 
decades model checking significant progress tackling verification complex concurrent systems 
tools smv spin murphi verify hardware software protocols exhaustively searching state space 
caching states employing sound state reduction techniques tools detect non trivial bugs 
drawback traditional model checkers system verified modeled particular description language requiring significant amount manual effort easily error prone 
cmc specifically designed goal reducing amount required go software development systematic verification 
software model checking formal verification tools idea executing checking systems implementation level 
verisoft instance systematically executes verifies actual code successfully check communication protocols written verisoft store states potentially explore state 
problem alleviated degree partial order reduction sound state space reduction technique implemented verisoft eliminates exploration redundant interleavings transitions created commutative operations 
technique requires hints provided user static analysis code determine dependencies transitions set possible transitions system high degree interdependence case handlers protocol code verified partial order methods effective 
interesting systems state spaces cycles cases verisoft limited checking fixed depth 
java pathfinder uses model checking verify concurrent java programs deadlock assertion failures 
relies specialized virtual machine tailored automatically extract current state java program 
cmc java pathfinder compresses stores states table prevent redundant searches relies various abstraction techniques curb state space explosion problem 
infrastructure jpf relies applied software written predominant languages system software development 
slam tool converts code abstracted skeletons contain boolean types 
slam model checks abstracted program see error state reachable 
difficulty tool slam giving specification correct behavior system 
slam static tool writing specification routing loops possible difficult depends interleaved event behavior multiple nodes 
furthermore slam deal concurrent environments contain multiple processes queues static analysis static analysis gained ground years detecting bugs software 
tools esc lclint esp mc checker check source code errors statically detected minimal manual effort 
static techniques finding specific set errors cmc approach find deep conceptual errors code emergent routing loops difficult find statically 
addition cmc suffer false positives scenario checked valid execution path 
described cmc model checker targetting subtle bugs systems code experimental results cmc check implementations aodv routing protocol 
key features cmc checks implementation code directly stores states avoid redundant state explorations 
initial experiences cmc encouraging cmc powerful discover non trivial bugs implementation specification protocols 
currently cmc verify larger complex protocols 
wider essential automate process converting implementation system cmc model possible 
results reported require considerable manual effort improvements cmc significantly reduce 
exploring heuristics efficiently search state space 
initial findings suggest simple heuristics provide huge improvements state space search 
instance implemented monitor detects counters rogue variables uninitialized variables statistics variables 
monitor abstracts away variables system state automatically pruning infinite state space 
interesting avenue research simple facts discovered static analysis code direct search interesting parts state space 
acknowledgments das thoughtful discussions 
miguel castro various anonymous reviewers providing valuable comments suggesting improvements previous versions 
thomas ball majumdar todd millstein sriram rajamani 
automatic predicate abstraction programs 
proceedings sigplan conference programming language design implementation 
gunter 
formal verification standards distance vector routing protocols 
brat havelund park visser 
model checking programs 
ieee international conference automated software engineering ase 
clarke grumberg peled 
model checking 
mit press 
corbett dwyer hatcliff laubach pasareanu robby zheng :10.1.1.29.3872
bandera extracting finite state models java source code 
icse 
cowan calton pu dave maier jonathan walpole peat steve beattie aaron perry wagle qian zhang heather hinton 
stackguard automatic adaptive detection prevention attacks 
proc 
th usenix security conference pages san antonio texas jan 
perkins royer das 
ad hoc demand distance vector aodv routing 
ietf draft www ietf org internet drafts manet aodv txt january 
das lerner mark 
esp program verification polynomial time 
conference programming language design implementation 
david detlefs rustan leino greg nelson james saxe 
extended static checking 
david dill andreas drexler alan hu han yang 
protocol verification hardware design aid 
ieee international conference computer design vlsi computers processors pages 
engler chelf chou hallem 
checking system rules system specific compiler extensions 
proceedings fourth symposium operating systems design implementation october 
erik nordstrom ad hoc protocol evaluation testbed 
sourceforge net 
erik nordstrom aodv uu implementation 
user uu se aodv 
david evans john guttag james horning yang meng tan 
lclint tool specifications check code 
proceedings acm sig soft symposium foundations software engineering pages 
godefroid 
model checking programming languages verisoft 
proceedings th acm symposium principles programming languages 
hajek 
automatically verified data transfer protocols 
proceedings th pages 
monica lam 
tracking software bugs automatic anomaly detection 
proceedings international conference software engineering may 
gerard holzmann 
model checker spin 
software engineering 
mcmillan symbolic model checking 
kluwer academic publishers 
luke klein berndt kernel aodv implementation 
nist gov aodv kernel 
mad hoc aodv implementation 
mad hoc net 
mccanne floyd 
ucb lbnl vint network simulator ns version april 
www isi edu nsnam ns 
mcmillan 
formal verification cache consistency protocol 
proceedings international symposium shared memory multiprocessing pages 
tokyo japan inf 
process 
soc 
nelson 
techniques program verification 
available xerox parc research report csl june stanford university 
park stern dill 
java model checking 
ieee international conference automated software engineering ase 
charles perkins elizabeth royer samir das 
private email communication 
rational software 
purify advanced runtime error checking developers 
www rational com products purify unix 
stern dill 
new scheme memory efficient probabilistic verification 
ifip tc wg joint international conference formal description techniques distributed systems communication protocols protocol specification testing verification 
stern dill 
automatic verification sci cache coherence protocol 
correct hardware design verification methods ifip wg advanced research working conference proceedings 
west 
general technique communications protocol validation 
ibm journal research development 
