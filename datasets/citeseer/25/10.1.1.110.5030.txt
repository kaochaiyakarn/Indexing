new directions traffic measurement accounting focusing elephants ignoring mice cristian estan george varghese university california san diego accurate network traffic measurement required accounting bandwidth provisioning detecting dos attacks 
applications see traffic collection flows need measure 
link speeds number flows increase keeping counter flow expensive sram slow dram 
current state art methods cisco sampled netflow count periodically sampled packets slow inaccurate 
previous showed different granularities small number heavy hitters accounts large share traffic 
introduces paradigm shift concentrating measurement process large flows threshold link capacity 
propose novel scalable algorithms identifying large flows sample hold multistage filters take constant number memory packet small amount memory 
available memory show analytically errors new algorithms proportional contrast error algorithm classical sampling proportional providing accuracy amount memory 
describe optimizations early removal conservative update improve accuracy algorithms measured real traffic traces order magnitude 
schemes allow new form accounting called threshold accounting flows threshold charged usage rest charged fixed fee 
threshold accounting generalizes usage duration pricing 
categories subject descriptors computer communication networks network operations traffic measurement identifying large flows general terms algorithms measurement additional key words phrases network traffic measurement usage accounting scalability line algorithms identifying large flows 
re keeping flow state scaling problem ll tracking millions ants track elephants 
van jacobson research meeting june 
measuring monitoring network traffic required manage today complex internet backbones feldmann duffield grossglauser 
measurement information essential short term monitoring detecting hot spots denial service attacks mahajan longer term traffic engineering rerouting traffic shaikh upgrading selected links feldmann accounting support usage author emails cs ucsd edu varghese cs ucsd edu acm transactions computer systems vol 
tbd 
tdb month year pages 
estan varghese ing duffield 
standard approach advocated real time flow measurement brownlee working group ietf instrument routers add flow meters selected input links 
today routers offer tools netflow netflow give flow level information traffic 
main problem flow measurement approach lack scalability 
measurements mci traces early thomson showed concurrent flows 
measurements fang peterson variety traces show number flows host pairs hour period high fix west mci 
aggregation number flows hour fix west fang peterson large 
feasible flow measurement devices keep increases number flows aggregation cheapest memories drams 
updating packet counters dram impossible today line speeds gap dram speeds improving year link speeds improving year increasing 
cisco netflow netflow keeps flow counters dram solves problem sampling sampled packets result updates 
sampled netflow problems show sampling affects measurement accuracy 
despite large number flows common observation measurement studies feldmann fang peterson small percentage flows accounts large percentage traffic 
fang peterson shows flows pairs account byte traffic pairs 
applications knowledge large flows probably sufficient 
fang peterson pan suggest achieving scalable differentiated services providing selective treatment small number large flows 
feldmann underlines importance knowledge heavy hitters decisions network upgrades peering 
duffield proposes usage sensitive billing scheme relies exact knowledge traffic large flows samples traffic small flows 
conclude infeasible accurately measure flows high speed links applications benefit accurately measuring large flows 
easily keep counters large flows small amount fast memory sram 
device know flows track 
keeps state flows identify large flows purpose defeated 
reasonable goal devise algorithm identifies large flows memory small constant larger needed describe large flows place 
central question addressed 
algorithms provably identify large flows small amount state 
algorithms memory packet making suitable high speed routers 
algorithms produce accurate estimates sampled netflow processing access memory packet 
small amount memory fast memory operating line speeds 
acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants problem definition flow generically defined optional pattern defines packets focus identifier values set specified header fields 
generalize allowing identifier function header field values prefixes addresses mapping route tables 
flow definitions vary applications example traffic matrix wildcard pattern identifiers defined distinct source destination network numbers 
hand identifying tcp denial service attacks pattern focuses tcp packets destination ip address flow identifier 
note require algorithms support simultaneously ways aggregating packets flows 
algorithms know priori flow definition need ensure posteriori analyses different flow definitions possible netflow data 
large flows defined send threshold say link capacity measurement interval second minute hour 
technical report version estan varghese gives alternative definitions algorithms defining large flows leaky bucket descriptors 
ideal algorithm reports measurement interval flow ids sizes flows exceeded threshold 
ideal algorithm fail ways omit large flows wrongly add small flows report give inaccurate estimate traffic large flows 
call large flows evade detection false negatives small flows wrongly included false positives 
minimum amount memory required ideal algorithm inverse threshold example flows link 
measure performance algorithm metrics memory compared ideal algorithm second algorithm probability false negatives third algorithm probability false positives fourth expected error traffic estimates 
motivation algorithms identifying large flows potentially solve problems 
different applications define flows different header fields need separate instance algorithms 
applications envisage include scalable threshold accounting poles pricing network traffic usage price byte flow duration fixed price duration 
usage pricing mackie masson varian shenker shown improve utility usage pricing complete form scalable track flows high speeds 
suggest scheme measure aggregates link traffic subject usage pricing remaining traffic subject duration pricing 
varying move usage pricing duration pricing 
acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese importantly reasonably small values say threshold accounting may offer compromise scalable offers utility usage pricing 
altman chu offers experimental evidence index experiment threshold pricing attractive users isps 
real time traffic monitoring isps monitor backbones hot spots order identify large traffic aggregates rerouted mpls tunnels routes optical switches reduce congestion 
isps may consider sudden increases traffic sent certain destinations victims indicate ongoing attack 
mahajan proposes mechanism reacts soon attacks detected give mechanism detect ongoing attacks 
traffic monitoring attack detection may suffice focus large flows 
scalable queue management smaller time scale scheduling mechanisms seeking approximate max min fairness need detect penalize flows sending fair rate 
keeping flow state flows feng pan improve fairness small memory 
address application note techniques may useful problems 
example pan uses classical sampling techniques estimate sending rates large flows 
algorithms better accuracy classical sampling may possible provide increased fairness amount memory applying algorithms 
rest organized follows 
describe related section describe main ideas section provide theoretical analysis section 
theoretically compare algorithms netflow section 
showing dimension algorithms section describe experimental evaluation traces section 
implementation issues section section 
related primary tool flow level measurement ip backbone operators cisco netflow netflow 
netflow keeps flow counters large slow dram 
basic netflow problems processing overhead updating dram slows forwarding rate ii collection overhead amount data generated netflow overwhelm collection server network connection 
example feldmann reports loss rates basic netflow 
processing overhead alleviated sampling flow counters incremented sampled packets classical random sampling introduces considerable inaccuracy estimate problem measurements long periods errors average applications need exact data 
altman chu brief similar idea shenker 
proposes fast mechanism implement idea 
netflow periodic sampling simplify analysis assume performs ordinary sampling processing packet probability independently 
acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants show sampling applications require true lower bounds customer traffic may infeasible charge customers estimates larger actual usage applications require accurate data small time scales billing systems charge higher congested periods 
data collection overhead alleviated having router aggregate flows source destination numbers directed manager 
fang peterson shows number aggregated flows large 
example collecting packet headers code red traffic class network moore produced gbytes hour compressed netflow data aggregation reduced data factor 
techniques described duffield reduce collection overhead cost errors 
considerably simplify router processing keep track heavy hitters application needs 
papers address problem mapping traffic large ip networks 
feldmann deals correlating measurements taken various points find spatial traffic distributions techniques complement methods 
duffield grossglauser describes mechanism identifying packet trajectories backbone focused estimating traffic various networks 
shaikh proposes edge routers identify large long lived flows route loaded paths achieve stable load balancing 
algorithms allow detection candidates re routing higher speed routers 
bloom filters bloom stochastic fair blue feng similar different techniques parallel multistage filters compute different metrics set membership drop probability 
tong reddy authors look various mechanisms identifying high rate flows ensure quality service 
algorithms rely caching flow identifiers techniques similar sampling technique call preserving entries algorithms quite different form 
gibbons matias gibbons matias consider synopsis data structures small amounts memory approximately summarize large databases algorithms profiling program execution burrows 
counting samples core idea sample hold algorithm 
constraints requirements setting data warehouses updated constantly different final algorithms differ 
example need take account packet lengths operate sequence measurement intervals algorithms need ensure low worst packet processing times opposed amortized processing data warehouse context 
fang fang look efficient ways answering iceberg queries counting number appearances popular items database 
multi stage algorithm similar multistage filters propose 
sampling front filter multiple passes 
final algorithms analyses different 
instance analysis limited zipf distributions analysis holds traffic distributions 
cohen matias cohen matias independently discovered context spectral bloom filters optimization multistage fil acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese ters call conservative 
karp karp give algorithm guaranteed identify elements repeat frequently single pass 
second pass data count exactly number occurrences frequent elements pass guarantee accurate results 
building multistage filters conservative update determine execution profiles hardware obtain promising results 

solution algorithms amount memory constant factor larger relatively small number large flows algorithms implemented chip chip sram store flow state 
assume packet arrival afford look flow id sram update counter entry allocate new entry entry associated current packet 
biggest problem identify large flows 
approaches suggest 
packet arrives flow id flow memory place new flow evicting flow smallest measured traffic smallest counter 
works traces possible provide counter examples large flow measured keeps expelled flow memory counter large 
happen lru replacement policy 
second approach classical random sampling 
random sampling similar sampled netflow smaller amount sram provably identifies large flows 
known result table shows random sampling introduces high relative error measurement estimate proportional amount sram device 
needs high amounts memory reduce inaccuracy acceptable levels 
important contributions new algorithms identifying large flows sample hold section multistage filters section 
performance similar main advantage sample hold implementation simplicity main advantage multistage filters higher accuracy 
contrast random sampling relative errors new algorithms scale amount sram 
allows algorithms provide accurate estimates random sampling amount memory 
sampled netflow algorithms access memory packet memories fast keep line speeds 
section improvements increase accuracy algorithms traces section 
start describing main ideas schemes 
sample hold base idea simplest way identify large flows sampling twist 
ordinary sampling sample packet probability 
packet sampled flow belongs entry flow memory new entry created 
entry created flow sampled netflow update entry subsequent packet acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants sampled packet probability entry created entry updated transmitted packets flow memory fig 

leftmost packet flow label arrives router 
entry created flow solid line counter updated packets dotted lines belonging flow shown 
counting samples gibbons matias gibbons matias core idea 
flow sampled corresponding counter held hash table flow memory till measurement interval 
clearly requires processing looking flow entry updating counter packet sampled netflow show reduced memory requirements allow flow memory sram dram 
turn allows packet processing scale line speeds 
probability sample byte 
sampling probability packet size ps sp looked precomputed table approximated ps example packets bytes approximation introduces errors smaller ps 
choosing high value guarantees flows threshold detected 
increasing unduly cause false positives small flows filling flow memory 
advantage scheme easy implement gives accurate measurements high probability 
preliminary analysis example illustrates method analysis 
suppose wish measure traffic sent flows take link capacity measurement interval 
flows 
making flow memory just locations allow oversampling factor keep locations 
wish sample byte probability average number samples 
bytes transmitted measurement interval error analysis consider flow takes traffic 
sends bytes 
randomly sampling byte probability probability flow memory acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese packets xth packet sampled netflow update entry create new large flow memory sample hold update existing entry pass entry 
probability small flow memory packets size create new entry large reports management station small reports management station fig 

sampled netflow counts sampled packets sample hold counts entry created measurement interval false negative close notice factor exponent oversampling factor 
better probability flow flow memory sending traffic similarly greater probability 
probability reported traffic flow actual amount sent analysis generalized arbitrary threshold values memory needs scale inversely threshold percentage directly oversampling factor 
notice analysis assumes space place sample flow memory 
setting ensures average number flows sampled 
distribution number samples binomial small standard deviation square root mean 
adding standard deviations memory estimate total memory size extremely flow memory overflow compared sampled netflow idea significant differences 
importantly sample decide add flow memory point update flow memory byte flow sends shown 
section shows results accurate 
second sampling technique avoids packet size biases netflow samples packets 
third technique reduces extra resource overhead router processing router memory network bandwidth sending large reports analyses section estan varghese give tight upper bounds number entries hold high probability 
flow memory overflows create new entries entries freed measurement interval large flows go undetected 
allocating memory probably option hardware implementations 
selectively discarding important entries requires traverse entire flow memory violate strict bounds packet processing time 
acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants packet flow id stage stage stage large 
flow memory fig 

parallel multistage filter packet flow id hashed hash function table stage table table entry contains counter incremented packet size 
hashed counters threshold shown passed flow memory individual observation 
records management station 
multistage filters base idea basic multistage filter shown 
building blocks hash stages operate parallel 
consider filter operates stage 
stage table counters indexed hash function computed packet flow id counters table initialized start measurement interval 
packet comes hash flow id computed size packet added corresponding counter 
packets belonging flow hash counter flow sends threshold counter exceed threshold 
add flow memory packets hash counters guaranteed identify large flows false negatives 
multi stage algorithm fang fang similar multistage filters accounting bins stochastic fair blue feng similar data structure compute drop probabilities active queue management 
unfortunately number counters afford significantly smaller number flows flows map counter 
cause false positives ways small flows map counters hold large flows get added flow memory second small flows hash counter add number larger threshold 
reduce large number false positives multiple stages 
stage uses independent hash function 
packets map counters stages get added flow memory 
example packet flow id arrives hashes counters respectively stages pass filter counters threshold shown darkened 
hand flow hashes counters pass filter second stage counter threshold 
effectively multiple stages attenuate probability false positives exponentially number stages 
shown acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese simple analysis 
preliminary analysis assume mbytes link flows want identify flows link second measurement interval 
assume stage buckets threshold mbyte 
see probability flow sending kbytes pass filter 
flow pass stage flows need add mbyte kbytes kbytes 
buckets stage 
probability passing stage 
independent stages probability certain flow larger kbytes passes stages product individual stage probabilities analysis dimension flow memory large accommodate flows pass filter 
expected number flows kbytes passing filter 
flows kbytes number entries expect accommodate flows 
section rigorous theorem proves stronger bound example entries holds distribution flow sizes 
note potential scalability scheme 
number flows increases simply add fifth hash stage get effect 
handle flows requires roughly counters flow memory approximately memory locations handle flows requires roughly counters size flow memory 
logarithmic scaling 
number memory accesses packet multistage filter read write stage 
number stages small feasible high speeds doing parallel memory accesses stage chip implementation 
multistage filters need compute hash functions 
computed efficiently hardware 
software implementations adds packet processing replace memory accesses main bottleneck 
need compute hash function locate flow entries flow memory argue introduce new problem just existing worse 
multistage filters complex sample important advantages 
reduce probability false negatives decrease probability false positives reducing size required flow memory 
serial multistage filter 
briefly variant multistage filter called serial multistage filter 
multiple stages parallel place serially stage seeing packets passed previous stage 
number stages depth serial filter 
set stage threshold stages 
flow sends bytes time packet sent counters flow hashes stages reach packet pass flow memory 
parallel filters false simplify computation examples assume mbyte bytes kbyte bytes 
describe details preliminary oc chip implementation multistage filters section 
acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants packet flow id stage stage stage flow memory fig 

serial multistage filter packet flow id hashed hash function stage table 
counter stage threshold incremented 
counter reaches stage threshold packet hashed function stage counter packet passes stages entry created flow memory 
negatives 
parallel filters small flows pass filter keep hashing counters large flows 
analytical evaluation serial filters complicated parallel filters 
hand early stages shield stages traffic contributes stronger filtering 
hand threshold stages smaller factor contributes weaker filtering 
shown section parallel filters perform better serial filters traces actual traffic main focus parallel filters 
improvements basic algorithms improvements algorithms section increase accuracy measurements reduce memory requirements 
improvements apply algorithms apply 
basic optimizations 
number basic optimizations exploit fact large flows measurement interval 
preserving entries erasing flow memory interval implies bytes large flow sent flow allocated entry counted 
preserving entries large flows measurement intervals stage counters long lived large flows measured nearly exactly 
distinguish large flow identified late small flow identified error conservative solution preserve entries flows count bytes current interval flows added current interval may large flows entered late 
early removal sample hold larger rate false positives multistage filters 
keep interval flows obtained new entry small flows keep entries intervals 
improve situation selectively removing flow entries created current interval 
new rule preserving entries follows 
define early removal threshold threshold measurement interval keep entries counter entries added current interval counter acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese incoming packet counter counter counter counter counter counter fig 

conservative update conservative update left counters increased size incoming packet conservative update right counter increased size smallest counter plus size packet shielding consider large long lived flows go filter measurement interval 
measurement interval counters hash exceed threshold 
shielding traffic belonging flows entry flow memory longer passes filter counters filter incremented packets entry reducing false positives 
shield filter large flow counters hashes reach threshold interval 
reduces probability random small flow pass filter hashing counters large flows 
conservative update counters 
describe important optimization multistage filters improves performance order magnitude 
conservative update reduces number false positives multistage filters subtle changes rules updating counters 
essence endeavour increment counters little possible reducing false positives preventing small flows passing filter avoiding false negatives need ensure flows reach threshold pass filter 
change applies parallel filters packets don pass filter 
usual arriving flow hashed counter stage 
update smallest counters normally adding size packet 
counters set maximum old value new value smallest counter 
amount traffic sent current flow new value smallest counter change introduce false negative flow packet belongs 
decrement counters large flows hash counters prevented passing filter 
acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants second change simple applies parallel serial filters 
packet passes filter obtains entry flow memory counters updated 
leave counters threshold 
flows smaller packets hash counters get help passing filter 
third change applies serial filters 
regards way counters updated threshold exceeded stage 
say value counter packet hashes stage size packet 
normally increment counter stage add counter stage 
counter stage update value maximum old value assuming 
counter stage know prior packets belonging flow current passed stage contributed value counter stage 
apply change threshold allowed change measurement interval 

analytical evaluation algorithms section analytically evaluate algorithms 
main results 
proofs supporting lemmas important results high probability bounds corresponding bounds average number flows passing multistage filter estan varghese 
focus important questions results 
distinct measures quality results large flows identified accurately traffic estimated 
resources required algorithm 
key resource measure size flow memory needed 
second resource measure number memory required 
section analyze sample hold algorithm section analyze multistage filters 
analyze basic algorithms examine effect improvements section 
section section results section analytically compare algorithms sampled netflow 
example running example give numeric instances 
assume mbyte link flows 
want measure flows traffic mbyte link capacity second measurement interval 
sample hold define notation section 
probability sampling byte size flow bytes threshold large flows capacity link number bytes sent entire measurement interval acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese oversampling factor defined number bytes counted flow 
quality results sample hold 
measure quality results probability flow threshold identified 
section probability flow size identified oversampling factor results probability missing flows threshold example example bytes oversampling 
average packet size bytes roughly packets 
second measure quality results difference size flow estimate 
number bytes go gets sampled geometric probability distribution probability sd best estimate standard deviation estimate error larger overestimate size flow case deviation actual value value compute relative error flow size example example oversampling factor relative error computed standard deviation estimate divided actual value flow threshold 
memory requirements sample hold 
size flow memory determined number flows identified 
actual number sampled packets upper bound number entries needed flow memory new entries created sampled packets 
assuming link constantly busy linearity expectation expected number sampled bytes example oversampling requires entries average 
number sampled bytes exceed value 
number sampled bytes binomial distribution normal curve bound high probability number bytes sampled measurement interval 
probability actual number standard deviations expected value similarly probability standard deviations expected value 
standard deviation number sampled bytes cp 
example oversampling overflow probability need entries 
ignore simplicity bytes sampled byte packet counted 
actual algorithm accurate model 
focus large flows ignore simplicity correction factor need apply account case flow goes undetected bound size flow ignore 
gibbons matias gibbons matias elaborate analysis different correction factor 
acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants result tightened assumptions distribution flow sizes account large flows having packets sampled 
assume flows zipf pareto distribution parameter defined prs constant bandwidth total traffic largest flows ln ln estan varghese 
value obtain upper bound number entries expected flow memory assuming largest flows entry having packets sampled packet sampled rest traffic creates entry cp ln ln 
differentiating obtain value provides tightest bound cp ln 
example oversampling requires entries average 
effect preserving entries 
preserve entries measurement intervals improve accuracy 
probability missing large flow decreases keep entry prior interval 
accuracy increases know exact size flows entries keep 
quantify improvements need know ratio long lived flows large ones 
cost improvement accuracy increase size flow memory 
need memory hold samples measurement intervals expected number entries bounded bound high probability number entries normal curve standard deviation number sampled packets intervals cp 
example oversampling acceptable probability overflow equal flow memory entries preserve entries 
effect early removal 
effect early removal proportion false negatives depends entries removed early reported 
believe realistic implementations report entries assumption analysis 
early removal threshold 
flow threshold reported bytes sampled 
probability missing flow approximately early removal threshold increases probability missing large flow oversampling 
early removal reduces size memory required limiting number entries preserved previous measurement interval 
flows sending bytes number entries keep smaller oc bound expected number sampled packets 
expected number entries need oc bound high probability number entries normal curve 
standard deviation randomness packets keep older entries threshold 
performing worst case analysis assume flow threshold packets sampled decreasing number entries required 
acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese sampled interval cp 
example oversampling overflow probability requires memory entries 
multistage filters section analyze parallel multistage filters 
notation define new number buckets stage depth filter number stages number active flows stage strength ratio threshold average size counter 
channel capacity 
intuitively factor inflate stage memory minimum example illustrate results numerically assume solve measurement example described section stage filter buckets stage 
stage strength stage memory times buckets maximum number flows cross specified threshold 
quality results multistage filters 
discussed section multistage filters false negatives 
error traffic estimates large flows bounded threshold flow send bytes entered flow memory 
stronger filter flow entered flow memory reaches state upper bound probability small flow passing filter described section 
lemma 
assuming hash functions different stages independent probability flow size passing parallel multistage filter ps proof bound formalizes preliminary analysis multistage filters section 
note bound assumption distribution flow sizes applies flow distributions 
assume hash functions random independent 
bound tight sense exact distribution flows size send packets flow size realistic traffic mixes flow sizes follow zipf distribution conservative bound 
lemma obtain lower bound expected error large flow 
theorem 
expected number bytes large flow size undetected multistage filter bound ymax maximum size packet 
ymax acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants bound suggests significantly improve accuracy estimates adding correction factor bytes counted 
side adding correction factor overestimate flow sizes may problem accounting applications 
ymax factor result comes fact packet counters exceed threshold arrives initialized size ymax 
memory requirements multistage filters 
dimension flow memory bounds number flows pass filter 
lemma compute bound total number flows expected pass filter full derivation theorem appendix 
theorem 
expected number flows passing parallel multistage filter bound max kn kn example theorem gives bound flows 
stages resulted bound give 
note term dominates max gain adding stages 
bound number flows passing filter high probability 
example probability flows pass filter 
increasing flow memory expected size overflow flow memory extremely improbable 
sample hold making assumptions distribution flow sizes lead smaller bound number flows expected enter flow memory estan varghese 
theorem 
flows sizes zipf distribution parameter expected number flows passing parallel multistage filter bound db kd kd max ln ln 
db ln example theorem gives bound number flows expected pass filter 
effect preserving entries shielding 
preserving entries affects accuracy results way sample hold long lived large flows traffic counted exactly interval threshold 
sample hold preserving entries basically doubles bounds memory usage 
shielding strong effect filter performance reduces traffic filter 
reducing traffic times increases stage strength substituted theorems 
acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese measure sample multistage sampling hold filters relative error flow size zc memory accesses packet mz log mz log mz table comparison core algorithms sample hold provides accurate results pure sampling memory accesses 
comparing measurement methods section analytically compare performance traffic measurement algorithms new algorithms sample hold multistage filters sampled netflow 
section compare algorithms core traffic measurement devices 
core comparison assume algorithms amount high speed memory compare accuracy number memory accesses 
allows fundamental analytical comparison effectiveness algorithm identifying heavy hitters 
practice may unfair compare sampled netflow algorithms amount memory 
sampled netflow afford large amount dram process packet algorithms process packet need store flow entries sram 
perform second comparison section complete traffic measurement devices 
second comparison allow sampled netflow memory algorithms 
comparisons algorithm analysis section analysis netflow taken estan varghese 
comparison core algorithms section compare sample hold multistage filters ordinary sampling netflow assumption constrained memory entries 
precisely expected number memory entries irrespective distribution flow sizes 
focus accuracy measurement flow defined standard deviation estimate actual size flow traffic zc flows link capacity 
bound expected number entries sample hold sampling pc 
making equal solve substituting formulae accuracy estimates eliminating terms insignificant decreases link capacity goes obtain results shown table multistage filters simplified version result theorem kd increase number stages multistage filter logarithmically number flows increases single small flow expected pass filter strength stages 
point configuring filter small number small flows pass resulted smaller memory fewer memory accesses need fewer stages complicated formulae 
acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants measure sample hold multistage filters sampled netflow exact measurements longlived longlived relative error zt memory bound log min memory accesses log table ii 
comparison traffic measurement devices estimate memory usage log depends implementation reflects relative cost counter entry flow memory 
obtain upper bound error estimate flows size zc 
result table immediate 
term mz appears formulae row table exactly equal oversampling defined case sample hold 
expresses times willing allocate theoretical minimum memory obtain better accuracy 
see error algorithms decreases inversely proportional term error sampling proportional inverse square root 
second line table gives number memory locations accessed packet algorithm 
sample hold performs packet lookup packet packet processing 
multistage filters add flow memory lookup extra access counter stage number stages increases logarithm number flows 
ordinary sampling packets get sampled average packet processing table provides fundamental comparison new algorithms ordinary sampling sampled netflow 
line shows relative error algorithms scales better scaling ordinary sampling 
second line shows improvement comes cost requiring memory access packet algorithms 
allows implement new algorithms sram smaller number memory accesses packet allows sampled netflow dram 
true long larger ratio dram memory access sram memory access 
dram implementation sampled netflow problems turn second comparison 
comparing measurement devices table implies increasing dram memory size infinity reduce relative error sampled netflow zero 
assumes increasing memory increase sampling rate arbitrarily close 
error packet logged 
equate lookup flow memory single memory access 
true content memory 
lookups hardware support require memory accesses resolve hash collisions 
acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese large ratio dram speed currently ns sram speed currently ns sampled netflow minimum error corresponding value unlimited dram 
insight compare performance algorithms net flow table ii limiting netflow memory 
table ii takes account underlying technologies potential dram sram optimization preserving entries algorithms 
consider task estimating size flows fraction link capacity measurement interval seconds 
order comparison possible change somewhat way netflow operates assume reports traffic data flow measurement interval algorithms 
characteristics traffic measurement algorithms table percentage large flows known measured exactly relative error estimate large flow upper bound memory size number memory accesses packet 
note table contain actual memory bound 
example number entries netflow bounded number active flows number dram memory lookups perform measurement interval doesn change link capacity grows measurements section show algorithms actual memory usage smaller bounds especially multistage filters 
memory measured entries bytes 
assume flow memory entry equivalent counters filter flow id typically larger counter 
note number memory accesses required packet necessarily translate time spent packet memory accesses pipelined performed parallel 
simplifying assumptions technology evolution 
link speeds increase electronics 
assume sram speeds keep pace link capacities 
assume speed dram improve significantly patterson hennessy states dram speeds improve year clock rates improve year 
assume configurations algorithms 
algorithms preserve entries 
multistage filters introduce new parameter expressing times larger flow interest threshold filter zc speed gap dram sampled netflow link speeds increases link speeds increase netflow decrease sampling rate proportionally increase capacity provide smallest possible error 
netflow error calculations assume size packets large flows bytes 
differences stem core algorithms table see new differences table ii 
big difference row table ii limit number packets netflow process table ii cisco documentation states sampling turned speeds larger oc mbits second 
assumed maximum speed netflow handle minimum sized byte packets 
capacity link times oc packets gets sampled 
assume netflow netflow handle packets smaller bytes oc speeds 
acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants netflow algorithms provide exact measures long lived large flows preserving entries 
precisely preserving entries algorithms exactly measure traffic case sample hold large flows large previous interval 
measurements show large flows long lived depending flow definition average percentage large flows large previous measurement interval big advantage 
course get advantage sram flow memory preserves large flows measurement intervals sampled netflow 
require router root dram flow memory interval find large flows large processing load 
argue afford sram flow memory quite easy sample hold 
second big difference row table ii algorithms arbitrarily accurate cost increases amount memory sampled netflow increasing measurement interval third row table ii compares memory algorithms 
extra factor sample hold multistage filters arises preserving entries 
note number entries sampled netflow bounded number active flows number memory accesses seconds 
fourth row table ii identical second row table table ii demonstrates algorithms advantages netflow provide exact values long lived large flows row ii provide better accuracy small measurement intervals row 
advantages algorithms advantages shown table ii 
iii provable lower bounds traffic iv reduced resource consumption collection faster detection new large flows 
examine advantages iii detail 
iii provable lower bounds possible disadvantage sampled netflow netflow estimate actual lower bound flow size 
customer may charged customer sends 
probability arbitrarily low large measurement intervals methods duffield may philosophical objections 
algorithms problem 
iv reduced resource consumption clearly sampled netflow increase dram improve accuracy router entries measurement interval 
records processed potentially aggregated transmitted network management station 
router extracts heavy hitters log router processing large bandwidth consumed processing management station large 
fewer entries algorithms avoid resource memory transmission bandwidth router cpu cycles bottlenecks detailed table ii sample hold multistage filters incur upfront processing packet 
course technology cost impose limitations amount available sram current limits chip sram high algorithms 
acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese usage usage target threshold threshold usage target threshold increase intervals threshold threshold usage target endif endif fig 

dynamic threshold adaptation achieve target memory usage 
dimensioning traffic measurement devices describe dimension algorithms 
applications face adversarial behavior detecting dos attacks conservative bounds sections 
applications accounting obtain greater accuracy aggressive dimensioning described 
measurements section show gains substantial 
example number false positives multistage filter orders magnitude conservative analysis predicts 
avoid priori knowledge flow distributions adapt algorithm parameters actual traffic 
main idea keep decreasing threshold conservative estimate flow memory nearly full totally filling memory result new large flows tracked 
dynamically adapting threshold effective way control memory usage 
sampled netflow uses fixed sampling rate low small percentage memory time high memory filled netflow forced expire entries lead inaccurate results exactly important traffic 
presents threshold adaptation algorithm 
important constants adapt threshold traffic target usage variable target tells full memory risking filling completely adjustment ratio variables algorithm uses decide adjust threshold achieve desired increase decrease flow memory usage 
give stability traffic measurement device variable contain number entries measurement interval average intervals 
measurements estan varghese find values target usage adjustment ratio 
want target usage high possible low short term fluctuations number large flows cause flow memory fill 
measurements target memory usage experiments 
adjustment ratio reflects traffic measurement device adapts longer term fluctuations number large flows 
memory target usage drastic increasing threshold usage target cautious decreasing 
measuring highest lowest impact increase threshold number flows flow memory arrived acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants value case sample hold multistage filters 
dimensioning multistage filter correct constants threshold adaptation algorithm configuration parameters multistage filter need set 
aim section derive exact optimal values configuration parameters multistage filters 
due dynamic threshold adaptation device suboptimal values configuration parameters 
want avoid configuration parameters lead dynamic adaptation stabilize value threshold significantly higher optimal configuration 
assume design constraints limit total amount memory stage counters flow memory restrictions divide filter flow memory 
number packet memory accesses limited assume limit number stages 
want see divide available memory filter flow memory stages 
base configuration parameters knowledge traffic mix number active flows percentage large flows long lived 
introduce simplified model multistage filter works 
measurements confirm model closer actual behavior filters conservative analysis 
shielding old large flows affect filter 
assume conservative update counters new large flows hash reach threshold 
number large flows number new large flows 
approximate probability small flow passing stage passing filter gives number false positives interval fp number memory locations measurement interval consists large flows false positives previous interval new large flows new false positives fp 
able establish tradeoff available memory filter flow memory need know relative cost counter flow entry 
denote ratio size counter size entry 
amount memory filter going equivalent entries 
determine optimal number counters stage certain number large flows new large flows stages take derivative total memory respect equation gives optimal value equation gives total amount memory required choice simplifying assumption ratio re acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese lated flow arrival rate doesn depend threshold 
measurements confirm approximation wide ranges threshold 
mag trace define flows granularity tcp connections defining flows destination ip defining pairs 
number entries available memory hold 
solve equation respect possible values limit number memory accesses afford packet 
choose depth filter gives largest compute value 

measurements section section theoretical analysis understand effectiveness algorithms 
section turn experimental analysis show algorithms behave better real traces reasonably bounds provided earlier theoretical analysis compare sampled netflow 
start describing traces configuration details common experiments 
section compare measured performance sample hold algorithm predictions analytical evaluation evaluate various improvements basic algorithm help 
section evaluate multistage filter improvements apply 
conclude section compare complete traffic measurement devices algorithms cisco sampled netflow 
unidirectional traces internet traffic second clear mag caida captured august oc backbone link isps second anonymized traces project nlanr captured september access points internet large universities oc ind oc cos 
experiments seconds trace mag trace mag 
experiments different definitions flows 
definition granularity tcp connections flows defined tuple source destination ip address port protocol number 
definition close cisco netflow 
second definition uses destination ip address flow identifier 
definition identify router ongoing distributed denial service attacks 
third definition uses source destination autonomous system flow identifier 
close determine traffic patterns network 
definition anonymized traces ind cos perform route lookups 
table iii describes traces 
number active flows applicable flow definitions 
reported values smallest largest average value measurement intervals respective traces 
number megabytes interval smallest average largest value 
traces respective link capacities 
best value size measurement interval depends application traffic mix 
chose measurement interval seconds experiments 
estan varghese gives measurements base decision 
note cases acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants trace number flows min avg max mb interval tuple destination ip pair min max mag mag ind cos percentage traffic table iii 
traces measurements mag tuples mag destination ip mag pairs ind cos percentage flows fig 

cumulative distribution flow sizes various traces flow definitions packets weighted packet size arrive seconds previous packet belonging flow 
algorithms assumption heavy flows dominate traffic mix find useful see extent true traces 
presents cumulative distributions flow sizes traces mag ind cos flows defined tuples 
trace mag plot distribution case flows defined destination ip address case flows defined source destination ases 
see top flows represent total traffic validating original assumption flows dominate 
comparing theory practice summarize important results compare theoretical bounds results actual traces quantify benefits various optimizations 
appendix discuss measurement results sample hold appendix results multistage filters 
acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese algorithm maximum memory usage entries average error mag tuple mag mag ind tuple cos tuple general bound zipf bound sample hold pres 
entries early removal table iv 
summary sample hold measurements threshold oversampling summary findings sample hold 
table iv summarizes results single configuration threshold link oversampling 
ran experiments different random hash functions reported traces respective flow definitions 
table gives maximum memory usage measurement intervals ratio average error large flows threshold 
row presents theoretical bounds hold making assumption distribution flow sizes number flows 
bounds expected number entries case high probability bounds 
second row presents theoretical bounds assuming know number flows know sizes zipf distribution parameter 
note relative errors predicted theory may appear large computed low threshold apply flows exactly threshold 
third row shows actual values measured basic sample hold algorithm 
actual memory usage bounds 
reason links lightly loaded second reason partially captured analysis assumes zipf distribution flows sizes large flows packets sampled 
average error close expected value 
fourth row presents effects preserving entries 
increases memory usage especially large flows big share traffic significantly reduces error estimates large flows error large flows identified previous intervals 
improvement noticeable long lived flows 
row table reports results preserving entries early removal threshold threshold see appendix value 
compensated increase probability false negatives early removal causes increasing oversampling 
average error decreases slightly 
memory usage decreases especially cases defined relative error dividing average error size threshold 
defined average ratio flow error size difficult compare results different traces 
acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants percentage false positives log scale depth filter general bound zipf bound serial filter parallel filter conservative update fig 

filter performance stage strength preserving entries caused increase 
performed measurements configurations 
results general similar ones table iv emphasize noteworthy differences 
expected error approaches size packet see significant decreases average error 
analysis assumes sample byte level 
practice certain packet gets sampled bytes counted including ones byte sampled 
second preserving entries reduces average error increases memory usage 
figures vary change threshold oversampling 
third early removal threshold reduces memory usage 
size improvement depends trace flow definition increases slightly oversampling 
summary findings multistage filters 
summarizes findings configurations stage strength challenging trace mag flows defined granularity tcp connections 
represents percentage small flows log scale passed filter depths stages 
threshold th maximum traffic 
topmost solid line represents bound theorem 
second line represents improvement theoretical bound assume zipf distribution flow sizes 
case sample hold maximum traffic link capacity computing theoretical bounds 
results tighter theoretical bounds 
third line represents measured average percentage false positives serial filter fourth line represents parallel filter 
see times better stronger theoretical bounds 
number stages goes parallel filter gets better serial filter factor 
line represents parallel filter conservative update gets progressively better parallel filter factor acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese number stages increases 
see lines roughly straight indicates percentage false positives decreases exponentially number stages 
measurements traces show similar results 
difference bounds measured performance larger traces largest flows responsible large share traffic 
conservative update preserving entries average error close threshold 
preserving entries reduces average error estimates estimates long lived flows exact measurement interval 
improvements results due preserving entries depend traffic mix 
preserving entries increases number flow memory entries 
effectively increasing stage strength shielding considerably strengthens weak filters 
lead reducing number entries 
evaluation complete traffic measurement devices final comparison sample hold multistage filters sampled netflow 
perform evaluation long oc trace mag 
assume devices mbit memory entries possibilities today chips 
sampled netflow unlimited memory uses sampling packets 
run algorithms times trace different sampling hash functions 
algorithms adaptive threshold approach 
avoid effect initial misconfiguration ignore intervals give devices time reach relatively stable value threshold 
impose limit stages multistage filters 
heuristics section counters stage entries flow memory flow definition granularity tcp connections counters entries destination ip flow identifier counters entries source destination 
multistage filters shielding conservative update 
sample hold uses oversampling early removal threshold 
purpose see accurately algorithms measure largest flows implicit definition large flows 
look separately devices perform groups large flows link capacity large flows tenth medium flows tenth bytes 
groups look measures accuracy average runs measurement intervals percentage flows identified relative average error 
compute relative average error dividing sum absolute values errors sum sizes flows 
modulus positive negative errors don cancel netflow 
cisco netflow uses bytes entry cheap dram 
conservatively assume size flow memory entry bytes plausible 
conservatively assume bytes counter bytes 
acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants group unidentified flows average error flow size sample multistage sampled hold filters netflow table comparison traffic measurement devices flow ids defined tuple group unidentified flows average error flow size sample multistage sampled hold filters netflow table vi 
comparison traffic measurement devices flow ids defined destination ip unidentified flows consider error equal total traffic 
tables vii results different flow definitions 
source destination flow identifier situation different cases average number active flows larger number memory locations accommodate sram discuss case separately 
cases see algorithms accurate sampled netflow large large flows 
medium flows average error roughly algorithms sampled netflow 
sample hold stabilized thresholds slightly multistage filters normal flows third group detected 
believe results similar results confirm algorithms better sampled netflow measuring large flows 
multistage filters slightly better sample hold despite fact sacrifice part memory stage counters 
tighter algorithms threshold adaptation possibly improve algorithms 
third case average number large large medium flows number available memory locations flows long lived algorithms measured flows accurately 
number flows times larger number active flows algorithms ensure available memory accurately measure largest flows provide graceful degradation case traffic deviates expected flows 

implementation issues briefly describe implementation issues 
sample hold easy implement network processor adds memory packet processing assuming sufficient sram flow memory assuming associative memory 
small flow memory sizes adding cam quite feasible 
alterna acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese group unidentified flows average error flow size sample multistage sampled hold filters netflow table vii 
comparison traffic measurement devices flow ids defined source destination tively implement associative memory hash table storing flow ids collide smaller cam 
multistage filters harder implement network processor need multiple stage memory 
multistage filters easy implement asic feasibility study shows 
huber describes chip designed implement parallel multistage filter stages counters flow memory entries 
chip runs oc line speeds 
core logic consists roughly transistors fit mm mm micron process 
including memories overhead total size chip mm mm total power watt put chip low today ic designs 

motivated measurements show traffic dominated heavy hitters tackles problem directly identifying heavy hitters keeping track potentially millions small flows 
fundamentally table shows algorithms better scaling estimate error inversely proportional memory size provided state art sampled netflow solution inversely proportional square root memory size 
actual measurements algorithms optimizations orders magnitude better predicted theory 
comparing sampled netflow algorithms difficult indicated table sampled netflow process packet afford large dram 
despite results table ii section show algorithms accurate small intervals netflow 
addition netflow algorithms provide exact values long lived large flows provide provable lower bounds traffic reliably billing avoid resource intensive collection large netflow logs identify large flows fast 
comparison indicates algorithms may better sampled netflow problem identifying heavy hitters manager precise idea flow definitions interesting 
netflow records allow managers mine posteriori patterns data anticipate algorithms rely efficiently identifying stylized patterns defined priori 
see may insufficient imagine cnn suddenly gets flooded web traffic 
manager realize event interesting flow definition watch acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants multipoint point flow defined destination address port numbers 
example motivates interesting open question 
possible generalize algorithms automatically extract flow definitions corresponding large flows 
second open question deepen theoretical analysis account large discrepancies theory experiment 
noting measurement problems data volume high speeds networking similar measurement problems faced areas data mining architecture compilers 
example sastry proposed sampled netflow strategy obtain dynamic instruction profiles processor optimization sastry 
show multistage filters conservative update improve results sastry 
techniques may utility areas techniques areas may utility 

claffy moore anonymous reviewers valuable comments 
possible nist project nsf ani 
altman chu 
proposal flexible service plan attractive users internet service providers 
ieee proceedings infocom 
bloom 
space time trade offs hash coding allowable errors 
commun 
acm 
vol 


brownlee mills ruth 
traffic flow measurement architecture 
rfc 
burrows leung vandevoorde waldspurger weihl 
efficient flexible value sampling 
asplos 
cohen matias 
spectral bloom filters 
sigmod pods 
duffield lund thorup 
charging sampled network usage 
sigcomm internet measurement workshop 
duffield grossglauser 
trajectory sampling direct traffic observation 
proceedings acm sigcomm 

estan varghese 
new directions traffic measurement accounting 
tech 
rep ucsd cse department 
feb fang shivakumar garcia molina motwani ullman 
computing iceberg queries efficiently 
international conference large data bases 

fang peterson 
inter traffic patterns implications 
proceedings ieee globecom 
feldmann greenberg lund reingold rexford true 
deriving traffic demands operational ip networks methodology experience 
proceedings acm sigcomm 

feng kandlur saha shin 
stochastic fair blue queue management algorithm enforcing fairness 
ieee proceedings infocom 
gibbons matias 
new sampling summary statistics improving approximate query answers 
proceedings acm sigmod 

huber 
design oc flow monitoring chip 
class project 
karp papadimitriou shenker 
simple algorithm finding frequent elements streams bags 
acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese mackie masson varian 
public access internet 
mit press chapter pricing internet 
mahajan bellovin floyd ioannidis paxson shenker 
controlling high bandwidth aggregates network 
www aciri org 
moore 
personal conversation 
see caida analysis code red 
www caida org analysis security code red 
sherwood calder varghese 
catching accurate profiles hardware 
hpca 
netflow 
cisco netflow 
www cisco com warp public tech netflow 
pan breslau prabhakar shenker 
approximate fairness differential dropping 
tech 
rep aciri 
patterson hennessy 
computer organization design second ed 
morgan kaufmann 
sastry bodik 
rapid profiling stratified sampling 
th 
international symposium computer architecture 

shaikh rexford 
load sensitive routing long lived ip flows 
proceedings acm sigcomm 
shenker clark estrin herzog 
pricing computer networks reshaping research agenda 
acm computer communications review 
vol 


kim reddy 
identifying long term high rate flows router 
proceedings high performance computing 
thomson miller wilder 
wide area traffic patterns characteristics 
ieee network 
tong reddy 
qos enhancement partial state 
international workshop qos 
acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants details analysis multistage filters appendix presents full derivation theorem 
notation section 
derive necessary lemmas 
lemma 
probability flow size passing stage filter bound ps ifs tk bound 
proof assume flow arrive bucket 
increase chance pass stage contrary reality happened packets belonging flow arrived bucket reached threshold flow detected bucket went threshold 
probability flow passing stage larger probability bucket hashed reaches bucket flow reach flows hashing bucket add total amount traffic belonging flows maximum number buckets traffic flows reach 
probability flow passing filter bound probability hashed bucket 
ps lemma compute probability small flow passes parallel multistage filter 
lemma 
assuming hash functions different stages independent probability flow size passing parallel multistage filter bound ps proof flow passes filter passes stages 
stages updated way parallel filter lemma applies 
hash functions independent probability flow passing stages equals product probabilities stage 
give bound number flows passing multistage filter 
theorem 
expected number flows passing parallel multistage filter bound max kn kn proof si sequence flow sizes traffic mix 
ni ni si share total traffic flows number flows size si 
hi size si responsible 
immediate ni hi 
lemma expected number flows size si pass filter si linearity expectation able bound divide flows groups size 
largest flows ones bound psi 
ones si smallest flows ones average flow size psi pc 
acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese number average flows bound flows taken np si middle group flows hic si si hi si si hic si si si si hi si si si easier follow proof proceeds assume adversary tries arrange flows purpose largest number possible flows passes filter 
adversary budget limited total amount traffic send add send link bandwidth 
see adversary achieve highest number spending traffic allocates flows flows exactly equivalent noticing substituting flows group number flows size generate amount traffic guaranteed decrease lower bound 
step observation number flows passing filter maximized adversary chooses size flows middle group maximizes number flows expected pass filter amount total traffic 
si max si si hi si si si determine maximum function don domain 
forx interval left value right 
represents minimum 
maximum obtained ends interval df df nt kc kn substituting values obtain bound 
acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants percentage false negatives log scale mag tuples mag destination ip mag pairs ind cos analytical estimate oversampling fig 

percentage false negatives oversampling changes measurements sample hold appendix detailed discussion measurements performance sample hold optimizations 
important results omitted results estan varghese results discussed 
compare measured performance sample hold algorithm values predicted analysis 
measure improvement introduced preserving entries measurement intervals 
subsection measure effect early removal determine value early removal threshold 
measures performance sample hold algorithm average percentage large flows identified false negatives average error traffic estimates large flows maximum number locations flow memory 
comparing behavior basic algorithm analytic results set experiments looks effect oversampling performance sample hold 
configure sample hold measure flows link bandwidth vary oversampling factor probability missing flow threshold 
perform experiment trace mag ind cos trace mag flow definitions 
configuration perform runs different random functions choosing sampled packets 
shows percentage false negatives axis logarithmic 
plot probability false negatives predicted conservative analysis 
measurement results considerably better predicted analysis 
reason analysis assumes size large flow exactly equal threshold large flows threshold making identified 
acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese average error percentage threshold mag tuples mag destination ip mag pairs ind cos analytical estimate oversampling fig 

average error traffic estimates large flows maximum number flow memory entries mag tuples mag destination ip mag pairs ind cos oversampling fig 

maximum number flow memory entries configurations large flows close threshold false negative ratios closest results conservative analysis 
results confirm probability false negatives decreases exponentially oversampling increases 
shows average error estimate size identified large flow 
measured error slightly error predicted analysis 
results confirm average error estimates proportional inverse oversampling 
shows maximum measurement intervals number entries flow memory 
measurement results acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants average error percentage flow threshold mag tuples mag destination ip mag pairs ind cos threshold percentage link capacity fig 

average error traffic estimates large flows order magnitude lower bound section 
main reasons links lightly loaded sampled packets belonging large flows create new entries flow memory 
results show number entries depends number active flows dependence stronger sampling probability oversampling increases 
set experiments looks choice threshold influences performance sample hold algorithm 
run algorithm fixed oversampling factor thresholds link bandwidth 
interesting result showing average error estimate size identified large flow 
expected actual values usually slightly expected error threshold 
significant deviations traces ind especially cos small values threshold 
explanation threshold approaches size large packet threshold oc cos corresponds bytes size packets large flows bytes 
analysis assumes sample byte level 
practice certain packet gets sampled bytes counted including ones byte sampled 
effect preserving entries traces performed sets experiments fixed threshold varying oversampling fixed oversampling varying threshold 
improvement introduced preserving entries influenced oversampling influenced considerably choice threshold 
conjecture happens magnitude improvement depends distribution durations large flows changes change threshold mix large flows changes 
preserving entries reduces acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese memory usage ratio ratio early removal threshold threshold fig 

effect early removal memory usage trace flow definition false neg 
change average error change memory change min median max min median max min median max mag tuple mag destination ip mag pairs ind tuple cos tuple table viii 
various measures performance early removal threshold threshold compared values early removal probability false negatives 
reduces average error 
reduction strongest large flows long lived 
preserving entries increases memory usage 
increase smallest large flows larger share traffic 
effect early removal measure effect early removal configurations oversampling thresholds link bandwidth 
configurations measure range values early removal threshold 
adjust oversampling probability missing flow threshold stays early removal see section details 
point experiments obtain value early removal threshold results smallest possible memory usage 
performed runs cos trace configuration 
measurements show probability false negatives decreases slightly early removal threshold increases 
confirms compensate correctly large flows removed early increase oversampling 
results confirm expectation acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants proportion false positives log scale depth filter mag serial mag serial mag serial ind serial cos serial mag parallel mag parallel mag parallel ind parallel cos parallel strongest bound fig 

actual performance stage strength average error decrease roughly linearly early removal threshold increases due compensatory increase oversampling 
shows optimal value early removal threshold far memory usage concerned threshold 
results conclude larger threshold memory save gain accuracy early removal 
larger oversampling gain accuracy memory 
results traces flow definitions similar trends actual improvements achieved various metrics different 
table viii minimum median maximum values configurations metrics interest early removal threshold threshold 
values reported ratios values obtained early removal 
measurements multistage filters compare performance serial parallel multistage filters bound theorem 
measure benefits conservative update 
subsection measure combined effect preserving entries shielding 
comparing behavior basic filters analytic results compare number false positives serial parallel filters bound theorem 
number flow memory locations meaningful measure performance algorithm number false positives strong filters number entries dominated entries actual large flows making harder distinguish changes order magnitude number entries occupied false positives 
easier compare results different traces different flow definitions different numbers active flows report percentage false positives number 
important detail acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese proportion false positives log scale depth filter mag serial mag serial mag serial ind serial cos serial mag parallel mag parallel mag parallel ind parallel cos parallel strongest bound fig 

actual performance stage strength express threshold percentage maximum traffic percentage link capacity 
actual implementations know traffic advance choice thresholds gives information filters behave extreme conditions fully loaded link 
set experiments fix threshold th maximum traffic vary stage strength depth filter number counters filter 
configuration measure runs different random hash functions 
results measurements stage strengths results estan varghese 
represent strongest bound obtain theorem configurations measure 
note axis logarithmic 
results show filtering general order magnitude stronger bound 
parallel filters stronger serial filters configuration 
difference grows degenerate case single stage orders magnitude stages 
actual filtering depends trace flow definition 
see actual filtering strongest traces flow definitions large flows strongly dominate traffic 
see actual filtering follows straight lines denotes exponential improvement numbering stages 
configurations certain point filtering doesn improve fast anymore 
explanation false positives dominated flows close threshold 
parallel filters clearly outperform serial ones subsequent experiments 
effect conservative update set experiments evaluates effect conservative update 
run experiments filter depths 
configuration measure runs different random hash functions 
brevity figures results stage strengths 
improvement introduced acm transactions computer systems vol 
tbd 
tdb month year 
new directions traffic measurement accounting focusing elephants proportion false positives log scale proportion false positives log scale depth filter mag parallel mag parallel mag parallel ind parallel cos parallel mag conservative mag cons 
mag cons 
ind conservative cos conservative fig 

conservative update stage strength depth filter mag parallel mag parallel mag parallel ind parallel cos parallel mag conservative mag cons 
mag cons 
ind conservative cos conservative fig 

conservative update stage strength conservative update grows order magnitude number stages increases 
configuration stages strength obtained false positives running mag trace flows defined pairs plotted line falls abruptly 
extrapolating curve expect find approximately false positive consider data point invalidate 
effect preserving entries shielding set experiments evaluates combined effect preserving entries shielding 
run experiments filter depths stage strengths 
measure largest number entries flow memory acm transactions computer systems vol 
tbd 
tdb month year 
estan varghese trace flow definition error preserving entries mag tuple mag destination ip mag pairs ind tuple cos tuple table ix 
average error preserving entries percentage average error base case change memory usage depth filter mag mag mag ind cos mag mag mag ind cos fig 

change memory usage due preserving entries shielding average error estimates 
computing maximum memory requirement ignored measurement intervals experiment effect shielding fully visible third measurement interval 
improvement average error depend filter configuration 
table ix shows results trace flow definition 
usually weak filters weak stages reduction average error slightly larger strong ones 
conflicting effects preserving entries memory requirements 
hand preserving entries increase number entries 
hand shielding increases strength filter see section details leads decrease number false positives 
shows memory usage influenced preserving entries 
effect strong filters leading increase memory usage 
second weak filters leading decrease 
acm transactions computer systems vol 
tbd 
tdb month year 
