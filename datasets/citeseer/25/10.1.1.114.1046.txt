program optimization object oriented languages craig chambers jeffrey dean david grove department computer science engineering box university washington seattle washington usa technical report june chambers grove cs washington edu fax program optimization object oriented languages craig chambers jeffrey dean david grove department computer science engineering university washington box seattle washington fax chambers grove cs washington edu describe vortex optimizing compiler intended produce high quality code programs written heavily object oriented style 
achieve vortex includes number intra interprocedural static analyses exploit knowledge program compiled including intraprocedural class analysis class hierarchy analysis exhaustive class testing profile guided optimizations receiver class prediction selective specialization 
program optimization practical vortex automatically tracks cross file optimization dependencies fine granularity triggering selective recompilation affected compiled files source program changes 
empirical measurements purely object oriented benchmark programs written cecil ranging size lines source code indicate optimization techniques improve performance large programs factor system intraprocedural static optimizations 
vortex written cecil compiler optimizer development past years 
vortex optimizations implementation techniques useful language program optimizations reduce cost polymorphism important including object oriented languages currently adding front ends modula java vortex study effectiveness language styles highlevel symbolic functional logic languages 
object oriented programming languages include features programs reusable extensible classes support construction encapsulated data types inheritance allows data type implemented incremental modification existing data type implementations dynamic dispatching known message passing introduces level indirection client implementation allows single piece client code manipulate multiple different implementations different times program run long implementations support interface required client 
additionally presence specific features encourages new programming styles idioms 
example rich inheritance hierarchies classes developed particular domains including standard data structure libraries graphics packages numerical libraries 
libraries include related abstractions inheritance allows similar abstractions developed maintained relatively little effort 
combination inheritance dynamic dispatching allows common code patterns factored specific concrete classes shared superclasses dynamic dispatching allows subclass specific behavior invoked shared factored code 
libraries client applications new ways expecting client applications add application specific subclasses instantiate refine generic class library collections classes designed application specific program optimization object oriented languages chambers subclassing called frameworks 
object oriented systems achieved remarkable success popularity due large part increases programmer productivity natural match object oriented notions ways people think programs application domain 
unfortunately new styles programming fostered object oriented programming language features tend hinder efficient execution 
dynamic dispatching incurs direct cost determining appropriate routine execute dynamic class es argument call indirect opportunity cost due preventing inline expansion post inlining intraprocedural optimizations 
programming styles fostered object oriented programming serve exacerbate cost classes encapsulation encourage smaller routines greater frequency procedure calls inheritance factoring encourage increased dynamic dispatching frameworks designed application customization subclassing rely dynamic dispatching interact new classes 
sad fact greater potential benefits object oriented programming greater runtime performance cost 
pure object oriented languages smalltalk represent extreme position trade language features expressed object oriented terms preserving maximum flexibility potential extension incurring greatest run time performance cost 
developing new optimizing compiler infrastructure object oriented languages named vortex 
vortex attempts reduce run time performance cost heavily object oriented programming styles collection static analysis dynamic profile guided techniques culminating idea program analysis optimization examining static dynamic behavior entire application compiler attempts identify potential flexibility needed particular application choose efficient implementation strategy flexibility needed 
vortex includes techniques static intraprocedural class analysis kind dataflow analysis computes upper bound set classes instances stored variables result expression evaluations 
information receivers messages compiler tries perform compile time method lookup replace dynamically dispatched message statically bound direct procedure call 
automatic procedure inlining serves reduce overhead statically bound calls small procedures 
similar intraprocedural analyses reduce cost closures especially implement user defined control structures 
class hierarchy analysis extends static intraprocedural analysis knowledge entire program class inheritance graph 
knowledge compiler replace knowledge variable holds unknown subclass class specific knowledge variable holds instance fixed set known classes 
class hierarchy analysis particularly helpful identifying messages default target method overridden potential flexibility needed particular application compiled 
languages multi methods knowledge formal argument positions specialized multi methods comprising program enables compile time method lookup run time dispatching implemented efficiently 
class hierarchy analysis able narrow set potentially invoked methods methods exhaustive class testing insert run time subtyping tests replace message group statically bound calls inlined code 
dynamic profile information relative frequencies classes receivers particular call sites vortex augment information derived static analysis 
vortex applies dynamic receiver class frequency information guide receiver class prediction technique common program optimization object oriented languages chambers receiver classes special cased call sites inserting run time tests expected classes branch inlined versions corresponding target methods 
splitting technique reduces cost redundant class tests replicating paths intraprocedural control flow graph order preserve intraprocedural class information derived class tests long needed 
selective method specialization produces multiple versions particular source method version compiled optimized subset original method potential argument classes 
class hierarchy information identify set classes share particular specialized version dynamic profile information determine potential specialized versions methods profitable generate 
program analysis form interprocedural analysis introduce compilation dependencies modules module changed independent modules may outof date need recompilation 
vortex includes automatic dependency mechanism track dependencies fine grain effort minimize number modules need recompilation source program change 
manner vortex compensates lack support separate compilation selective recompilation facility 
development vortex began fall 
initially vortex compiled cecil object oriented language pure dynamically typed object oriented language multi methods chambers currently modified compile object oriented languages including modula java 
vortex written entirely cecil vortex sole cecil compiler 
techniques discussed implemented daily part ongoing development vortex compiler 
section discusses vortex static analyses including static class analysis class hierarchy analysis considers impact program analysis interactive turnaround time separate compilation 
section describes dynamic profiles guide optimization receiver class prediction considers important properties profiles peakedness stability inputs program versions necessary profile guided optimizations effective practical 
section discusses method specialization static profile guided 
section reports empirical experiments measure effectiveness techniques number benchmark programs 
section compares vortex approach related section contains sketches directions 
static analyses way reduce cost dynamic dispatching try replace dynamically dispatched message direct procedure call 
possible example receiver argument message known instance particular class case method lookup performed compile time dynamically dispatched call replaced direct call looked method 
message statically bound traditional techniques inlining interprocedural analysis optimize call 
inlining particularly important median size procedures gets small heavily object oriented functional programming 
consider dynamically dispatched calls method lookup depends argument receiver smalltalk 
extend techniques consider multi methods method lookup depend run time classes subset arguments clos cecil 
program optimization object oriented languages chambers static class analysis provides conservative upper bound set classes receiver message instance 
compiler analyses class analysis performed variety scopes ranging local analyses intraprocedural interprocedural analyses 
different scopes analysis offer different trade offs terms precision implementation complexity analysis time impact separate compilation 
section describes intraprocedural class analysis section describes class hierarchy analysis limited form interprocedural class analysis 
intraprocedural class analysis intraprocedural class analysis computes program point mapping variables sets classes 
fundamental safety requirement mappings run time object stored particular variable direct instance classes corresponding set 
goal analysis compute smallest sets possible small sets enable greatest degree static binding dynamically dispatched messages 
dataflow analysis intraprocedural class analysis structured standard forward dataflow analysis 
representations class sets useful name definition description unknown set classes information available cone set subclasses procedure entry formal parameter bound unknown dynamically typed language cone statically declared type pointer subclasses 
relevant flow functions common operators include analyze const const analyze new analyze analyze op result op receiver static type declarations available class constants results union sn sn control flow merges difference unsuccessful type tests analyze msg rcvr result msg analyze obj var result var class 
sets updated result represents set classes result operator message instance variable access 
operators result classes pre defined 
messages instance variable accesses result class set unknown dynamically typed language cone statically typed language declared type result message contents instance variable statically declared pointer subclasses 
program optimization object oriented languages chambers vortex compiler incorporates somewhat sophisticated analysis performs simple kind alias analysis parallel class analysis enabling contents instance variables subject analysis example store instance variable followed load instance variable 
merge points mappings combined set union corresponding class sets variable defined merging mappings assuming variables defined paths meet vn vi branches mappings propagated successor branches unchanged branches represent run time class tests class set associated tested variable narrowed branches reflect outcome test op goto goto loops handled straightforward iterative techniques 
termination assured absence difference representations class sets flow functions monotonic size class sets program point grows iterative analysis proceeds finite number possible class set representations finite number classes mentioned routine optimized 
ensure termination presence difference sets widening operator approximate difference set representations conservatively necessary cousot cousot 
compiler access entire class hierarchy program discussed section approximation avoided converting difference exact union classes 
implementation treat differences left hand operand unknown specially avoid introducing recompilation dependency set concrete classes program described section 
exploiting information information derived class analysis ways optimizing dynamically dispatched messages eliminating run time class checks 
compiling dynamically dispatched send class set receiver argument fetched mapping send 
class set bounded specifies fixed enumerable set classes compile time method lookup performed member class set 
members invoke method send replaced direct call method general static binding receiver maps singleton set 
classes map small number target methods dynamically dispatched send replaced class case statement checks class receiver run time branches appropriate statically bound call 
class case transformation improve performance subsequent optimizations statically bound calls occur 
class casing discussed detail section optimizing messages way requires receiver map bounded set classes 
intraprocedural information class representation unions class representations bounded 
particular cone representation open ended representing unknown set classes program optimization object oriented languages chambers compiler know possible subclasses class 
possible techniques discussed far perform static binding messages receivers cones compiler enumerate possible receiver classes 
weakness cone representations intraprocedural class analysis implies static type declarations form variable holds class subclasses type declarations support subclass polymorphism key component flexibility object oriented programming provide help optimizing sends static binding statically typed languages bad dynamically typed languages regard 
counter intuitive result important suggests sophisticated techniques needed optimize heavily object oriented programs statically dynamically typed static types insufficient support optimizing oriented programs 
static class analysis eliminate run time class checks result class check implied known static information check successor branch eliminated 
class checks may introduced part run time checking dynamically typed languages example testing argument integer part dynamically checked narrow operations statically typed languages including latest version dynamic cast java cast eiffel reverse assignment attempt modula typecase narrow 
get best results intraprocedural static class analysis run parallel compile time method lookup inlining 
allows analysis try compute non trivial class set result method class sets arguments inlined method body inlined method help improving quality analysis downstream method 
parallel analysis particularly important pure object oriented languages computation expressed message essentially useful information obtained analysis prior inlining 
automatic inlining vortex compiler automatically decisions routines appropriate inlining 
currently compiler uses conventional heuristics examine apparent size callee method expected execution frequency call derived static heuristics wall dynamic profile data section call recursive 
higher level languages calls operations heuristics perform consider superficial size target method ignore effects optimizations performed inlining 
high level languages apparent calls target method turn optimization simple operations arithmetic standard control structures instance variable accesses leading large disparity apparent superficial size method actual size optimized code inlining 
partially overcome weakness heuristics allow routines annotated inlining pragmas indicating routine inlined overriding default heuristics pragmas key routines methods current implementation vortex compiler achieve better inlining results 
previous designed implemented sophisticated automatic inlining decision maker overcomes problems simple source level heuristics dean chambers 
encountering statically bound call potentially worthy inlining compiler tentatively inline callee optimize context caller 
optimization completed program optimization object oriented languages chambers compiler estimate costs compiled code space benefits instructions removed optimization inlining routine 
costs high relative benefits inlining undone 
amortize cost inlining trials call sites invoke method compiler recorded results trials persistent program database cost benefit information particular call database trial process skipped previous results directly 
way compiler trained inlining decisions accurate cost benefit information 
important component inlining trial system treatment call site specific information 
optimization inlined callee depends information known statically call site different call sites invoking routine lead quite different effects optimization 
approximate dependency cost benefit information information available call site compiler record static class information known call arguments system class information variables important static information 
furthermore available static information exploited optimization system recorded aspect available class information exploited optimization 
descriptions available lacking static information included entry inlining database 
call sites invoke target method compatible static class information reuse inlining trial database entry 
experimental results showed inlining trial system led inlining results sensitive superficial changes source code structure sensitive source level threshold determine routine potentially candidate inlining 
experience vortex source level heuristics confirms need sophisticated inlining decision maker 
examining results compiler frequently discover cases source level heuristics making poor inlining choices decision maker post inlining costs benefits better choices 
expect add version inlining trials vortex compiler near 
closure analyses closures class function objects high level object oriented languages smalltalk functional languages scheme ml control structures iterators predicates exception handling 
smalltalk closures implement basic control structures closures heavily part iterators collections 
unoptimized heavy closures incur serious performance cost form time allocate garbage collect closure objects time invoke closure body sending closure message 
consequently performance languages relies optimizing away cost closures 
fortunately techniques optimizing messages applied optimize closures 
treating occurrence closure expression separate class static class analysis track flow closures procedure 
inlining optimize away control structures leading code sends invoke closure message value smalltalk variable static class known closure 
message inlined replaced body closure 
uses closure value eliminated inline expansion dead assignment elimination remove closure allocation program optimization object oriented languages chambers operation 
additionally closure object downstream paths uses having inlined away instance closure allocation operation delayed program points known closure object needed run time kind partial dead code elimination knoop 
techniques vortex simple uses closures free normal case 
cases incur cost closure passed argument visible routine inlined closure stored data structure visible non inlined routines situations small fraction original source level uses closures 
class hierarchy analysis intraprocedural class analysis limited lack information program outside method analyzed methods inlined method analyzed 
particular intraprocedural class analysis useful information formal parameters method variables contents instance variables arrays results non inlined methods 
limitation greatly effectiveness strictly intraprocedural class analysis overcoming weakness lead overly aggressive inlining attempt improve quality analysis 
interprocedural class analysis greatly improve quality analysis intraprocedural class analysis research projects investigated different kinds interprocedural analyses object oriented languages palsberg schwartzbach plevyak chien agesen pande ryder 
fundamental complication underlying interprocedural analysis object oriented programs cyclic dependency structure call graph static class information inferred message receivers 
early results encouraging concerns remain scalability interprocedural analyses larger programs higher level languages grove interprocedural analysis interactions separate compilation fast turnaround time interactive development environments 
simpler alternative full interprocedural class analysis vortex compiler includes class hierarchy analysis 
class hierarchy analysis augments intraprocedural class analysis knowledge program class inheritance graph 
exploiting information structure class inheritance graph including methods defined depending implementation method instance variables classes compiler gain valuable static information possible classes receiver method compiled static type information languages 
particular cone class sets bounded compiler enumerate subclasses particular class enabling support compile time method lookup discussed section 
means messages sent receiver formal method variables statically declared types potentially optimized dramatically increasing opportunities optimization 
program optimization object oriented languages chambers illustrate consider class hierarchy method class contains send message self class class method class method method class method general sends message dynamically dispatched implementations subclasses terminology declared virtual function 
result static intraprocedural class analysis message implemented general message send 
examining subclasses determining overriding implementations message replaced direct procedure call optimized inlining traditional interprocedural analysis 
reasoning depends knowing exact class receiver previous techniques knowing subclasses override version inherited key aspect class hierarchy analysis supports goal program incur cost dynamic dispatching program 
message invokes particular method method known overridden class hierarchy analysis enable message replaced statically bound call 
facility supports development flexible reusable class libraries frameworks libraries constructed solely dynamic dispatches interaction supporting high degree potential extensibility extensibility particular application practice incur cost dynamic dispatching 
unused potential optimized automatically simply direct procedure calls open inlining 
implementation compile time method lookup previous implementations compile time method lookup considered receivers particular class 
cone union class sets receiver message bounded enumerable set classes 
long members set inherit method static binding available 
non singleton receiver class sets important studies compiling vortex compiler indicate nearly messages statically bound class hierarchy analysis receiver class sets containing single class 
implementation compile time method lookup presence non singleton receiver class sets iterate elements union cone sets performing method lookup class class method class 
class hierarchy example class method class 
program optimization object oriented languages chambers checking class inherits method slow large sets cones classes subclasses 
developed alternative approach vortex compares sets classes 
precompute method set classes method appropriate target classes inherit class method defined inherit overriding method call set applies set 
vortex computes applies sets methods demand time message particular name argument count analyzed spread cost computation 
message send take class set inferred receiver test set overlaps potentially invoked method applies set 
method applies set overlaps receiver class set method invoked message send replaced direct procedure call method 
avoid checking large number methods applicability call site program vortex incorporates compile time method lookup cache function mapping receiver class set set target methods 
practice size cache reasonable line program cache contained entries total queries cache compilation 
efficiency approach compile time method lookup depends ability precompute applies sets method implementation set overlaps test different representations sets 
precompute applies sets construct partial order set methods method partial ordering iff overrides earlier example construct partial order method initialize applies set cone class method defined 
traverse partial order top 
method visit immediately overriding methods subtract initial applies sets applies set 
general resulting applies set method represented difference cone union cone cone classes containing directly overriding methods 
method directly overriding methods representation method applies set quite large 
avoid problem subtracting ignored point safe conservative applies sets larger necessary 
efficiency overlaps testing depends representation sets compared 
overlaps testing arbitrary union sets size overlaps testing cone class representations takes constant time assuming testing class inherit takes constant time ak agrawal caseau example cone overlaps class iff inherits 
overlaps testing arbitrary difference sets complex expensive 
applies sets general differences overlaps testing receiver class set set classes fixed union sets elements singleton classes stored sorted order reducing overlaps computation 
program optimization object oriented languages chambers collection applies difference sets expensive 
represent irregular applies sets efficiently convert difference sets flattened bit set representation 
overlaps testing bit sets requires time number classes program 
practice check fast large program classes bit sets bit positions machine word machine word comparisons required check bit sets overlap 
implementation precompute bit set representation cone class bit sets computing differences cones overlaps cones membership class cone 
compiling method performing intraprocedural static class analysis static class information method receiver initialized cone class containing method 
appear applies set computed method precise initial information 
normally case 
overriding method contains super send equivalent invoke overridden method overridden method called objects method applies set applies set applies normal dynamically dispatched message sends 
known overriding methods contain super sends invoke method applies precise legal initial class set 
support dynamically typed languages dynamically typed language possibility receiver classes message send result run time message understood error 
attempting optimize dynamic dispatch need ensure replace message send statically bound call applicable source method 
handle introduce special error method defined root class default method defined 
error methods introduced special checks need compile time method lookup handle possibility run time method lookup errors 
example source method applicable method lookup error possible framework treat case methods real error applicable block static binding real method 
similarly message ambiguously defined class due multiple inheritance instance method include class applies set preventing static binding method 
support multi methods strategy static class analysis presence class hierarchy analysis static type declarations works singly dispatched languages message receiver support languages multi methods clos dylan cecil 
support multi methods associate methods sets classes sets tuples classes number dispatched arguments method 
represent common sets tuples classes concisely tuples class sets tuple sk si class sets represents set tuples classes cartesian product si class sets 
represent irregular sets tuples classes support union class set tuples basic representation 
assume compiler determine statically subset message arguments examined part method lookup 
clos instance methods generic function set dispatched arguments 
cecil compiler examines methods name number arguments finds argument positions methods specialized 
possible consider arguments potentially dispatched substantially efficient compile time run time particularly majority methods specialized single argument 
program optimization object oriented languages chambers static class analysis modified support multi methods follows 
method precompute method applies tuple class sets tuple describes combinations classes method invoked 
multi method specialized classes method applies tuple initialized cone cone 
visiting directly overriding methods overriding method applies tuple subtracted overridden method tuple 
determining methods apply message tuple formed class sets inferred dispatched message arguments applies tuples candidate methods checked see overlap tuple representing actual arguments message 
efficient multi method static class analysis relies efficient overlaps testing difference operations tuples 
testing tuple overlaps straightforward element class set tuple overlap corresponding class set tuple 
computing difference tuples class sets efficiently trickier 
pointwise difference element class sets concise incorrect 
straightforward correct representation union kk tuples tuple element class set difference taken element set empty th tuple dropped union cartesian product expansion empty set 
tuples union identical position merged single tuple union element class sets 
optimizations important practice 
example consider class hierarchy multi methods syntax indicating formal argument multi method specialized class class class class clos cecil method overriding rules partial order constructed methods applies tuples constructed methods formula third tuple method applies union drops tuple elements empty class set 
unfortunately series difference operations occurs computing applies tuple method subtracting applies tuples overriding methods representation tends 

program optimization object oriented languages chambers grow size exponentially number differences taken 
example third method added existing class hierarchy overrides method 
applies tuple method curb exponential growth problem developed help william pugh efficient way represent difference overlapping tuples class sets intersection elements th tuple union avoid duplication element tuples union 
result element sets tuples smaller tend drop series tuple difference operations 
multi method example applies tuple method reduces final guard exponential growth impose limit number class set terms resulting tuple representation narrowing subtraction method set 
rarely resort final ad hoc measure compiling line cecil program applies tuple message dispatched argument positions crossed implementation threshold terms 
intersection representation crucial conserving space simpler representation described applies sets exceeded term threshold 
incremental programming changes class hierarchy analysis kind interprocedural analysis conflict incremental compilation compiler generates code assumptions structure program class inheritance hierarchy method definitions assumptions change class hierarchy altered method added removed 
simple approach overcoming obstacle perform class hierarchy analysis dependent optimizations program development ceases 
final batch optimizing compilation applied frequently executed software just prior shipping users final performance boost 
fortunately class hierarchy analysis applied active program development compiler maintains intermodule dependency information able selectively recompile parts program invalidated change class hierarchy set methods 
vortex compiler includes framework maintaining intermodule dependency information 
subsection serves overview dependency mechanism detailed description available chambers 
dependency framework intermodule dependencies represented directed acyclic graph structure 
nodes graph represent information including pieces program source information resulting various interprocedural analyses class hierarchy analysis edge program optimization object oriented languages chambers node indicates information represented target node derived depends information represented source node 
depending number incoming outgoing edges classify nodes categories source nodes internal nodes target nodes source nodes outgoing dependency edges 
represent information source modules comprising program source code procedures class inheritance hierarchy 
target nodes incoming dependency edges 
represent information product compilation compiled files 
internal nodes incoming outgoing edges 
represent information derived earlier information derivation information 
dependency graph constructed incrementally compilation 
portion compilation process uses piece information change compiler adds edge dependency graph node representing information node representing client information 
changes source program compiler computes source dependency nodes affected propagates invalidations downstream nodes 
invalidates information including compiled code modules depended changed source information 
illustrate dependency framework vortex static class analysis queries compile time method lookup cache attempt determine outcome message lookups statically cache indexed message name tuple argument class sets returns set methods called message 
compute entry method lookup cache compiler tests tuples methods matching name turn examining bit set representation set classes represented cone class set computed underlying class inheritance graph 
support selective recompilation optimized code dependency graph nodes introduced model information derived source code cone bit set method set applies tuples lookup cache entry compiled code dependency node represents bit set representation set subclasses class product class hierarchy analysis dependency node represents set methods particular name product class hierarchy analysis third dependency node represents applies tuples methods derived previous pieces information 
program optimization object oriented languages chambers fourth dependency node guards entry compile time method lookup cache computing set methods applies tuples 
set subclasses class changed set methods particular name argument count changed corresponding source dependency nodes invalidated 
causes downstream dependency nodes invalidated recursively eventually leading appropriate compiled code invalidated subsequently recompiled 
support greater selectivity avoid unnecessarily invalidating compiled code internal nodes dependency framework filtering nodes 
invalidated filtering node check information represents really changed information represents changed filtering node invalidate successor dependency nodes 
compile time method lookup cache entries guarded filtering nodes 
part inheritance graph changed new method added downstream method lookup results may changed source changes affect potentially dependent method lookup cache entries 
method lookup invalidated invalidating downstream nodes method lookup outcome unaffected particular source change unnecessary recompilations avoided 
empirical evaluation trace month worth actual program development indicates dependency graph approach reduces amount recompilation required incremental compiles factor coarser grained style header file scheme presence class hierarchy analysis factor self compiler previous state art fine grained dependency mechanism details self mechanism published chambers ungar 
course recompilation occurs presence class hierarchy analysis occur traces number files recompiled programming change number files directly modified changes 
important concern current implementation filtering nodes may need checked kinds programming changes compiled files invalidated fair amount compilation time expended checking caches 
size dependency graph half large executable program compiled acceptable program development environment coarser grained dependency graphs devised save space cost reduced selectivity 
separate compilation class hierarchy analysis effective situations compiler access source code entire program inheritance hierarchy examined locations method definitions determined having access source code provides compiler option inlining routine message send routine statically bound 
today integrated programming environments increasingly program available analysis situations having source code entire program unrealizable 
particular library may developed separately client applications library developer may wish share source code library clients 
example commercial class libraries provide header files compiled files provide complete source code library 
fortunately having full source code access requirement class hierarchy analysis long compiler knowledge class hierarchy methods defined hierarchy implementations class hierarchy analysis applied information usually available program optimization object oriented languages chambers header files provided library 
compiling client application compiler perform class hierarchy analysis application including library statically bind calls client application 
source code methods library unavailable statically bound calls methods simply won able inlined 
static binding provides significant performance improvements particularly modern processors dynamically dispatched message send implementations stall hardware pipeline 
furthermore optimizing linkers able optimize static calls inlining target routine machine code link time fernandez resulting code optimized done compiler 
approach optimize library code enclosing application losing benefits class hierarchy analysis 
get full benefits class hierarchy analysis supporting separate development libraries protection proprietary source code library delivered binary code intermediate code 
intermediate code compiler optimize library specific way extended application eliminating unneeded generality library code 
long sufficiently difficult recover library source code intermediate code source code remain protected 
approach compiling intermediate code binary code taken fernandez fernandez support link time optimization separate compilation libraries 
compilation may separate static reasoning typechecking verification done separately 
believe strongly ability reason modules isolation prospective clients vice versa 
program analysis compiler aid generating high quality code affect localized program view humans static reasoning 
annotations versus class hierarchy analysis object oriented languages allow programmer provide annotations give benefits class hierarchy analysis 
programmer declare method virtual methods default non virtual 
method declared virtual compiler infer subclass override method enabling implement invocations method direct procedure calls 
approach suffers weaknesses relative class hierarchy analysis programmer explicit decisions methods need virtual making programming process difficult 
developing reusable framework framework designer decisions operations clients framework 
decisions framework designer may match needs client program particular written highly extensible framework provide flexibility goes unused particular application incurring unnecessary run time performance cost 
contrast class hierarchy analysis automatic adapts particular framework client combination optimized 
virtual non virtual annotations embedded source program 
extensions class hierarchy require non virtual function overloaded dynamically dispatched source program modified 
particularly difficult presence non virtual functions overridden dynamic binding performed static type receiver determines version non virtual method invoke dynamic class 
program optimization object oriented languages chambers separately developed frameworks clients may able change 
class hierarchy analysis automatic mechanism requires source level modifications 
function may need virtual multiple implementations need selected dynamically particular subtree inheritance graph implementation applies 
hierarchy previously depicted method declared virtual implementations version called subclasses 
virtual consequently implemented dynamically bound message class hierarchy analysis identify virtual function reverts non virtual single implementation particular class subtree enabling better optimization 
particular case message sent receiver method defined leaf class target implementation implemented direct procedure call regardless target method declared virtual 
benchmark programs discussed section slightly half message sends statically bound class hierarchy analysis non virtual single definition routine 
similar vein trellis schaffert schaffert allows class declared subtypes annotation dylan allows class sealed indicating subclasses statically visible compilation unit java provides general mechanism allowing classes methods declared final gosling indicating class method won subclassed overridden final method override non final method overcoming limitation non virtual functions described third bullet 
class hierarchy analysis automatically determines better information approaches adapts actual usage class library particular program 
exhaustive class testing class hierarchy analysis may able narrow set potentially invoked methods particular call site singleton set able narrow set candidate methods small set potentially invocable methods 
histogram shows distribution number potentially invoked methods identified class hierarchy analysis message send sites analyzed compilation line cecil program 
purposes histogram cecil dynamically typed possibility message understood error treated additional candidate method 
number candidate methods static call site histogram shows static call sites single candidate method call sites candidate methods 
section explore possibility program optimization object oriented languages chambers inserting explicit tests partition potential classes call site various methods invoked 
exhaustive class testing produces code message send converted statically bound calls providing main benefits 
paths statically bound single routine depending dynamic dispatches implemented tests inserted effect faster full dynamic dispatch 
second statically bound calls inlined downstream benefits knowing precise information result message send 
section section consider mechanisms supporting class tests section describes algorithm relies mechanisms insert exhaustive tests statically bind send 
single class tests object oriented language implementations able compute unique identifier class object message sent object able determine method invoked runtime class object 
example virtual function table pointer method suite pointer modula map identifier self cecil serve purpose uniquely identifying object class 
class identifier test see object member particular class typically implemented instructions modern machines comparison object class identifier compile time constant representing class 
low cost tests feasible insert tests partition possible classes receiver message send different sets invoke different methods 
example consider class hierarchy code fragment 
class hierarchy analysis able narrow possible methods invoked class class method class method class method example class hierarchy code class tests send obj candidate methods method method method information insufficient statically bind call site single method 
insertion explicit tests call site transformed different cases invokes single method statically bound 
effect compiler translates message send equivalent sequences inline code similar typecase statement modula nelson java gosling 
possible sequence tests shown 
unfortunately aspects individual class tests limit general utility exhaustive class testing mechanism testing large hierarchies impractical 
second problem limiting cases exhaustive class testing applied testing singleton classes impractical large number classes invoke method terms code space terms execution speed 
example class having just single subclass different subclasses exhaustive class testing performed impractical require tests causing large blowup compiled code space assuming compiler obj obj program optimization object oriented languages chambers information classes probably slow program executing unsuccessful tests reaching successful test 
increased sensitivity programming changes 
exhaustive class testing singleton class tests specific classes increases possibility source changes require recompilation generated code message send 
particular adding new subclasses normally affect set candidate methods impacts correctness code possible subclasses exhaustively enumerated tests 
example new subclass defined inherits class exhaustive class testing done longer correct call site need recompiled 
subsection addresses drawbacks implementation mechanism permits efficient testing subclassing relationships run time 
cone tests obj obj language implementation able provide means quickly testing subclassing relationships drawbacks discussed section mitigated exhaustive class testing practically applied larger fraction call sites 
example compiler able generate tests form obj class id class 
tests termed cone tests test particular object class lies cone classes inheriting particular class 
way test implemented depends large part language supports multiple inheritance 
languages support single inheritance modula nelson implementation subclass test take advantage fact inheritance graph tree dag 
trees possible assign node pair numbers node tree property holds ancestor iff static binding exhaustive tests simple algorithm assign numbers class traverse class hierarchy tree assigning values preorder walk numbers postorder manner 
class hierarchy assigned numbers subclass test form implemented sequence loads extract class identifier plus pair comparisons subclass test 
approach inspired dec src modula compiler implements user code containing typecase statements similar manner src 
obj id obj class id id id obj id obj obj program optimization object oriented languages chambers languages support multiple inheritance possible consistently assign values satisfy property node may multiple parents 
support efficient subclass testing presence multiple inheritance vortex compiler computes boolean matrix subclass relations number classes program 
class assigned unique number th entry matrix indicates class number subclass class number test implemented efficiently storing pointer class identifier structure row matrix 
class top cone testing compile time constant column number matrix class identifier known statically 
relationship matrix represented bit matrix code test inheritance relationship 
id obj class id id class number compile time constant class number compile time constant compile time constant 
code case obj inherits obj inherit 
obj implementation multiple inheritance encoding inheritance relationships manner allows relationship tested instruction sequence operations followed anand cmp modern processors instruction level parallelism instructions instruction dependent result predecessor 
encoding matrix single bit entry approach consumes bits space 
example program classes requires bits bytes represent matrix row represented bit vector 
programs large number classes tend large amount code data relative increase memory requirements substantial 
alternative encodings relationship possible representing time space tradeoffs kaci provide useful overview efficient lattice operations discusses alternatives ak 
table presents summary pros cons single class tests cone tests 
table class testing alternatives kind test instruction cost cons singleton class test load alu branch tests single class cone test single inheritance cone test multiple inheritance loads alu branches applicable single inheritance loads alu branch space subclass relationship matrix requires space program optimization object oriented languages chambers exhaustive class testing algorithm desire insert exhaustive tests garner performance improvements static binding inlining balanced desire increase code space unreasonably 
section describes set heuristics attempt balance concerns deciding insert exhaustive tests algorithm inserting exhaustive tests order allows cone test described section 
input exhaustive class testing decision process set candidate methods invoked call site results class hierarchy analysis 
order consider cases improve performance significantly increasing code space compile time heuristics require conditions true inserting exhaustive tests small number candidate methods 
order temper code space increase small number candidate methods 
environment limit fewer methods 
candidates 
largest performance improvement comes calls methods inlined optimized context call site downstream benefits 
current heuristics consider exhaustive class testing candidate methods 
decision insert exhaustive tests problem choosing order insert tests 
simple algorithm generate tests works way method partial order defined section repeatedly removing bottom specific methods partial order generating exhaustive tests method partial order empty 
algorithm shown 
set candidate methods call site info tuple static class information known arguments call site specializers tuple sets classes inherit method overriding method exhaustively test info po build partial order po empty choose bottoms po remove po foreach dispatched argument position candidate methods info covers specializers insert test ensure class arg specializers path successful tests known invoked insert statically bound call inlined version appropriate unsuccessful test path know classes invoke remain info info specializers algorithm perform exhaustive class testing program optimization object oriented languages chambers algorithm designed effective cone tests working upwards bottoms partial order 
methods bottom partial order tested cone tests tested removed partial order 
removal potentially converts methods interior nodes partial order bottoms partial order turn tested cone tests 
desirable test methods interior nodes partial order jagged nature applies sets overridden methods implies tested cone tests ruling methods lower partial order 
practice performance improvements possible testing interior method limited consider applying exhaustive class testing number candidate methods small 
additional static analyses value analysis presence heavy inlining intermediate representation procedures simplex copy instructions introduced copy actuals formals entry callee similarly result exit callee 
copy statements lead situation multiple variable names hold run time value program point 
presence intermediate language instructions modify information associated variable run time class test instruction narrows static class information associated argument variable downstream paths information associated copies may updated accordingly 
ensure information associated name propagated equivalent names vortex compiler follows self compiler chambers introducing value intermediate objects 
dataflow analysis defined variable name mapped value object represents possible run time values stored variable run time 
kinds values supported name description id unknown value known id represents values incoming arguments results non inlined calls contents unknown instance variables array elements merges different values new created represent union manner similar functions static single assignment form cytron 
value constant value op value result unary operator constant folded op value value result binary operator constant folded multiple variable names map value object 
particular copy statement simply updates left hand side variable map value right hand side variable 
dataflow information associated values variables 
vortex includes static class information available expressions common subexpression elimination 
constant propagation copy propagation easy express replacing variable canonical value variable name value associated name 
program optimization object oriented languages chambers possible get effect similar vortex value analysis performing copy propagation analysis particularly converting static single assignment form cytron 
vortex fairly sweeping changes control flow graph part optimizations inlining splitting described section introducing new copy statements duplicating maintaining static single assignment properties propagating new copies expensive unwieldy 
explicit variable value mapping computed parallel dataflow information fairly easily 
instance variable optimizations heavily object oriented programs tend allocate objects fairly frequently 
objects initialized separate constructor methods modified allocation caller manipulated short time thrown away 
presence inlining object creation initialization modification reading deallocation may occur single compiled procedure 
vortex includes simple optimizations strive reduce number object instance variable writes reads potentially eliminating intermediate objects altogether 
parallel computing available expressions common subexpression elimination vortex tracks contents memory locations form set base offset contents bindings base offset contents values 
base offset addresses base offset components known 
derived pointers allowed intermediate language base offset address known different base offset components known different derived pointers allowed conservative rule 
analyzing store instruction form base offset contents operands instruction map values base offset contents memory map consulted see exists binding form base offset contents 
contents contents compared 
known store instruction redundant eliminated old binding replaced mapping contents strong update 
definite match new binding base offset contents added map weak update 
bindings may exist memory locations may may representing may alias relationship 
analyzing load instruction form result base offset operands instruction map values base offset memory map consulted see exists binding form base offset contents binding memory location 
load redundant replaced result contents contents variable holding contents program point necessary mapping values distinguished representative variables supported implement copy propagation 
performing redundant load elimination parallel static class analysis class information known value stored instance variable recovered subsequently loaded instance variable 
addition identifying redundant load store instructions vortex identifies store dead contents read 
dead stores arise inlined object constructor initializes instance variables subsequently reassigned appropriate values caller 
manner similar dead assignment elimination vortex performs reverse dataflow analysis tracking memory locations live 
return procedure memory locations considered live 
refined 
store instruction target memory location dead program optimization object oriented languages chambers 
overwritten 
load target memory location considered live 
calls memory locations considered live 
store dead point store target memory location known dead 
dead stores eliminated 
objects allocated procedure escape outside world passed parameter call assigned escaped object instance variable stored global variable returned procedure 
local objects aggressive dead store identification rule 
return procedure instance variables local objects considered dead alive calls affect state instance variables local objects 
store base pointer local object dead store memory location known loads memory locations may 
redundant dead loads stores removed remaining object may allocation 
case object dead 
dead assignment elimination takes care deleting allocation instruction 
profile guided optimizations static analyses identify cases possible 
cases possible static analysis provides little benefit 
supplement static analysis dynamic profile data predict possible cases common allowing compiler try optimize common case 
vortex exploits different kinds dynamic profile data improve purely static analysis vortex uses dynamic execution frequency data assist making inlining decisions scale optimization infrequently executed routines 
vortex uses dynamic receiver class distribution data gathered messages guide receiver class prediction optimization run time class tests inserted send handle commonly occurring receiver classes 
vortex uses dynamic receiver class distributions guide selectively producing specialized versions methods commonly occurring receiver argument classes 
point similar compilers profile data chang 
rest section describes points specific object oriented languages 
subsection discusses granularity receiver class distribution data 
subsection describes receiver class prediction 
subsection discusses statistical properties profile data peakedness stability important profiles useful accurate predictors execution behavior 
subsection concludes description gather profile data efficiently 
receiver class distributions key new kind profile information available object oriented languages execution frequency histogram classes receiver message 
receiver class distributions indicate classes common message indicate classes dominate distribution fairly flat 
system multi methods element distribution tuple argument classes number specialized arguments message simplify terms term receiver class refer single class language tuples multiply dispatched language 
program optimization object oriented languages chambers diagrams illustrate sample receiver class distributions stack true rectangle circle pop false triangle square ellipse area execution frequency message single receiver class stack practice 
message receiver quarters time receiver class information supports kind branch prediction 
message sent receiver classes instances far common 
context receiver class distributions receiver class distribution associated set messages 
size set reflects trade precision information small sets generality information large sets 
extreme distribution associated messages particular name producing message summary distribution 
call sites sending particular message similar distributions single message summary distribution adequate predictor 
case different call sites particular message different distributions 
precise approach associate receiver class distributions particular call site producing call site specific distributions preserve variations call sites avoid smearing different profiles 
possible exploit context associating receiver class distribution particular stack calling methods enclosing call site height call chain specific distributions avoid blending distributions different clients method shared polymorphic library routines differently different parts program 
general probably expensive gather call chain specific distributions arbitrary presence inlining call chain height number levels inlined callers gathered cost call site specific distribution 
unify different degrees context profile information ccp call chain profile model grove patterned shivers cfa family control flow analyses scheme shivers shivers 
ccp receiver class distribution associated message sent specific call sites procedures dynamically enclose call 
ccp distribution associated message sent leading message summary distribution 
ccp distribution specific particular call site particular procedure producing call site specific distribution 
higher values reflect additional context chain enclosing procedures 
ccp refer distributions maximum amount inlined call chain context available stand different different call sites 
framework model context associated kinds information calls execution frequency call different contexts 
amount context increases precision distributions increases applicability distributions decreases fewer call sites program compiled able receiver class distribution increases 
information context widely particular message program optimization object oriented languages chambers fetch 
pair pair includes key summary ccp distributions predict behavior call sites profiled 
fortunately relatively straightforward combine multiple high context distributions calculate corresponding lower context distribution 
consequently vortex compiler maintains receiver class distributions greatest context available summarizes distributions necessary construct distributions call sites available context 
representing summarizing receiver class distributions 
call chain representation profile may different distributions associated message different partially overlapping call chains varying lengths 
internally represent profile information message tree node represents particular call chain length common prefixes call chains factored 
node may may receiver class distribution associated leaves information 
example shows receiver class distributions message shaded nodes distribution information 
numbers arcs indicate call site enclosing procedure 
separate call site specific distributions recorded distinct sends pair method distribution recorded send fetch method shared table data structures separate distribution maintained send method inlined key method inlined store var client method 
dynamic occurrence message quite different precise receiver class distribution general distribution 
compilation extract distribution particular message send compiler searches message prediction tree identifying longest call chain prefix common call site tree 
node distribution information compiler uses directly assuming accurate predictor call sites chain 
node profile data successor nodes nodes indexed longer call chains data summary distribution node calculated summing counts class successor distributions 
example call site sending message compiled profile data call site call chain share node profile database call tree 
node profile data successor nodes aggregated summary distribution cached node 
fashion global message summaries calculated demand store var 
program optimization object oriented languages chambers specific distribution information 
similarly summaries finer granularities calculated needed 
receiver class prediction static class analysis unable uniquely determine target method particular message compiler try optimize message expected receiver classes 
receiver class frequency distribution call site compiler elect insert series class tests common receiver class es test branches success statically bound inlined version message 
dynamically dispatched version message remains handle situation tests succeeds run time 
example control flow graph fragment shown tests common receiver classes call site inserted send area length width predicted classes speed long benefits avoiding dynamic dispatch optimizing callee context caller greater run time cost class test 
tested classes sufficiently common benefits speeding tested cases outweigh slowdowns due failed class tests incurred unpredicted cases 
static class information complements receiver class distribution information 
static class information provides upper bound set possible classes message receiver receiver class distributions provide kind lower bound indicating set classes expected 
sources information combination filtering set predicted classes include deemed possible static analysis 
sources receiver class distributions class rectangle 
radius pi earlier compilers dynamically typed object oriented languages smalltalk deutsch schiffman self chambers incorporated hard wired table giving expected receiver classes number commonly occurring message names 
example smalltalk expected sent smallint instances iffalse instances 
effect hard wired table provided ccp message summary receiver class distributions small set basic messages 
class circle 
send area control flow graph insertion class prediction tests program optimization object oriented languages chambers compilers dynamically typed languages scheme incorporate similar optimizations speed performance generic arithmetic 
receiver class distributions derived dynamic profile information greatly improve hard wired receiver class distributions 
accurately reflect actual program behavior estimates built compiler program written 
second messages program distribution information just select 
important encouraging programmers define abstractions messages programmers know built operations case smalltalk write lower level code primitive fast operations defining higher level slower abstractions natural 
third distributions derived profiles exploit increased levels context provided call site specific ccp call chain specific ccp monitoring receiver classes precise simple message summary ccp distributions 
example program operation apply smallint objects floating point intensive part application ccp distributions flag messages arguments 
vortex compiler supports hard wired profile derived distributions 
start standard file read seeds receiver class distributions standard messages 
distributions profile derived data available 
profile derived distributions gathered read vortex compiler replacing earlier default distributions 
investigated combine multiple profiles single profile useful idea explore 
vortex assumes profiles gathered line separate training run application program compiled statically previously gathered profiles 
approach works profiles earlier runs predictors behavior executions program 
experience profile guided receiver class distributions reasonably stable program runs discussed section may true programs 
latest self compiler lzle ungar avoids issue exploiting dynamic compilation system gathers receiver class distribution information program runs system dynamically procedures class distributions gathered far particular program execution 
approach eliminates need separate line training run potential producing programs different executions substantially different profiles 
incur costs associated dynamic compilation including extra run time overhead compilation extra runtime memory overhead compiler internal data structures representation program dynamically compiled inability easily share dynamically compiled code multiple users extra run time costs gathering receiver class distributions program executions 
splitting receiver class prediction hard wired profile guided introduce class test branches program 
variable sent messages sequence sent message loop class tests seen redundant 
avoid redundant tests control flow graph method compiled modified splitting path merge occurrence class test occurrence test illustrated chambers ungar 
vortex performs splitting lazy fashion 
forward static class analysis compiler tracks variables class sets diluted merges set possible classes variable program optimization object oriented languages chambers receiver class prediction splitting area length width bound box length width class rectangle 
radius pi class rectangle 
class circle 
class circle 
center radius call new rect class rectangle 
radius pi splitting class circle 
center radius call new rect larger merge predecessors 
point class test encountered inserted part receiver class prediction compiler checks tested variable type diluted earlier merge 
compiler scans back control flow send area send bound box send area send bound box control flow graph splitting eliminate redundant tests program optimization object oriented languages chambers graph identify paths back test merge predecessors statically resolve test accumulated cost terms compiled code space potential splitting 
splitting performed paths split resolve class test statically cost split fixed threshold 
alternative approach implementing splitting apply reverse dataflow analysis identify class tests propagating back class tests merges resolve 
approach similar taken mueller whalley avoid conditional branches mueller whalley 
current vortex compiler support splitting past loop entry exit node simplify analysis 
possible useful split paths loops potentially splitting copies loops optimized particular classes early self compilers implemented optimization chambers ungar 
loop splitting effect peeling iteration loop hoist invariant class tests loop shown 
loop splitting loop splitting class rectangle 
splitting general loop splitting particular increase compiled code space substantially self compilers exploited dynamic compilation deferring compilation paths downstream uncommon class rectangle 
loop splitting create multiple loop bodies program optimization object oriented languages chambers branch outcomes chambers ungar 
example operand message expected integer virtually time run time class test compiled program test failed branch leads stub 
taken run time stub invoke compiler compile uncommon path 
vortex static compiler exploit lazy compilation uncommon branches 
qualities profiles profile guided receiver class prediction opportunity improve results static analysis receiver class distributions strongly peaked small number receiver classes dominate execution worth predicting 
addition line profiling effective profiles program execution special training execution predictive behavior executions profiles stable program inputs 
interactive development environment amortize effort gather profile multiple versions program development profile version program predict behavior versions profiles stable program versions 
assess degree profile derived receiver class distributions peaked stable gathered profiles reasonably large cecil programs deemed written fairly heavily object oriented style language program size lines inputs cecil self compiler self compiler doc editor graphical editor trace driven memory subsystem simulator teaching compiler undergraduate course global instruction scheduler mips vortex compiler library library applications compiled standard intraprocedural optimizations 
programs version optimization level 
interested call sites potential candidates profile guided class prediction instrumented virtual function calls 
measure class distributions non virtual member functions call sites statically bound consequently need class prediction 
cecil programs compiled hard wired class prediction common messages intraprocedural static class analysis splitting inlining standard intraprocedural optimizations 
default level optimization chosen small self benchmarks cecil compiler written self small self benchmarks cecil compiler written self typing page text 
randomly cutting pasting existing page document 
drawing lots rectangles 
exercising possible shapes text 
memory traces execution doduc programs small programs library library mips assembly files towers hanoi benchmark compiler test suite optimization program optimization object oriented languages chambers dynamic sends degree polymorphism call site degree polymorphism call site receiver class polymorphism compensate pure object oriented model user defined control structures cecil eliminating dynamic dispatches due simple arithmetic operations control structures languages selection built data types control structures 
subsections discuss peakedness stability inputs versions receiver class distributions derived profiles benchmarks 
peakedness language computed call site specific ccp class distributions merged call sites exhibited degree polymorphism number distinct receiver classes run time 
results shown 
height bar histogram indicates dynamic percentage sends virtual function calls benchmarks degree polymorphism 
bar histogram reporting execution frequencies sends degree polymorphism vertically divided parts showing relative frequency common common receiver 
bottom shaded portions bars report frequency messages sent common receiver class call site 
sends polymorphism greater collected bin 
graphs show aggregate results benchmarks particular language benchmark program weighted equally 
graphs drawn program isolation similar shapes 
languages common receiver class call site receives majority messages sent call site messages cecil messages sent common receiver class 
indicates predicting uniformly receiver class call site lead success rate 
dynamic dispatches occurred call sites single receiver class cecil messages sent call sites single receiver class 
calder grunwald studied characteristics class distributions programs messages sent common receiver class call sites sent single receiver class calder grunwald 
programs larger judging greater degree polymorphism programmed object oriented style 
programs large percentage virtual function call sites single receiver class 
dynamic sends cecil program optimization object oriented languages chambers stability inputs assess cross input stability class distributions compared profiles cecil programs run different input sets 
attempted inputs different possible worst case scenario cross input stability receiver class distributions 
results interactive programs doc stable measured applications 
ccp ccp stability programs profiling technology support gathering ccp distributions 
stability results cecil applications vortex compiler mips global instruction scheduler 
programs remainder programs batch oriented applications similar cross input stability characteristics 
metrics evaluate stability receiver class distributions 
metric difference normalized distributions indicator high low stability particularly accurate metric assessing distributions somewhat similar 
advantage metric allows comparison class distributions independent application distributions 
additional metrics directly related intended application class distributions 
metric classifies distributions long common receiver classes 
common receiver class usually important class prediction expect metric fairly realistic measure stability purpose guiding receiver class prediction 
final stringent metric classifies distributions comprised classes frequency order 
presents cross input stability results average interactive applications norm comparator 
presents corresponding results average batch cecil applications batch programs show similar characteristics batch cecil programs 
receiver class profiles interactive programs fairly stable inputs receiver class profiles cecil applications batch oriented applications stable 
table presents results applying metrics measure cross input stability 
numbers represent dynamic percentage class distributions considered metric question 
table cross input stability summary distributions considered equivalent cecil ccp ccp ccp ccp ccp ccp distributions receiver classes considered points dimensional space norm euclidean distance points 
program optimization object oriented languages chambers dynamic distributions ccp distribution stability change change metric class distributions extremely stable inputs 
stringent metric cecil distributions stable distributions somewhat stable 
believe metric closely models profile guided class prediction uses receiver class distributions data indicates distributions cross input stability support optimization 
stability program versions class distributions stable versions program undergoing rapid development 
stability holds profile older version program reused versions requiring programming change 
determine degree stability exhibited class distributions rcs logs tichy recreate snapshots development vortex compiler written cecil 
measured period began approximately month compiler reached basic stable level functionality compiler optimize snapshots taken twice month period months 
time application doubled size growing lines additional optimization passes functionality added 
support selective recompilation added implications pieces compiler 
period existing pieces compiler substantially modified 
class hierarchies defining internal representation completely redesigned new dynamic distributions interactive stability inputs ccp distribution stability ccp distribution stability change change change change cecil stability inputs ccp distribution stability change change ccp distribution stability change change program optimization object oriented languages chambers month month ccp months months profile age ccp months months profile age months months months months cecil stability versions iterative data flow analysis engine added key data structures method table compile time method lookup cache replaced efficient implementations 
pieces compiler remained largely unchanged period example slight changes scanner parser 
results cross version stability study 
ccp ccp distributions reported older versions system support collecting ccp distributions 
previous section data points represent dynamic frequencies 
compared profile profile plotted lines showing profile degraded predictive quality time 
example data points coordinates month represent comparison profiles taken month apart 
lines graph representing single profile compared profiles 
stringent metric distributions somewhat unstable significant percentage distributions changed week period 
realistic metric class distributions quite stable 
applying metric fewer ccp distributions changed entire month period took months ccp distributions changed 
suggests old profiles quite useful guiding receiver class prediction versions program 
section reports empirical results confirming suggestion 
month month ccp months months profile age ccp months months profile age months months months months program optimization object oriented languages chambers includes gathering similar revision histories applications confirm cecil results 
gathering profile data profiling application get receiver class distributions requires program executable built appropriate instrumentation 
enable long profiling runs profiling typical application usage profiling inexpensive possible may feasible gather profile information 
expense profiling ease different granularities profile data gathered depends large part run time system message dispatching mechanism 
systems including vortex implementations self polymorphic inline caches pics lzle call site specific association lists mapping individual receiver classes target methods dispatching speed association list represented executable code 
gather call site specific profile data counter increments added cases counters pics call sites dumped file program run 
pic annotated inlined call chain context available 
systems rely dispatch tables direct messages 
gather profiles programs gap measure recognizing assembly code generated compiler virtual function call inserting instrumenting code records call site specific distribution information call chain information relatively high run time cost 
switching vortex implementation uses pics gather statistics virtual function calls gathering profile data 
profiling optimized code profiling intrusive wish able profile optimized programs 
presence optimization dynamic dispatches unoptimized program longer performed static analysis able determine message target uniquely receiver class prediction enabled dynamic send avoided due earlier run time class test 
optimized program profiled naively resulting distributions quite misleading optimization include data statically bound calls receiver classes 
techniques support accurate efficient profiling optimized programs 
instrument sends statically bound solely due static analysis 
reason sends able optimized similarly resorting profile guidance need data recorded profile database 
consequently avoid introducing significant cost instrumenting sends 
second sends optimized class prediction instrument successful branches dynamic send combining results single distribution representing original unoptimized send 
preserves high frequency classes distribution accurately example allowing compiler detect common case common 
run time overhead profiling fully optimized cecil benchmarks range 
profiling overhead due fine grained profiling certain commonly occurring messages 
example cecil self smalltalk implemented message false 
message usually optimized receiver class prediction tests true false inserted message catch common cases 
class hierarchy analysis program optimization object oriented languages chambers determines possible implementations case replaced call run time system message understood error handler 
profiling program message instrumented determine occurred providing kind branch prediction information 
counting number class tests accounts run time overhead profiling system languages traditional control data models monitor branch outcomes may observe far lower cost gathering receiver class distributions optimized programs 
iterated optimization profiling program optimized receiver class prediction profiling optimized program lead better profile information profile unoptimized program 
call sites optimized receiver class prediction leading additional inlining produces new call sites longer inlined call chains 
profile optimized program may multiple separate receiver class distributions call site method inlined multiple places profile original unoptimized program blended distribution 
process repeated profiling second program optimized profile optimized program improvements occur profile inlining performed 
section reports impact successive run time performance 
method specialization important strategy object oriented design increasing reusability malleability code factoring similar code data type implementations shared superclasses 
single piece source code applies uniformly family subclasses 
invoke subclass specific behavior shared code includes dynamically dispatched sends receiver formal parameter self 
unfortunately factoring hurt run time performance introducing extra procedure boundaries importantly introducing new dynamically dispatched sends factored code access specialized behavior 
compiler automatically undo effects factoring sacrificing programmer benefits transparently producing specialized versions shared code inheriting subclasses 
variations method specialization developed ranging simple strategies self customization sophisticated strategies vortex profile guided selective method specialization 
rest section discusses techniques 
splitting described section viewed kind intraprocedural specialization 
customization customization simple specialization scheme implementations object oriented languages including self chambers ungar lzle ungar sather lim stolcke trellis kilian specialized version method compiled class inheriting method 
customized version method exact class receiver known enabling compiler statically bind messages sent self 
sends self tend fairly common objectoriented programs customization effective increasing execution performance self code runs times faster result customization customization single important optimizations included self compiler chambers 
lea hand simulated customization program optimization object oriented languages chambers matrix class hierarchy showing order magnitude speedup argued inclusion customization implementations lea 
unfortunately customization suffers twin problems specialization done considering costs benefits case case basis occurs multiple specialized versions method identical nearly coalesced single shared compiled method significant impact program performance 
large programs deep inheritance hierarchies methods producing specialized version method potential receiver class leads explosion compiled code 
presence large reusable libraries expect applications subset available classes operations infrequently consequently simple customization practical 
occur simple customization methods specialized arguments receiver 
cases considerable benefits arise specializing method particular argument classes 
hand indiscriminate specialization multiple arguments lead combinatorial explosion explaining previous systems customized receiver argument 
systems employing dynamic compilation self customization done lazily delaying creation specialized version method particular specialized instance needed runtime 
strategy avoids generating code class method combinations systems problems method invoked large number distinct receiver classes program execution method invoked rarely particular receiver classes 
profile guided selective method specialization vortex compiler includes alternative method specialization algorithm exploits class hierarchy information dynamic profile information reduce problems 
specializing exhaustively vortex guided dynamic profile data selectively specialize heavily methods beneficial argument classes original general purpose versions methods retained handle remaining cases 
avoid producing multiple similar specializations reuse existing specializations widest range argument classes vortex uses class hierarchy information identify set argument class combinations safely share particular specialized method 
algorithm driven weighted call graph derived profile data 
node represents method profiled program 
node set call sites call site set outgoing call arcs pointing node representing invoked method multiple outgoing arcs single call site possible dynamically dispatched call sites invoke callee run time 
weight call arc number times traversed profiled execution 
goal algorithm eliminate heavily executed high weight dynamically dispatched call arcs specializing calling method particular classes formal parameters 
providing precise information classes method formals algorithm attempts static information available dynamically dispatched call sites method enable call sites statically bound specialized version 
simplest case specializing method formal provide program optimization object oriented languages chambers better information call site actual occurs formal passed directly actual parameter call call call site pass call site similar notion jump functions grove torczon grove torczon 
algorithm focuses pass call sites term call sites sites easily determined benefit specialization 
sophisticated jump functions possible quickly difficult accurately estimate costs benefits specialization inlining downstream effects taken account 
inlining database described section help 
summary algorithm visits method call graph 
algorithm searches high weight dynamically dispatched pass call arcs method call arcs possible profitable optimize specialization sending method 
class hierarchy program compiled algorithm computes greatest subset classes method formals support static binding call arc creates corresponding specialization method subset classes exists 
represent particular specialization method arguments sets classes 
algorithm completes method associated set tuples class sets representing general purpose version plus number specializations identified profitable algorithm 
identification pass completes second pass produces specialized compiled methods 
regular static class analysis automatically perform desired optimizations formal parameters specialized version annotated class sets specialization tuple 
illustrate algorithm class hierarchy method definitions shown profile derived weighted call graph shown 
class hierarchy consists classes implemented andg implemented andb andm implemented 
give method definitions formals including self explicit 
shaded regions show equivalence classes invoke implementation ofm andm note illustrations views underlying inheritance hierarchy 
detailed pseudocode version algorithm shown 
set operations tuples defined operate pairwise tuple elements 
profile derived weighted call graph accessed helper functions call arcs arc call graph caller arc gives calling method callee arc gives called method callsite arc identifies message send site caller weight arc gives execution count arc example arc labelled caller callee callsite send arg weight 
function gives relationship formal parameters sending method actual arguments call site expressed set bindings formal parameter index actual parameter index pass arc non empty set bindings 
instance foo inm index receiver 
algorithm accesses information class hierarchy function 
meth returns tuple set classes formal argument method meth invoked excluding classes bind overriding methods tuples constructed compile time method lookup described section 
shaded regions program optimization object oriented languages chambers example class hierarchy example weighted call graph visually identify methods 
example methode 
remainder section examines key aspects selective specialization algorithm detail set classes enable specialization call arc computed 
computed function discussed section 
specializations multiple call sites method combined 
handled routine discussed section 
method specialized avoid converting statically bound calls calls 
cascading specializations upwards routine solve problem cases discussed section 
arc important specialize 
algorithm currently uses simple heuristic section discusses tradeoffs involved 
method self arg self arg method self arg self arg self arg callers ofm self arg call arc non call arc dynamically dispatched call site statically bound call site program optimization object oriented languages chambers helper functions caller callee callsite weight give caller callee call site execution count arc msg arg arg arg inm fpos fpos arg method tuple sets classes forf invoked input minimum weight arc arc considered specialization output specializations meth set tuples sets classes method specialized foreach method meth specializations meth meth foreach method meth meth meth foreach arc caller arc meth arc weight arc meth arc arc returns bool return callsite arc caller arc arc arc returns tuple set class return arc callee arc arc returns tuple set class needed caller arc foreach fpos callsite arc needed fpos needed fpos return needed meth foreach specializations meth specializations meth specializations meth foreach arc callee arc meth arc spec arc callsite arc caller arc arc weight arc arc specializations caller arc caller arc selective specialization algorithm program optimization object oriented languages chambers run time right specialized version chosen 
discussed section 
interaction specialization algorithm class nested functions 
section considers question 
section concludes discussion specialization adapted system dynamic compilation 
computing specializations call sites algorithm visits high weight pass arc leaving method 
arc determines general class set tuple pass formals allow static binding call arc callee method 
information computed function maps callee routine back caller formals mapping contained call site specialization possible caller returned unchanged 
example consider arc call graph 
arc caller callee tuple mapping call site 
means specialized version possible classes restricted information sufficient statically bind message send specialized version 
tuple added set specializations form specializations 
combining specializations distinct call sites different call arcs single method may generate different class set tuples specialization 
different tuples need combined specialization tuples method 
deciding combine specializations different call sites method difficult problem 
ideally combined method specialization cover combinations method arguments common lead best specialization impossible general examine arc counts call graph determine argument tuples enclosing method called 
example determine class times times class times times tell combinations argument classes appeared 
want sure produce specializations help high benefit call arcs algorithm covers bases producing method specializations plausible combinations arc specializations 
function function new arc specialization tuple forms combination new tuple previously computed specialization tuples including initial unspecialized tuple adds new tuples set specializations method 
example method specialization class set tuples adding new arc specialization tuple leads method specialization tuples method assuming intersections empty tuples containing empty class sets dropped 
example figures versions produced including original unspecialized version assuming outgoing call arcs threshold 
program optimization object oriented languages chambers approach principle produce number specializations particular method exponential number call arcs emanating method observed behavior practice 
benchmarks described section observed average specializations method receiving specializations maximum specializations method 
suspect practice observe exponential blow call sites high weight call arcs methods tend small number formal arguments highly polymorphic 
exponential blow problem profile information extended maintain set tuples classes actual parameters passed method profiling run 
set potential specializations set actual tuples encountered profiling run see specializations invoked high frequency 
course expensive gather profiles argument tuples gather simple call arc count information 
cascading specializations method specialized callers able statically bind method 
specialized versions method introduced possible static information call site sufficient select appropriate specialization 
case arc tom example static information arguments descendents class sufficient statically bind single version multiple versions ofm produced 
case choices statically bound calls left unchanged having call general purpose version routine statically bound call replaced dynamically bound call selects appropriate specialization run time 
right choice depends amount optimization garnered specialization callee relative increased cost dynamically dispatching call specialized method 
cases conversion statically bound calls dynamically dispatched sends avoided recursively specializing calling routine match specialized callee method 
purpose function 
specialization method attempts specialize statically bound pass callers method provide caller sufficient information statically bind specialized version method 
checks sure call arc statically bound respect pass arguments high weight call arc dynamically bound regular specialization attempt optimize arc example specializing method tuple arc method identified target cascaded specialization callers 
calling arc passes test computes class set tuple caller specialized order support static binding call arc specialized version 
example computed class set tuple form algorithm 
algorithm determines call site call specialized version specialization caller necessary enable static binding algorithm recursively specializes caller method specialization hasn created 
recursive specialization set ripples specialization rising upwards call graph statically bound pass high weight arcs 
recursive cycles statically bound pass arcs need special treatment produce specialized program optimization object oriented languages chambers collection mutually recursive methods check see desired specialization created 
recursive specialization stops callers dynamically dispatched pass arcs low weight 
effect recursive specialization effect hoisting dynamic dispatches high weight parts call graph lower weight places higher call graph places combined previously existing dynamic dispatches 
improved cost benefit analysis algorithm currently uses simple heuristic deciding specialize weight arc larger parameter arc considered specialization 
implementation invocations 
shortcomings simple approach 
code space increase incurred specializing considered 
intelligent heuristic compute set specializations necessary statically bind particular arc factor information decision making process 
second treats dynamic dispatches equally beneficial specialization 
due indirect effects optimizations inlining benefits statically binding message sends higher 
sophisticated heuristic estimate performance benefit static binding account post inlining optimizations 
third heuristic global view consumption space specialization 
alternatively algorithm provided fixed space budget visit arcs decreasing order weight specializing space budget consumed 
results section show current simple heuristic incurs low space cost specialization 
current algorithm specializing aggressively 
invoking appropriate version specialized method run time message lookup needs select appropriate specialized version method 
languages smalltalk existing message dispatch mechanisms fine selecting methods specialized receiver argument 
allowing specialization arguments receiver create multi methods methods requiring dispatching multiple argument positions perspective implementation source language allows singly dispatched methods 
runtime system support multi methods extended support 
number efficient strategies multi method lookup devised including trees single dispatch tables kiczales rodriguez compressed multi method dispatch tables chen polymorphic inline caches extended support multiple arguments lzle vortex 
specializing nested methods presence lexically nested class functions message sent formal outermost enclosing method lexically nested function closure accepts arguments 
current implementation considers outermost method specialization principle reason algorithm produce multiple specialized versions nested methods 
run time representation closure contain direct pointer target method code contain address stub routine performed necessary dispatching specialized argument positions 
program optimization object oriented languages chambers applicability dynamic compilation environment selective specialization suitable dynamic compilation environments self static compilation environments vortex 
described section self system initially compiles methods optimization installs counters detect heavily methods 
counter exceeds threshold system portions code optimization adapt code program hot spots 
specialization algorithm system 
unoptimized code keep track target methods call site counts essentially arcs call graph appropriate localized portion call graph constructed necessary specialization decisions recompilation process 
section provides results showing system compiles code lazily approach lead significant reduction code space requirements system employs simple customization 
performance studies previous sections number analyses transformations developed improve performance object oriented applications 
section assesses effectiveness applying applications written cecil dynamically typed purely objectoriented language chambers 
section describes applications performance studies details experimental set 
vortex transforms dynamically dispatched message sends statically bound procedure calls main techniques intraprocedural class analysis class hierarchy analysis exhaustive class testing profile guided receiver class prediction selective specialization 
section focuses impact techniques isolation combination 
section presents series supporting experiments address related issues 
methodology evaluate performance techniques discussed implemented context vortex compiler selected benchmark programs compare techniques ranging size lines 
benchmark programs described table metrics inheritance method overriding programs 
metrics designed give feel programming style employed programs 
particular note deep broad inheritance hierarchies large generic functions larger programs 
programs compiled vortex code compiled gcc produce executable 
evaluate techniques data program properties number messages sent metrics specific particular implementation execution time compiled code space 
reported execution times median time runs application unloaded sparcstation mb main memory running sunos release 
exception takes input different inputs gather profile data measure application performance 
compiled code space numbers represent size bytes stripped program executable 
methods name number arguments considered part single generic function 
program optimization object oriented languages chambers program description richards operating system simulation deltablue incremental constraint solver scheduler mips global instruction scheduler typechecker primary results table benchmark programs characteristics lines code section examine effectiveness interactions major techniques vortex eliminate message sends intraprocedural class analysis described section 
class hierarchy analysis described section 
insertion exhaustive tests described section 
profile guided receiver class prediction described section 
selective specialization described section 
classes methods std 
library cecil typechecker std 
library compiler vortex optimizing compiler std 
library vortex implementations class hierarchy analysis profile guided receiver class prediction integrated implementation intraprocedural class analysis 
include intraprocedural class analysis measured configurations 
similarly selective specialization utilizes class hierarchy information consider selective specialization including class hierarchy analysis 
applications compiled vortex compiler configurations unopt high level optimizations message sends 
intra intraprocedural class analysis automatic inlining hard wired class prediction primitive message names extended splitting section partial dead code elimination techniques inherently dependent intraprocedural class analysis self system lzle ungar incorporated profile guided receiver class prediction intraprocedural class analysis statically typed object oriented languages static type message receiver enable class hierarchy analysis additional analysis 
classes immediate parents ii classes immediate children classes distance root hierarchy generic functions consisting methods program optimization object oriented languages chambers closures section value analysis section elimination dead redundant load stores section standard iterative dataflow optimizations common subexpression elimination dead assignment elimination 
cha intra augmented class hierarchy analysis section 
cha exh cha augmented exhaustive class testing call sites small nonsingular number candidate methods section 
intra cha exh spec cha exh augmented selective specialization section 
consider configurations profile guided class prediction section 
table contains data execution speed dynamic numbers dynamically dispatched message sends class tests comprising singleton class cone tests executed compiled code space optimization configurations benchmark programs 
addition raw data table contains values normalized intra profile data configuration program 
tables section include normalized values indicated enclosing parentheses 
program richards deltablue profile data profile data profile data profile data configuration table impact message send optimizations execution time secs message sends executed class tests executed code space bytes unopt intra cha cha exh cha exh spec intra cha cha exh cha exh spec unopt intra cha cha exh cha exh spec intra cha cha exh cha exh spec program optimization object oriented languages chambers program scheduler typechecker compiler profile data profile data profile data profile data profile data profile data configuration table impact message send optimizations execution time secs message sends executed unopt intra cha cha exh cha exh spec intra cha cha exh cha exh spec unopt intra cha cha exh cha exh spec intra cha cha exh cha exh spec unopt intra cha cha exh cha exh spec intra cha cha exh cha exh spec thing notice data impact optimizations exaggerated small benchmarks richards deltablue 
small benchmarks tend potential benefits applying techniques larger realistic programs discussion remainder section focus larger benchmark programs scheduler typechecker compiler 
graphs illustrate average execution time speed average dynamic number dispatches executed larger programs normalized intra configuration 
major jumps performance worth noting 
factor performance improvement highlighted corresponding drop number message class tests executed code space bytes program optimization object oriented languages chambers ratio intra execution speed unopt intra cha exh spec intra cha exh spec profile guided class prediction sends unopt intra 
benefit attributable simple hardwired class prediction eliminate message passing overhead common messages 
purely object oriented languages cecil message sending implement basic operations control structures important initial step efficient implementation optimize messages 
second major performance improvement comes adding class hierarchy analysis top intraprocedural class analysis giving improvement performance reduction number message sends intra 
addition exhaustive class testing improves performance reduces number messages sent nearly 
selective specialization execution frequencies improves performance class hierarchy analysis exhaustive class testing 
impact selective specialization larger past dean developed implemented exhaustive class testing algorithm 
exhaustive class testing small numbers candidate methods selective specialization algorithm optimizing kinds message sends adding specialization top exhaustive class testing provides relatively little performance improvement 
substantial impact profile guided class prediction noticeable trend graph execution speed improvement attributable profile guided class prediction represented darker shaded portions bar 
combined relatively weak static analysis simple intraprocedural class analysis profile guided class prediction provides factor performance improvement reduction number message sends 
compiler applies powerful static analyses performance improvement due profile guided class prediction decreases 
example system applies class hierarchy analysis exhaustive class testing performance improvement due profile data 
powerful interprocedural class analysis techniques narrow performance gap purely static static profile system grove agesen lzle 
profile guided class prediction largest individual impact techniques performance improvement cha exh profile profile indicates ratio intra message sends executed unopt intra cha exh spec intra cha exh spec effects optimizations larger benchmarks profile guided class prediction program optimization object oriented languages chambers static guarantees provided static analyses give performance benefits guaranteed information provided profile guided class prediction 
synergy static techniques class hierarchy analysis exhaustive class testing dynamic techniques profile guided class prediction indicating achieve highest performance compilers apply kinds information 
considering large amount inlining performed result optimizations impact code space surprisingly small 
part message sends implementation require significant amount code inlined code ends smaller code equivalent message send 
benchmarks unopt version largest executable configurations 
profile guided class prediction tended increase code space requirements equivalent system profile data 
compile time impact optimizations significant system 
moving unopt intra increases compile time 
adding class hierarchy analysis exhaustive class testing profile guided class prediction optimizations increases compile time 
additional compile time comes result performing additional inlining subsequent optimizations inlined code performing analyses 
compilation time results scrutinized closely compiler research infrastructure designed primarily ease extension experimentation short compile times 
supporting experiments previous section assessment primary optimization techniques utilized vortex reduce message passing overhead 
section presents series additional experiments focus number interesting secondary questions 
subsequent subsections address issues benchmark applications cecil programs 
efficiency language implementation may substantial impact magnitude expected runtime benefits studied optimizations 
absolute performance cecil compare languages self smalltalk 
section described vortex uses partial dead code elimination delay closures allocation operations absolutely necessary hope removing main control flow paths 
effective technique reducing dynamic number closure allocations impact application performance 
vortex incorporates interrelated analyses uses optimize instance variable accesses detecting eliminating redundant dead loads stores section 
optimizations applicable impact application performance 
receiver class prediction introduce partially redundant class tests multiple messages sent receiver 
splitting described section eliminates redundant class tests duplicating portions control flow graph 
costs benefits transformation 
effectiveness profile guided receiver class prediction highly dependent predictive quality profile derived class distributions drive 
stability peakedness results section suggest directly related degree context associated class distribution 
profiles experiments section iterated profiles large degree associated context 
extent lack context degrade effectiveness profile guided receiver class prediction 
program optimization object oriented languages chambers order line profile guided receiver class prediction practical program development environment able avoid re profiling application program change 
ideally single profile utilized large number programing changes 
profile derived class distributions degrade application evolves 
section reported performance impact selective method specialization 
performance selective specialization compare method customization described section 
experiments base configuration cha exh spec profile guided class prediction configuration highest optimizing configuration 
absolute cecil performance quantify absolute performance vortex compiled cecil programs 
compare vortex implementation cecil optimizing implementations statically typed hybrid object oriented language smalltalk goldberg robson self ungar smith dynamically typed purely object oriented languages 
comparison cecil quantifies performance gap introduced cecil expressive language features 
comparison self interesting self cecil number advanced language features common self system carefully engineered state art implementation outperforms commercial smalltalk systems lzle ungar 
cecil vortex base configuration 
compiler configuration day day development vortex compiler 
smalltalk visualworks commercial smalltalk implementation parcplace systems self self performing type feedback customization intraprocedural class analysis splitting lzle ungar gnu functions unfortunately currently non trivial programs written languages richards 
execution times shown table may indicative relative performance larger applications definitive large applications available languages 
solely small benchmarks misleading relatively table cecil performance relative languages benchmark cecil self richards sec sec sec sec sec sec sec sec smalltalk times elapsed wall clock time times cpu times 
observed difference elapsed time cpu time cecil versions programs 
benchmark input parameters 
minor changes large impact observed execution times 
example cecil inlining heuristics different possibly slightly aggressive self 
call sites inside critical method richards benchmark self chose inline invoked method cecil program optimization object oriented languages chambers 
adding pragma cecil version benchmark forcing just callsite inline expanded left line call cecil execution time dropped seconds cutting performance gap self cecil implementations richards half 
data suggest language implementations divided groups cecil self smalltalk 
appears cecil self roughly equivalent performance cecil self roughly factor slower smalltalk times slower cecil self 
partial dead code elimination closures section described partial dead code elimination adapted push infrequently needed closure allocation operations main control flow path delaying allocation needed 
aggressive optimizing implementations languages cecil self utilize closures heavily optimization may significant closures inline expanded subset control flow paths method obviating need create closure object 
quantify impact optimization application performance comparing base configuration perform optimization 
table shows execution speeds dynamic number closure objects created application optimization 
table impact partial dead code elimination closures base base closure delaying program execution time secs closures created execution time secs closures created richards deltablue scheduler typechecker compiler results show optimization dramatic increase dynamic number closures creations factor small benchmarks factor larger benchmarks increase substantial impact program execution time factor slowdown smaller benchmarks larger benchmarks 
section small benchmarks tend exaggerate impact optimization 
eliminating dead redundant memory operations section series simple optimizations instance variable accesses eliminate redundant dead loads stores instance variables completely eliminate object allocations effectively allocating object instance variables local variables 
quantify impact techniques compare execution times dynamic number instance variable related loads stores dynamic number objects created programs compiled base configuration perform optimizations 
results comparison shown table program optimization object oriented languages chambers program table impact dead redundant memory operation elimination execution time secs base base memory optimizations objects created instance variable loads stores average optimizations able eliminate instance variable operations dead redundant 
elimination memory operations principle cause object creations unnecessary 
practice happen object creations eliminated compiler benchmark object creations removed 
impact execution time optimizations benchmarks negligible compiler typechecker benchmarks 
possible optimizations may greater value 
effectiveness analysis hampered intraprocedural pieces code inlined particular context require extremely conservative assumptions 
suspect powerful interprocedural analysis able prove object creations instance variable loads stores dead redundant 
interprocedural escape analysis able prove object creations outlive enclosing context permit objects allocated stack heap allocated hudak kranz 
splitting splitting described section eliminates potentially redundant class tests duplicating portions control flow graph 
assess costs benefits technique measured execution time dynamic number class tests compiled code size applications compiled base configuration perform splitting 
shown table splitting substantial impact number class tests executed 
splitting programs execute class tests smallest benchmarks performance impact splitting substantial richards deltablue 
performance impact larger benchmarks smaller 
splitting virtually impact code space indicating increases caused duplicating code preserve information roughly offset decreases code space enabled elimination class tests branches 
profile data context effectiveness profile guided receiver class prediction highly dependent profile derived class distributions drive 
discussed section increased context increase predictive ability profile data removing imprecisions introduced polymorphism 
amount context available compiler increased iterating process profiling optimizing application see section 
quantify importance effects compiled applications configurations execution time secs objects created instance variable loads stores richards deltablue scheduler typechecker compiler program optimization object oriented languages chambers program execution time secs table impact splitting base base splitting class tests executed code space static cha exh described section performs intraprocedural class analysis class hierarchy analysis exhaustive class testing forms baseline set experiments 
static ccp static profile data restricted ccp message summary distributions static ccp static profile data restricted ccp call site distributions static static available call chain context profile data derived static version application 
static static available call chain context profile data derived static version application 
static static available call chain context profile data derived static version application 
static static available call chain context profile data derived static version application 
additional context impact program exhibits different behavior different contexts 
smallest benchmarks deltablue richards exhibit interesting behavior regard results indicate degree context profile data unimportant 
larger programs tend exhibit interesting behavior depending amount context profile 
table reports execution speeds dynamic number class tests dynamic dispatches larger benchmarks configurations 
execution time secs class tests executed code space richards deltablue scheduler typechecker compiler program scheduler table impact additional context profile data configuration execution time secs class tests executed message sends executed static static ccp static ccp static static static static program optimization object oriented languages chambers program typechecker compiler degree context profile data significant effect number messages sent execution time 
message level ccp profile data performs worse call site specific ccp profile data 
programs compiled ccp information sent fewer messages ran faster compiled ccp information 
similarly additional context provided longer call chains profile data significant difference number messages sent bottom line performance 
example scheduler benchmark executed fewer message sends ran faster compiled profile information compiled ccp profile data 
improvements due additional context subject law diminishing marginal returns 
iterating compile profile cycle produce profile data reduced number message sends additional little effect execution time 
iteration produce longer call chain contexts reduced number messages sent slightly virtually effect execution time 
interestingly effects iterating compile profile cycle gather additional context information significant system prior exhaustive class testing algorithm grove 
old profile data table impact additional context profile data configuration execution time secs static static ccp static ccp static static static static static static ccp static ccp static static static static measure degree sufficient cross version stability allow old profiles optimize newer versions program ccp distributions profiled dates optimize compiler benchmark program sources date section presents experiments generated dated profiles 
plots execution speeds compiler program optimized intraprocedural class analysis class hierarchy analysis profile data varying ages dated profiles compiler program optimized static optimizations profile data cha 
clearly fairly inaccurate profile information better profile data 
application appears profiling class tests executed message sends executed program optimization object oriented languages chambers execution speed relative cha month months months effectiveness receiver class prediction old profiles weeks sufficient maintain execution speeds enabled completely date profiles 
specialization vs customization way obtain additional static information class arguments method compile multiple versions routine specialized different set classes 
key issue deciding routines specialize argument classes impacts performance code space compile time 
approach called customization chambers ungar compiles different specialized version routine class inherits routine compilers self chambers ungar lzle ungar sather lim stolcke trellis kilian 
customization compilers perform class hierarchy analysis order obtain information class receiver message 
profile guided selective specialization described section alternative approach uses class hierarchy analysis profile data determine additional information useful 
section compare approaches examine effects performance compiled code space 
examined compiler configurations profile guided class prediction intra intra configuration section performs intraprocedural class analysis hardwired class prediction common messages compiles single routine source method 
cust intra configuration plus customization compiles new version method different class inherits method 
cha exh configuration described section performs intraprocedural class analysis class hierarchy analysis exhaustive class testing cha exh spec configuration described section performs intraprocedural class analysis class hierarchy analysis exhaustive class testing selectively specializes routines experiments performed exhaustive class testing version vortex includes exhaustive class testing algorithm capable compiling older version cecil language appears snapshots compiler benchmark 
months months dated profiles cha program optimization object oriented languages chambers profile data static analysis costs benefits specialization 
class hierarchy analysis included selective specialization algorithm requires 
evaluate performance algorithm measured dynamic number dynamic dispatches version programs bottom line execution speed compiled code space 
results shown table 
program richards deltablue scheduler profile profile profile table impact specialization customization configuration execution time message sends executed compiled code space intra cust cha exh cha exh spec intra cust cha exh cha exh spec intra cust cha exh cha exh spec intra cust cha exh cha exh spec intra cust cha exh cha exh spec intra cust cha exh cha exh spec program optimization object oriented languages chambers customization selective specialization significantly decrease number messages sent programs compared intra configuration selective specialization usually performing slightly better terms execution time message sends executed 
trend true profile guided class prediction 
improvements intra configuration come cost 
cost customization paid compiled code space compile time executables programs compiled customization ranged larger compilation times increased roughly factor 
cost higher larger programs classes deeper inheritance hierarchies methods making customization increasingly impractical realistic sized programs 
contrast class hierarchy analysis coupled selective specialization provides better performance customization increases code space intra configuration 
costs approach requiring entire class hierarchy program available compile time precluding separate compilation gathering profile data needed derive weighted call graph 
related self program typechecker compiler profile profile table impact specialization customization configuration execution time intra cust cha exh cha exh spec intra cust cha exh cha exh spec intra cust cha exh cha exh spec intra cust cha exh cha exh spec self self systems pioneered number techniques included vortex compiler self introduced intraprocedural static class analysis splitting customization fine grained recompilation dependencies self introduced profile guided receiver class prediction 
vortex compiler extends self systems class hierarchy analysis exhaustive class testing cone tests powerful profile guided specialization algorithm customization support multi method dispatching message sends executed compiled code space program optimization object oriented languages chambers sophisticated selective recompilation mechanism 
vortex language independent modula java front ends nearing completion writing 
self systems dynamic compilation code compiled invoked run time 
code initially compiled little optimization heavily executed code dynamically recompiled optimization 
dynamic compilation exploited effect ways self systems serves eliminate compilation unused code unused paths procedures enables simple customization practical contexts enables receiver class profile data gathered line application runs recompiling heavily executed procedures optimization 
vortex system traditional line static compilation part applications compiled delivered requiring compiler program representation application run time system part feasible explore expensive static analyses programs interprocedural analyses 
possible combined approach best static line analysis program lead partially compiled programs parts compilation deferred run time information available 
systems combining static analysis dynamic code generation developed consel noel leone lee auslander engler 
static class analysis general approach class analysis sets concrete classes started typed smalltalk system johnson johnson 
subsequent compiling object oriented languages similar framework 
palsberg schwartzbach type system points single classes cones classes inheriting class palsberg schwartzbach 
number researchers investigated interprocedural static class analysis 
key problem call graph interprocedural analysis run depends solution class sets inferred receivers message send sites 
consequently call graph construction phase run parallel call graph compute class sets 
issue cope effectively parametric subtype polymorphism programs amount context sensitive analysis needed avoid smearing distinct class information different calling contexts 
palsberg schwartzbach developed early algorithm characterized solving system constraints palsberg schwartzbach extended algorithm handle polymorphic data structures better treating static occurrence object creation expression producing distinct type 
agesen adapted extended handle self language support better context sensitivity agesen agesen 
plevyak chien developed sophisticated algorithm works polymorphic procedures polymorphic data structures iteratively solving interprocedural analysis problem greater degrees context needed solution improve system drives procedure specialization algorithm context specialization analysis 
demonstrated results small benchmarks nearly run time class tests dispatches removed 
algorithms shown scale programs lines determined simple context insensitive algorithm takes hours analyze larger programs grove 
additionally issues separate selective recompilation incremental update analysis results addressed 
related interprocedural analysis problems arise functional languages program optimization object oriented languages chambers function called computed expression number context insensitive sensitive algorithms developed shivers heintze 
similarly algorithms developed support calls function variables fortran callahan imperative languages ryder weihl landi ryder 
diwan moss mckinley built optimizing modula system program analysis diwan 
system includes techniques similar vortex compiler techniques including intraprocedural static class analysis class hierarchy analysis 
include receiver class prediction selective specialization intraprocedural analysis narrow class sets paths downstream run time class tests 
include form interprocedural class analysis intraprocedural solution construct call graph interprocedural analysis 
unfortunately analyses resolve static call sites benchmarks ignoring possibility null error invocations bottom line speed benchmarks due large part dynamically dispatched calls benchmarks 
aigner lzle implemented prototype system compare class hierarchy analysis profile guided receiver class prediction programs aigner lzle 
compiler combines input files single monolithic file applies transformations input file produces output file compiled regular compiler 
substantially reduce number dynamic dispatches benchmarks achieve modest bottom line speed ups result 
system attempt support separate incremental recompilation relying underlying compiler perform inlining analyses suffer having accurate knowledge code inlining 
alternative performing program optimizations class hierarchy analysis compile time perform optimizations link time 
fernandez investigated link time optimization modula programs convert dynamic dispatches statically bound calls overriding methods defined fernandez 
optimization similar class hierarchy analysis 
advantage performing optimizations link time optimizations operate machine code applied program including libraries source code unavailable 
drawbacks link time optimizations 
conversion message sends statically bound calls happens linker compiler compiler optimization tools brought bear statically bound call site indirect benefits post inlining optimizations compiler important direct benefit eliminating procedure call return sequences 
second care taken prevent linking bottleneck edit compile debug cycle 
example fernandez link time optimizer modula performs code generation machine independent intermediate representation entire program link fernandez acknowledges design penalizes turnaround time small programming changes 
additional link time optimizations increase penalty 
contrast class hierarchy analysis coupled selective invalidation mechanism supports incremental recompilation fast linking compile time optimization call sites source code target methods available 
srivastava developed algorithm prune unreachable procedures programs link time srivastava 
described algorithm prune code optimize dynamic program optimization object oriented languages chambers dispatches relatively simple convert virtual function calls direct procedure calls basic infrastructure perform procedure pruning 
optimizing implementations dynamically typed languages lisp scheme techniques similar static class analysis try eliminate cost run time type checking kranz 
usually systems simple intraprocedural dataflow analyses fixed set possible types derived compiler knowledge type signatures primitive operations language 
sophisticated systems soft typing soft scheme system cartwright fagan wright cartwright support polymorphic interprocedural type inference 
soft typing attempts modified version hindley milner type inference perform type inference scheme inserting run time type checks producing warning messages programmer static inference prove absence run time type errors 
static class analysis dataflow analysis generate flow sensitive type bindings soft scheme system accepts normal type inference constraint assigning variable single type lifetime special case patternmatching 
soft scheme currently requires program order perform type inference support incremental reanalysis 
til compiler ml uses intentional polymorphism transform polymorphic routines overloaded monomorphic specializations indexed run time typecase tarditi previous leroy leroy shao appel shao appel similar goals 
til propagation concrete monomorphic type information place general efficient polymorphic routines static class analysis concrete sets representations propagated 
til introduces place polymorphic routines uses analysis try simplify possible static class analysis introduces explicit lazily needed 
til analysis relies heavily static types declared inferred ml program static class analysis dynamically typed languages static type declarations included static class analysis form cone representation constraints variables 
til specializes polymorphic functions particular monomorphic argument types interprocedural type analysis mechanisms vortex uses separate specialization mechanism 
key benefits til conversion polymorphic code monomorphic code basic datatypes usually represented native unboxed form tag bits header words making basic operations efficient reducing size allocation overhead objects easing interoperability languages 
optimizations useful adapt object oriented context 
til tested relatively small ml programs modules feasible compile away polymorphism applications 
remains seen approach scale programs tens thousands lines 
haskell implementations typically pass run time dictionary data structures implement manipulating values function polymorphic instances particular type class peterson jones 
dictionary similar run time class associated objects object oriented system 
accordingly static class analyses context reduce overhead accessing data structures 
jones reports version haskell applies exhaustive procedure specialization replace single polymorphic function set monomorphic versions calling tuple dictionaries jones 
quite similar flavor til compiler replacement polymorphism program optimization object oriented languages chambers specialized monomorphic versions customization self similar systems 
programs lines exhaustive specialization polymorphic functions reduces code size 
profile guided class prediction smalltalk deutsch schiffman self chambers ungar self chambers compilers utilized hard wired receiver class prediction called type prediction self eliminate overhead due pure object model user defined control structures 
self lzle ungar demonstrated line call site specific profile class prediction called type feedback substantially improve performance self programs investigate effectiveness line profiling demonstrate applicability hybrid languages examine peakedness stability class distributions 
calder grunwald considered ways optimizing dynamically bound calls calder grunwald 
examined characteristics class distributions programs potential polymorphism high distributions seen individual call sites strongly peaked 
results confirm general result programs measured significantly larger appear heavier object oriented programming techniques deep class hierarchies factoring judging greater degree observed polymorphism 
wall wall investigated profiles predict relatively fine grained properties execution frequencies call sites basic blocks global variables 
reported profiles actual runs program better indicators static estimates inaccurate 
investigated predictive power coarser grained kind information receiver class distributions greater stability 
examined stability program versions property considered wall 
agesen lzle compared effectiveness profile guided receiver class prediction interprocedural class analysis suite small medium sized self programs agesen lzle agesen lzle 
techniques appeared roughly comparable performance somewhat appeared synergistic effects combined 
procedure specialization implementations self chambers ungar trellis kilian sather lim stolcke customization provide compiler additional information class receiver argument method allowing message sends customized version method statically bound 
previous takes approach specializing exact class receiver specializing arguments 
trellis compiler merges specializations compilation save code space specializations produced identical optimized code compile time reduced 
approach effective identifies sets receiver classes enable static binding messages uses profile data ignore infrequently executed methods avoiding allows specialization arguments just receiver message preventing arguments 
lea describes language extension support customization argument lea 
lea approach didn address selective specialization particular groups classes 
program optimization object oriented languages chambers cooper hall kennedy general framework identifying creating multiple specialized copies procedure provide additional information solving interprocedural dataflow optimization problems cooper 
approach begins program call graph forward pass call graph propagating cloning vectors represent information available call sites deemed interesting called routine second pass merging cloning vectors lead optimizations 
resulting equivalence classes cloning vectors indicate specializations created 
framework applies forward dataflow analysis problem constant propagation 
differs approach important respects 
assume existence complete call graph prior analysis 
subset real call graph derived dynamic profile information 
important discussed describing interprocedural class analysis precise call graph difficult compute presence extensive dynamically dispatched messages 
second algorithm tailored object oriented languages information interest derived specializations arguments called routines 
algorithm consequently works backwards dynamically dispatched pass call sites places demand precise information proceeding phases cooper algorithm 
algorithm exploits profile information select profitable specializations 
procedure specialization long incorporated principal technique partial evaluation systems jones 
ruf katz weise ruf weise katz weise address problem avoiding fuse partial evaluator 
seeks identify specializations generate code 
ruf identifies subset information arguments specialization reuses specialization call sites share static information 
katz extends noting information conveyed routine result rest program 
differs working richer data language model functional subset scheme algorithm exploits dynamic profile information avoid specializations benefits accrued infrequently 
vortex compiler strives certain kinds programming styles practical combination static analyses profile guided optimizations plus supporting compiler infrastructure 
programmers feel free develop reusable libraries frameworks hooks extension form dynamically dispatched calls sensible 
style followed objectoriented language programmer discipline pure language prevents premature binding implementations 
application library exploits subset available functionality extensibility library compiler responsible eliminating cost unused flexibility reducing cost dispatching exploited 
cass hierarchy analysis works identify subclassing method overriding particular combination application libraries replacing unnecessary dynamic dispatching direct calls inlined code 
selective specialization applies code replication turn shared polymorphic code multiple versions monomorphic code eliminating dispatches reducing performance cost factoring profile class hierarchy information focus specialization important routines argument type combinations 
profile guided receiver class prediction reduces cost remaining dynamic dispatching common case receiver classes dominate 
selective recompilation mechanism helps program approach compilation optimization program optimization object oriented languages chambers practical normal program development setting performance group cecil benchmark programs ranging size lines size shows techniques deliver nearly order magnitude improvement unoptimized code factor improvement code compiled static intraprocedural optimizations 
currently developing front ends modula java vortex investigate optimizations points language design space dean 
programing style important language program written developing languageindependent metrics characterize style benchmark compare style performance improvements attributed different optimization techniques 
investigating number optimizations 
effective scalable interprocedural class analysis key technology call graph builds required interprocedural optimizations 
plan investigate automatically specializing object layout unboxing primitive datatypes eliminating pointer indirections component objects style similar shao appel ml compiler shao appel til ml compiler tarditi optimization requires call graph track flow data structures program lieu static type system ml implementing data structures particular representations useful communicating external programs writing systems programs 
traditional analyses pointer analysis chase landi ryder hendren deutsch wilson lam escape analysis object lifetime analysis hudak kranz exploit program call graph 
wish investigate integrating static dynamic compilation system combining advantages allowing experimentation different divisions labor static dynamic 
wish explore different points spectrum ranging pure separate compilation pure program optimization 
example library compiled optimized description application allowed extend library vice versa applications partial implementation descriptions libraries 
merging application library application fulfils assumptions compiling library vice versa linking succeeds fix code generated replace code compiled violated assumptions 
way separately compiled sharable libraries produced sacrificing optimization libraries cost lost optimization opportunities clients extra fix code space clients 
high level languages aggressive subtle optimizations difficult programmers predict program performance source code longer acceptable model relative costs different versions code 
want investigate mechanisms profiling performance monitoring inform programmer different aspects program behavior ideally requiring programmer detailed understanding compiler analyses optimizations 
addition programmer able express assertions optimization expectations instance message closure get inlined simple loop feedback programmer expectation met 
techniques developed vortex originally aimed object oriented languages high level languages share important characteristics object oriented languages viewed compiler perspective 
example generic arithmetic generic operations common lisp program optimization object oriented languages chambers similar languages bobrow introduce overloaded operations different run time representations selected run time run time type operands just non extensible kind class hierarchy vortex techniques applied optimizing code 
ml haskell implementations jones shao appel tarditi starting optimize programs particular representations place original polymorphic version analyses track representations bear great deal similarity static class analysis 
techniques vortex profile guided optimizations selective procedure specialization profitably added systems 
vortex selective recompilation mechanism help support program compilation model systems 
acknowledgments members cecil vortex team greatly contributed 
litvinov gathered performance data reported section 
charles garrett performed early gathering studying characteristics receiver class profiles 
tina wong joy implemented initial versions value analysis eliminating redundant dead loads stores performing symbolic range analysis eliminate unnecessary array bounds checks 
greg defouw implemented parts vortex compiler support input languages particularly modula 
research supported part nsf young investigator award contract number ccr nsf research initiation award contract number ccr office naval research contract number gifts sun microsystems ibm pure software edison design group 
agesen lzle ole agesen urs lzle 
type feedback vs concrete type analysis comparison optimization techniques object oriented languages 
oopsla conference proceedings pages austin tx october 
agesen lzle ole agesen urs lzle 
dynamic vs static optimization techniques object oriented languages 
theory practice object systems 
appear 
agesen ole agesen 
cartesian product algorithm simple precise type inference parametric polymorphism 
proceedings ecoop aarhus denmark august 
springer verlag 
agesen ole agesen jens palsberg michael 
type inference self analysis objects dynamic multiple inheritance 
proceedings ecoop july 
agrawal rakesh agrawal linda demichiel bruce lindsay 
static type checking multi methods 
proceedings oopsla acm sigplan notices pages november 
published proceedings oopsla acm sigplan notices volume number 
aigner lzle gerald aigner urs lzle 
eliminating virtual function calls programs 
proceedings ecoop linz austria august 
springer verlag 
appear 
ak hassan kaci robert boyer patrick lincoln roger nasr 
efficient implementation lattice operations 
acm transactions programming languages systems january 
eric olivier gruber eric simon 
optimizing multi method dispatch compressed dispatch tables 
proceedings oopsla pages portland october 
auslander joel auslander philipose craig chambers susan eggers brian bershad 
fast effective dynamic compilation 
sigplan notices pages may 
proceedings program optimization object oriented languages chambers acm sigplan conference programming language design implementation 
bobrow bobrow demichiel gabriel keene kiczales moon 
common lisp object system specification 
sigplan notices special issue september 
calder grunwald brad calder dirk grunwald 
reducing indirect function call overhead programs 
conference record popl st acm sigplan sigact symposium principles programming languages pages portland oregon january 
callahan david callahan alan carle mary hall ken kennedy 
constructing procedure call multigraph 
ieee transactions software engineering 
cartwright fagan robert cartwright mike fagan 
soft typing 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
caseau yves caseau 
efficient handling multiple inheritance hierarchies 
proceedings oopsla acm sigplan notices pages october 
published proceedings oopsla acm sigplan notices volume number 
chambers ungar craig chambers david ungar 
customization optimizing compiler technology self dynamically typed object oriented programming language 
sigplan notices july 
proceedings acm sigplan conference programming language design implementation 
chambers ungar craig chambers david ungar 
iterative type analysis extended message splitting optimizing dynamically typed object oriented programs 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
chambers ungar craig chambers david ungar 
making pure object oriented languages practical 
proceedings oopsla acm sigplan notices pages november 
published proceedings oopsla acm sigplan notices volume number 
chambers craig chambers 
design implementation self compiler optimizing compiler object oriented programming languages 
phd thesis stanford university march 
chambers craig chambers 
cecil language specification rationale 
technical report tr department computer science engineering 
university washington march 
chambers craig chambers david ungar lee 
efficient implementation self dynamically typed object oriented language prototypes 
proceedings oopsla acm sigplan notices pages october 
published proceedings oopsla acm sig plan notices volume number 
chambers craig chambers jeffrey dean david grove 
framework selective recompilation presence complex intermodule dependencies 
th international conference software engineering pages seattle wa april 
chang chang scott mahlke chen wen mei hwu 
profile guided automatic inline expansion programs 
software practice experience may 
chase david chase mark wegman kenneth zadeck 
analysis pointers structures 
sig plan notices june 
proceedings acm sigplan conference programming language design implementation 
chen chen volker wolfgang klas 
efficient dynamic look strategy multi methods 
tokoro pareschi editors proceedings ecoop lncs pages bologna italy july 
springer verlag 
consel noel charles consel francois noel 
general approach run time specialization ap program optimization object oriented languages chambers plication conference record popl st acm sigplan sigact symposium principles programming languages pages st petersburg florida january 
cooper keith cooper mary hall ken kennedy 
procedure cloning 
proceedings ieee international conference computer languages pages oakland ca april 
cousot cousot patrick cousot radhia cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
conference record fourth acm symposium principles programming languages pages los angeles california january 
cytron ron cytron jeanne ferrante barry rosen mark wegman kenneth zadeck 
efficient method computing static single assignment form 
conference record sixteenth annual acm symposium principles programming languages pages austin texas january 
dean chambers jeffrey dean craig chambers 
better inlining decisions inlining trials 
proceedings acm conference lisp functional programming pages orlando fl june 
dean jeffrey dean craig chambers david grove 
selective specialization object oriented languages 
sigplan notices pages june 
proceedings acm sigplan conference programming language design implementation 
dean jeffrey dean greg defouw dave grove litvinov craig chambers 
vortex optimizing compiler object oriented languages 
oopsla conference proceedings san jose ca october 
appear 
deutsch schiffman peter deutsch allan schiffman 
efficient implementation smalltalk system 
conference record eleventh annual acm symposium principles programming languages pages salt lake city utah january 
deutsch alain deutsch 
interprocedural may alias analysis pointers pldi limiting 
sigplan notices appear june 
proceedings acm sigplan conference programming language design implementation 
diwan amer diwan eliot moss kathryn mckinley 
simple effective analysis statically typed object oriented programs 
oopsla conference proceedings san jose ca october 
appear 
dylan object oriented dynamic language april 
apple computer 
engler dawson engler wilson frans kaashoek 
language high level efficient machine independent dynamic code generation 
conference record popl st acm sigplan sigact symposium principles programming languages pages st petersburg florida january 
fernandez mary fernandez 
simple effective link time optimization modula programs 
sigplan notices pages june 
proceedings acm sigplan conference programming language design implementation 
goldberg robson adele goldberg david robson 
smalltalk implementation 
wesley reading ma 
gosling james gosling bill joy guy steele 
java language specification 
addison wesley reading ma 
grove torczon dan grove linda torczon 
interprocedural constant propagation study jump function implementations 
sigplan notices june 
proceedings acm sig plan conference programming language design implementation 
grove david grove 
impact interprocedural class analysis optimization 
proceedings cas program optimization object oriented languages chambers con pages toronto canada october 
grove david grove jeffrey dean charles garrett craig chambers 
profile guided receiver class prediction 
oopsla conference proceedings pages austin tx october 
heintze nevin heintze 
set analysis ml programs 
proceedings acm conference lisp functional programming pages orlando fl june 
hendren laurie hendren joseph hummel alexandru nicolau 
abstractions recursive pointer data structures improving analysis imperative programs 
sigplan notices july 
proceedings acm sigplan conference programming language design implementation 
lzle ungar urs lzle david ungar 
optimizing dynamically dispatched calls run time type feedback 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
lzle ungar urs lzle david ungar 
optimizing dynamically dispatched calls run time type feedback 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
lzle urs lzle craig chambers david ungar 
optimizing dynamically typed object oriented languages polymorphic inline caches 
america editor proceedings ecoop lncs pages geneva switzerland july 
springer verlag 
hudak paul hudak 
semantic model counting abstraction 
acm symposium lisp functional programming pages august 
johnson ralph johnson 
type checking smalltalk 
proceedings oopsla acm sigplan notices pages november 
published proceedings oopsla acm sigplan notices volume number 
johnson ralph johnson 
ts optimizing compiler smalltalk 
proceedings oopsla acm sig plan notices pages november 
published proceedings oopsla acm sig plan notices volume number 
jones mark jones 
dictionary free overloading partial evaluation 
proceedings workshop partial evaluation semantics program manipulation pages orlando fl june 
jones neil jones peter sestoft 
partial evaluation automatic program generation 
prentice hall new york ny 
katz weise katz weise 
new perspective partial evaluation 
proceedings workshop partial evaluation semantics program manipulation pages 
yale university 
kiczales rodriguez gregor kiczales luis rodriguez 
efficient method dispatch pcl 
technical report ssl xerox parc systems sciences laboratory 
kilian michael kilian 
trellis owl runs fast 
unpublished manuscript march 
knoop jens knoop oliver thing bernhard steffen 
partial dead code elimination 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
kranz david kranz richard kelsey jonathan rees paul hudak james philbin norman adams 
orbit optimizing compiler scheme 
sigplan notices july 
proceedings acm sigplan symposium compiler construction 
landi ryder william landi barbara ryder 
safe approximate algorithm interprocedural pointer aliasing 
sigplan notices july 
proceedings acm sigplan program optimization object oriented languages chambers conference programming language design implementation 
lea doug lea 
customization 
proceedings usenix conference san francisco ca april 
leone lee mark leone peter lee 
optimizing ml run time code generation 
sigplan notices pages may 
proceedings acm sigplan conference programming language design implementation 
leroy xavier leroy 
unboxed objects polymorphic typing 
conference record nineteenth annual acm sigplan sigact symposium principles programming languages pages new mexico january 
lim stolcke chu lim andreas stolcke 
sather language design performance evaluation 
technical report tr international computer science institute may 
mueller whalley frank mueller david whalley 
avoiding conditional branches code replication 
sigplan notices pages june 
proceedings acm sigplan conference programming language design implementation 
nelson greg nelson 
systems programming modula 
prentice hall englewood cliffs nj 
nicholas jens palsberg michael schwartzbach 
making type inference practical 
lehrmann madsen editor proceedings ecoop lncs pages utrecht netherlands june 
springer verlag 
palsberg schwartzbach jens palsberg michael schwartzbach 
object oriented type inference 
proceedings oopsla acm sigplan notices pages november 
published proceedings oopsla acm sigplan notices volume number 
palsberg schwartzbach jens palsberg michael schwartzbach 
object oriented type systems 
john wiley sons 
pande ryder pande barbara ryder 
static type determination 
proceedings sixth usenix technical conference 
peterson jones john peterson mark jones 
implementing type classes 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
plevyak chien john plevyak andrew chien 
precise concrete type inference object oriented languages 
proceedings oopsla pages portland october 
ruf weise ruf weise 
types avoid redundant specialization 
proceedings symposium partial evaluation semantics program manipulation pages 
acm 
ryder barbara ryder 
constructing call graph program 
ieee transactions software engineering 
schaffert craig schaffert cooper carrie 
trellis object environment language manual 
technical report dec tr digital equipment november 
schaffert craig schaffert cooper bruce mike killian carrie 
trellis owl 
proceedings oopsla acm sigplan notices pages november 
published proceedings oopsla acm sigplan notices volume number 
shao appel zhong shao andrew appel 
type compiler standard ml 
sigplan notices pages june 
proceedings acm sigplan conference programming language design implementation 
shivers olin shivers 
control flow analysis scheme 
sigplan notices july 
proceedings acm sigplan conference programming language design imple program optimization object oriented languages chambers mentation 
shivers olin shivers 
control flow analysis higher order languages 
phd thesis carnegie mellon university may 
cmu cs 
src dec src modula implementation 
digital equipment systems research center 
www research digital com src modula html home html 
srivastava amitabh srivastava 
unreachable procedures object oriented programming 
acm letters programming languages systems december 
tarditi david tarditi greg morrisett perry cheng chris stone bob harper peter lee 
til type directed compiler ml 
sigplan notices pages may 
proceedings acm sigplan conference programming language design implementation 
tichy walter tichy 
rcs system version control 
software practice experience july 
ungar smith david ungar randall smith 
self power simplicity 
proceedings oopsla acm sigplan notices pages december 
published proceedings oopsla acm sigplan notices volume number 
wall david wall 
predicting program behavior real estimated profiles 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
weihl william weihl 
interprocedural data flow analysis presence pointers procedure variables label variables 
conference record seventh annual acm symposium principles programming languages pages las vegas nevada january 
wilson lam robert wilson monica lam 
efficient context sensitive pointer analysis programs 
sigplan notices pages june 
proceedings acm sigplan conference programming language design implementation 
wright cartwright andrew wright robert cartwright 
practical soft type system scheme 
proceedings acm conference lisp functional programming pages orlando fl june 

