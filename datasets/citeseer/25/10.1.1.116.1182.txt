dangers replication solution jim gray gray microsoft tom pat microsoft tom patrick neil cs edu dennis shasha shasha cs nyu edu update anytime anyway transactional replication unstable behavior workload scales fold increase nodes gives fold increase deadlocks 
master copy replica tion primary schemes reduce problem 
simple analytic model demonstrates results 
new tier replication algorithm proposed allows mobile disconnected applications propose tentative update trans actions applied master copy 
commutative update transactions avoid instability replication schemes 

data replicated multiple network nodes performance availability eager replication keeps replicas exactly synchronized nodes updating replicas part atomic transaction 
eager replication gives serializable execution concurrency anomalies 
eager replication reduces update performance increases transac tion response times extra updates messages added transaction 
eager replication option mobile applications nodes normally disconnected 
mobile appli cations require lazy replication algorithms asynchronously propagate replica updates nodes updating transaction commits 
continuously connected systems lazy replication improve response time 
lazy replication shortcomings serious stale data versions transactions read write data concurrently transaction updates serialized avoids concurrency anomalies 
eager replication typically uses locking scheme detect late concurrent execution 
lazy replication schemes typically multi version concurrency control scheme detect non serializable behavior bernstein hadzilacos goodman 
multi version isolation schemes provide transaction committed value 
lazy replication may allow transaction see old committed value 
committed updates local value may transit node update strategy lazy 
permission copy part personal granted fee provided copies distributed profit commercial advantage copyright notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission ard fee 
sigmod montreal canada acm eager replication delays aborts uncommitted trans action committing violate serialization 
lazy replication difficult task replica updates committed tion problem detected 
usually auto matic way reverse committed replica updates program person reconcile conflicting transac tions 
tangible consider joint checking account share spouse 
suppose 
account replicated places check book spouse bank 
eager replication assures books account balance 
prevents spouse writing checks totaling 
try account transaction fail 
lazy replication allows spouse write checks totaling total withdrawals 
checks arrived bank communicated spouse reconciles transactions virtual 
nice automate reconciliation 
bank rejecting updates cause 
master replication scheme bank master copy bank updates really count 
unfortunately works bank 
spouse spend considerable time reconciling extra dollars worth transactions 
books incon sistent bank books 
difficult perform banking operations 
database checking account single number log updates number 
simplest database 
reality databases complex serialization issues subtle 
theme update anytime anyway replication unstable 
number account increases factor deadlock reconciliation rates rises factor 

disconnected operation message delays mean lazy replication frequent reconciliation 
replicated simple single node transaction apply updates remotely part eager separate transactions lazy ase data replicated nodes transaction single node node node transaction write ww transactions rim wl simple replication works low loads nodes 
creates scaleup pitfall 
prototype system demonstrates 
transactions deadlock need reconciliation running connected nodes 
system behaves differently application scaled large number nodes nodes disconnected message propagation delays longer 
systems higher transaction rates 
suddenly deadlock reconciliation rate higher cubic growth predicted model database node diverges rec fails reconciliation failure implies differences nodes 
soon system suffers system database inconsistent obvious way repair gray reuter pp 

picture probably accurate 
simple replica tion transactional update anytime anyway global serializability outline gives simple model replication closed form average case analysis probability waits deadlocks 
simplicity model ignores issues predicted behavior worse 
particular ignores message propagation delays needed broadcast replica updates 
ignores true serialization assumes weak multi version form committed read serialization read locks 
considers object master replication 
unrestricted lazy master replication instability problems ea ger group replication 
restricted form replication avoids problems tier replication base nodes connected mobile nodes usually disconnected 

mobile nodes propose tentative update transactions objects owned nodes 
mobile node keeps object versions local version best known master version 

mobile nodes occasionally connect base nodes propose tentative update transactions master node 
proposed transactions re executed may succeed rejected improve chances success tentative transactions designed commute transactions 
exchanges mobile node database synchronized base nodes 
rejected tentative transactions reconciled mobile node owner generated transaction 
analysis shows scheme supports lazy replication mobile computing avoids system tentative updates may ejected state remains consistent 
replication models base database shows ways propagate updates replicas 
eager updates applied replicas object part original transaction 

replica updated originating trans 
action 
updates replicas propagate asynchronously typically separate transaction node 
updates may controlled ways 
updates emanate master copy object updates may emanate 
group ownership chances conflicting updates 
object master object group master shows ways regulate replica updates 
group node copy data item date 
called update 

master object master node 
master update primary copy object 

replicas read 
nodes wanting update object request master update 
table taxonomy replication propagation strati ea lazy tha strategy master group 
vs lazy eager ownership group transactions transaction object owners object owners master transactions transaction object owner object owner tier transactions object owner tentative local updates eager base updates nodes transactions tps actions action time time disconnects disconnected time message delay cpu wcs rnd die model analysis number distinct objects data base number nodes node number concurrent transactions node 
derived value 
number transactions second node 
number transaction time perform action mean time network disconnect node 
mean time node disconnected network time update object update replica ignored processing transmission time needed send replication message apply replica update ignored analysis indicates group lazy replication prone serializability ions master eager replication model assumes database consists fixed set ob jects 
fixed number nodes storing rep lica objects 
node originates fixed number transactions second 
transaction updates fixed number objects 
access objects equi probable hotspots 
inserts deletes modeled updates 
reads ignored 
replica update requests transmit delay require processing sender receiver 
delays extra processing ignored sequentially updating replicas node modeled 
nodes mobile disconnected time 
connected mobile node sends receives de replica updates 
table lists model parameters 
imagine variations model 
applying eager updates parallel comes mind 
design alterna tive gives slightly different results 
design roughly characterizes basic alternatives 
believe obvious varia tions substantially change results 
node generates tps transactions second 
transaction involves fixed number actions 
action requires fixed time execute transaction duration actions action time 
observations number concurrent transactions originating node transactions tps actions time careful analysis consider fact system load contention rises time complete action increases 
scaleable server system time dilation second order effect ignored 
system nodes times transactions wi originating second 
update transaction replicate updates nodes easy see transaction size eager systems grows factor node update rate grows 
lazy systems user update transaction gener ates lazy replica updates times concurrent transactions node update rate higher 
non linear growth node update rates leads unstable behavior system scaled 

eager replication eager replication updates replicas transaction updates instance object 
zation anomalies inconsistencies need recon eager systems 
locking detects potential anomalies converts waits deadlocks 
eager replication reads connected nodes give cur rent data 
reads disconnected nodes may give stale date data 
simple eager replication systems pro updates node disconnected 
high avail ability eager replication systems allow updates members quorum cluster gifford garcia molina 
node joins quorum quorum sends new node replica updates node disconnected 
assume quorum fault tolerance scheme improve update availability 
nodes connected time updates may fail due deadlocks prevent serialization errors 
fol lowing simple analysis derives wait deadlock rates eager replication system 
start wait deadlock rates single node system 
single node system transactions actions resources locked half way complete objects chosen uniformly data base chance request transaction request resource locked transaction transactions actions transaction actions re db size quests chance wait lifetime approximately gray gray reuter pp 
transactions actions pw db size db size deadlock consists cycle transactions waiting 
probability transaction forms cycle length pw divided number transactions 
cycles length proportional pw pw 
applying equation probability transaction deadlocks approximately tp tion tim actions pd transactions db db sue equation gives deadlock hazard transaction 
deadlock rate transaction probability deadlock second 
pd divided transaction life time actions time 
tps actions trans deadlock rate db size node runs transactions concurrent transactions deadlock rate node higher 
multiplying equation equation node deadlock rate node deadlock rate tps action timex actions db size suppose systems replicated eager replication updates done immediately 
node initiate local load tps transac tions 
transaction size duration aggregate transaction rate eager systems transaction size actions nodes transaction duration actions nodes time total tps tps nodes node doing applying updates generated nodes 
update transaction transaction arrival rate node stays constant nodes replicated assumes nodes lightly loaded 
replication workload increases nodes grow processing io power handle increased load 
growing power rate problematic performs actions nodes actions longer lifetime takes nodes times longer 
result total number transactions system rises quadratically number nodes total transactions tps time rise active transactions due eager transactions times longer due lazy updates generating times transactions 
action rate rises fast node generates nodes 
eager rate measured actions second action rate total tps transaction size tps nodes surprising action rate number ac tive transactions eager lazy systems 
eager systems fewer longer transactions 
lazy sys tems shorter transactions 
equations different lazy systems equations apply eager lazy systems 
ignoring message handling probability transaction waits computed argument equation 
transaction actions requests total transactions actions objects locked 
result approximately pw eager total transactions actions actions db size tps action timex actions nodes db size probability transaction waits 
wait rate waits second entire system com puted total eager wait rate pw eager total transactions transaction duration tps action timex actions nodes db size equation probability particular transaction deadlocks approximately pd eager total transactions actions db size tps action timex nodes db size model eager actions broadcast update repli cas instant 
replicas updated parallel elapsed time action constant independent 
model attempt capture message handing costs serializing individual updates follows model processing node rises number concurrent transactions stays con stant scaleup 
model avoids polynomial explosion waits deadlocks total tps rate held constant 
lo equation single transaction deadlock implies total deadlock rate 
arguments equations equations total eager deadlock rate total transactions pd eager transaction duration tps action time nodes db size message delays added model transac tion longer hold resources longer collide transactions 
equation ignores second order effect transactions racing update object time distinguish master group replication 
db size node conflicts rare 
analysis points serious problems eager rep 
deadlocks rise third power number nodes network fifth power transaction size 
going node nodes increases deadlock rate fold 
fold increase transaction size increases deadlock rate factor 
ameliorate imagine database size grows number nodes example earlier tpc tpc tpc benchmarks 
nodes transactions mean data 
scaled database size equation eager deadlock rate scaled db tps action timex nodes db size fold growth number nodes creates fold growth deadlock rate 
unstable situation big improvement equation having master object helps eager replication avoid deadlocks 
suppose object owner node 
updates go node applied replicas 
transaction updated single replica object master approach eliminate deadlocks 
summary eager replication major problems 
mobile nodes eager scheme nected 

probability deadlocks consequently failed transactions rises quickly transaction size number nodes 
fold increase nodes gives fold increase failed transactions deadlocks 
see solution problem 
replica updates done concurrently action time crease growth rate quad 

lazy group replication lazy group replication allows node update local data 
transaction commits transaction sent node apply root transaction updates replicas destination node see possible nodes update object race install updates nodes 
replication mechanism detect reconcile transactions updates lost 
timestamps commonly detect reconcile lazy group transactional updates 
object carries timestamp update 
replica update carries new value tagged old object timestamp 
node detects incoming replica updates overwrite earlier committed updates 
node tests local replica timestamp update old timestamp equal 
update safe 
local replica timestamp advances new transaction timestamp object value updated 
current timestamp local replica match old timestamp seen root transaction update may dangerous 
cases node rejects incoming transaction submits reconciliation 
root wa transaction lazy transaction root execution updates master local copies data 
subse quent transactions update replicas remote nodes lazy transaction remote node 
lazy dates carry timestamps original object 
local object timestamp match update may dan form reconciliation needed transactions wait eager replication sys tem face reconciliation lazy group replication system 
waits frequent deadlocks takes waits deadlock 
waits rare event deadlocks rare rare 
eager replication waits cause delays deadlocks create ap plication faults 
lazy replication frequent waits determines reconciliation frequency 
system wide lazy group reconciliation rate follows transaction wait rate equation equation lazy group reconciliation rate tps action timex actions nodes db size eager replication message propagation times added reconciliation rate rise 
having rec rate rise factor system scales factor 
really bad case arises mobile computing 
suppose typical node disconnected time node accepts applies transactions day 
night connects downloads rest network 
time accepts replica updates 
message propagation time hours 
transactions different nodes update data disconnection period need reconciliation 
chance disconnected trans actions colliding disconnected time 

lazy master replication master replication assigns owner object 
owner stores object correct current value updates done owner propagated replicas 
different objects may different owners 
transaction wants update object sends rpc remote procedure call node owning ob ject 
get serializability read action send rpcs masters objects reads 
simplify analysis assume node originating transaction broadcasts replica updates slave replicas master transaction commits 
originating node sends slave transaction slave node 
slave updates timestamped assure replicas converge final state record timestamp newer replica update timestamp update stale ignored 
master node sends replica updates slaves sequential commit order 
node updates small fraction database day lazy master replication appropriate mobile ap number distinct outbound pending object updates 
node wanting update object reconnect approximately connected object owner participate atomic outbound updates disconnect timex tps actions transaction owner 
updates applies replicas object 
pending inbound updates node rest network approximately nodes times larger 
inbound updates nodes disconnect timex tps actions inbound outbound sets overlap reconciliation needed 
chance object sets approxi mately collision inbound updates outbound updates db size disconnect time tps actions db size equation chance node needs reconciliation dur ing disconnect time cycle 
rate nodes la group reconciliation rate nodes collision disconnect time disconnect time tps actions nodes db size quadratic nature equation suggests system performs nodes simple transactions may unstable system scales 
eager systems lazy master systems rec failures conflicts resolved wait ing deadlock ignoring message delays deadlock rate lazy master replication system similar single node system higher transaction rates 
lazy master transactions operate master copies ob jects 
nodes times users nodes times concurrent master transac tions approximately nodes times replica update transactions 
replica update transactions really matter background housekeeping transactions 
abort restart affecting user 
main issue frequently master transactions deadlock 
logic equation deadlock rate approximated lazy 
master deadlock rate tps zt better behavior lazy group replication 
lazy master replication sends fewer messages base transaction completes quickly 
replication schemes troubling deadlock reconciliation rates grow nodes 
summary lazy master replication requires contact object masters useable mobile applica tions 
lazy master replication slightly deadlock prone eager group replication primarily transactions shorter duration 

non transactional replication schemes kind commutative update adding subtracting constants integer value 
equations previous sections facts nature possible notes support third form help explain fact nature 
show transaction high update traffic replicated databases globally 
commutative updates incremental transfor serializable transactions 
mations value applied order 
certainly replicated databases phone books check books mail systems name servers 
dates databases managed interesting ways typically lazy master way 
updates oriented updates expressed transactional transformations debit account change account 
strategy abandon serializability convergence property new transactions arrive nodes connected converge repli cated state exchanging replica updates 
resulting state contains committed appends re placements updates may lost 
lotus notes gives example convergence 
notes lazy group replication design update anytime 
notes provides convergence acid transaction execution model 
database state may reflect particular serial execution states identical 
explained timestamp schemes lost update problem lotus notes achieves convergence offering lazy group replication transaction level 
provides forms date transaction 
append adds data notes file 
appended note timestamp 
notes stored timestamp order 
nodes contact converge state 

timestamped replace value replaces value newer value 
current value object timestamp greater update timestamp incom ing update discarded 
convergence goal timestamp method sufficient 
timestamp scheme may lose effects transactions just applies updates 
applying timestamp scheme check book example concurrent updates balance highest timestamp value wins update discarded stale value 
concurrency control theory calls lost update problem 
timestamp schemes vulnerable lost updates 
lotus notes internet name service mall systems mi access applications techniques achieve convergence avoid sion 
microsoft access offers convergence follows 
single design master node controls schema updates replicated database 
offers update record instances 
node keeps version vector replicated record 
version vectors exchanged demand periodically 
date wins pairwise exchange 
rejected updates reported hammond 
examples contrast simple update anytime lazy group replication offered systems 
transaction profiles constrained lazy group schemes suffer unstable reconciliation described earlier sections 
systems degenerate system scale 
lazy group replication schemes emerging spe reconciliation rules 
oracle provides choice twelve reconciliation rules merge conflicting updates oracle 
addition users program recon rules 
rules give priority certain sites time priority value priority merge commutative updates 
rules transactions commutative 
similar transaction level approach followed tier scheme described 

tier replication ideal replication scheme achieve goals availability scalability provide high availability scalability replication avoiding stability 
mobility allow mobile nodes read update da disconnected network 
serializability provide single copy serializable transaction execution 
convergence provide convergence avoid system convergence desirable converged state re safest transactional replication schemes ones fleet effects committed transactions 
general avoid system eager systems lazy possible global serialization techniques 
master systems 
reconciliation problems reconciliation 
systems certain cases transactions designed commute problems 
shown earlier database ends state matter transaction execution order chosen 
timestamped append sion 

mastered objects accept updates master node accessible 
difficult master replication mobile applications 

master systems unstable increasing load 
deadlocks rise quickly nodes added 

eager systems lazy master reads go master give acid serializability 
circumventing problems requires changing way system 
believe scaleable replication system function check books phone books lotus notes access replication systems see 
lazy group replication systems prone reconciliation problems scale 
manually reconciling conflicting transactions unworkable 
approach undo transaction needs reconciliation backing updates transaction 
transactions atomic consistent isolated durable durable updates propagated node 
lazy group system transaction tentative replica updates propagated 
mobile rep lica node disconnected long time transactions tentative missing node reconnects 
undo oriented lazy group replication scheme untenable mobile applications 
solution require modified mastered replication scheme 
avoid reconciliation object mastered node bank owns checking account mail server owns mailbox 
mobile agents tentative updates connect base nodes learn tentative update acceptable 
tier replication scheme begins assuming kinds nodes mobile nodes disconnected time 
store replica database may originate tentative trans actions 
mobile node may master data items 
base nodes connected 
store replica database 
items mastered base nodes 
replicated data items versions mobile nodes master version value received ob ject master 
version object master master version disconnected lazy replica nodes may older versions 
tentative version local object may updated tentative transactions 
value due local updates maintained tentative value 
similarly kinds transactions base transaction base transactions master data produce new master data 
involve connected mobile node may involve base nodes 
tentative transaction tentative transactions local tentative data 
produce new tentative ver sions 
produce base transaction run time base nodes 
tentative transactions follow scope rule may involve objects mastered base nodes mastered mobile node originating transaction call transaction scope idea mobile node base nodes contact tentative transaction processed real base transaction real transaction able read master copy item scope 
local transactions read write local data designed way 
read write tentative data lg lc tier replication scheme 
base nodes store replicas database 
object mastered node mobile nodes store replica database 
usually disconnected 
mobile nodes accumulate tentative transactions run tentative data base stored node 
tentative transactions base transactions mobile node base 
tentative transactions may fail 
iee ee ode base transaction generated tentative transaction may fail may produce different results 
base transaction acceptance criterion test result ing outputs pass slightly different base trans action results acceptable 
give sample ac criteria bank balance go negative 
price quote exceed tentative quote 
seats seats 
tentative transaction fails originating node person generated transaction informed failed failed 
acceptance failure equivalent reconciliation mechanism lazy group replication schemes 
differences master database converged system originating node need contact base node order discover tentative transaction acceptable continue checking account analogy bank version account master version 
writing checks spouse creating tentative transactions result tentative versions account 
bank runs base transaction clears check 
contact bank clears check know tentative transaction real transaction consider tier replication scheme behavior connected operation 
environment tier system operates lazy master system additional restriction transaction update data mastered mobile node 
restriction really needed connected case 
consider disconnected case 
imagine mobile node disconnected day ago 
copy base data yesterday 
generated tentative transactions base data local data mastered mobile node 
transactions generated tentative data versions mo bile node 
mobile node queries data sees values 
example updated documents produced contracts sent mail messages tentative updates visible mobile node 
mobile node connects base node mobile node 
discards tentative object versions soon refreshed masters 
sends replica updates objects mastered mo bile node base node hosting mobile node 
sends tentative transactions input pa rameters base node executed order committed mobile node 
accepts replica updates base node stan dard lazy master replication 
accepts notice success failure tentative transaction 
host base node tier tiers 
contacted mobile note host base node 
sends delayed replica update transactions mobile node 
accepts delayed update transactions mobile mastered objects mobile node 

accepts list tentative transactions input mes sages acceptance criteria 
tentative transaction order committed mobile node 
reprocessing base transaction reads writes object master copies lazy master execution model 
scope rule assures base transaction accesses data mastered originating mobile node base nodes 
master copies data transaction scope available base transaction 
base transaction fails acceptance criteria base transaction aborted diagnostic message returned mobile node 
acceptance criteria requires base tentative transaction identical outputs subsequent transactions reading tentative results written fail 
hand weaker tance criteria possible 

base node commits base transaction propagates lazy replica updates transactions sent replica nodes 
standard lazy master 

tentative transactions base transactions mobile node state converged base state 
key properties tier replication scheme 
mobile nodes may tentative database updates 
base transactions execute single copy serializability master base system state result serializable execution 

transaction durable base trans action completes 

replicas connected nodes converge base system state 

transactions commute tions 
comes close meeting goals outlined start section 
executing base transaction tier scheme lazy master scheme 
deadlock rate base transactions equation 
deadlock rate 
base transaction deadlocks re submitted succeeds replica update transactions resubmitted case deadlock 
reconciliation rate base transactions zero transactions commute 
reconciliation rate driven rate base transactions fail acceptance criteria 
processing base transaction may produce results dif ferent tentative results 
acceptable applications 
fine checking account bal ance different transaction 
transactions nodes may affected account mobile node disconnected 
cases changes may acceptable 
price item increased large amount item stock seats longer available salesman price delivery quote reconciled customer 
acceptance criteria application specific 
replication system detect difference tentative base transaction 
probably pessimistic test 
replication system simply run tentative transaction 
tentative transaction completes successfully passes acceptance test replication system assumes propagates replica updates usual 
users aware updates tentative transac 
tion base transaction 
base transaction fails user may revise resubmit transaction 
programmer design transactions commutative acceptance criteria detect tentative transaction agrees base transaction effects 
executing tentative base transactions tier replication 
thinking example earlier section 
check fact tentative update sent bank 
bank honors check rejects 
analogous mechanisms forms flow systems ranging tax filing applying job subscribing magazine 
approach widely human commerce 
approach similar general data cycle architecture herman single master node objects 
approach obtain pure serializability base transaction reads writes master objects current versions 

summary replicating data nodes letting update data problematic 
security issue performance 
standard transaction model applied replicated database size transaction rises degree replication 
combined higher transaction rates means dramatically higher deadlock rates 
lazy replication scheme solve problem 
unfortunate lazy group replication just con waits deadlocks 
lazy master replication slightly better behavior eager master repli cation 
suffer dramatically increased deadlock replication degree rises 
master schemes allow mobile computers update database disconnected system 
solution appears semantic tricks timestamps commutative transactions combined tier replication scheme 
tier replication supports mobile nodes combines benefits eager master replication scheme local update scheme 
john 
bennett microsoft alex ibm gave helpful advice earlier version 
anonymous referees helpful suggestions improve presentation 

bernstein hadzilacos goodman concurrency control recovery database systems addison wesley reading ma 
bernstein gray jim melton neil critique ansi sql isolation levels proc 
acm sigmod pp 
san jose ca june 
garcia molina performance update algorithms rep data distributed database tr stan cs cs dept stanford stanford ca june 
garcia molina barbara assign votes dis tributed system acm 
pp 
october 
gifford weighted voting replicated data proc 
acm sigops sosp pp pacific grove ca de gray reuter transaction processing concepts techniques morgan kaufmann san francisco ca 

gray korth obermarck strawman analysis probability deadlock ibm rj ibm research san jose ca 
hammond brad replication service micro soft access visual basic microsoft white microsoft 
com herman gopal lee architecture high throughput database systems proc 
acm sigmod san francisco ca 
may raymond greif replicated document management group communication system proc 
second conference com puter supported cooperative sept 
oracle oracle server distributed systems replicated data oracle part number march oracle redwood ca 
www oracle 
com products oracle server whitepapers replication 
