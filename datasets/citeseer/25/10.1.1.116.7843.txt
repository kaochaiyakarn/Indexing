general method compiling event driven simulations robert french monica lam jeremy levitt olukotun computer systems laboratory stanford university ca new approach event driven simulation centralized run time event queue capable handling arbitrary models including feedback delay 
elimination event queue significantly reduces run time overhead resulting faster simulation 
implemented algorithm prototype verilog simulator called 
simulator demonstrate improved performance vs commercial simulator small set programs 
modern digital system design relies heavily simulation reduce number design errors improve system efficiency 
large system designs time spent simulation design bottleneck 
event driven simulation compiled simulation known simulation techniques currently digital system design 
event driven simulation events managed dynamically event scheduler 
main advantage event driven scheduling flexibility event driven simulators simulate synchronous asynchronous models arbitrary timing delays 
disadvantage event driven simulation low simulation performance 
compiled code logic simulators potential provide higher simulation performance event driven simulators eliminate run time overhead associated ordering propagating events 
done evaluating components clock cycle order ensures inputs component latest value time component executed 
main disadvantage compiled simulation techniques general 
compiled logic simulators simulate models arbitrary delays notable exception 
furthermore techniques models feedback 
practice digital systems synchronous asynchronous chip interfaces common 
general method compiling eventdriven models called static simulation combines generality event driven simulations efficiency simulation approach 
event driven simulation technique applies general models including synchronous asynchronous designs 
restriction specified delays simulation known constants compile time 
efficiency technique schedules events compile time eliminating research supported part arpa contract dabt 
need run time event queue associated overhead 
replace event queue inexpensive run time tests necessary 
models tested run time tests incur significantly overhead run time event queue 
represent event driven behavior event graph vertices represent events simulation edges represent causal relationships events 
apply general technique partial evaluation schedule events possible statically available information 
specifically compiler tries approximate dynamic simulation process keeping track available static information affects contents run time event queue dynamic simulation 
general method applied uniformly models previous approaches 
test algorithm implemented prototype simulator called suif stanford university intermediate format compiler system 
chose verilog mainly relatively simple language implement 
simulator particularly useful long running regression tests produces faster simulation techniques 
current implementation unsuitable phases design process support interactive debugging 
remainder organized follows 
give brief overview verilog describe features verilog support 
describe event graph representation underlies method 
describe mathematical model traditional event driven simulation static simulation technique 
discuss optimizations experimental results 
ii 
brief overview verilog verilog programs composed modules 
modules may instantiated inside modules create hierarchy structure hardware system 
modules contain types concurrent process statements initial blocks blocks continuous assignments 
initial blocks executed simulation blocks executed repeatedly 
initial blocks consist statements executed sequentially wait signal change value statements 
continuous assignment assignment wire left hand side continuously reflects current state variables right hand side 
verilog simulator simulates model sequentially removing events event queue executing events placing new events queue activated 
supports subset verilog 
support tasks functions fork join disable statement 
foresee difficulty extending system handle features 
iii 
event graph representation represent model event graph 
event graphs provide representation static simulation algorithm transformations event graphs improve simulation performance 
event graph partitions model events represented vertices uses directed edges represent relationships events 
define event largest unit program execute atomically simulation corresponds code executed step event driven simulation 
semantics original language determines precisely boundaries events determined original source 
verilog events boundaries start finish initial blocks explicit delays statements wait signals 
vertex associated executable code verilog program 
edge represents causal relationship event 
edges take forms triggering 
event event separated statement 
execution event sensitive triggered events 
triggering actions cause events scheduled execution 
kinds trigger actions control flow data flow delays 
trigger program control flows boolean expression evaluates true executing execution changes value expression delay statement separates 
note control flow represented control flow edges 
control flow crosses event boundary represented way 
control flow contained single event 
verilog program represented event graph hv en eb ex edi set events start event set initially sensitive events en represents edges eb set boolean expressions represents possible triggering actions due control flow ex set expressions represents possible triggering actions due change expression values ed set numbers represents possible triggering actions due delay statements 
example event graph small verilog program shown 
iv 
dynamic simulation describe compiler algorithm formally describe model traditional dynamic simulation process 
simulation state computation captured quadruple hn mi module example reg clk initial clk clk clk clk display clk clk clk clk clk display verilog program event graph 
trigger edges solid edges dashed 
start event shaded initially sensitive events thick edges 
set sensitive events set events ready executed set hv di event time steps left execute memory store maps variable current value 
assume existence operations oneof deterministically chooses event set ready events exec applies code event memory store returns new memory store 
may produce side effects generating output 
eval evaluates boolean expression memory store returns true false 
indicates execution event initial memory store changes value expression define hn mi hn type transition represents execution event current simulation time step oneof exec fvg fv eng fvg fv bi eb eval fv hv xi ex fhv di edg type ii transition represents incrementing simulation time time event occur 
min hv di fhv di di ag fhv type iii transition represents simulation denoting state 
dynamic simulation event graph sequence states hn fv fg represents initial memory store maps variable appropriate initial value verilog variables 
si si static simulation manipulating event queue considerable source run time overhead 
approach reducing overhead compiler perform simulation possible compile time completely eliminate run time event queue 
collecting information events executed point simulation generating code events guarded run time tests 
possible track variable values compilation decisions event execute compile time run time 
example consider 
start simulation compiler finds initial event event graph emits corresponding code 
analyzing code compiler determines value clk set 
trigger edge start event compiler emits code similarly notes value changed 
change clk triggers compiler emits code notes remains sensitive 
point possible transition take corresponds delay edge back 
compiler generates code increment time 
repeats series clk value initially set arrives state executed ready execute 
compiler simply wraps loop section code 
events waiting executed compilation complete 
final code clk forever clk clk display clk time time clk clk display clk time time event driven simulator example events scheduled time step 
approach completely eliminates overhead run time event queue conditional tests performed run time 
generated code expects cycle compiled code simulator technique require special treatment clock signals general 
example shows variable values tracked compile time 
general variables known values compile time compiler afford track 
example intractable record values generated increment initially known value loop 
compiler tracks values due assignments constants simple boolean expressions 
knowing exact values compiler may able determine event definitely execute 
cases compiler generates run time tests ensure simulation correct 
discuss static simulation technique detail 
static simulation state compiler runs static simulation program compile time 
static simulation state hn captures conservative approximation corresponding dynamic simulation state hn mi follows contains events may hv mi hv 
event paired may simultaneously 
contains events may ready executed currently hv mi hv 
event paired may simultaneously 
contains events may waiting executed simulation time hv di hv mi hv hv di 
event paired may simultaneously 
memory store maps variable current value 
know value variable compile time maps 
mapping var 
val val var 
val 
modify functions dynamic simulation follows oneof deterministically chooses tuple hv mi set ready events exec applies code associated event memory store returns new memory store 
variable written stored known constant subject restrictions outlined earlier 
variable written map eval evaluates boolean expression memory store returns true may variable maps false 
indicates execution event initial memory store changes value expression returns true may variable maps false 
define operator may follows may may may may may define function merge sets tuples hv mi 
assume existence similar function hv mi 
merge fhv mij hv mi may hv extend state transition function static states 
definition ensures set events currently waiting events delayed events superset corresponding event sets dynamic simulation 
define hn mi hn type transition represents execution event current simulation time step hv mi oneof exec merge fhv mi fhv eng merge fhv mig fhv ij hv bi eb eval fhv ij hv xi ex hv merge fhv di edg type ii transition represents incrementing simulation time time event occur 
min hv mi fhv mi fhv mi ag fhv mi type iii transition represents simulation static simulation event graph sequence states hn fv fg si si code generation event chosen oneof function type transition compiler emits code corresponding event 
ensure code may event executed dynamic conditions right code predicated condition evaluated run time 
compiler introduces run time boolean variable vertex event graph maintained program execution reflects corresponding event 
likewise static simulation state trigger variable introduced indicate event executed state triggered 
code generated set reset variables event 
type ii transition taken code emitted increment global simulation clock 
observe naive static simulation described may generate infinite list states event graphs 
may happen circumstances 
static simulation may reach state set ready events empty 
algorithm described far keep type transitions forever 
occur example simulating circuits feedback 

similarly static simulation may reach state delayed events empty 
occurs synchronous designs clock signals change continuously dynamic condition occurs see 
general method finding fixed points solve problems 
technique observation set possible static simulation states finite 
theorem number possible static simulation states event graph finite 
proof hv en eb ex edi sets ed finite 
relations hold jnj jv jrj jv jdj dm dm di ed equation derived observing delayed events hv triggered edge hv di 
remaining time wait greater original delay program 
finite number possible sets 
discussed earlier limit possible values constants appear program unary operators constants 
finite number possible sets finite number possible static simulation states 
compiler algorithm follows 
compiler generates new state si compares si previously generated states 
guaranteed theorem simulation eventually terminate find matching states 
match static simulation proceeds discussed 
sj matched state 
sequence static simulation states si exactly follows necessary continue simulate statically compiler produce equivalent code sequence inserting branch operation si sj creating loop consisting events sj si 
loop necessary remove elements current static simulation may continue 
remove elements corresponding events executed loop 
set events allows construct exit condition loop events ready triggered loop may exit 
finding loop continue simulation find loop simulation complete type iii transition taken 
general loops consisting type transitions generated feedback enclosed loops consisting type ii transitions clocked feedback 
vi 
optimizations algorithm previous section generates working code number optimizations useful produce efficient simulation 
continuous assignment optimizations continuous assignments represent assignments wires left hand side continuously reflects current state variables right hand side 
treating separate events inline directly code drastically reducing number events need schedule 
inlining done moderation limit increase code size 
optimization performed event graph scheduling takes place 
sensitization optimization event immediately execution sensitive simulation sensitive 
necessary test sensitivity generated code 
models case majority events 
course event driven simulation possible execute events multiple times values propagate model 
multiple executions required correct answer adversely impact simulation performance 
proper ordering event execution unnecessary events eliminated 
process generally called compiled code simulators 
add form event driven simulator intelligent events retrieved event queue 
implement compiler assigning level event graph basedon maximum length path start event 
oneof function chooses events chooses event lowest level number 
vii 
preliminary experimental results benchmarks test implementation 
thomas 
suite consists small benchmarks vary hierarchy depth partitioning operators 
benchmarks include series test vectors vectors run times produce measurable run times 
arms counter benchmark particularly interesting contains feedback 
suite contains benchmarks 
variations bit bit wise adder prototype support efficient bit operations 
final benchmark mips lite simple behavioral description mips compatible processor 
compared performance simulator vcs simulation state art commercial simulator 
vcs generate code 
cases generated code compiled mips compiler 
simulations executed silicon graphics indigo mb memory mhz processor 
scheduling overhead measured pixie tool 
results shown table 
overhead show vcs indicates amount time spent run time library manipulating event queue 
vcs optimizations reduce run time overhead bypassing event queue cases simple signal propagation 
cases uses function calls activate events 
time spent performing function calls included measurements 
overhead shows amount time spent code sets tests triggers 
absolute run time shown time spent performing scheduling tasks 
looking absolute times important realize vcs highly tuned code generator cases generates better code 
apparent gcd benchmarks poorer computational code sole reason reduced performance 
disadvantage run times faster average 
interesting time spent performing scheduling tasks 
see time spent performing event queue management vcs substantial 
average spend time vcs scheduling overhead 
interesting measure benefit tracking variable values static simulation 
comparison table 
percentage scheduling states require run time test nearly double variable tracking requiring tests entire simulation states marked variable tracking due unconditional control flow delays 
result eliminating run time tests variable tracking able reduce scheduling overhead benchmarks average times 
cases benchmark series constant test vectors compiler able determine events trigger test 
arms counter mips lite benchmarks top level clock compiler eliminate run time tests events depend clock edges 
disadvantage variable tracking number static states increase significantly 
takes longer detect cycle variable values taken account 
viii 
introduce static simulation technique general method compiling event driven models efficient simulation code 
method innovations 
general event graph succinctly captures semantics event driven simulation 
second general technique partial evaluation schedule events possible statically available benchmark absolute runtime sec scheduling overhead sec name vcs speedup vcs speedup alg block arms counter gcd mips lite average table comparison run time speed scheduling overhead vcs 
variable tracking variable tracking benchmark schedule scheduling schedule scheduling overhead name size overhead size overhead speedup alg block arms counter gcd mips lite average table comparison scheduling overhead variable tracking 
times seconds 
information 
general technique applied uniformly optimize simulation arbitrary models including containing feedback delay 
prototype implementation simulator uses suif compiler system 
achieve average speedup compared vcs benchmarks 
importantly average scheduling overhead amounts vcs code 
acknowledgments john randy allen help vcs brian murphy help document 
carter rosen rutledge hss high speed simulator ieee transactions computer aided design vol 
pp 
july 
hansen hardware logic simulation compilation th acm ieee design automation conference pp 

shriver sakallah assigned delay compiled code logic simulation proceedings ieee international conference computer aided design pp 
nov 
wang maurer event driven compiled logic simulator th acm ieee design automation conference pp 

lewis hierarchical compiled code event driven logic simulator ieee transactions computer aided design vol 
pp 
june 
ulrich herbert speed accuracy digital network simulation structural modeling th acm ieee design automation conference 
wilson french wilson amarasinghe anderson tjiang 
liao 
tseng hall lam hennessy suif infrastructure research parallelizing optimizing compilers acm sigplan notices vol 
pp 
dec 
thomas benchmark descriptions comparing performance verilog vhdl simulators proceedings international verilog hdl conference pp 
mar 
