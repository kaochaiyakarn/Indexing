homology homotopy applications vol pp geometry intuitionistic proofs jean goubault eric goubault communicated gunnar carlsson curry howard correspondence formulas types proofs programs proof simplification program execution holds intuitionistic modal logic 
turns modalities translate monoidal comonad space proofs giving rise canonical augmented simplicial structure 
study geometry augmented simplicial sets showing type gives rise augmented simplicial set disjoint sum nerves finite lattices points plus isolated gamma dimensional 
application give semantics modal proofs programs categories augmented simplicial sets topological spaces prove completeness result style friedman proofs denotations augmented simplicial model convertible 
result rests fine geometric structure constructed spaces proofs properties categories categorical generalization notion logical relations lambda calculus 

successful paradigms modern theoretical computer science called curry howard isomorphism easy surprising connection proofs intuitionistic logics functional programs far reaching consequences 
cardinal principle logics help design crafted programming constructs semantical properties 
intuitionistic logic implications denote function spaces conjunctions give rise cartesian products disjunctions disjoint sums false empty type true unit type universal quantifications polymorphic types existential quantifications author acknowledges gie common venture bull inria part accomplished 
received october revised published 
mathematics subject classification key words phrases comonads completeness curry howard correspondence distributivity laws comonads intuitionistic logic lambda calculus logical relations modal logic presheaves resolution functors simplicial sets 
cfl jean goubault eric goubault 
permission copy private granted 
homology homotopy applications vol 
data types 
classical logic addition introduces rich concept continuation modal logic introduces form staged computation :10.1.1.28.4059
aim show proofs geometric objects 
precise formulas correspond augmented simplicial sets proofs correspond maps spaces 
particular extends picture logic programming geometry formulae types augmented sets proofs programs augmented simplicial maps equality proofs convertibility equality maps signs exact possibly programs augmented simplicial maps get definable augmented simplicial maps 
particular known equality proofs defined symmetric closure detour cut elimination exactly convertibility terms programs 
shall addition show definable augmented simplicial maps equal defining terms convertible equal proofs bottom right sign 
theorem corollary variant friedman theorem constitute main goal 
friedman theorem ordinary non modal intuitionistic case proved relatively straightforward way logical relations case complex require establish existence certain strong retraction augmented simplicial set hom delta oe corollary 
way invite reader check existence corresponding strong retraction category sets needed map techniques non modal case trivial 
existence announced retraction category delta augmented simplicial sets involved prompts study geometry proofs 
plan follows 
review related section deal logical preliminaries section 
start recalling basic concepts logics section go curry howard correspondence types formulae proofs programs equality proofs convertibility section 
introduce logic shall minimal intuitionistic giving kripke semantics section natural deduction system proof term language essentially due 
section prove basic properties confluence strong normalization typed terms study structure normal called long normal forms 
come meat section observe type induces augmented simplicial set simplices terms type lambda modulo ss 
characterize exactly computation faces degeneracies terms written long normal form section take particularly simple form 
allows study geometry terms precise way section 
crucial notion oriented contiguity oriented form path connectedness 
turns allows characterize simplicial part augmented simplicial sets nerve points homology homotopy applications vol 
ordered contiguity oriented simplicial complex 
dimension gamma get connected components simplicial complexes show section 
show non empty connected component finite lattice points simplices 
section turn important construction augmented simplicial sets planes 
lattice structure able show augmented simplicial maps projecting space planes mild conditions 
essential ingredient showing hom delta strongly retracts oe announced 
section reverses picture shows may interpret proofs augmented simplicial maps 
general may interpret proofs cartesian closed category ccc strict monoidal comonad called strict cs categories shown section section 
give examples strict cs categories section 
section show additionally typed calculus way describing free strict cs category set base types 
particular strict cs categories offer sound complete way describing terms equalities 
categories general constructions need concrete 
able compare proofs looking strict cs category concrete ones particular category delta augmented simplicial sets 
show terms get interpreted faithfully delta section friedman theorem prove variant kripke logical relations indexed category delta essential way strong retraction hom delta oe constructed section 
review logical relations section explain generalized form kripke logical relation case 
complex better viewed categorical viewpoint section establish basic lemma section bounding lemma section main ingredients equational completeness theorem section 
proof minor theorems elided 
please refer full report fuller proofs 

related possible misunderstanding 
part concerned logic proof theory study proof terms programming language validity provability 
reader interested categorical models validity modal case referred 
line known topological interpretation lambda modality due kuratowski follows interpret formula subset topological space lambda interior 
general operator works 
note interpretation collapses lambda lambda lambda interpretations lambda 
fact lambda compared lambda interpretations easier reason proof terms directly proofs 
particular homology homotopy applications vol 
convenient reason church calculus natural deduction proofs 
bierman de paiva language proof terms 
suitable proposals :10.1.1.28.4059
particular dispenses boxes terms represent lambda rules operators non negative indices corresponding dimensions 
augmented simplicial structure language apparent syntax language turned convenient technically 
proof terms partial evaluation run time program generation higher order syntax idea type values type delayed computations values type terms denoting values type evaluates computations terms return values lifts delayed computation doubly delayed computation value :10.1.1.28.4059
similar eval quote lisp processes evolving time say starting homing values argued unpublished 
similar viewpoint brookes geva comonads enriched called computational comonads adding natural transformation fl identity functor allowing lift value just computation computation fl ffi fl id ffi fl fl ffi fl delta fl induces contracting homotopy gamma gamma gamma fl gamma build resolutions chain complexes 
comonads need computational sense role contracting homotopies clearer pondering proposition construction lemma 
tempting compare computational comonads moggi computational calculus cccs strong monad 
nice relation mendler propositional lax logic 
brookes geva special connection computational comonads strong monads 
sense express similar concerns programming language theory 
shown strong monads best understood existential dual sigma lambda futures 
kobayashi deals calculus containing lambda sigma pfenning davies give improved framework combining lambda sigma show lax logic naturally embedded :10.1.1.17.1563
classical negation provides natural link modalities intuitionistic logic link 
gor cogent intuitionistically valid connection existential universal modality provided existential modality defined monad left adjoint lambda sense moggi strong monad written tense logic modality upsilon past upsilon oe provable oe lambda duality reflected programming language semantics lambda type computations values upsilon type values produced computations geometrically upsilon builds space cones space soon connected may defined categories topological spaces augmented simplicial sets turns cone modality strong monad 
existentials upsilon hard deal establishing equational completeness homology homotopy applications vol 
results won consider 
notion logical relation strong monads developed may help 
hope studies kind help understand connections computation logic geometry 
relation geometric ways viewing computation distributed computation clarified 
interesting piece intersection logic linear logic simplicial geometry provides sophisticated models multiplicative exponential fragment linear logic affine simplicial spaces extra homological constraint 
note strong links linear logic see 

logics curry howard correspondence 
logics consider logic specified set deduction rules 
got notion formula plus notion deduction proof 
formulas deduce called theorems 
example minimal propositional logic smallest non trivial logics formulas grammar oe ranges propositional variables fixed set sigma oe implication 
logic called minimal removing operator oe leave skinny called logic 
deductions standard hilbert system intuitionistic minimal logic axioms oe oe oe oe oe oe oe oe range formulas oe associates right oe oe abbreviates oe oe modus ponens rule oe mp allows deduce proofs oe third level apart formulas proofs proof simplifications 
consider example proof oe oe delta delta delta ss oe delta delta delta ss mp may simplified just proof ss idea proofs may simplified simplification longer obtaining equivalent normal proofs pioneered gerhard gentzen give proof sense hilbert consistency order peano arithmetic 
logical system homology homotopy applications vol 
proper way gentzen sequent calculus easy see false normal proof rule lead proof false 
false proof proof ss false simplified normal proof false exist 
hilbert systems really suited task shall natural deduction systems section 

curry howard correspondence note reading logic 
consider formula set oe denote set total functions set set proofs inhabitants sets interpret step proof function returning function takes returns interpret complex functional takes oe oe oe returns ss proof oe function ss mp builds ss ss element syntactically build programming language defining terms constants mn denotes application 
language called combinatory logic 
may restrict typed terms typing rules type oe oe type oe oe oe oe oe oe type oe type mn type may written typing judgments assign term type typing rules oe oe oe oe oe oe oe oe oe mp mn note formal similarity proof rules mp 
typing rule converted proof forgetting terms 
conversely proof converted typing derivation labeling judgments suitable terms 
furthermore typable term unique called principal typing typings recovered hindley theorem 
constitutes half called curry howard correspondence programs terms proofs 
subscripting types meant occurrence term isomorphism typable terms proofs 
introduce second half curry howard correspondence proof simplification steps give rise program reduction rules natural choice kmn mp 
turns reduction rules give rise notion computation term program reduced normal term reached 
reduction process exactly proof simplification process described 
homology homotopy applications vol 

natural deduction lambda calculus language hilbert systems combinatory logic easy done 
comfortable choice church calculus programming language associated minimal logic natural deduction format 
terms grammar xj delta jm ranges variables delta abstraction function maps typically depends 
convenience write mn mn application associates left delta delta delta delta typing proofs described sequents mere formulae 
sequent expression form meaning type assumptions type 
type needed type abstractions 
context 
list bindings distinct 
shall usually write gamma theta contexts 
notation gamma denotes provided 
typing rules ax gamma oe gamma delta oe gamma oe gamma oe gamma mn computation proof simplification described fi reduction rule delta denotes capture avoiding substitution may add reduction rule delta mx provided free necessary proof normalization reduction allows get extensional notion function functions equal provided return equal results equal arguments 
corresponds reducing proofs axiom sequents proofs consisting just ax rule proof theoretically 

minimal intuitionistic topic intuitionistic modal logic 
simplicity consider minimal intuitionistic captures core logic formulae types defined oe lambda ranges fixed set sigma base types 
adding conjunctions truth pose new problems noted adding disjunctions falsehood upsilon innocuous theorems 
usual semantics classical kripke semantics 
kripke frame preorder valuation ae mapping base types sigma sets worlds intended true define formula holds world ae abbreviated ae ae ae ae oe ae ae ae lambda ae think lambda meaning holds 
homology homotopy applications vol 
idea truth value formula may depend time natural physics electron gone left slit may hold time intuitionistic may refine semantics formulae include worlds accounting intuitionistic forcing 
intuitively may ordering states mind mathematician typically ordering sets basic facts mathematician knows analogy due brouwer 
mathematician knows oe state mind abbreviated oe knows know knowing oe state mind means mathematician extended state mind larger allows deduce able deduce state mind 
intuitionistic meaning oe oe knowing negation state mind means knowing hold hold state mind extending distinguishing feature intuitionistic logic may case formulae negation hold state mind think unsolved conjecture classical tautology hold general 
kripke semantics intuitionistic follows 
definition kripke semantics 
intuitionistic kripke frame triple valuation ae map base types sigma upper sets worlds upper set subset semantics formulas ae iff ae ae oe iff ae ae ae lambda iff ae formula valid written ae frame valuation ae 
resulting logic called ints condition relating 
ffi ffi case preorder equivalent analogy states mind mathematician worth condition intuitively states learn new basic facts increase time passes time may pass learning new facts 
mentioned upsilon modality section 
expected semantics ae upsilon ae modalities xi sigma naturally defined intuitionistic modal logic introducing new binary relation needs converse letting ae xi ae ae sigma ae 
constraints addition homology homotopy applications vol 
ffi ffi denotes converse relation 
natural deduction intuitionistic shall interested validity formulas actual proofs formulas 
talk proofs 
language proof terms 
raw terms mn delta dm delta explicit substitution substitution appears explicit component terms 
substitution finite mapping variables terms written fx domain dom set fx 
omit type subscript variables convenient 
yield defined dom fv mutually recursively set free variables fv term fv fxg fv fv fv fv delta fv fxg fv dm fv fv delta 
equality definition 
assume term delta fv dom assume barendregt naming convention variable occurs free bound bound different places bound variables delta variables dom delta 
notations differ 
delta fx written box new notation allows materialize explicit substitution naturally second frame notation put explain simplices look 
dm written unbox dm concise hints face operator 
substitution application defined dom mn delta delta provided dom dm delta delta delta substitution concatenation delta defined fx delta fx terms equated modulo ff conversion smallest congruence delta delta mfx yg delta fx fx delta fy provided free case 
free pairwise distinct second case identical type subscripts 
respectively 
operator kind eval comma operator language lisp 

delta operator complex 
look special case term fv fx delta fx formally mfx delta fx behaves quote lisp ex homology homotopy applications vol 
backquote provided dom fv delta exactly syntactic closure sense quoted term environment mapping free variables values :10.1.1.18.3867
ax gamma theta gamma oe gamma oe gamma mn gamma oe gamma delta oe gamma lambda lambda gamma dm gamma lambda lambda lambda lambda gamma delta fx lambda typing terms typing rules defining natural deduction system minimal gamma theta 
typing contexts lists bindings variable type bindings contain variable context 
exchange rule gamma theta gamma theta easily seen admissible consider typing contexts multisets lists 
particular choice order variables 
right premise rule lambda 
fi delta mfx delta gc delta fx ng delta provided fv ctr delta fx fy xg delta fx ng lambda delta fx delta mfx delta delta provided fv lambda dx delta fx reduction relation define reduction relation terms smallest relation compatible term structure denotes term distinguished occurrence defined 
terms match left hand side rules called redexes reduction ex pression 
convertibility relation ss smallest congruence extending words ss reflexive symmetric transitive closure 
addition write transitive closure lambda reflexive transitive closure 
homology homotopy applications vol 
rule lisp rule evaluating quoted expressions evaluating reduces rule lambda seen inlining rule allowing inline definition inside body box logically box box commutation rule 
gc garbage collection rule ctr contraction rule 
new notation rules substitutions disjoint domains denotes obvious union 
rules called extensional equalities 
gc lambda allows deduce dx delta ss dm delta ss term variable 
discussion see 

standard properties subject reduction confluence strong normalization prove standard properties proof simplification calculi 
lemma series easy tedious computations says reduction preserves typings alternatively rewrites proofs proofs sequents 
lemma subject reduction 
typing judgment gamma derivable gamma derivable 
proposition strong normalization 
typable strongly normalizing reduction sequence starting finite 
proof 
reducibility method 
sn set strongly normalizing terms define interpretation types sets terms follows ffl base type jjajj sn ffl jjf oe gjj fm sn lambda delta jjf jj fx ng ffl jj lambda jj fm sn lambda delta jjf jjg observe cr jjf jj sn type cr jjf jj jjf jj 
structural induction clear base type 
implications assume jjf oe gjj sn lambda delta lambda delta definition jjf oe gjj fx jjf jj jjf oe gjj 
case box types proved similarly 
cr neutral term jjf jj jjf jj 
call term neutral form delta delta 
structural induction clear base type 
implications assume jjf oe gjj show jjf oe gjj 
clearly sn reduction starting empty go jjf oe gjj sn cr 
assume lambda delta neutral reduction non empty homology homotopy applications vol 
lambda delta assumption jjf oe gjj jjf jj fx 
follows jjf oe gjj 
case box types similar 
show 
jjf oe gjj jjf jj mn 
cr sn prove induction pair ordered lexicographically 
note mn neutral may rewrite step mn fx ng fi delta 
cases jjf oe gjj resp 
jjf jj cr may apply induction hypothesis 
third case definition jjf oe gjj 
case get term cr 

mfx jjf jj delta jjf oe gjj 
show show converse jjf jj mn jjf oe gjj 
sn take variable jjf jj cr mx assumption mx sn cr sn 
second assume lambda delta jjf jj lambda fx ng cr 
jjf oe gjj 
assume fx jjf jj show delta jjf oe gjj 
show delta jjf jj 
induction ordered founded jjf jj sn cr mfx xg sn cr jjf jj cr 
delta neutral apply cr delta may rewrite delta cr induction hypothesis delta similar mfx fi assumption free mfx assumption 

jj lambda jj dm jjf jj 
induction ordered founded cr sn dm may rewrite dm apply induction hypothesis noting jj lambda jj cr dm jjf jj provided delta jjf jj definition 
dm neutral cr dm jjf jj 

jjf jj maps variable dom strongly normalizing term delta jj lambda jj 
show converse dm jjf jj jj lambda jj 
dm jjf jj sn cr sn 
remains show lambda delta jjf jj 
dm lambda jjf jj cr 
knowing jjf jj map variable dom strongly normalizing term 
show delta jj lambda jj 
converse shown show delta jjf jj 
shall prove cr delta neutral 
letting fx show induction ordered multiset homology homotopy applications vol 
extension immediate relation known soon founded part founded part multiset extension allows replace element multiset finite number smaller elements founded multisets elements taken founded part underlying ordering second lexicographically 
delta may rewrite step ffl jjf jj assumption 
ffl dn lambda dx 
dn jjf jj assumption 
ffl delta cr jjf jj may apply induction hypothesis 
ffl delta fx sn may apply induction hypothesis 
ffl delta fx ng free gc 
induction hypothesis 
argument applies ctr 
ffl mfx delta fx delta lambda 
wish apply induction hypothesis 
check mfx jjf jj 
jjf jj equals fx delta equal rewrites gc fx mfx jjf jj cr 
check typing derivation ss jjf jj 
jjf jj fx jjf jj 
structural induction ss 
ax cas obvious cases dealt items 
jjf jj cr follows jjf jj 
cr sn 
proposition confluence 
typable lambda lambda lambda lambda proof 
long uninteresting series computations shows critical pairs joinable locally confluent 
holds typable terms lemma 
newman lemma locally confluent strongly normalizing rewrite system confluent proposition confluent typed terms 
corollary 
typable term unique normal form 

shape normal forms long normal forms way describing normal forms typed terms typing system bn 
lemma 
call term beta normal contains fi gc lambda redex redex possibly ctr lambda redexes 
homology homotopy applications vol 
ax gamma theta gamma oe gamma oe gamma mn gamma lip gamma gamma lambda lambda gamma dm gamma oe gamma delta oe gamma lambda lambda lambda lambda gamma delta fx lambda fv fx typing beta normal forms system bn gamma beta normal gamma neutral starting box gamma conversely gamma gamma gamma beta normal 
proof 
structural induction derivation gamma cases variable form delta trivial 
gamma oe gamma neutral typing start fi redex 
induction hypothesis gamma oe induction hypothesis gamma follows rule oe gamma case dm similar 
form delta fx gamma lambda lambda lambda induction hypothesis lambda lambda gc redex fv fx neutral typing start box forbidden lambda redex induction hypothesis gamma lambda follows rule lambda applies gamma lambda conversely gamma gamma obvious gamma erase subscripts remove instances lip 
remains show beta normal 
consider subterm form type derived oe rule implies typed gamma oe rule bn allow derive judgment began fi redex 
similarly subterm redex 
side conditions rule lambda entail subterm gc redex fact lambda derived judgment entails starts box subterm lambda redex 
beta normal 
convenient form normal forms long normal form imitating non modal case 
case long normal forms slightly homology homotopy applications vol 
complex described follows including additional linearity constraint boxes 
definition long normal form 
call term linear free variable occurs exactly formally define notion linear finite set variables follows 
variable linear delta linear provided linear fxg linear provided fv fv linear provided delta fx linear provided linear fv fv term linear provided linear fv 
call lip rule lip restricted case set sigma base types lambda rule lambda restricted case linear 
call bn typing system bn instances lip instances lip instances lambda instances lambda 
term said long normal type gamma derive gamma system bn lemma weakening 
bn derivation gamma lambda lambda fi context theta bn derivation gamma theta lambda proof 
structural induction derivation 
obvious provided assume bound variables renamed distinct ones theta lemma 
gamma long normal form 
term ss gamma proof 
proposition lemma may assume gamma idea rewrite instance lip non base types instances lip smaller types get instances lip 
done rules gamma oe lip gamma oe gamma gamma oe ax gamma lip gamma oe gamma mx lip gamma mx oe gamma delta mx oe gamma lambda lip gamma lambda gamma gamma lambda ax lambda lambda lambda lambda dx lip lambda dx lambda gamma dx delta fx mg lambda right hand side rule derivation gamma oe obtained gamma oe weakening lemma 
homology homotopy applications vol 
terminates sum sizes formulae right hand sides judgments lip decreases define size jf formula jaj jf oe gj jf jgj lambda jf 
hand instance lambda lambda linearizing term free variable distinct occurrences create fresh variables iki jth occurrence replaced ij rewrite derivation gamma lambda lambda lambda lambda gamma delta fx lambda ki gamma lambda ij lambda ki lambda gamma delta ij ki lambda lemma 
gamma long normal form type gamma proof 
long normal form beta normal construction 
rewrite system consisting rules lambda 
clear terminates rewrites beta normal terms beta normal terms 
similarly rewrite system ctr consisting sole rule ctr terminates rewrites normal beta normal terms normal beta normal terms 
normal form ctr normal form ctr normal normal beta normal normal 
long normal form ss ss proposition normal lambda summing lambda lambda rj lambda denotes rewriting observe rewrite system gamma ctr derivations defined transformation fy xg delta fx ng delta fx free locally confluent 
typed beta normal rewrites ctr rewrites gamma ctr gamma ctr terminates term fv gamma number occurrences induction followed lexicographically multiset terms dom ordered gamma ctr delta gamma ctr terminating soon dom follows structural induction terms term gamma ctr terminating 
similarly rewrite system gamma derivations defined terminating noticed lemma locally confluent typed beta normal rewrites rewrites gamma homology homotopy applications vol 
long normal form lambda lambda gamma ctr lambda gamma general long normal forms get lambda lambda gamma ctr lambda gamma lambda lambda gamma ctr lambda gamma gamma ctr confluent gamma ctr normal gamma confluent long normal gamma normal lemmas entail proposition long normalization 
term gamma derivable unique long normal form type gamma write 
particular gamma gamma ss 
value long normal forms substituting terms certain form variables long normal form yields long normal form lemma 
theta lambda lambda fi gamma system bn gamma theta lambda mfx system bn proof 
structural induction derivation theta lambda bn derived ax lambda fx may deduce gamma theta weakening gamma lemma variable fx get gamma theta ax 
rule oe lambda lip induction hypothesis straightforwardly 
rule oe lambda form delta form oe induction hypothesis able derive gamma theta fx get gamma theta mfx oe oe 
rule lambda lambda form lambda form delta fy fv fy linear typing derivation ends theta lambda lambda lambda lambda theta delta fy lambda induction hypothesis got derivation bn gamma theta fx lambda derivation lambda lambda fv fy linear may apply lambda derive gamma theta delta fx fx gg lambda precisely gamma theta mfx lambda homology homotopy applications vol 
lemma 
long normal type lambda gamma form delta 
dm 
proof 
part obvious gamma lambda system bn rule lambda lead 
letting fx lambda lambda bn gamma lambda bn lemma gamma bn dm ss proposition dm 
crucial thing lemma dm ss obvious 
fact reduced delta reached long normal form 
similarly obtain lemma 
sm delta fx mg 
delta long normal type lambda gamma sm delta 
proof 
sm delta fx delta ss delta 
long normal letting fx lambda lambda bn gamma lambda bn produce bn derivation delta delta delta gamma ni lambda fi axe lambda xn lambda fn xi lambda fi delta delta delta lambda xn lambda fn lambda lambda xn lambda fn lambda lambda gamma delta lambda lambda delta long normal type lambda lambda gamma claim follows proposition 

augmented simplicial structure define augmented simplicial set consisting typed terms 
recall definition set map 
augmented simplicial set family sets gamma simplices simplices dimension face maps gamma degeneracy maps gamma ffi gamma gamma ffi ii ffi gamma ffi iii ffi gamma gamma ffi iv ffi id ffi id vi gamma ffi ffi iv 
augmented simplicial map family maps gamma ffi gamma ffi ffi ffi homology homotopy applications vol 
subscripts start gamma standard allows match geometric dimension 
abbreviate augmented simplicial sequel 
run risk confusion write kq kq category delta augmented simplicial sets objects augmented simplicial maps morphisms see vii follows 
delta category objects finite ordinals qg gamma morphisms monotonic non decreasing maps 
category generated morphisms gamma ffi gamma mapping oe gamma mapping gamma relations succinctly described vi replaced ffi oe composition order reversed 
delta category functors opposite category delta category set sets 
general denotes category functors set presheaves elementary topos cartesian closed category ccc 
terminal object delta singleton lambda gamma 
product theta theta theta theta kq lq theta kq lq product component wise 
structure exponentials internal homs hom delta general constructions largely irrelevant 
just say got application maps app hom delta theta abstraction operator lambda maps theta lambda map hom delta satisfying certain equations specified 
furthermore gamma simplices hom delta just simplicial maps simplices homotopies maps simplices higher dimensional homotopies 
general ccc just delta denote unique morphism gamma 
cartesian products pair hf gi gamma theta gamma gamma projections theta ssi gamma 
internal hom objects exponentials hom application hom theta app gamma abstraction lambda gamma hom theta gamma obey categorical combinator equations omit types objects sake conciseness id ffi ffi id ffi ffi ffi ffi 
delta 
ss ffi hf gi ss ffi hf gi hss ss id hf gi ffi hf ffi ffi hi lambda ffi lambda ffi hh ffi ss ss app ffi lambda gi lambda app ffi hf ffi ss ss ffi hid gi reasons convenience shall abbreviate hf ffi ss ffi ss theta derived equations id theta id id theta ffi theta ffi theta ffi lambda ffi lambda ffi theta id app ffi lambda ffi gi ffi hh gi app ffi lambda theta id lambda app ffi theta id homology homotopy applications vol 

augmented simplicial sets gamma observe modality allows exhibit augmented simplicial structure 
shall see section arises comonad certain resolution functors 
prefer remain syntactic relatively concrete 
definition gamma 
context gamma type gamma set equivalence classes terms gamma derivable modulo ss 
gamma gamma gamma lambda gamma family gamma gamma function gamma theta theta gamma gamma define lambda function gamma lambda theta theta gamma lambda gamma lambda maps tuple dx dx delta fx say substitutive ss 
function gamma gamma gamma defined lambda function gamma gamma defined lambda sm delta fx mg 
lemma 
hold 
lambda id id 
substitutive lambda ffi lambda lambda ffi 

lambda substitutive 

substitutive 
proof 

lambda id dx delta fx mg ss lambda lambda id id 
functions provided substitutive lambda lambda dx delta fx dy delta fy mgg ss dx fx dy delta fy mg lambda ss dy delta fy mg substitutive ss dy delta fy mg lambda ffi lambda lambda ffi 

obvious 
follows 
proposition 
gamma triple gamma augmented simplicial set 
proof 
lemma check vi case general case follows immediately induction gamma lambda gamma gamma gamma gamma dx delta fx ss gamma gamma dm gamma gamma 
homology homotopy applications vol 
ii gamma delta fy gamma mg lambda gamma gamma dy delta fy mg gamma dy delta fy delta fx mgg ss gamma delta fx lambda ss gamma delta fx mg 
gamma delta fy delta fx mgg ss delta fx mg lambda delta fx precisely 
obtains gamma delta fy gamma delta fy lambda gamma gamma mg delta fy gamma gamma dx delta fx mgg ss gamma gamma dx delta fx mg lambda lambda gamma gamma delta fx mg gamma delta fx mg exactly 
iii lambda gamma gamma gamma gamma dx delta fx ss gamma gamma dm gamma gamma 
iv delta fx ss 
lambda dx delta fx delta fy mgg ss delta fy lambda ss dy delta fy mg ss lambda 
vi gamma gamma lambda gamma gamma delta fx gamma gamma dy delta fy mgg ss gamma gamma dy delta fy mg lambda delta fy mg hand lambda delta fy mg dx delta fx delta fy mgg ss delta fy lambda ss delta fy mg 
lemma long normal form term type lambda gamma written unique way delta delta gamma delta fix variable fx 
delta delta gamma delta gamma basically sequences substitutions additional typing linearity conditions conditions domains substitutions 
compute faces degeneracies act long normal forms 
short call long normal form simplex gamma unique long normal form type lambda gamma lemma help compute long normal forms lambda applied arguments long normal form 
homology homotopy applications vol 
lemma 
function gamma theta theta gamma gamma 
say linearity preserving long normal form type gamma 
long normal form type gamma 
linear long normal form type gamma linear 
abuse write long normal form 
say non collapsing long normal forms type gamma 
type gamma fv fv fv 
delta 
delta long normal forms respective types lambda 
lambda gamma assume loss generality 
pairwise disjoint domains 
substitutive linearity preserving non collapsing long normal form type gamma lambda delta delta exactly delta 
proof 
lambda delta delta dx dx delta fx delta delta ss dx dx fx delta lambda ss delta substitutive ss delta 
remains show long normal type lambda gamma allow proposition 
check fv dom dom linear 
non collapsing fv dom linearity preserving linear 
fv dom linear delta long normal 
proposition 
gamma long form delta delta gamma delta long form delta delta gamma delta delta delta delta gamma delta long form delta delta gamma delta delta id delta delta id identity substitution dom homology homotopy applications vol 
proof 
induction simultaneously fact substitutive linearity preserving non collapsing 
inductive case lemma 
base case lemma lemma 
geometry gamma close nerve category objects contexts gamma morphisms gamma gamma theta substitutions letting theta form fy gamma derivable identities identity substitutions composition substitution concatenation 
quite nerve added conditions substitutions 
connection nerves precise theorem 

geometry gamma proposition note substitutions taken particular modulo ss 
hints fact gamma general kan complex recall nerve small category kan groupoid morphisms isomorphisms 
category substitutions isomorphisms renamings fx pairwise distinct variables 
proposition 
gamma kan general 
proof 
kan imply particular simplices simplex write long normal forms delta delta delta delta condition means delta delta delta delta 
particular renaming variables free delta delta exists form delta delta delta renamings bound variables entails delta entails delta follows instance particular 
instance substitution substitution form delta guarantee 
example take fx dx fx fx dx fx fx dx easily checked gamma type lambda gamma formula gamma lambda settles case gamma contains formula form lambda gamma empty easy see gamma empty possibly homology homotopy applications vol 
dimension gamma trivially kan geometry simplicial sets uninteresting 
notion useful studying geometry gamma definition contiguity 
augmented simplicial set 
simplex step contiguous simplex short simplex indices simplex contiguous lambda strictly contiguous say contiguous reflexive symmetric transitive closure 
contiguity usually bit differently 
particular usually required step contiguity 
lambda equivalence relation 
shall need finer notion sequel 
lemma example unusual lemma 
relation founded gamma 
proof 
define measure simplices gamma long normal form delta delta tuple ordered lexicographically left right size defined obvious way 
simplices gamma assume simplex say delta delta delta delta delta delta delta gamma delta delta delta delta delta delta delta delta delta delta clearly 
claim 
lexicographic ordering sizes founded establish result 
assume contrary 
delta renaming bound variables delta id gamma 
imply gamma 
map variables variables 
linearity constraints long normal forms 
homology homotopy applications vol 
renaming bound variables gamma id contradicting corollary 
relation gamma strict ordering 
proof 
reflexive infinite decreasing chain definition vertices component 
augmented simplicial set 
simplex vertices simplices iterated faces ith vertex gamma component ss known simplex exactly vertices possibly equal 
vertices contiguous lemma 
augmented simplicial set 
simplex lambda lambda lambda proof 
show lambda simplex gamma 
observe need take case simplices lemma 
relation transitive simplices gamma 
proof 
note simplices means simplex assume simplex delta delta delta delta delta 
simplex delta delta delta delta delta 
comparing forms renaming bound variables delta delta delta delta valid simplex 
take delta delta delta corollary lemma shows basically simplices contiguous unique way lemma face lemma 
simplices gamma 
simplex gamma homology homotopy applications vol 
proof 
assume exists write delta delta delta write delta delta delta delta delta delta renaming bound variables 
gamma gamma delta 
renaming bound variables 
gamma gamma delta 
particular 
gamma gamma 
determined uniquely soon 
determines uniquely possibly additional equations delta means variable dom free term range determines uniquely 
case gamma lemma condition vertices needs satisfied vertices simplex proposition 

simplices gamma 
lambda lambda lambda unique simplex proof 
lemma show uniqueness induction 
obvious 
induction gamma simplex vertices gamma simplex vertices gamma simplex vertices 
lemma 
existence write delta unique simplices delta delta renaming bound variables delta note delta define delta gamma delta gamma delta delta particular gamma gamma delta gamma gamma delta delta gamma delta gamma delta delta delta homology homotopy applications vol 
delta gamma delta delta delta delta delta gamma delta delta delta delta sum non augmented part gamma characterized particularly simple nerve theorem nerve theorem 
gamma partial order consisting simplices gamma ordered contiguity lambda non augmented simplicial set gamma isomorphic nerve gamma 
proof 
recall nerve category diagrams fq gamma aq gamma fq aq simplices 
morphisms 
ith face obtained removing sequence composing neighboring arrows dropping ith degeneracy obtained duplicating adding identity morphism 
lemma proposition simplices bijection ordered sequences simplices lambda lambda lambda gamma jth vertex gamma gamma gamma ae vertices similarly jth vertex gamma gamma vertices sequence occurring twice 
words gamma oriented simplicial complex 
recall oriented simplicial complex family linearly ordered sequences called points containing element sequences subsequence element family family 
fact full oriented simplicial complex containing linearly ordered sequences points 
futile study classical notions loop homotopy oriented simplicial complex 
loops trivial simplex loop point sequence vertices lambda degenerate simplex 
homotopies loops fact natural extension homotopies simplices trivial simplices homotopy simplex connecting faces plus degenerate simplex sequence vertices lambda lambda lambda lambda follows homotopy degeneracies homology homotopy applications vol 
short simplices homotopic classical sense equal homotopies degenerate 
studying homotopies paths just loops certainly remains interesting 
particular geometry preorders lattices viewed order complexes rich domain 

components section closes case non negative dimensions 
dimension gamma recall extremal ways build augmentation simplicial set see 
exemplified nerve construction augmented simplicial sets builds augmentation simplicial set gamma element set empty set empty unique function gamma builds gamma set connected components set equivalence classes points 
turns augmentation built gamma gamma simplices component simplex 
words components exactly path connected components plus isolated gamma dimensional simplices 
shown proposition 
observe proposition lattice points 
gamma simplex gamma 
set simplices equipped ordering lambda empty finite lattice 
proof 
written unique way delta names free variables finitely 
finite 
rest proof fix typing way subterm gets unique type 
allow reason induction general terms bn derivation gamma note delta lambda delta delta delta lemma delta delta delta renaming bound variables substitution words instance pair points supremum lambda lambda lambda lambda lambda write delta delta exists common instance easy see common instance instance instance generally finite set variables collect bound variables call instance away term dom 
common instance away linear computed 
define unique substitution dom fv free variables free variables boxed types 
delta typed term lambda lambda instance homology homotopy applications vol 
delta delta delta fxg dn dn delta fx delta fx delta fx common instances instance construction supremum 
unification :10.1.1.36.6957
key basically need unification modulo empty theory theory relation ss 
write symmetrically pair points infimum lambda lambda lambda lambda lambda write delta delta calling generalization term away term having instance away may compute greatest common generalization away letting delta delta delta fxg dn dn delta fx delta fx delta fx greatest common generalizations unique substitution fv dom delta typed term conclude infimum write remains show empty element greatest element 
obvious defined finite infimum homology homotopy applications vol 
elements finite supremum elements 
proposition 
simplices gamma proof 
clearly simplex conversely assume name gamma simplex 
proposition element lambda lambda particular words non empty components coincide path connected components 
generalizes higher dimensions proposition 
simplices gamma ss ss proof 
recall ss denotes component definition 
simplex ss ss ss conversely assume ss ss vertex 
nerve theorem equate simplices ordered sequences vertices 
notice sequence contiguous soon st face ith face sequence iterating obtain sequence contiguous soon lambda recall vertex 
proposition viewed sequence lambda lambda lambda contiguous lambda lambda lambda 
similarly contiguous simplex 
planes retractions show certains subspaces gamma retracts space mild conditions 
definition planes 
call type boxed form lambda call gamma boxed maps variables boxed types 
gamma context theta lambda lambda boxed subcontext gamma plane theta gamma set simplices gamma having long normal form form delta dom delta fv homology homotopy applications vol 
note types variables start lambda definition sense 
fully formal mention gamma notation theta gamma clear context 
point view gentzen style sequents term plane corresponds proof ends lambda rule followed series cuts formulae occurring left lambda rule lambda theta extension theorem proposition define simplices theta contiguous sequences points lambda lambda lambda theta components points theta gamma 
hard see theta gamma theta empty 
hand gamma theta points theta form component case component plane theta contains exactly point follows case theta discrete collection points 
lemma 
boxed subcontext theta gamma theta sub set gamma 
proof 
clearly simplex theta simplex gamma 
faces degeneracies simplices theta theta construction 
lemma 
theta boxed subcontext gamma gamma gamma simplices 
lambda theta theta 
theta proof 

delta delta theta dom free lambda instance substitution delta dom dom fv fv dom assume free dom fv 
occurs free fv 
particular free recalling theta words follows standard size considerations variable 
occurs free obtains 
delta delta theta simplicity assume theta contains exactly variable entails loss generality general theta intersection dom theta theta follows lambda hand form delta unique substitution domain fv general may compute unique substitution domain fv provided exists linear homology homotopy applications vol 
common instance 
parallels computation fx fx delta delta delta fxg dm dn dn delta fx xn mng delta fx delta fx mj notice unions substitutions defined assume linear terms away distinct subterms share free variable possibly variables 
generalize claim follows 
assume common instance away dom fv dom fv 
assume variable dom free 
easy induction terms shows variable fv nw free crucial cases definition symmetric 
particular case assume assumption fx restricted may 
claim follows 
proposition projection 
gamma boxed theta gamma augmented simplicial map ss theta projection theta gamma sub set theta coincides identity theta proof 
define ss theta simplices 
proposition define ss theta delta infimum set elements theta lambda delta 
observe gamma boxed typed valid simplex 
clear theta lambda delta 
empty exists simplex gamma 
lemma finite non empty infimum elements theta theta proposition gamma finite finite non empty infimum elements theta ss theta delta theta delta theta lambda delta construction delta minimal element delta ss theta delta 
ss theta coincides identity theta homology homotopy applications vol 
show ss theta extends map gamma theta remains show ss theta preserves components obvious contiguity dimensions 
far concerned lambda simplices gamma 
lambda fm theta jm lambda fm theta jm lambda fm theta jm lambda lambda fm theta jm lambda ss theta lambda ss theta 
projection construction show connection syntactic function space gamma oe hom delta gamma gamma 
direction easy definition syntactic application 
syntactic application map gamma oe theta gamma gamma written infix defined gamma mn lambda gamma lemma 
substitutive function gamma theta theta gamma gamma family functions lambda gamma map gamma theta theta gamma gamma 
proof 
write lambda recall lemma soon substitutive lambda ffi lambda lambda ffi 
gamma 
gamma lambda lambda lambda ffi lambda gamma 
ffi lambda ffi lambda gamma 
lambda gamma lambda gamma dx dx delta fx ss lambda gamma dx dx fx lambda gamma dn dn substitutive ffi lambda gamma lambda gamma ffi ffi lambda ffi lambda gamma lambda lambda gamma ffi lambda ffi lambda gamma ffi fact lambda gamma substitutive 
similarly claim lambda ss lambda 
follow ffi ffi claim proved induction 
lambda delta fx dy dy delta fy gg ss dy dy delta fy homology homotopy applications vol 
lambda lambda dx dx delta fx dz dz delta fz dx dx fx delta fy delta fy gg ss dz dz delta fz delta fy ss dz dz delta fz delta fy dy dy delta fy ff renaming inductive case lambda lambda lambda ss lambda lambda replacing lambda lambda desired 
corollary 
syntactic application map map 
shows may compute lemma 
gamma oe gamma long normal delta delta delta delta delta delta provided dom dom ss delta delta delta proof 
clear gamma 
delta lemma 
follows case theorem 
corollary follows application uniquely determined values components simplices dimension gamma points dimension 
follows lambda 
map gamma oe hom delta gamma gamma 
kind converse syntactic application 
intuitively calculus non modal case apply term term build delta term delta applied get mfx thing plane 
homology homotopy applications vol 
proposition 
simplex set define gamma say simplex gamma lambda ss written fy term gamma typable particular free plane lambda gamma lambda 
map sub set terms gamma lambda terms delta delta ss proof 
note syntactic sets studied may define synthetically dp dp enclosed boxes 
case 
define delta 
write long normal form delta 
lambda free variable free 
free variables restriction lambda remaining variables maps variables terms free 
assumption fy occurs direct argument 
definition 
term obtained replacing dx lambda construction long normal type gamma delta delta delta lambda simplex desired type 
long normal fv delta fv fyg fv fx fyg fyg fv fx dom fx dom lambda delta linear free variable possibly occurs exactly 
check delta ss delta dz dz delta fz delta ss delta dx delta lambda fx xg ss delta dx delta lambda fx xg ss fy delta lambda fx xg fi ss delta lambda fx xg ctr delta general case 
extend delta gamma proposition 
extend check 
delta lambda monotonic theorem 
assume simplices delta delta simplex delta delta homology homotopy applications vol 
delta words simplex delta delta delta lambda 
free variables 
similarly 
free variables observe xi conversely xi free dom free 
brief fv dom may write disjoint union restriction lambda dom fx substitution mapping xi 
particular loss generality may assume free lambda dom lambda lambda restriction fv lambda fv fx obtained replacing dx obtained replacing dx delta delta lambda delta lambda claim valid simplex 
delta linear fv delta fv fyg fv fx dom fx dom lambda delta delta lambda linear delta fv delta delta lambda fv delta fv lambda fv fv lambda fv fv fx lambda fx free lambda fv delta dom fx dom lambda claim delta delta claim notice lambda obtained lambda replacing dx obtained replacing dx obtained replacing dx follows delta lambda delta lambda delta delta lambda delta delta lambda delta second claim delta lambda fx lambda fx xg lambda fx xg free lambda dom lambda follows lambda delta lambda fx xg lambda fx xg lambda delta lambda lambda delta delta lambda delta lambda delta delta lambda delta follows 
delta lambda monotonic extends unique map dimension 
shown lambda 
injective leave reader 
say price considering slightly looser sets homology homotopy applications vol 
definition 
gamma set ss equivalence classes terms gamma lambda derivable boxed context gamma gives rise set gamma map extends naturally map written lambda oe theta 
note defined simplices typable terms typing derivations 
difference illustrated follows variable instance term typing derivations gamma ax gamma varies distinct 
clearer categorical language proposition 
injectivity lambda lambda yields embedding oe hom delta 
shall show turned inclusion part strong retraction hom delta oe 
note general results definition hull 
set gamma hull subset simplices simplices ss inherits face degeneracy operators set splits sum hulls proposition 
set splits sum gamma fxg 
particular gamma gamma 
lemma change gamma required lemma 
subset gamma assume simplex strong retraction words map proof 
simplex gamma delta gamma proposition note hull clearly remains show gamma delta gamma delta gamma 
gamma gamma gamma ss gamma 
similarly proposition 
oe strong retract im lambda lambda gamma precisely map oeg im lambda lambda gamma oe oeg ffi lambda lambda id oeg proof 
boxed context gamma fix variable gamma outside domain gamma homology homotopy applications vol 
simplex im lambda lambda gamma hom delta ss lambda lambda gamma term boxed context gamma gamma oe derivable bn long normal type oe form delta gamma derivable bn sum lambda lambda gamma delta ss app gamma simplex 
component ss app gamma equals app gamma ss gamma app gamma lambda lambda gamma delta gamma delta lambda gamma gamma combinator equations particular delta gamma ss fy gamma far typing concerned gamma derivable bn gamma gamma lambda fy gamma 
ss app gamma gamma gamma lambda gamma follows app gamma gamma gamma lambda proposition ss gamma lambda app gamma 
element gamma gamma lambda projection preserves components ss ss app gamma fy gamma construction gamma lambda ss gamma lambda app gamma gamma may proposition oeg gamma delta ss gamma lambda app gamma clearly composition maps 
check oeg left inverse lambda lambda 
check dimension theorem proposition oeg simplex im lambda lambda lambda lambda oe write unique way long normal form delta delta 
oeg gamma delta ss gamma lambda app gamma gamma delta ss gamma lambda lambda gamma gamma delta ss gamma lambda fy gamma delta gamma delta fy gamma delta fy gamma delta gamma lambda delta delta readability converted fy gamma delta long normal form ought fy gamma general linear gamma 
combining lemma im lambda lambda gamma proposition get corollary strong functional retraction 
oe strong retract set hom delta augmented simplicial map oeg hom delta oe oeg ffi lambda lambda id oeg proof 
take oeg oeg ffir im lambda lambda gamma lemma applies simplex im lambda lambda gamma lambda lambda lambda oe lambda oe lambda oe oe oe homology homotopy applications vol 

augmented simplicial models natural interpretation non modal types typed terms category set sets total functions 
interpret base types sets interpret oe set total functions terms precisely derivations interpreted total functions theta theta variable gets interpreted ith projection application interpreted function mapping theta theta abstraction delta oe interpreted function mapping theta theta function mapping currying 
arguably intended semantics terms 
particular convertible terms fi rules fij equivalent interpretation 
interpretation far note countably terms soon base type gets interpreted infinite set oe countable oe oe countable cardinality powerset proved interpretation equationally complete theorem 
typed terms type set theoretic interpretation choice interpretation base types fij equivalent 
fact fixed set theoretic interpretation value interpretation fij equivalent 
extending result modal case topic section subsequent ones 

lambda comonad delta strict cs categories case fact gamma augmented simplicial set natural investigate extension constructions intuitionistic hand category augmented simplicial sets hand 
general intuitionistic proofs interpreted ccc monoidal comonad 
ccc structure delta accounting non modal part proofs recalled section monoidal comonad definition lambda comonad delta 
set lambda denote set lambda lambda kq lambda kq map lambda lambda lambda lambda lambda lambda lambda maps kq kq respectively gamma 
cccs monoidal comonad argued proper categorical models intuitionistic 
bierman de paiva show fi sound easy check equalities gc ctr lambda lambda sound 
easy check monoidal comonad definition satisfies lambda lambda theta lambda theta lambda natural isomorphisms homology homotopy applications vol 
explicit readability purposes called strict monoidal comonad equations hold lambda id id lambda ffi lambda ffi lambda ffi lambda ffi ffi lambda lambda ffi lambda ss ss ffi id lambda ffi id lambda ffi ffi lambda ss ss lambda hf gi lambda lambda gi ffi hf gi hd ffi ffi gi ffi hf gi hs ffi ffi gi definition strict cs category 
strict cs category category strict monoidal comonad lambda 
strict cs categories categories interpret typed terms 
bierman de paiva considered non strict cs categories 
shall need strict variant exposition simpler 
particular delta comonad definition strict cs category 
lambda functor delta related functor xi 
standardly dual lambda set converse obtained letting kq gamma kq kq gamma kq obtained reversing order faces 
xi converse lambda lambda sense means natural think xi past 
announced section shall leave task investigating modalities 

topological models interesting strict cs categories 
interest topology category cghaus compactly generated topological spaces kelley spaces vii 
tempting category top topological spaces top ccc 
argued cghaus right category topology 
recall kelley space hausdorff topological space closed subsets exactly subsets intersection compact subspace closed cghaus kelley spaces objects continuous functions morphisms 
hausdorff space smallest topology containing kelley 
resulting kelley space obtained adding closed sets intersection compact subspace closed terminal object cghaus point topological space product product topological spaces internal hom hom cghaus space continuous functions compact open topology 
may equip cghaus structure strict cs category follows definition lambda comonad cghaus 
topological space path space lambda disjoint sum lambda lambda space continuous functions ff ff compact open topology 
continuous function lambda lambda lambda function mapping ff lambda ffi ff lambda homology homotopy applications vol 
counit maps ff lambda ff comultiplication maps ff lambda map 

ff tt lambda comonad fact related functor singular simplex geometric realization functors 
path comonad defined pointed topological spaces lambda point lambda pointed constant path point 
standard path comonad right adjoint cone comonad fundamental homotopy homology see 
shall see path comonad right adjoint cone monad proposition 
terms processes may think ff lambda process starts time produce value time 
counit operator extracts final value process ff argument 
proposition 
construction lambda definition strict monoidal comonad cghaus making strict cs category 
proof 
show lambda kelley 
compact locally compact hausdorff known space continuous functions kelley hom cghaus 
general hom cghaus space continuous functions space 
fx closed projection ff 
ff continuous lambda closed hom cghaus 
closed subset kelley space lambda kelley 
coproduct kelley spaces kelley follows lambda kelley 
show lambda continuous show auxiliary claim function lambda continuous connected component ii restriction jc continuous hom cghaus 
connected connected 
lambda open closed lambda construction lambda definition lambda means 
hand continuous jc continuous lambda 
subset lambda closed hom cghaus closed lambda definition ii holds 
fact continuous inverse image closed set closed 
lambda ii closed subset lambda closed hom cghaus jc continuous lambda lambda open lambda gamma union gamma jc ranges connected components open 
continuous lambda claim proved 
continuous claim lambda continuous 
connected component lambda lambda open closed lambda homology homotopy applications vol 
included lambda ff fi lambda ff ff fi lambda fi holds 
jc trivially continuous hom cghaus ffi continuous operation morphism lambda cghaus ccc 
claim applies lambda continuous 
show lambda continuous 
closed subset gamma fff lambda fff lambda fff hom cghaus jff ff functions hom cghaus mapping ff ff ff respectively continuous fff hom cghaus jff ff closed hom cghaus lambda set closed sum space intersection summand closed summand gamma closed 
show lambda lambda continuous 
connected component lambda particular lambda ff ff ff map 
ff constant map 
independent ff holds 
hand closed subset hom cghaus lambda 
letting constant map 
gamma jc gamma jc lambda lambda gamma jc lambda lambda closed hom cghaus 
lambda lambda closed hom cghaus hom cghaus jc continuous hom cghaus hom cghaus hom cghaus composition continuous maps 
gamma jc closed ii holds 
claim continuous 
claim lambda strict monoidal 
terminal object cghaus singleton ffflg lambda ffflg space paths ffl ffl ffflg singleton set 
hand products slightly harder deal 
lambda denote product topological spaces theta lambda claim pair functions lambda theta lambda theta lambda fl 
ss ffi fl ss ffi fl lambda theta lambda lambda theta ff fi 

ff fi defines natural isomorphism lambda theta lambda lambda inverse clear remains show continuous 
theta product cghaus show fl 
ss ffi fl continuous lambda theta lambda similarly fl 
ss ffi fl 
apply claim connected component lambda theta 
lambda theta open closed lambda theta included lambda theta fl 
ss ffi fl maps fl path value independent fl holds 
ii obvious continuous 
subtler require prove claim connected component theta subset product lambda connected component connected component homology homotopy applications vol 
connected component resp 
open closed resp 
product lambda open closed lambda connected components 
topology theta finer lambda lambda open closed theta set pairs connected components lambda 
note union lambda covers lambda open closed connected pair connected components lambda 
follows lambda claim proved 
show continuous apply claim connected component lambda theta lambda claim included product connected components lambda lambda respectively 
particular lambda lambda lambda follows ff fi ff fi ff fi independent ff fi 
holds 
ii holds trivially 
continuous 
remains check equations easy left reader 
said lambda dual cone functor 
reader check upsilon theta smallest equivalence relation 
provided lie connected component writing jt xj equivalence class upsilon function mapping jt xj jt map xj map jt jt xjj jt xj 
proposition 
strong monad upsilon cone monad category cghaus kelley spaces upsilon lambda recalling discussion section gives way interpreting moggi computational lambda calculus labeled kelley spaces preserving duality lambda upsilon forms talking computations values adjunction upsilon lambda 
cone monad exists delta complex built join point set example 
instructive see space points lambda space paths lambda space singular simplices general lambda space singular simplices 
examine lambda 
space paths fi fi path fi kind square deformation 
fi continuous connected range fi connected 
range fi subset lambda direct sum spaces lambda direct sum topological spaces summand open closed connected subspace fact subspace summand 
case means range fi subset lambda words fi range fi assumes shape triangle deformation see 
note phenomenon entirely due strange topology take lambda separates completely paths ff ff 
just taken lambda set paths compact open topology lambda set cubes simplices 
homology homotopy applications vol 
xx points paths simplices extended singular simplices general define gamma set extended singular simplices definition extended singular simplices 
gamma extended singular simplices continuous maps delta delta standard extended simplex 
delta gamma singleton containing empty tuple 
delta polyhedron vertices second points 
analogous usual notion standard simplices delta vertices 
delta 
singular simplices continuous maps delta see illustration standard simplices standard extended simplices look 
delta delta segment point delta delta triangle segment delta delta tetrahedron triangle standard extended simplices topology follows 
gamma isomorphic viewed topological sum spaces fl ff hom cghaus delta delta flg fl ranges homology homotopy applications vol 
singular simplices interested reader check fact homeomorphic lambda note extended simplices space functions elegant geometric interpretation 
set continuous functions lambda set continuous paths functions functions lambda set homotopies continuous functions elements lambda known higher order homotopies lambda set homotopies homotopies classical construction algebraic topology 
terms proof theory translation intuitionistic proofs proofs replaces base type lambda implication corresponding boxed implication 
level proof terms yields calculus interprets slightly plotkin call value calculus 
constructions give rise model terms paths elements base types homotopies implications 
left reader 

models categories orders cpos categories cogent computer science models calculus complete partial orders 
may define strict monoidal comonads follows 
recall ord category objects partial orders morphisms monotonic functions ccc 
similarly cat category small categories ccc 
category cpo complete partial orders cpos cpos objects continuous functions morphisms 
recall cpo partial order infinite increasing chain upper bound 
don require cpos pointed element 
function continuous provided preserves upper bounds increasing chains particular continuous function monotonic 
cpo ccc 
variant category dcpo directed cpos required non empty directed subsets upper bound directed subset elements upper bound continuous functions required preserve upper bounds directed sets 
dcpo ccc 
definition lambda comonad ord cpo dcpo 
partial order lambda set pairs elements ordered monotonic function resp 
continuous lambda map 
counit lambda maps comultiplication lambda lambda maps 
easily checked defines strict monoidal comonad ord cpo dcpo 
topological case may give synthetic description lambda isomorphic partial order resp 
cpo resp 
dcpo chains gamma elements ordered gamma gamma homology homotopy applications vol 
gamma gamma 
gamma gamma just iterating lambda topological case allowed retrieve form singular simplex functor retrieve form nerve functor 
passing invite reader check cone monad upsilon ord cpo dcpo upsilon new bottom element added connected component 
connected components equivalence classes symmetric closure 
unit upsilon natural inclusion orders 
multiplication upsilon upsilon additional bottoms upsilon ones just come upsilon strong monad left adjoint lambda pointed cpos known lifting monad 
leave reader check similar constructions cat small category lambda category morphisms morphisms commuting triangles short lambda coproduct counit functor mapping diagram morphism comultiplication maps object obvious commuting triangle morphisms triangle commuting tetrahedra id 
interpreting proofs cccs monoidal comonads fix arbitrary strict cs category calling strict monoidal comonad lambda 
prime example delta restrict 
reuse ccc notations section strict monoidal comonad notations section equations 
extend set theoretic interpretation terms interpretation formulas objects terms morphisms interpretation shown 
parameterized environment ae mapping base type sigma object ae 
notations match standard meaning functions denotational semantics 
theta theta theta theta theta gamma theta hf hh gamma abuse language considering interpretation typed terms typing derivations 
homology homotopy applications vol 
jak ae ae jf oe gk ae hom jf ae jgk ae lambda ae lambda jf kae gamma ae ss gamma ffi ffi ss gamma gamma gk ae app ffi hc gamma oe gk ae gamma aei gamma delta oe gk ae lambda gamma gk ae gamma dm ae ffi gamma lambda ae gamma delta lambda ae lambda theta gk ae ffi gamma lambda ae gamma lambda aei theta lambda lambda fx interpreting proof terms gamma gamma ae product jf ae theta theta jf ae 
lemma soundness 
interpretation sound strict cs category gamma derivable jmk ae morphism gamma ae jf ae ss jmk ae ae 
proof 
typing part immediate 
equality part standard arguments show gamma fx ae jx ae gamma ae gamma aei indicated sequents derivable gamma gk ae gamma gk ae ffi ss free standard tedious calculations check jmk ae ae entails second claim 
allowed vary strict cs category converses lemma 
idea define syntactic category follows definition sigma category 
sigma category objects contexts mapping variables types built set sigma base types morphisms gamma xn fn fy ym theta ym gm substitution gamma modulo ss 
identity gamma identity substitution id gamma fx composition ffi substitution concatenation delta homology homotopy applications vol 
ccc strict monoidal comonad 
terminal object empty context unique morphism gamma gamma empty substitution 
define products notice contexts isomorphic renaming variables 
words isomorphic allows define gamma theta gamma gamma gamma disjoint domains 
gamma theta gamma concatenation gamma gamma contexts theta gamma gamma theta gamma gamma morphism 
projections restrictions gamma theta gamma ss fx xn xng gamma gamma theta gamma ss fx gamma gamma gamma internal hom object hom sigma gamma gamma context oe oe oe oe oe oe 
application homs sigma gamma gamma theta gamma app gamma gamma built syntactic application fx zn abstraction built abstraction follows 
theta theta gamma gamma gamma gamma gamma theta theta xn delta xn delta homs sigma gamma gamma uses non modal part particular computation rules fi 
strict monoidal comonad lambda sigma defined lambda modality objects lambda defined lambda lambda morphisms definition lambda lambda gamma lambda fy lambda ym lambda lambda theta lambda mfx dx dx gamma derivable 
counit lambda gamma fx dx xn gamma comultiplication lambda gamma fx sx xn lambda gamma recall sm delta fx mg 
trivially follows proposition existential completeness 
ae map base type sigma context morphism sigma gamma ae sigma jf ae sigma provable gamma term gamma derivable 
proposition evaluation functor 
strict cs category ae sigma ae extends ae representation strict cs categories sigma homology homotopy applications vol 
proof 
morphism gamma xn fn fy ym ym gm define ae hc gamma ae gamma aei 
functorial gamma ae hss ffi ss gamma ss ffi ss ss id ae preserves composition 
preserves cartesian products construction 
preserves lambda lambda gamma lambda lambda ae lambda gamma fx dx dx lambda ae lambda gamma mfx dx dx ae ffis ffi hss ffi ss gamma ss ffi ss ffi ss lambda gamma mfx dx dx ae ffi lambda gamma gamma ae ffi hd ffi ss ffi ss gamma ffi ss ffi ss ffi ss delta ffi lambda gamma ae ffi ffi lambda gamma ae ffi lambda ffi lambda gamma ae lambda ae hc lambda gamma lambda lambda ae lambda gamma lambda aei lambda gamma ae lambda gamma aei lambda ae ae preserves jdk ae hc lambda gamma dx ae lambda gamma dx aei hd ffi ss ffi ss gamma ffi ss ffi ss ffi ss ffi hss ffi ss gamma ss ffi ss ss ae preserves gamma sm lambda ae gamma delta fx lambda ae lambda jx lambda lambda ae ffi ffi gamma lambda ae lambda id ffi ffi gamma lambda ae ffi gamma lambda ae ae hs ffi ss ffi ss gamma ffi ss ffi ss ffi ss ffi hss ffi ss gamma ss ffi ss ss functor ae preserves internal homs application app abstraction lambda standard tedious omitted 
proposition free strict cs category 
sigma free strict cs category sigma homology homotopy applications vol 
precisely set sigma base types seen discrete category denote natural inclusion functor sigma sigma strict cs category functor ae sigma unique functor phi diagram commute sigma sigma ae oe phi furthermore phi exactly ae functor defined 
proof 
uniqueness assume phi exists shall show uniquely determined 
objects phi map formula jf ae general context gamma gamma ae 
morphisms phi preserve products phi uniquely determined images morphisms sigma form gamma xn fn fy ym theta ym gm 
case equate morphism judgment gamma phi uniquely determined values typed terms 
readability abuse language equating terms typing derivations 
phi preserve lambda phi fx dx dx lambda phi phi gamma delta fx delta ffi phi possibly gc delta fx ss mfx dx dx fx delta fy delta fy gg follows phi delta fx lambda phi ffi ffi phi phi similarly phi preserve phi dm ffi phi 
recognize clauses ae boxes terms 
case internal homs application abstraction equally easy standard phi ae 
existence phi ae lemma proposition 
corollary 
denote canonical inclusion sigma sigma mapping base type seen formula 
sigma gamma ss proof 
apply proposition sigma ae 
corollary immediately implies homology homotopy applications vol 
proposition equational completeness 
terms gamma gamma derivable 
sigma gamma sigma gamma ss sigma characterized free strict cs category section elucidating construction augmented simplicial set definition categorical point view 
note lemma 
functor mapping formula generally context gamma gamma theta theta morphism gamma xn fn fy ym theta ym gm morphism delta augmented simplicial map sends gamma lambda lambda fx faithful preserves finite products comonads source target categories 
proof 
functor follows equations 
clearly preserves finite products maps syntactic comonad lambda dual comonad lambda delta easy check shows 
faithful definition retrieve uniquely looking image tuple gamma give description follows essentially way generalizing familiar hom set functor hom augmented simplicial case 
way shall see related standard resolution comonad vii definition resolution functor res 
lambda strict cs category 
resolution functor res theta delta maps pair objects augmented simplicial set hom lambda gamma lambda ffi lambda ffi pair morphisms gamma gamma map res dimension gamma res lambda ffi ffi hom lambda 
instance res sigma augmented simplicial set ground terms type lambda gamma 
term ground provided free variable 
seen lemma purposes 
minimal augmented simplicial set follows definition contracting resolution functor 
lambda small strict cs category 
contracting resolution functor delta colimit lim gamma 
lambda res ffi lambda category hom cat delta functors delta definition sense provided take lambda meaning abstraction cat functor theta delta lambda functor homology homotopy applications vol 
hom cat delta lambda endofunctor defines endofunctor indicated colimit exists hom cat delta hom cat hom cat delta set theta delta set category presheaves topos small cocomplete small 
geometrically idea resolutions point space res take resolutions spaces contracting homotopy properly amalgamated 
recall contracting homotopy augmented simplicial set gamma map lambda right inverse delta concretely family maps gamma gamma gamma ffis ffis gamma gamma gamma ffi ffis gamma ffi gamma id 
exactly needed build standard notion contracting homotopy simplicial homology 
trivial way ensuring res contracting homotopy take form lambda res lambda hom lambda lambda may define gamma lambda ffi proof theoretically sigma gamma term manifestation lambda rule 
level programs lisp quote operator 
proposition 
context theta set theta exactly sigma theta 
proof 
deal case theta form single formula readability purposes 
general case similar 
colimits functor categories taken pointwise sigma colimit functor maps context gamma set res sigma lambda gamma terms lambda gamma lambda modulo ss 
hand apex cocone consisting morphisms res sigma lambda gamma gamma map typing derivation lambda gamma lambda term 
hand claim universal 
set morphisms res sigma lambda gamma gamma gamma gamma ranges contexts morphisms define cocone gamma gamma gamma morphism sigma gamma lambda gamma gamma res sigma lambda gamma gamma lambda gamma gamma gamma lambda gamma delta lambda gamma 
substitutions mapping variables variables noticing variable lambda dx ss follows gamma depends lambda gamma gamma defines unique morphism colimit desired functor 
uniqueness colimits isomorphism result obtains 

review logical relations interpretation complete allowed take sigma interested geometrical categories particular delta review standard way proving friedman theorem chapter logical relations 
shall discuss proof replayed directly case appropriate modifications 
friedman result non modal part calculus interpreted set 
spell relevant part homology homotopy applications vol 
tion detail 
map base types sigma sets ae set jf oe gk ae set functions set jf ae set jgk ae 
set gamma ae gamma mapping variable set jf ae gamma environment 
interpretation set maps typing derivation term type gamma gamma environment element set gamma ae short set jmk ae set jf ae set jxk ae set jmn ae set jm ae applied set jn ae set gamma delta oe gk ae function maps set jf ae set jmk ae 

set defined set terms type modulo fij conversion 
get interpretation terms free ccc sigma mapping term set gamma environment just substitution 
logical relation family binary relations indexed formulae set set jf ae oeg mn 
general logical relations relations indexed types henkin models cccs 
specialize notion problem hand 
fundamental lemma logical relations basic lemma states gamma environment gamma substitution mapping term type fi set set jm ae term type gamma words soon environments related logical relation values term models 
show set ae equationally complete show build functional logical relation set jf ae set ss note logical relation uniquely determined relations sigma trick choose functional 
turns asking functional carry require functional set set jf ae assumptions oeg functional soon 
functional choose set jf oe gk ae function set jf ae set jgk ae term oeg 
axiom choice fact may define function set set jf ae 

functional may define projection set jf ae set implies arbitrary 
mn 
determines mn uniquely provided exists 
oeg functional 
show map set oe function set jf oe gk ae mapping 
essentially line proof shall follow 
case set replaced delta axiom choice invalid epi delta map general ffi id build explicitly induction formulae 
important property needs preserved formula shall call homology homotopy applications vol 
bounding lemma 
retracing argument find requires define oeg function mapping obvious definition oeg oeg delta wrong 
incompatible ff renaming general map functions ss classes terms 
compatibility ff renaming imposes delta delta fx yg reason ffi ffi substitutive 
solution define oeg oeg oeg 
oeg retraction set functions set set syntactic function space set oe retraction meaning oeg 
term exactly 
exactly taken pain constructing augmented simplicial case corollary 
final note embark proving theorem 
right notion logical relation kripke logical relation complex notion ordinary logical relations 
contrarily usual cases set worlds kripke logical relation just preorder category fact augmented simplicial category delta concretely families relations indexed formulae dimensions gamma gamma lambda logical lambda 
oe logical oeg monotonic function lambda app lambda app defined unique way ffi oe id id ffi ffi 
condition particularly unwieldy 
prefer categorical notion factor irrelevant details 
turns logical relations kripke logical relations special cases right notion 

categories having finite cartesian products pullbacks functor preserves finite cartesian products lambda objects triples object object ae mono defined similarly requirement mono 
strict cs category 
set sigma base types mapping assigns base type object seen functor sigma seen homology homotopy applications vol 
trivial category elements sigma objects identity morphisms sigma ae unique representation strict cs categories ae free strict cs category sigma sigma sigma sigma ae oe ae denotes canonical inclusion functor sigma sigma diagram replace category lambda get diagram sigma sigma lambda ae oe lambda ae ae lambda ae uniquely determined representation strict cs categories right notion kripke logical relation 
known proposition provided equalizers finitely complete provided preserves finite products lambda ccc forgetful functor lambda gamma maps object representation cccs 
similarly 
explicit construction terminal objects products internal homs lambda 
terminal object 
id 

binary products 
product theta theta theta 

internal homs 
build hom lambda follows 
careful reader note construction 
hom 
build morphisms 
build homc theta id theta homc theta app currying getting homc lambda app ffi id theta homd second built homd theta app ae homology homotopy applications vol 
currying homd lambda ffi app homd claim morphism mono 
consider morphisms lambda ffi app ffi lambda ffi app ffi applying app ffi theta id left hand side get app ffi lambda ffi app ffi theta id app ffi lambda ffi app ffi theta id theta id ffi app ffi theta id 
applying sides equation get ffi app ffi theta id ffi app ffi theta id app ffi theta id app ffi theta id mono 
applying lambda sides left hand side simplifies right hand side lambda ffi app mono 
build pullback diagram ae homc homd ae lambda ffi app homd lambda app ffi id theta upper morphism mono pullbacks preserve monos 
application pair morphisms app ffi theta id theta app theta conversely morphism theta build curried morphism follows 
recall morphism square commutes theta ae theta theta ae curried version morphism lambda unique morphism diagram commute lambda homd lambda ffi app lambda homd lambda app ffi id theta homology homotopy applications vol 
bottom pullback diagram definition internal homs 
outer diagram commutes lambda ffi app ffi lambda lambda ffi app ffi lambda theta id lambda ffi lambda ffi theta morphism lambda app ffi id theta ffif lambda lambda app ffi id theta ffi lambda theta id lambda app ffi lambda theta id ffi theta lambda lambda theta id ffi theta functor preserves products lambda ffi theta 

comonad lambda 
ccc structure category general choices strict monoidal comonad 
standard choice defining comonad lambda comonad lambda works defining lambda lambda pullback diagram lambda ae purposes intuitively represents relation defining lambda way lambda mean replacing lambda logical condition lambda definition lambda large second implication bounding lemma hold general 
note unsatisfying definition comonad may notice simpler solution soon comes equipped comonad provided preserves lambda shall say preserves comonad lambda lambda preserves monos 
letting lambda lambda lambda lambda defines object 
lambda morphism lambda lambda lambda mono lambda preserves monos 

case requirement lambda preserves monos necessary 
simple case completeness augmented simplicial case case shall deal 
just mention right construction general cases lambda lambda isomorphic 
particular case topological spaces shall mono lambda lambda object insist condition distributivity law comonads name analogy distributivity laws monads originated lambda preserves pullbacks distributivity law 
role distributivity laws apparent proof proposition 
appeal distributivity law subsumes simple case preserves comonad lambda just take identity 
clearly distributivity law pullbacks preserved vacuously 
definition distributivity law 
strict cs categories homology homotopy applications vol 
functor 
distributivity law respect comonads lambda natural transformation lambda lambda equations hold ffi ffi lambda ffi lambda ffi diagrams lambda lambda lambda lambda lambda oe oe lambda ic lambda lambda ic say additionally lambda preserves pullbacks object pullback lambda lambda lambda lambda ic commuting square pullback lambda lambda lambda lambda lambda lambda lambda lambda lambda ic proposition 
assume strict cs categories preserves finite products finitely complete lambda preserves monos pullbacks distributivity law wrt 
lambda lambda strict cs category equipped comonad lambda defined ffl objects lambda unique morphism lambda homology homotopy applications vol 
pullback diagram lambda lambda lambda lambda ic morphisms morphism lambda unique morphism lambda diagram commute lambda 
ic lambda lambda lambda lambda lambda lambda lambda lambda lambda ic lambda front face defines lambda back face defines lambda bottom face definition morphism right face naturality determined uniquely fact front face pullback 
ffl counit lambda ffi diagram 
ffl comultiplication uniquely determined homology homotopy applications vol 
diagram commutes lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda ic defining square lambda lambda lambda image lambda defining square lambda 
forgetful functor lambda gamma mapping object resp 
morphism representation strict cs categories 
proof 
ccc structure resp 
lambda fact representation cccs known 
check comonad 
diagram mono lambda lambda preserves monos mono pullbacks preserve monos 
follows lambda object lambda claim lambda functor lambda morphisms defined solution universal problem 
lambda lambda preserves lambda ffi defined 
pile definition lambda atop square saying ffi lambda ffi lambda lambda lambda lambda ic ffi implies ffi ffi ffi means homology homotopy applications vol 
exactly ffi morphism lambda 
maps ffi preserves show defined bit intricate 
lambda preserves pullbacks pullback diagram square obtained pullback square 
uniquely defined soon show outer square commutes 
leftmost path lambda lambda lambda rightmost path lambda ffii lambda ffif ffi ffi 
equal lambda ffi ffi definition lambda diagram 
diagram indicates 
remains check comonad equations 
checked follow fact lambda preserve finite products 
checked fashion 
check ffi lambda ffi write morphism 
lambda lambda shown diagram 
writing top face diagram square saying morphism yields diagram left taken notations diagram 
hand putting definition atop defining square yields diagram right lambda lambda lambda lambda ffi ffi dffi lambda paths diagram equal leftmost ones equal 
mono left vertical paths equal 
means exactly ffi ffi ffi ffi ffi lambda ffi 
equations checked similarly 
homology homotopy applications vol 
equation follows diagram lambda lambda ffi lambda lower square definition lambda lambda lambda lambda lambda lambda 
rightmost path lambda lambda ffi ffi id id ffi ffi ffi 
mono ffi ffi id ffi id 
equation dealt similarly 

basic lemma argument 
functor sigma ae gamma lambda get functor sigma composition freeness sigma unique functors ae ae ffi ae lambda ae upper left upper right triangles diagram diagram category cat categories commute sigma sigma ae lambda ae oe lambda ae ae go representation strict cs categories ffi lambda ae uniqueness ae arrow right representation strict cs categories get lemma basic lemma 
ffi lambda ae ffi ae 
bounding lemma consider case form theta omega id functor preserves finite products distributivity homology homotopy applications vol 
law wrt 
lambda 
omega functor mapping theta 
typically sigma sigma delta id case identity morphism 
shall prove lemma bounding lemma 
strict cs categories preserve finite products 
assume finitely complete lambda preserves monos pullbacks distributivity law wrt 
lambda fix ae sigma assume formulae hom jf ae jgk ae retracts strongly jf oe gk ae meaning family morphisms oeg diagram commutes homd jf ae jgk ae oe lambda app jf oe gk ae homd jf ae jgk ae id jf oe gk ae id similarly formula lambda jf ae retracts strongly lambda ae meaning family morphisms lambda diagram commutes lambda jf ae oe lambda ae lambda jf ae id lambda lambda ae id ae sigma ffi ae ae sigma lambda omega id map sigma ae ae ae hid idi 
formula write lambda omega id jf ae jf ae jf ae hm 
families morphisms monos diagrams commute formula jf ae jf ae ae id df ae jf ae oe jf ae oe id homology homotopy applications vol 
proof 
build formula ffi id required result hold diagram implies ffi ffi id id ffi ffi base type sigma define diagrams commute ae ae oe ia ae ae id pa ae ae id just id lambda lambda lambda ffi lambda lambda ffi lambda lambda ffi lambda lambda ffi lambda ffi lambda ffi lambda ffi lambda ffi ffi lambda ffi lambda id ffi lambda ffi id form oe build unique type consistent way 
diagram jhk ae oe ih jhk ae homd jgk ae jhk ae theta jgk ae id theta homd jgk ae jhk ae theta jgk ae app induction hypothesis 
apply lambda resulting composite morphism compose lambda app yields goeh defined jg oe hk ae oe lambda ih ffi app ffi id theta pg homd jgk ae jhk ae oe lambda app jg oe hk ae similarly define morphism goeh jg oe hk ae jg oe hk ae composite jg oe hk ae lambda ph ffi app ffi id theta ig homd jgk ae jhk ae goeh jg oe hk ae superposing diagrams get jg oe hk ae oe lambda ih ffi app ffi id theta pg homd jf ae jgk ae oe lambda app jf oe gk ae jg oe hk ae id lambda ph ffi app ffi id theta ig homd jf ae jgk ae id jf oe gk ae id goeh top line goeh bottom line right square commutes left square commutes calculation shows left reader hint ffi id ffi id 
goeh ffi goeh id homology homotopy applications vol 
build note soon diagram commutes automatically mono 
ffii id mono ffih mono 
similarly hm mono part definition object hm hp idi ffi mono 
mono imply id id mono lambda omega id jf ae 
diagram commutative equivalent showing existence diagram lambda omega id ae id lambda omega id jf ae ae id pf jf ae jf ae jf ae hid jf ae jf ae jf ae hp idi build structural induction base type notice id take id box formula lambda recall lambda lambda ffi lambda lambda lambda ffii drop indices avoid clutter 
hand definition lambda pullback diagram lambda hm lambda lambda lambda gk ae theta lambda gk ae lambda dg hm lambda lambda lambda jgk ae theta lambda jgk ae theta id allows define lambda universal property pullback lambda gk ae lambda hm lambda lambda lambda lambda gk ae theta lambda gk ae hid lambda ffi lambda dg hm lambda lambda lambda ffi lambda jgk ae theta lambda jgk ae theta id homology homotopy applications vol 
upper triangle exactly left part diagram looking lambda gk ae lambda gk ae lambda id lambda lambda lambda gk ae lambda lambda hand right part lambda lambda provided show lambda ffi lambda lambda show note rewrite diagram lambda gk ae oe lambda lambda lambda lambda gk ae lambda jgk ae oe lambda lambda dg hm lambda lambda gk ae id induction hypothesis ffi adding morphism lambda lower right lambda gk ae lower left lambda jgk ae commutative diagram 
follows reading topmost lambda lower left lambda jgk ae different ways lambda lambda lambda composing lambda left get lambda ffi lambda ffi lambda lambda ffi ffi lambda lambda ffi lambda lambda desired 
terminates box case 
arrow type oe build goeh construct morphism jg oe hk ae theta jgk ae oe id theta jg oe hk ae theta dg jhk ae app dh short call morphism temporarily 
construct morphism app app jg oe hk ae jg oe hk ae theta jgk ae jgk ae jhk ae jhk ae theta claim morphism lambda omega id goeh theta lambda omega id jgk ae lambda omega id jhk ae 
requires show diagram commutes split products increase homology homotopy applications vol 
ity jg oe hk ae theta jgk ae oe id theta jg oe hk ae theta dg theta jg oe hk ae theta jgk ae jhk ae app oe dh jhk ae app left square commutes ffi identity induction hypothesis ffi ffi ffi app ffi id theta app ffi id theta right square note app ffi goeh theta id ffi app ffi id theta definition goeh composing id theta right follows app ffi goeh theta ffi app ffi id theta ffi 
ffi induction hypothesis 
get app ffi goeh theta ffi app ffi id theta ffi induction hypothesis right hand side exactly ffi right square commutes 
commutes morphism lambda omega id 
may curry lambda omega id getting morphism goeh internal hom object hom lambda omega id lambda omega id jgk ae lambda omega id jhk ae goeh lambda omega id jg oe hk ae 
call morphism goeh recalled paragraph morphism form lambda lambda taken product category theta application category lambda id goeh required form goeh id goeh morphism lambda omega id diagram commutes jg oe hk ae hid jg oe hk ae theta jg oe hk ae goeh hm goeh goeh jg oe hk ae theta jg oe hk ae id homology homotopy applications vol 
exactly left part desired diagram jg oe hk ae jg oe hk ae goeh id goeh jg oe hk ae goeh oe build goeh define goeh goeh adapting definition internal homs category lambda omega id trivial isomorphisms lambda omega id jg oe hk ae pullback diagram hm goeh goeh jg oe hk ae theta jg oe hk ae homd dg dh lambda ffi app lambda ffi app homd dg jhk ae theta homd dg jhk ae lambda app ffi id theta theta lambda app ffi id theta splitting products may rewrite jg oe hk ae oe goeh goeh jg oe hk ae homd dg jhk ae lambda app ffi id theta oe lambda homd dg dh lambda homd dg jhk ae lambda app ffi id theta take product jg oe hk ae theta dg oe goeh theta id theta dg goeh theta id jg oe hk ae theta dg homd dg jhk ae theta dg lambda app ffi id theta theta id oe lambda ffi app theta id homd dg dh theta dg theta id lambda ffi app theta id homd dg jhk ae theta dg lambda app ffi id theta theta id homology homotopy applications vol 
putting diagram homd dg jhk ae theta dg oe lambda ffi app theta id homd dg dh theta dg lambda ffi app theta id homd dg jhk ae theta dg jhk ae app oe dh app jhk ae app easily seen commute obtain jg oe hk ae theta dg oe goeh theta id theta dg goeh theta id jg oe hk ae theta dg jhk ae app ffi id theta oe dh jhk ae app ffi id theta leftmost vertical morphism app ffi lambda app ffi id theta theta id app ffi id theta rightmost vertical morphism obtained similarly 
induction hypothesis ffi may complete diagram adding arrow lower right jhk ae lower left jhk ae get commutative diagram 
looking leftmost rightmost paths upper goeh theta lower left jhk ae follows app ffi id theta ffi goeh theta id ffi app ffi id theta ffi goeh theta id composing id theta right simplifying obtain app ffi goeh theta ffih goeh theta ffih 
induction hypothesis ffih id ffi app ffi goeh theta id ffi app ffi goeh theta entails lambda ffi app ffi id theta ffi goeh lambda ffi app ffi id theta ffi goeh theta id lambda ffi app ffi goeh theta lambda app ffi goeh theta id lambda app ffi goeh composing goeh left remembering goeh ffi lambda app id diagram obtains goeh ffi lambda ffi app ffi id theta ffi goeh goeh goeh ffi goeh goeh hand recall goeh goeh got right part homology homotopy applications vol 
desired diagram jg oe hk ae goeh goeh jg oe hk ae oe oe jg oe hk ae goeh oe id terminates implication case 

equational completeness prove theorem equational completeness 
strict cs category sigma preserve finite products 
assume finitely complete lambda preserves monos pullbacks distributivity law wrt 
lambda formulae hom sigma jf sigma jgk retracts strongly sigma jf oe gk lambda sigma jf retracts strongly sigma lambda canonical inclusion sigma sigma assume faithful morphisms domain empty context 
valuation ae sigma terms type gamma ss jm ae jn ae proof 
direction soundness lemma 
deal direction 
loss generality assume ground gamma empty context gamma empty say gamma reduce empty case reasoning delta delta take sigma ae 
lemma ae ffi ae ae map sigma ae ae ae hid idi 
basic lemma lemma lambda omega id jf ae sigma jf ae jf ae forgetful functor maps morphism expanding definition case type derivation morphism lambda omega id jm ae lambda omega id jf ae written basic lemma demands sigma jmk ae theta jmk ae morphism lambda omega id diagram commutes ae id df ae hm sigma jf ae theta jf ae sigma jmk ae theta jmk ae homology homotopy applications vol 
ffi sigma jm ae ffi jm ae bounding lemma lemma diagram ffi sigma jm ae ffi jmk ae holds derivable follows immediately take terms jm ae jn ae sigma jm ae sigma ae 
faithful morphisms domain empty context sigma jmk ae sigma jn ae ae proposition ss corollary equational completeness delta 
valuation ae sigma delta terms type gamma ss delta jmk ae delta ae proof 
check hypotheses 
delta strict cs category definition 
take alternatively contracting resolution functor sigma 
lemma preserves finite products lambda comonad canonical isomorphism lambda lambda distributivity law wrt 
lambda lambda preserves pullbacks faithful 
delta finitely complete fact topos 
lambda preserves monos recall mono delta map gamma follows lambda maps gamma gamma preserves monos delta lambda sigma jf retracts strongly sigma lambda canonically isomorphic 
corollary hom delta sigma jf sigma jgk retracts strongly sigma jf oe gk observe sigma jf similarly 
case topological models variants thereof open 
acknowledgments author wishes people attending types workshop talked ideas eventually led michael mendler goguen james mckinna 
tim porter rajeev gor fruitful discussions dana scott sergei art eugenio moggi mints valeria de paiva anonymous referees earlier version remarks 
acknowledge paul taylor diagrams package draw diagrams 
characterization lambda definability categorical models implicit polymorphism theoretical computer science 
homology homotopy applications vol 
henk barendregt lambda calculus syntax semantics studies logic foundations mathematics vol 
north holland publishing amsterdam 
basu geometry sequential computation simplicial geometry interaction technische universit unchen institut ur informatik august 
geometry sequential computation ii full abstraction pcf technische universit unchen institut ur informatik august 
alan bawden jonathan rees syntactic closures acm conference lisp functional programming pp :10.1.1.18.3867

nick benton gavin bierman valeria de paiva computational types logical perspective journal functional programming 
gavin bierman valeria de paiva intuitionistic necessity revisited logic amsterdam netherlands revised version technical report csr university birmingham june 
anders bj topological methods handbook combinatorics graham gr lov asz eds vol 
elsevier science pp 

stephen brookes shai geva computational comonads intensional semantics applications categories computer science proceedings lms symposium durham fourman johnstone pitts eds london mathematical society lecture notes 
pierre louis curien categorical combinators sequential algorithms functional programming nd ed progress theoretical computer science birkh auser boston 
rowan davies frank pfenning modal analysis staged computation rd acm sigplan sigact symposium principles programming languages january pp :10.1.1.28.4059

nachum dershowitz termination rewriting journal symbolic computation 
nachum dershowitz jean pierre jouannaud rewrite systems handbook theoretical computer science jan van leeuwen ed elsevier science publishers pp 

philip tim porter joins augmented simplicial sets bangor maths preprint bangor university february submitted journal pure applied algebra 
peter freyd andre scedrov categories allegories north holland mathematical library vol 
north holland amsterdam 
harvey friedman equality functionals logic colloquium rohit parikh ed lecture notes mathematics vol 
springer verlag pp 

homology homotopy applications vol 
jean yves girard linear logic theoretical computer science 
jean yves girard yves lafont paul taylor proofs types cambridge tracts theoretical computer science vol 
cambridge university press 
goguen jean goubault sequent combinators hilbert system lambda calculus mathematical structures computer science 
jean goubault computational interpretations modal logic cut elimination bericht university karlsruhe 
computational interpretations modal logic ii 
ev calculus bericht university karlsruhe 
jean goubault eric goubault order theoretic geometric combinatorial models intuitionistic proofs st workshop intuitionistic modal logics applications trento italy st workshop geometric methods concurrency theory aalborg denmark 
available www fr fr actions vip top ps gz june 
geometry intuitionistic proofs research report lsv laboratoire sp ens cachan france november pages available www lsv ens cachan fr lsv rr lsv rr ps 
jean goubault david nowak logical relations monadic types proceedings th international workshop computer science logic csl edinburgh scotland springer verlag lecture notes computer science appear 
marco grandis homotopical algebra homotopical categories applied categorical structures 
timothy griffin formulas types notion control proceedings th annual acm symposium principles programming languages san francisco california january pp 

herlihy sergio rajsbaum algebraic topology distributed computing primer computer science today trends developments jan van leeuwen ed lecture notes computer science vol 
springer verlag pp 

jonathan hindley roger seldin combinators calculus london mathematical society student texts vol 
cambridge university press 
william howard formulae types notion construction curry essays combinatory logic lambda calculus formalism hindley seldin eds academic press pp 

erard huet unification algorithm typed calculus theoretical computer science 
homology homotopy applications vol 
jean pierre jouannaud claude kirchner solving equations algebras rule survey unification tech :10.1.1.36.6957
report lri cnrs ua march 
satoshi kobayashi monad modality theoretical computer science 
joachim lambek phil scott higher order categorical logic cambridge studies advanced mathematics vol 
cambridge university press 
pierre modal lambda calculus iteration case constructs technical report rr institut national de recherche en informatique en automatique inria france 
john mac edwards hart levin lisp programmer manual mit press 
saunders mac lane categories working mathematician graduate texts mathematics vol 
springer verlag 
simone martini andrea masini modal view linear logic journal symbolic logic 
computational interpretation modal proofs proof theory modal logic wansing ed kluwer pp 

peter may simplicial objects algebraic topology chicago lectures mathematics university chicago press 
john mitchell foundations programming languages mit press 
john mitchell andre scedrov notes relators computer science logic selected papers ed available anonymous ftp host ftp cis upenn edu file pub papers scedrov rel dvi pp 

michel parigot calculus algorithmic interpretation classical natural deduction rd international conference logic programming automated reasoning saint petersburg ussr lecture notes computer science vol 
springer verlag july 
frank pfenning rowan davies judgmental reconstruction modal logic invited talk st workshop intuitionistic modal logics applications trento italy july submitted mathematical structures computer science :10.1.1.17.1563
available www cs cmu edu fp papers mscs ps gz 
frank pfenning hao chi wong modal calculus th conference mathematical foundations programming semantics extended 
gordon plotkin call name call value calculus theoretical computer science 
tim porter letter authors rajeev gor august th available porter authors 
homology homotopy applications vol 
dag prawitz natural deduction proof theoretical study almqvist stockholm 
szabo collected papers gerhard gentzen north holland publishing amsterdam 
daniele turi functorial operational semantics denotational dual ph thesis free university amsterdam june 
philip peter lee frank pfenning modal types staging specifications run time code generation acm sigplan notices 
frank wolter michael intuitionistic modal logic tech 
report institute computer science january appear logic florence 
available www informatik uni leipzig de wolter ps 
gonzalo reyes topos theoretic approaches modality category theory lecture notes mathematics vol 
springer verlag como italy pp 

jean goubault goubault lsv ens cachan fr www lsv ens cachan fr goubault lsv cnrs umr ens cachan av 
du pr wilson cachan cedex eric goubault goubault cea fr www di ens fr goubault cea recherche list sla gif sur 
