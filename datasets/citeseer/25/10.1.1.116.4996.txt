causally totally ordered communication support catocs proposed important provide part basic building blocks constructing reliable distributed systems 
identify major limitations catocs investigate applicability catocs classes distributed applications light limitations potential impact facilities communication scalability robustness 
investigation find limited merit potential problems catocs 
fundamental difficulty catocs attempts solve state problems communication level violation known argument 
understanding limitations causally totally ordered communication david cheriton dale skeen computer science dept software systems stanford university palo alto california cheriton cs stanford edu skeen tss com causally totally ordered communication support catocs proposed important facility constructing reliable distributed systems 
causally ordered communication ensures messages delivered order consistent potential causal dependencies messages logical clock model imposing partial ordering events distributed system 
totally ordered communication support goes step ensure messages delivered order participants 
catocs implementations date provide atomicity message delivery ensuring messages received processes fail interval interest 
catocs implementations may provide failure notification causally totally ordered respect message traffic 
facilities catocs advocated suited research supported part darpa contract dabt 
preprint appear proceedings th symposium operating systems principles acm december asheville north carolina 
solving important distributed computing problems including particular data replication 
catocs justified identifying significant class real applications facilities sufficient efficient requirements efficiently satisfied alternative general purpose mechanisms 
investigate applicability catocs classes distributed applications particular focus examples catocs literature 
investigation find limited merit catocs 
basic difficulty catocs best explained terms argument 
catocs communication level consistency requirements typically expressed terms application state 
section describes greater detail mean causally totally ordered communication support catocs 
section describes number significant limitations cost techniques variety communication situations 
section considers applicability causal total ordering protocols number classes distributed applications including examples literature illustrating catocs protocols 
show limitations section significantly restrict benefits catocs application areas 
section presents arguments catocs communications data transfer path significant scaling cost 
conclude state level approach implemented object oriented technology provides efficient robust scalable easier specialize solution distributed systems problems considered 
causally totally ordered communication causally ordered message system messages delivered order messages sent determined happens relationship restricted message sending receiving events convenience extend happens relationship include messages 

natural restriction message events events message system knows 
simplest case message said happen exists process sent received sends 
transitive closure simple cases yields full happens relationship messages 
term causally precedes synonym happens causally precedes happens 
illustrates causal ordering common charting device known event diagram 
message sending receiving events arranged column process time advancing top bottom 
diagram shows process sends received process sends subsequently received process message causally precedes 
messages said concurrent causally precedes 
causal multicast delivers messages accordance happens relationship specified group processes known process group 
specifically messages multicast process group sending message happens sending message message delivered second message processes group 
causal multicast really means preserving 
process event diagram 
messages causally precedes 
messages concurrent causally unrelated 
proc 
proc 
proc 
sent received sent received 
literature referred broadcast protocol multicast protocol 
prefer term multicast 
totally ordered multicast delivers messages order processes process group concurrent messages 
message delivery commonly accordance happens relationship assumption systems provide causal guarantees 
systems providing catocs implement atomic message delivery ensuring message delivered non failing processes 
atomic message delivery loss message process delay indefinitely receipt casually dependent message effectively dropping messages 
clearly loss message transitively force dropping arbitrary number subsequent messages 
atomic message delivery implemented relatively straight forward way having process group buffer message receives sure message stable received members group 
assume discussion catocs systems provide atomic message delivery 
note atomicity property message delivery include processes fail execution catocs multicast 
message delivery atomic durable 
action durable changes survive failures recoveries 
specifically sender fails catocs protocol execution message stable guarantee remaining operational processes receive deliver message 
special case problem process send message process group receive act message locally member fail members process group receiving message potentially leaving state inconsistent members process group 
atomic durable message delivery catocs appears expensive provide supported implementations aware significant deficiency catocs reliable replicated data update 
catocs systems may provide failure notification consistently ordered respect message receipt process group 
appropriate consider utility ordering conjunction merits catocs general 
note ordered failure notification provided catocs useful standalone capability 
stressed focus understanding merits ordered message delivery consider merits ordered failure notification stand capability 
systems supporting multicast process groups causal communication support udp ip multicast earlier system examples 
systems exploit causal relationships ordering relationships incorporating mechanism communication system munin example 
concern merits implementing ordering relationships delivery messages multiple sources communication system 
ordering provided catocs called incidental ordering ordering incidents communication process group 
incidental ordering necessarily consistent semantic ordering determined information contained message 
example notifications changes database disseminated order committed database system catocs ensures semantic ordering updates provided communication system incidents occurring semantic order 
consequently systems provide call prescriptive ordering message delivery order effectively ordering constraints explicitly specified prescribed process time sends message 
described sections prescriptive ordering state level clocks temporal logical offers attractive alternative catocs real applications 
limitations costs catocs general problem arises attempting apply catocs actual application problems characterized follows catocs adequate ensure application level consistency providing additional mechanism state level remedy deficiency eliminates need catocs expensive small scale far efficient solution straight forward provide 
rest section identifies specific limitations costs catocs lead situation 
informally summarize limitations catocs say sure say story say say efficiently 

unrecognized causality say sure 
causal relationships arise messages semantic level recognizable happens relationship messages enforceable catocs 
situation typically arises external hidden communication channel shared database external environment 
illustrates limitation manufacturing system typical current manufacturing environments 
multiple instances shop floor control system executing accessing common database 
start processing lot request arrives instance shortly processing lot arrives 
instance processes respective request updates shared database multicasts results 
semantically meaningful causal relationship created requests database hidden communication channel 
interaction outside scope communication substrate multicast messages recognized causally related arrive order recipients violates semantic level causal ordering 
anomaly arise instances referred example concurrent threads multi threaded process shared state address space constituting hidden channel 
possible thread updates shared 
example illustrating unrecognized unenforced causal relationships 
shared database orders requests shop floor control sfc system ordering unknown communications substrate 
client system configuration communications substrate shop floor control instance common database shop floor control instance client event diagram dashed lines indicate messages sent outside communication substrate client sfc data sfc client base start request reply request reply start broadcasted broadcasted received start received memory data structures delayed scheduling sending multicast message second update thread multicast delivered catocs order respect actual shared state update true causal dependencies 
forcing inter thread communication take place message system shared data structures impractically reduce performance multi threaded servers cost messages compared cost shared memory access 
maintaining optimized causal graph threads interacting shared data structures significant code complexity performance overhead 
illustrates limitation external channel fire similar manufacturing setting 
process controlling furnace detects fire separate occasions multicasts fire warnings accordingly 
separate monitor program detects fire instance multicasts results 
unfortunately message received third process fire message incorrectly concludes fire 
messages sent causal multicast 
note behavior exhibited total ordered multicast 
fire effectively external channel semantic causal dependency created fire fire messages 
dependency recognized internal communication facilities enforced catocs 
limitation significantly limits usefulness causal communication applications majority interactions take place shared resources external channels outside scope communications substrate 
example increas 
event diagram illustrating example anomalous behavior dependent messages delivered late 
communication causal multicast 
proc 
proc 
proc 
fire message sent fire message sent second fire message sent msg received fire ingly popularity multi threaded shared servers shared state threads major problem 
similarly significant amount communication real time control systems occurs external channel provided external system controlled 
case difficult guarantee absence hidden channels prompting characterize limitation catocs say sure 
causal dependencies easily handled adding prescriptive ordering information messages reflect true ordering causal dependencies having recipients information ensure proper ordering 
example considering shared manufacturing database lot status records contained version numbers recipient easily correctly order messages 
provision version numbers viewed logical clocks database state obviates need catocs 
application state techniques eliminate uncertainty overlooked hidden channel catocs solution 
lack serialization ability say 
catocs ensure serializable ordering operations correspond groups messages 
updates data structures typically involve groups memory operations means ensuring serializability group operations constituting update required application level consistency 
example shared memory system processors ensure consistent total ordering accesses memory ensure consistency data structures shared memory 
locking standard solution optimistic concurrency control techniques 
catocs provides ordering individual messages 
update requires group messages handled serial unit requires additional mechanism 
extra mechanism typically obviates need catocs 
example locks shared data provide mutual exclusion memory updates different processors making relative ordering memory access processors irrelevant catocs required 
argument 
theory external communication channels create problems state approaches having external channel communicate uncommitted updates transaction part system 
experience computer channels faster typical external channels problems arise possibly catastrophic failure conditions example long lived transactions design systems users making trade favoring availability strict consistency 
cases user participation may required handle inconsistencies just arises continued operations network partition 
applies examples section require transactional support 
attendant serialization facility transaction mechanism obviates need catocs 
lack serialization ability catocs potentially serious incompatibility interfacing catocs applications transactional systems quite prevalent commercially 
inability catocs protocols group operations significant limitation handling higher level error conditions 
example update message replicated state distributed group server processes results consistent replicated state process able accept process message just receive message consistent order 
reality server processes may reject operation lack storage protection problems state applicationlevel constraints 
standard atomic transaction protocols allow participating server process abort transaction reasons 
proposed uses catocs maintaining distributed replicated data process effectively fail invoke full failure notification mechanism rejects message class reasons rely separate rollback recovery mechanism undoing effects message delivery nodes 
case expensive generally assumes message eventually accepted failed process approach entails atomic transaction mechanism obviates need catocs 
note dropping message state application level equivalent reordering message delivery dropping message acceptable case message ordering support catocs limited value application 

semantic ordering constraints say story 
semantic ordering constraints expressible happens relationship enforceable catocs 
generalizing previous limitation correct behavior application requires ordering constraints operations state constraints typically stronger distinct ordering constraints imposed happens relationship 
ordering constraints referred semantic ordering constraints run gamut weak strong may may require grouping 
example constraints include causal memory linearizability course serializability 
weakest semantic ordering constraints causal memory enforced causal multicast 
weak ordering constraint enforced totally ordered multicast protocols expensive cheaper protocols utilize state level logical clocks 
stronger ordering constraints linearizability serializability causally totally ordered multicast sufficient illustrated stock trading example developed section 
lack efficiency gain state level techniques say efficiently 
catocs protocols offer efficiency gain state level techniques appear far scalable 
catocs imposes ordering overhead messages eliminate need prescriptive ordering messages operations required toend semantics 
catocs eliminate reduce need timestamps versions real time manufacturing examples locks examples transactional techniques 
catocs prone delaying messages false causality messages incidentally causally dependent communication level semantically causally dependent 
situation arises happens relationship messages indicates potential causality actual causality 
just message received second message necessarily mean message caused second 
example false causality arise fig 
message just happened sent receipt message semantic sense caused receipt message caused internal timer external input instance 
false causality reduces performance unnecessarily delaying messages earlier supposedly causally related messages received delivered 
increases total memory requirements buffering unstable messages potentially prohibitive cost scale argued section 
amount false causality appears dependent application behavior causal domain group size 
studies overheads incurred false causality major concern designer systems catocs uncertainty regarding false causality overhead expect course challenge construct groups communication patterns minimize false causality 
catocs imposes overhead message transmission reception ordering information added transmission checked reception 
overhead increasingly significant cost networks go higher transfer rates aspects protocol processing optimized 
optimizing catocs limited interest greater 
note lightweight causal multicast protocols delay messages order preserve causal ordering 
alternative delaying dependent messages causal protocols append earlier causal messages dependent messages technique significantly increase network traffic 
functional benefit identified question return section 
catocs communication facility limited ensuring communication level semantics recognize enforce application state level toend semantic requirements arise hidden channels grouping requirements state access control resource limits 
limitation basically corollary known argument states lower level facility ensure higherlevel semantics best optimization higher level mechanisms 
original describing argument limitation illustrated considering careful file transfer 
file transfer completed successfully file data safely correctly stored file system recipient machine just data delivered network recipient machine 
recipient machine crash buffer overflow point instance 
check determine acknowledge entire file correctly safely stored recipient file system 
example basic transport protocol useful lower level optimization identify individual packets file data dropped reordered transmission correct situation optimizing common case transmission problems avoiding overhead retransmitting entire file 
argued catocs appears provide comparable optimization fact appears introduce significant extra overheads 
classes distributed applications classes distributed applications including major examples catocs literature justify catocs examined order evaluate merits catocs applications compared established state level techniques 
limitations identified previous section arise repeatedly discussion 
data dissemination applications netnews 
communication support usenet newsgroups cited example need causally ordered communication 
current usenet world possible receive response inquiry news group receiving inquiry catocs ensure 
actual problem particularly severe responses fact contain sufficient information inquiry including original inquiry news reader infer inquiry response 
informal poll colleagues strong sentiment messages usenet newsgroups significant problem 
considered example detail widely discussed support catocs 
multicast response delayed causative inquiry delivered 
solving problem catocs introduce desirable behavior 
causal group entire news group messages sent subsequent inquiry considered potentially causally related inquiry 
case user see subsequent messages news group delayed inquiry lost delayed 
match actual causality incidental ordering catocs new causal group created inquiry 
number resulting causal groups enormous number independent time usenet news groups 
amount state maintained communication system proportional number causal groups amount traffic outstanding 
current growing levels traffic scale related individual failures time participating nodes overhead impractical 
addition logistics regarding generation deletion groups nontrivial 
readers news groups realize actual grouping responses practice complicated considered rendering catocs problematic 
relatively straightforward solve netnews ordering problem application state level 
assign news article globally unique id response designated field containing id inquiry article local news database maintain order relationship specifically note articles missing 
news database browsed user option displaying order responses 
complexity maintaining ordering information local news database proportional number inquiries interest user number sent 
furthermore database maintains actual causal dependencies access required semantic information 
example points problems catocs lie notion causal relationships attempting implement causal ordering communication level 
trading application example 
security trading application widely cited support utility catocs 
dissemination trading information trader workstations consistent order natural causal multicast certainly want observe price changes actual order occurrence 
causal multicast enforce necessary semantic ordering constraints appears expensive 
version scheme exists 
line posting contain message id tags posting depends 

event diagram trading example illustrating anomalous ordering behavior communication causal multicast 
option price theoretical price option price theoretical price option price theoretical price theoretic option user pricing pricing monitor illustrates scenario semantic ordering constraints enforced 
price option multicast server 
server calculates theoretical price option basis trading decisions 
correct behavior application obeys semantic ordering constraint defined informally follows theoretical price ordered underlying option price derived subsequent changes underlying price 
anomaly occurs depicted example theoretical price data delivered underlying option price changed 
monitoring program observe inconsistent view world new option price theoretical price old option price 
new option price old theoretic price concurrent messages happens relationship messages causal total multicast avoid anomaly 
example illustrates limitation say story semantic ordering constraint new option price old theoretic price stronger happens relationship catocs 
note large percentage data trading floor computed data theoretical pricing data semantic ordering constraints frequent 
note anomaly example superficially resembles hidden channels anomalies 
helped design commercial trading floors production speak significant basis experience 
monitor output option false crossing due ordering anomaly depicted figures limitation illustrated different 
catocs solution appears expensive unique stock instrument assigned process group constrain message ordering causal multicast 
large trading floor monitor price changes stocks derivative instruments requiring process groups understand current catocs implementation support 
production systems designed pricing service maintains version numbers security prices real time timestamp sequence number 
computed data object records id version number base data object designated dependency field 
general purpose utilities maintain dependencies data objects applications exploit information ordering presenting data 
consistent theme simple state level solution dependency preserving utilities implemented low cost high degree generality 
utilities require causal multicast simplified 

example derivative instrument buy option underlying stock 

pricing information comes communication lines external sources nyse local pricing server line 
theoretical netnews trading solutions outlined generalized notion order preserving data cache useful number applications 
cache approach example problems simplified tackled right level abstraction system 
semantic information inquiry response relationship netnews object version dependencies trading applications readily available application state level exposed communication level 
global predicate evaluation global predicate evaluation problems normally expressed terms stable predicate true true detected corrective action taken 
examples include distributed deadlock detection distributed garbage collection orphan detection 
general solution problem involves snapshot local process states represent consistent cut local process states done straightforward way catocs 
catocs solutions stable predicate detection problem elegant couple major disadvantages 
firstly require catocs communication interaction possibly affect state stable predicate 
detection protocols typically run periodically continuously frequency orders magnitude frequency message sending hard justify cost catocs communication just detect stable properties 
secondly limitation catocs solution relies catocs may fail hidden channels unrecognized causal relationships 
important role stable predicate detection real systems research focused identifying efficient protocols requiring catocs 
elnozahy proposed periodic consistent snapshot protocol takes full consistent cut state level catocs 
protocol useful checking global predicates failure recovery 
marzullo identified subclass detection problems notion locally stable predicates 
subclass contains problems practical importance including detection transaction deadlock rpc deadlock deadlock loss token orphans termination forms garbage collection 
authors efficient general purpose detection protocol class problems proceed derive message efficient special purpose detection protocols general protocol 
schiper independently investigated similar subclass detection problems characterized strong stable properties efficient detection protocol class 
focusing deadlock detection problems important subset re formulated terms local predicates evaluation insensitive message ordering effectively transforming detection problem consistent cut just cut simpler problem 
deadlock detection protocols proper subclass locally stable detection problems strong stable detection problems solved simple protocol 
example consider distributed deadlock detection transaction system phase locking 
local property insensitive event ordering message state system 
consider set transactions tn uses phase locking 
set deadlocked independently true time execution waits waits tn waits tn tn waits property implies wait relationships detected incrementally need detected order events occurred order receipt wait information affect detection valid deadlocks 
construct global wait graph sufficient node multicast local wait graph nodes running detection algorithm 
stronger ordering properties required 
follows clause property actual deadlocks detected false deadlocks detected 
simple variants deadlock detection algorithm nested transactions rpc deadlock detection orphan detection 
discussion indicates important stable predicate detection problems occurring real systems fall subclasses solved general purpose detection protocols catocs 
protocols cheaper catocs protocols require catocs communication interaction just communications involved consistent cut 
detection problems requiring full consistent cut solved periodic consistent snapshot protocol implemented efficiently state level catocs 
transactional applications transactional applications cited example catocs 
distributed transaction management protocol orders transactions 
note property necessarily hold non phase protocols 
ensures serializability 
particular pessimistic transaction management ordering transactions dictated phase locking data accessed part transaction 
relative message ordering concurrent separate transactions irrelevant regards correctness transaction committed independently prepare commit phase protocol necessarily requires acknowledgments participating node allowed abort transaction 
limitation catocs execute phase 
commit protocol executed single site commit coordinator delivery commit phase messages easily ordered conventional transport mechanisms catocs 
catocs needed noted limitation sufficient place locking mutual exclusion group operations required just consistent ordering individual operations 
considering intra transaction ordering operations conventional transactions executed single sequential process operations ordered process execution conventional transport protocol ordering applied messages generated process 
multi threaded transaction threads need synchronized state level general 
groups operations separate threads interleaved resulting inconsistencies consistent causal total ordering actions 
catocs adequate necessary state solution applied 
called optimistic transaction system transactions globally ordered commit time transaction aborted conflicts earlier transaction 
inter transaction ordering required execution transaction operations 
simple ordering mechanism local timestamp coordinator initiation commit protocol plus node id break ties provides globally consistent ordering transactions needing catocs 
replicated data replicated data management frequently cited reason catocs supposedly simplifies higher level mechanisms avoids update aborts due failures arise transactional solution improves performance asynchrony 
close inspection optimized atomic transaction approach appears uniformly superior 
simple transaction transaction facilities transaction mechanism provide simple high level interface application code 
provides functionality ability atomically group updates abort groups updates say 
secondly replicated data management system replicated transactional file system read write available protocol optimized match behavior catocs presence failure 
particular transaction updating replicated files drop failed servers availability list transaction commit commit transaction remaining servers provided transaction holding read locks failed servers 
availability list mechanism required bringing servers back consistent state serving clients catocs transactions 
transaction protocol optimization simple replicated file update aborts failure cases catocs 
catocs provides comparable support consistent update groups files objects say appears inferior solution compared optimized atomic transactions 
actual asynchrony achieves catocs systems limited illustrated considering deceit file system built isis system toolkit implementing catocs protocols 
deceit write updates sent replicas causal multicast essentially asynchrony isis causal multicast operation waits acknowledgments called write safety level fault tolerance level write safety level asynchronous acknowledgments write data lost single failure lack durability compromising semantics presumably purpose replication 
typical replication level non zero write safety level implies synchronous update servers just conventional rpc write multicast primary site server handling write operation 
higher degrees replication expect benefit significant differences round trip times different servers write safety level smaller number replicas 
generally speaking catocs requires trading concurrency asynchrony 
transactional systems execute individual updates synchronously permit concurrent systems necessarily support concurrency control serializability 
parallelism single update restricted parallelism concurrent updates 
individual computations threads increase concurrency parallelism updating 
contrast catocs implementations typically enforce primary updater approach catocs provides explicit mechanism concurrency control 
similarly primary multi threaded 
asynchrony updates limited non durability discussed catocs solution ends parallel efficient 
considering deceit detail number considerations server limit benefits catocs 
firstly considerable server specific mechanisms required handle reconciliation files significant failures network partitions catocs aid implementation mechanisms 
fact implementor deceit failure detection primary benefit provided isis facilities server catocs specifically causal multicast relatively limited benefit 
secondly failure deceit results flurry messages members process group active file create new view flush messages sent previous view 
view change managed synchronous operation imposes processing messaging overhead availability set update similar overhead required transactional system 
specific point comparison harp file server transaction replicated nfs file server providing service similar catocs deceit file server 
harp uses highly optimized atomic transaction techniques claimed provide better performance deceit tolerates wide range failures 
achieved spite fact nfs dictates treating file write separate transaction 
replication large replication large large scale naming services exploit application state specific techniques ensure consistency updates exploit application specific tolerance inconsistencies anomalies favor availability performance strict ordering 
instance lampson design suggests duplicate name binding resolved undoing name bindings 
scale multi national directory service design addresses tolerating occasional undo nature far preferable practice having directory operations significantly delayed message losses reorderings 
experience operating causal total ordering support scale size communication state required node impractical expected levels traffic reasonable probabilities node communication failures 
catocs viewed general solution saving code expected extra costs operation appear justify specialized solution especially extrapolating deceit experience system complexity dominated management recovery aspects outside independent base catocs facility 
distributed real time applications real time applications cited application area catocs generally characterized systems monitor control physical system real time clock wall time 
examples include factory monitoring control airplane distributed interactive simulation 
distinguish monitoring aspect control aspect systems applications 
limitations catocs realtime systems significant 
firstly pointed section causal relationships implemented catocs real time system may incomplete true semantic causal relationships implemented monitored system totally outside catocs mechanism unrecognized causality limitation 
example message sent actuator move temperature sensor factory oven may semantically cause alarm message separate oven temperature sensor relationship recognized catocs mechanism 
particular control message may received message logging device alarm message 
secondly catocs support need realtime systems execute groups operations real time achieve desired effect easily implemented timestamping messages possibly transaction mechanism abort group 
example starting factory oven lighting pilot grouped opening gas value pilot flame 
catocs inefficiency delaying message delivery false causality general communication overheads detracts just performance correctness real time system 
monitored system correctness system semantic notion consistency maximized minimizing difference computer stored state actual state monitored system 
example value oven temperature stored computer oven control factory close actual temperature oven call sufficient consistency 
sufficient consistency normally provided sensors transmitting periodic updates communication system giving priority updates dropping older updates necessary monitoring system interpolating smoothing averaging updates accommodate lost updates replicated sensors erroneous readings 
update messages delayed catocs reduce consistency monitored system detract correctness operation 
delay occurs message received potentially causally dependent message received 
consistent ordered view failures provided catocs systems means additional message delays incurred process fails new view determined propagated process group members 
additional group wide delay real time systems worse form failure failure individual group member process functions replicated systems requiring reliability 
implementing part message traffic system catocs avoid disadvantages aggravates problem message delivery catocs accurately reflecting happens true causal relationships messages 
example update message oven controller may cause send message cell controller may turn cause initiate reconfiguration action 
message sent outside catocs rest sent causal totally ordered process groups part causal relationship recognized catocs 
real time programmer carefully reason partial correctness catocs delivery sufficient application 
similar arguments put forward controller aspects real time distributed systems see 
contrast catocs approaches state approach real time clock values key shared piece state real time system simple implement provides far better semantics including true temporal precedence important precedence relationship realtime systems 
example oven sensor places realtime timestamp update message information ordering events real time recording events log correlating events factory events may occurred outside monitoring system 
example local power utility may report power surge particular real time factory manager wishes correlate log oven behavior 
real time timestamp provides ability purely logical incidental ordering provided catocs 
implementation distributed realtime clock synchronization understood takes little communication processing available variety distributed systems 
amount mechanism required substantially smaller required catocs critical path sense time synchronization invoked data communication action 
synchronized time service required realtime systems case highly reliable 
computer maintained timestamp far accurate timing events real time systems 
example timestamp granularity microsecond range accuracy millisecond events real time systems occur granularity tens milliseconds 
example computer controlled flight surfaces advanced tactical fighters operate hz range 
high performance control sense separate sensor controller network packets lost introducing delays exceeding acceptable application 
note potential delay due lost packet generally round trip time especially multicast communication problem acknowledgment implosion precludes tight time outs 
temporal precedence provided timestamping specifies ordering events semantically meaningful real time systems provides ordering events required imposing load complexity communication system 
contrast catocs incidental ordering capture actual causal relationships semantic ordering constraints messages unnecessarily delays delivery messages correctness performance imposes complexity processing burden communication support 
catocs scalability catocs appears introduce significant problems scaling roughly quadratic growth expected message buffering arises growing numbers participating processes section provides informal argument expected behavior 
consider scaling system processes catocs 
causal order messages system represented directed acyclic graph nodes messages arc nodes represents messages potentially causally related 
active causal graph subgraph results deleting nodes corresponding stable messages incidental arcs stable messages known delivered 
number nodes messages active causal graph proportional number processes system reasoning 
time sending message deletion active causal graph roughly proportional diameter system time propagate message system 
number messages transmitted time number constituting nodes active causal graph equal message rate process times number processes times time grows number processes roughly proportional square root number processes 
just need 
term process designate participant catocs group consistent previous discussion terminology catocs literature 
process discussion typically representative service network node 
non decreasing number processes desired result 
number arcs grow quadratically number messages 
instance process multicasts new message group receiving message introduces new arcs graph 
argue properly structured applications exhibit linear growth active message graph number arcs grows quadratically possible causal graphs false causality tends increase number arcs actual causal relationships application 
amount buffering catocs system tends grow proportional number arcs active causal graph reasons 
number causal graph arcs quadratic number processes number causal dependencies communicated message average linear number processes 
number messages referenced causal dependencies received process grows linearly number assuming error delay rate roughly fixed percentage message rate standard realistic assumption 
amount buffering process holding delayed messages expected grow linearly number processes system 
buffering requirements system tend grow quadratically number processes 
practically stated buffering requirements individual node tend grow linearly increase scale system node participates unfortunate property caused problems systems xerox grapevine mail system 
buffering requirements grow quadratically memory required store active causal graph descriptors tend smaller messages 
buffering requirements increased implementations provide atomic message delivery node retain copy message message sends referenced message known stable recipients received referenced message 
example cell controller sends message potentially causally dependent message sensor catocs cell controller buffers message sensor sensor message stable 
argued section atomic message delivery necessary useful 
square root growth assumes uniform world nodes packed circle 
reality significantly higher delay wide area communication compared local area communication 
growing scale introduces growing heterogeneity communication technology capacities increasing delay packet loss 
implementation catocs plus assumed example uses catocs fault tolerant systems 
receiver new message assumes get copies causally referenced messages sender new message original sender referenced messages crashed 
group membership change protocols required catocs enforce atomic delivery semantics scalability concern rate member failures increases linearly group size cost protocol execution 
membership change protocols suppress sending new messages significant portion protocol 
partitioning large process group smaller process groups necessarily reduce problem smaller groups causally related 
instance causal domain proposed causally related set groups quadratic growth 
division groups reduces application generated message traffic receiver message delivery delays 
buffering requirements reduced delaying sending messages addition delaying delivery 
delaying obvious detrimental effects application performance particularly real time near realtime applications trading example section 
delaying messages produces highly synchronous execution messages delayed endto acknowledgments indicating stability 
increases communication overhead stabilizing messages fewer application messages piggyback acknowledgment information vector clock 
summary worst case statistically expected behavior catocs buffering requirements grow quadratically number processes system 
delaying transmission messages restricting communication topology reduce problem cost application performance 
various optimizations partitioning process groups sending additional message traffic may reduce buffering required techniques provide guarantees increase complexity implementation troublesome situation applications striving fault tolerance 
state level solutions put forward alternatives require extensive buffering real time applications able buffer updates secondary storage replicated data implementations 
state applications easily distinguish updates queries reduce buffering logging catocs approach separate process group reads writes attendant loss causal ordering types operations 
causally totally ordered communication support catocs appealing idea appears significantly limited major limitations identified informally say sure say say story say efficiently 
classes distributed applications considered include catocs literature justify support limitations imply catocs adequate narrowly applicable 
case state solution established techniques appears relatively straight forward implement obviates need catocs 
cases examined catocs fails provide simplification application writer 
scalable performance appears problem catocs 
adds processing overhead buffering performance critical message transmission reception paths unnecessarily delays messages false causality fails allow asynchrony need acknowledgments real time uses catocs mechanism appears limited benefit 
fact considerations expected quadratic cost message buffering appear restrict practical deployment applications significantly restricted size communication topology 
known argument played key role investigation 
considering real distributed applications detail toend semantics applications available critically evaluating full requirements alternative techniques catocs 
contrast catocs literature contains process message examples lack sufficient detail identify alternatives 
repeatedly observe applications place requirements distributed state catocs provide limited consistency guarantees communication 
argument state consistency ensured state level operations catocs best regarded optimization 
mechanism required ensure state level consistency subsumes need catocs catocs provides performance improvement cases considered 
attractive generic mechanism abstraction catocs variety distributed applications systems application specific solution better problem 
ideal framework state level framework communication level catocs consistency requirements 
distributed systems supporting objects types development number research development organizations fact commercial cases provide framework 
objects state level entities object systems focused state level techniques communication incidental implementation appropriate consistency reliability considerations 
object systems provide powerful object oriented mechanisms inheritance type safe dynamic binding allow applications generic base class functionality atomic transaction support specialize base classes needed meet application specific requirements 
resulting frameworks easier programming basic message level solve state problems state level avoid complicating base communication facilities avoiding attendant performance robustness penalties 
broadening focus slightly conjecture view expressed lamport logical clocks communication activity better applied state level 
object oriented view distributed systems clock ticks state object versions relevant communication clock ticks state clocks generally advance rate order magnitude slower communication clocks reads outnumber writes 
state clocks easily durable state relate write clock value part updating state high rate communication clock ticks generally stable storage infeasible 
reasoning distributed systems communication clocks fails focus relevant aspect state separates important dynamics state updates deals ephemeral easily recreated activity communication key issue fault tolerance recovery state durability 
state level clocks accurately drive reasoning correspond directly practical implementations 
focused primarily understanding limitations catocs addresses general issue placement function distributed systems powerful argument show merits state level reasoning implementation techniques communication level approaches 
applications dictating requirements choice implementation techniques available level regard correct level function placement key challenge systems designers 
proposed principle solve state problems state level represents promising starting point 
hope expect research experience distributed systems applications refine extend understanding area 
acknowledgments benefited enormously comments anonymous reviewers stuart cheshire ed lazowska keith marzullo hector garcia molina alex siegel raj willy zwaenepoel 
ahmad john implementing programming distributed shared memory proc 
th international conference distributed computing systems may 
birman joseph reliable communication unreliable environment acm transactions computer systems feb 
birman joseph exploiting replication distributed systems distributed systems edited mullender acm press addison wesley new york 
birman schiper stephenson lightweight causal atomic group multicast acm transactions computer systems august 
cheriton zwaenepoel distributed process groups kernel acm transactions computer systems may 
cheriton skeen understanding limitations causally totally ordered communication comp 
sci 
research report stan cs stanford univ sept 
deering host extensions ip multicast internet rfc aug 
detlefs herlihy wing inheritance synchronization recovery properties ieee computer dec 
elnozahy johnson zwaenepoel performance consistent checkpointing proc 
th symp 
reliable distributed systems oct 
goodman skeen chan dayal fox ries recovery algorithm distributed database system proc 
nd symp 
principles database systems atlanta georgia march 
herlihy quorum consensus replication method types acm transactions computer systems feb 
herlihy wing linearizability correctness condition concurrent objects acm trans 
programming languages systems july 
joseph birman reliable broadcast protocols distributed systems edited mullender acm press addison wesley 
keleher cox zwaenepoel lazy release consistency software distributed shared memory proc 
th int 
symp computer architecture may 
ladin liskov shrira ghemawat providing high availability lazy replication acm transactions computer systems nov 
lamport time clocks ordering events distributed system comm 
acm july 
lampson designing global name service proc 
th acm symp 
principles distributed computing calgary aug acm 
liskov curtis johnson scheifler implementation argus proc 
th symposium operating system principles austin tx november 
liskov replication harp file system proc 
th symposium operating system principles oct pacific grove ca 
marzullo tolerating failures continuous valued sensors acm transactions computer systems nov 
marzullo consistency detecting stable properties proc 
international workshop distributed algorithms delphi greece oct 
mishra peterson implementing fault tolerant replicated objects proc 
th symposium reliable distributed systems seattle washington oct 
oki siegel skeen information bus architecture extensible distributed systems proc 
th symposium operating system principles dec asheville north carolina 
rodrigues multi primitive group communications service proc 
th symposium reliable distributed systems ieee houston tx october 
saltzer reed clark arguments system design acm trans 
computer systems nov 
schiper strong stable properties distributed systems technical report lse tr dept computer science epf lausanne march 
siegel birman marzullo deceit flexible distributed file system proc 
usenix summer conf anaheim ca june 
siegel private communication april 
van renesse causal controversy le mont st michel operating systems review april 
weihl liskov implementation resilient atomic data types acm transactions programming languages systems april 
appendix appendix presents additional examples contrasting catocs approaches non catocs ones 
drilling example control actions entail scheduling sequences actions performed independent nodes particular schedule 
example causal ordering support control cell controllers sequencing drilling operations birman 
possible cases scenario map applicationlevel scheduling requirements incidental ordering provided causal communication 
solution appealing providing highly distributed execution controllers schedule independently broadcast drilling request 
question address implement application catocs 
think 
input process set holes 
product checklist describing holes need checked drills may failed part way drilling step 
constraint holes multiple times partially time 
solution supposed survive failures controllers 
state set holes states completed checked plus state controllers 
realistic solution central cell controller monitor state controllers assigning drilling operations transmit assigned holes reporting back completed hole 
reliability central controller state replicated sites practice second backup sufficient storing state stable storage protection power glitches common factories important higher degrees replication 
approach communication traffic linear number controllers quadratic claimed birman solution catocs required 
distributed scheduling approach birman solution controller independently assigns holes relies causal ordering guarantee drills collide hole 
thing accomplished state approach making state distributed replicated object having monitor update state completes hole 
update performed simple replicated update schedule locking commit hole assigned separate controller update refused 
fact wait acknowledgments birman solution waits synchronously tied degree fault tolerance required 
drill fails failure monitor synchronize controllers new schedule remaining proceed new non conflicting schedule 
requires synchronous atomic transaction controllers 
failures frequent perfor mance resulting system faster catocs techniques normal case communication non ordered multicast rpcs normal drilling updates 
rpc deadlock detection rpc deadlock detection algorithm van renesse apparent simplicity attributed causal communication protocols 
algorithm appears expensive realistic settings 
alternative rpc deadlock detection algorithm general formulation problem simple van renesse algorithm performs better require causal communication 
solution re formation detection problem expressed stable local predicate 
van renesse algorithm process causally multicasts rpc invocation rpc return 
monitor process receives rpc related events constructs wait graph 
appearance cycle wait graph indicates deadlock 
monitor process provide fault tolerance 
causal communication yields simple expensive algorithm 
rpc invocation algorithm results causal multicasts multicasts process group consist monitor processes plus processes potentially invoke rpc order propagate potential causality information 
performance penalty algorithm appears prohibitive especially detection relatively infrequent event deadlock 
consider alternative solution simple re formation problem 
assign rpc invocation locally unique instance identifier 
augment wait information instance identifiers 
example denotes rpc instance executing process waiting rpc instance process process periodically multicasts augmented wait information set monitor processes conventional sequence number timestamp ensuring multicasts sent process received order sent 
monitors construct wait graph nodes represent instances 
cycle implies deadlock 
alternative algorithm simple van renesse require causal communication 
general handle multi threaded processes invocations may active time detect deadlocks involve resource sharing rpc instances multi threaded server 

