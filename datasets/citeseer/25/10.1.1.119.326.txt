symbolic boolean manipulation ordered binary decision randal bryant school computer science carnegie mellon university pittsburgh pennsylvania ordered binary decision diagrams obdds represent boolean functions directed acyclic graphs 
form canonical representation making testing functional properties equivalence straightforward 
number operations boolean functions implemented graph algorithms obdd data structures 
obdds wide variety problems solved symbolic analysis 
possible variations system parameters operating conditions encoded boolean variables 
system evaluated variations bya sequence obdd operations 
researchers solved number system design finite state system analysis mathematical logic 
describes obdd data structure surveys number applications solved obdd symbolic analysis 
categories subject descriptors logic design reliability logic design design aids computation devices models computation automata algebraic manipulation expressions representation algebraic manipulation algorithm artificial intelligence deduction theorem proving general terms algorithms verification additional key words phrases binary decision diagrams boolean functions boolean algebra branching programs symbolic analysis symbolic manipulation tasks digital system design combinatorial optimization mathematical logic artificial intelligence formulated terms operations small finite domains 
introducing binary encoding elements domains problems reduced operations boolean values 
symbolic representation boolean functions express problem general form 
solving generalized problem symbolic boolean function manipulation pro vides solutions large number specific problem instances 
efficient method representing manipulating boolean functions symbolically lead solution large class complex problems 
ordered binary decision diagrams obdds bryant provide representation 
representation defined imposing restrictions binary decision diagram bdd representation introduced lee akers resulting form canonical restrictions resulting canonicity recognized supported defense advanced research project agency arpa order number national science foundation mip 
written author leave fujitsu laboratories kawasaki japan 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 
acm acm computmg surveys vol 
september randal bryant contents 
obdd representation binary reducing effect variable ordering refinements operations construction manipulation apply operation restrict operation operations performance characteristics implementation techniques 
representing mathematical systems encoding sets digital system design applications design error correction 
finite state system analysis application areas 
areas improvement summary fortune 
functions represented directed acyclic graphs internal vertices corresponding variables function defined terminal vertices labeled function values 
obdd representation function may size exponential number variables useful functions compact representations 
operations boolean functions implemented graph algorithms operating obdds 
tasks problem domains expressed entirely terms operations obdds lee represented boolean binary decision programs form straight line program 
program viewed linear ordering vertices directed graph distinction forms minor 
acm computmg surveys vol 
september full enumeration problem space truth table state transition graph search tree need constructed 
obdds researchers solved problems possible traditional techniques case analysis combinatorial search 
date applications obdds areas digital system design verification testing 
interest spread areas concurrent system design mathematical logic artificial intelligence 
provides combined tutorial survey symbolic boolean manipulation obdds 
sections describe obdd representation algorithms construct manipulate 
section describes basic techniques representing operating number mathematical structures including functions sets relations symbolic boolean manipulation 
illustrate techniques describing applications obdds conclude describing areas research 
application examples involve problems digital system design believe similar methods applied variety application domains 
background assume reader basic knowledge boolean functions logic design finite automata 

obdd representation binary decision diagrams recognized representations boolean functions years 
name branching programs studied extensively complexity theorists wegener 
key idea obdds restricting representation boolean manipulation simpler computationally 
consequently provide suitable data structure symbolic boolean manipulator 
ordered binary decision diagrams xl ii ti 
truth table decision tree representations boolean function 
dashed solid branch denotes case decision variable 
binary decision diagrams binary decision diagram represents boolean function rooted directed acyclic graph 
example illustrates representation function xz defined truth table left special case graph tree 
nonterminal vertex labeled variable uar arcs directed children shown dashed line corresponding case variable assigned hi shown solid line corresponding case variable assigned 
terminal vertex labeled 
assignment variables value yielded function determined tracing path root terminal vertex branches indicated values assigned variables 
function value terminal vertex label 
due way branches ordered values terminal vertices read left right match truth table read top bottom 
ordering reducing ordered bdd obdd impose total ordering set variables require vertex nonterminal child respective variables ordered uar uar 
decision tree example variables ordered xl xz 
principle variable ordering selected arbitrarily algorithms operate correctly ordering 
practice selecting satisfactory ordering critical efficient symbolic manipulation 
issue discussed section 
define transformation rules graphs alter function represented remove duplicate terminals 
eliminate terminal vertex label redirect arcs eliminated vertices remaining 
remove duplicate nonterminals 
nonterminal vertices uar uar lo lo hi hi eliminate vertices redirect incoming arcs vertex 
remove redundant tests 
nonterminal vertex hi eliminate redirect incoming arcs lo 
starting bdd satisfying ordering property reduce size repeatedly applying transformation rules 
term obdd refer maximally reduced graph obeys ordering 
example illustrates reduction decision tree shown obdd 
applying transformation rule reduces terminal vertices 
acm computmg surveys vol 
september randal bryant xl 
terminals xl xl 
nonterminals cl 
reduction decision tree obdd 
applying reduction rules tree yields canonical representation function obdd 
applying second transformation rule eliminates vertices having variable arcs terminal vertices labels hi 
applying third transformation rule eliminates vertices variable variable xz 
general transformation rules applied repeatedly transformation expose new possibilities ones 
obdd representation function canonical ordering obdds function isomorphic 
property important consequences 
functional equivalence easily tested 
function satisfiable iff obdd representation correspond single terminal vertex labeled ical function terminal vertex labeled obdd representation 
function independent variable obdd representation contain vertices labeled obdd representations functions generated functional properties easily testable 
figures illustrate construct obdd representation function truth table constructing reducing decision tree 
approach practical functions small number variables truth table decision tree size exponential acm computmg surveys vol 
september number variables 
obdds generally constructed symbolically evaluating logic expression logic gate network apply operation described section 
effect variable ordering form size obdd representing function depends variable ordering 
example shows obdd representations function denoted boolean expression az ct denotes operation denotes operation 
case left variables ordered bl az bz case right ordered az az bl bz 
generalize function variables bl 
expression bl az 
bz 
ab generalizing variable ordering bl 
yields obdd nonterminal vertices variable 
generalizing second variable ordering bl 
hand yields obdd nonterminal vertices 
large values difference linear growth ordering versus exponential growth second dramatic effect ordered binary decision diagrams 
obdd representations single function different variable orderings storage requirements efficiency manipulation algorithms 
examining structure graphs see case variables paired occurrences boolean expression bl bz 
second level graph branch destinations required terminal vertex labeled case corresponding product yields level case product point yields hand levels second case form complete binary tree encoding possible assignments variables 
general assignment variables function value depends unique way assignment variables 
generalize function ordering variables levels obdd form complete binary tree 
applications obdds choose ordering variables outset construct graphs ordering 
ordering chosen manually heuristic analysis particular system represented 
example heuristic methods devised logic gate network generally derive ordering variables representing primary inputs fujita malik 
developed sequential system analysis jeong 
note heuristics need find best possible ordering ordering chosen effect correctness results 
long ordering avoids exponential growth operations obdds remain reasonably efficient 
complexity characteristics obdds provide practical approach symbolic boolean manipulation graph sizes remain worst case exponential number variables 
previous examples show functions sensitive variable ordering remain quite compact long ordering chosen 
furthermore ample empirical evidence indicating functions encountered real applications represented efficiently obdds 
way understand fully strengths limitations obdds derive lower upper bounds important classes boolean functions 
acm computing surveys vol 
september randal bryant table 
obdd common classes function class complexity best worst linear quadratic linear exponential bits exponential table summarizes asymptotic growth rate classes boolean functions sensitivity variable ordering 
symmetric functions function value depends number equal insensitive variable ordering 
trivial case constant functions functions graphs ranging linear parity quadratic half inputs equal 
consider output bit adder boolean function variables 
representing operand bo bl 
representing operand 
function bit obdd representations linear complexity ordering bo bl 
exponential complexity ordering 
bo 

fact functions representations similar function shown 
boolean functions representing integer multiplication hand form particularly difficult case obdds 
regardless ordering boolean function representing middle outputs bit multiplier exponential obdd representations bryant 
upper bounds classes boolean functions derived structural properties logic network realizations 
berman mcmillan derived useful bounds classes acm computmg surveys vol september bounded width networks 
consider network primary inputs primary output consisting logic blocks block may multiple inputs outputs 
primary inputs represented source blocks input output 
example shows network having output significant sum bit bit adder 
network consists carry chain computing carry input final stage 
blocks labeled compute majority function having output inputs 
output computed exclusive significant bits inputs 
define linear arrangement network numbering blocks block producing primary output numbered 
define forward cross section block total number wires output block input block define forward cross section wf circuit respect arrangement maximum forward cross section blocks 
dashed line shows adder circuit forward cross section 
similarly define reverse cross section block total number wires output block input block arrangements blocks ordered topologically case considered berman shown reverse cross section define ordered binary decision diagrams 
linear arrangement circuit computing significant bit integer addition 

linear arrangement 
shown forward cross section logz reverse cross section logz 
reverse cross section circuit respect arrangement maximum reverse cross section blocks 
measures shown obdd representing circuit function ngu vertices 
furthermore finding arrangement low cross section leads ordering function variables reverse ordering corresponding source blocks arrangement 
bound network realizations leads useful bounds variety boolean functions 
example functions having realizations constant forward cross section zero reverse cross section adder circuit linear obdd representations 
symmetric function variables realized circuit having forward cross section log reverse cross section circuit consists series stages compute total number inputs having value encoding total log zn bit binary number 
realization implies quadratic upper bound obdd size stated table 
st 
dashed line shows application result circuit nonzero reverse cross section 
circuit shows general realization function constant inputs xo xl 
function yields inputs equal equals mod value illustrates function computed series blocks arranged ring block outputs bit value bit logz kl integer value land ll realization signal encodes number remaining positions input value paired signal indicates pair inputs having acm computmg surveys vol september randal bryant value distance occurred far 
realize modular proximity measure output final stage routed back initial stage 
note circuit cyclic structure output uniquely defined input values 
dashed line indicates ring structure flattened linear arrangement having forward cross section reverse cross section construction yields upper bound obdd size 
constant values obdd linear size constant factor grows rapidly mcmillan generalized technique tree arrangements network organized tree logic blocks branching factor primary output produced block root 
arrangement forward respectively reverse cross section refers wires directed respectively away root 
arrangement obdd yields size er bound upper bound linear arrangement formula 
observe constant values wf obdd size polynomial upper bound results give insight functions encountered logic design applications efficient obdd representations 
suggest strategies finding variable orderings finding network realizations low cross section 
results form representations boolean functions prove useful characterizing potential obdds application domains 
refinements variations years refinements basic obdd structure reported 
include single graph represent functions required brace karplus reeves irwin adding labels arcs denote boolean negation brace acm computmg surveys vol september karplus madre generalizing concept finite domains srinivasan 
refinements yield significant savings memory requirement generally critical resource determining complexity problems solved 
applications require generating vertices routinely performed workstation computers 

operations introduce notation describing operations boolean functions 
standard operations boolean algebra exclusive 
addition symbol indicate complement exclusive operation referred exclusive 
summation product notation boolean sums products 
observe operations defined functions boolean values 
example functions set variables function variables 
assignment values variables yields iff yields 
constant functions yielding variable assignments denoted respectively 
function resulting argument function assigned constant value called restriction call cofactor brayton denoted 
restrictions function respect variable function reconstructed flx fl ze 
identity commonly referred shannon expansion respect originally recognized boole brown 
variety useful operations defined terms algebraic operations plus restriction operation 
composition operation function substituted variable function identity flx fl 
flx variable quantification operation variable function existentially universally quantified identities fl flx flr researchers prefer call operations smoothing existential consensus universal emphasize operations boolean functions truth values lin 

construction manipulation number symbolic operations boolean functions implemented graph algorithms applied obdds 
algorithms obey important closure property arguments obdds obeying ordering result obdd obeying ordering 
implement complex manipulation sequence simpler manipulations operating obdds common ordering 
users view library bdd manipulation routines implementation boolean function data type selection variable ordering operations implemented purely mechanical way 
user needs concerned details representation implement ation 
apply operation apply operation generates boolean functions applying algebraic operations functions 
argument functions plus binary boolean operator op apply ordered binary decision diagrams returns function op operation central symbolic boolean manipulator 
complement function computing 
functions don care conditions expressed function yields variable assignments function values unimportant test equivalent care conditions computing test result function 
construct obdd representations output functions combinational logic gate network symbolically interpreting network 
start representing function primary input obdd consisting test single variable 
proceeding order network 
apply operation construct obdd representation gate output gate operation obdds computed inputs 
apply algorithm operates traversing argument graphs depth maintaining hash tables improve efficiency computation assist producing maximally reduced graph 
note earlier presentations treated reduction canonical form separate step bryant algorithm produces reduced form directly 
illustrate operation example applying operation functions having obdd representations shown 
implementation apply operation relies fact algebraic operations commute shannon expansion variable op flx op gl 

fl 
op observe function represented obdd root vertex restriction respect variable uar rf computed acm computmg surveys vol september randal bryant ai az bz 
example arguments apply operation vertices labeled identification execution trace 
simply rf var rf flx lo rf tmr rf hi rf uar rf restriction represented graph subgraphs root 
equation forms basis recursive procedure computing obdd representation op example recursive evaluation structure illustrated 
note evaluation step identified vertex argument graphs 
suppose functions represented obdds root vertices respectively 
case rf terminal vertices recursion terminates returning appropriately labeled terminal vertex 
example occurs evaluations bl 
variable splitting variable defined minimum variables var rt uar 
obdds functions fl op gl fl op gl computed recursively evaluating restrictions value indicated dashed lines value indicated solid lines 
example initial evaluation vertices bi causes recursive evaluations vertices ag 
acm computmg surveys vol september az 
bz 
execution trace apply operation operation evaluation step operands vertex ar ment graph 
implement apply operation efficiently add refinements procedure described 
reach condition arguments terminal vertex representing dominant value operation op recursion return appropriately labeled terminal vertex 
occurs example evaluations bz aj bi 
second avoid making multiple recursive calls pair arguments maintaining hash table entry key pair vertices arguments datum vertex generated graph 
start evaluation arguments check entry key table 
entry return datum entry avoiding recursion 
entry follow steps described creating new entry table returning result 
example refinement avoids multiple evaluations arguments bz bz 
observe refinement evaluation structure represented directed acyclic graph familiar tree structure recursive routines 
evaluation step returns result vertex generated graph 
recursive evaluation structure naturally defines unreduced graph 

result generation apply operation 
recursive calling structure naturally yields unreduced graph left 
applying reduction rules recursive call reduced graph generated directly right 
evaluation step yields vertex labeled splitting variable having children results recursive calls 
example graph illustrated left hand side 
generate reduced graph directly evaluation step attempts avoid creating new vertex applying tests corresponding transformation rules described section 
suppose evaluation step splitting variable recursive evaluations return vertices vi 
test uo vi return vertex procedure result 
second test generated graph contains vertex having uar lo vo hi ul 
test assisted maintaining second hash table containing entry nonterminal vertex generated graph key uar hi lo 
desired vertex returned procedure result 
vertex added graph entry added hash table vertex returned procedure result 
similarly terminal vertices entered hash table having labels keys 
new terminal vertex generated desired label 
example process avoids creating shaded vertices shown left hand side 
graph right hand side gen ordered binary decision diagrams erated directly 
observe graph represents function result applying operation argument functions 
table avoid multiple evaluations pair vertices bounds complexity apply operation yields bound size result 
suppose functions represented obdds having mf vertices respectively 
unique evaluation arguments evaluation adds vertex generated result 
implementation hash tables evaluation step performed average constant time 
complexity algorithm size generated result 
restrict operation computing restriction function represented kind bdd straightforward 
restrict variable value simply redirect arc vertex having rmr point lo hi illustrates variable function value 
original function obdd left redirecting arcs effect bypassing vertex labeled illustrated center 
example shows direct implementation technique may yield unreduced graph 
operation implemented traversing original graph depth 
recursive call argument vertex original graph returns result vertex generated graph 
ensure generated graph reduced procedure maintains hash table entry vertex generated graph applying reduction rules described apply operation 
example result obdd representation function shown right hand side 
acm computmg surveys vol september randal bryant ha aa ic el 
example restrict operation 
variable argument left value involves bypassing vertices labeled center reducing graph right 
computing restriction function having obdd representation mf vertices involves recursive calls generating vertex result graph 
hash table implementation recursive step requires constant time average 
complexity algorithm size generated result mt 
derived operations described section variety operations boolean functions expressed terms algebraic restriction operations 
apply restrict algorithms provide way implement operations 
furthermore operations complexity size generated graph bounded polynomial function argument functions 
function mt denote size obi representation 
functions don care conditions expressed function compute equivalence care conditions time 
compute composition functions restrictions calls apply 
approach time complexity 
implementing entire computation traversal complexity reduced nl bryant 
compute quantification variable function time mf 
acm computmg surveys vol 
september performance characteristics problem solved obdds expressing task series operations boolean functions discussed 
seen operations implemented algorithms having complexity polynomial sizes obdds representing arguments 
result obdd symbolic boolean manipulation advantages common approaches 
long graphs remain reasonable size total computation remains tractable 
second graph sizes grow successive operation single operation reasonable worst case performance 
contrast representations boolean functions lack graceful degradation property 
example function reasonably compact sum products representation complement may exponential size brayton 
implementation techniques standpoint implementation obdd symbolic manipulation different characteristics computational tasks 
course computation thousands graphs containing thousands vertices constructed discarded 
information represented obdd structure associated data values little computational effort expended vertex 
computation highly dynamic character predictable patterns memory access 
date successful implementations workstation computers large physical memories careful attention programming memory management routines brace 
extract maximum performance desirable exploit potential pipelined parallel computers 
symbolic analysis tasks parallelism exist macro level operations performed simultaneously micro level vertices obdd operated simultaneously 
compared tasks successfully mapped vector parallel computers obdd manipulation requires considerably communication synchronization computing elements considerably local computation 
task provides challenging problem design parallel computer architectures programming models languages 
early attempts proved promising 
researchers successfully exploited vector processing shown results executing shared memory multiprocessors kimura clarke 
implementations exploit micro parallelism implementing apply operation breadthfirst traversal argument graphs contrast depth traversal conventional implementations 

representing mathematical systems applications notably digital design call direct representation manipulation boolean functions 
general power symbolic boolean manipulation comes ability binary values boolean operations represent implement wide range different mathematical domains 
basic princi ordered binary decision diagrams ple seldom think 
example people define add operation computer set boolean functions set arguments 
table lists examples areas mathematics objects represented operated analyzed symbolic boolean manipulation long underlying domains finite 
providing unified framework number mathematical systems symbolic boolean manipulation solve just problems individual areas ones involving multiple areas simultaneously 
example programs analyze sequential behavior digital circuits see section involve operating areas listed table 
desired properties system expressed formulas logic system behavior state functions circuit 
analyzer computes sets states having particular properties 
transition structure finite state system represented relation 
execution analyzer readily shift representations obdds underlying data structures 
furthermore canonical property obdds easy detect conditions convergence solutions exist problem 
key exploiting power symbolic boolean manipulation express problem form objects represented boolean functions 
remainder section describe standard techniques developed line 
experience practice surprisingly wide range problems expressed manner 
mathematical concepts underlying techniques long understood 
techniques rely specifically obdd representation implemented number representations 
obdds simply extended range problems solved practically 
doing motivation express problems terms acm computmg surveys vol 
september randal bryant table 
example systems represented th boolean functions class logic finite domains functions sets relations typical operations dependent application composition composition closure applications domains natural encoding binary encoding finite integers constructed artificially 
example cosmos symbolic simulator bryant uses obdds compute behavior transistor circuit symbolically 
simulator automatically generate tests faults circuit formally verify circuit desired behavior 
circuit model represents node voltages signal set values represent low high voltages third value indicates unknown potentially voltage 
typical tests satisfiability equivalence equivalence subset symmetry symbolic boolean operations symbolic simulation node states increased 
computed valued functions set boolean variables intro encoding finite domains duced user represent values consider finite set elements ial encode element vector binary values logz iv 
encoding denoted function mapping element distinct bit binary vector 
ct denote ith bit encoding 
function mapping elements elements represented vector boolean functions fi defined primary inputs initial state 
cosmos represents state node pair obdds 
encodes iv elements signal set vector binary values encoding ct 
state functions computed simulator defined entirely boolean encoding allowing boolean functions accurately describe valued circuit behavior 
example table shows valued extensions logic operations cr ctl 

observe operations yield case unknown argument cause uncertainty function value 
letting denote encoding signal valued operation expressed entirely terms boolean operations acm computmg surveys vol september ao bl bo ao aol ol ao ol ol ao operation simulator operates conventional event driven logic simulator 
begins internal node initialized state indicating node value unknown conditions 
simulation node states updated evaluating boolean representation state function apply operation 
time state node recomputed old state compared new state equivalent event created fan node 
process continues event list empty indicating network stable state 
method processing events relies heavily having efficient test equivalence 
sets encoding set represent manipulate subsets characteristic functions marin 
set denoted boolean function represents complement exclusive operation 
operations sets implemented boolean operations characteristic functions xs xt xs 
xs xt xs xs xt ordered binary decision diagrams table 
ternary extensions 
third value indicates unknown voltage 
xx set subset iff xs xt applications obdds sets constructed manipulated manner explicitly elements 
alternatively nonempty set represented set possible outputs function vector rt 
consider denote set da fi forsome 
representation convenient applications system analyzed represented function vector 
modifying functions represent subsets system states 
relations ary relation defined set ordered tuples 
represent manipulate relations characteristic functions 
example consider binary relation relation denoted boolean function defined representation perform operations intersection union difference relations applying boolean operations characteristic functions 
combination functional composition variable quantification compose relations 
acm computing surveys vol mh 
randal bryant denotes composition relations quantification variable vector involves quantifying vector elements order 
compute transitive closure relation fixed point techniques burch 
function xr computed limit sequence functions defining relation ro iu ror denotes identity relation 
computation converges reaches iteration xr xr making efficient equivalence testing 
think representing graph vertex element edge element relation denotes pairs reachable path edges 
computation converge iterations ial 
technique known iterative squaring burch reduces maximum number iterations logz iv 
iteration computes relation denoting pairs reachable path edges iu applications obdds involve manipulating relations large sets reduction iterations dramatic 

digital system design applications obdds digital system design verification testing gained widespread acceptance 
section describe areas methods application 
verification obdds applied directly task testing equivalence acm comput ng surveys vol september combinational logic circuits 
problem arises comparing circuit network derived system specification bryant verifying logic optimizer altered circuit functionality 
apply operation functional representations networks derived tested equivalence 
method sequential systems compared long state encoding madre 
systems identical output state functions 
design error correction content simply detect existence errors logic design researchers developed techniques automatically correct defective design 
involves considering relatively small class potential design errors single incorrect logic gate determining variant network meet required functionality madre 
analysis demonstrates power quantification operations computing projections case projecting primary input values universal quantification 
analysis performed symbolically encoding possible gate functions boolean variables illustrated 
example shows arbitrary input gate emulated input multiplexer gate operation determined multiplexer data inputs mead conway 
consider circuit gates replaced block giving resulting network functionality represents set primary inputs 
suppose desired functionality 
task determine functions identical primary input values programming gate appropriately 
involves computing function 
universal function block 
assigning different values variables arbitrary input operation realized 
defined 
assignment ii yields satisfactory solution 
major design errors corrected manner eliminates tedious task debugging circuits common errors misplaced inverters incorrect gate type 
task useful logic synthesis designers want alter circuit meet revised specification 
sensitivity analysis second class applications involves characterizing effects altering signal values different lines combinational circuit 
signal value want compute boolean difference primary output respect sellers 
analysis performed symbolically introducing signal line modifiers network illustrated 
line normally carry signal value selectively alter value control boolean value computing 
determine conditions output circuit sensitive value signal line comparing outputs original altered circuits illustrated 
illustrates compute effect single line ordered binary decision diagrams 
signal line modifier 
nonzero value alters value carried line 

computing sensitivities single line modifications 
assignment variables causes value just line modified 
tion circuit symbolic evaluation cho bryant 
number signal line introduce set log permutation variables 
permutation signal defined function yields permutation variables binary representation number assigned signal logic design terms equivalent generating permutation signals decoder having input 
resulting function yields original network network permuted produce output values input application sensitivity analysis automatic test generation 
sensitivity function describes set tests single fault 
signal line numbered binary function normal circuit 
input pattern detect stuck fault line iff 
similarly detect stuck acm comput ng surveys vol 
september randal bryant fault iff 
method generalized sequential circuits circuits represented switch level cho bryant 
second application area combinational logic optimization 
signal line num bered binary function represents don care set line circuit cases circuit outputs independent signal value line 
information guidance circuit optimizer apply transformations eliminating signal line moving line different gate output 
drawback approach sensitivity function recomputed time optimizer modifies circuit 
alternative approach yields restricted compatible set don care functions don care sets remain valid circuit structure altered sato 
probabilistic analysis researchers devised method statistically analyzing effects varying circuit delays digital circuit 
application obdds particularly intriguing conventional wisdom hold analysis requires evaluation real valued parametric variations encoded boolean variables 
consider logic gate network gate delay probability distribution 
circuit may exhibit range behaviors classified undesirable 
yield defined probability behaviors occur 
example shows simple circuit logic gates variable distribution delays wish evaluate probability glitch occurring node input signal transition 
shows analysis signal changes time signals acm computmg surveys vol 
september 
circuit uncertain delays 
gates labeled mm max delays inverters distribution delays 
transitions transition times probability distributions shown 
simple analysis treat waveform probabilities signals independently distributed easily compute behavior gate output gate function input waveforms 
example treat signals independent compute probability rising transition node time product probability transition probability transition occurs time lead transition probability distribution labeled independent net probability transition occurring glitch computed 
reality course transition times signals highly correlated affected delay initial buffer gate 
careful analysis yield transition time probability distribution labeled actual having net probability occurrence 
simplified analysis underestimates circuit yield 
cases simplified analysis overestimate yield 
solve problem symbolic boolean analysis restrictions 
circuit delays integer valued appropriately chosen time unit transitions occur discrete time points 
second delay probabilities gate multiples value power 
example variable gates delays ordered binary decision diagrams lr cq 
effect uncertain delays 
signal switches time ignoring signal correlations causes overestimate transition probability 
js ja 
modeling uncertain delays 
boolean variables control delay selection 
signals replicated delay distribution 
ranging 
uniformly distributed delays delays nearly approximate normal distribution 
delay value gate encoded set log boolean variables shown 
model circuit element input multiplexer delay value having probability fed inputs 
circuit evaluated symbolic extension conventional logic gate simulation algorithm 
signal value node time boolean function delay variables 
example suppose variables el 
encode delay variables dz dl encode delay shown table 
times node functions 
times node function computed el 
eo 

eo 
el 
zo el eo acm computmg surveys vol september randal bryant table 
delay example condition el eo efl el dld el 

dl 
dl 
dz 

equations output signal computed times dz dl el eo dz 
dl 
el 
eo dz 
dl dz 
dl 

el 
eo compute boolean function indicating delay conditions undesirable behavior arises 
example compute probability glitch occurring node 
case compute dz cto glitch occurs iff delay equals 
boolean function representing conditions event occurs compute event probability computing density function fraction variable assignments function yields 
aid shannon expansion density function shown satisfy recursive acm computmg surveys vol 
september delay condition dz dl dz dl dl el el el meo eo 
computation function density vertex labeled tbe fraction variable assignments yielding formulation flx fl 
ll obdd representation compute density linear time traversing graph depth labeling vertex density function denoted subgraph 
computation shown obdd representing conditions node rising transition time indicating event probability 
application shows obdd symbolic analysis applied systems complex parametric variations 
requires simplifying problem consider discrete variations useful results obtained 
key advantage approach simplified methods probabilistic analysis controllability observability measures accurately considers effects correlations stochastic values 

finite state system analysis problems digital system verification protocol validation sequential system optimization require detailed characterization finite state system sequence state transitions 
classic algorithms task construct explicit representation state graph analyze path cycle structure clarke 
techniques impractical number states grows large 
unfortunately relatively small digital systems large state spaces 
example single bit register states 
researchers developed symbolic state methods state transition structure represented boolean function burch coudert involves selecting binary encodings system states input alphabet 
state behavior described relation characteristic function yielding input cause transition state state example illustrates obdd representation nondeterministic automaton having state graph illustrated 
example represents possible states binary values apparently mcmillan implemented symbolic model checker publish 
ordered binary decision diagrams 
explicit representation nondeterministic finite state machine 
size representation grows linearly number states 

symbolic representation nondeterministic finite state machine 
number variables grows logarithmically number states 
encoding cr 
observe unused code value treated don care value arguments function 
obdd combination treated alternate code state simplify obdd representation 
small automaton obdd representation improve explicit representation 
complex systems hand obdd representation considerably smaller 
upper bounds derived bounded width networks discussed section mcmillan characterized conditions cm computing surveys vol september randal bryant obdd representing transition relation system grows linearly number system components number states grows exponentially 
particular property holds system components connected linear tree structure component maintains bounded amount information state components 
example illustrated bound holds systems ring flattened linear chain bidirectional links 
mcmillan identified variety systems satisfying conditions including hierarchical distributed cache shared memory multiprocessor ring distributed mutual exclusion circuit 
obdd representation properties finite state system expressed fixed point equations transition function equations solved iterative methods similar described compute transitive closure relation 
example consider task determining set states reachable initial state having binary coding sequence transitions 
define relation indicate conditions input transition state state relation characteristic function xs 
set states reachable state characteristic function xr systems states analyzed method burch far larger analyzed explicit state graph methods 
number refinements proposed speed convergence burch reduce size intermediate obdds coudert 
acm computmg surveys vol 
september unfortunately system characteristics guarantee efficient obdd representation transition relation provide useful upper bounds results generated symbolic state machine analysis 
example devise system having linear interconnection structure characteristic function set reachable states requires exponentially sized obdd mcmillan 
hand researchers shown number real life systems analyzed methods 
application finite state system analysis correctness sequential digital circuit 
example prove state machine derived system specification equivalent derived circuit uses different state encodings 
application specialized techniques developed exploit characteristics system verified circuit synchronous deterministic specification requires analyzing bounded number clock cycles bose fisher beatty 
example verified pipelined data paths containing bits register state 
system having states exceeds capacity current symbolic state graph methods 

application areas historically obdds applied tasks digital system design verification testing 
spread application domains 
example fixed point techniques machine analysis solve number problems mathematical logic formal languages long domains finite burch 
researchers shown problems application areas formulated set equations boolean algebras solved form unification simonis 
area artificial intelligence researchers developed truth maintenance system obdds madre coudert 
obdd represent database known relations elements 
encoding database form system inferences readily traditional approach simply maintaining unorganized list known facts example determining new fact consistent follows set existing facts involves simple test implication 

areas improvement variety problems solved successfully obdd symbolic manipulation cases improved methods required 
course problems solved np hard cases pspace hard garey johnson 
method polynomial worst case behavior 
best develop methods yield acceptable performance tasks interest 
possibility improve representation 
working digital systems containing multipliers functions involving complex relation control data signals obdds quickly impractically large 
methods proposed follow general principles obdd symbolic manipulation fewer restrictions data structure 
example karplus proposed variant termed dags test condition vertex complex function simple variable test 
researchers cmu experimented free bdds variable ordering restriction obdds relaxed extent variables appear order path root terminal vertex test variable personal communication brace 
ordered binary decision diagrams graphs known time branching programs theoretical community wegener desirable properties obdds including efficient probabilistic method testing equivalence blum chandra 
techniques representation developed maintain desirable characteristics obdds including canonical form polynomial time apply operation 
researchers removed restrictions variable occurrence allowing paths multiple tests single variable burch 
extensions see trade compactness representation difficulty constructing testing properties 
combinatorial optimization problems symbolic methods obdds performed traditional methods 
problems typically interested finding solution satisfies optimality criterion 
approaches obdds hand derive possible solutions select best 
unfortunately problems solutions encode symbolically 
traditional search methods branch techniques prove efficient able solve larger problems 
example test generation program determines possible tests fault cho bryant traditional methods search soon single test 
possibility apply idea lazy delayed evaluation abelson obdd manipulation 
eagerly creating full representation function sequence operations program attempt construct obdds required derive final information desired 
test generation programs characteristic acm computmg surveys vol 
september randal bryant hybrid combinatorial search functional evaluation bushnell 

summary researchers explore new application areas formulate problems cally find exploit key features boolean functions obdds encoding elements finite domain binary operations domains represented vectors boolean functions 
symbolic boolean manipulation provides unified framework representing number different mathematical systems 
problems variable order ing obdd sizes remain reasonable 
ability quickly test equivalence satisfiability techniques iterative methods ity analysis feasible 
apply restrict operations provide powerful basis complex operations 
discovering new application areas improving performance symbolic methods obdd exist ing areas provide fruitful area research years come 
son sussman 
structure interpretation computer programs 
mit press cambridge 
mass 
pp 


binary decision diagrams 
ieee trans 
comput 
aug 
devadas ghosh 
boolean equivalence checking general binary decision diagrams 
international conference computer design cambridge mass oct ieee new york pp 
bea seger 

formal hardware verification symbolic trajectory evaluation 
proceedings th acm ieee design automation conference san june 
acm new york pp 

acm computmg surveys vol 
september berman 
ordered binary decision diagrams circuit structure 
international conference computer design cambridge mass ott ieee new york pp 

bi um chandra 
equivalence free boolean graphs decided probabilistically polynomial time 
pro cess 
mar 
bose fisher 
pipelined hardware symbolic logic simulation 
international conference computer boston oct 
ieee new york pp 

brace bryant 
efficient implementation bdd package 
proceedings th acm ieee automation conference orlando june 
acm new york pp 

sangiovanni 
logic algorithms vlsi syn 
kluwer academic publishers boston 
hum 
atpg path tracing 
test conference oct 
ieee new york pp 

brown 
boolean reason zg 
kluwer academic publishers boston bryant 
complexity vlsi implementations graph representations boolean functions application integer multiplication 
ieee trans 
comput 
feb 
bryant 
graph algorithms boolean function manipulation 
ieee trans 
comput 
aug 
burch bdds verify multipliers 
proceedings th acm ieee design automation conference san francisco june 
acm new york pp 

burch mcmillan 
symbolic model checking states th annual ieee computer philadelphia june ieee new york pp burch clarke dill mcmillan 
sequential circuit verification model checking 
proceedings th acm ieee automation conference orlando june acm new york pp 

simonis 
embedding boolean expressions logic programming 
symb 
comput 
oct 

approach unified methodology combinational switching circuits 
ieee trans comput aug 
cho bryant 
test pattern generation sequential mos circuits fault simulation 
proceedings th acm ieee des gn conference las vegas june 
acm new york pp 

emerson sistla 
automatic verification finite state concurrent systems temporal logic specifications 
acm trans 
program 
lang 
apr 
coudert madre 
verifying temporal properties sequential machines building state diagrams 
computer rutgers june clarke kurshan eds american mathematical society providence ri pp 


probabilistic ctss analysis timing error asynchronous logic circuits 
proceedings th acm ieee design automation conference san francisco june 
acm new york pp 


generating bdds symbolic model checking ccs 
cav third international conference computer aided verification aalborg denmark jul larsen skou eds springer verlag pp 


method symbolic verification synchronous circuits 
computer hardware languages ther applications apr 
proceedings ifip wg tenth international symposium amsterdam north holland waxman eds pp 

fortune hopcroft 
complexity equivalence containment free single variable program schemes 
automata languages 
lecture notes computer science vol 
goos hartmanis boehm eds 
springer verlag pp 

fujisawa kawato 
evaluations improvements boolean comparison program binary decision diagrams 
international conference computer design santa clara calif nov 
ieee new york pp 

fu 
redesign automatic error correction combinational circuits 
logic arch tecture synthesis 
proceedings ifip tc wg workshop logic architecture paris may michel eds 
elsevier amsterdam pp 

garey johnson 
computers intractability 
freeman new york 
ordered binary decision diagrams 
efficient analysis manipulation obdds extended read branching programs 
tech 
rep universitat trier fachbereich iv mathematik informatik trier germany 
bushnell 
est new frontier automatic test pattern generation 
proceedings th acm ieee design automation conference orlando june 
acm new york pp 

jeong somenzi 
variable ordering fsm traversal 
international conference computer aided design santa clara calif nov 
ieee new york pp 

karplus 
dags multi level logic minimization 
advance research vlsi seitz ed 
mit press cambridge mass pp 

kimura clark 
parallel algorithm constructing binary decision diagrams 
international conference boston ott 
ieee new york pp 

lee 
representation switching cir binary decision programs 
bell system tech 
july 
lin touati newton 
don care minimization multi level sequential logic networks 
conference cm computer santa clara calif nov 
ieee new york pp 

madre 
proving circuit correctness formal comparison expected extracted behaviour 
proceedings th acm ieee de automation conference anaheim june 
acm new york pp 

madre coudert 
logically complete reasoning maintenance system logical constraint solver 
th international joint conference art intelligence sydney aug morgan kaufman san mateo ca pp 

madre coudert 
rectification design errors 
international conference computer ded design santa clara nov 
ieee new york pp 

mali wang brayton sangiovanni 
logic verification binary decision dia rams lo synthesis environment international conference computer aided design santa clara 
nov 
ieee new york pp 

acm computing surveys vol september randal bryant mcmillan 
model checking approach state explosion problem 
phd thesis school computer science carnegie mellon univ mead conway 
vlsi systems 
addison wesley reading mass 
mod ed programs computational power 
lecture notes computer science vol 
goos hartmanis eds 
springer verlag berlin 
shared binary diagram attributed edges efficient boolean function manipulation 
proceedings th acm ieee automation conference orlando june 
acm new york pp 


breadth manipulation function vector processing 
proceedings th acm ieee des gn automat conference san francisco june acm new york pp 
may final accepted june acm computmg surveys vol september reeves irwin 
fast methods switch level verification mos circuits 
ieee trans cad ic ca sept 
sato fu jit 
boolean resubstitution permissible functions binary decision diagrams 
proceedings th acm ieee design automation conference orlando june 
acm new york pp 

sellers hsiao 
analyzing errors boolean difference 
ieee trans 
comput 
july 
srinivasan kam malik brayton 
algorithms discrete function manipulation 
con ference computer des gn santa clara calif nov 
ieee new york pp 

wegener complexity branching programs decision trees clique functions 
acm apr 
