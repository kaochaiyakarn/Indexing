storage management caching past large scale persistent peer peer storage utility antony rowstron microsoft research st george house street cambridge cb nh united kingdom 
microsoft com presents evaluates storage management caching past large scale peer peer persistent storage utility 
past self organizing overlay network storage nodes cooperatively route file queries store multiple replicas files cache additional copies popular files 
past system storage nodes files assigned uniformly distributed identifiers replicas file stored nodes identifier matches closely file identifier 
statistical assignment files storage nodes approximately balances number files stored node 
non uniform storage node capacities file sizes require explicit storage load balancing permit graceful behavior high global storage utilization likewise non uniform popularity files requires caching minimize fetch distance balance query load 
evaluate past emphasis storage management caching system 
extensive experiments show system minimizes fetch distance balances query load popular files displays graceful degradation performance global storage utilization increases 

peer peer internet applications popularized file sharing applications napster gnutella freenet :10.1.1.10.4919
attention focused copyright issues raised particular applications peer peer systems interesting technical aspects decentralized control selforganization adaptation scalability 
peer peer systems characterized distributed systems nodes identical capabilities responsibilities peter druschel rice university main street ms houston tx usa 
druschel cs rice edu communication symmetric 
currently projects aimed constructing peer peer applications understanding issues requirements applications systems :10.1.1.20.417:10.1.1.115.4299:10.1.1.10.4919
developing past internet peer peer global storage utility aims provide strong persistence high availability scalability security 
past system composed nodes connected internet node capable initiating routing client requests insert retrieve files 
optionally nodes may contribute storage system 
past nodes form self organizing overlay network 
inserted files replicated multiple nodes availability 
high probability set nodes file replicated diverse terms geographic location ownership administration network connectivity rule law storage utility past attractive reasons 
exploits multitude diversity geography ownership administration jurisdiction nodes internet achieve strong persistence high availability 
obviates need physical transport storage media protect backup archival data likewise obviates need explicit mirroring ensure high availability throughput shared data 
global storage utility facilitates sharing storage bandwidth permitting group nodes jointly store publish content exceed capacity bandwidth individual node 
past offers persistent storage services semantics differ conventional filesystem 
files stored past associated quasi unique fileid generated time file insertion past 
files stored past immutable file inserted multiple times fileid 
files shared owner discretion distributing fileid potentially anonymously necessary decryption key 
efficient routing scheme called pastry ensures client requests reliably routed appropriate nodes :10.1.1.28.5987:10.1.1.28.5987
client requests retrieve file routed high probability node close network client issued request live nodes store requested file 
number past nodes traversed number messages exchanged routing client request logarithmic total number past nodes system normal operation 
retrieve file past client know fileid necessary decryption key 
past provide facilities searching directory lookup key distribution 
layering facilities top pastry peer peer substrate past subject current research 
past intended archival storage content distribution utility general purpose filesystem 
assumed users interact primarily conventional filesystem acts local cache files stored past 
focus storage management caching past 
section overview past architecture briefly describe pastry past content location routing scheme 
section describes storage management section mechanisms policies caching past 
results experimental evaluation past section 
related discussed section conclude section 
past overview host connected internet act past node installing appropriate software 
collection past nodes forms overlay network internet 
minimally past node acts access point user 
optionally past node may contribute storage past participate routing requests past network 
past system exports set operations clients fileid insert name owner credentials file stores file user specified number diverse nodes past network 
operation produces bit identifier fileid subsequently identify file 
fileid computed secure hash sha file name owner public key randomly chosen salt 
choice ensures high probability unique 
rare fileid collisions detected lead rejection inserted file 
file lookup fileid reliably retrieves copy file identified fileid exists past nodes store file reachable internet 
file normally retrieved live node near past node issuing lookup terms proximity metric nodes store file 
reclaim fileid owner credentials reclaims storage occupied copies file identified fileid 
operation completes past longer guarantees lookup operation produce file 
delete operation reclaim guarantee file network proximity scalar metric number ip routing hops bandwidth geographic distance longer available reclaimed 
weaker semantics avoid complex agreement protocols nodes storing file 
past node assigned bit node identifier called nodeid 
nodeid indicates node position circular namespace ranges 
nodeid assignment quasi random sha hash node public key biased malicious node operator 
process ensures correlation value nodeid node geographic location network connectivity ownership jurisdiction 
follows set nodes adjacent nodeids highly diverse aspects 
set excellent candidate storing replicas file nodes set conspire subject correlated failures threats 
insert operation past stores file past nodes nodeids numerically closest significant bits msb file fileid 
invariant maintained lifetime file despite arrival failure recovery past nodes 
reasons outlined high probability replicas stored diverse set past nodes 
invariant set existing nodeid values set existing fileid values uniformly distributed respective domains 
property follows quasi random assignment nodeids ensures number files stored past node roughly balanced 
fact provides initial approximation balancing storage utilization past nodes 
files differ size past nodes differ amount storage provide additional explicit means load balancing required described section 
number chosen meet availability needs file relative expected failure rates individual nodes 
popular files may need maintained nodes order meet balance query load file minimize latency network traffic 
past adapts query load caching additional copies files unused portions past node local disks 
primary replicas file cached copies may discarded node time 
caching past discussed section 
past layered top pastry peer peer request routing content location scheme 
pastry fully described evaluated :10.1.1.28.5987
selfcontained give brief overview pastry 
pastry pastry peer peer routing substrate efficient scalable fault resilient self organizing 
fileid pastry routes associated message node nodeid numerically closest fileid live nodes 
past invariant file stored nodes nodeids numerically closest fileid follows file located nodes failed simultaneously recovery period 
assuming past network consisting nodes pastry route numerically closest node fileid log bn steps normal operation configuration parameter typical value 
despite concurrent node failures eventual delivery guaranteed nodes adjacent nodeids fail simultaneously configuration parameter typical value 
tables required past node log bn entries entry maps nodeid associated node ip address 
node failure arrival new node invariants restored exchanging log bn messages affected nodes 
briefly sketch pastry routing scheme 
purpose routing nodeids thought sequence digits base node routing table organized log bn levels entries 
entries level routing table refer node nodeid shares node nodeid digits th digit possible values th digit node id entry routing table points potentially nodes nodeid appropriate prefix practice node chosen close node proximity metric 
node known suitable nodeid routing table entry left empty 
uniform distribution nodeids ensures population nodeid space log bn levels populated routing table 
addition routing table node maintains ip addresses nodes leaf set neighborhood set 
leaf set set nodes numerically closest larger nodeids nodes numerically closest smaller nodeids relative node nodeid 
neighborhood set set nodes near node proximity metric 
routing useful node addition recovery 
depicts state past node nodeid base hypothetical system uses bit nodeids values andl 
routing step node normally forwards message node nodeid shares fileid prefix digit bits longer prefix fileid shares node id node known message forwarded node nodeid shares prefix fileid long current node numerically closer fileid node id node leaf set message arrived node numerically closest nodeid 
adjacent nodes leaf set failed simultaneously nodes live 
locality briefly discuss pastry properties respect network proximity metric 
recall entries node routing tables chosen refer nearby node terms proximity metric appropriate nodeid prefix 
result step message routed nearby node longer prefix match leaf set routing table nodeid smaller larger neighborhood set state hypothetical pastry node nodeid 
num bers base 
top row routing table represents level zero 
shaded cell level routing table shows corresponding digit node nodeid 
nodeids entry split show common prefix digit rest nodeid 
associated ip addresses shown 
digit 
local heuristic obviously achieve globally shortest routes simulations shown average distance traveled message terms proximity metric higher corresponding distance source destination underlying network :10.1.1.28.5987
pastry repeatedly takes locally short routing step node shares longer prefix fileid messages tendency reach node nodes store requested file near client proximity metric 
experiment shows replicated copies file pastry able find nearest copy lookups finds nearest copies lookups :10.1.1.28.5987
node addition failure key design issue pastry efficiently dynamically maintain node state routing table leaf set neighborhood sets presence node failures node recoveries new node arrivals 
protocol described evaluated full detail :10.1.1.28.5987
briefly arriving node newly chosen nodeid initialize state contacting nearby node proximity metric asking route special message destination set message routed existing node nodeid numerically closest obtains leaf set neighborhood set row routing exceedingly event equal new node obtain new nodeid 
table ith node encountered route show information correctly initialize state notify nodes need know arrival restoring pastry invariants 
handle node failures neighboring nodes nodeid space aware virtue leaf set periodically exchange keep alive messages 
node unresponsive period failed 
members failed node leaf set notified update leaf sets restore invariant 
leaf sets nodes adjacent nodeids overlap update trivial 
recovering node contacts nodes known leaf set obtains current leafs sets updates leaf set notifies members new leaf set presence 
routing table entries refer failed nodes repaired lazily details relevant subject :10.1.1.28.5987
pastry described far deterministic vulnerable malicious failed nodes route accept messages correctly forward 
repeated queries fail time take route 
overcome problem routing randomized 
avoid routing loops message forwarded node shares long prefix numerically closer destination node namespace current node 
choice multiple nodes random 
practice probability distribution heavily biased best choice ensure low average route delay 
event malicious failed node path client may issue requests route chosen avoids bad node 
full description evaluation pastry :10.1.1.28.5987
principle possible layer past top peer peer routing schemes described literature tapestry chord 
past properties respect network locality fault resilience may change case depending properties underlying routing scheme 
past operations briefly describe past implements insert lookup reclaim operations 
response insert request fileid computed sha hashcode file textual name client public key random salt 
required storage file size times client storage quota file certificate issued signed owner private key 
certificate contains fileid sha hash file content replication factor salt creation date optional file metadata 
file certificate associated file routed pastry fileid destination 
message reaches nodes closest fileid node verifies file certificate recomputes content hashcode compares content hashcode file certificate 
checks node accepts responsibility replica file forwards insert request nodes nodeids numerically closest fileid 
nodes accepted replica acknowledgment passed back client replica storing nodes attach store receipt 
client verifies store receipts confirm requested number copies created 
goes wrong point insertion process illegitimate file certificate corrupted content failure locate sufficient storage store copies appropriate error indication returned client 
response lookup request client node sends appropriate request message requested fileid destination 
soon request message reaches node stores file node responds content stored file certificate request message routed 
due locality properties pastry routing scheme fact file replicas stored nodes adjacent nodeids lookup find replica near client proximity metric 
reclaim request proceeds analogous insert request 
client node issues reclaim certificate allows replica storing nodes verify file legitimate owner requesting operation 
storing nodes issue return reclaim receipt client node verifies credit user storage quota 
detail quota management 
security details security past scope give brief overview 
detail forthcoming 
past node user system hold smartcard read clients don need card 
private public key pair associated card 
smartcard public key signed smartcard issuer private key certification purposes 
smartcards generate verify various certificates maintain storage quotas 
possible operate past smartcards providing comparable security quota system smartcards complicates system 
assumptions underly past security model computationally infeasible break public key cryptosystem cryptographic hash function past clients node operators node software trusted attackers may control behavior individual past nodes assumed nodes overlay network behaved attacker control behavior smartcards 
smartcards ensure integrity nodeid fileid assignments preventing attacker controlling adjacent nodes nodeid space directing file insertions specific portion fileid space 
store receipts prevent malicious node causing system create fewer diverse replicas file client noticing 
file certificates allow storage nodes clients verify integrity authenticity stored content 
file reclaim certificates help enforce client storage quotas 
desired client ensure file privacy encrypting content inserting file past 
pastry routing scheme randomized preventing malicious node path repeatedly intercepting request message causing denial service 
routing table entries nodeid ip address mappings signed associated node verified nodes 
malicious node may worst suppress valid entries forge entries 
routing information pastry inherently redundant globally disseminated 
owing factors pastry highly resilient malicious nodes limits impact degradation routing performance long nodes behaved 
worst case widespread corruption nodes cause routing failures denial service 
sections describe storage management caching past 
primary goal storage management ensure availability files balancing storage load system approaches maximal storage utilization 
goal caching minimize client access latencies maximize query throughput balance query load system 

storage management past storage management aims allowing high global storage utilization graceful degradation system approaches maximal utilization 
aggregate size file replicas stored past able grow large fraction aggregate storage capacity past nodes large fraction insert requests rejected suffer decreased performance 
difficult predict systems past typically operated high levels storage utilization contention highly efficient reliable system remain robust event extreme operating conditions 
line decentralized architecture past important design goal storage management rely local coordination nodes nearby nodeids fully integrate storage management file insertion incur modest performance overheads related storage management 
responsibilities storage management balance remaining free storage space nodes past network system wide storage utilization approaching maintain invariant copies file maintained nodes nodeids closest fileid 
goals appear conflicting requiring file stored nodes closest fileid leaves room explicit load balancing 
past resolves conflict ways 
past allows node numerically closest nodes fileid alternatively store file leaf set nodes 
process called replica diversion purpose accommodate differences storage capacity utilization nodes leaf set 
replica diversion done care ensure file availability degraded 
second file diversion performed node entire leaf set reaching capacity 
purpose achieve global load balancing large portions nodeid space 
file diverted different part nodeid space choosing different salt generation fileid 
rest section discuss causes storage imbalance state assumptions node storage algorithms replica file diversion 
describe storage invariant maintained presence new node addition node failure recovery 
experimental evaluation past storage management follows section 
causes storage load imbalance recall past node maintains leaf set contains nodes nodeids numerically closest node larger smaller nodeids 
normally replicas file stored nodes numerically closest fileid larger 
consider case closest nodes accommodate replica due insufficient storage nodes exist leaf sets nodes accommodate file 
imbalance available storage nodes intersection leaf sets arise reasons due statistical variation assignment nodeids number files assigned node may differ 
size distribution inserted files may high variance may heavy tailed 
storage capacity individual past nodes differs 
replica diversion aims balancing remaining free storage space nodes leaf set 
addition global storage utilization past system increases file diversion may necessary balance storage load different portions nodeid space 
node storage assume storage capacities individual past nodes differ orders magnitude time 
discussion provides justification assumption 
past nodes cost effective hardware available time installation 
time writing pc small number gb disk drives 
size cost effective disk size expected double year node typical low cost configuration time installation remain viable years capacity drop orders magnitude largest newly installed node 
assumption prevent construction sites provide large scale storage 
site configured cluster logically separate past nodes separate nodeids 
associated hardware centralized large multiprocessor node raid storage subsystem cluster pcs small number attached disks irrelevant considerations cost fault resilience normally favor clusters pcs 
multiple nodes site administratively independent may correlated failures sites significantly affect average diversity nodes selected store replicas file long number nodes site small compared total number nodes past system 
past controls distribution node storage capacities comparing advertised storage capacity newly joining node average storage capacity nodes leaf set 
node large asked split join multiple nodeids 
node small rejected 
node free advertise fraction actual disk space past 
advertised capacity basis admission decision 
replica diversion purpose replica diversion balance remaining free storage space nodes leaf set 
replica diversion accomplished follows 
insert request message reaches node nodeid numerically closest fileid node checks see accommodate copy file local disk 
stores file issues store receipt forwards message nodeids closest fileid 
nodes exist node leaf set message forwarded directly 
nodes turn attempts store replica file returns store receipt 
accommodate copy locally considers replica diversion 
purpose chooses node leaf set closest hold diverted replica file 
asks store copy behalf enters entry file table pointer issues store receipt usual 
say diverted copy file node care taken ensure diverted replica contributes availability file locally stored replica 
particular ensure failure node causes creation replacement replica failure node render replica stored inaccessible 
diverted replica double probability replicas inaccessible 
node failure recovery procedure described section ensures condition 
condition achieved entering pointer replica stored file table node th closest nodeid fileid 
node fails node maintains pointer replica stored maintaining invariant closest nodes maintain replica distinct diverted replica 
node fails node installs th closest node 
results section show replica diversion achieves local storage space balancing necessary achieve high storage utilization graceful degradation past system reaches storage capacity 
overhead diverting replica additional entry file tables nodes entries pointing additional rpcs insert additional rpc lookup reaches diverted copy 
minimize impact replica diversion past performance appropriate policies avoid unnecessary replica diversion 
policies describe policies past control replica diversion 
relevant policies acceptance replicas node local store selecting node store diverted replica deciding divert file different part nodeid space 
choosing appropriate policies replica diversion considerations relevant 
necessary balance remaining free storage space nodes long utilization nodes low 
doing advantage incur cost replica diversion 
second preferable divert large file multiple small ones 
diverting large files reduces insertion overhead replica diversion amount free space needs balanced account workloads biased lookups small files minimize impact lookup overhead replica diversion 
third replica diverted node remaining free space significantly average node free space significantly average free space gets uniformly low leaf set better divert file part nodeid space attempt divert replicas risk spreading locally high utilization neighboring parts nodeid space 
policy accepting replica node metric sd fn size file fn remaining free storage space node particular node rejects file sd fn consume fraction remaining free space 
nodes numerically closest fileid primary replica stores nodes closest diverted replica stores criterion threshold 
things note policy 
assuming average file size smaller node average storage size past node accepts oversized files long utilization low 
property avoids unnecessary diversion node plenty space 
second policy discriminates large files decreases size threshold files get rejected node utilization increases 
bias minimizes number diverted replicas tends divert large files leaving room small files 
third criterion accepting diverted replicas restrictive accepting primary replicas ensures node leaves space primary replicas replicas diverted node significantly free space 
primary store node rejects replica needs select node hold diverted replica 
policy choose node maximal remaining free space nodes leaf set nodeid nodes closest fileid hold diverted replica file 
policy ensures replicas diverted node free space eligible nodes 
note selected node may reject diverted replica mentioned policy accepting replicas 
policy diverting entire file part nodeid space follows 
nodes nodeids closest fileid declines store replica node chooses hold diverted replica declines entire file diverted 
case nodes stored replica discard replica negative acknowledgment message returned client node causing file diversion 
file diversion purpose file diversion balance remaining free storage space different portions nodeid space past 
file insert operation fails nodes closest chosen fileid accommodate file divert replicas locally leaf set negative acknowledgment returned client node 
client node turn generates new fileid different salt value retries insert operation 
client node repeats process times 
attempts insert operation fails operation aborted insert failure reported application 
failure indicates system able locate necessary space store copies file 
cases application may choose retry operation smaller file size fragmenting file smaller number replicas 
maintaining replicas past maintains invariant copies inserted file maintained different nodes leaf set 
accomplished follows 
recall part pastry protocol neighboring nodes nodeid space periodically exchange keep alive messages 
node unresponsive period presumed failed pastry triggers adjustment leaf sets affected nodes 
specifically nodes leaf set failed node removes failed node leaf set includes live node closest nodeid 
second new node joins system previously failed node gets back line similar adjustment leaf set occurs nodes constitute leaf set joining node 
joining node included node dropped previous leaf sets 
part adjustments node may closest nodes certain files storage invariant requires node acquire replica file re creating replicas previously held failed node 
similarly node may cease nodes certain files invariant allows node discard copies 
current ratio disk storage versus wide area internet bandwidth time consuming inefficient node request replicas files just numerically closest nodes 
particularly obvious case new node recovering node disk contents lost part failure 
solve problem joining node may install pointer file table referring node just ceased numerically closest fileid requiring node keep replica 
process semantically identical replica diversion existing mechanisms ensure availability reused see section 
affected files gradually migrated joining node part background operation 
past network growing node additions may create situation node holds diverted replica node refers replica longer part leaf set 
nodes automatically notified failure explicitly exchange keep alive messages maintain invariants 
minimize associated overhead affected replicas gradually migrated node referring node leaf set possible 
consider case node fails storage utilization high remaining nodes leaf set unable store additional replicas 
allow past maintain storage invariants circumstances node asks distant members leaf set nodeid space locate node respective leaf sets store file 
exactly half node leaf set overlaps nodes leaf sets total nodes reached way 
nodes able accommodate file space system number replicas may temporarily drop nodes disk space available 
reader may noticed point maintaining copies file past system high utilization possible total amount disk storage system decrease 
total disk storage decrease due node disk failures eventually balanced node disk additions system eventually exhaust storage 
certain point system unable re replicate files replicas lost due node failures 
maintaining adequate resources utilization problem systems past centrally managed 
solution provide strong incentives users balance resource consumption resources contribute system 
past addresses problem maintaining storage quotas ensuring demand storage exceed supply 
full discussion management security aspects past scope 
file encoding storing complete copies file method achieve high availability 
reed solomon encoding instance adding additional checksum blocks original data blocks equal size allows recovery losses data checksum blocks 
reduces storage overhead required tolerate failures times file size 
fragmenting file large number data blocks storage overhead availability small 
independent encoding storing fragments file separate nodes striping file disks improve bandwidth 
potential benefits weighed cost terms latency aggregate query network load availability contacting nodes retrieve file 
cost may outweigh benefits large files exploring option 
storage management issues discussed largely orthogonal choice file encoding striping 

caching section describe cache management past 
goal cache management minimize client access latencies fetch distance maximize query throughput balance query load system 
note past running overlay network fetch distance measured terms pastry routing hops 
replicas file maintained past primarily reasons availability degree query load balancing latency reduction results 
see recall nodes adjacent nodeids store copies file widely dispersed pastry route client lookup request replica closest client 
highly popular file may demand replicas order sustain lookup load minimizing client latency network traffic 
furthermore file popular local clusters clients advantageous store copy near cluster 
creating maintaining additional copies task cache management past 
past nodes unused portion advertised disk space cache files 
cached copies evicted discarded time 
particular node stores new primary redirected replica file typically evicts cached files room replica 
approach advantage unused disk space past improve performance hand storage utilization system increases cache performance degrades gracefully 
cache insertion policy past follows 
file routed node part lookup insert operation inserted local disk cache size fraction node current cache size portion node storage currently store primary diverted replicas 
cache replacement policy past size gd policy originally developed caching web proxies 
gd maintains weight cached file 
insertion cache hit weight hd associated file set represents cost associated ands 
file needs replaced file evicted hv minimal cached files 
hv subtracted values remaining cached files 
value set policy maximizes cache hit rate 
results section demonstrate effectiveness caching past 

experimental results section experimental results obtained prototype implementation past 
past node software implemented java 
able perform experiments large networks pastry nodes implemented network emulation environment instances node software communicate 
experiments reported pastry nodes configured run single java vm 
largely transparent pastry implementation java runtime system automatically reduces communication pastry nodes local object invocations 
experiments performed quad processor compaq alphaserver es mhz alpha cpus gbytes main memory running true unix version 
pastry node software implemented java executed compaq java sdk version compaq version 
verified storage invariants maintained properly despite random node failures recoveries 
past able maintain invariants long pastry able maintain proper leaf sets case nodes adjacent nodeids fail recovery period 
remaining experimental results divided analyzing effectiveness past storage management examining effectiveness caching past 
storage experiments exploring storage management different workloads 
consists set web proxy logs nlanr th march truncated contain entries national laboratory applied network research ftp ircache nlanr net traces 
national science foundation ncr ncr 
ing unique urls totaling gbytes content mean file size bytes median file size bytes largest smallest file size mbytes bytes respectively 
second workloads generated combining file name file size information file systems authors home institutions 
files sorted alphabetically filename provide ordering 
trace contained files combined file size gbytes mean file size bytes median file size bytes largest smallest file size gbytes bytes respectively 
selecting appropriate workload evaluate system past difficult workload traces existing peer topeer systems available relatively little known characteristics 
chose web proxy filesystems workloads evaluate storage management caching past 
file size distributions workloads different bracket range size distributions encountered past 
purposes evaluating caching locality properties web proxy log give rough idea locality expect past workload 
experiments number replicas file fixed fixed number past nodes fixed 
number replicas chosen measurements analysis considers availability desktop computers corporate network environment 
storage space contributed past node chosen truncated normal distribution mean standard deviation upper lower limits respectively 
table shows values distributions set experiments 
lower upper bounds indicate tails normal distribution cut 
case lower upper bound defined respectively 
lower upper bound fixed arbitrarily large 
experimented uniform distributions results significantly affected 
mean storage capacities distributions approximately factor expect practice 
scaling necessary experiment high storage utilization substantial number nodes workload traces available limited storage requirements 
notice reducing node storage capacity way storage management difficult results conservative 
set experiments nlanr traces 
separate web traces combined preserving temporal ordering entries log create single log 
entries log sequence appearance url insert file past subsequent url ignored 
stated node storage sizes chosen distribution 
dist lower upper total name bound bound capacity table parameters normal distributions node storage sizes experiments 
figures mbytes 
experiment replica diversion file diversion disabled setting threshold primary replica stores setting threshold diverted replica stores declaring file insertion rejected insert failure re 
purpose experiment demonstrate need explicit storage load balancing past 
entire web log trace played past system 
replica file diversion file insertions failed global storage utilization past system trace 
clearly demonstrates need storage management system past 
table shows results experiment file replica diversion enabled various distributions storage node sizes settings leaf set size 
table shows percentage successful unsuccessful inserts success fail respectively 
file diversion column shows percentage successful inserts involved file diversion possibly multiple times replica diversion shows fraction stored replicas diverted 
util shows global storage utilization past 
dist succeed fail file replica util 
name diversion diversion table effects varying storage distribution leaf set size 
results table show storage management past highly effective 
compared results replica file diversion utilization risen andl respectively 
furthermore distribution node storage sizes recall file size free storage space threshold file stored node 
minor impact performance past set distributions experiment 
number small nodes increases number replica lesser degree number file increases expected 
noticeable increase performance leaf set size increased 
larger leaf set increases scope local load balancing 
storage size distributions experiments increasing leaf set size yields increase performance increase cost past node arrival departure 
remainder experiments leaf set size 
set experiments examines sensitivity results setting parameters control replica file diversion 
experiments value varied keeping constant node storage size distribution 
table shows results 
succeed fail file replica util 


table insertion statistics utilization past varied 
shows cumulative failure ratio versus storage utilization experiment 
cumulative failure ratio defined ratio failed file insertions file insertions occurred point storage utilization reached 
data conjunction table shows increased fewer files successfully inserted higher storage utilization achieved 
explained considering general lower value large file stored particular past node 
small files stored place large file number files stored increases decreases utilization drops large files rejected low utilization levels 
storage utilization low higher rate insertion failure observed smaller values 
table shows effect varying parameter storage size distribution 
shows cumulative failure ratio versus storage utilization experiments 
experiment varying increased storage utilization improves fewer insertions complete successfully reasons 
repeated sensitivity experiments filesystem trace despite different file size distribution trace results similar 
experiments conclude provide balance maximal storage utilization low file insertion failure rate low storage utilization 
failure ratio utilization cumulative failure ratio versus storage utilization achieved varying parameter 
succeed fail file replica util 


table insertion statistics utilization past varied 
set results explore detail utilization levels file diversion replica diversion impact past performance 
shows percentage inserted files diverted twice times cumulative failure ratio versus storage utilization 
results show file negligible long storage utilization 
maximum file diversion attempts insertion considered failed 
shows ratio replicas diverted total replicas stored past versus storage utilization 
seen number diverted replicas remains small high utilization utilization replicas stored past diverted replicas 
sets results show overhead imposed replica file diversion moderate long utilization 
higher utilization overhead remains acceptable 
result shows size distribution files inserted past function utilization 
shows scatter plot insertion failures file size left vertical axis versus utilization level failure occurred 
shown fraction failed insertions versus utilization right vertical axis 
graph files larger lower bound storage capacity distribution shown nlanr trace files larger upper storage capacity bound larger mean storage capacity larger lower storage capacity bound 
number files larger lower storage capacity bound successfully inserted 
files larger mean cumulative failure ratio utilization cumulative failure ratio versus storage utilization achieved varying parameter 
cumulative ratio redirects redirects redirect insertion failure utilization ratio file cumulative insertion failures versus storage utilization 
storage capacity successfully inserted 
shows storage utilization increases smaller files fail inserted 
utilization reaches file average size bytes rejected time 
just utilization files smaller mbytes minimal node storage capacity rejected 
total rate failed insertions extremely small utilization utilization total rate failures reaching 
having shown properties past nlanr traces consider results filesystem workload 
total size files workload significantly larger nlanr web proxy trace 
number past nodes experiments storage capacity contributed node increased 
experiment generate storage capacities increased storage capacity node factor 
resulting lower upper bound storage capacity mbytes mbytes respectively whilst mean mbytes 
cumulative ratio replica utilization cumulative ratio replica versus storage utilization 
file size bytes failed insertion failure ratio utilization file insertion failures versus storage utilization nlanr trace 
total storage capacity nodes gbytes 
shows results experiment filesystem workload 
files larger smallest storage capacity shown filesystem load files larger upper storage capacity larger mean storage capacity larger lower storage capacity bound 
number files larger smallest storage capacity successfully inserted files larger mean storage capacity inserted successfully 
caching results section demonstrate impact caching past 
experiment uses nlanr trace 
trace contains unique clients mapped past nodes request client trace issued corresponding past node 
mapping achieved follows 
individual web proxy traces combined preserving temporal ordering create single trace experiment 
traces come top level proxy servers distributed geographically usa 
new client identifier trace new node assigned way ensure requests trace failure ratio file size bytes failed insertion failure ratio utilization file insertion failures versus storage utilization 
issued past nodes close emulated network 
time url seen trace referenced file inserted past subsequent occurrences url cause lookup performed 
insertion lookup performed past node matches client identifier operation trace 
files cached past nodes successful insertions successful lookups nodes request routed 
parameter set 
experiment uses past nodes storage capacity distribution 
global cache hit rate lru hit rate hops gd hit rate lru hops gd hit rate gd hops lru hit rate gd hops lru hops hops utilization global cache hit ratio average number message hops versus utilization lru size gd caching 
shows number routing hops required perform successful lookup global cache hit ratio versus utilization 
size gd policy described section 
comparison include results lru policy 
caching disabled number routing hops average required constant utilization begins rise slightly 
due replica diversion occurring small percentage lookups failure ratio average number routing hops diverted replica retrieved adding extra routing hop 
noted log 
global cache hit rate lru gd algorithms decreases storage utilization increases 
zipf distribution web requests small number files requested :10.1.1.12.2253
system low utilization files widely cached 
storage utilization increases number files increases caches replace files 
leads global cache hit rate dropping 
average number routing hops lru gd indicates performance benefits caching terms client latency network traffic 
low storage utilization clearly files cached network close requested 
global cache hit ratio lowers increasing storage utilization average number routing hops increases 
storage utilization average number hops result caching 
file sizes proxy trace median value bytes high storage utilization capacity cache small files 
terms global cache hit ratio average number routing hops gd performs better lru 
deliberately reported lookup performance terms number pastry routing hops actual lookup delays strongly depend hop network delays 
give indication actual delays cause past retrieving kb file node pastry hop away lan takes approximately ms 
result improved substantially appropriate performance tuning prototype implementation 

related currently peer peer systems development 
prominent file sharing facilities gnutella freenet :10.1.1.10.4919
napster music exchange service provided original motivation peer peer systems pure peer peer system database centralized 
systems primarily intended large scale sharing data files persistence reliable content location guaranteed necessary environment 
comparison past aims combining scalability self organization systems freenet strong persistence reliability expected archival storage system 
regard closely related projects oceanstore farsite eternity :10.1.1.20.417:10.1.1.16.1952
freenet eternity focused providing strong anonymity anti censorship 
oceanstore provides global transactional persistent storage service supports serializable updates widely replicated nomadic data 
contrast past provides simple lean storage abstraction persistent immutable files intention sophisticated storage semantics mutable files built top past needed 
past farsite traditional filesystem semantics 
distributed directory service farsite locate content different past pastry scheme integrates content location routing 
currently published scalability analysis farsite 
node maintains partial list live nodes chooses nodes store replicas 
farsite design motivated feasibility study measures corporate lan assumptions may hold wide area environment 
pastry tapestry chord represent second generation peer peer routing location schemes inspired pioneering systems freenet gnutella 
earlier guarantee definite answer query bounded number network hops retaining scalability freenet self organizing properties freenet gnutella 
pastry tapestry bear similarity plaxton :10.1.1.38.1850
approach routing address prefixes viewed generalization hypercube routing common schemes 
plaxton scheme special node associated file forms single point failure 
plaxton handle automatic node integration failure recovery self organizing 
pastry tapestry differ approach achieving network locality replicating objects pastry appears complex 
chord protocol closely related pastry tapestry routing nodes share successively longer address prefixes destination chord forwards messages numerical difference destination address 
pastry tapestry chord explicit effort achieve network locality 
routes messages dimensional space node maintains routing table entries node reached dn routing hops 
pastry routing table grow network size number routing hops grows faster logn 
cfs decentralized cooperative read storage system 
past built top peer peer routing lookup substrate case chord 
past intended solely file sharing medium provides weak persistence 
cfs storage block oriented conventional unix filesystem layered top 
block stored multiple nodes adjacent chord node ids popular blocks cached additional nodes similar way entire files stored past 
compared past increases file retrieval overhead file data metadata block located separate chord lookup 
hand cfs permits parallel block retrievals benefits large files 
cfs design assumes abundance free disk space 
combined block orientation weak persistence simplifies storage management compared system past 
accomodate nodes minimal storage size cfs relies hosting multiple logical nodes physical nodes separate chord id past uses technique nodes storage size exceeds minimal size orders magnitude 
chord pastry overhead maintaining state multiple logical nodes increases proportionally 
xfs serverless filesystem 
shares decentralized architecture peer peer systems past intended general purpose filesystem serving single organization lan 
design goals assumptions respect performance network characteristics security administration different past loosely related overlay networks ad hoc network routing naming web content replication :10.1.1.12.7544

design evaluation past internet global peer peer storage utility focus past storage management caching 
storage nodes files past assigned uniformly distributed identifiers replicas files stored nodes nodeids numerically closest file fileid 
results show storage load balance provided statistical assignment insufficient achieve high global storage utilization typical file size distributions non uniform storage node capacities 
storage management scheme allows past system achieve high utilization rejecting file insert requests 
scheme relies local coordination nodes leaf set imposes little overhead 
detailed experimental results show scheme allow past achieve global storage utilization excess 
rate failed file insertions remains storage utilization failed insertions heavily biased large files 
furthermore describe evaluate caching past allows node retain additional copy file 
show caching effective achieving load balancing reduces fetch distance network traffic 
acknowledgments miguel castro marvin theimer dan wallach anonymous reviewers shepherd andrew myers useful comments feedback 
peter druschel microsoft research cambridge uk massachussetts institute technology support visits fall spring respectively compaq donating equipment 

napster 
www napster com 
gnutella protocol specification 
dss clip com pdf 
adjie winoto schwartz balakrishnan lilley 
design implementation intentional naming system 
proc 
sosp kiawah island sc dec 
amir peterson shaw 
seamlessly selecting best copy internet wide replicated web servers 
proc 
th symposium distributed computing greece sept 
anderson :10.1.1.16.1952
eternity service 
proc 
pages 
publishing house 
prague czech republic 
anderson dahlin neefe patterson roselli wang 
serverless network file systems 
proc 
th acm sosp copper mountain dec 
bennett clarke evans hopper jones 
piconet embedded mobile networking 
ieee personal communications october 
bolosky douceur ely theimer 
feasibility serverless distributed file system deployed existing set desktop pcs 
proc 
sigmetrics santa clara ca 
bowman peterson 
univers attribute name server 
software practice experience apr 
breslau cao fan phillips shenker :10.1.1.12.2253
web caching zipf distributions evidence implications 
proc 
ieee infocom new york ny mar 
cao irani 
cost aware www proxy caching algorithms 
proc 
usenix symposium internet technologies systems usits monterey ca dec 
cheriton mann 
decentralizing global naming service improved performance fault tolerance 
acm trans 
comput 
syst may 
clarke sandberg wiley hong :10.1.1.10.4919
freenet distributed anonymous information storage retrieval system 
workshop design issues anonymity unobservability pages july 
icsi berkeley ca usa 
dabek kaashoek karger morris stoica 
wide area cooperative storage cfs 
proc 
acm sosp banff canada oct 
dingledine freedman molnar :10.1.1.20.417
free haven project distributed anonymous storage service 
proc 
workshop design issues anonymity unobservability berkeley ca july 
druschel rowstron 
past large scale persistent peer peer storage utility 
proc 
hotos viii schloss germany may 
jannotti gifford johnson kaashoek toole :10.1.1.12.7544
overcast reliable multicasting overlay network 
proc 
osdi san diego ca october 
roberts ross 
performance evaluation redirection schemes content distribution networks 
proc 
th web caching workshop san diego ca mar 
ross 
replicated architecture domain name system 
proc 
ieee infocom tel aviv israel mar 
kubiatowicz bindel chen czerwinski eaton geels gummadi rhea weatherspoon weimer wells zhao 
oceanstore architecture global scale persistent store 
proc 
asplos cambridge ma november 
lampson 
designing global name service 
proc 
fifth symposium principles distributed computing pages canada aug 
li jannotti couto karger morris 
scalable location service geographical ad hoc routing 
proc mobicom boston ma august 
plank 
tutorial reed solomon coding fault tolerance raid systems 
software practice experience sept 
plaxton rajaraman richa :10.1.1.38.1850
accessing nearby copies replicated objects distributed environment 
theory computing systems 
ratnasamy francis handley karp shenker 
scalable content addressable network 
proc 
acm sigcomm san diego ca aug 
reynolds 
rfc technical overview directory services protocol mar 
rowstron druschel :10.1.1.28.5987
pastry scalable distributed object location routing large scale peer peer systems 
proc 
ifip acm middleware heidelberg germany nov 
saroiu gummadi gribble 
measurement study peer peer file sharing systems 
technical report uw cse university washington july 
sheldon duda weiss gifford 
discover resource discovery system content routing 
proc 
rd international world wide web conference darmstadt germany 
stoica morris karger kaashoek balakrishnan 
chord scalable peer peer lookup service internet applications 
proc 
acm sigcomm san diego ca aug 
zhao kubiatowicz joseph 
tapestry infrastructure fault resilient wide area location routing 
technical report ucb csd berkeley april 
