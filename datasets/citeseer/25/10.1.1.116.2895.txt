arxiv cs lo sep stable models alternative logic programming paradigm victor marek law truszczynski department computer science university kentucky lexington ky marek cs engr edu reexamine place role stable model semantics logic programming contrast herbrand model approach horn programs 
demonstrate inherent features stable model semantics naturally lead logic programming system offers interesting alternative traditional logic programming styles horn logic programming stratified logic programming logic programming founded semantics 
proposed approach interpretation program clauses constraints 
setting programs describe single intended model family stable models 
stable models encode solutions constraint satisfaction problem described program 
approach imposes restrictions syntax logic programs 
particular function symbols eliminated language 
argue resulting logic programming system attuned problems class np defined domain applications emerging methodology programming 
point approach viable progress implementations algorithms compute stable models propositional logic programs 
stable model semantics appeared logic programming scene late effort provide understanding programs negation 
proposed gelfond lifschitz gl regarded logic programming community dose reserve 
intuitively felt stable model semantics properly deals negation formal evidence supporting intuition established 
time stable model semantics fit standard paradigm logic programming languages 
standard approaches assign logic program single intended model stable model semantics assigns program family possibly empty intended models 
presence function symbols horn logic programs specify recursively enumerable set stable model semantics increases expressive power logic programs acceptable notions computability 
sld resolution true bread butter logic programmers heart control mechanisms standard logic programming implementations inappropriate stable model semantics 
consequence difficulties reconciling stable model semantics traditional paradigm logic programming stable model semantics received relatively attention logic programming community semantics proposed programs negation perfect model semantics stratified programs founded semantics 
argue try resolve inconsistencies force stable model semantics standard logic programming mold effort doomed failure change view required 
propose perspective stable model semantics departs basic tenets logic programming 
time perspective leads computational system general spirit logic programming 
system declarative retains separation logic control defined domain applications emerging programming methodology 
refer version logic programming stable logic programming slp short 
key elements view stable model semantics describe 
restrict syntax disallowing function symbols 
syntax slp syntax datalog negation 
restriction syntax significant effect expressive power programs 
particular ability recursion 
second view program specifying collection models single model 
slp especially suited problems solutions subsets universe solution modeled different stable model 
combinatorial constraint satisfaction problems fall category 
restricted syntax limiting recursion shift semantics programs specify collection models single model change way interpret design programs 
programs interpreted sets constraints 
clauses represent individual constraints objects interest recursive definitions objects 
different approach programming needed 
objects horn logic programming represented terms defined recursively slp represented different stable models defined terms constraints 
slp follows basic logic programming tenet uniform control control slp different 
sld resolution horn logic programming backtracking search stable models 
horn logic programming attuned concepts turing computability recursively enumerable sets partial recursive functions slp related narrow class problems 
point decision problems np solved paradigm slp 
possibly search problems decision versions np solved slp programs 
np smaller class sets covers wide collection important computational problems including combinatorial optimization constraint satisfaction problems 
main reasons believe slp evolve useful computational tool 
idea logic programs restricted syntax nonstandard semantics discussed papers 
niemel nie closely related proposed function symbol free logic programming stable model semantics vehicle process constraint satisfaction problem 
second cadoli cp proposed datalog programs negation semantics parallel circumscription tool solving decision problems np 
study similar default logic formalism extending slp programming environment solving decision problems class projects supported algorithms process logic programs implementations 
niemel simons ns ns developed system smodels compute stable models logic programs 
algorithms process datalog programs parallel circumscription 
system process wider class programs default theories described cmt 
emergence implementations main reason alternative logic programming systems viable computational tools 
organized follows 
section provide perspective horn logic programming pointing features responsible expressivity 
discuss effects negation operator logic programming show increases expressivity currently accepted bounds 
section formally introduce stable logic programming slp 
study expressive power slp showing applicability slp attuned class np 
section note limitations recursion slp show slp programs interpreted descriptions sets constraints 
consequently methodology programming slp different ordinary logic programming 
discuss examples show slp programs solve developed 
discuss issue uniform control associated slp section 
road map complete 
horn logic programming idea logic computational mechanism traced back herbrand analysis effectivity proofs order logic 
herbrand discovered unification algorithm basic constructions day automated deduction logic programming 
transforming logic viable programming tool required additional crucial steps 
resolution robinson rob unification key components 
years resolution extensively studied cl lov mw gained successful techniques automated reasoning 
second key step narrow focus automated deduction class horn theories specifically class definite horn theories 
definite horn clause formula form qk written 
qk logic programming community qi atoms language 
definite horn theory horn logic program finite theory consisting definite horn clauses 
definite horn theory consistent possesses herbrand model lm 
model provides natural intuitive semantics definite horn theories leads natural concept computability 
say finite definite horn theory specifies subset herbrand universe hu predicate symbol occurring hu lm 
fundamental results underlying area logic programming recursively enumerable set specified definite horn theory smu 
result shows definite horn theories expressive turing machines precisely capture concept church turing computability 
area logic programming born early realized elements set hu lm computed 
special form resolution sld resolution kow ave called lifting lemma llo allow compute ground terms generally ground substitutions belongs herbrand model definite horn theory 
availability uniform control mechanism sld resolution key aspect horn logic programming 
horn programs definite horn theories need specify definitions properties objects domains interest 
programmer longer needs specify exact way perform computation 
control provided mechanism sld resolution 
feature logic programming separation logic part control part remains attractive features logic programming 
allows programmers focus logic problem frees burden specifying control 
consequently carries promise easier code development facilitates modular design software eases problems program verification kow 
due separation logic control logic programming classified declarative programming system 
function symbols critical horn logic programming 
presence function symbols language especially list constructor allows programmer encode hereditarily finite higher order objects terms language 
consequently logic program clauses describe recursive definitions higher order objects 
modeling recursive definitions logic programs responsible expressive power logic programming important common programming techniques 
situation changes drastically function symbols particular available 
formalism extensively studied possible query language database community known datalog see instance ull 
function symbols herbrand universe finite horn programs finite 
ability represent higherorder objects datalog significantly restricted 
similarly recursive definitions longer modeled datalog clauses describe complex objects higher order constructed simpler ones 
consequently expressive power finite datalog programs limited 
express proper subset polynomial time computable queries 
presence function symbols language responsible expressive power horn logic programming 
summarize key features horn logic programming 
expectation entirely materialize 
peculiarities logic programming implementations including subtleties search space pruning side effects resulted paradigm easily accepted real life programmers 

existence single intended model herbrand model yields semantics horn logic programs notion computability 
horn programs compute extensions predicates model 

function symbols language allow programmer encode higher order objects terms represent recursive definitions objects means horn clauses 

horn programs specify recursively enumerable set 
horn logic programming precisely captures commonly accepted notion computability 

horn logic programming declarative due separation logic represented horn programs uniform control represented sld resolution 
negation logic programming observed point view expressive power horn logic programming powerful programmer want captures recursively enumerable sets 
declarative system quite satisfying 
ability describe intuitive declarative specifications objects computed significantly hampered disallowing negation operator bodies clauses 
recognized early development field 
particular negation operator available prolog creation extensions horn logic programming negation bodies program clauses studied mid 
fact effort extend horn logic programming allowing negation operator bodies strongest driving forces development area past years 
task far straightforward adding negation implies existence unique model fundamental features horn logic programming paradigm longer guaranteed 
proposals address problem divided classes 
proposals type attempt salvage notion single intended model cost narrowing class programs weakening semantics 
apt blair walker abw introduced notion stratification syntactic restriction logic programs negation 
assigned stratified program single intended model perfect model 
approach van gelder ross schlipf assigned arbitrary program single intended valued model founded model 
proposals spirit horn logic programming paradigm 
approaches program specifies extensions predicates single intended model perfect founded respectively 
suitably modified versions resolution proposed uniform processing mechanisms rrs rrs 
approaches lead problems excessive expressive power 
apt blair ab proved stratified programs finite number strata specify precisely arithmetic sets 
means expressive considered computable 
founded model coincides perfect model stratified programs result applies founded semantics fact perfect models locally stratified particular programmer uses logic programming environment founded seman programs prz specify bigger class sets class sets bms 
class sets specified programs founded model total general founded semantics specifies class sets sch 
common idea proposals second type distinguish models program collection intended models single 
class supported models introduced clark cla years gelfond lifschitz gl fine tuned clark approach defined class stable models candidates intended models logic programs negation 
goal perspective logic programming stable model semantics focus stable models 
briefly recall definition stable model detailed treatment reader referred mt 
logic program pg grounding subset herbrand base stable model coincides model reduct pg respect reduct program obtained pg removing pg clauses containing body literal form removing literals form remaining clauses 
directly definition derive fundamental properties stable models 
stable model logic model furthermore stable model minimal model supported model family stable models program form antichain 
stable model semantics day proposed subject controversy 
hand commonly accepted stable models provide right semantics logic programming negation 
abundance evidence support claim 
instance known stable model semantics coincides model semantics definite horn programs 
stratified logic programs coincides perfect model semantics 
founded model total defines unique stable model 
founded model valued stable model prz 
addition demonstrated mt bf kam logic programming stable model semantics closely related default logic reiter rei commonly accepted formalism knowledge representation 
hand clear reconcile stable model semantics paradigm horn logic programming section 
problems lack single intended model notion specification requires modifications increase expressive power accepted limits computability inadequacy resolution control 
problem degree overcome means called skeptical semantics 
semantics ground atom entailed program true stable models 
say logic program negation specifies subset hu predicate symbol occurring hu skeptical 
point problems expressive power reappear 
stratified pro tics instance xsb understand programs specify complex sets computation terminate 
non termination occurs horn logic programming complex semantics adds additional layer complexity programmer task 
grams unique stable model skeptical semantics coincides perfect model semantics programs 
consequently results expressivity perfect semantics stratified programs apply situation 
problem decide existence complete problem decide stable model finite logic program membership stable models complete mnr 
problems far accepted notions computability 
additional complication 
due complexity form resolution applicable general case skeptical semantics drastic restrictions syntax programs 
case founded semantics conditions limiting complexity known resolution systems founded semantics developed rrs rrs case skeptical semantics results established 
stable logic programming difficulty fitting logic programming stable model semantics paradigm horn logic programming combined intuitive appeal stable models believe place stable model semantics logic programming reexamined 
propose alternative paradigm horn logic programming paradigm consistent properties stable models 
refer stable logic programming slp short 
stable logic programming aspects different horn logic programming general level shares key feature separation logic control 
consequently logic programming formalisms stable logic programming declarative 
programmer specifies problem hand logic program 
program processed uniform control mechanism solving original problem 
differences syntax semantics 
differences affect control mechanism longer sld resolution expressive power stable logic programming corresponding programming methodology 
specify stable model programming discuss differences detail 
restrict syntax saw earlier restrictions expressive power gets hand 
trivially negation operator remain language need stable model semantics 
major source complexity function symbols eliminated 
restriction stratification presence negation operator function symbols language complexity grows limits computability ab 
stable logic programming adopt language logic programming consists denumerable collections constant variable predicate symbols 
addition allow negation operator appear bodies program clauses 
finite programs language referred slp programs 
due presence negation existence herbrand model longer guaranteed 
semantics slp programs defined terms stable models 
address issue detail observe formalism finite function symbol free logic programs negation extensively studied database community 
formalism referred datalog semantics datalog studied 
stratified version datalog perfect model semantics founded semantics received particular attention ahv 
time datalog stable model semantics drawn significant interest database community due fact stable model semantics guarantee single intended model determine answer query stated datalog program 
skeptical stable semantics regarded quite satisfactory set atoms entailed semantics model datalog query 
lack single intended stable model perceived problem logic programming database communities plays key role stable logic programming 
stable model semantics finite slp program viewed specification finite family finite sets 
say finite slp program specifies family sets ary predicate 
ck hu ck stable model 
notion specification counterpart case slp notion specification case horn logic programming 
allows programmer resorting function symbols write logic programs specify second order objects horn logic programming encoded means terms involving operator 
state formally multiple intended models allow recover slp expressive power logic programming lost eliminating function symbols language 
addition notion specification suggests slp programs suited represent problems solutions finite families finite sets 
instance hamiltonian cycle directed graph set edges set pairs vertices 
collection hamiltonian cycles graph collection sets pairs object form 
section exhibit explicit slp programs represent hamiltonian cycle problem 
expressive power slp garey johnson gj define search problem consist set finite instances 
instance finite set solutions instance algorithm solves search problem instance returns answer empty solution 
notice decision problems viewed special search problems instance decision problem define instance 
notice search problem associate decision problem instance decide 
interesting search decision problems associated stable logic programming 
consider finite slp program clearly herbrand universe herbrand base grounding finite 
consequently stable models exist finite 
follows problem compute finite slp program stable models search problem 
search problem interest finite slp element herbrand base hb compute stable model containing associated decision problem asks existence stable models finite slp program related decision problems ask element herbrand base hb belongs stable models understand expressive power slp need study search decision problems reduced search decision problems associated slp 
consider class decision problems restrict moment propositional programs 
theorem mt plays key role discussion 
theorem problem decide finite propositional logic program stable model np complete 
theorem implies decision problem class np instance propositional program constructed time polynomial size solution stable model 
decision problem np solved uniform control mechanism deciding existence stable models logic programs 
instance decided may encode propositional logic program constructed time polynomial size decide instance deciding stable model 
decision problem decided way np 
consider search problem 
assume instance propositional program satisfying condition stronger version condition polynomially computable function sol models 
class stable search problems type solved similar way described earlier case decision problems 
instance constructs program finds stable model computes sol returns solution stable model exists answer returned 
best knowledge open problem characterize class search problems approach class search problems programs satisfying conditions 
saw decision problems class np solved way 
furthermore search problems associated decision problems np considered far dealt way encodings discussed 
approach relies encodings decision search problems problems involving existence computation stable models propositional programs 
entirely satisfactory different programs needed instance problem put differently logic separated data 
possible approach takes advantage variables language 
consider search problem 
assume exist effective encoding edb instance represented database fixed instances relational database scheme finite slp program instance polynomially computable function sol class stable models edb 
solved instance constructing program edb finding stable model reconstructing solution sol 
approach elegant spirit standard programming 
approach regarded program logic solving problem database edb viewed data 
clear separation logic uniform possible instances problem data encodings problem instances 
say search problem solved uniform slp program exist encoding edb program satisfying 
case earlier approaches question search problems solved uniform slp program 
strengthening theorem proved sch 
theorem decision problem solved uniform slp program class np 
decision problems complete answer 
problem remains open arbitrary search problems 
point search problems associated decision problems np considered far solved 
summarize due absence function symbols expressive power stable logic programming restricted compared horn logic programming 
due negation stable model semantics lost expressive power recovered 
slp capture decision problems np search problems decision versions np 
recursion versus constraints restrictions syntax slp change semantics consequently change notion specification requires different approach programming 
importantly recursion severely restricted 
limited version recursion available 
recursive definitions predicates sets extensions modeled slp clauses 
instance slp clauses define transitive closure relation rel tc rel tc tc rel function symbols build terms representing higher order objects far clear clause capture recursive definitions specify complex objects constructed simpler ones 
instance consider hlp program clique vertex clique clique assume predicate defined succeed precisely vertex connected edge vertices list repetitions 
program consisting definition clauses description graph terms facts specifying extensions predicates vertex edge computes cliques notice time clause computation produces longer list precisely iteration step operator associated program generates new ground terms need included extension predicate clique 
capability growing set available ground terms strength weakness hlp 
allows code hereditarily finite sets time possible write programs terminate 
phenomenon occur slp available constants prescribed new terms built constants function symbols accomplish 
time saw earlier slp expressive specify higher order objects 
slp program specifies collection stable models defined collections extensions predicates stable models 
clauses program represent recursive definitions individual stable models act constraints 
specifically ground clause qm 
rn expresses constraint qi belong putative stable model rj belongs belongs words model clause treated propositional formula 
crucial difference propositional logic stable logic programming adds constraint preferred way compute sets satisfy order enforce constraint qi computed rj established added set qi eliminated rj added 
lies key difference horn logic programming stable logic programming 
specify higher order object horn logic programming programmer models object term represents program recursive definition object 
specify secondorder object slp programmer thinks object stable model program constructs program modeling definition object expressed terms constraints 
feature slp especially suited deal constraint satisfaction problems point nie 
important issue raised discussion represent constraints slp clauses 
technique adding selection clauses case default logic techniques discussed 
applications specify objects interest problem hand specifying general domain objects selected family subsets set family tuples set specifying additional conditions constraints objects satisfy 
particular constraint satisfaction problems type 
develop programs encoding solutions problems proceed steps 
develop slp program family stable models encodes general domain candidate objects subsets sequences length 
add program clauses representing constraints enforced 
applications involving subsets universe constraints form subsets universe solution contains set contain element words solution contain set contain element set assume slp program stable models subsets family stable models enforce constraint sets construct program stable models exactly stable models satisfy add clause ak bm 
ak 
bm atom occurring formally theorem 
theorem logic program family stable models constraint sets atoms stable model satisfies 
corollary theorem follows conjunctions constraints type formulas conjunctive normal form enforced slp programs consisting clauses conjunct 
size slp program linear size cnf formula 
theorem step methodology programming slp programs 
systematic study programming techniques appropriate case slp conducted performed slp programming language 
technique quite powerful 
illustrate applied encode combinatorial problems 
revisit clique problem 
assume graph described lists facts vertex vertices graph denote set vertices edge edges graph 
denote lists facts 
specify cliques slp program needs write program specifying subsets set vertices graph 
accomplished instance clauses clq vertex clq vertex stable models program consisting clauses clq clq facts form subset vertex set 
stable models program correspondence subsets vertex set regarded representations 
need select stable models represent sets satisfying clique condition vertices clique connected edge 
condition may expressed constraint type vertices clique equal connected edge 
constraints pairs vertices expressed single slp clause clq vertex vertex edge theorem program consisting facts clauses clq clq stable models precisely sets form clique 
illustrate approach describing programs encoding problems 
computing hamiltonian cycles directed graphs 
computing models propositional cnf formula problem need represent directed graphs 
directed graph set vertices set directed edges represent facts vertex vertices edge directed edges vertex denote representation 
consider clauses ham edge ham edge clauses set facts define slp program stable models form set edges stable models represent subsets set edges sets edges hamiltonian cycles satisfy additional constraints edges cycle vertex edges equal edges cycle start vertex edges equal 
theorem constraints enforced adding clauses ham ham stable models expanded program form set edges spanning set vertex disjoint paths cycles 
adding clauses ham reached reached ham reached expands stable models set atoms reached vertices reached vertex means nonempty sequence edges model note weaker notion recursion available slp 
stable model encodes hamiltonian cycle vertices reached 
constraint enforced clause ham reached follows program consisting clauses ham ham facts set stable models sets form reached set edges hamiltonian cycle satisfiability problem need represent cnf formulas 
consider cnf formula set clauses set variables formula represented lists facts var clause clause pos variable clause appears positively neg variable clause appears negatively specification cnf formula denoted 
consider clauses sat true var false sat false var true clauses generate possible truth assignments variables formally program consisting clauses sat sat stable models sets form true false subset represent set valuations 
clauses sat sat var clause true pos sat sat var clause false neg simply define clause satisfied add stable model set clauses true valuation represented model 
formula satisfiable valuation clauses true 
requirement enforced adding clause sat clause sat follows stable model program consisting clauses sat sat facts set sat true false propositional model 
encodings far uniform 
input data problem encoded collection facts constraints defining problem clauses usually variables part depending particular input 
parts correspond extensional intensional components datalog program 
encodings possible easier come 
point consider satisfiability problem 
consider cnf formula set variables set clauses time represent valuations subsets turns simple propositional encoding satisfiability problem 
note clauses sat sat sat sat ranges specify subsets stable models program consisting clauses sat sat precisely sets form subset clause ak bm add program slp clause sat 
ak 
bm set atoms satisfies clause satisfies constraint ak 
bm follows program consisting clauses sat sat stable models sets form model 
emphasize encodings discussed section unique 
satisfiability encodings constitute example 
different encoding hamiltonian cycle problem nie encodings propositional default theories logic programs combinatorial problems 
encodings may different computational properties 
particular second encoding satisfiability uniform requires separate program created satisfiability instance may better suited processing 
issue programming methodology result programs stable models quickly computed important 
studied receive significant attention stable logic programming practical problem solving tool 
uniform control slp seen earlier sections slp programs specify wide class search decision problems 
addition declarative fashion modeling direct way constraints defining problem hand 
slp programs suited represent logic part kowalski algorithm logic control phrase 
order stable logic programming serve effective computational problem solving tool knowledge representation formalism need develop component kowalski equation uniform control 
stable logic programming problems encoded slp programs solutions correspond stable models uniform control consist algorithms process slp programs compute decide existence stable models 
algorithms proposed years 
particular algorithms proposed decide existence stable models propositional logic program compute stable models exist 
algorithms decide membership atom stable models developed ns cmt elm adn 
algorithms employ backtracking search space subsets herbrand base program collection propositional letters occur program 
variety search space pruning techniques 
techniques rely generalization concept stratification cmt 
methods wellfounded semantics way unit propagation davis putnam procedure computing models cnf formulas ns 
notice function symbols language slp herbrand universe herbrand base grounding arbitrary necessarily propositional finite slp program finite 
straightforward algorithms produce finite ground version finite slp program 
sophisticated algorithms minimizing size ground program preserving stable models proposed ns cho 
algorithms compute stable models finite propositional programs arbitrary finite slp programs termination guaranteed 
algorithms led implementations systems processing slp programs computing stable models 
smodels ns ns cmt system described elm 
systems control mechanism stable logic programming environment transforms slp knowledge representation formalism computational programming tool 
transition horn logic programming slp semantics methodology programming changes 
control change 
sld resolution basis control mechanism slp provided backtracking search algorithms search spaces subsets finite set herbrand base finite slp program 
stable logic programming viable proposal new logic programming system advances algorithms computing stable models subsequent implementations algorithms ns cmt elm 
comprehensive studies implementations performed available results provide reasons optimism 
classes programs systems smodels ns cmt successfully process programs tens thousands clauses 
addition reported nie smodels successfully compete class planning problems special purpose planners comprehensive discussion applications logic programming planning see lif collection papers referred 
clear performance systems computing stable models improving attractiveness slp computational tool grow 
despite significant progress existence systems smodels algorithms computing stable models needed order obtain acceptable performance 
open problems development new powerful pruning techniques study probabilistic algorithms stable model computation 
directions discussed stable model semantics foundation computational logic programming system different horn logic programming 
system stable logic programming slp shares logic programming systems key feature separation logic control 
despite fact stable model semantics roots efforts extend principles horn logic programming case programs negation stable logic programming aspects differs significantly standard logic programming systems 

slp programs assigned collection intended models single intended model horn logic programming stratified logic programming logic programming founded semantics 

function symbols language higher order objects represented slp stable models programs ground terms herbrand universe case horn logic programming similar systems 

slp programs interpreted sets constraints objects computed horn logic programming clauses model recursive definitions constraints 

control mechanism slp longer resolution 
uniform control slp consists backtracking search algorithms computing stable models programs 

slp lower expressive power standard logic programming systems 
may limitation class problems solved slp quite wide includes decision problems np search constraint satisfaction problems importance artificial intelligence operations research 
believe perspective stable logic programming certainly warrants investigations 
outline interesting research directions 
start fundamental question stable logic programming simply propositional logic 
finite collection clauses possibly variables function symbols finite collection facts viewed representation finite propositional formula conjunctive normal form 
consequently viewed encoding family models formula way slp program represents family stable models key observation underlying stable model programming 
propositional satisfiability problem np complete decision problems np reduced time satisfiability testing solved means programs davis putnam procedure satisfiability testing 
constraints type easily encoded clauses 
real need resort logic programming 
challenging open problem 
believe answer positive offer rigorous argument support claim 
opinion advantage stable logic programming stems properties stable models 
minimal 
dealing optimization problems minimality comes free stable model semantics 
second grounded facts included stable models justified 
furthermore comparison existing encodings combinatorial problem shows cases encodings terms logic programs concise terms satisfiability possibly due groundedness property stable models 
particular believe concise encodings existence hamiltonian cycle problem problem existence stable model logic program asymptotically concise similar encodings problem existence satisfying valuation cnf formula 
developing formal setting compare stable logic programming propositional logic providing rigorous account advantages disadvantages approaches important general theoretical challenges 
second important research direction development systematic study methodology developing slp programs 
initial steps direction section 
potential trade 
hand important objectives ease program development 
hand want programs run fast 
third despite successes implementing systems stable model semantics done 
far performance studies existing systems ad hoc 
comprehensive experimental studies needed give insights computational nature stable models lead faster algorithms 
support studies needs benchmarking systems 
step direction theory base system described 
slp especially suited dealing constraint satisfaction problems 
important extend language slp important classes constraints involving arithmetic operations relations easier model 
possibility incorporating slp existing constraint solving systems important problem 
evidence slp useful tool solving planning problems nie 
studying applicability slp paradigm classical problems artificial intelligence operations research may provide additional motivation focusing approach may gain badly needed recognition logic programming 
ab apt blair 
arithmetical classification perfect models stratified programs 
fundamenta informaticae 
abw apt blair walker 
theory declarative knowledge 
minker editor foundations deductive databases logic programming pages los altos ca 
morgan kaufmann 
afrati yannakakis 
datalog vs polynomial time 
proceedings pods pages 
adn dix niemel 
disjunctive logic programming system 
proceedings th international conference logic programming nonmonotonic reasoning pages 
springer ln computer science 
ahv abiteboul hull vianu 
foundations databases 
addison wesley publishing 

generalized completeness horn predicate logic programming language 
acta cybernetica 
ave apt van emden 
contributions theory logic programming 
journal acm 
bf bidoit froidevaux 
negation default logic programs 
theoretical computer science 
bms blair marek schlipf 
expressiveness locally stratified programs 
annals mathematics artificial intelligence 
cho 
automated reasoning default logic 
phd thesis university kentucky 
ph thesis 
colmerauer 
un systeme de communication machine en 
technical report university marseille 
cl 
chang 
lee 
symbolic logic mechanical theorem proving 
academic press 
cla clark 
negation failure 
gallaire minker editors logic data bases pages 
plenum press 
ski marek truszczy ski 
experimenting nonmonotonic reasoning 
proceedings th international conference logic programming pages 
mit press 
ski marek truszczy ski 
programming default logic 
submitted publication 
cmt ski marek truszczy ski 
default reasoning system 
proceedings kr pages 
morgan kaufmann 
cp cadoli 
circumscribing datalog expressive power complexity 
theoretical computer science 
cadoli schaerf 
np spec executable specification language solving problems np 
unpublished manuscript 
elm eiter leone pfeifer scarcello 
deductive system non monotonic reasoning 
proceedings th international conference logic programming nonmonotonic reasoning pages 
springer ln computer science 
gj garey johnson 
computers intractability guide theory np completeness 
freeman 
gl gelfond lifschitz 
stable semantics logic programs 
kowalski bowen editors proceedings th international symposium logic programming pages cambridge ma 
mit press 
herbrand 
recherches sur la th orie de la 
phd thesis paris 
kam 
note stable semantics logic programs 
technion israel institute technology pp 
kow kowalski 
predicate logic programming language 
proceedings ifip pages amsterdam 
north holland 
kow kowalski 
logic problem solving 
north holland amsterdam 
lif lifschitz 
action languages answer sets planning 
unpublished manuscript 
llo lloyd 
foundations logic programming 
berlin springer verlag 
lov loveland 
automated theorem proving logical basis 
north holland 
mnr marek nerode remmel 
stable models predicate logic programs 
proceedings international joint conference symposium logic programming boston ma 
mit press 
mt marek truszczy ski 
stable semantics logic programs default theories 
lusk overbeek editors proceedings north american conference logic programming pages 
mit press 
mt marek truszczy ski 
autoepistemic logic 
journal acm 
mt marek truszczy ski 
nonmonotonic logics context dependent reasoning 
springer verlag 
mw maier warren 
computing logic 
logic programming prolog 
benjamin cummings publishing 
nie niemel 
logic programs stable model semantics constraint programming paradigm 
niemel schaub editor proceedings workshop computational aspects nonmonotonic reasoning pages 
ns niemel simons 
evaluating algorithm default reasoning 
proceedings ijcai workshop applications implementations reasoning systems 
ns niemel simons 
efficient implementation founded stable model semantics 
proceedings jicslp 
mit press 
prz ski 
declarative semantics deductive databases logic programs 
foundations deductive databases logic programming pages los altos ca 
morgan kaufmann 
prz przymusinski 
stationary semantics disjunctive logic programs 
technical report university texas el paso 
rei reiter 
logic default reasoning 
artificial intelligence 
rob robinson 
machine oriented logic resolution principle 
journal acm 
rrs rao sagonas swift warren 
efficient tabling mechanisms logic programs 
proceedings th international conference logic programming cambridge ma 
mit press 
rrs rao sagonas swift warren freire 
xsb system efficiently computing founded semantics 
proceedings lpnmr pages 
berlin springer verlag 
lecture notes computer science 
sch schlipf 
expressive powers logic programming semantics 
journal computer systems science 
smu 
order logic 
berlin springer verlag 
ull ullman 
principles database knowledge base systems 
computer science press rockville md 
van gelder ross schlipf 
unfounded sets founded semantics general logic programs 
journal acm 

