ieee transactions information theory vol 
march linear programming decode binary linear codes jon feldman martin wainwright member ieee david karger associate member ieee new method performing approximate maximum likelihood ml decoding arbitrary binary linear code observations received discrete memoryless symmetric channel 
decoding algorithm linear programming lp relaxation defined factor graph parity check representation code 
resulting lp decoder generalizes previous turbo codes 
precise combinatorial characterization lp decoder succeeds provided associated factor graph 
definition pseudocodeword unifies notions known iterative algorithms including stopping sets irreducible closed walks trellis cycles deviation sets graph covers fractional distance code introduced lower bound classical distance 
shown efficient lp decoder correct errors codes efficient algorithm compute fractional distance 
experimental evidence shows similar performance low density parity check ldpc codes lp decoding min sum sum product algorithms 
methods tightening lp relaxation improve performance provided 
index terms belief propagation bp iterative decoding parity check ldpc codes linear codes linear programming lp lp decoding minimum distance 
low density parity check ldpc codes discovered gallager 
rediscovered number researchers received lot attention 
error correcting performance codes fact chung family ldpc codes come db capacity channel block length goes infinity 
decoders family manuscript received may revised december 
feldman conducted author mit laboratory computer science supported part national science foundation postdoctoral research fellowship dms 
karger supported part national science foundation contract ccr david packard foundation fellowship 
material part conference information sciences systems baltimore md june 
feldman department industrial engineering operations research columbia university new york ny usa mail columbia edu 
wainwright department electrical engineering computer science department statistics university california berkeley berkeley ca usa mail eecs berkeley edu 
karger computer science artificial intelligence laboratory csail massachusetts institute technology cambridge ma usa mail karger mit edu 
communicated urbanke associate editor coding techniques 
digital object identifier tit ieee belief propagation algorithm messages iteratively sent factor graph modeling structure code 
performance decoder quite analyzing behavior difficult factor graph contains cycles 
introduce new algorithm decoding arbitrary binary linear code method linear programming lp relaxation 
design polytope contains valid codewords objective function maximum likelihood ml codeword optimum point integral coordinates 
linear programming find polytope possibly fractional optimum achieve success optimum transmitted codeword 
experiments ldpc codes show performance resulting lp decoder better iterative min sum algorithm 
addition lp decoder ml certificate property outputs codeword guaranteed ml codeword 
standard iterative methods known desirable property 
desirable feature lp decoder amenability analysis 
introduce variety techniques analyzing performance algorithm 
give exact combinatorial characterization conditions lp decoding success presence cycles factor graph 
characterization holds discrete memoryless symmetric channel channels linear cost function defined code bits lowest cost codeword ml codeword 
define set superset set codewords prove lp decoder finds lowest cost pseudocodeword 
lp decoder succeeds lowest cost pseudocodeword transmitted codeword 
define notion fractional distance factor graph essentially minimum distance codeword pseudocodeword 
analogy performance guarantees exact ml decoding respect classical distance prove lp decoder correct errors binary symmetric channel bsc 
prove fractional distance linear code check degree exponential girth graph associated code 
graph logarithmic girth fractional distance lower bounded constant code length 
case ldpc codes show compute fractional distance efficiently 
fractional distance useful evaluating performance code lp decoding serves lower bound true distance code 
feldman linear programming decode binary linear codes relation iterative algorithms techniques chung analyze ldpc codes richardson urbanke luby give algorithm calculate threshold randomly constructed ldpc code 
threshold acts limit channel noise noise threshold reliable decoding belief propagation bp achieved block length goes infinity 
threshold analysis idea considering ensemble codes purposes analysis averaging behavior ensemble block length code goes infinity 
ensembles known constant difference error rate belief propagation decoding random code average code ensemble probability exponentially small block length 
calculating error rate ensemble average difficult factor graph contains cycles iterative algorithms traverse cycles repeatedly noise channel affect final decision complicated highly dependent ways 
complication avoided considering limiting case infinite block length probability message traversing cycle converges zero 
practical block lengths leads poor approximation true error rate 
valuable examine behavior code ensemble fixed block lengths try analyze effect cycles 
di took finite length analysis ldpc codes binary erasure channel bec 
key results notion purely combinatorial structure known stopping set 
bp fails stopping set exists erased bits error rate bp reduced purely combinatorial question 
case bec show define exactly stopping sets 
performance lp decoder equivalent bp bec 
notion pseudocodeword unifies known results particular cases codes channels 
tail biting equivalent introduced forney 
applied analysis computation trees min sum decoding connection deviation sets defined wiberg refined forney frey koetter vardy 
previous results previous introduced approach decoding turbo code similar network flow linear programming relaxation techniques 
gave precise combinatorial characterization conditions decoder succeeds 
properties lp decoder design rate repeat accumulate ra code certain class simple turbo codes proved upper bound probability decoding error 
showed derive classical iterative algorithm performance identical lp decoder 
outline section ii giving background factor graphs binary linear codes ml decoding problem 
lp relaxation ml decoding section iii 
section iv discuss basic analysis lp decoding 
define section fractional distance section vi 
section vii draw connections various iterative decoding algorithms lp decoder experiments 
section viii discuss various methods tightening lp order get better performance 
conclude discuss section ix 
notes developments preliminary forms part appeared conference papers thesis authors 
submission shown lp decoder defined correct constant fraction error certain ldpc codes variant lp achieve capacity expander codes 
additionally relationships lp decoding iterative decoding refined 
discovered independently koetter notion graph cover equivalent notion pseudocodeword graph defined 
authors explores notions detail gives new bounds error performance 
ii 
background linear code parity check matrix represented tanner factor graph defined way 
indices columns respectively rows parity check matrix code 
notation bipartite graph independent node sets refer nodes variable nodes nodes check nodes 
edges endpoint edge included neighborhood check node denoted set nodes check node incident variable node similarly set check nodes incident particular variable node imagine assigning variable node value representing value particular code bit 
node satisfied collection bits assigned variable nodes parity 
binary vector codeword check nodes satisfied 
fig 
shows example linear code associated factor graph 
hamming code set neighborhood check node parity 
represents codeword write codewords include denote maximum variable left degree factor graph maximum nodes ieee transactions information theory vol 
march fig 

factor graph uy ry qa hamming code 
nodes iy py qy ry sy ty drawn open circles correspond variable nodes nodes ey fy black squares correspond check nodes 
degree denote minimum variable degree 
denote maximum minimum check right degree factor graph 
channel assumptions binary codeword length sent noisy channel corrupted word received 
assume arbitrary discrete memoryless symmetric channel 
notation denote probability codeword sent channel received 
assume information words equally priori bayes rule assumption implies code memoryless property channel implies space possible received symbols 
example bsc additive white gaussian noise awgn channel symmetry set partitioned pairs ml decoding received word ml decoding problem find codeword maximizes equivalent minimizing negative log likelihood call cost function 
assumptions channel cost function written known negative log likelihood ratio llr variable node 
example bsc crossover probability set received bit interpretation cost decoding note cost may negative decoding better choice frequently exploit fact cost vector uniformly rescaled affecting solution ml problem 
bsc example rescaling allows assume iii 
decoding linear programming section formulate ml decoding problem arbitrary binary linear code show equivalent solving linear program codeword polytope 
define modified linear program represents relaxation exact problem 
codeword polytope motivate lp relaxation show ml decoding formulated equivalent lp 
code define codeword polytope convex hull possible codewords note polytope contained hypercube includes exactly vertices hypercube corresponding codewords 
point corresponds vector element defined summation vertices polytope points expressed convex combinations points polytope 
key fact linear program attains optimum vertex polytope 
consequently optimum attained vertex vertices correspondence codewords 
define ml decoding problem minimizing subject constraint formulation linear program involves minimizing linear cost function polytope lp relaxation common practical method solving linear program simplex algorithm generally requires explicit representation constraints 
lp formulation exact ml decoding just described characterized finite number linear constraints number constraints exponential code length ellipsoid algorithm require explicit representation useful case ml decoding np hard general 
strategy formulate relaxed polytope contains codewords manageable representation 
concretely motivate lp relaxation observation 
check node factor graph defines local code set binary vectors weight neighborhood variables 
global code corresponds intersection local codes 
lp feldman linear programming decode binary linear codes terminology check node defines local codeword polytope meaning set convex combinations local codewords global relaxation polytope intersection polytopes 
variables naturally denote code bits 
define local codeword polytope consider set variable nodes neighbors check node interest subsets contain number variable nodes subset corresponds local codeword set defined setting index arbitrarily 
setting set introduce auxiliary lp variable indicator local codeword set associated setting equal indicates set bits set note variable parity check represents setting variables zero 
equal indicator variables variables constraints satisfy variable seen indicating codeword satisfies check configuration parity check satisfied particular sized subset nodes neighborhood set may enforce constraint satisfied codeword 
indicator variable node belong local codeword polytope associated check node leads constraint polytope set points hold check node intersection polytopes set points hold linear code linear program lclp corresponds problem minimize 
integral point polytope referred integral solution linear program point polytope values integers 
observing correspondence codewords integral solutions lclp 
proposition integral points sequence represents codeword 
furthermore codewords exists integral point proof suppose point suppose codeword parity check unsatisfied setting constraints fact integral constraints satisfied setting contradiction 
second part claim codeword set nodes codeword check satisfied variable 
set constraints satisfied variables integral 
decoding algorithm lclp consists steps 
solve lp obtain output optimal codeword fractional output error proposition get 
proposition lp decoding ml certificate property algorithm outputs codeword guaranteed ml codeword 
proof algorithm outputs codeword cost equal points codeword point proposition 
cost equal cycle free factor graph shown optimal solution lclp integral 
lclp exact formulation ml decoding problem cycle free case 
contrast factor graph cycles optimal solution lclp may integral 
take example hamming code fig 

suppose define cost vector follows variable node set nodes set hard verify cost function codewords nonnegative cost codeword negative cost set set total cost consider fractional solution lclp set check node set check node assign lastly check node set verified satisfies lclp constraints 
cost solution strictly cost codeword 
note solution convex combination codewords contained solution gets outside exploiting local perspective relaxation check node satisfied configuration check node configuration 
analysis follow provide insight nature fractional solutions lclp 
worthwhile noting local codeword constraints identical enforced bethe free energy formulation bp 
reason surprising performance lp decoder turns closely related bp min sum algorithms 
ieee transactions information theory vol 
march lp solving polytope representations efficiency practical lp solvers depends lp represented 
lp defined set variables cost function polytope set linear constraints 
ellipsoid algorithm guaranteed run time polynomial size lp representation proportional number variables constraints 
simplex algorithm guaranteed run efficiently worst case dependence representation size usually efficient ellipsoid algorithm 
details solving linear programs refer reader standard texts 
polytope described intuitive form relaxation 
ldpc codes size linear ellipsoid algorithm provably efficient reasonably expect simplex algorithm efficient practice 
arbitrary binary linear codes number constraints exponential degree check node 
check node degree expect random codes example polytope number constraints exponential solve efficiently need define smaller polytope produces results 
alternative representations lp useful analytical purposes 
see discuss fractional distance section vi 
polytope equivalence polytopes variables may involve auxiliary variables variables description polytopes share set possible settings variables may 
formalize notion 
definition polytope defined variables auxiliary variables projection variables 
say equivalent words require projections variables 
objective function lclp involves variables optimizing produce result 
remainder section define new polytopes 
explicit description useful defining computing fractional distance code cover section vi 
second polytope equivalent small representation high density codes 
equivalence shows lclp solved efficiently binary linear code 
projected polytope subsection derive explicit description polytope definition terms constraints derived parity polytope jeroslow 
enforce fig 

equivalence polytopes dimensions 
polytope defined set points inside unit hypercube distance odd weight hypercube vertices 
polytope convex hull weight hypercube vertices 
check explicitly forbid bad configuration neighborhood specifically odd require note integral settings bits satisfy constraints check exactly local codewords 
set points satisfy particular check odd 
understand constraints rewriting follows words distance relevant portion incidence vector set 
constraint ensures separated bit flip illegal configurations 
dimensions easy see constraints equivalent convex hull sized subsets shown fig 

fact theorem states general enforce checks get explicit description theorem polytope equivalent 
words polytope exactly set points satisfy checks odd 
proof recall set points satisfy local codeword polytope check consider projection words convex hull local codeword sets defined sets note exactly expresses constraints associated check recall set points satisfy constraints particular check suffices show shown jeroslow 
completeness include proof fact appendix feldman linear programming decode binary linear codes high density code polytope recall maximum degree check node graph 
stated lclp variables constraints 
turbo ldpc codes complexity linear constant 
arbitrary binary linear codes give characterization lclp variables constraints 
derive characterization give new polytope local codeword polytope construction yannakakis size exponential dependence size check neighborhood 
refer representation polytope details representation proof equivalent appendix ii 
iv 
analysis lp decoding lp decoding method error arise ways 
lp optimum integral case algorithm outputs error lp optimum may integral corresponds ml codeword ml codeword transmitted 
case code failed exact ml decoding error 
notation denote probability lp decoder error transmitted 
proposition feasible solution lclp corresponding transmitted codeword characterize conditions lp decoding succeed follows 
theorem suppose codeword transmitted 
feasible solutions lclp cost cost lclp decoder succeeds 
solution lclp cost cost fails 
decoder proof proposition feasible solution lclp 
feasible solutions lclp cost cost unique optimal solution lclp 
decoder output transmitted codeword 
solution lclp cost cost optimal solution lclp 
variables affect cost solution decoder outputs error outputs transmitted codeword 
degenerate case multiple optima lclp decoder may may succeed 
conservative consider case decoding failure theorem proceed provide combinatorial characterizations decoding success analyze performance lp decoding various settings 
zeros assumption analyzing linear codes common assume codeword sent channel zeros vector tends simplify analysis 
context lp relaxation validity assumption immediately clear 
section prove zeros assumption analyzing lclp 
basically follows fact polytope highly symmetric codeword polytope looks exactly 
theorem probability lp decoder fails independent codeword transmitted 
proof see appendix iii 
point forward analysis lp decoding assume zeros codeword transmitted codeword 
zeros codeword zero cost theorem consideration multiple lp optima failure gives 
corollary zeros codeword transmitted may assume theorem lp decoder fail point cost equal zero 
section introduce concept pseudocodeword lp decoding define scaled version solution lclp 
consequence theorem hold way holds solutions lclp 
definition codeword motivates notion pseudocodeword 
recall set sized subsets neighborhood check node vector setting nonnegative integer weights weight check say codeword edges factor graph corresponds exactly consistency constraint lclp 
difficult see construction guarantees binary vector codeword original code 
obtain definition pseudocodeword removing restriction allowing take arbitrary nonnegative integer values 
words pseudocodeword vector nonnegative integers parity check neighborhood sum local codewords incidence vectors sized sets 
definition codeword trivially pseudocodeword sum codewords pseudocodeword 
general exist decomposed sum codewords 
illustration consider hamming code fig 
earlier constructed fractional lclp solution code 
simply scale fractional solution factor result pseudocodeword form 
ieee transactions information theory vol 
march setting satisfy constraints pseudocodeword set pseudocodeword expressed sum individual codewords 
fact optimum points linear program rational coefficients rational 
simple scaling arguments zeros assumption restate corollary terms follows 
theorem zeros codeword transmitted may assume theorem lp decoder fail pseudocodeword proof suppose decoder fails 
optimal point lp point minimizes corollary construct pseudocodeword follows 
lowest common denominator exists optimal point lp optimal points lp rational 
integer integer sets bits set checks sets set constraints meets definition pseudocodeword 
cost exactly wehave implies see establish converse suppose pseudocodeword construct point follows set code bits checks set sets ii set handle special case exist 
construction definition pseudocodeword meets constraints polytope cost exactly point cost equal zero 
corollary lp decoder fails 
theorem essential proving equivalence iterative decoding bec section vii 
pseudocodeword graphs codeword corresponds particular subgraph factor graph particular vertex set subgraph consists variable nodes check nodes variable nodes incident 
pseudocodeword associated graph analogous way 
graph vertices 
consists node graph contains copies graph contains copies check node label refer set copies variable node copies check node label edges graph connected membership sets precisely consider edge copies node consider set nodes copies check node labeled sets include words set definition pseudocodeword pseudocodeword graph connect sized node sets arbitrary matching correspondence 
process repeated edge note check node appears exactly sets neighbor set node consists exactly copy variable node furthermore variable node connected exactly copy check node cost pseudocodeword graph sum costs variable nodes graph equal cost pseudocodeword derived 
theorem holds pseudocodeword graphs 
fig 
gives graph pseudocodeword example earlier fig 
gives graph different complex pseudocodeword 
graphical characterization pseudocodeword essential proving lower bound fractional distance 
additionally pseudocodeword graph helpful making connections notions literature 
discuss section vii 
vi 
fractional distance classical quantity associated code distance linear code equal minimum weight nonzero codeword 
section introduce fractional analog distance prove additional results performance lp decoding 
roughly speaking fractional distance minimum weight nonzero vertex codewords nonzero vertices fractional distance lower bound true distance 
fractional distance connections minimum weight pseudocodeword defined wiberg studied forney 
feldman linear programming decode binary linear codes fig 

graph pseudocodeword uy ry qa hamming code 
particular pseudocodeword copies node copies check fig 

graph pseudocodeword hy iy hy iy hy py uy ry qa hamming code 
dotted circles show original variable nodes factor graph sets nodes dotted squares original check nodes contain sets shown dashed lines definitions basic properties correspondence codewords integral vertices classical distance code equal minimum weight nonzero integral vertex polytope 
relaxed polytope may additional vertices 
particular earlier example hamming code involved constructing precisely fractional vertex 
stated previously optimal solution lclp vertex note objective function lclp affects variables consequence point vertex projection 
general vertices projected vertices projected polytope definition fractional distance vertices exactly settings optimal solutions lclp 
introduce false vertices optimal points problem included costs variables 
point define weight set nonzero vertices fractional distance code minimum weight vertex note fractional distance lower bound classical distance code nonzero codeword contained performance lp decoding tied fractional distance precise 
theorem code fractional distance lp decoder successful binary symmetric channel 
bits flipped proof suppose lp decoder fails optimal solution lclp know vertex wehave implies fractional distance set bits flipped channel 
bsc zeros assumption write cost bits flipped channel follows theorem fact decoder failed optimal solution lclp cost equal zero contradiction 
note analogy classical case just exact ml decoding performance guarantee terms classical distance theorem establishes lp decoder performance guarantee specified fractional distance code 
computing fractional distance contrast classical distance fractional distance ldpc code computed efficiently 
fractional distance lower bound real distance efficient algorithm give nontrivial lower bound distance ldpc code 
compute fractional distance compute minimum weight vertex consider general problem facets polytope vertices specified vertex linear function find vertex minimizes efficient algorithm problem set facets sit 
facet intersect facet obtain optimize minimum value obtained facets minimum vertices running time algorithm equal time taken calls lp solver 
algorithm correct argument 
known vertex polytope dimension uniquely determined giving linearly independent facets polytope vertex sits 
fact clear vertex looking sit facet point point procedure potential considered 
furthermore intersect facet obtain ieee transactions information theory vol 
march fig 

average fractional distance function length randomly generated ldpc code left degree right degree ensemble gallager 
vertices vertices equal true obtain minimum value facets problem interested polytope special vertex order run procedure small explicit representation theorem 
number facets representation exponential dependence check degree code 
ldpc code number facets linear compute exact fractional distance efficiently 
arbitrary linear codes compute minimum weight nonzero vertex section iii provides possibly weaker lower bound fractional distance 
representation explicitly appendix ii introduces auxiliary variables may false vertices low weight 
experiments fig 
gives average fractional distance randomly chosen ldpc factor graph computed algorithm just described 
graph left degree right degree randomly chosen ensemble gallager 
data insufficient extrapolate growth rate fractional distance certainly grows nontrivially block length 
conjectured growth rate linear block length case graphs regular degree conjecture disproved koetter 
fig 
gives fractional distance normal realizations reed muller codes 
codes defined lengths equal power classical distance exactly curve suggests fractional distance graphs roughly note code families may alternate realizations factor graphs better fractional distance 
david forney suggesting study normal realizations reed muller codes 
fig 

classical versus fractional distance normal realizations reed muller codes 
classical distance codes exactly ap 
upper part fractional distance curve follows roughly max fractional distance subsection define notion fractional distance call max fractional distance 
simply fractional distance normalized maximum value 
show lp decoder corrects half max fractional distance 
furthermore prove section max fractional distance grows exponentially girth define max fractional distance code polytope essentially proof theorem obtain 
theorem code max fractional distance lp decoder successful flipped binary symmetric channel 
bits exact relationship interesting question 
clearly general fact know follows fact 
proof fact comes simple scaling arguments 
ldpc codes quantities constant factor 
compute max fractional distance efficiently algorithm similar fractional distance reduce problem finding point minimum imum weight point polytope 
finding min lower bound girth theorem asserts max fractional distance exponential girth analogous earlier result tanner provides similar bound classical distance code terms girth associated factor graph 
feldman linear programming decode binary linear codes theorem factor graph girth max fractional distance theorem proved appendix iv heavy combinatorial properties 
consequence theorem max fractional distance constant graph girth note known constructions graphs 
theorem yield bound word error rate wer bsc demonstrates lp decoding girth 
errors code defined graph loga vii 
comparison iterative decoding section draw connections lp decoding iterative decoding code types channel models 
show known combinatorial characterizations decoding success fact special cases definition pseudocodeword 
discuss stopping sets bec cycle codes tail biting tree reweighted max product algorithm wainwright min sum decoding 
section give experimental results comparing lp decoding min sum sum product bp algorithms 
stopping sets bec bec bits flipped erased 
consequently bit decoder receives erasure 
symbol received correct 
hand erasure denote received information bit 
known bec iterative bp decoder fails stopping set exists erased bits 
main result section stopping sets special case bec lp decoding exhibits property 
model bec lclp cost function bsc received bit set information bit 
note zeros assumption costs nonnegative bits flipped 
theorem implies lp decoder fail nonzero pseudocodeword zero cost 
set code bits erased channel 
subset stopping set checks neighborhood degree respect statement assumed iterative lclp decoders fail answer ambiguous 
iterative algorithm ambiguity corresponds existence stopping set lclp algorithm corresponds nonzero pseudocodeword zero cost multiple optima lp 
theorem bec nonzero pseudocodeword zero cost stopping set 
performance lp bp decoding equivalent bec 
proof zero cost pseudocodeword stopping set 
pseudocodeword suppose stopping set check node neighbor definition pseudocodeword definition cardinality code bit neighbor check wehave definition pseudocodeword implying contradicts fact neighbor stopping set zero cost pseudocodeword 
stopping set 
construct pseudocodeword follows 
set set immediately check set definition stopping set odd odd arbitrary size subset set set set set process 
additionally pseudocodeword 
cycle codes cycle code binary linear code described factor graph variable nodes degree case consist collection cycle structures call 
structure closed walk graph allowed repeat nodes traverse edges different directions long turns edge twice row 
wiberg calls structures irreducible closed walks 
may conclude connection iterative lp decoding identical performance case cycle codes 
note cycle codes poor general excellent example lp decoding decode minimum distance 
cycle codes minimum distance better logarithmic 
showed cycle codes lp decoding wer requiring crossover probability bounded certain function constant independent 
ieee transactions information theory vol 
march tail biting tail biting write linear program similar explored turbo codes lp correspond analyzed forney 
linear program fact instance network flow solvable efficient algorithm generic lp solver 
see general treatment lps trellis codes including turbo codes 
case correspond cycles directed graph circular trellis 
cycles graph length integer codewords simple cycles length exactly forney show iterative decoding find pseudocodeword minimum symbol 
basic network flow theory shown weight symbol pseudocodeword cost corresponding lp solution 
algorithms identical performance 
note get connection tail biting code factor graph representation sufficient simply write factor graph code plug polytope weaker relaxation general 
define new linear program turbo codes 
setup problem reduces directly min cost flow 
tree reweighted max product earlier explored connection lp approach applied turbo codes tree reweighted max product message passing algorithm developed wainwright jaakkola willsky 
similar usual max product min sum algorithm algorithm passing messages nodes factor graph 
differs usual updates messages suitably reweighted structure factor graph 
drawing connection dual linear program showed algorithm converges codeword ml codeword 
note usual min sum algorithm guarantee 
min sum decoding deviation sets defined wiberg refined forney compared pseudocodeword graphs 
computation tree iterative min sum algorithm map computations lead decoding single bit root tree 
bit decoded correctly assuming zeros word sent locally consistent minimal configuration tree sets bit configuration called deviation set ora pseudocodeword 
deviation sets support set nodes configuration set supports acyclic graphs form 
nodes nodes factor graph possibly multiple copies node 
furthermore leaves variable nodes fig 

waterfall region comparison performance lp decoding min sum decoding iterations bsc random rate ldpc code length left degree right degree trial decoders tested channel output 
error curve represents trials decoders failed 
nonleaf variable node connected copy check node check node degree 
clear definition deviation sets quite similar pseudocodeword graphs essentially difference deviation sets acyclic 
fact removed nonleaf condition equivalent 
thesis wiberg states graph finite infinite deviation behave completely irregularly repeat 
appears natural look repeatable closed structures graph property deviation decomposed structures 
definition pseudocodeword natural closed structure deviation set 
arbitrary deviation set decomposed may irregular near leaves 
furthermore wiberg points cost deviation set dominated cost near leaves number nodes grows exponentially depth tree 
strictly speaking min sum decoding lp decoding incomparable 
experiments suggest rare min sum decoding succeed lp decoding fail see fig 

conclude experiments irregular portions min sum computation tree worth considering hurt decoder help 
new iterative algorithms ml certificates lp dual earlier described iterative subgradient ascent algorithm solve lp dual ra codes 
iterative decoder error correcting performance identical lp decoding case 
technique may applied general setting ldpc codes iterative algorithm ldpc code performance guarantees lp decoding 
feldman linear programming decode binary linear codes fig 

comparison performance lp decoding min sum decoding iterations bp iterations bsc random rate iar ldpc code length left degree right degree fig 

comparison performance ml decoding lp decoding min sum decoding iterations bp iterations bsc random rate iar ldpc code length th left degree right degree ml decoder mixed integer programming decoder lp relaxation 
furthermore show lp duality give iterative algorithm ml certificate property derive conditions output message passing decoder provably ml codeword 
experimental comparison compared performance lp decoder min sum sum product decoders bsc 
randomly generated rate ldpc code left degree right degree fig 
shows error rate comparison waterfall region block length see lp decoding performs better min sum region sum product 
compare algorithms ml decoding random codes similar performance 
shown fig 

fact see lp decoding slightly outperforms sum product low noise levels 
interesting see general phenomenon explained analytically 
fig 

error correcting performance gained adding set redundant parity checks factor graph 
code randomly selected regular ldpc code length rh left degree right degree ensemble gallager 
order decoder lp decoder polytope defined original factor graph 
second order decoder uses polytope defined factor graph adding set redundant parity checks set consists checks sum pa original parity checks 
viii 
tighter relaxations important observe lclp defined respect specific factor graph 
code representations possible lp relaxations may better 
particular significance fact adding redundant parity checks factor graph affect code provides new constraints lp relaxation general strengthen 
example returning hamming code fig 
suppose add new check node neighborhood parity check redundant code simply mod sum checks linear constraints added check tighten relaxation fact render example pseudocodeword infeasible 
redundant constraints may degrade performance bp decoding due creation small cycles adding new constraints improve lp performance 
example fig 
shows performance improvement achieved adding second order parity checks factor graph second order mean parity checks sum original parity checks 
natural question adding redundant parity checks results codeword polytope turns case dual hamming code provides counterexample 
addition redundant parity checks various generic ways lp relaxation strengthened 
lifting techniques provide nested sequence relaxations increasing tightness complexity equivalent albeit exponential complexity 
obtain sequence decoders increasing performance complexity intractable ml decoder 
interesting analyze rate performance improvement ieee transactions information theory vol 
march fig 

wer lift project relaxation compared lp decoding ml decoding 
sequence 
fig 
shows performance gained application lift project method random ldpc code length interesting question complex decoder needed order surpass performance bp 
fractional distance code defined function factor graph representation code 
fractional distance yields lower bound true distance quality bound improved adding redundant constraints methods tightening lp 
ml decoding integer programming interesting application lp decoding polytope perform true ml decoding 
integer program ip optimization problem allows integer constraints may force variables integers 
add constraint linear program get exact formulation ml decoding 
general integer programming np hard various methods solving ip far outperform naive exhaustive search routines ml decoding 
program cplex able perform ml decoding ldpc codes moderate block lengths reasonable amount time 
fig 
includes error curve ml decoding ldpc code block length trial took seconds pentium iv ghz processor 
drawing curve allows see gap various suboptimal algorithms optimal ml decoder 
gap motivates search tighter lp relaxations approach ml decoding 
running time decoder prohibitive longer block lengths ml decoding small block lengths useful evaluating algorithms determining decoding errors fault decoder code 
ix 
discussion described lp decoding method proved number results error correcting performance 
central characterization notion pseudocodeword corresponds rescaled solution lp relaxation 
definition pseudocodeword unifies previous iterative decoding 
introduced fractional distance code quantity shares worst case error correcting guarantees classical notion efficient algorithm realize guarantees 
number open questions directions suggested detail 
earlier version suggested graph expansion improve performance bounds 
accomplished degree know lp decoding correct constant fraction error 
done order improve constant level best known bound 
know lp decoding achieve capacity commonly considered channels 
interesting see methods extended achieve capacity exponential dependence gap capacity known capacity achieving decoders dependence 
turbo codes turbo codes efficient encoders ldpc codes interesting see lp decoding obtain performance bounds setting 
previous ra codes able prove bound error rate lp decoding stronger implied minimum distance 
analogous lp decoders general turbo codes remains provide satisfying analysis performance 
appendix proving theorem recall set points odd prove theorem remains show 
theorem polytope 
proof variable unconstrained aside constraints may ignore indices assume 
henceforth denote point constraints convex hull incidence vectors sized sets vectors satisfy constraints check node satisfy constraints 
direction suppose point contained facet cuts infeasible 
case passes hypercube cut vertex hypercube incidence vectors sized sets feasible vertex incidence vector odd sized set feldman linear programming decode binary linear codes particular specify facet terms variables equation infeasible wehave may conclude denote vector bit flipped odd parity parity cut implies note may conclude case polytope full dimensional 
example set points exactly cyclically consecutive full dimensional set 
full proof see 
pass vertices pass parity binary vectors 
claim true case faces case pass points 
claim vectors points suppose case 
vertex facet differs place 
suppose loss generality wehave wehave contradicts fact passes vertices itis hard see exactly odd set constraint corresponding set incidence vector 
cuts facet wehave contradiction 
appendix ii high density polytope representation appendix give polytope lclp variables constraints 
polytope provides efficient way perform lp decoding binary linear code 
polytope derived parity polytope yannakakis 
check node set numbers new representation sets variables 
variable variable represents code bit 
variable weight variable indicates contribution local codewords 
variable indicating portion locally assigned local codewords weight variables constraint set set points constraints hold 
polytope variables check node plus variables total variables 
number constraints total representation variables constraints 
show optimizing equivalent optimizing cost function affects variables suffices show polytopes projection variables 
proving need fact 
lemma nonnegative integers 
expressed sum sets size exists setting variables specifically nonnegative integers proof induction base case simple equal exactly equal set induction step assume set 
fact implies induction expressed sum size set increase setting expresses proposition set equal set optimizing equivalent optimizing proof suppose set ryan donnell showing proof 
ieee transactions information theory vol 
march clear constraints satisfied setting 
constraint implied 
constraint implied 
giving constraint 
suppose vertex polytope variables rational 
consider set members common divisor numbers integer 
set consists integers sum elements equal lemma set expressed sum sets size set variables lemma 
set immediately satisfy 
lemma get giving 
giving 
construction works vertices projection point variables appendix iii proving theorem appendix show zeros assumption valid analyzing lp decoders defined factor graphs 
specifically prove theorem 
theorem probability lp decoder fails independent codeword transmitted 
proof recall probability lp decoder error transmitted 
arbitrary transmitted word need show define set received words cause decoding failure assuming transmitted 
theorem note cost vector function received word rewriting codewords applying codeword get show space possible received vectors partitioned pairs gives partition performed symmetry channel 
fix received vector define follows symmetric symbol channel 
note operation inverse gives valid partition pairs 
show channel memoryless equations follow definition follows symmetry channel 
feldman linear programming decode binary linear codes remains show cost vector received cost vector received defined 
suppose suppose equation follows symmetry channel 
conclude lemma shows correspondence points cost function points cost function lemma fix codeword furthermore prove lemma section 
suppose definition lemma symmetric argument half lemma shows proving lemma need define notion relative solution prove results feasibility cost 
sets denote symmetric difference point lclp corresponding codeword sent channel 
particular feasible solution lclp set relative solution respect follows bits set checks member set note fixed operation making relative solution inverse relative solution lemma feasible solution lclp relative solution respect feasible solution lclp 
proof consider bounds variables see 
satisfied definition fact feasible 
consider distribution constraints 
feasibility definition checks defined definition note get satisfying distribution constraints 
remains show satisfies consistency constraints 
assume sets contained appropriate set clear context 
edges wehave case case step follows fact long case step follows fact long distribution constraints get lemma point relative solution wehave proof definition wehave ieee transactions information theory vol 
march get lemma follows fact ready prove lemma completes proof theorem 
restate lemma 
lemma fix codeword furthermore proof consider relative solution respect lemma lemma second part lemma consider relative solution respect lemma operation making relative solution inverse relative solution lemma appendix iv proving theorem proving theorem prove useful facts pseudocodeword graphs 
theorems section factor graph variable nodes having degree check nodes having degree girth graph arbitrary pseudocodeword define path may repeat nodes edges takes turns represent set nodes path particular clear context 
note variable check node 
paths similar notion irreducible closed walk wiberg 
simple path graph repeat nodes 
recall represent sets variable check nodes copies node underlying factor graph variable node corresponding node variable node check node 
claim length girth simple path represents simple path precisely simple path simple path proof note valid path 
construction edge edge simple simple need show simple 
true length girth graph 
remainder appendix suppose note bipartite 
set nodes distance set nodes path length claim subgraph induced node set tree 
proof suppose case 
node different paths length implies cycle length contradiction claim 
claim node subsets mutually disjoint 
proof suppose case share vertex 
vertex closest root appears consider subpath unique path tree subpath unique path tree show turns 
subpaths simple show chose node closest appears appear simple path claim 
node appears twice 
contradiction 
claim number variable nodes proof take node set count number nodes level tree induced level consists nodes distance note levels contain variable nodes odd levels contain check nodes 
feldman linear programming decode binary linear codes consider variable node level 
variable nodes incident nodes construction children tree level 
consider check node odd level check nodes incident nodes check node child level 
tree expands factor odd level 
odd level may expand contract 
final level tree level final level level expansion properties showed level tree contain variable nodes 
claim tree independent number variable nodes theorem factor graph girth max fractional distance proof arbitrary vertex construct pseudocodeword lemma integer integer bits integer checks sets integer exists vertex rational 
bits set checks sets set graph pseudocodeword section 
lemma variable nodes 
number variable nodes equal wehave recall substituting follows argument holds arbitrary 
feldman karger decoding turbo codes linear programming proc 
rd annu 
ieee symp 
foundations computer science focs vancouver bc canada nov pp 

feldman wainwright karger linear programming decoding turbo codes relation iterative approaches proc 
allerton conf 
communications control computing monticello il oct 
di telatar richardson urbanke finite length analysis low density parity check codes binary erasure channels ieee trans 
inf 
theory vol 
pp 
jun 
wiberg codes decoding general graphs ph dissertation link ping university link ping sweden 
forney kschischang marcus iterative decoding tail biting connections symbolic dynamics codes systems graphical models 
new york springer verlag pp 

forney koetter kschischang effective weights codes defined graphs cycles codes systems graphical models 
new york springer verlag pp 

gallager low density parity check codes ire trans 
inf 
theory vol 
pp 
jan 
mackay error correcting codes sparse matrices ieee trans 
inf 
theory vol 
pp 
mar 
sipser spielman expander codes ieee trans 
inf 
theory vol 
pp 
nov 

chung forney richardson urbanke design low density parity check codes db shannon limit ieee commun 
lett vol 
pp 
feb 
mceliece mackay cheng turbo decoding instance pearl belief propagation algorithm ieee sel 
areas commun vol 
pp 
feb 
richardson urbanke capacity low density codes message passing decoding ieee trans 
inf 
theory vol 
pp 
feb 
luby mitzenmacher shokrollahi spielman improved low density parity check codes irregular graphs belief propagation proc 
ieee int 
symp 
information theory cambridge ma oct 
frey koetter vardy signal space characterization iterative decoding ieee trans 
inf 
theory vol 
pp 
feb 
feldman wainwright karger linear programming decode linear codes th annu 
conf 
information sciences systems ciss baltimore md mar 
feldman karger wainwright lp decoding proc 
st annu 
allerton conf 
communications control computing monticello il oct 
feldman decoding error correcting codes linear programming ph dissertation mit cambridge ma 
feldman malkin stein wainwright lp decoding corrects constant fraction errors proc 
ieee int 
symp 
information theory chicago il jun jul 
feldman stein lp decoding achieves capacity proc 
symp 
discrete algorithms soda vancouver bc canada jan 
koetter graph covers iterative decoding finite length codes proc 
rd int 
symp 
turbo codes france sep pp 

koetter relationship linear programming decoding max product decoding submitted int 
symp 
information theory applications parma italy oct 
lower bounds minimum pseudo weight linear codes proc 
ieee int 
symp 
information theory chicago il jun jul 
schrijver theory linear integer programming 
new york wiley 
grotschel lov sz schrijver ellipsoid method consequences combinatorial optimization combinatorica vol 
pp 

ieee transactions information theory vol 
march berlekamp mceliece van inherent intractability certain coding problems ieee trans 
inf 
theory vol 
pp 
may 
wainwright jaakkola willsky map estimation agreement hyper trees message passing linear programming approaches proc 
th annu 
allerton conf 
communication control computing monticello il oct 
yedidia freeman weiss understanding belief propagation generalizations mitsubishi electric res 
labs tech 
rep tr 
bertsimas tsitsiklis linear optimization 
belmont ma athena scientific 
jeroslow defining sets vertices hypercube linear inequalities discr 
math vol 
pp 

yannakakis expressing combinatorial optimization problems linear programs comp 
syst 
sci vol 
pp 

forney jr codes graphs normal realizations ieee trans 
inf 
theory vol 
pp 
feb 
tanner recursive approach low complexity codes ieee trans 
inf 
theory vol 
pp 
sep 
rosenthal constructions ldpc codes ramanujan graphs ideas margulis proc 
th annu 
allerton conf 
communication control computing monticello il oct pp 

bertsekas nonlinear programming 
belmont ma athena scientific 
lov sz schrijver cones matrices set functions optimization siam vol 
pp 

sherali adams hierarchy relaxations continuous convex hull representations zero programming problems siam vol 
pp 

user manual ilog cplex ed ilog mountain view ca 
