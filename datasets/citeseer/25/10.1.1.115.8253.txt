vldb journal dynamic vp tree indexing nearest neighbor search pair wise distances ada wai chee fu polly mei chan yin ling cheung sang moon department computer science engineering chinese university hong kong hong kong mail cse cuhk edu hk edited zsu christodoulakis 
received june accepted january 
multimedia applications domain objects represented feature vectors multidimensional space 
pair wise distances data objects input 
support content retrieval approach maps object dimensional point tries preserve distances points 
existing spatial access index methods trees kd trees support fast searching resulting points 
information loss inevitable approach distances data objects preserved certain extent 
investigate distance indexing method 
particular apply vantage point tree vp tree method 
important problems vp tree method warrant investigation neighbors search updating mechanisms 
study nearest neighbors search algorithm shown experiments scale size dataset desired number nearest neighbors experiments show searching vp tree efficient tree tree 
propose solutions update problem vp tree show experiments algorithms efficient effective 
investigate problem selecting vantage point propose alternative methods study impact number distance computation 
key words content retrieval indexing nearest neighbor search updating pair wise distances advent large scale multimedia database systems need efficiently answer user queries 
contentbased retrieval typically required 
advantage approach bypasses difficult problem specifying desired multimedia objects terms formal query languages 
popular form content queries employs query example paradigm 
example vldb journal springer verlag collection images users existing images query templates ask system images similar query images 
called query 
alternatively user sketch picture serves query template 
support content retrieval rely feature extraction capabilities map domain object point space object represented chosen features 
example feature vector may color components image shot cuts video clip 
processing content queries typically requires measurement similarity kd points 
similarity distance objects measured metric distance function space 
common metric distance function euclidean distance 
entire problem formulated storing retrieving points fine tuned indexing methods available 
general methods called multidimensional indexing spatial access methods sams 
previous works :10.1.1.102.7240:10.1.1.40.9848
setting applied certain applications 
example cites example typed english words similarity function defined minimum number insertion deletions substitutions transform string example matching digitized voice excerpts include consideration time warping 
time warping problem occurs similarity search time series 
examples describes method measuring similarity color images color similarity matrix takes account perceptual distance different pairs colors 
shape similarity natural definition value area difference measure area shapes match placed top obtain pixel wise exclusive shapes 
method represents shape terms boundaries string edit distance similarity measure employed number changes required transform 
applications may relatively easier domain expert assess similarity distance fu dynamic vp tree indexing nearest neighbor search pair wise distances objects giving computable definition similarity 
applications similarities distances pairs data 
cases distances metric meaning triangle inequality property applies assumption 
distance information need indexing method support query update 
problem approach uses distance information deduce points objects subsequently vector space model vsm multidimensional indexing methods tree variants 
fastmap algorithm multidimensional scaling fall category 
main challenge approach preserve distances possible 
difficult decide value map domain object point accurately representing similarity objects metric space 
experimental results show approach incur considerable amount inaccuracy nearest neighbor search 
study alternative approach uses distance indexing known metric space model msm indexing 
particular examine vantage point tree vp tree method 
approach obviously save overhead inferring points multidimensional space avoid difficulty preserving distances 
main contributions 
apply nearest neighbor search algorithm vp tree index method 
experiments neighbor search algorithm demonstrates promising performance 
detailed implementation suggest implement method physical clustering vp tree nodes 
compare costs neighbor search tree tree experiments show search vp tree considerably efficient 

update problem left open variants 
propose mechanisms update operations vp tree 
investigate alternatives insert operation split techniques alternatives delete operation merge redistribute 
techniques preserve balanced tree property vp tree 
split merge strategies preserve original characteristics vantage points efficient 
show experiments updating cost particularly expensive 

propose alternative techniques vantage point selection reduce number distance computations 
experiments carried demonstrate proposed methods efficient effective 
rest organized follows 
previous related described sect 

sect 
give experimental results distance preserving approach 
section details algorithm nearest neighbor search performance results 
update mechanisms vp tree outlined sect 
comparison different approaches experiments 
section discusses possible improvements selection fig 

partitioning mechanism vantage point tree method vantage points experimental results 
conclude sect 
outline 
related pair wise distances objects major approaches indexing methods contentbased retrieval distance preserving transformation methods distance indexing methods 
shall briefly describe approaches 
distance preserving methods distance preserving approach try deduce object corresponding point multidimensional space distances objects preserved possible 
example method pattern recognition multidimensional scaling mds 
fastmap algorithm proposed faloutsos lin 
experiments showed fastmap achieves dramatic computational savings known mds methods loss quality results shall focus fastmap method 
details mds methods omitted brevity 
fastmap algorithm assumes objects points unknown high dimensional space projects points mutually orthogonal directions userdefined objects mapped points space 
important requirement fastmap fulfill preserve distances possible euclidean distances points space match pair wise distances 
distances preserved sufficiently information distinguishes objects maintained 
mapping number highly fine tuned spatial access methods tree employed provide fast searching range queries nearest neighbor queries fastmap introduces pre processing costs index construction querying domain objects query object mapped corresponding points index structure built query processed :10.1.1.102.7240
mapping objects nk points requires recursive calls function called fastmap 
example target deduce points objects fastmap determine coordinates objects axis recursive call axis second recursive call 
example find objects distance query object 
example find objects closest query object 
fu dynamic vp tree indexing nearest neighbor search pair wise distances pick set candidate vantage points data set vantage point pick set sample objects data set compute distance values vantage point sample objects calculate mean standard deviation distance values endfor choose candidate vantage point maximum standard deviation 
distance index structures quite number distance indexing structures proposed 
summary methods 
previous includes techniques suggested contains basic ideas methods generalized hyperplane tree gh tree vantage point tree vp tree geometric access tree gnat mvp tree variation vp tree tree 
gnat compared binary vp tree set experiments incur expensive construction numbers distance computations range querying 
mvp tree uses pre computed distance reduce number distance computations uses multiple vantage points tree node 
shown experiments mvp tree incur distance computations range querying compared vp tree 
nearest neighbor search considered gnat vp tree variations focus number distance computations range queries 
tree balanced tree able deal dynamic data 
tree internal node routing object objects subtree node certain distance routing object 
updating allowed may trigger node splitting 
experimental results show competent access method 
shall compare approach tree 
vantage point tree method vp tree structure describe detail vp tree method 
consider finite set data points node tree particular data object selected vantage point randomized algorithm shown fig 

point chosen root node median distance values points respect partitioned subsets approximately equal sizes defined distance points illustrates concept 
partitioning procedure applied recursively 
subset corresponds node vp tree 
vp tree uses term point refer data objects shall terms data points data objects interchangeably 
fig 

algorithm choose vantage point node distinct vantage point chosen partition data points corresponding subset 
leaf node store number data points 
eventually entire data set organized balanced tree spatial index structures 
ary vp tree construction similar case binary vp trees 
data set split subsets si tom distance values chosen vantage point data points 
si roughly number data points 
denote boundary distance value si 
si recursively partitioned smaller subsets partitioning mechanism 
note perform updating vp tree branching factor vp tree node reduced deletion shall specify minimum branching factor 
value maximum branching factor 
example minimum branching factor ary vp tree 
multi vantage point tree mvp tree incorporates mechanisms top vp tree reduce number distance computations 
mechanism keep pre computed distances data points vantage points 
second mechanism vantage point partition space spherical cuts level 
shall adopt mechanism implementation 
shall study second mechanism sect 

motivation vsm methods try preserve distances problem accuracy distance information may lost 
show experiment inaccuracy may result method 
implemented fastmap tree unix 
performed tests nearest neighbor queries relative points chosen dataset 
average taken performance randomly chosen query points 
tree implemented able handle nearest neighbor search 
experiment synthetic dataset 
generated dataset points space 
points form clusters number points cluster 
centers clusters uniformly distributed distances points cluster centers follow normal distribution 
input euclidean distances data points 
study accuracy nearest neighbor search resulting fastmap method dimensionality fu dynamic vp tree indexing nearest neighbor search pair wise distances percentage query accuracy fastmap number dimensions fig 

query accuracy vs number dimensions dataset objects fig 

meaning threshold increases varied 
nearest neighbors query objects 
fastmap sets points deduced 
set points organized tree 
necessary map query objects space 
resulting queries submitted trees search algorithm run obtain results 
expressed accuracy nearest neighbor search percentage answers nearest neighbors query object 
reported average accuracy queries 
plots percentage query accuracy function number dimensions 
fastmap lower dimensionality nearest neighbors missed 
mainly fastmap may preserve actual distances objects preservation problem gets worse getting smaller 
enhancements proposed tree methods multi step nearest neighbor search method 
enhancements efficiency method help enhancing accuracy method data subjected information loss 
discussion fastmap suffers difficulties preserving actual distances determining proper value achieve high accuracy 
propose methods able locate nearest neighbor fast response 
chosen vp tree approach 
advantages vp tree approach mainly lie 
need infer multidimensional points domain objects index built 
build index directly distances 
avoids pre processing steps 
major problems pre processing fastmap approach computation involved steps costly 
difficult determine number dimensions preserve distances satisfactory level 

updates vp tree relatively easier fastmap method 
fastmap method certain amount data objects inserted deleted mapping data points longer 
point fastmap executed objects clear determine time re construction 
comparison updates vp tree straightforward see sect 


distance indexing method vp tree flexible applicable multimedia objects pair wise distances able index objects represented feature vectors fixed number dimensions case feature extraction functions available 
show performance better tree tree terms page accesses nearest neighbor search 
nearest neighbor search vp trees content retrieval rare exact match multimedia data nearest neighbor queries desirable 
practice users ask certain number objects similar query object select part returned collection 
interested finding nearest neighbors query object usually greater 
describe algorithm nearest neighbor search vp tree 
basic idea similar nearest neighbor search index trees tree tree 
single nearest neighbor search algorithm relies specific threshold estimates upper bound distance query object nearest neighbor 
distance points value algorithm look single nearest neighbor range see fig 

recall node vp tree vantage point determines subsets si distances 
hypersphere depicted fig 
falls inside boundary subset si algorithm needs explore particular subset 
multiple subsets subtrees need explored 
tighter value ensure subtrees explored increases chance nearest neighbor case search repeated greater value 
algorithm specific bound number trials passes increasing values 
mechanism generalized nearest neighbor search 
value similar way 
fu dynamic vp tree indexing nearest neighbor search pair wise distances procedure nnn search root input query point number nearest neighbors requested root node vp tree 
output set nearest neighbors local variable record distance th nearest neighbor discovered far 
search root return procedure search node input query point number nearest neighbors requested node vp tree distance th nearest points discovered far set nearest neighbors obtained far 
output updated values node leaf element node insert proper position sorted ascending order wn dist node dist node mu dist nodes mu search node left dist nodes mu search node right dist nodes mu search node right dist nodes mu search node left initial value set infinitely large 
value dynamically improved discover shorter distances query point data points come search 
simplicity focus binary partitioning case discussion easily generalized case ary vp tree 
construction algorithm vp tree similar original vp tree construction algorithm 
pseudocode algorithm fig 

algorithm triggers procedure call search root 
procedure search fig 
activated times 
traversal dynamically adjusted value distance query object current th nearest candidate 
guarantees nearest neighbors distance query point 
effectively perform depth search determined distances actual data objects leaf nodes encounter search 
tried alternative ways setting initial infinite experimental results show setting infinite initial value achieve better performance 
note depth traversal fig 
node vantage point node node mu median value node node left pointer left child node node right pointer right child node 
fig 

procedure nnn search fig 

procedure search adopt method proposed best traversed node subtree searched iteration 
lead better pruning power 
current method simpler experimental results show superior tree tree 
performance evaluation study performance nearest neighbor search algorithm vp tree implemented vp tree search algorithms unix ultrasparc 
experiment compared vp tree tree 
implemented algorithms tree berchtold keim kriegel able support nearest neighbor queries enhanced method proposed 
implemented neighbor search algorithms tree 
describe setup results observations 
experimental setup synthetic datasets real dataset 
synthetic datasets similar ones details areas follows fu dynamic vp tree indexing nearest neighbor search pair wise distances clustered sets vectors consisting clusters equal size 
cluster centered point chosen uniform distribution interval dimension point cluster uniformly distributed interval relative cluster center dimension 
uniform sets uniformly distributed vectors interval dimension 
real dataset provided berchtold keim kriegel contains mb fourier points variable dimensionality representing shapes polygons 
randomly extracted groups sizes points dimensions entire dataset 
provide details disk implementation vp tree 
internal node store vantage point boundary distance values child pointers denotes branching factor 
leaf node keep actual data objects feature vectors 
carried experiments branching factor affects performance way high low 
note low branching factor say size node small need keep vantage point object id feature vector median distance value pointers child nodes 
smaller node tree dimensionality data points 
fit number nodes vp tree page disk block 
suggest doing starting root scanning tree group levels subtree page 
repeated recursively lowest level nodes stored page 
suppose branching factor altogether vantage points kept page number child node pointers bottom subtree page 
essentially treat content page supernode branching factor see fig 

dotted box fig 
indicates contents page 
search vp tree typically traverses parent node child nodes clustering vp tree nodes help achieve page access rate fraction node access rate 
preliminary experiments show set achieve performance terms amount page accesses nearest neighbor search compared strategies 
value maximum branching factor internal nodes maximum number data objects contained leaf determined page size 
tables list parameters calculations 
kb page size assume vantage points data objects represented feature vectors dimensions dimension occupying byte float 
done experiments estimate optimal number branching internal nodes best results occurs greatest branching factor possible restriction levels subtree shown fig 

clustering vp tree nodes page table 
parameters calculating branching factor internal nodes parameters descriptions page size page kb flag indicator internal leaf node byte entries number internal nodes stored page bytes header flag entries bytes vantage point represented feature vector bytes sigma factor sigma factor algorithm bytes mu boundary distance value partitioning bytes pointer pointer child node bytes inode size internal node vantage point sigma factor mu pointer branching factor internal nodes fig 
held disk page 
chosen store level subtree node page meaning value 
branching factor internal nodes calculated finding value satisfies page header inode note child pointer stored internal vp tree node page pointer 
greater pointers may offsets page 
leaf nodes different structure internal nodes vp tree keep data vectors 
number data vectors stored leaf node 
maximize number data vectors stored page leaf node vp tree 
leaf node vp tree corresponds disk page 
tree internal node corresponds disk page maximize branching factor page size 
tree internal node keeps data object center spherical space corresponding node radius space 
nodes arranged vp tree child nodes table 
parameters calculating maximum number data objects stored leaf node parameters descriptions page size page kb flag indicator internal leaf node byte entries number data objects stored page bytes header flag entries bytes data object represented feature vector bytes max 
number data objects page header data object fu dynamic vp tree indexing nearest neighbor search pair wise distances page access non leaf leaf vp tree tree tree dataset size page access non leaf leaf vp tree tree tree number nearest neighbors nearest neighbors dataset size fig 
comparison tree tree synthetic clustered data dimension node stored disk page branching factor maximized arrangement 
measured total number pages accessed search assuming tree root stored disk 
results averaged query points randomly chosen test dataset 
comparison tree tree partitioning strategies adopted vp trees trees different 
vp tree partitions search space distances objects distance indexing tree uses absolute coordinate values multidimensional vector space feature indexing 
believe comparison significant distance index methods applied distance case vectorspace case 
tree popular distance indexing 
show vp tree comparatively performance searching argue vp tree choice content retrieval indexing 
compare vp tree tree 
tree distance indexing 
shown nearest neighbor search performance capable handling dynamic updates 
node structure tree similarity tree hyperspace occupied different nodes level tree overlap 
contrasts vp tree hyperspace sibling nodes disjoint 
results obtained averaging results runs nearest neighbor queries 
tested synthetic clustered datasets 
figures show performance vp tree tree tree terms page accesses function dataset size number nearest neighbors dimensionality respectively 
seen figures vp tree consistently outperforms tree tree 
plots results experiments fixed dimensionality nearest neighbor queries varying sizes datasets 
gap page access non leaf leaf vp tree tree tree number dimensions fig 

comparison tree tree synthetic clustered data dataset size nearest neighbors vp tree trees increases size datasets indicating vp tree method scales better 
different numbers nearest neighbors see vp tree fewer page accesses tree tree 
notice increase number nearest neighbors leads small increase search effort 
hand dimensionality greater impact performance 
significantly better performance tree tree 
results provide support findings previous trees efficient dimensionalities greater 
reasons vp tree achieves better performance tree discussed partitioning methods vp tree tree belong entirely different approaches 
nearest neighbor search algorithms accordingly certain specific properties perform differently 
particular tree undesirable property tree nodes level tree overlap data point lies overlapping area tree nodes grouped node 
property triggers backtracking searches especially high dimensional fu dynamic vp tree indexing nearest neighbor search pair wise distances page access non leaf leaf vp tree tree tree number nearest neighbors page access non leaf leaf vp tree tree tree dataset size nearest neighbors dataset size fig 
comparison tree tree synthetic uniform data dimension page access non leaf leaf vp tree tree tree number dimensions page access non leaf leaf vp tree tree tree dataset size synthetic uniform data dataset size real data number dimensions fig 
comparison tree tree dataset size nearest neighbors data overlapping problem serious 
vp tree introduce overlapping area tree nodes level 
explain vp tree better performance gap performance increases number dimensions tree limits closed bounded interval stored dimension size internal node tree larger vp tree 
leads lower fanout larger tree size resulting cost querying disk blocks vp tree highly utilized 
tree implementation focuses issues reduction overlap bounding boxes utilization rate typically high vp tree tree disadvantages having large internal tree nodes avoided vp tree stores center distance value indicate boundary node 
similar tree problem overlapping node spaces 
explain vp tree superior tree searching performance 
test dataset synthetic uniform 
recall dimensions set data varied lower clustered dataset 
figures show results 
compared results clustered dataset curves figures display considerable similarity terms general trend vp tree outperforms tree structures structures respond strongly increase number nearest neighbors 
better performance achieved vp tree explained reasons mentioned 
see performance clustered datasets 
due fact data objects uniform datasets distant making harder filter non qualifying objects nearest neighbor search 
curves uniform data exhibit slightly different trend tree perform better tree 
believe clustered data shape clusters spherical rectangular spherical nodes tree superior handling clusters 
advantage may hold uniformly distributed data 
real data studied dependency dataset size 
datasets sizes fixed maximum dimensionality 
presents number page accesses versus dataset size 
vp tree performs better tree tree 
gap open dataset size increases 
gives performance results fu dynamic vp tree indexing nearest neighbor search pair wise distances page access non leaf leaf vp tree tree tree number nearest neighbors page access non leaf leaf vp tree tree tree number dimensions dimension nearest neighbor fig 
comparison tree tree real data dataset size varying numbers nearest neighbors 
test dataset contained objects 
vp tree outperforms tree tree 
dataset size objects chosen experiment impact dimensionality data 
result shown fig 

vp tree performs better especially higher dimensions 
observing actual number page accesses reported figs 
clearly seen query cost required real data larger clustered data smaller uniform data 
mentioned objects uniform datasets distant explains cost involved searching uniform data 
believe original set real data provided berchtold keim kriegel real datasets correlated clustered 
randomly selected small part set containing objects clustering effect fully maintained 
search effort real data corresponds clustered uniform datasets require 
distance computation may see vp tree tree search requires distance computation expensive 
fact node access accompanied distance computation strategy discussed sect 
adopted 
nearest neighbor search algorithm tree requires computation distance mindist roughly shortest distance query point minimum bounding box tree node order achieve effective heuristic pruning 
computation node tree 
tree page storing node 
vp tree tree physical clustering described sect 
determines branching factor 
improved version tree implementation data object node representing center spherical space stored object id entire feature vector 
way branching factor tree independent number dimensions table 
maximum branching factor tree vp tree dimensions tree vp tree experiments 
enhance performance original tree method 
compare branching factors determined arrangements tree tree vp tree table 
branching factor tree maximum number minimum bounding rectangles stored node page determines number distance computations needed page access 
vp tree tree node may store number vantage points routing objects branching factor fraction need considered nodes search range need traversed 
experiments number page access vp tree search smaller compared tree tree number distance computation smaller 
update operations vp trees top partitioning strategy updates vp tree complex manage global reorganization structure may result 
tree variants conveniently split node simply propagate splitting vp tree 
partitioning parent node affects partitioning child nodes effect split needs propagated downwards 
similar problems apply merging nodes deletion 
handling update operations maintain balanced tree substantial restructuring left open problem 
propose algorithms doing insertions deletions vp tree 
maximum branching factor non leaf nodes maximum number objects contained leaf determined page size described sect 

non leaf non root node number child nodes varies minimum value maximum value tree 
minimum value fu dynamic vp tree indexing nearest neighbor search pair wise distances node node upper non leaf nodes new object needs inserted sibling leaf nodes full 
fig 
redistribution leaf nodes node node upper non leaf nodes leaf nodes leaf nodes needs inserted siblings full parent node room child 
fig 
splitting leaf node node node node node upper non leaf nodes needs inserted entire subtree full sibling subtree room choose redistribute objects fig 
redistribution subtrees vc vb old boundary fig 

redistribution non leaf nodes new boundary nodes points inside ring moved distances vc computed greater 
root leaf node child nodes 
node node upper non leaf nodes objects redistributed gets inserted boundary distances updated node upper non leaf nodes node node split nodes gets inserted 
node node leaf nodes leaf nodes node node upper non leaf nodes assume objects farthest respect vantage point 
redistribution moved subtree gets inserted 
insert insert new object level vp tree pick node distance associated vantage point new object computed 
traverse tree choosing subtree si distance range covers leaf node 
room insert new object insertion done 
full employ strategy 
examples figs 

sibling leaf node full redistribute objects leaf nodes fig 

number leaf nodes retrieve objects stored leaf nodes set objects retrieved plus new object inserted 
order objects respect distances vantage point divide groups equal cardinality ssi subsets update boundary distance values pointers stored fu dynamic vp tree indexing nearest neighbor search pair wise distances average num num num num set objects stored th subtree plus new object order objects respect distances vantage point number data objects moved th subtree th subtree num average divide subsets ss ss order ss num ss num num num ss delete th subtree mu max ss min ss ss reinsert st subtree set objects stored st subtree plus new object order objects respect distances vantage point number data objects moved st subtree th subtree num average divide subsets ss ss order ss sw ss sw sw num ss delete st subtree mu max ss min ss ss reinsert th subtree endif node node node node upper non leaf nodes needs inserted subtree full siblings ancestor room child 
node splitting fig 
splitting non leaf node mui max sj sj ssi min sj sj ssi leaf node containing ssi 

parent node room child split leaf node fig 

assume th child retrieve objects stored set objects retrieved plus new object 
order objects respect distances vantage point divide groups equal cardinality ss ss subsets order 
denotes number leaf nodes rooted pseudocode describes node fig 

algorithm redistributing objects adjacent subtrees upper non leaf nodes node node node split gets inserted 
note remains unchanged 
shift boundary distances pointers room new leaf node split mui mui max sj sj ss min sj sj ss leaf node containing ss leaf node containing ss 

suppose find nearest ancestor full 
immediate child node ancestor sibling subtree full locate nearest full sibling redistribute objects fu dynamic vp tree indexing nearest neighbor search pair wise distances vb vb node splitted fig 

splitting non leaf node vp splitting boundary vp vantage point 
subtrees fig 

simplicity focus case adjacent subtrees take part redistribution discussion easily generalized cases number subtrees involved 
shall redistribute objects kept th st subtrees 
th st subtree 
num num number objects stored th st subtrees respectively 
calculate average number objects stored subtrees 
th subtree holds objects average th subtree farthest vantage point moved st subtree subtrees eventually hold number objects 
boundary distances pointers involved subtrees updated accordingly 
hand find st subtree holds objects objects closest vantage point moved th subtree 
gives pseudocode description redistribution objects adjacent subtrees 
example shown fig 

full room child split non leaf node fig 

assume th child retrieve objects stored subtree rooted set objects retrieved plus new object 
order objects respect distances vantage point divide groups equal cardinality ss ss subsets order 
number subtrees rooted room new subtree split shift boundary distances pointers way 
note vp tree procedure vp tree construction called construct subtrees sets ss ss respectively mui mui max sj sj ss min sj sj ss vb vb vp result splitting new node created vp tree ss vp tree ss 

root node find ancestor node full 
split root node new nodes insert new data point strategy discussed splitting leaf node non leaf node 
new root node created child nodes 
insertion algorithm described redistribute strategy prefer redistribution node splitting choices allowed 
certainly adopt split strategy case node splitting higher order preference 
shall compare strategies performance study 
delete traverse tree way described insertion case leaf node 
remove object leaf node see node underflows 
task done 
level denote level node ife leaf node level 
minimum number objects stored leaf node minimum number subtrees non leaf node 
denotes minimum number objects stored subtree rooted node defined level define leaf node underflows number objects stores subtree node underflows number objects stored subtree 
leaf node underflows choose scheme 
parent node underflow number leaf nodes total spare room siblings hold objects redistribute objects fu dynamic vp tree indexing nearest neighbor search pair wise distances vc vb nodes merged fig 

merging nodes vm vantage point new vc vb nodes merged siblings 
total spare room hold objects redistribute objects nodes 

locate nearest ancestor underflow 
immediate child node ancestor assume th subtree conditions satisfied perform merge 
note merge involves adjacent subtrees 
describes merge 
show diagram merging nodes fig 
show vantage point vm new old implementation choose old 
case st subtree room hold objects move objects th subtree delete case th subtree room hold objects move objects th subtree delete case total spare room st th subtrees hold objects calculate number objects moved th subtree denoted variable mid fig 

move mid objects th subtree rest st subtree delete conditions satisfied redistribute objects child subtrees 
apply method step insertion 

root node ancestors underflow 
case root node child nodes merge child nodes root deletion data point 
merging strategy 
original root node deleted merged node new root node 
root node leaf node means root node deletion carried root node simply delete data object check adjacency cases outlined step emphasized sure reinsertion involved merge subtrees cause 
similar insert algorithm redistribute merge strategies doing deletes 
table 
access cost splits non leaf nodes redistribute strategy synthetic clustered sample intervals node splitting redistribution insertions occurrence avg 
cost occurrence avg 
cost pages pages table 
access cost splits non leaf nodes split strategy synthetic clustered sample intervals node splitting redistribution insertions occurrence avg 
cost occurrence avg 
cost pages pages procedure merge strategy take place adjacent nodes room allow merge 
hand redistribute strategy merges occur sibling nodes minimum size leaf nodes non leaf nodes 
performance evaluation conducted number experiments demonstrate performance insertion deletion algorithms vp tree 
algorithms implemented unix ultrasparc 
samples data clustered uniform real containing objects 
separate vp tree constructed organize objects samples branching factor tree determined physical clustering strategy described sect 

inserted new objects tree redistribute strategy split strategy 
insertions measured average page accesses required insertions far 
plots results clustered sample 
counted times node splitting redistribution occurred interval insertions 
tables show count associated cost page accesses redistribute split strategies respectively 
note details data samples sect 

fu dynamic vp tree indexing nearest neighbor search pair wise distances page access non leaf leaf retrieve objects stored subtree set objects retrieved number subtrees rooted case mu mu insert st subtree elseif case mu mu insert th subtree elseif case num denote number objects stored th subtree mid num num num num order objects respect distances vantage point divide subsets ss ss order ss mid ss mid mid num mu max ss min ss mu mu ss insert th subtree ss insert st subtree endif child child split redistribute number insertions fig 

insertion synthetic clustered dataset objects focused occurred non leaf nodes cost splitting redistribution leaves comparatively low 
tables show splitting redistribution non leaf nodes occurs manner 
intervals insertions cost entirely due splits leaves 
operations costly curves fig 
strategies show lower page access rates 
intervals splitting redistribution non leaf nodes frequent 
due phenomenon nodes get fuller insertion point insertions trigger non leaf node splitting 
insertions recognize prior insertions moved nodes close saturation 
required fig 

algorithm merging adjacent subtrees costly large number subtrees involved 
redistribution done node splitting necessary 
having done split followed considerable utilization nodes averaged leading slight drop total page accesses insertions 
soon nodes fuller fuller due insertion objects 
trend resembles 
split strategy choosing splitting redistribution creates room nodes saturated 
strategy able avoid frequent 
access cost split strategy lower redistribute 
insertions splits results uniform real data shown figs 
respectively 
see figures strategies exhibit similar trend split strategy better 
omitted brevity 
note big difference performance clustered data uniform real data 
fact due differences fullness nodes trees 
clustered data dimensions leaf node hold data objects maximum branching factor 
tree levels maximum number data objects 
see close number data objects database 
nodes fully packed 
uniform data dimensions leaf node hold data objects maximum branching factor 
tree levels needed fu dynamic vp tree indexing nearest neighbor search pair wise distances page access non leaf leaf split redistribute number insertions page access non leaf leaf split redistribute number insertions synthetic uniform data real dataset fig 
insertion comparison datasets objects page access non leaf leaf merge redistribute number deletions fig 

deletion synthetic clustered dataset objects hold data objects 
tree levels maximum number data objects 
leaf nodes tree full 
real data dimensions leaf node hold data objects maximum branching factor 
tree levels needed hold data objects 
tree levels maximum number data objects 
leaf nodes tree full 
leaf nodes full expect lot redistribution splitting operations seen case clustered dataset 
leaf nodes full cases uniform dataset real dataset insertion trigger redistribution splitting 
page access minimal 
fact carried set experiments clustered data limited maximal page utilization 
resulting number page accesses split merge strategies 
measuring delete performance removed objects vp trees built data samples redistribute strategy strategy 
set maximum number objects contained leaf 
deletions measured average page accesses required objects deleted far 
figures give results clustered uniform real samples 
curves show similar trend 
height trees clustered uniform samples observe deletions samples required corresponding minimum cost deletes merge redistribute strategies 
true deletions real data sample 
words deleting amounts objects caused underflows 
objects removed merges occurred 
consequently average number page accesses increased steadily number deletions shown figures 
reason merge strategy needs fewer page accesses redistribute strategy merging nodes reduces total number nodes turn increases average utilization nodes 
underflows occur frequently case redistribute 
changed minimum fan factor vp tree maximum fan 
repeated similar experiments deletion 
results shown figs 

greater minimum fan introduce restructuring tree help increase page utilization shorten tree 
see average number page accesses increased compared previous set experiments merges occurred 
deletion process quite efficient 
performance evaluation previous sections updates performed top existing database 
investigate case empty database 
incrementally updated database results shown figs 

average page access lower split strategy 
performance slightly worse inserting existing database acceptable number page accesses split case cases considered 
carried set experiments interleaving insertion deletion operations results performance similar pure insertion deletion 
performed set experiments evaluate effect update operations nearest neighbor search 
fu dynamic vp tree indexing nearest neighbor search pair wise distances page access non leaf leaf merge redistribute number deletions page access non leaf leaf merge redistribute number deletions synthetic uniform data real dataset fig 
deletion comparison datasets objects page access non leaf leaf merge redistribute number deletions page access non leaf leaf merge redistribute number deletions synthetic uniform data real dataset fig 
deletion comparison datasets objects minimum fan page access non leaf leaf merge redistribute number deletions fig 

deletion synthetic clustered dataset objects minimum fan maximal page utilization maximal page utilization vp tree node splitting average utilization maximal 
chose amount utilization typical tree indexing 
starting dataset size performed insert delete operations nearest neighbor query 
measured average nearest neighbor query performance terms page accesses insertion deletion 
results clustered data shown fig 

note query performances ing slightly worse reported sect 
began node utilization 
search performance affected updating 
fact certain amount insertion deletion nodes probably better organized initial utilization re organization tree insertion deletion 
reflected drop number page accesses nearest neighbor search 
results show proposed insertion deletion algorithms effective maintaining desired goodness tree structures 
vantage point selection high dimensional space distance calculations data objects expected computationally expensive 
major concern distance indexing minimize number distance computations order aim efficient query processing 
mvp tree example 
mvp tree uses vantage points node 
binary mvp trees vantage point divides space parts second vantage point divides partitions making fanout node binary mvp tree 
seen fig 
node mvp tree viewed levels fu dynamic vp tree indexing nearest neighbor search pair wise distances page access non leaf leaf split redistribute number insertions page access non leaf leaf split redistribute number insertions synthetic uniform data real dataset fig 
starting empty tree comparison inserting datasets objects page access non leaf leaf split redistribute number insertions fig 

starting empty tree comparison inserting synthetic clustered dataset objects vp tree involving fewer vantage points vantage point node mvp tree fewer vantage points compared vp tree 
query processing distance computations query point vantage points 
mvp tree structure reduce certain amount distance computations 
mvp tree approach compared alternatives shall number experiments 
single vantage point level vp trees node tree associated distinct vantage point 
search operation traverses multiple branches different distance computation root branch 
conversely single vantage point partition regions associated nodes level distance computation involved non leaf level 
idea method minimizing distance computations 
root level choose vantage point method depicted fig 
method original vp tree 
choose second vantage point level farthest points fig 
denote different vantage points nodes 
vantage point third vantage point farthest previous vantage points forth 
reason require vantage points far apart ensure relatively effective partitioning dataset 
single vantage point level search operation number distance computations non leaf nodes equivalent number non leaf levels tree assumed small number 
small quantity keep vantage points outside tree keep pointers tree 
allows higher fanout non leaf nodes smaller tree size consequently enhance performance querying 
reuse vantage points main drawback single vantage point level lies deviation original partitioning strategy vp tree 
original method chosen vantage point algorithm fig 
suit associated region certain extent 
attempt maintain partitioning original method choosing vantage points distant chosen vantage point may appropriate nodes corresponding level 
second method tries achieve balance favorable partitioning dataset reduction distance computations 
previous approach nodes level may different vantage points 
vantage point unique 
may fact vantage points reused 
building vp tree fix number maximum number vantage points shall total 
selection vantage points previous approach vantage point selected algorithm fig 
points chosen farthest 
construct pre selected vantage points 
words set pre selected points act candidate vantage points described fig 

increasing number method provides choices vantage points partitioning node 
particular fixed vantage point 
clearly fu dynamic vp tree indexing nearest neighbor search pair wise distances page access non leaf leaf split number insertions page access non leaf leaf merge number deletions insert delete fig 
updating querying comparison datasets objects fig 
node structures binary vp tree binary mvp tree number distance computations non leaf nodes query processing bounded number manageable amount keeping main memory costly keep vantage points outside vp tree previous approach 
reduce storage size tree increase fanout non leaf nodes particular vantage points high dimensional feature vectors 
idea keep small store vantage points outside tree time select distant points dataset determine best vantage point non leaf node 
minimal may offset partitioning dataset 
believe value trial error dataset 
performance evaluation compare methods mvp tree approach implemented disk model mvp tree extended nearest neighbor search algorithm 
original implementation vp tree modified methods proposed 
mvp tree vp tree implemented ultrasparc 
data point leaves mvp tree tree keeps pre computed construction time distances data point vantage points path root leaf node keeps distances effective filtering non qualifying objects search operations 
experiments proved competence technique 
vp trees including original version mvp trees built performance study employed technique 
set extra distances stored data point leaves 
method reuses fixed table 
nearest neighbor search clustered data dimension dataset size number distance computations reuse single mvpt original number vantage points set value reasonably small number 
single vantage point level approach kept vantage points outside vp trees 
performance metrics number distance computations page accesses 
counted number distance computations page accesses required nearest neighbor queries method 
results averaged queries 
sets synthetic clustered data containing different amount data points dimensions 
amounts vary 
details datasets sect 

results tables 
tables column labeled reuse refers method reuses fixed number vantage points single refers method associates single vantage point nonleaf level mvpt refers method adopted original refers original vp tree structure 
note results original vp tree provided 
table reports number distance computations various dataset sizes 
seen table reusing vantage points achieves best results mvp tree approach better single method 
indicates choosing single vantage point nodes level certain negative effects partitioning nodes leads searching turn leaf accesses 
result distance computations query point data points involved 
better performance offers reuse method advantages mvp tree method 
method selecting vantage points straightforward selection process completed tree construction construction easier fu dynamic vp tree indexing nearest neighbor search pair wise distances table 
page accesses search nearest neighbor search clustered data dimension dataset size page accesses reuse single mvpt original time required 
second reduce size tree storing vantage points outside tree total number small experiments 
measured page accesses see methods affect access cost vp tree 
table displays results 
methods general fewer page accesses original vp tree structure 
single method needs number page accesses 
merely trees constructed single vantage point level approach smallest compared 
smaller tree size access cost search operations inevitably lower 
summary methods comparable mvp tree approach terms number distance computations additionally provide better performance page accesses 
performance searching believe reuse vantage points affect goodness tree structure 
may facilitate updating procedures described previous section 
reusing vantage points lead updating pre computed distances data objects reused vantage points 
tackle problem content retrieval multimedia data objects pair wise distances data objects 
approach solve problem infer feature vector data object distances provided preserving possible distances objects 
ran experiments show approach may incur considerable inaccuracies query results 
examine approach distance indexing structure 
approach provides number advantages preprocessing steps involved inferring feature vectors eliminated second difficulty preserving distances avoided third updating handled efficiently lastly method applied data represented multi dimensional vectors 
promising structure approach shown vp tree 
examine important problems variants nearest neighbor search updating 
propose methods vantage point selection reduce number distance computation 
study performance nearest neighbor search algorithm vp tree 
show experiments algorithm scales size data sets value set synthetic clustered data uniform data set real data 
scales dimensionality 
compare result tree tree show vp tree outperforms trees significantly nearest neighbor search synthetic clustered data uniform data real data experiments 
propose solutions update problem vp tree variants 
insertion deletion procedures involve nodes redistribution splitting merging preserve balanced structure vp tree 
alternatives split redistribute insertion alternatives merge redistribute deletion 
study performance methods show overhead quite acceptable show split merge strategy superior redistribute strategy 
propose alternatives vantage point selection making idea reusing vantage points 
basic idea 
design different methods reuse vantage points 
turns results terms reduction distance computation similar different methods 
may investigate methods vantage point selection 
major criticism vp trees region inside median sphere region outside median sphere extremely asymmetric volume grows rapidly radius sphere increases outside sphere tends thin 
consider convex hull enclosing data points search space 
vantage point creates boundary hypersphere surface search space argument holds 
vantage point far search space theoretically infinite distance points boundary created median search space closer hyperplane divides search space regions 
regions symmetric 
may want look vantage points far away center search space 
locate points efficiently method heuristic introduced choosing distant objects 
note space near spherical boundary created median vantage point critical factor performance query evaluation query falls region lead search sides boundary 
method adopted experiments previous standard deviation try ensure small number data points boundary 
look vantage point far center search space current node high standard deviation 
possible standard deviation method automatically introduce vantage points edge search space see fig 
left investigation see true 
investigate improvements vp tree 
enhancements tree introducing redundancy flavor linear search tree 
try capture ideas enhancements apply vp tree 
fu dynamic vp tree indexing nearest neighbor search pair wise distances 
thankful authors providing set real data experimental setup 
authors sending pre published version 
kelvin kam wing chu enhanced version tree implementation chun hing cai implementation enhanced nearest neighbor search tree 
grateful anonymous referees gave thoughtful useful comments enhance 

ainsworth speech recognition machine 
london peter 
beckmann kriegel schneider seeger tree efficient robust access method points rectangles 
proc 
acm sigmod int 
conf 
manage 
data pp may 
berchtold bohm keim kriegel fast parallel similarity search multimedia databases 
proc 
acm sigmod int 
conf 
manage 
data pp 

berchtold keim kriegel tree index structure high dimensional data 
proc 
nd int 
conf 
vldb pp 

berndt clifford finding patterns time series dynamic programming approach 
fayyad shapiro smyth uthurusamy eds advances knowledge discovery data mining cambridge ma aaai mit press 
distance indexing highdimensional metric spaces 
proc 
acm sigmod int 
conf 
manage 
data pp 

brin near neighbor search large metric space proc 
st int 
conf 
vldb pp 
burkhard keller approaches best match file searching 
commun 
acm april 
cheung fu enhanced nearest neighbour search tree 
acm sigmod record september 
chiueh content image indexing 
proc 
th vldb conf pp 
ciaccia patella tree efficient access method similarity search metric 
proc 
rd int 
conf 
vldb pp august 
lomet salzberg hb ii tree modified bb tree supporting concurrency recovery node consolidation 
proc 
st int 
conf 
vldb pp 
lomet salzberg tree multiattribute index supporting concurrency recovery node consolidation 
vldb 
faloutsos barber flickner hafner niblack petkovic equitz efficient effective querying image content 
intell 
inf 
syst july 
friedman bentley finkel algorithm finding best matches logarithmic expected time 
acm trans 
math 
software september 
fu cheung enhancements tree support efficient similarity search high dimensional space 
thesis chinese univ hong kong 
mehrotra index object recognition pictorial data management 
comput 
vision 
raghavan content image retrieval systems 
ieee comput september 
guttman trees dynamic index structure spatial searching 
proc 
acm sigmod int 
conf 
manage 
data pp june 
hafner sawhney equitz flickner niblack efficient color histogram indexing quadratic form distance functions 
ieee trans 
pattern anal 
mach 
intell july 
katayama satoh sr tree index structure high dimensional nearest neighbor queries 
proc 
acm sigmod int 
conf 
manage 
data pp 

korn sidiropoulos faloutsos siegel fast nearest neighbor search medical image databases 
technical report cs tr university maryland march 
kruskal wish multidimensional scaling 
beverly hills ca sage 
lin faloutsos fastmap fast algorithm indexing data mining visualization traditional multimedia datasets 
proc 
acm sigmod pp 

lin jagadish faloutsos tv tree index structure high dimensional data 
vldb october 
lomet salzberg hb tree multiattribute indexing method guaranteed performance 
acm tods december 
niblack barber equitz flickner petkovic yanker faloutsos taubin qbic project querying images content color texture shape 
proc 
spie storage retr 
image video databases pp february 
roussopoulos kelley vincent nearest neighbor queries 
proc 
acm sigmod int 
conf 
manage 
data pp june 
sakoe chiba dynamic programming algorithm optimization spoken word recognition 
waibel lee eds readings speech recognition 
san ca morgan kaufmann 
samet design analysis spatial data structures 
reading ma addison wesley 
sankoff kruskal time warps string edits macromolecules theory practice sequence comparisons 
reading ma addison wesley 
seidl kriegel optimal multi step nearest neighbor search 
proc 
acm sigmod int 
conf 
manage 
data pp 
sellis roussopoulos faloutsos tree dynamic index multidimensional objects 
proc 
th int 
conf 
vldb pp 
theodoridis sellis model prediction tree performance 
proc 
acm princ 
database syst pods pp 
thomas kriegel efficient user adaptable similarity search large multimedia databases 
proc 
th int 
conf 
vldb pp 

uhlmann satisfying general proximity similarity queries metric trees 
inf 
process 
lett november 
white jain algorithms strategies similarity retrieval 
technical report vcl university california san diego july 
white jain similarity indexing ss tree 
proc 
th ieee int 
conf 
data engin pp february 
yianilos data structures algorithms nearest neighbor search general metric spaces 
proc 
rd annual acm siam symp 
discrete algorithms pp 
