program analysis specialization programming language ph thesis lars ole andersen diku university copenhagen dk copenhagen denmark email lars diku dk may software engineers faced dilemma 
want write general programs flexible easy maintain 
hand generality price efficiency 
specialized program solving particular problem significantly faster general program 
development specialized software time consuming exceed production today programmers 
new techniques required solve called software crisis 
partial evaluation program specialization technique reconciles benefits generality efficiency 
thesis presents automatic partial evaluator ansi programming language 
content thesis analysis transformation programs 
develop analyses support transformation program generating extension 
generating extension program produces specialized programs executed parts input 
thesis contains main results 
develop generating extension transformation describe specialization various parts including pointers structures 
develop constraint inter procedural pointer binding time analysis 
analyses specified non standard type inference systems implemented constraint solving 
develop side effect analysis 
analyses developed classical monotone data flow analysis framework 
intriguing similarities constraint analysis observed 
investigate separate incremental program analysis transformation 
realistic programs structured modules break inter procedural analyses need global information functions 
prove partial evaluation accomplish linear speedup develop automatic speedup analysis 
study stronger transformation technique driving initiate development generating super extensions 
developments thesis supported implementation 
chapters empirical results 
preface thesis submitted fulfillment requirements ph degree computer science diku department computer science university copenhagen 
reports done february may 
supervisor prof neil jones diku external examiner dr peter lee carnegie mellon university 
thesis consists eleven chapters serves holds 
chapters published papers extensively revised completely rewritten 
individual chapters self contained chapter introduces notations extensively rest thesis 
overview thesis section 
am grateful advisor neil jones done academic career 
neil probably written thesis provided inspirations comments insight aware 
neil founded programming language group diku continues enable contacts great people world 
group diku place 
peter lee interest useful feedback comments discussions stay diku 
special due peter holst andersen 
experimental results reproduced thesis spent hours correcting embarrassing bugs code 
olivier danvy deserves enthusiasm useful feedback received wrote chapter partial evaluation book 
comments certainly improved book chapter influenced presentation thesis view computer science 
robert gl ck continued interest useful discussions partial evaluation optimization 
furthermore carsten gomard speedup analysis written 
warm go members programming language group ii visitors providing stimulating enjoyable serious research environment 
active members ready provide comments share ideas interests created contacts researcher universities 
mornings clearly demonstrated group just collection individual persons 
undergraduate graduate days especially jens 
fun written project reminded world outside diku 
lars lassen luckily dragged away boring uncountable number times 
nice come suggest cup coffee beer game billiard 
parents rest family done research supported danish research council snf research project dart ec esprit bra diku 
iii contents preface ii ii software engineering 
specification deliverable 
problem excess generality versus efficiency 
executable specifications 
generality programs 
computation stages 
specialization applied software development 
program specialization partial evaluation 
programs semantics representations 
futamura projections 
generating extensions 
program analysis 
approximation safety 
type analysis specifications 
program analysis techniques 
contributions 
overview mix 
main results 
differs 

overview thesis 
programming language 
design motivations 
conforming strictly conforming programs 
user feedback 
program representation 
notation terminology 
overview chapter 
iv syntax static semantics 
syntax 
static semantics 

representation programs 
program representation 
static call graph 
separation types 
dynamic semantics 
notations conventions 
semantics programs 
semantics functions 
semantics statements 
semantics expressions 
semantics declarations 
memory management 
requirements 
related 
summary 
generating extensions 
mix equation revisited 
generating extensions specialization 
previous 
overview chapter 
case study generating string matcher 
string matcher strstr 
binding time separation 
generating extension strstr gen 
specializing strstr 
types operators expressions 
constants 
data types declarations 
operators 
type conversions 
assignment operators 
conditional expressions 
precedence order evaluation 
expression statements 
control flow 
pending loop 

switch 
loops 
goto labels 
functions program structure 
basics function specialization 
functions side effects 
recursion unfolding 
external variables 
static variables 
register variable 
initialization 
pointers arrays 
pointers addresses 
pointers function arguments 
pointers arrays 
address arithmetic 
character pointers functions 
pointer arrays pointers pointers multi dimensional arrays 
pointers functions 
structures 
basics structures 
structures functions 
pointers structures 
self referential structures 
runtime allocation structures 
replacing dynamic allocation static allocation 
unions 
bit fields 
input output 
standard input output 
case study formatted output printf 
variable length argument lists 
file access 
error handling 
miscellaneous functions 
correctness matters 
memory management 
basic requirements 
storage model 
state descriptions 
object copy functions 
predicate 
improved sharing code 
heap allocated memory 
code generation 
vi algebraic reductions 
deciding dynamic tests 
domain re sharing 
domain specialization 
domain re 
live variables domain re 
specialization sharing unfolding 
sharing specialization 
unfolding strategy 
imperfect termination 
related 
partial evaluation 
partial evaluation imperative languages 
generating extension generators 
transformations imperative languages 



pointer analysis 
harder analyze 
points analysis 
set pointer analysis 
overview chapter 
pointer analysis accuracy efficiency 
flow insensitive versus flow sensitive analysis 
poor man program point analysis 
intra inter procedural analysis 
inter procedural information 
may 
pointer analysis 
structures unions 
implementation defined features 
dereferencing unknown pointers 
separate translation units 
safe pointer abstractions 
locations 
pointer abstraction 
safe pointer abstraction 
pointer analysis specification 
intra procedural pointer analysis 
pointer types constraint systems 
constraint generation 
vii completeness soundness 
inter procedural pointer analysis 
separating function contexts 
context separation static call graphs 
constraints variant vectors 
inter procedural constraint generation 
improved naming convention 
constraint solving 
rewrite rules 
minimal solutions 
algorithm aspects 
representation 
iterative constraint solving 
correctness 
complexity 
experiments 
program point pointer analysis 
program point sequence point 
program point constraint program analysis 
heintze set analysis fails 
related 
alias analysis 
points analysis 
approximation data structures 



binding time analysis 
binding times 
efficient binding time analysis 
related 

overview chapter 
separating binding times 
externally defined identifiers 
pure functions 
function specialization 
unions common initial members 
pointers side effects 
run time memory allocation 
implementation defined behaviour 
pointers casts arithmetic 
viii specifying binding times 
binding time types 
binding time classifications objects 
lift relation 
divisions type environment 
level binding time annotation 
annotated definitions 
annotated expressions 
annotated statements 
annotated functions 
annotated programs 
binding time inference 
constraints constraint systems 
binding time attributes annotations 
capturing binding times constraints 
normal form 
solving constraints 
doing binding time analysis 
division annotated program 
extensions 
efficient constraint normalization algorithm 
representation 
normalization algorithm 
complexity 
correctness 
improvements 
polyvariant binding time analysis 
polyvariant constraint analysis 
generation extensions 
examples 
related 
bta interpretation 
bta type inference constraint solving 
polyvariant bta 

constraint solving tracing error messages 
granularity binding times 
struct variants 
analysis heap allocated objects 

ix data flow analysis 
data flow analysis framework 
solutions methods 
inter procedural program analysis 
procedure cloning 
taming pointers 
overview chapter 
side effect analysis 
may side effect 
side effects conditional side effects 
side effect information 
control dependence 
conditional may side effect analysis 
doing side effect analysis 
analysis 
objects 
liveness 
generating extensions 
analysis functions 
doing analysis 
enhancement 
related 
side effect analysis 
live variable analysis 
procedure cloning specialization 



separate program analysis specialization 
partial evaluation modules 
modules generating extensions 
pragmatics 
analysis steps 
separate specialization 
overview chapter 
problem modules 
external identifiers 
exported data structures functions 
pure external functions 
separate binding time analysis 
constraint binding time analysis revisited 
inter modular binding time information 
binding time signatures 
doing inter modular binding time analysis 
binding times 
correctness separate analysis 
incremental binding time analysis 
incremental analysis 
basic idea 
components incremental constraint solver 
correctness incremental binding time analysis 
doing incremental binding time analysis 
separate specialization 
motivation 
conflicts global transformations modules 
separate specialization 
example specializing library functions 
separate incremental data flow analysis 
separate pointer analysis 
related 



speedup theory analysis 
prospective speedups 
predicting speedups 
reservation 
overview chapter 
partial evaluation linear speedups 
measuring execution times 
linear speedup 
examples 
super linear speedup 
predicting speedups 
safety speedup intervals 
simple loops relative speedup 
doing speedup analysis 
experiments 
limitations improvements 
variations speedup analysis 
predicting speedups generating extensions 
accounting static values 
speedup analysis generating extensions 
xi related 
speedup partial evaluation 
speedup analysis versus complexity analysis 
properties optimized programs 

costs instructions 
estimation code size 
unsafe optimizations super linear speedup 

partial evaluation practice mix partial evaluator 
overview 
mix practice 
speed versus size 
data dependent algorithms 
case study binary search 
specialization optimization 
enabling disabling optimizations 
order optimization 
observations 
experiments 
lexical analysis 
scientific computing 
ray tracing 
ecological modelling 


summary 
improvements driving 
catalogue transformation techniques 
example genius transformation 
overview chapter 
case study generation kmp matcher 
naive pattern matcher 
positive context propagation 
kmp matcher 
generating super extensions 
online decisions 
representation unknown values 
theorem proving 
context propagation 
driving 
xii related 




program specialization transformation 
pointer analysis 
binding time analysis 
data flow analysis 
separate analysis 
speedup analysis 
experiments 
driving 
final remarks 
bibliography danish summary xiii chapter need computer software constantly increasing 
prices computers fall new areas suitable automatic data processing emerge 
today bottleneck production delivery hardware specification implementation debugging programs 
tools aiming automating software development needed called software crisis 
thesis presents promising tool automatic partial evaluator program specializer ansi programming language 
particular describe generating extension transformation develop program analyses guide transformation 
software engineering despite rapid development computer technology software engineering ingenious software engineers 
effort put development prototypes implementation deliverables debugging demand programs exceed capacity current software production 
section sketch contemporary development software deficiencies 
explain automatic program specialization reconcile benefits general solutions efficient specialized programs enabling fast computer software production maintenance 
specification deliverable development computer system usually undertakes phases specification prototyping implementation debugging deliverable steps may iterated 
initial specification problem prototype implementation created 
objective real testing requirement study system potential performances features 
prototypes implemented high level languages lisp offer rich library auxiliary functions programmers burdened implementation primitive data structures lists 
prototyping stage completed prototype normally thrown away system re implemented language efficiency major concern 
currently systems implemented pervasive programing language due availability platforms efficiency support low level operations 
vast amount invested debugging run deliverables effort presumably put implementation prototype version 
due primitive basic operations consider example differences list manipulation lisp errors prototype creep debugging order magnitude harder time consuming 
ideally implementation rigorously showed correct delivered practice impossible task case continually changing programs 
project manager may estimate errors remain state correct 
obviously preferable base final implementations prototype system having start scratch errors introduced final implementation probably fixed prototype version prototypes amenable changes allow code re prototypes cleanly structured easier maintain 
reason prototype generality kept efficiency 
problem excess generality versus efficiency important property prototype possibility modify system accommodate new requirements specifications 
fulfill prototypes parameterized specifications 
example data base program number lines output specification parameter hard coded constant program 
customer wants experiment different amounts output deciding right number easily done 
number specified places system insight hours needed change 
unfortunately passing testing specification constants slows program execution normally removed final implementation 
software developer point view desirable parameterization permanent part system 
software engineers know users reverse decisions want systems changed 
significant part money spent software development software maintenance 
exceptions see speed weighted generality 
unacceptably long response times may result superfluous generality faster computers answer complexity problems grows faster hitherto subjects qualified parameterization hardware technology 
executable specifications dominant professional software engineering 
admittedly contrived example illustrates principles 
printf output values format int printf char format char values int format format format putc format switch format case putc break case puts values break default return eof return mini version standard library function printf executable specifications compelling idea automatic transformation specifications efficient specialized programs objective faster software development reduced software maintaining costs 
possible specification executable sense 
thesis concerned transformation high level specifications low level code optimization target code produced transformations 
lisp specification language 
believe programmers agree software development lisp productive error prone assembly code 
automatic compilation lisp say solve efficiency problem 
traditional compilation techniques strong eliminate excessive generality 
today methods translated program carry specification perform testing runtime 
furthermore automatic transformation high level languages low level languages tends employ general compilation schemes statements data structures 
example separate statically allocated variables automatically produced programs heap allocated objects 
identify excessive generality obstacle efficiency 
efficient corresponding lisp program transformed program may order magnitude slower hand piece software 
needed way transforming general program specialized program eliminates specification testing 
generality programs excessive generality coupled automatic program transformation 
existing programs 
consider depicts mini version library function printf 
body function contains loop traverses format string 
substitute favorite programming language sml ada haskell 
printf spec print values int printf spec char values putc putc puts values return specialized version printf control codes string different actions performed 
time spent determining output normally referred interpretation overhead 
printf function general produce kinds output specification format 
function prime candidate inclusion library code re 
excess generality seldom needed 
typical program calls printf form printf format constant string 
program fully specifies action printf compile time interpretation overhead wasted 
general call profitably replaced call specialized version printf illustrated 
specialized version specification coded control structure 
net effect interpretation overhead gone away 
example generalizes easily differential equation solver invoked times equation system different start conditions program examining looks pattern thousands samples ray tracer repeatedly applied picture different view points spread sheet program run tax base specification taxes change interpreter executed times subject program different input 
restatement known fact compilation running low level target program normally faster interpretation high level program 
reason analogous examples interpreter performs great amount run time book keeping removed compilation 
existing program may benefit form specialization 
broadly purely efficiency criteria specialization may advantageous parameters change frequently 
example program contains calls format string interpretation overhead executed twice general version specialized version 
hand programmers write specialized version printf general version 
reason obvious existing version printf known correct introduce bugs convenient 
analogy software development general prototypes clear 
single prototype wish derive specialized efficient implementations 
prototype included library repeatedly 
comp int target computation stages computation stages programs contain computations separated stages notable example interpreters 
interpreter program int language takes input subject program input returns result execution applied machine 
notion precise section 
compiler comp program input takes yields target program language 
run target program gives result applied machine 
ways execution program illustrated 
left result produced step right stages 
computations carried compiler called compile time runtime 
interpreter mixes times run interpreter performs compile time computations syntax analysis run time calculations multiplication integers 
printf function compile time computations include scanning format string calls putc puts constitute run time part 
separation stages enables performance gain 
interested interpreters broadly general programs generality causes loss performance 
number arguments general programs easier write specialized programs 
general programs support code re 
programs modified time contexts change input specification 
general programs uniform structure manageable maintain show correct 
furthermore program maintained opposed dedicated specialized versions 
known facts computer science years area syntax analysis generality efficiency successfully reconciled 
reason programmers ignore efficiency aspects efficiency major concern writing specialized program particular task 
implementation parser basis specification bnf grammar tedious time consuming trivial job 
alternative employ general parser example earley algorithm takes input grammar stream tokens 
witnessed practical experiments yields excessively slow parsers commercial software 
order produce efficient parsers bnf specifications parser generators yacc developed 
yacc produced parsers easy generate known adhere specification 
generalization years compiler generators convert language specifications compilers 
fruitful way specifying language means operational semantics 
put machine readable form operational semantics interpreter 
thesis contributes direction 
approach goes yacc 
yacc dedicated problem parser generation goal automatic generation program generators 
example earley algorithm generate parser generator interpreter generate compiler 
specialization applied software development today professional software development large extent dominated software engineers 
solve problem specific program constructed scratch 
products software companies undergone revolution little progress actual software development happened 
consider example area data base programs 
years ago specialized data base application developed hand 
general data base program customized handle different purposes 
highly general data base programs technology exhibit worldwide case today 
extra generality acceptably due larger computers problems require fast implementations rule excess generality 
principle extended software engineering process 
imagine software engineering highly parameterized general programs automatically turned efficient implementations means program specialization 
gives best worlds general program maintained shown correct 
new specialized program complying changed specifications constructed automatically 
correctness comes free 
code re urged simply changing parameters general program unrelated problems may solvable program 
programmer concerned efficiency matters 
thesis develops software tool automatic program specializer programming language 
small companies prefer slow cheap data base data base 
program specialization partial evaluation order conduct analysis transformation program clear specification program semantics needed 
section define extensional meaning program run 
aim analysis transformation normally insufficient intensional specification assigning meaning various language constructs required 
programs semantics representations simplify presentation regard program meaning inputoutput function 
program programming language data domain denotes meaning function 
programs may fail terminate lifted domain 
case programming language complying implementation standard iso 
program input write execution yields value example array containing string hello printf hello consider function program 
interpreter program int takes input representation program representation input yields result meaning function specifies int pgm val val iff val denotes representation input suitable data structure similarly pgm compiler comp specified follows comp pgm target pgm target iff programs input equation specifies compiler adhere language standard compiler shall produce target programs complies standard iso 
admittedly hard achieve case languages involved dynamic semantics 
compiler taken standard program ansi sense gcc ansi wall gives warnings errors 
futamura projections program inputs 
residual version ps respect program ps iff program ps residual specialized version respect known input input called unknown input 
partial evaluator mix program specializes programs known input 
captured mix equation jones jones 
stolen announcement parser generator claimed produce strict ansi 
definition program input 
partial evaluator mix fulfills mix pgm val ps pgm ps obviously mix operate notions compile time run time 
constructs solely depend known input called static constructs may depend unknown input called dynamic 
classification constructs static dynamic done actual specialization binding time analysis specialization 
case system called line line 
consider line specialization thesis reason apparent 
suppose cmix partial evaluator language 
cmix printf pgm val printf spec pgm program printf spec listed previous section 
practical purposes weaken definition allow mix loop 
implicitly assume mix terminates problem practice 
partial evaluator mix written language accepts possible self apply 
effect stated futamura projections jones 
theorem int interpreter program 
holds mix int pgm val target pgm mix mix pgm int comp pgm mix mix pgm mix cogen pgm comp compiler cogen compiler generator 
projections straightforward verify mix equation definitions target programs compilers 
compiler generator cogen program interpreter yields compiler cogen int comp pgm cf 
mix equation second futamura projection 
suppose apply cogen interpreter printf cogen printf printf gen pgm result function called printf gen 
run static input extension generate specialized program printf spec 
statement completely true 
investigate mix line strategy decisions taken specialization 
generating extensions generating extension program generator executed produces program 
definition program input 
generating extension gen yields program ps executed gen ps pgm ps specialized version respect generating extension generator program transforms programs generating extensions 
definition generating extension generator gegen program program gegen pgm gen pgm gen generating extension compiler generator cogen produced double self application mix generating extension generator 
notice difference signature cogen gen pgm gegen operates representation program cogen inputs val encoding program 
reason cogen inherits representation employed mix generated 
program analysis program transformation meaning preserving optimized program computes result original program 
transformations purely syntactical criteria limited practice information construct behaviour result needed 
aim program analysis gather dynamic properties programs run computer 
typical properties interest include objects may pointer point 
pointer analysis chapter variable bound compile time run time 
binding time analysis chapter efficiency gained specializing program 
speedup analysis chapter variable function 
analysis chapter 
information revealed program analysis employed guide transformations optimizations 
compiler may live variable information decide ether preserve value register partial evaluator may binding time information decide evaluate reduce expression output analysis may employed program analyses 
example languages pointers approximation pointer usage critical analyses 
lack pointer information necessitates worst case assumptions degrade accuracy 
approximation safety program analysis normally applied program input available obviously renders analysis undecidable 
complexity theory known rice theorem trivial properties program undecidable 
practice desire analysis compute information valid possible inputs 
means example branches statement taken account 
classical data flow analysis known control flow assumption control paths program executable 
course clever analysis may recognize branch program fragment executed improves analysis precision programs general 
control flow assumption properties may undecidable example alias analysis presence multi level pointers see chapter 
implies analysis inevitably approximate 
fails detect certain property output safe answer 
notion safety intimately connected aim analysis consumer inferred information 
example case live variable analysis safe classify live variables pointer may refer assignment 
case constant propagation analysis erroneous regard objects constant 
decided properties analysis supposed approximate ideally proved correct respect language semantics 
type analysis specifications semantics normally solely concerned program input output behavior 
opposed program analysis typically collects informations program interior computation 
example set locations pointer may assume 
necessitates instrumented semantics collects desired information characterizes input output function 
example instrumented collecting semantics may accumulate values variable get bound 
analysis seen decidable abstraction instrumented semantics 
thesis specify analyses non standard type systems basis operational semantics properties programs seen types expressions statements functions 
consider example constant propagation analysis 
aim analysis determine variables possess constant value 
precisely case part store representing variable constant value 
dynamic operational semantics small language constants variables binary plus inference rules follows case point information needed 
simplicity find variables constant values program 
store 
constant evaluates value variable determined store value binary plus sum subexpressions 
perform constant propagation analysis value domain domain denotes means constant value denotes non constant 
operator defined 
analysis specified follows 
fixed constant propagation map interpretation constant map safe fulfills rules expression consider property constant type defined operator types 
example type view program analysis admits easy comparison language dynamic semantics specifications check safety correctness 
program analysis techniques program analysis techniques roughly grouped follows 
classical data flow analysis including iterative hecht ullman elimination interval ryder methods 
see marlow ryder survey marlowe ryder 
interpretation including forward cousot cousot backward hughes analysis 
see jones nielson survey jones nielson 
non standard type inference including algorithm methods gomard constraint techniques henglein heintze 
classical data flow analyses data flow equation solving 
iterative methods find solution propagation approximative solutions fixed point reached 
interval methods reduce equation system solution directly computed 
data flow equations typically collected syntax directed traversal program syntax tree 
example live variable analysis aho gen kill equations produced assignments 
classical data flow analysis criticized ad hoc semantically 
author opinion simply classical data flow analyses formulated framework denotational operational semantics founded 
classical data flow analyses aimed languages fortran obvious semantics pointers 
overlooked large part literature concerned algorithmic aspects contrary literature interpretation mainly concerned specification 
interpretation usually formulated denotational semantics style suitable imperative languages 
recipe described follows standard semantics instrumented compute desired information 
semantics abstracted decidable approximate semantics 
result executable specification 
practice interpretations implemented simple naive fixedpoint techniques clever algorithms developed 
common belief interpretation slow realistic languages 
reason analyses traverse program times compute fixed point 
ways reduce runtime naive interpretations proposed borrowing techniques classical data flow analysis efficient fixed point algorithms 
expression type abstraction set values may evaluate 
seen data flow problems characterized properties expressions specified means non standard type systems 
non standard types inferred standard techniques efficient methods constraint solving 
non standard type analysis consists separated parts specification implementation 
eases correctness matters specification concerned efficiency 
hand type specification gives uniform formulation computational problem allows efficient algorithms developed 
example point problem solved chapter reduced solving system inclusion constraints 
thesis type analyses dominating particular constraintbased analyses 
gives surprisingly simple framework 
furthermore relation specification implementation clearly separated opposed classically formulated data flow problems 
shall consider data flow problems formulate framework classical monotone data flow analysis firm semantical foundation 
side effect observe classical data flow analyses constraint analyses similarities 
contributions thesis continues automatic analysis specialization realistic imperative languages particular main result mix automatic partial evaluator ansi programming language 
overview mix mix partial evaluator ansi programming language 
phases illustrated 
subject program parsed intermediate representation built 
type checking annotation carried call graph table built 
program analyzed 
pointer analysis approximates usage pointers side effect analysis employs pointer information detect possible side effects analysis aims finding useless variables binding time analysis computes binding time expressions speedup analysis estimates prospective speedup 
generating extension generator transforms binding time annotated program generating extension 
generating extension linked library implements common routines yield executable 
chapters thesis describe phases detail 
main results thesis contributes results 
develop describe transformation binding time analyzed ansi program generating extension including methods specialization programs featuring pointers dynamic memory allocation structs function pointers 
develop inter procedural pointer analysis constraint solving 
develop constraint binding time analysis runs linear time 
develop side effect analysis formulated classical monotone data flow problems 
investigate potential speedup partial evaluation devise analysis estimate speedup obtainable specialization 
develop separate incremental binding time analysis describe separate program specialization 
consider separate analysis broadly 
study stronger transformations specialization techniques partial evaluation foremost driving 
provide experimental result demonstrates usefulness mix 
implementation transformations analyses supports thesis 
noted time writing implemented integrated analyses listed 
see chapter 
program mix parse type checking annotation transformation analysis pointer analysis analysis transformation call graph analysis side effect analysis binding time analysis speedup analysis generating extension generator generating extension overview mix gen mix lib differs feedback results reported thesis differ respects 
underlying design decisions efficiency reality usability 
consider turn 
efficiency 
literature contains examples program analyses need nights analyze line program 
opinion analyses nearly useless practice 
practical point view unacceptable pointer analysis needs hour analyze line program 
implies concerned efficiency accuracy 
extra precision pay inclined choose efficiency 
furthermore concerned storage usage 
analyses simply generate information feasible practice 
reality 
main purpose demonstrate semantically analysis transformation realistic languages possible transfer academic results realistic context 
implies unwilling give analysis instance function pointers casts simplify matters allow precise approximations cases 
consider small claim results scale 
experience syntactic sugaring just matter syntax may importance complex expressions allowed 
example partial evaluation feedback user desirable 
feedback form incomprehensible intermediate language little help 
usability 
information inferred programs 
information little difference transformations carried optimizations possible 
author opinion important program analyses transformations tested realistic programs 
implies see accurate analysis better coarse fast analysis trade efficiency precision 

argued see suitable language automatic analysis transformation 
open ended semantics supports machinedependent features conflicts semantic preserving transformation extent 
hand pervasively languages programs computer community years 
languages long term replace suspect going take 
commercial software companies certainly willing give simply lambda calculus easier analyze 
efficient compilers exist old technology 
example gnu compiler perform inter procedural analysis 
thesis consider separate analysis describe practical ways realize truly separate inter procedural analysis 
popular target language high level language compilers 
reasons continued research analysis optimization programs 
reservation analysis infer strong information program may worthwhile 
overview thesis remainder thesis organized follows 
chapters concern transformation programs generating extension 
chapter develop generating extension transformation ansi language 
describe specialization various language constructs supporting transformations 
briefly describe generating extension library implementing routines extensions 
chapter develops inter procedural constraint point analysis object pointer type approximates set locations object may contain 
analysis analyses avoid worst case assumptions due assignments pointers 
chapter efficient constraint binding time analysis developed 
analysis runs linear time fast practice 
extension yields polyvariant binding time classification 
chapter contains analyses 
side effect analysis identifies conditional unconditional side effects 
conditional side effects control dependence analysis 
analysis computes approximation objects function 
analyses formulated monotone data flow problems 
chapter considers speedup partial evaluation theoretical analytical point view 
prove partial evaluation give linear speedup develop simple speedup analysis estimate prospective relative speedup 
separate incremental analysis subject chapter 
trivial programs separated modules render inter procedural analysis hard 
develop detail separate constraint binding time analysis 
describe incremental constraint solver accommodates incremental binding time analysis 
chapter provides experimental result produces mix assesses utility system 
chapter consider stronger transformations broadly particular driving 
initial steps automation driving taken 
chapter holds describes areas 
appendix contains danish summary 
chapter programming language programming language pervasive computer science commercial software engineering 
language designed seventies originates unix operating system environment exists platforms 
efficient imperative language developed programmer underlying design decision programmer knows doing language prevent accomplishing 
international standard organization published iso standard adopted ansi standard ansi supports recursive functions multi level pointers multi dimensional arrays userdefined structures unions address operator run time memory allocation function pointers 
macro substitution separate compilation integrated parts language 
small flexible set statements rich variety operators 
low high level applications programmed user defined structures enable convenient data abstraction means bit fields port device matched 
low level manipulation pointers bytes allows efficient implementation data structures machine dependent features enable development operating systems architecture close applications 
renders program analysis optimization hard major reason language success 
popular target language high level language compilers efficient automatic optimization continues importance 
describe syntax additional static semantic rules assures uniform representation 
specify dynamic semantics means structural operational semantics comply standard 
high level transformation systems comprehensible feedback desirable 
describe representation programs accommodates feedback suitable automatic program analysis transformation 
particular consider separation struct union definitions convenient doing type analysis 
furthermore define give algorithm computing program static call graph 
static call graph approximates invocation functions run time contextsensitive program analyses 
programming language designed implemented unix operating system dennis ritchie seventies 
efficient imperative language offering features recursive functions multi level pointers run time memory allocation user defined types function pointers small flexible set statements 
preprocessor responsible macro substitution separate compilation integrated 
currently perceived languages software engineering exists nearly platforms 
signs indicated continue dominant professional software engineering years 
language ancestor increasingly popular object oriented language 
design motivations reasons language success terse powerful flexible efficient 
example functions read write built language 
communication environment provided set standard library functions 
consists parts kernel language standard library 
library defines functions standard input output printf mathematical functions pow string manipulations strcmp useful operations 
externally defined functions declared standard header files 
language kernel language interchangeably explicitly specified 
language originally designed operating system implementation convenient data abstraction mechanism enables writing low high level applications 
data abstraction supported user defined types 
means members structs laid match addresses bits hardware ports 
low level operations bit shifts logical convenient operations part language 
casts pointers void pointers allows writing generic functions 
spirit language concisely captured motivations standard stated rationale ansi programming language trust programmer 
don prevent programmer doing needs done 
keep language small simple 
provide way operation 
fast guaranteed portable 
example strongly typed integers converted pointers opening illegal 
years experience demonstrated usefulness abandoned standard 
standard specifies conversions explicit 
programmer knows doing shall allowed 
language deficiencies due lack strong typing prevent type errors run time pohl 
conforming strictly conforming programs substantial milestone language history international standard organization iso published iso standard document iso 
standard modeled manual published programming language kernighan ritchie tried preserve spirit language 
standard adopted american standard ansi 
program comply standard ways conforming strictly conforming 
strictly conforming program shall features described standard may produce result depends undefined unspecified implementation defined behavior 
conforming program may rely features available conforming implementation 
example suppose struct structure consider code 
extern void malloc size struct struct malloc sizeof struct code conforming strictly conforming struct pointer stricter alignment requirement void pointer sizeof operator 
example intension strictly conforming programs independent architectural details henceforth highly portable 
hand implementation instance operating systems compilers require implementation dependent operations part standard 
example result cast pointer integral value vice versa implementation defined 
cast pointer pointer alignment requirement void pointer strictly conforming 
evaluation order function arguments unspecified 
strictly conforming program may rely particular evaluation order 
example thesis concerned implementation architecture transparent analysis transformation 
program analyses shall take peculiarities implementation account transformations shall perform optimization conforming constructs replace sizeof int 
restriction strictly conforming programs limited realistic purposes 
trivial programs separated modules shall furthermore restrict attention monolithic programs 
general non strictly conforming parts program shall optimized suspended run time 
analyses shall instrumented respect particular implementation 
user feedback program specialization partial evaluation fully automated high level program optimization technique principle requires user guidance inspections 
program specialization ambitious software engineering process goals go far traditional program optimization 
goals met user may want know went wrong 
situation similar type checking 
program type checks compiler needs output information 
case type errors informative error messages ideally indicate reason toe error desirable 
possible feedback includes output clearly shows feasible apply specialization bindingtime annotations profile informations 
information describes gains prospective speedups estimates residual program size 
general feedback program dynamic properties side effects call information 
source dynamic suspended computations 
naturally information connected subject program 
feedback form intermediate machine constructed representations useful 
renders probably address code aho useless user feedback 
program representation previous intermediate program representations complex constructs transformed simpler ones 
example assignment simplified statements 
option program related feedback possible 
furthermore transformation may semantically wrong 
example simplification eliminates sequence point demands evaluation 
thesis program representation closely resembling structure subject program 
advantages include transformation simpler intermediate form static single assignment form tends increase size subject program 
avoid 
user feedback concisely essentially user sees subject program 
simplification constructs may throw away information 
example may useful information points array apparent equivalent 
disadvantages control flow information cases consider 
mix system user receives graphical feedback form annotated programs 
instance binding time separation program illustrated dynamic constructs bold face 
notation terminology thesis notation terminology defined standard secondly community 
variable declaration allocates storage called definition 
declaration simply brings name scope called declaration 
example int definition extern int declaration 
going term dynamic possibly unknown term run time memory allocation opposed dynamic memory allocation 
program usually consists translation units 
program translation units contains main function 
identifiers defined modules considered external 
function variable external depends solely existence definition file 
definition exists function variable non external 
overview chapter chapter structured follows 
section describe syntax section concerned representation programs defines static call graphs 
section provides operational semantics section mentions related section concludes 
syntax static semantics section presents syntax syntax deliberately formed resemble concrete contain simplifications 
example type definitions appear top translation unit variable function definitions mixed initializers provided part definition 
syntax syntax figures 
defines syntax type definitions global variable function definitions defines statements expressions 
translation unit consists parts 
come type definitions followed declaration definition global variables external functions lastly come function definitions 
translation unit roughly corresponds file 
const constants constants id id identifiers label label labels op op operators translation unit type def decl fun def module type def struct id decl type definition union id decl enum id enum decl decl decl exp struct declarator enum id id exp enumerator declarator decl storage spec id type spec declaration storage spec extern register storage specifier type spec void char int double 
base type struct id union id struct type enum id enum type type spec pointer type const type spec array type declaration type spec function type fun def type spec id declaration body function definition body decl stmt function body syntax part type definition introduce struct union enumeration type 
type names introduced means typedef syntax henceforth syntax 
similar remarks apply forward declarations 
syntax supports bit fields enumeration constants specific values 
enumeration constants large extent act constants regard named constants 
struct union definitions nested 
declaration parts list storage specifiers identifier list type specifiers 
purposes storage specifier extern suffices 
specifiers auto static register thesis added convenient 
type specifier list specifiers base struct enumeration specifier 
type specifier shall read left right 
readability surround type specifiers brackets write concrete type int int example examples show connection concrete declarations corresponding syntax notations 
revision standard eliminate implicit type coercion integers requiring strong typing enumeration types 
course implementation correctly represents storage specifiers ignored 
rest thesis struct mean struct union 
int int int int double double char fp int fp int char type specifier empty 
definition specifies pointer function integer argument returning pointer char 
example declaration extern int called declarator extern storage specifier int type 
type qualifiers const volatile thesis left syntax 
qualifiers introduced tags base pointer type specifiers desired 
function definition consists type identifier parameter list function body 
function body list local automatic variable definitions sequence statements 
statement empty statement expression statement conditional statement loop statements labeled statement jump function return block 
notice blocks support local definitions 
simplicity automatic variables assumed function scope 
assume break continue replaced goto control flow explicit 
notice explicit control flow easily added break continue statements solely notational purposes 
expression constant variable struct indexing pointer dereference application unary binary operator function call assignment preand post increment operators 
increment example operator 
special call alloc denotes run time memory allocation 
type name alloc returns pointer object suitable representation objects 
special form motivated chapter 
assume alloc inserted user 
ease presentation unary operators pointer dereference address operator treated special forms 
differentiate types call expressions calls extern functions pow direct calls module defined functions foo calls function pointers fp 
indicate calls category ef direct calls user defined functions indirect calls 
kinds differentiated purely syntactically notice function pointers may point defined external functions 
static semantics static semantics defined standard iso 
impose additional requirements sake uniformity 
notice definitions declarations 
main reason restriction chapter 
stmt empty statement exp expression exp stmt stmt switch exp stmt multi case exp stmt case entry default stmt default entry exp stmt loop stmt exp loop exp exp exp stmt loop label stmt label goto label jump break continue loop break continue return return exp function return stmt block exp const constant id variable exp id struct index exp pointer dereference exp exp array index exp address operator op exp unary operator exp op exp binary operator alloc type runtime allocation id exp extern function call id exp user function call exp exp indirect call exp exp pre increment exp exp post increment exp aop exp assignment exp exp comma expressions sizeof type sizeof operator type spec exp cast syntax part external functions shall declared explicitly 
array specifiers parameter definitions shall changed pointer specifiers 
functions shall explicitly return value case non void functions 
switches shall default case 
optional expressions allowed replaced constant say 
array index expressions arranged pointer type 
type specifier short int shall specified short similar long 
implies base types represented type specifier 
defined functions declared course 
storage specifier extern shall applied global identifiers 
conversions function designators explicit address function taken fp indirect call written fp 
overloading operators resolved applied pointers shall syntactically different applied integers 
notice conditions purely syntactical fulfilled automatically parsing 
example return statements inserted void functions 
structure syntax closely resembles concrete allowing informative feedback 
syntactic omissions include static specifier possibility definitions inside statement blocks conditional expressions 
storage specifier static interpretations 
applied global definition definition gets file scope 
applied local definition variable statically allocated 
renaming static identifiers lifting local static definitions global level file scope static allocation respectively assured 
local definitions lifted function level renaming identifiers 
transformation may introduce superfluous local variables removed simple means 
conditional expression 
evaluation context context replaced new local variable transformation type 
transformation non trivial evaluation context contains sequence points comma expression context broken preserve evaluation order 
representation programs section outline concrete representation approaches need complicated representation static representation 
essentially syntax tree static call graph suffice 
part section consider deficiencies regarding sharing user defined types connection type analysis describe methods alleviating 
remaining constructs register specifier const qualifier added syntax outlined previous section 
reasons may desirable include static specifier syntax 
example analysis exploit knowledge function local 
type definitions struct definitions struct representation definitions program representation int struct struct program denoted triple set type definitions set global variable definitions declarations set function definitions 
function definitions shall contained function definition consists quadruple dp dl return type sets dp dl parameter local variable definitions representation statement sequence making function body 
example function int id int return abstractly described int int representation return statement 
function body represented single exit control flow graph set statement nodes set control flow edges unique start exit nodes respectively aho 
node incoming edges return statements 
start node equals initial statement node 
declaration definition represented declarator node list types 
denote type bracket notation int written int type definition list member declarations 
gives illustrative examples 
example depicts representation definitions 
struct int struct section elaborates representation structure types 
example expressions represented syntax tree 
static call graph conduct inter procedural context sensitive program analysis static call graphs useful 
static call graph abstracts invocations functions mainly employed differentiate invocations functions different contexts 
function call static dynamic depending binding time function designator 
call 
classified static name called function syntactically statically 
indirect call 
classified dynamic function invoked run time general determined statically 
static call graph represents invocations functions due static calls 
indirect calls represented 
assume static calls labeled uniquely 
function may called different call sites calls foo foo function foo invoked contexts calls 
call gives rise variant called function corresponding context call 
definition static call graph scg variant id variant maps call label variant number function name variant number scg call site th variant function containing call site invokes variant suppose call site appears main function foo called 
scg foo represents variant main calls variant foo 
example consider program 
int main void int foo void int bar void int fp void bar return bar return foo foo fp return static call graph shown 
notice indirect call represented 
tabulation scg show call variant foo foo bar bar call sites refer program 
example suppose program contains recursive mutually recursive functions 
implies infinite number function invocation contexts exist run time 
represent limit approximation adopted 
naturally analysis compute set functions possibly invoked see chapter 
main foo bar foo static call graph example definition number times variant recursive function created due direct indirect recursive call called limit 
limit means recursive call function approximated context invocation function 
bar example static call graph useless function int rec int return rec scg rec example better precision obtained larger limits 
implementation supports arbitrary limits experimented 
static call graph computed algorithm 
algorithm computation static call graph 
invoke main invoke build scg variant var function fun void invoke fun var fun stack var limit approximate variant scg insert var create new variant invoke variant stack push scg insert var invoke stack pop variable stack stack function identifiers variants 
method scans stack see function invoked limit number times 
affirmative case variant number returned 
variant reserved special purpose see chapter 
int int int int int int int representation declarations expression notice number variants function may grow exponentially practice seldom happens 
strategies preventing discussed literature cooper 
consider issue 

definition static call graph differs usual notion call graphs aho 
program static call graph approximates invocations functions run time starting main function 
traditional call graphs simply represent set functions function may call 
example consider program example 
call graph usual sense shows foo calls bar 
static call graph represents variant foo calls variant bar similarly variant 
example separation types shall assume expression attributed type expression 
example representation int assignment shown 
principle declarator type specifier lists shared expression nodes expression points relevant part declarator type specifier list 
going associate value flow information specifiers result precise representation information associated different occurrences variable merged refrain 
example type analysis convenient associate value flow information type specifiers 
example binding time analysis chapter assign binding time flag type specifier 
case non struct type new type specifier list assigned definition 
example definitions int specifier int shared fresh instance created 
suppose struct definition struct node int struct node definitions struct node 
typically information associated types members determines lay structs memory appearance residual struct definition consequence completely unrelated uses struct type may influence 
example case binding time analysis assigned dynamic value dynamic side effect definition type shared 
highly unfortunately unrelated 
avoid fresh instances struct definitions created 
example instance struct created similarly instance struct assigned type 
example chapter develop program transformation outputs program consequently struct definitions 
suppose program contains assignment 
uses type equivalence name types equal 
means instance underlying struct type struct 
value flow analysis accomplish single traversal program struct type instances assignments parameters assignments function returns union ed 
example accommodate recursive struct definitions limit approximation adopted 
instances recursive struct definition created 
implementation limit recursive structs context 
larger limits give better precision 
dynamic semantics dynamic semantics specified means big step structural operational semantics plotkin hennessy nielson nielson 
aim section compete standard iso provide concise description serve foundation specifying reasoning program analyses transformations 
instance specify behaviour functions leave implicit conversions take place 
specification comes parts inference systems functions statements expressions declarations 
informally describe modeling store 
precise description memory management relevant exhibition depends implementation 
usual store assumed consecutive set locations separate part constitutes program stack 
heap allocation performed isolated part store 
semantics assigns meaning programs translation units 
principle external function calls exist 
convenience shall regard calls library functions extern calls pre defined function id value store value store describe behaviour 
example pow 
include setjmp functions describe 
notations conventions set identifiers denoted id adopt convention denotes variable user defined function ef externally defined library function 
set declarations denoted decl 
dp range parameter declarations dl range local definitions convenient differentiate 
set expr set expressions stmt denotes set statements 
symbol ranges statements seq ranges statement sequences 
set function denoted fun set types type 
set values called value includes example integers locations objects array struct types 
set locations denoted loc 
environment map id loc identifiers locations 
store modeled map loc value locations values 
solely consider type annotated programs omit projections values 
instance write loc address 
simplicity explicit errors 
assume external functions behaved set errno variable case errors rely stuck states 
infinite loops modeled infinite derivations 
assume output delivered writes reserved memory locations taken care library functions 
semantics programs recall program triple type definitions global declarations function definitions 
type definitions merely interesting static program elaboration storage allocation ignore 
definition program meaning function library functions 
store 
meaning program applied values 
vn value 
vn decl di ei si ei si di 
en fi lfi fi 
lfi sn fresh locations fun 
vn main function decl defined section fun defined section 
fun 
dp 
seq decl vi ei si ei si decl dl em sm em stmt seq sm fun 
vm dynamic semantics function invocation em sm initial store updated respect global definitions 
environment updated contain addresses functions 
value program determined relation fun defined 
semantics functions function takes list values store executes statements context environment extended locations parameters local variables 
specified means relation fun loc value store value store defined 
result value possibly modified store 
definition function environment store respectively 

vn list values 
function application 
vn returns value store fun 
vn fun defined 
operationally speaking rule explained follows 
storage parameters local variables allocated means decl relation 
parameters initialized actual values vi 
local variables initialized 
statements executed extended environment 
semantics statements execution statement possibly modifies store transfers control implicitly program point explicitly named labelled program point 
semantics specified means relation stmt stmt store value store defined 
standard specifies local variables may contain garbage choice adheres definition 
recall consider setjmp longjmp 
empty stmt expr true false switch case switch default true false conv label goto exp stmt exp stmt stmt exp stmt stmt exp stmt sv case sv stmt switch exp stmt default stmt switch exp stmt stmt exp stmt stmt stmt stmt stmt stmt stmt stmt stmt goto return stmt return return block seq seq exp stmt return stmt seq stmt seq stmt stmt seq stmt stmt seq stmt seq dynamic semantics statements set value value employed model absence value 
element denotes void value 
range value range value definition seq statement sequence function environment store agreement meaning seq value store stmt seq stmt defined 
const exp valof var exp struct indr array address unary binary lexp exp offset exp exp exp exp exp lexp exp exp exp exp exp exp alloc exp alloc fresh location extern user call pre post assign comma exp 
exp en sn vn sn 
vn sn exp 
en exp 
exp en vn sn fun 
vn exp 
en exp exp 
exp en sn vn sn fun 
vn sn exp 
en lexp exp lexp exp lexp exp exp exp exp exp sizeof exp sizeof sizeof cast exp exp dynamic semantics expressions empty statement effect value expression statement discarded 
store may modified 
statement executes branch expression evaluates value different 
branch executed 
case switch corresponding case entry selected match default rules chosen 
rule executes body test non zero 
statements assigned meaning transformation semantically equivalent loops kernighan ritchie appendix 
label ignored case goto control transferred corresponding statement sequence 
return statement terminates execution value expression zero 
statements blocks executed sequence return statement met 
semantics expressions evaluation expression may modify store 
expressions sole construct affect store 
evaluation described means relations exp expr store value store defined 
computes values lvalues 
simplicity ignore void functions return value 
definition expr expression function executed environment store meaning value store exp exp defined 
semantic value syntactic constant meaning function valof 
value variable looked store environment 
notice case array variable implicit conversion array pointer takes place 
shown 
access value field struct object address calculated member offset added 
case pointer dereference array indexing store accessed location subexpression evaluates 
recall array index expressions assumed arranged subexpression pointer type 
address operator assigned meaning lvalue relation 
rules unary binary operator applications unspecified semantic function recall overloading resolved parsing 
rule alloc returns address free consecutive block memory suitable size 
external function calls calls library functions meaning function 
function call evaluated follows 
arguments possibly function expression evaluated 
return value determined means fun relation 
var lexp struct exp lexp offset indr exp exp array exp exp lexp dynamic semantics left expressions pre post increment expressions update location subexpression assignment updates lvalue left hand side expression 
comma expressions evaluated sequence rule sizeof uses semantic function sizeof 
rules cast trivial conversions left implicit 
rules computation expression lvalue straightforward 
notice function identifiers bound environment locations lvalue expression correctly evaluates location 
semantics declarations dynamic semantics declarations amount storage allocation 
external declarations simply update environment address function assume available 
necessary address library functions may taken 
definitions global variables allocate storage update environment reflect 
expressed relation decl decl value env store env store value initializer 
definition decl declaration environment store respectively 
value 
evaluation yields environment decl decl defined 
holds declarator rules justified follows 
variable definitions cause memory allocated 
semantics allocation expressed relation alloc briefly defined 
rules external variable functions simply update environment address declarator 
var evar alloc decl dynamic semantics declarations memory management address decl extern address decl extern precise modeling storage immaterial purposes depends implementation 
standard requires implementation adhere requirements take axioms 
variables shall allocated sequence 
objects base type occupy suitable number bytes depending machine 
members structs shall allocated order declaration member allocated location object 
elements arrays shall stored row 
store managed stack 
run time memory allocation accomplished separate space storage 
relation alloc type store loc store model allocation object particular type 
intuitively type store alloc holds store resulting allocation store memory object type location ignore deallocation aspect 
requirements properties importance chapters briefly mentioned 
pointer struct union points suitably converted member iso paragraph 
common initial members members structs union guaranteed shared 
struct member union assigned value accessed union member iso paragraph 
pointer arithmetic allowed move pointer inside array past element 
programs may rely variables allocated sequence members struct allocated order definition padding may inserted iso paragraph 
completes description dynamic semantics conjecture semantics complies standard 
notice semantics respect specified standard 
instance evaluation order fixed 
conforming programs allowed rely evaluation order violate correctness semantics 
related master thesis gave operational semantics core subset including functions global variables structs arrays andersen 
gurevich specified semantics core part means evolving algebras gurevich 
computation fortran programs call graphs studied numerous works ryder callahan lakhotia 
contrary fortran procedure variables function pointers 
hendren developed context sensitive invocation graph analysis supporting function pointers hendren 
analysis coupled point analysis approximates set functions function pointer may point 
invocation graphs precise expensive compute 
literature reports program representations suitable different purposes 
hendren simple representation complex expressions broken address code hendren 
environment harrison uses representation computation expressed primitive operations harrison iii 
summary described syntax semantics programming language 
furthermore devised representation accommodates user feedback program analysis described static call graphs 
chapter generating extensions develop automatic generating extension generator ansi programming language 
generating extension program produces applied partial program input specialized version ps respect generating extension generator program transformation converts program generating extension 
partial evaluation quickly evolving program specialization technique combines generality efficiency 
technique applied realistic applications languages 
traditionally partial evaluation accomplished partial evaluators mix symbolic evaluation subject programs 
expressions depending solely known input evaluated code generated constructs possibly depending unknown values 
approach drawbacks render development mix realistic imperative languages hard 
conspicuous problems include preservation semantics memory usage efficiency 
evaluate static expressions mix contains evaluator 
presence multi level pointers user defined structs address operator casts function pointers implementation defined features sizeof operator semantical correctness hard establish practice theory 
memory usage specializer considerably larger direct execution acceptable 
symbolic evaluation known order magnitude slower direct execution 
practice may specialization infeasible possible 
generating extension hand evaluates static expressions directly underlying implementation 
semantic correctness evaluation comes free representation overhead static values symbolic evaluation occurs 
chapter investigates specialization parts ansi programming language develops corresponding transformations constructs generating equivalents 
study specialization functions interaction global variables program point specialization statements treatment pointers runtime memory allocation specialization time splitting arrays structs various aspects 
stat stmt dyn stmt static dyn input static gegen stat stmt gen dyn stmt spec value gen dyn stmt ann gen spec boxes data programs 
horizontal arrows denote execution simplified structure generating extension generator program specialization means partial evaluation mature wellunderstood technology 
research focussed functional languages progress reported specialization imperative programming languages fortran baier pascal meyer andersen 
extension previous faced difficulties hard incorporate existing partial evaluators 
substantial problems preservation semantics efficiency central issues automatic program transformation 
example 
specialization ray tracer took minutes previous version mix symbolic evaluation 
current version generating extension transformation developed chapter accomplishes task seconds 
went wrong old version mix 
basic problem specializer works tagged representation static values spends time tag testing traversal representation 
generating extension hand works directly static values 
simplified view generating extension generator gegen shown 
input generator binding time annotated program ann output generating extension gen 
static parts program appear generating extension statements executed dynamic parts transformed code generating statements 
run generating extension inputs static data executes static statements generates code dynamic statements 
output spec specialized version spec 
specialized program inputs dynamic data yields value 
chapter develop generating extension generator transforms program generating extension pgen 
transformation depends specialization program constructs expressions statements data structures cover specialization aspects programming language 
mix equation revisited recall mix equation section 
input subject program language data domain suppose execution denoted result assuming produced 
pgm denote representation encoding data structure pgm 
partial evaluator mix fulfills mix pgm val ps pgm ps implication opposed bi implication allows mix loop 
traditionally partial evaluation accomplished means symbolic evaluation subject programs 
operationally speaking mix evaluates static constructs generates code dynamic constructs 
evaluate static expressions statements mix contains interpreter 
disadvantages interpretative approach include evaluator correctly implement semantics subject language 
specialization subject program represented pgm data structure inside mix 
static data encoded uniform data type representation mix 
symbolic evaluation order magnitude slower execution 
compiler program generator generation hindered double encoding subject programs cf 
futamura projections section 
evaluate static expressions mix employs evaluator faithful standard conforming implementation implementation evaluator non trivial error prone task 
consider example interpretation pointer arithmetic conversion cast pointer struct pointer member representation function pointers evaluation address operator 
principle possible implement correct evaluator practice hard establish correctness 
furthermore evaluators representations values 
example value represented assuming evaluator written huge union value entries integers doubles pointers values possibility user defined structs unions renders representation problematic 
consider representation structs 
number members unknown struct represented external value object instance pointer array values representing members 
suppose call subject program expression classified static solely depends known input 
dynamic 
dynamically typed languages example lisp encoding done underlying system 
standard allows upper limit members struct impractical iso paragraph 
passes struct argument function recall structs passed call value 
representation naturally implement call value passing structs representation struct copied call value pointer array copied array 
copying done explicitly necessitating objects tagged mix time size type 
increases memory usage andersen launchbury de 
empirical evidence specializer spends considerably time comparing tags traversing representation static data 
consider generation program generators self application mix 
previous succeeded self applying specializer kernel substantial subset andersen program generators suffered greatly inherited representation programs values 
example generating extension power function pow produced self application specializer pow specialized programs obtained execution extension pow gen indirect value representation objects difference cogen gegen see section 
highly undesirable specialized programs intended linked programs 
generating extensions specialization recall generating extension pgen program program produces specialized versions applied parts input 
assume pgen ps pgm ps result 
generating extension applied input yields specialized program ps respect generating extension generator gegen takes program returns generating extension pgen gegen pgm pgen pgm cf 
section 
notice input gegen binding time annotated program just program section suggests 
transformer gegen employed specialize programs stage process gegen pgm pgen pgm produce generating extension pgen ps pgm produce specialized program programs static input operationally speaking generating extension generator works follows 
binding time annotated program essence copies static constructs unchanged pgen evaluation execution extension 
dynamic constructs transformed calls pgen code generating functions produce residual code 
residual code specialized program 
illustrated 
gegen automatically produced compiler generator cogen produce generating extensions residual programs may differ 
cogen uses representation objects mix specialized programs inherit value representation 
hand gegen uses direct representation values produces residual declarations types subject program 
consider issues listed previous section 
specialization generating extension run static constructs evaluated directly underlying implementation words extension compiled run ordinary program 
need interpreter 
generating extension subject program extension carry program data structure 
generating extension generator needs subject program 
static values represented directly 
need expensive time storage usage universal value encoding 
essentially interpretation overhead static statements expressions evaluated interpreted 
program generator gegen inherit types mix 
program generators created gegen usually efficient possible cogen 
addition identify advantages 
suppose program specialized respect different static values 
mix subject program evaluated set static values 
gegen subject program need examined generating extension produced 
static computations redone source program syntax analysis suppose commercial product uses program specialization speed program execution 
mix technology complete partial evaluator delivered software gegen generating extension derived original software needs released 
naturally effect principle achieved cogen requires self applicable mix solve representation problem 
due simplicity generating extension transformation possible argue correctness task hopeless case traditional partial evaluator non trivial language 
definition gegen equation program language data domain generating extension generator gegen fulfills gegen pgm pgen pgm pgen ps pgm requires existence self applicable mix 
truth modification statements expressions evaluated directly memory management imposes penalty program execution see section 
ps residual version respect naturally program generator terminate 
allow generating extension suffer imperfect termination properties specializers 
may fail terminate static input ordinary program execution terminates dynamic input 
nontermination due reasons 
subject program loops static data dynamic input 
normally acceptable specializer loop case 
may case generating extension loops normal direct execution terminates 
course annoying 
assume generating extensions terminate 
section consider termination problem greater detail 
previous ershov introduced term generating extension program defined data mixed computation 
framework developed small toy language assignments loops 
described hand writing generating extensions example programs 
techniques knowledge extended automated cope languages supporting pointers user defined structs runtime memory allocation systematic way 
project contained hand written compiler generator subset lisp beckman 
system aimed optimization compilers elimination intermediate computation specialization programs 
holst launchbury suggested hand writing cogen mainly way overcome problem double encoding subject programs self application time 
studied small ml language 
key observation structure automatically generated compiler resembles hand written compiler manageable task write compiler generator hand 
birkedal developed generating extension generator core standard ml language imperative constructs birkedal 
bondorf studied cps cogen untyped lambda calculus 
remains generalized realistic context 
author succeeded self application partial evaluator subset language andersen andersen 
managed generate cogen convert interpreters compilers broadly programs generating extensions 
section contains detailed comparison related cites relevant literature 
extends previous follows 
develop partial evaluation full ansi language allows specialization larger programs previously possible demonstrate techniques feasible practice 
furthermore aim different 
previous mainly concerned self application compiler generation focusses primarily efficient specialization software development 
gen ext input static stat stmt gen dyn stmt return pgm generating extension structure generating extension overview chapter code gen calls pending list memory management residual pgm knowledge polyvariant program point specialization realization techniques assumed chapter gomard jones jones 
rest chapter structured follows 
section presents example transformation string matcher generating extension 
section serves introduce basic concepts notions exposition 
sections contain complete treatment aspects programming language 
part chapter modeled book programming language kernighan ritchie kernighan ritchie 
consider specialization expressions statements functions interaction global variables side effects 
consider treatment pointers arrays structs define notion partially static data structure specialization time splitting runtime memory allocation 
sections serve purposes describe specialization various constructs introduce corresponding transformations state binding time separation requirements subject program meet 
consider binding time analysis chapter subject programs assumed annotated binding times 
chapter summarizes transformation 
section investigates memory management generating extension 
due pointers side effects memory management involved example functional languages 
furthermore storage usage major concern specialization big programs may easily exhaust memory care taken 
section describes strategies function specialization sharing unfolding 
section considers code generation introduces improvement allows determination dynamic tests 
section focusses termination problem 
argue methods reported literature insufficient realistic 
section describes related section lists related concludes 
refined picture generating extension shown 
copyright free software foundation return occurrence needle haystack 
char strstr char haystack char needle register const char const needle needle register const char const haystack haystack register const size needle len needle needle register const size needle needle len register const char needle len return char haystack ansi size haystack haystack needle len return null haystack needle haystack register const char needle needle register const char goto loop continue loop needle haystack return char loop return null gnu implementation standard string function strstr case study generating string matcher aim section illustrate main principles case study transformation naive string matcher program generating extension 
string matcher inputs pattern string returns pointer occurrence pattern string null 
generating extension takes pattern yields specialized matcher inputs string 
subject program strstr 
speedup obtain impressive example simple convey generating extension works 
specialized matchers optimal contain redundant tests compare example knuth morris pratt kmp matchers knuth 
specialization string matchers popular test comparing strength program transformers jones 
return problem chapter consider stronger specialization technique driving allows propagation context information 
enables generating efficient kmp matchers naive string matchers 
string matcher strstr gnu library implementation strstr function shown stallman 
string matcher naive efficiently implemented 
code copyrighted free software foundation 
char strstr char haystack char haystack char char haystack haystack int haystack haystack return haystack cmix label haystack goto cmix label goto cmix label goto cmix label return char return specialized version strstr aab lengths pattern needle string haystack standard function 
length pattern exceeds length string match possible 
pattern searched linear scan string loop 
suppose examine dna strings 
look pattern strings 
may pay specialize strstr respect fixed pattern obtain efficient matcher 
needle static known data haystack dynamic unknown input 
goal specialized program shown 
shows strstr specialized pattern aab 
input program string hay stack 
pattern coded control testing needle array 
binding time separation consider program text 
haystack classified dynamic variables depending classified dynamic 
means haystack program generated automatically henceforth awful appearance 
char strstr char haystack char needle register const char const needle needle register const char const haystack haystack register const size needle len needle needle register const size needle needle len register const char needle len return char haystack ansi size haystack haystack needle len return null haystack needle haystack register const char needle needle register const char goto loop continue loop needle return char loop return null binding time separated version strstr dynamic 
hand needle len needle static 
separation variables static dynamic called division 
classification haystack needle initial division 
dynamic variables expressions statements underlined 
minor change sake presentation conjunct haystack eliminated loop 
easy see modified program computes function original 
change necessary prevent loop dynamic 
section describe extension renders binding time improvement unnecessary 
loop statement dynamic tests dynamic 
function return value runtime specialization time return statements classified dynamic including return null 
generating extension strstr gen generating extension shall output specialized version strstr respect needle 
intuitively accomplished follows 
suppose program executed 
non underlined static constructs executed normally loop iterated evaluated 
underlined dynamic construct encountered imagine statement added residual program constructed incrementally 
execution terminates residual program contain specialized versions statements executed statically 
due loops statement may get specialized times test recognized times 
type code 
represent dynamic variables introduce reserved type code generating extensions 
instance definition code haystack represents dynamic pointer haystack 
variables type code appear residual program 
case haystack appear specialized versions strstr expected 
residual code code generating functions 
execution generating extension residual code generated 
assume library code generating functions add residual statements residual program 
example adds expression statement residual program adds goto goto 
similarly assume code generating functions expressions 
example function returns representation binary addition representations arguments 
function converts integer value syntactic constant 
transformation non branching statements 
consider expression statement haystack needle 
recall haystack dynamic needle static 
result transformation haystack needle lifts static value needle syntactic constant 
consider dynamic statement return char 
transformed version char goto cmixpendloop cmixpendloop specified label 
residual return statement added residual program means 
return terminates control flow path specialize 
goto statement transfers control pending loop see 
transformation branching statements 
test loop static determined specialization time 
consider needle subject program 
needle static loop static unrolled specialization 
loop henceforth transformed needle generating extension transformation consider specialization dynamic conditional goto loop 
similarly compiler generate code branches arrange branches specialized 
branch specialized time introduce pending list program points pending specialized 
library function cmixpendinsert insert label program point specialized 
conditional transformed follows cmixpendinsert cmixpendinsert label goto loop inserted transformation label empty statement generally label branch transformation test 
branch jump goto inserted label statement 
implicitly convert loop dynamic test goto 
pending loop 
pending loop generating extension responsible ensure program points inserted pending list specialized 
program points pending specialization taken marked processed corresponding statements pgen executed 
code strstr gen char needle int cmixpendinsert switch case program point case program point cmixpendloop return initiate specialization label statement inserted list 
left aspect program point shall specialized respect values static variables assumed label inserted pending list 
simply assume records information restores values static variables 
example consider contrived version sign assume specialized respect dynamic value 
sign return sign int sign int int return suppose branch specialized 
value updated 
eventually branch specialized 
static variable restored value branch recorded specialization 
example example rely left right evaluation order 
code strstr char needle register const char const needle needle register const size needle len needle needle register const size needle needle len code haystack haystack int cmixpendinsert switch case haystack haystack needle len char haystack goto cmixpendloop size haystack haystack needle len cmixpendinsert cmixpendinsert goto cmixpendloop case null goto cmixpendloop case haystack needle loop haystack cmixpendinsert cmixpendinsert goto cmixpendloop case register char needle needle cmixpendinsert cmixpendinsert goto cmixpendloop needle char goto cmixpendloop case goto case char goto cmixpendloop case goto loop case loop goto loop case null goto cmixpendloop cmixpendloop return name function generating extension strstr practice static values copied label inserted pending list restored label taken 
program point values static variables called partial state 
generating extension transformation 
transformation strstr generating extension summarized follows 

change type dynamic variables code 

copy static expressions statements generating extension 

replace dynamic expressions statements calls code generating functions 

insert pending loop 
result generating extension strstr shown 
due lack space shown calls generate code expressions 
specializing strstr execution generating extension input pattern aab yields residual program shown 
benchmarks provided table 
experiments conducted sun sparcstation ii mbytes memory compiled gnu option 
match performed times 
input runtime sec pattern string original specialized speedup aab aab aab aab types operators expressions sections describe binding time separation transformation various aspects programming language 
sections serve introduce code generating functions generating extension library implement 
section consider simple expressions base type variables 
generating extension program manipulating program fragments 
assume type expr suitable representation expressions 
program shown generated mix adapted fit presentation section 
hand program 
constants language supports kinds constants base type constants string constants enumeration constants 
constant static 
build syntactic expression corresponding constant value called lift functions employed 
lift function builds syntactic representation value 
example int returns representation integer constant char returns representation string function char returns representation named enumeration constant example consider pow function assume base static dynamic 
int pow int base int int base return variable pow assigned value dynamic 
constant appears dynamic context henceforth lift needed generating extension 
example avoid code duplication restricted string constants 
arbitrary character arrays lifted 
data types declarations impose uniform program point insensitive monovariant binding time division variables 
variables definitely specialization time known values called static called dynamic 
sections introduce partially static variables 
specialization static variable holds value dynamic variable holds symbolic address 
generating extension static variables defined subject program dynamic variables defined reserved type code 
section argue convenient dynamic variables contain symbolic addresses residual program 
variable symbolic address corresponds residual name 
example consider pow function defined example 
generating extension static parameter defined int base dynamic variables code code respectively 
example currently enumerations implicitly converted integers needed 
revision standard require strong typing enumeration constants 
obvious alternative function generate residual variable 
dynamic variables initialized code 
functions char type expr var char type expr var produce residual parameters variable definitions 
example calls int int define dynamic variables residual program pow 
example type dynamic variable deduced subject program 
operators set operators divided groups unary binary assignment special operators 
consider group turn 
set unary operators includes 
unary operator application performed specialization time provided argument static 
application suspended 
library function char op expr arg builds residual application 
representation binary operator application returned expr char op expr 
binary operator applied specialization time arguments static 
deferred runtime 
example call produces representation 
expression transformed cf 
example 
example dynamic operator application transformed checked argument static 
case surrounded lift function 
assignment operators considered 
pointer dereference operator address operator treated section 
type conversions type value converted implicitly explicitly 
implicit conversion happens example integer value passed argument function expecting double 
generating extensions executed ordinary programs static values represented directly special action needs taken 
explicit conversions normally referred casts change type object specified type 
example char null changes type constant pointer 
casts divided categories portable non portable 
cast pointer portable cast iso page 
effect non portable casts implementation defined undefined 
cast base types evaluated specialization time provided operand static 
static casts transformed unchanged generating extension 
consider cases iso paragraph conversion pointer integral type conversion suspended integral value lifted possible lift specialization time addresses runtime 
effect conversion implementation defined undefined 
conversion integer pointer type conversion suspended specialized programs depend implementation generated program computer executed generating extension 
conversion pointer type pointer type 
alignments general implementation defined conversion suspended runtime 
conversion function pointers 
cast performed specialization time provided pointer static 
residual casts build char type expr 
example definitions int 
cast int suspended pointer converted integral value 
cast int suspended integral value converted pointer 
call char casts character pointer 
example assignment operators set assignment operators includes compound assignments 
assignment performed specialization arguments static 
suspended 
possibly lift function applied static right hand side subexpression 
library function expr char op expr generates residual assignment 
example call produces residual assignment cf 
example 
example language supports assignment struct values example definitions struct int assignment simultaneously assigns fields value 
suppose member static member dynamic 
assignment objects mixed binding times called partially static assignment 
ideally assignment members performed specialization time code generated member 
generating extension assignment evaluated static cause code generated dynamic 
solve conflict struct assignment split static dynamic part 
result implementation defined 
result depends object pointer points 
pointer object alignment may converted object alignment back result shall compare equal original pointer 
pointer function type may converted function pointer back result shall compare equal original pointer 
example definitions struct int assume members static dynamic 
assignment transformed lines memcpy sizeof memcpy function copies entries array 
example splitting struct assignments separate assignments potentially represents execution overhead compiler may generate efficient struct assignment block copy 
case gnu compiler case 
thesis gain outweigh loss 
conditional expressions simplicity conditional expressions 
transformed conditional statements cf 
chapter 
way evaluation irreconcilable expressions avoided contain assignments 
precedence order evaluation standard specifies evaluation order operators comma operator 
generating extension executed conforming implementation precedence rules automatically obeyed 
execution generating extension particular implementation fixes order evaluation 
conforming programs allowed rely evaluation order represents problem 
example evaluation order assignment specified defined incremented index evaluated 
generating extension specialized program executed platform original program behavior 
example expression statements expression act statement 
expression static transferred unchanged generating extension evaluation specialization 
code dynamic expressions added residual program construction 
function expr 
takes representation expression adds expression statement residual function 
transformation gegen transformation impossible assignment change semantics program 
time writing implemented partially static assignments mix system 
control flow employ variant depth polyvariant program point specialization specialization statements control flow jones 
section presents called pending loop controls specialization program points static values generating extension transformation various statement kinds 
assume local variable definitions function scope cf 
chapter 
simplifies memory management generating extension 
consider example jumps block dynamic variables 
scopes exist global scope function scope 
due pointers objects lexically scope may accessible 
set static visible objects program point called static store 
execution generating extension static stores may exist parallel 
example branches dynamic specialized generating extension execute branch 
branch specialized static values valid test expression reduced values resulting specialization branch assuming branch specialized branch values copied 
static store computations carried called active store 
pending loop generating extension uses pending list represent set program points remaining specialized respect static store 
list contains quadruples form label program point specialized program label static store copy values static variables label residual program point generated label inserted list 
flag indicates entry processed 
operations pending list needed insertion test exhaustion pending program points way restoring values static variables static store 
function cmixpendinsert label inserts label pending list 
side effect copy active store 
label similar static store exist pending list residual label associated entry returned program point inserted 
implements sharing residual code 
copying active store subject section 
function checks program points remain processed selects affirmative case 
returns 
function label restores static store associated selected entry marks processed 
text residual label returned 
simplicity shall assume address label computed computed goto available goto 
pending loop easily expressed switch statement section desired 
pending loop generating extension sketched algorithm 
algorithm pending loop 
cmixpendinsert label cmixpendloop pp process program point npp pp restore state npp generate residual label goto pp jump program point return fun name return name generating extension body label label label assumed unique introduced transformation 
un processed program points remain list selected 
address corresponding program point assigned variable pp 
active store restored respect static store associated selected entry 
residual label added residual program means label call 
control transferred program point specialized goto pp 
assuming pp effect branch part pgen generate code part statement labeled program points processed name completed residual function returned 
transformation statement determined binding time test 
test static branch performed specialization time 
static transformed generating extension 
residual statement added residual program branches specialized 
statement consider 
residual code statements look 
possibilities exist unfolded branches control flow joined specialized version 
example residual versions 
unfolding joining operations supported gnu compiler 
left unfolded branches specialized right control flow joins specialized version 
example gives better exploitation static values gives residual code 
suppose contain conflicting assignments assigns assigns 
implies control flow jointed single statement 
line partial evaluators side step problem suspending conflicting variables insertion called disagreeing variables 
lifts variable runtime barzdin meyer 
technique unsuitable line partial evaluation set variables lifted determined bindingtime analysis time 
compromise shared static stores resulting specialization similar 
transformation dynamic illustrated example 
example program fragment binary search procedure 
mid high mid mid low mid return mid suppose static dynamic specialized 
transformed code follows 
cmix test mid cmix test cmixpendinsert cmixpendinsert goto cmixpendloop branch high mid cmixpendinsert goto cmixpendloop branch cmix test mid cmix test cmixpendinsert cmixpendinsert goto cmixpendloop second branch low mid cmixpendinsert goto cmixpendloop second branch mid goto cmixpendloop variable cmix test assigned expression ensure side effects completed active store copied cmixpendinsert 
executed code form recall evaluation order arguments unspecified 
return generated 
example transformation 
cmix test cmix test cmixpendinsert cmixpendinsert goto cmixpendloop sm gegen cmixpendinsert goto cmixpendloop sn cmixpendinsert goto cmixpendloop statement specialization point 
shared static stores valid branches agree 
function expr label label adds residual statement goto goto current residual function 
function label adds residual goto 
switch treatment switch statement depends expression 
static switch executed specialization copied generating extension 
case dynamic switch case entries specialized 
transformation shown 
switch cmix test cmix test case cmixpendinsert cmixpendinsert goto cmixpendloop case gegen cmix test cmixpendinsert cmixpendinsert goto cmixpendloop default sn ln goto cmixpendloop 
ln sn observe residual code generated due transformation correctly implements cases fall 
example dynamic switch statements candidate trick transformation statically bounded variation jones 
point branch case vi si switch expression known assume value vi dynamic 
terminology driving called positive context propagation gl ck 
consider chapter 
example loops static loops iterated unrolled specialization 
consider dynamic loops loops dynamic test 
loop corresponds loop initialization step expression kernighan ritchie manual 
loop similar 
suffices consider loops 
transformation 
loop test test test gegen cmixpendinsert cmixpendinsert goto cmixpendinsert iterate goto cmixpendloop loop notice back jump specialized potentially giving better sharing residual code 
example tempting idea introduce residual 
requires assignments body suspended excessively conservative cases 
structured loops re introduced residual programs post processing 
baker 
example example version standard library function strcmp shown 
specialize respect dynamic 
strcmp return int strcmp char char return return assume break continue statements pre transformed goto 
kernighan ritchie page kernighan ritchie 
code strcmp char pending loop omitted test cmixpendinsert cmixpendinsert goto cmixpendloop goto cmixpendloop cmixpendinsert goto cmixpendloop goto cmixpendloop generating extension strcmp generating extension shown residual program 
int strcmp char return return return transformation result monovariant specialization assignment suspended 
example possible improve sharing residual code slightly 
observe program point specialized due dynamic jumps dynamic 
general statement controlling dynamic loop rarely target jump time loop met 
label inserted pending list due back jump 
means appear twice residual program 
alleviated forcing specialization point cmixpendinsert goto cmixpendloop test test cmixpendinsert cmixpendinsert goto cmixpendloop goto cmixpendloop goto labels language exhibit computed gotos target jump statically known 
implies goto performed specialization labelled statement generating extension corresponding target jump subject program 
static execution jumps generating code known transition compression 
notice transition compression cause non termination program contains purely static loop 
convenient specialize gotos connection loops 
library function label generates residual goto 
accompanying transformation goto gegen cmixpendinsert goto cmixpendloop seen times proceeding examples 
example copying restoring static values may expensive 
case dynamic goto need restore active store specialization proceeds immediately target statement residual code shared 
transformation changed goto cmixpendinsert goto goto cmixpendloop gegen returns true previous call cmixpendinsert shared residual program point 
example functions program structure arguments function known specialized hopefully optimized version produced 
aim function specialization 
subject section transformation functions generating functions 
generating function adds specialized version fs residual program returns name 
furthermore study impact side effects residual function sharing unfolding 
part section discuss extern static register specifiers recursion 
basics function specialization 
vm static arguments generating function fulfills pgm vm 
vn 
vn 
vm vm 
vn 
parameters functions may modify non local variables 
programs exhibit extensive global variables imperative languages instance global array rare 
restricting function specialization parameters give poor results 
constraint function specialization shall respect static parameters static global variables 
runtime heap allocated objects seen global anonymous data objects 
example aim specialize function 
struct int int main void struct malloc sizeof struct return int void return clearly specialized respect global variable indirection 
example suppose generating function called twice execution generating extension arguments 
seemingly possible share specialized function generated due call simply second invocation return name function 
assume predicate returns true call shared 
section outlines strategy function sharing 
context fold unfold transformations sharing known function folding burstall darlington 
structure generating function 
algorithm generating function code fun static arguments return share specialize push fun new res 
fun 
pending loop specialize body return pop fun generating statements 
see algorithm 
generating function checks invoked similar context 
affirmative case name shared function returned immediately caller new residual function constructed 
residual function constructed 
residual functions generated parallel calls generating extension 
generating function called new residual function built code generation resumes previous residual function generating function returns 
implement residual function stack 
new residual function constructed name pushed stack push fun 
specialization completed popped means pop fun 
code generating functions add code residual function currently top residual function stack 
functions side effects program implements stack push function 
int stack max stack sp push push val top stack void push int val sp max stack stack sp val fprintf stderr stack overflow suppose contents stack dynamic stack pointer static 
specialization push respect particular value sp function inserts value specific location stack produced 
example version push specialized respect sp assigns argument stack 
notice specialization static value sp 
suppose second call push sp 
apparently call shared call signature matches previous invocation 
doing prevents value sp updated wrong sp dead 
extreme solutions prohibit static side effects disallow sharing functions accomplishing static side effects 
degenerate specialization instance initialization global data structures suspended 
increases risk non termination 
section presents sharing strategy 
example function call malloc performs side effect heap henceforth shared 
example consider contrived function performs static side effect dynamic control 
pop zero pop top element zero void pop zero void stack sp sp return test dynamic branches specialized 
branch ends state sp leaves sp unchanged 
pop zero pop stack zero void pop zero void stack sp return sp return problem call generating function pop zero value static variable sp unknown assume 
value determined runtime 
specialization code generation resumes point statement call 
handling dynamic feasible unfold subsequent statements branches 
naturally unfolding side effect function side effect handled case local side effects 
constraint side effects dynamic control shall suspended 
chapter develops side effect analysis detect side effects dynamic control 
recursion unfolding function specialization proceed depth preserve execution order 
functions may recursive call recorded seen body specialized cf 
algorithm 
guarantee termination 
termination properties discussed section 
partial evaluation tends produce small functions obviously unfolded inlined caller 
modern compiler perform inlining desirable inlining explicitly residual program 
enhances compiler opportunity perform optimizations davidson holler 
generating function function unfolded shortly called unfold able generating function 
unfolding done specialization postprocess 
section solely describes unfolding specialization accomplished follows 

execution generating extension call unfold able function residual code assign dynamic actuals formal called function 

generating functions unfold able functions calls push fun pop fun omitted specialization time residual code added callee residual function 

generating functions unfold able function generate assignment result variable jump label residual return 
procedure implements function unfolding function basis 
alternatively unfolding decided call site basis 
structure generating function depends heavily unfold able pursue 
example suppose function pow unfolded main 
previous described management configuration updating state sharing functions side effect dynamic control andersen 
experiments revealed fruitful approach abandon 
notice residual function unfolded generating function 
int main void int exp result dynamic result pow exp return result residual function appearance 
int main void int exp result int exp result return result example copy propagation optimize code done optimizing compilers 
external variables programs consist translation units implementing different parts system 
module refer global identifier variable function defined modules means extern declarations 
externally defined variables suspended runtime 
externally defined functions may side effect variables modules calls suspended 
constraint externally defined identifiers shall suspended 
practice requirement strict 
example mathematical functions pow externally declared math purely static calls computed specialization time 
section return introduce notion pure function 
pure function calls evaluated statically 
program specialization context modules subject chapter 
chapter discusses dubious treatment global variables 
global identifier exported modules explicitly declared local means static specifier 
looking module isolation global variables principle suspended 
dramatic consequence function specialization occur 
continue assume translation unit relevant part program suspend externally defined identifiers 
compilers allow implicit declaration functions returning integer values 
assume external explicitly declared 
static variables storage specifier static meanings 
applied global identifier identifier file scope 
impact program specialization ignored chapter consider separate program specialization modules 
local variable defined static allocated statically lives function invocations 
argued chapter static identifiers treated unique global identifiers 
register variable register specifier hint compiler influence program specialization 
storage specifier copied residual program 
initialization allows initialization values provided part definitions 
matters rely pre transformation converts initializations ordinary assignments 
pointers arrays subject section specialization pointers arrays 
early partial evaluators data structures classified completely static completely dynamic 
resulted need manual binding time engineering programs splitting list pairs lists achieve results 
section describe binding time classification specialization partially static data structures interaction functions pointers 
section deals structures unions 
pointers addresses pointer variable containing address constant null 
classify pointer static value contents definitely known specialization time 
classify dynamic 
static pointers dereferenced specialization dynamic pointers 
example consider int ip assume static dynamic 
pointer ip static pointer static object assignment ip 
static pointer dynamic object ip 
dynamic expression assignment ip forces ip dynamic pointer 
example special reason doing simplifies presentation 
static pointer dynamic object partially static data structure 
referring static pointers static objects explicitly written 
recall dynamic variable bound symbolic runtime address specialization 
example int dynamic variable defined code generating extension bound loc say 
appears residual program int loc 
sake readability assume scalar dynamic variables bound name 
constraint dynamic variables shall bound runtime address specialization 
consider specialization expressions ip ip ip static pointer dynamic object 
generating extension code appears ip ip lift static constant dynamic context 
operationally speaking static pointer ip assigned address dynamic 
ip dereferenced giving desired 
example consider contrived inline version swap implemented pointers 
int px py int temp swap temp px px py py temp suppose dynamic 
specialization produces residual program int int temp temp temp pointer manipulations take place 
example additional conditions imposed usage address operator specialization time applied arrays described 
pointers function arguments consider specialization swap function 
swap swap content px py void int px int py int temp temp px px py py temp see kernighan ritchie kernighan ritchie page 
suppose int dynamic variables consider specialization due call swap 
formal parameters classified partially static static pointers dynamic objects net effect dereferencing body runtime addresses illegally propagated residual body swap 
illegal residual program void swap px py int temp temp temp prevent specialization respect partially static pointers disallowed 
constraint formal parameters pointer type shall completely static completely dynamic 
suffices prohibit specialization respect pointers point non local objects 
pointer analysis developed chapter implement improvement 
furthermore indirection partially static pointer dead body pointer retain status static see section 
example consider function increments pointer 
ptr increment integer pointer int ptr int return partially static pointer requirement forces fully suspended 
dereferenced body ptr permissible classify function static 
point body functions need specialized dead values see section 
example pointers arrays suppose int statically indexed array dynamic values 
array split separate variables int 
specialization objective elimination index calculations level indirection 
example suppose polish calculator uses stack int stack carry calculations 
example addition computed instructions push push push pop pop 
stack statically indexed specialization respect program produces residual program symbolic address example statically indexed means index expressions static 
naturally index array dynamic array split 
precisely split array requirements fulfilled 
constraint array split provided index expressions static dynamic pointer may refer array passed actual argument function 
conditions justified follows 
index expression corresponds clearly addition evaluated dynamic 
dynamic pointer may array array split entry pointer points may computable specialization time ii program may rely array allocated consecutive block memory pointer arithmetic 
splitting array passed parameter function passing pointers individual variables residual program introduces severe call overhead 
example consider application address operator array dynamic elements 
evaluates dynamic value application classified static rewriting shows 
hand case dynamic index evaluated statically 
example binding time classification specialization runtime allocated arrays similar statically allocated arrays 
address arithmetic language allows pointer assigned pointer adding subtracting pointer integer subtracting comparing pointers members array assigning comparing zero 
hard part binding time separation 
considered chapters pointer analysis binding time analysis 
example strcpy function pointer arithmetic 
strcpy copy page void strcpy char char suppose dynamic static 
increment operators classified dynamic static respectively 
specialized program respect ab shown 
recall pointer arithmetic allowed shuffle pointer inside array past element 
strcpy copy ab void strcpy char assessment usability doubtful 
practice specialized function form void strcpy char char ab preferable due reduced storage usage 
example binding time classification pointer versions plus minus differs normal applied partially static pointers 
example static pointer dynamic object classified static static part needed evaluate addition 
see chapter details 
character pointers functions section defined lift functions constants base type strings 
example useful lift string constants 
example string function strcmp char char external function suspended argument dynamic 
call strcmp ab dynamic transformed strcmp ab returns residual function call strcmp 
example lift arbitrary character arrays undesirable may duplicate data 
imagine example editor representing edited file string 
section considers externally allocated strings string functions 
pointer arrays pointers pointers multi dimensional arrays far employed level pointers 
techniques carry multi level pointers modification 
instance pointer int classified static pointer static pointer dynamic object dereferenced twice specialization 
naturally sense classify pointer dynamic pointer static pointer dynamic objects objects pointer points runtime 
pointers functions flexible rules assignment function addresses pointers 
assume standardized notation fp assignment fp call function fp pointer suitable type see chapter 
specialization respect function pointers similar simpler specialization respect higher order values functional languages 
simpler allow closures partial function applications 
consider general application fp 
en differentiate situations 
pointer fp static points particular generating function specialization 

pointer fp dynamic known point 
fn 

pointer fp dynamic imperfect information functions points available 
consider case turn 
function pointer static dereferenced corresponding generating function called 
call transformed fp 
em em 
en em 
en dynamic arguments 
suppose fp points 
residual call res 

function pointer point functions defined program 
typically point small set 
means pointer analysis set functions approximated 
assume fp dynamic pointer determined point functions 
fn 
idea specialize functions respect static arguments defer decision specialized function call run time 
example fp function pointer defined functions 
example dynamic function pointer fp dyn exp fp specialization addresses defined functions replaced unique numbers assigned fp 
call site switch possible functions generated 
ignore case function static 
paragraph consider program translation unit 
specialized example dynamic function pointer fp dyn exp switch fp case spec specialized version case spec specialized version observe functions usually appear residual program fp meaning 
function pointer assignment may cause different specialized function called 
example actual function executed runtime unknown specialization time potential functions may perform static side effects 
constraint functions potentially called function pointer shall commit static side effects 
consider case set functions function pointer may point approximated 
example happen pointer assigned entries externally defined array functions 
problem function pointer may point unknown function user defined function 
example suppose int cmp array function pointers int defined function 
example code function pointer fp dyn exp cmp exp fp type cast unique label assigned fp 
specialized example code fp dyn exp cmp exp int switch int fp case spec specialized version default fp call unknown function switch tests pointer points user defined function calls unknown function 
example depending compiler switch may converted jump table final compilation 
specialization respect dynamic function pointers summarized follows 
execution generating extension 
expressions form defined function replaced unique constant address function consider program consist translation units subject specialization 

unknown functions left unchanged 

calls fp specialized switch possible values fp see example 
generating extension transformation indirect call clear 
note residual code strictly conforming standard conforming iso 
easy see portable 
solution optimal 
replaces efficient construct indirect call potentially expensive construct switch statement 
thesis switch statements optimized compiler gain obtain specialization outweigh extra call overhead 
shall consider specialization function pointers respect known unknown functions 
structures structure consists logically related variables passed entity 
classification structs completely static completely dynamic produce conservative results 
section develops fine grained binding time assignment allows automatic splitting partially static structs 
investigate runtime memory allocation show dynamic memory allocation replaced static allocation 
discuss unions bit fields 
basics structures structure collection variables called members 
example struct point int pt defines struct variable pt useful representation coordinates 
struct necessarily members dynamic called partially static struct 
differentiate cases members struct accessed specialization time case 
called static structs said dynamic 
constraint members dynamic struct shall dynamic 
struct may instance classified dynamic part unknown input subject program returned function see section 
notice attribute classification struct definitions variables 
struct index operator applied static struct evaluated specialization time 
dynamic sloppy write struct variable structure type common practice 
normally undesirable change type dynamic input 
recall type separation performed representations programs cf 
section 
indexing transformed transformation expression net effect static structs split separate variables indexing dynamic structs deferred runtime 
objective struct splitting elimination level indirection offset calculation 
example suppose struct point static struct dynamic dynamic 
consider code struct point pt static struct pt assignment static member pt assignment dynamic member specialization yields lines code 
int pt pt dynamic members pt pt assignment dynamic member struct variable pt split residual variable pt pt type integer 
example dynamic struct members shall bound runtime symbolic address dynamic variables 
constraint static structs split specialization dynamic members appear separate variables residual program 
consider interaction structs pointers 
example strategy narrow definition partially static structs dynamic members 
specialization static members accessed code generated dynamic members 
structs split 
compilers pass structs approach may outperform struct splitting 
shall pursue 
example structures functions struct passed function ways call value pointer 
ansi standard allows functions return structs 
consider function returns struct 
point create point coordinates struct point point int int int struct point pt pt pt pt return pt suppose static dynamic 
pt returned function split classified dynamic 
see consider call pt point suppose member static 
variable pt need updating specialization point undesirable 
constraint structs returned function shall dynamic 
consider opposite structs passed call value functions 
length function receives struct point 
length compute length origin point double length struct point pt return sqrt pt pt pt pt pt pt clear separation static dynamic arguments prohibit passing partially static structs 
constraint struct type parameter definition shall completely static members completely dynamic members 
case struct shall classified dynamic 
information lost due requirement revealed passing struct members separate variables 
naturally care taken change passing semantics passing directly array previously encapsulated struct 
example avoid struct point classified dynamic passed function length apply transformation clearly automated 
transformed version length struct point pt double length int int int struct point pt return sqrt pt pt pt pt pt pt local variable pt needed address original parameter taken see 
example precisely applying transformation subject programs partially static structures passed functions 
transformation applied members array type 
call changed 
members 
function definition changed accordingly 
body function local variable original struct type introduced initialized parameters 
transformation obviously automated 
pointers structures section considers pointers structs created address operator 
runtime memory allocation subject section 
address operator applied static struct result pointer access members 
address operator applied dynamic struct struct object 
example assume usual binding time assignment struct point 
struct point pt pt ppt pt pt pt ppt pt pt ppt pt ppt pt ppt specialization proceeds follows 
line assignment evaluated code generated rest 
line static pointer pt created dereferenced line 
consider line 
assignment partially static structs 
applying transformation described section splits assignments static dynamic part 
residual code generated 
int pt pt pt pt pt pt pt pt pt pt pt pt assignment line split struct point inevitably dynamic 
example notice structs lifted struct appearing dynamic contexts classified dynamic 
constraint structs referred dynamic pointer shall classified dynamic 
consider passing struct pointer function 
example suppose function length changed length struct point ppt accepts pointer struct 
case pointers objects cause dynamic objects lexically scope propagated body called function 
avoid pointers partially static structs allowed 
transformation increases number parameters function may represent call overhead 
case structs members passed registers transformation effect 
constraint parameter type pointer struct shall dynamic struct contains dynamic member 
struct referred dynamic pointer classified dynamic fully suspends struct 
example suppose function length struct point pt takes address parameter pt uses compute result 
suppose parameter splitting transformation outlined previous section applied 
int length int int int struct point pt struct point ppt ppt pt return sqrt ppt ppt ppt ppt ppt ppt function specializes residual program shown modulo copy propagation elimination pt pt 
notice pt necessary address operator applicable 
example self referential structures struct definition refer means pointer 
recall chapter recursively defined structures limited type definition 
convey restriction binding time assignments 
example struct nlist struct nlist char name defn defines struct representing nodes list 
binding time struct nlist bt binding time static pointer bt dynamic pointer 
constraint binding time assignments self referential structs limited 
actual choice limit influence rest chapter 
runtime allocation structures dynamic runtime memory allocation performed means library function malloc variants 
example call struct nlist malloc sizeof struct nlist returns pointer storage represent object type struct nlist 
prevents programmer allocating twice memory really needed convert returned pointer struct point 
clearly allocation scheme liberal automatic program analysis transformation 
shall suspend calls malloc cousins introduce special allocation function alloc restricted semantics 
case unix functions sbrk operating system call get chunk storage 
constraint call alloc typename shall perform return pointer suitably converted sufficient chunk memory represent object indicated type 
inform memory manager generating extension storage allocated 
case type partially static struct add declarations dynamic members global variables residual program 
alloc performed specialization time memory allocated generating extension run appears static context result assigned static pointer 
assume function delete functionality free 
handling runtime memory generating extension discussed detail section 
example consider program fragment allocates node initializes 
assume static pointer name static defn dynamic 
struct nlist np np alloc struct nlist np null np name np defn foobar printf name definition np name np defn call alloc static causes memory allocated definition alloc defn added residual program 
assignment np null initializes static null np name name field 
final assignment dynamic 
yields residual program 
char alloc defn alloc defn foobar printf name definition foobar alloc defn notice static pointers eliminated pointer traversal performed specialization time 
example automatic detection malloc calls safely replaced alloc requires analysis heap usage 
assume done prior generating extension transformation 
alloc variant exist base type pointer type user defined type 
generated automatically basis type definitions 
struct nlist struct nlist entry chain char name defined name char defn replacement text lookup look struct nlist lookup char struct nlist np np hash np null np np strcmp np name return np return null install put name defn int install char name char defn struct nlist np unsigned np lookup name null np alloc struct nlist np null np name name null return hash name np np delete np defn np defn defn null return return functions text substitution replacing dynamic allocation static allocation demonstrate specialization set functions implementing text substitution 
example stems kernighan ritchie kernighan ritchie page reproduced 
main result example replacement dynamic runtime allocation static allocation 
changes original program 
call malloc replaced call alloc install function changed return integer pointer installed node 
consider specialization sequence statements struct nlist np install foobar np lookup null printf replace np defn assumed second argument install unknown 
changes essential 
assure memory allocated specialization prevent struct nlist dynamic 
char alloc defn int install char defn alloc defn defn null return return install foobar printf replace alloc defn specialized version examination program text see struct nlist partially static struct name static defn dynamic 
function lookup manipulates pointers partially static structs classified static 
definition install defn dynamic 
specialized program due call install foobar 
specialization calls lookup evaluated statically 
runtime allocation replaced static allocation specialized program 
test statement evaluated true lookup static pointer np defn reduced alloc defn 
unions union resembles struct major operational difference time union represent value member henceforth memory represent largest member needs allocated 
suppose union split separate variables union int increase storage usage residual program considerably naturally depending number static members union 
avoid suspend unions 
constraint unions shall classified dynamic 
example splitting union straightforward 
standard specifies union contains members struct type initial member sequence common tag union syntax struct int tag 
expr stmt struct int tag 
stmt technically member defn struct nlist body lookup 
legal access shared member tag struct member stmt defined field expr stmt 
implies field tag split separate variables shared variable 
example experience restriction strict practice 
experiments needed clarify 
bit fields bit fields restrict storage member influence program specialization 
bit field specifications translated unchanged generating extension residual programs 
notice generating extensions executed directly representation problems encountered due programs relying particular layout struct 
input output previous sections assumed static input delivered parameters generating extension goal function 
section concerned reading writing standard input output files 
discuss standard library functions pow declared extern standard header files 
standard input output small programs read data standard input write result standard output 
naturally output shall occur generating extension executed 
constraint writes standard output shall suspended 
reading input streams allowed specialization care taken avoid duplication operations 
potential risk illustrated code 
int float dyn exp scanf scanf specialization code cause scanf called twice contrary normal execution 
user annotations indicate input calls performed execution generating extension 
control dependence analysis developed chapter employed detect warn dubious read calls 
leave extension 
constraint reads standard input shall suspended 
file access reading static input files discussed 
mini version printf void char fmt void values int arg char sval fmt putchar continue switch case printf int values arg break case printf double values arg break case sval char values arg sval sval putchar sval break default putchar break mini version printf case study formatted output printf output function printf friends takes format string number values converts values printable characters 
printf small interpreter format string program values input 
specializing respect format string interpretation overhead removed 
consel danvy 
contains mini version printf library function program stems kernighan ritchie kernighan ritchie page 
minor change variable length argument list takes array pointers values printed 
reason change apparent section 
suppose fmt static values dynamic 
loop controlled format string unrolled 
tests statements switch statements static 
output calls dynamic cf 
discussion section 
static fmt string 
specialized version shown example suggested olivier danvy 
void fmt void values char sval sval char values sval sval putchar sval putchar putchar putchar printf int values putchar printf function specialized respect 
running original specialized program times dynamic input value takes seconds respectively 
speedup 
naturally speedup depends static input larger static input yields larger speedup 
variable length argument lists means ellipsis construct functions defined taken variablelength argument list 
example declaration void printf char fmt 
specifies printf takes arbitrary number arguments format string 
calls function variable length argument list known specialized versions function created simple preprocess program specialized normally 
suppose function part library call sites unknown 
implies type number arguments known generating extension run 
complicates memory management renders binding time analysis hard 
standard definition 
argument front ellipsis 
constraint ellipses parameter shall suspended runtime 
case printf function studied previous section caused fmt suspended rendering specialization trivial 
believe variable length argument lists rare programs suspension reasonable 
implemented feature mix ignore rest thesis 
file access far assumed static values delivered goal parameters 
practice inputs read files generated functions discuss generating copying functions depend availability type information 
reading files broadly static input delivered specialization time 
material section pragmatically oriented 
reading files similar scanning standard input section 
user annotation instance form cmix fscanf employed indicate streams read specialization 
avoid duplication operations warnings static reads dynamic control user 
consider essential feature reasons discussed leave 
program normally consists translation units modules implementing different aspects system 
typically module reading initialization data structures module implementing computation 
normally specialization applied computation module little gained specialization input routines 
program system specialized follows 
computation module binding time analyzed transformed generating extension 
resulting generating extension linked functions open read close files 
real need reading files specialization 
error handling partial evaluation strict normal order evaluation 
reason partial evaluator executes branches dynamic standard execution executes 
example consider program fragment lookup function returns record affirmative case sets pointer point 
lookup name printf number count printf partial evaluation fragment dynamic static may go wrong 
example errors specialization time detected guarding potential expressions 
example safe pointers detect dereferencing null pointers trap handler 
implemented current version mix suspect expensive 
miscellaneous functions standard library important part example library defines functions declared math 
library functions declared extern 
remarkable exception scanf specialized similarly printf eliminating interpretation overhead 
partial evaluation termed hyper strict literature 
ti decl di fun fi gegen 
tm 
dn 
fl 


int generate goal 
goal declare residual struct declare residual globals goal goal 
return generating extension transformation recall section calls externally defined functions suspended 
unfortunate effect static call pow suspended replaced constant expected 
example reason suspending external functions may side effect global variables 
case pow function 
include math int main void double pow errno fprintf stderr error pow printf result library functions report errors external variable errno 
example static calls external functions side effect global variables evaluated specialization time provided definitions 
definition function side effect non local variables called pure 
pure functions detected ways user annotations automatically 
section outline analysis determine pure functions 
examples specifier pure indicate pure functions 
example mentioned functions declared math pure return errors global variable errno 
redefining functions invoke function problem circumvented 
declaring power function extern pure double pow double double call pow evaluated specialization time 
example decl di stmt sj fun 
dm dm 
dn 
sk 


decl di stmt si fun 
dm dm 
dn 
sk code 

locals 
xn xi return locals define residual variables cmixpendinsert entry cmixpendloop lab lab goto entry 
transformations functions correctness matters crucial program transformations preserve semantics subject programs 
fatal optimized program possesses different observational behaviour original program 
main motivation adopting generating extension approach assure correctness residual programs 
section summarizes generating extension transformation 
attempt proving correctness definition 
hope clear correctness generating extension transformation easier establish correctness symbolic evaluator 
figures summarize generating extension transformation 
input annotated program dynamic constructs indicated underline 
simplicity assume lifting static values dynamic contexts denoted explicitly means lift functions 
practice application sites lift functions discovered transformation 
rule address operator incorporate function identifiers 
assume dynamic indirect calls lifted statement level 
shown unparsing declarations decl type decl decl extern extern base type type code struct type struct struct type struct code pointer type type array fun type type decl di type type di transformation declarations struct decl di struct di struct union decl di union di union enum enum enum transformation type definitions concrete syntax 
type code type code type di code struct union call empty stmt exp switch case default exp stmt exp stmt stmt stmt sm sn exp stmt stmt switch switch stmt case case stmt stmt default default transformation statements part exp ei stmt 
en switch int case case fn default eo calls 
fn exp stmt exp stmt sm stmt sn stmt sm sn cmix test cmix test cmixpendinsert cmixpendinsert goto cmixpendloop cmixpendinsert goto cmixpendloop cmixpendinsert goto cmixpendloop exp stmt stmt switch similar stmt case similar stmt stmt default similar label exp smt sm stmt sm exp stmt stmt stmt ei stmt stmt stmt stmt goto stmt goto goto return exp stmt return return comp stmt si stmt 
sn 
transformations statements part exp stmt sm stmt sm cmix test cmix test cmixpendinsert cmixpendinsert goto cmixpendloop cmixpendinsert goto cmixpendloop exp stmt stmt cmix test cmix test cmixpendinsert cmixpendinsert goto cmixpendloop exp ei stmt stmt cmix test cmix test cmixpendinsert cmixpendinsert goto cmixpendloop cmixpendinsert goto cmixpendloop exp stmt return goto cmixpendloop const exp var exp struct indr array addr unary binary exp exp exp exp exp ei exp exp exp exp exp exp ei exp exp exp lift exp exp exp exp exp ei ei exp exp exp exp texp exp ei exp alloc exp alloc alloc exp alloc call pcall exp ei exp 
en 
exp ei exp 
en 
exp ei exp 
en 
exp exp exp exp assign exp ei exp aop aop comma exp ei exp exp ei exp ef 
en ef 
exp ei exp 
en 


em static exp ext exp ext exp ei exp aop aop exp ei exp sizeof exp sizeof cast exp exp transformation rules expressions exp exp memory management section concerned management static stores generating extension 
due presence assignments pointers considerably complicated functional languages 
example program may rely locations pointers may point objects unknown size 
execution generating extension necessary copies static values restore time 
furthermore implement sharing residual code active state compared previously encountered states 
memory management part generation extension library 
basic requirements recall part store computations carried called active store 
basically consists storage allocated static objects 
copy active store called static store 
copies active store generating function invoked order determine sharing residual function generated generation residual statement specialization branches residual code shared generation residual goto statement enable sharing target residual code shared 
copying comparison static values specialization may expensive memory consuming 
basic requirements memory management listed follows 

memory management support comparison active store static stores 

memory management implement copying active store new area 

memory management implement restoring static store active store 

memory management represent static stores compactly enable efficient comparison values 
requirements non trivial 
execution generating extension static values allocated program stack case local variables statically fixed locations case global variables heap 
consider generating function function static parameter type pointer integer code foo int 
parameter allocated program stack 
suppose foo called determined previously applied instance 
content parameter easily compared previous values comparison indirection harder 
suffice compare may point array case entries compared 
easy way determine size object points expression sizeof simply returns size ints size data structure 
compare example calls foo foo integer variable array 
specializer overcomes problem tagged representations static values conflicts underlying idea generating extensions static values represented directly 
describe solution section 
example see compact representation needed consider example 
suppose pixel image global static array 
pixel image int process image dyn exp plot point image save point image specialization function causes array image copied twice due dynamic 
generating extension uses twice storage ordinary execution 
clearly storage usage may grow exponentially 
example section describe storage model tries share copies static values possible 
extension analysis program detect copying objects needless object dead 
example may ask necessary copy restore active store apparently needed flow chart mix system gomard jones 
reason flow chart language support locations class values operations rely addresses 
update store henceforth implemented purely functional way scheme example copying state happens need manner 
example storage model describe storage model objects allocated location active store may shared copies 
copy state assign unique store number 
store number employed differentiate objects copied due processing different specialization points 
store description function location store number location sd loc stnum loc 
intuitively sd means copy object location store number located address sd image copy storage description copies static objects storage description example implemented hash table representing lists pairs store numbers locations locations 
example recall scenario example assume image allocated location say 
due dynamic conditional static state copied twice store description contain bindings 
says copies image store numbers located address 
see 
example assume methods storage description find loc stnum loc insert loc size stnum loc restore loc size stnum loc defined follows 
method find returns location th copy object location method insert copies object location size gives store number method restore restores th copy object originally location size example example continued 
call find returns address 
call restore copies image array original position 
example state descriptions copy object location size known 
object contains pointer referenced object copied 
determine size objects state descriptions introduced 
state description associated generating function global state 
records size location static objects 
object object function bounded 
object function implements copying restoring comparison object type 
example suppose int static variables 
corresponding state description locals sizeof state int sizeof state int sizeof state ptr state int state ptr object functions integer non function pointers respectively 
example state descriptions come existence disappear functions represented automatic variables generating functions plus global state 
location state descriptions currently active known stack 
example generating function entered state description pushed stack 
function return popped 
code int int locals 
push state locals pop state return pop fun state description stack contains addresses active state descriptions 
state description function active function invoked till returns 
notice state description initialized means address operator contain addresses parameters local variables 
example suppose aim find size object pointed 
done scanning state descriptions state description stack object allocated location points 
example consider string constant char str hello 
string constants assigned need copy specialization points comparison accomplished pointer equality 
example object copy functions copy object base type suffices know location size 
size predefined type determined sizeof operator 
case user defined types struct copying depends definition 
example member pointer type referenced object taken account 
object function associated type 
example struct defined follows struct int 
copy object type object function copies members calls object function objects points 
example object function takes specification flag copy compare restore location object handle store number 
returns size object treats 
algorithm copying active store 
algorithm copy state corresponding stat desc 
state number new unique state number copy objects state description loc size sfun stat desc copy obj loc size sfun copy object loc size store number void copy obj void loc size size int fp insert loc size loc loc size sfun copy copying works follows 
object listed state description auxiliary function copy obj called 
copies data object storage description function insert calls object function base object 
example copy object function int simple 
copy int object void state int void loc int return sizeof int copy object function pointers uses state description stack determine size referenced object 
copy pointer object function pointer void state ptr void loc int loc null null pointer loc size lookup void loc copy obj loc size return sizeof void example example case array data object entire array object entry 
object functions base types pointers predefined library 
object functions user defined types defined part generating extension transformation basis struct definition 
example state function struct int 
void state void loc int loc struct loc null loc size lookup loc copy obj loc size return sizeof struct notice pointer member struct object just member copied 
introduces slight overhead matter practice 
example note 
standard allows pointer point past array pointer dereferenced 
consider situation 
definitions int points 
program rely allocated continuation case 
confuses memory management points 
safe copied 
algorithms restoring comparing objects similar algorithm omitted 
memory management may expensive unacceptable practice 
recall side effects normally suspended consequence local global objects needs copied 
heap allocated data structures seldom copied 
example memory usage reduced dramatically due observation 
sharable functions commit side effects necessary copy non local objects assigned 
state description employed determined object local non local 
example predicate predicate shall return true function static parameters global variables match previous invocation function specified sharable 
means copy values function specialized associated residual function 
minor complication taken account 
parameters function necessarily allocated location program stack time function called 
easy program problem 
need save copy functions shared 
improved sharing code development far sufficient handling static stores generating extension 
example dynamic goto transformed statements cmixpendinsert label goto cmixpendloop cmixpendinsert uses insert function copy active store 
increase amount sharing specialization restricted live variables 
example assume exp dynamic expression goto statements specialized 
exp goto goto program point dead specialized twice differs goto statements 
specializing live variables program point shared 
observation originally setting flow chart language gomard jones 
example accomplish extend function cmixpendinsert take bit string cmixpendinsert label cmix cmixpendloop indicates live variables 
chapter develops variable analysis computes desired information 
example function increments pointer 
ptr increment int int ptr int return suppose ptr specialized respect instance 
normally content indirection employed determine sharing residual version int ptr 
indirection body taken account 
analysis developed chapter recognizes situations 
example heap allocated memory recall runtime memory allocation specialization time performed means mix function alloc 
calls malloc cognates suspended 
allow tracing pointers pointing heap allocated objects alloc maintain state description heap 
heap allocated data structures tend large copying comparing heap allocated data structures kept minimum 
currently automatic strategy side effects heap allocated objects allowed 
example functions standard library allocate memory instance 
applications undesirable suspend calls memory allocating functions 
reason mix contains definitions library functions alloc function storage allocation 
example final 
data structures may circular 
complicates copying comparing restoring objects seen far accumulated prevent circular processing 
code generation section briefly code generating functions implemented library presents improvements 
gives nicer looking residual programs may improve specialization 
algebraic reductions consider dynamic expression transformed code generating calls 
example non trivial suppose result complicated static evaluation 
obviously implementing algebraic reduction plus operator eliminated residual program 
general improve efficiency residual programs optimizing compiler kind transformations yields nicer residual programs 
algebraic reduction serves purpose 
example useful algebraic rules appear test 
notice reductions safe semantics guarantees evaluated 
example beware rule discards possibly non terminating expression 
deciding dynamic tests consider strstr example section recall conjunct needle haystack commented prevent loop dynamic 
section shows extension problem 
consider specialization dynamic statement 
previous sections branches get specialized 
may case test decided dynamic 
case need specialize branches transition compressed 
accomplished follows 
statement transformed code test switch test case test true goto gegen case test false goto default test undecidable specialize test cmixpendinsert cmixpendinsert goto cmixpendloop goto goto function returns argument representation non zero constant zero constant 
example applying line test expression allows strstr function specialized rewriting 
example improvement implements mix line strategy determination value binding time jones chapter 
step positive context propagation consider chapter 
example improvement implemented mix slight change 
test expression constant generates jump corresponding branch 
example domain re sharing previous section defined predicate return true exact match 
strict requirement prevents sharing semantically equivalent functions 
section introduces domain re lists sufficient criteria sharing specialized functions 
discussion centered function specialization techniques carry program point specialization 
recall dynamic possibly unknown 
domain specialization functions specialized respect values base type struct type pointers composed types 
definition set types values functions specialized called domain specialization 
necessary requirement type domain specialization equality operator defined type 
example higher order partial evaluators similix bondorf consel representations closures recognize equality functions 
values comparable 
domain re section convenience assume global variables part function arguments 
far implicitly assumed residual function shared static arguments match 
cases excessively strict criteria 
consider example function choose return depending int choose int int int return 
assume specialized respect static 
strict comparison determine sharing get specialized version value 
clearly suffices construct versions non zero zero 
example remedy situation small trick 
generating extension choose code choose int return name function specialize 
trick normalize compared previous values 
naturally requires insight function 
example definition function arguments assume static 
specialized version respect instance 
vm 
domain re dor function defined largest set values vm ruf uses term equivalently domain re ruf weise 
believe terminology intuitive suggestive 

vn 
vn vm 
vn 
vm vm vm 
vn domain domain re set static values particular residual function computes result dynamic arguments 
example suppose choose specialized respect resulting choose 
dor choose 
notice domain re defined respect residual function 
example residual call met specialization static arguments domain re residual function shared 
general domain re uncomputable approximation 
live variables domain re previous section claimed specialization respect live variables gives better sharing 
example consider function argument contribute value returned 
int foo int int return suppose static 
dor foo 
specialization performed respect live variables residual version shared values desired 
example liveness information yields approximation domain re 
problem liveness information take value dependencies account 
example fails see outcome 
example consider ptr function 
residual version shared calls value content indirection immaterial 
classical live variable analysis recognize dead 
analysis develop chapter 
example specialization sharing unfolding dynamic function subject program handled ways specialization specialized residual versions possibly shared ii specialized unconditionally residual versions shared iii unfolded caller 
seen previously choice treatment interacts binding time classification side effects may influence greatly result specialization 
time writing automated strategy mix system 
functions specialized shared specified user 
section outline possible strategy 
noted easy find examples strategy fails 
sharing specialization recall share residual versions function side effects function suspended reason static variables may need updating sharing specialization time 
sharing abandoned side effects allowed side effects dynamic control 
example observe allowing function accomplish static side effect global variable implies callers function accomplish side effects 
side effects back propagate 
example preferable residual functions shared feasible possible reduce size residual program risk non termination 
cases static side effects necessary 
example function initializing global data structures permissible allow init function side effect called need sharing exists 
necessary requirements unconditional specialization function listed 
function non recursive terminal function calls functions close main function program invocations graph 
recall functions possibly referred function pointer shall contain static side effects 
requirements justified follows 
function recursive folding necessary prevent infinite function specialization 
function called terminal function calls functions 
condition included reduce code duplication 
condition ensures side effects back propagate functions case long invocation chain main calls foo calls bar calls baz contain sideeffect causing bar foo non sharable 
mix system supports specifiers specialize unfold 
example runtime memory allocation means alloc performs sideeffect heap 
strategy runtime allocation performed dynamic recursive functions deferred runtime 
example chapter side effect analysis detect side effects possibly dynamic control 
needed implement sharing strategy 
unfolding strategy unfolding strategy prevent infinite unfolding avoid extensive code duplication 
original mix call unfolding detection inductive arguments 
functions static inductive parameter unfolded sestoft 
scheme partial evaluator unfolds calls appearing branch dynamic jones 
similix system strategy dynamic loops broken insertion called sp functions specialization functions 
calls functions sp functions unfolded bondorf 
time writing implemented unfolding strategy mix 
functions unfolded specialization specified user unfold specifier 
reasons 
unfolding complicates handling pending list memory management introducing overhead generating extensions 
secondly prevent infinite unfold strategy conservative post unfolding needed anyway 
undesirable unfolding big functions called 
size number times residual function called determined specialization specialization 
reasons practical defer unfolding post processing stage advanced decision strategies unfolding employed hwu chang 
example inlining function foo clearly undesirable small 
foo notice may case number static call sites function unfolding undesirable anyway 
example necessary requirements function unfolded specialization non recursive called function pointer 
clearly unfolding recursive function loops 
equivalent similix adapted break loops 
functions called function pointers specialized unfolding technique function call site indirectly called functions unfolded 
currently believe function unfolding possible done post processing line unfolding may improve binding time classification abandoned completely 
imperfect termination generating extensions suffer termination problems ordinary program specializers may fail terminate programs normally 
reason extension executes branches dynamic normal execution executes 
non termination may due infinite transition compression case static loops simply subject program loops static input independently dynamic data 
program specializer accepted loop situation ideally terminate cases 
example generating extension lines loops 
int dyn exp hinder non termination variable generalized 
example jones formulated strict terminating binding time analysis order functional language inductive arguments jones 
holst refined termination analysis proved correctness holst 
prevailing idea analyses static value grows transition static value decrease 
computed dependency analysis approximates dependencies variables program point 
methods suitable partial evaluation analyses rely downward closed domains example handle example 
investigated methods time writing solution 
related reported chapter continues endeavor automatic specialization optimization imperative programs 
comprehensive description refer jones 
partial evaluation partial evaluation constructive realization theorem 
proof theorem mainly concerned existence aim partial evaluation general program specialization efficiency 
futamura formulated futamura projections practical experiments conducted futamura 
experiments began beckman partial evaluator beckman 
time turchin described super compilation technique subsumes partial evaluation turchin 
ershov studied partial evaluation small imperative languages ershov 
jones sestoft developed implemented partial evaluator subset lisp jones 
basic principles bondorf danvy developed similix partial evaluator handles substantial higher order subset scheme programming language bondorf consel developed similar language consel 
partial evaluation imperative languages partial evaluation mixed computation originally formulated small imperative languages ershov ershov ershov 
gomard jones developed line self applicable partial evaluator flow chart language lisp expressions sole data structure gomard jones jones 
author developed implemented line self applicable partial evaluator subset programming language including functions global variables arrays extent pointers andersen andersen andersen 
specializer kernel successfully self applied generate compilers compiler generator 
meyer described line partial evaluator parts pascal excluding pointers meyer 
pugh applied partial evaluator small language hard real time systems pugh 
baier developed partial evaluator subset fortran baier 
taken somewhat different approach partial evaluation fortran 
aim understand programs specialization input interest 
generating extension generators main motivation favor generating extension opposed traditional specialization preservation programs semantics 
issue prevailing optimizing compilers attempt compile time evaluation expressions 
thompson suggested compile time expressions executed underlying hardware compile time avoid erroneous interpretations aho exactly generating extensions execute static constructs 
beckman el developed compiler generator subset lisp language beckman 
aim optimize compilers project ahead time precise semantics foundation lacking 
ghezzi study program simplification generalization mixed computation ghezzi 
symbolic evaluation program constraints program predicates collected exploited expression reducer theorem prover 
example branch predicate recorded true 
coen extended methods incorporated ada coen 
describes hand conversions programs generating extension pascal framework 
mainly overcome problem doubly encoded pro grams self applying specializers strongly typed languages holst launchbury suggested hand writing compiler generator cogen holst launchbury 
small ml language side effects example language 
birkedal developed compiler generator core standard ml language birkedal 
system specialize functions respect higher order values exceptions 
specialization pattern matching yield significant speedups 
bondorf implemented cps cogen untyped lambda calculus bondorf 
cps style allows specialization time static evaluations dynamic contexts carried 
slightly different approach deferred compilation investigated leone lee leone lee 
aim defer code generation runtime input available 
function calls compiled calls generating functions produce specialized versions function machine code 
generating jump code performed 
preliminary experiments show speedup 
transformations imperative languages program transformation techniques formulated functional logic programming languages fold unfold transformations burstall darlington supercompilation turchin finite set differencing cai paige 
fundamental reason complicated semantics imperative languages side effects pointers 
chapter study driving strictly powerful transformation partial evaluation 
described transformation full ansi programming language room improvements 
structures 
experience structs complicated data structure specialize 
include methods passing partially static structs functions binding time improving transformations 
dynamic memory allocation 
thesis assumed user identifies runtime memory allocations replaces alloc calls 
preferably course system automatically 
generally treatment heap allocated data structures improved 
fruitful way proceed may inferring structure heap allocated data structures 
example knowing pointer points singly linked list may allow static binding time separation 
manual specification data structures proposed hendren hendren hummel klarlund schwartzbach klarlund schwartzbach 
suspect commonly data structures single double linked list binary trees inferred automatically involved pointers annotated 
memory 
generating extension memory usage explodes 
copying static part store specialization points problematic may easily exhaust memory slows specialization 
analysis may employed free allocated memory certain saved state needed anymore 
example known generating function called call signature deleted 
analysis detect similar calls function occur residual functions shared call signature discarded 
various techniques suggested investigated 
termination 
generating extensions suffer embarrassingly imperfect termination properties 
existing methods assuring termination suitable imperative languages 
methods improving termination needed 
probably coupled program transformations avoid excessive conservative binding time annotations 
approximation dor 
residual code sharing version mix poor 
analysis approximation domain re improve 
possible way may approximation parameter dependency function results backward analysis 
unfolding sharing strategies 
currently line unfolding strategy strategy unconditional specialization functions 
analysis program invocation graph possible 
developed described generating extension generator ansi programming language 
generator takes binding time annotated program converts generating extension produces specialized versions original program 
major concern automatic program transformation preservation semantics 
argued specialization means generating extensions superior traditional specialization symbolic evaluation 
furthermore described advantages 
studied specialization pointers structures arrays runtime memory allocation gave generating extension transformation constructs 
furthermore developed generating extension library implementing memory management code generation 
considered propagation partially known information algebraic reductions reduction 
implemented generating extension generator mix system 
chapter reports experimental results 
chapter pointer analysis develop efficient inter procedural pointer analysis programming language 
analysis approximates variable pointer type set objects may point program execution 
information improve accuracy analyses 
language considerably harder analyze example fortran pascal 
pointers allowed point stack heap allocated objects address operator employed compute address object lvalue type casts enable pointers change type pointers point members structs pointers functions defined 
traditional pointer analysis equivalent alias analysis 
example assignment aliased denoted alias pair chapter take approach 
object pointer type set objects pointer may point approximated 
example case assignments result analysis map 
economical representation requires storage suitable analyses 
specify analysis means non standard type inference system related standard semantics 
specification constraint formulation derived efficient inference algorithm developed 
non standard type inference provides clean separation specification implementation gives considerably simpler analysis previously reported literature 
chapter presents technique inter procedural constraint program analysis 
context sensitive analysis functions achieved copying constraints 
increases number constraints exponentially slows solving 
method constraints vectors pointer types solved 
way constraint generated intra procedural case 
pointer analysis employed mix system determine side effects binding time analysis 
lvalue objects coincides objects said aliased 
alias instance introduced pointer global variable created means address operator 
aim alias analysis approximate set aliases runtime 
chapter related somewhat different pointer analysis programming language 
pointer variable computes set locations pointer may point 
languages pointers call parameters alias analysis core part data flow analyses 
example live variable analysis expression worst case assumptions pointer information may visible objects subsequently marked live 
clearly renders live variable analysis nearly useless 
hand known aliases possible need marked live 
traditionally aliases represented equivalence relation locations aho 
example alias introduced due expression represented alias set 
suppose expressions added program 
alias set aliases induced aliases 
apparently size alias set may evolve quickly language multi level pointers experimental evidence landi alias analysis reports program point specific aliases line program landi 
alias sets excessively general applications 
needed answer objects may pointer point 
analysis chapter answer question 
harder analyze 
literature contains substantial amount alias analysis fortran languages see section 
programming language considerably difficult analyze reasons include multi level pointers address operator structs unions runtime memory allocations type casts function pointers separate compilation 
example consider assignment adds point relation assuming points syntactically expression 
single level pointers variable updated syntactically expression 
possible pointers heap stack allocated objects opposed pascal abandon 
shall mainly concerned analysis pointers stack allocated objects due specific application 
special characteristic language implementation defined features supported standard 
example cast integral values pointers 
easily shown call single level pointers simulate multi level pointers 
recall programs relying implementation defined features non strictly conforming 
suppose long table array addresses 
cast int table renders implementation defined accordingly worst case assumptions case 
points analysis object pointer type determine safe approximation set locations pointer may contain program execution possible input 
special case function pointers 
result analysis set functions pointer may invoke 
example represent point information map program variables sets object names 
consider program 
int main void int fp char char fp strcmp safe point map fp strcmp minimal map 
example point relation classified static dynamic depending creation 
case array int name statically points object representing content array 
pointer struct points suitable converted initial member iso 
accurate static point information collected single pass program 
point relations created program execution called dynamic 
examples include creates point relation alloc call returns pointer object returns pointer string 
general value setting functions may create dynamic point relation 
example point analysis program char compare int char char char fp char char fp 
return fp reveal fp 
example easy see point map carries information alias set compact representation 
treat arrays aggregates 
set pointer analysis chapter develop flow insensitive set point analysis implemented constraint solving 
set analysis consists parts specification inference algorithm 
specification describes safety pointer approximation 
set inference rules pointer abstraction map fulfills rules map safe 
gives algorithm independent characterization problem 
constraint characterization specification give constraint solving algorithm 
constraint analysis works phases 
constraint system generated capturing dependencies pointers locations 
solution constraints iterative solving procedure 
example consider program fragment example 
writing tp abstraction constraint system generated tp tq tq tfp strcmp interpretation constraint tq objects may point contain 
example constraint analysis resembles classical data flow analysis stronger semantical foundation 
shall borrow techniques iterative data flow analysis solve constraint systems finite solutions kildall 
overview chapter chapter develops flow insensitive context sensitive constraint point analysis programming language structured follows 
section discuss various degrees accuracy value flow analysis implement intra inter procedural analysis flow sensitive versus flow insensitive analysis 
section considers aspects pointer analysis section specifies sticky flow insensitive pointer analysis defines notion safety 
section give constraint characterization problem prove correctness 
section extends analysis context sensitive inter procedural analysis 
sticky analysis merges calls function resulting loss precision 
technique context sensitive constraint analysis static call graphs 
section presents constraint solving algorithm 
section discuss algorithmic aspects emphasis efficiency section documents usefulness analysis providing benchmarks existing implementation 
flow sensitive analyses precise flow insensitive analyses 
section investigate program point constraint pointer analysis show multilevel pointers render kind analysis difficult 
section describe related section presents topics concludes 
pointer analysis accuracy efficiency precision value flow analysis roughly characterized properties flow sensitivity inter procedural vs intra procedural 
improved accuracy normally implies efficiency storage usage 
section discuss various degrees accuracy relevance respect programs 
flow insensitive versus flow sensitive analysis data flow analysis takes control flow account called flow sensitive 
flow insensitive 
difference conspicuous treatment statements 
consider lines code 
int test flow sensitive analysis records branches assigned address respectively 
branch information merged mapped 
discrimination branches important instance contain function calls foo bar respectively 
flow insensitive analysis summarizes pointer usage states may point branches 
case spurious point information propagated foo bar 
notion flow insensitive flow sensitive analysis intimately related notion program point specific versus summary analysis 
analysis program point specific computes point information program point 
analysis maintains summary variable valid program points function program case global variable termed summary analysis 
flow sensitive analyses inevitably program point specific 
flow sensitive versus sensitive analysis trade accuracy efficiency flow sensitive analysis precise uses space slower 
example flow insensitive flow sensitive analysis 
flow insensitive flow sensitive int main void int main void int int foo foo analysis necessarily compute complete set pointer variable bindings interesting program points 
notice flow insensitive case spurious point information propagated function foo 
example focus flow insensitive summary pointer analysis reasons 
experience programs consist small functions 
extra approximation introduced summarizing program points appears minor importance 
secondly program point specific analyses may unacceptable amount storage 
pragmatic argument matters large programs analyzed 
thirdly application analysis accommodate program point specific information binding time analysis program point insensitive 
flow sensitive pointer analysis improve binding time separation modulo propagation spurious information believe negligible 
investigate program point specific pointer analysis section 
poor man program point analysis simple transformation possible recover accuracy specific analysis collecting information program point 
assignment variable independent pointer variables called initialization assignment 
idea rename pointer variables initialized 
example poor man flow sensitive analysis example 
variable copied 
int main void int foo renaming variables clearly done automatically 
example transformation fails indirect initializations assignment points pointer variable 
intra inter procedural analysis intra procedural analysis concerned data flow function bodies worst call assumption function calls 
chapter shall intra procedural strict meaning functions analysed context independently 
inter procedural opposed fortran tends long functions 
flow sensitive analyses gain transformation including binding time analysis 
main void px foo py foo return foo int return inter procedural call graph program example analysis infers information consideration call contexts 
intra procedural analysis called monovariant sticky inter procedural analysis known polyvariant 
example consider program 
int main void int foo int int px py px foo return py foo return intra procedural analysis merges contexts calls computes pointto information px py 
inter procedural analysis differentiates calls 
illustrates inter procedural call graph 
example inter procedural analysis improves precision intra procedural analysis preventing calls interfere 
consider depicts inter procedural call graphs program example 
goal value returned call erroneous propagated second call vice versa 
information propagated valid realizable program paths sharir pnueli 
control path realizable inter procedural exit path corresponds entry path 
inter procedural information inter procedural analysis mainly concerned propagation value flow information functions 
aspect inferred information optimization drive analyses 
classical inter procedural analyses produce summary function calls merged 
clearly degrades number possible optimizations 
example suppose apply inter procedural constant propagation program containing calls bar bar 
classical analysis merge calls henceforth classify parameter non const ruling compile time execution statement callahan 
example aggressive approach inline functions caller copy functions 
known procedure cloning cooper hall 
develop flexible approach function annotated context specific information summary 
stage function cloned desired 
return issue chapter postpone decision clone function 
assume program static call graph available 
recall graph approximates invocation functions assigns variant number functions call contexts 
example function called contexts function variants 
function textually copied contexts useful imagine variants function parameters local variables exist 
denote variable corresponding th variant 
may 
certainty pointer abstraction characterized may 
may point analysis computes pointer set locations pointer may point runtime 
point analysis computes pointer set locations pointer point 
may analysis known existential universal analysis 
case exists path point relation valid case point relation valid paths 
example consider live variable analysis expression 
point information marked live 
basis may point information marked live 
example shall consider may point analysis chapter 
pointer analysis section briefly consider pointer analysis intricate features separate compilation external variables non strictly complying expressions type casts interaction pointer analysis 
structures unions supports user defined structures unions 
recall section struct variables sharing common type definition separated different names parsing 
parsing value flow analysis unions types objects may flow 
relevant information includes number calls size function number calls functions 
example definitions struct int variants struct type assigned variables assigned type struct 
suppose program contains assignment 
value flow analysis merge type definitions type struct say type struct say 
example observe struct variables different type flow 
struct variables type may flow 
exploit fact way 
point information field members struct variable associated definition struct struct objects 
example point information member assuming definitions example represented definition struct 
definition common objects type 
important consequence case assignment fields need updated respect value flow analysis taken care 
pointer analysis factorized sub analyses 
struct value flow analysis 
point propagation analysis chapter describes propagation analysis 
continue term pointer analysis propagation analysis 
recall chapter initial members unions truly shared 
importance pointer analysis member pointer type 
simplicity take aspect account 
extension straightforward tedious describe 
implementation defined features program comply standard ways 
strictly conforming program shall depend implementation defined behavior conforming program allowed 
section consider type casts cases non strictly conforming 
example cast integral value pointer conversely behaviour 
cast pointer pointer alignment requirement back strictly conforming iso 
example implementation defined features described accurately analysis 
approximate pointers may point object unique location unknown 
definition pointer 
pointer abstraction maps unknown unknown may point accessible objects runtime 
location unknown corresponds know worst case 
example goal parameters program described unknown main function int main int argc char argv 
approximated argv unknown 
example chapter consider setjmp longjmp macros 
dereferencing unknown pointers suppose program contains assignment unknown pointer unknown 
case live variable analysis implies worst case assumptions 
problem affects pointer analysis 
consider assignment unknown 
implies assignment pointers may point 
worse assignment unknown renders pointers unknown 
shall proceed follows 
analysis reveals unknown pointer may dereferenced left hand side assignment analysis stops worstcase message 
corresponds inaccurate pointer approximation possible 
analyses depending pointer information worst case assumptions pointer usage 
assume unknown pointers dereferenced left hand side assignment 
section describes handling worst case behaviour 
separate translation units program usually consists collection translation units compiled separately linked executable 
file may refer variables defined units means extern declarations 
suppose pointer analysis applied single module 
consequences 
potentially global variables may modified assignments modules 
safe worst case assumptions unknown global variables 
secondly functions may called modules unknown parameters 
safe functions approximated unknown 
obtain results trivial shall avoid separate analysis assume relevant translation units merged consider solely monolithic programs 
subject chapter separate program analysis outlines separate pointer analysis development chapter 
constraint global variables pointer type may modified units 
ii functions assumed static translation unit analyzed 
convenient sustain notion object external 
example describe function returning pointer unknown object 
safe pointer abstractions pointer abstraction map program objects variables sets locations 
abstraction safe object pointer type set concrete addresses may contain runtime safely described set locations 
example pointer may contain locations lx location lg location runtime safe abstraction 
section define locations precise notion safety 
specification employed check safety abstraction 
specification serves foundation development constraint pointer analysis 
locations pointer variable containing distinguished constant null address 
due casts pointer principle point arbitrary address 
object set logically related locations bytes representing integer value bytes representing struct value 
pointers may point functions consider functions objects 
object allocated program stack local variables fixed location strings global variables code space functions heap runtime allocated objects 
shall concerned run time allocated objects brought existence alloc calls 
assume calls labeled uniquely 
label alloc denote set anonymous objects allocated alloc call site 
label may thought pointer relevant type 
example consider program lines 
int fp void struct ps fp foo ps alloc fp foo ps 
example consider application address operator 
similar alloc call returns pointer object 
denote set objects application returns assume assume unique labeling 
points object pointer definition set locations aloc defined inductively follows objects allocated means malloc considered unknown 
name global variable aloc 
parameter function variants aloc 
local variable function variants aloc 
string constant aloc 
name function variants aloc 
name function variants aloc 
label alloc function variants aloc 
label address operator function variants aloc 
aloc denotes object type array aloc 
type name struct union type aloc 
aloc type struct union aloc fields unknown aloc 
names assumed unique 
clearly set aloc finite programs 
analysis maps pointer element set aloc 
element unknown denotes arbitrary unknown address 
means analysis abstracts follows 
function invocations collapsed program static call graph see chapter 
means function variants instances parameters local variables taken account 
instance due limit imposed recursive functions instances parameters recursive function invocation chain identified 
location associated function denotes return location unique location delivers result value 
arrays treated aggregates entries merged 
fields struct objects name merged definition struct int fields collapsed 
example merging struct fields may seen excessively conservatively 
recall assume programs type separated parsing analysis applied identifier type struct objects may flow see section 
example unique location unknown denotes arbitrary unknown address valid illegal 
definition locations respect particular program continue aloc independently programs 
furthermore assume type object location denotes available 
example write aloc struct type object aloc denotes struct type 
implicitly assume binding function designator parameters 
function identifier write xi parameter xi pointer abstraction pointer abstraction aloc aloc map locations sets locations 
example consider assignments 
int extern int ep int int malloc sizeof int ep pointer assigned value non portable cast 
approximate unknown 
pointer assigned result malloc 
general pointers returned external functions approximated unknown 
pointer assigned value external variable 
approximated unknown 
refinement approximate content external pointers unique value extern 
giving accurate warning messages pursue 
example pointer abstraction fulfill requirements justify 
definition pointer abstraction aloc aloc map satisfying 
aloc base type unknown 

aloc struct union type 

aloc function designator 

aloc type array 

unknown unknown 
condition requires objects base types abstracted unknown 
motivation value may cast pointer unknown general 
second condition stipulates value struct object empty set 
notice struct object uniquely identified type 
fourth condition requires array variable points content 
content unknown location unknown 
define aloc unknown unknown 
pointer abstractions ordered set inclusion 
program minimal pointer abstraction 
program desire minimal safe pointer abstraction 
reality lvalue 
convenient consider pointer content 
safe pointer abstraction intuitively pointer abstraction program safe input object pointer may point runtime captured abstraction 
abstraction function loc aloc defined obvious way 
example lx location parameter invocation function corresponding th variant lx execution path initial program point initial program store denoted pn sn sn store program point pn 
program initial store mapping program input parameters goal function 
pn program point ln locations visible variables 
pointer abstraction safe respect ln sn pn sn program safe pointer abstraction 
define fulfills definition extend aloc pointer type unknown 
obviously safe useless abstraction 
definition safety considers monolithic programs external functions variables exist 
interested analysis translation units parts program may undefined 
example consider piece code 
extern int int external variable obviously established 
inevitably approximated unknown 
example definition 
mm program consisting modules mi 
pointer abstraction safe mi program points pn initial stores pn sn ln sn defined mi ln unknown defined mi mi ln set visible variables program point simplicity regard array visible variable regard labels alloc calls pointer variables 
example suppose introduced location extern denote contents external variables 
example abstracted extern 
operational difference extern unknown 
example compute approximation safe pointer abstraction 
example result implementation defined cast int integer variable unknown definition may allow accurate abstraction 
pointer analysis specification specify flow insensitive summary intra procedural pointer analysis 
postpone extension inter procedural analysis section 
specification employed check pointer abstraction safe program 
due lack space rules declarations expressions interesting cases describe cases informally 
specification form inference rules 
argue modulo omitted part specification program fulfills rules context pointer abstraction safe pointer abstraction 
rules fail pointer abstraction satisfy definition 

suppose definition extern declaration 
safety respect depends type lemma decl definition 
aloc aloc pointer abstraction respect defined unknown unknown 
proof straightforward verify definition fulfilled 
right rules external variables shown 
extern declaration 
pointer abstraction 
notice rules require external pointers approximated unknown stipulated definition 
omitted rule function definitions tf di dj sk require 
specify flow insensitive analysis safety pointer abstraction respect expression independent program points 
map aloc aloc pointer abstraction respect expression pointer abstraction respect variables occurring lemma expr expression pointer abstraction respect safe provided exist aloc decl base struct union ctype ptype unknown ptype ptype struct ptype union ptr ptype array ptype ptype extern unknown unknown struct unknown union unknown ptype fun ptype di ptype di pointer abstraction declarations pexp pexp defined 
intuitively rules infer lvalues expression example lvalue variable recall consider intra procedural analysis 
informal justification lemma 
omit formal proof 
justification formal proof induction evaluation length 
argue safe evaluation safe 
constant unknown lvalue lvalue string name 
motivation approximating lvalue constant unknown empty set obvious example int 
lvalue variable approximated name 
consider struct indexing type objects subexpression denotes lvalues fields rules pointer dereference array indexing pointer abstraction describe lvalue dereferenced objects 
notice points lvalue lvalue approximated 
rule address operator uses label placeholder indirection created 
effect unary binary operator applications described means op aloc aloc 
omit formal specification 
example suppose point array consider pointer subtraction 
int int unknown result integer 
consider 
get int int unknown pointer arithmetic allowed shuffle pointer outside array 
example variant function 
recall operator overloading assumed resolved parsing 
external function delivers result unknown location result unknown 
consider rules functions calls 
content argument lvalue contained description formal parameters 
result application returned called function return location 
case indirect calls possible functions taken account 
example case program fragment int fp int fp foo fp bar fp foo bar functions integer pointer parameter fp foo bar due applications address operator foo bar due indirect call 
lvalue call foo bar 
example rules pre post increment expressions trivial 
consider rule assignments 
content locations left hand side contain content right hand side expression 
recall assume unknown pointers dereferenced 
example consider assignments extern int int extern unknown points 
assignment may assign pointer unknown object pointer type 
extension shown section 
example lvalue comma expression determined second subexpression 
sizeof expression lvalue approximated unknown 
consider rule casts 
uses function cast type type aloc aloc defined follows 
recall consider intra procedural sticky analysis 
const string var struct indr array address unary binary alloc extern user call assign comma sizeof cast pexp unknown pexp pexp pexp struct pexp pexp pexp pexp pexp pexp pexp le pexp pexp pexp ei oi pexp op oi pexp alloc pexp ei oi pexp ef 
en unknown pexp ei oi xi oi pexp 
en pexp xi oi pexp 
en pexp pexp pexp pexp pexp pexp pexp aop pexp pexp pexp pexp sizeof unknown pexp pexp cast pointer abstraction expressions cast case unknown unknown type member struct casts base types change object lvalue 
casts pointer type integral type opposite implementation defined approximated unknown 
recall pointer struct object points suitably converted member 
implemented case cast struct pointer pointer 
denote name member 
conversions change lvalue referenced objects 
definition accordance standard iso paragraph 
justification specification statements uses rules expressions 
case return pexp return specifies return location function encapsulating statement value expression conjecture program map aloc aloc safe pointer abstraction iff rules fulfilled 
intra procedural pointer analysis section presents constraint formulation pointer analysis specification 
section extends analysis inter procedural analysis section describes constraint solving 
pointer types constraint systems constraint system defined set constraints pointer types 
solution constraint system substitution pointer type variables sets locations constraints satisfied 
syntax pointer type defined inductively grammar oj locations indexing function type variable oj aloc identifier 
pointer type set locations dereference type indexing type function type type variable 
pointer types oj ground types 
range pointer types 
object aloc non functional type assign type variable includes return location function object aloc function type associate type td tf td type variables assigned parameters type specifier assign type variable 
aim analysis instantiate type variables element aloc map safe pointer abstraction 
variable assignment substitution tvar ptype type variables ground pointer types 
application substitution type denoted juxtaposition meaning pointer type defined relatively variable assignment 
definition suppose variable assignment 
meaning pointer type defined sto struct ti ti st unique type variable associated object meaning type determined variable assignment 
intuitively denotes objects oi meaning contents objects case indexing meaning equals content fields object denote 
constraint system multi set formal inclusion constraints pointer types denote constraint systems 
solution constraint system substitution tvar ptype type variables ground pointer types identity variables occurring constraints satisfied 
definition define relation iff aloc ti iff ti substitution tvar ptype solves constraint variable assignment notice function type contra variant result type 
set solutions constraint system denoted sol 
constraint systems consider solution 
order solutions subset inclusion 
constraint system minimal solution accurate solution pointer analysis problem 
constraint generation give constraint formulation pointer analysis specification previous section 
definition program 
pointer analysis constraint system defined cdecl cfun constraint generating functions defined 
implicitly assume constraint unknown included constraint systems 
implements condition definition pointer abstraction 
goal parameters recall assume goal function called outside 
content goal function parameters unknown 
define tx unknown goal parameters goal function example main function int main int argc char argv unknown unknown content unknown program start 
example declaration decl declaration 
constraint system cdecl defined 
lemma decl declaration 
cdecl solution aloc defined 
proof see constraint system cdecl solution observe trivial substitution solution 
easy see solution constraint system pointer abstraction cf 
proof lemma 
decl ctype tt cdecl tx tx tt tt cdecl extern tx tx tt base ctype unknown unknown struct ctype struct struct unknown union ctype union union unknown ptr ctype array ctype ctype fun cdecl di ctype di constraint generation declarations struct union cdecl di di cdecl di struct di cdecl di union di enum enum constraint generation type definitions type definitions constraint generation type definition shown 
lemma type definition 
constraint system solution pointer abstraction respect proof follows lemma 
example implement sharing common initial members unions suitable number inclusion constraints added constraint system 
example expressions expression function constraint system cexp defined 
constraint generating function oc operators defined similarly specification expressions 
omit formal definition 
example application pointers oc int int te tei te unknown 
case application oc int int te tei te te cf 
example 
example const cexp te te unknown string cexp te te var cexp te te struct indr array addr unary binary cexp te cexp te cexp te cexp te cexp ei tei cexp te cexp te cexp te cexp te cexp te cexp ei tei cexp te cexp ei tei cexp ef 
en te te te te te te te tl te oc te te oc te tei te unknown alloc cexp alloc te te tl user call pre post assign comma cexp ei tei cexp 
en te cexp ei tei cexp 
en te cexp te cexp te cexp te cexp te cexp ei tei cexp aop te cexp ei tei cexp te tei tl te te tei tl te te te te te te te te te te te sizeof cexp sizeof te te unknown cast cexp te cexp te constraint generation expressions te te represent lvalue result function application fresh variable tl 
reasons seen section calls assumed labeled 
function implementing constraint generation casts defined follows 
te te case te te te unknown struct te unknown te te type member te te te te notice resemblance function cast defined section 
lemma expr expression 
cexp solution aloc pexp pexp defined 
proof see cexp solution observe solution 
safe pointer abstraction follows definition pointer types definition solution constraint systems definition 
example consider call simplified constraint system tf tf tf cf 

natural rewritings see section get tf tf tf tf bound tf tf rewritten tf tf tf corresponding tf tf parameter may point may return value location 
notice contra variant step 
example empty cstmt expr cexp te cstmt switch case default label cexp te cstmt si cstmt cexp te cstmt cstmt switch cstmt cstmt case cstmt cstmt default cexp te cstmt cstmt cexp te cstmt cexp ei tei cstmt cstmt cstmt cstmt goto cstmt goto return cexp te cstmt return block cstmt si cstmt si constraint generation statements statements tf te suppose stmt statement function constraint system cstmt defined 
rules basically collect constraints contained expressions add constraint return statement 
lemma stmt statement function cstmt solution safe pointer abstraction proof follows lemma 
functions fun function definition define cfun cdecl cdecl cstmt cdecl cstmt defined 
lemma fun function 
cfun solution safe pointer abstraction proof obvious 
completes specification constraint generation 
completeness soundness program show solution solution safe pointer abstraction 
lemma program 
constraint system solution 
proof trivial solution solves 
theorem program 
solution sol safe pointer abstraction proof follows lemma lemma lemma 
inter procedural pointer analysis intra procedural analysis developed previous section sacrifices accuracy functions calls calls function merged 
consider example function ptr increment pointer int ptr int return suppose calls ptr ptr pointers 
intra procedural analysis merges calls call ptr yields pointer calls ptr spurious point information propagated unrelated call sites degrading accuracy analysis 
section remedies problem extending analysis inter procedural context sensitive point analysis 
separating function contexts naive approach inter procedural analysis textual copying functions intra procedural analysis 
functions called different contexts copied callsites changed accordingly 
copying may increase size program exponentially henceforth generated constraint systems 
example consider program 
int main void int int int pa pb int ptr px int int ptr py return copying function due calls main create variants calls int ptr 
example problem textual copying functions analysis slowed due increased number constraints worse copying may useless copies function may similar contexts copying enhance accuracy 
ideally cloning functions result analysis functions gain copying copied 
example solution intra procedural analysis example 
tp tq calls collapsed 
copying ptr times pointers mixed 
example context separation static call graphs employ program static call graph differentiate functions different contexts 
recall program static call graph function scg variant id variant mapping call site variant number enclosing function function name variant 
static call graph program example shown 
variants ptr exist due call sites called twice main 
explicit copying functions amounts creating variants indicated 
observe constraint systems generated variants identical constraints calls return 
idea generate constraints vectors pointer types corresponding number variants 
example constraint main ptr ptr ptr ptr static call graph example program system ptr vectors length variants 
variant summary variant indirect calls 
analysis procedure cloning accomplished basis computed pointer information 
insignificant variants eliminated replaced general variants possibly summary variant 
constraints variant vectors extended constraint system multi set extended constraints range pointer types 
satisfiability constraints defined componentwise extension definition 
assigning single type variable objects expressions assign vector type variables 
length number variants encapsulating function plus variant case global objects 
example consider program example 
variable associated vector corresponding variant summary 
vector corresponding parameter ptr elements due variants 
example vector variables associated object denoted 
similarly expressions types 
example inter procedural solution pointer analysis problem example pa pa pb pb context numbering shown 
example example advantageous merge variant respectively 
inter procedural constraint generation inter procedural constraint generation proceeds intra procedural analysis section cases calls return statements 
consider constraint generation function variants 
rule constants te unknown unknown 
unknown length vector 
rule variable te 
global te 
local denote th variant object rule imply exists versions describe realization 
idea object uniquely identified associated variable practice rule reads te 
consider call 
em function constraint system ki gj ej ki te scg ki rule justified follows 
th variant actual parameters related corresponding variant ki formal parameters cf 
scg ki similarly result 
location abstracts lvalue call 
rule indirect call 
en uses summary nodes ei tl te 
cf 
rule intra procedural analysis 
context sensitivity maintained indirect calls 
definition appears variants constraints added 
assures variant type vector summarizes variants 
example call ptr example gives rise constraints 
ptr ptr variant variant sake presentation omitted intermediate variables rewritten constraints slightly 
example constraint system inter procedural analysis consists constraints case intra procedural analysis 
mean naturally inter procedural solution time intra procedural solution processing constraint takes time 
thesis processing extended constraint takes time processing increased number constraints 
improved naming convention side inter procedural analysis improves accuracy respect heap allocated objects 
recall objects allocated call site collapsed 
constraint generation inter procedural analysis calls te 
li fresh variables 
example intra procedural analysis merges objects allocated program unrelated 
int main void struct allocate void struct allocate return alloc struct allocate inter procedural analysis creates variants allocate separates apart invocations 
example gives analysis accuracy respect heap allocated objects analyses various invocations function distinguished choi 
constraint solving section presents set solution preserving rewrite rules constraint systems 
show repeated application rewrite rules brings system form solution easily 
argue solution minimal 
simplicity consider intra procedural constraints section 
extension inter procedural systems straightforward pairs types processed component wise 
notice number type variables appear sides constraint 
practice constraint annotated length type vectors 
rewrite rules constraint system 
application rewrite rule resulting system denoted repeated application rewrite rules written exhausted application denoted see exhausted application sense 
rewrite rule solution preserving substitution solution solution aim constraint rewriting propagate point sets type variables 
rules auxiliary function collect tvar aloc defined follows 
application system stabilizes 
type normalization tsi struct ti ti propagation collect collect collect collect solution preserving rewrite rules definition constraint system 
function collect tvar aloc defined inductively collect oi oi oi collect notice constraints may self dependent constraint system may contain constraints 
lemma constraint system suppose variable appearing sol sol collect 
proof obvious 
simplicity assumed location sets consist element 
generalization straightforward 
constraints form occur rewrite rule 
lemma rules solution preserving 
proof assume cl cr 
show solution iff solution cases rules follow definition pointer types definition 
observe due static typedness rule denotes struct object 
case due lemma 
case suppose solution cl lemma definition pointer types solution cl collect cl 
suppose solution cr 
lemma solution cr collect cr 
case similar case case similar case lemma consider constraint system set constraint 
repeated application rewrite rules terminates 
proof rules add constraints system 
done finite number times 
considered set constraint system normal form exhaustive application rewrite rules 
constraint systems normal form desirable property solution directly 
minimal solutions proof theorem gives constructive inefficient method finding minimal solution constraint system 
theorem constraint system 
perform steps 
apply rewrite rules system stabilizes system 
remove constraints constraints form giving 
define substitution collect aloc sol minimal solution 
proof due lemma lemma suffices show solution suppose solution clearly solution constraints added rewriting constraints generated rule solved exists constraint satisfied 
case analysis impossible due lemma 
impossible due exhaustive application rule lemma 
impossible due rewrite rule lemma 
impossible due rewrite rule lemma 
impossible due rewrite rules lemma 
solution see minimal notice inclusion constraints needed added minimal solution 
section develops iterative algorithm pointer analysis 
pointer type representation algorithm aspects struct int struct int int section outline algorithm pointer analysis 
algorithm similar classical iterative fixed point solvers aho kildall 
describe convenient representation 
representation declarator program associate pointer type 
locations declarator case array definition int create 
object uniquely identified pointer corresponding declarator 
constraint represented rewritten constant time 
example solution pointer analysis problem program shown 
struct int struct int dotted lines denotes representation static types 
example type variable associate set incl pointers 
boolean flag upd assumed type variable 
field incl incrementally updated set objects includes 
flag upd indicates set changed inspection 
iterative constraint solving constraints form pre normalized constraint generation exists solving process 
similar constraint generated user function call 
constraint solving algorithm algorithm 
algorithm iterative constraint solving 
fix clist switch case update break case update incl break case update struct incl break case update indr incl unknown incl abort unknown dereferenced break case upd upd incl update indr incl break case upd ti incl clist ti break fix update update content incl update incl incl fix functions indr struct defined obvious way 
example indr dereferences looks binding declarator pointer location name returns point set 
notice case pointer 
unknown dereferenced algorithm aborts worst case message 
strict needed 
example analysis yields worst case case assignment approximated unknown 
practice constraints appearing left hand side assignments tagged give rise abortion 
correctness algorithm terminates incl fields update finite number times 
termination solution incl 
lemma algorithm correct 
proof algorithm implements rewrite rules 
complexity algorithm polynomial size program number 
shown inter procedural may alias context multi level pointers space hard landi 
indicates degree approximation analysis 
hand fast results reasonable 
experiments implemented pointer analysis mix system 
analysis similar chapter deviates ways uses representation reduces number constraints significantly see computes summary information indirections pointer types 
decreases runtime analysis increases 
notice analysis chapter computes lvalues indirection pointer indirections computed inspections objects pointer may point 
value maintaining summary information indirections depends usage analysis 
example summary information indirections side effect analysis chapter need summarize pointers indirection node done pointer analysis 
hand useless information may accumulated 
suspect analysis chapter feasible practice time writing empirical evidence 
applied analysis test programs 
experiments conducted sun sparcstation ii mbytes memory 
results shown 
refer chapter description programs 
program lines constraints solving gnu strstr sec sec ray tracer sec sec seen analysis fast 
stressed programs pointers extensively 
believe analysis chapter exhibit comparable run times practice 
quality inferred information 
pointers approximated accurately modulo flow insensitivity 
average points sets pointer small 
number constraints reported impossible 
point superset constraints generated solved equality 
constraints pre normalized constraint system basically contains constraints assignments calls involving pointers 
shown programs exhibiting levels indirection 
program point pointer analysis analysis developed chapter flow insensitive produces summary entire body function 
benefits efficiency price precision illustrated contrived function left 
int foo void int bar void test foobar foobar foobar foobar analysis ignores branch information branch may influence 
example loss accuracy manifested propagation point information calls 
example right illustrates lack program point specific information 
program point specific analysis record point call second call 
section consider program point specific flow sensitive pointer analysis constraint solving 
program point sequence point aim compute pointer abstraction program point mapping pointers sets objects may point particular program point 
normally program point defined statements case notion coincides sequence points iso paragraph 
sequence point side effects previous current point shall completed store updated subsequent side effects taken place 
object shall accessed value determined 
object shall accessed determine value stored 
sequence points defined annex standard iso 
example definition renders undefined expression updated twice sequence points 
analyses rely programs transformed simpler form 
introduces new sequence points may turn undefined expression defined expression example 
example simplicity ignore sequence points expressions convention statement program immediately program 
instance sequence statements 

program point constraint program analysis section briefly constraint set program analysis imperative language developed heintze heintze 
program points assign vector type variables representing store 
example result program point specific analysis shown 
int main void int notice contain 
example corresponding constraint systems resemble introduced section 
extra constraints needed propagate state program points 
example program point variable assumes value updated 
example short hand constraints abstracts pointer usage previous example example constraint systems solved rewrite rules unfortunately analysis cope multi level pointers 
heintze set analysis fails consider program fragment 
int assignment program point updates location occur syntactically expression 
generating constraints incorrectly leads 
problems 
values propagated states syntactically expression updated program points 
secondly indirect assignment modeled constraint form saying indirection updated contain 
apparent constraint rewritten program points part constraint right type variable chosen 
solve problem constraints generated due assignments equipped program points meaning program point updated state example rewritten update happens program point 
problem intricate 
variables updated depend solution due loops program self dependences solution may depend variables propagated program points 
currently solution problem 
related consider areas related alias analysis fortran point analysis developed emami closest related approximation heap allocated data structures 
alias analysis literature contains alias analysis fortran languages 
fortran differs aspects dynamic aliases created due parameters program purely static call graph 
banning devised efficient inter procedural algorithm determining set aliases variables side effects functions banning 
analysis steps 
trivial aliases alias sets propagated call graph determine non trivial aliases 
cooper kennedy improved complexity algorithm separating treatment global variables parameters cooper kennedy 
chow designed inter procedural data flow analysis general single level pointers chow 
weihl studied inter procedural flow analysis presence pointers procedure variables weihl 
analysis approximates set procedures procedure variable may bound 
single level pointers treated simpler problem multi level pointers see 
mayer wolfe implemented inter procedural alias analysis fortran cooper kennedy algorithm report empirical results mayer wolfe 
conclude cost alias analysis cheap compared possible gains 
richardson ganapathi conducted similar experiment conclude aliases rarely occur realistic programs richardson ganapathi 
observe inter procedural analysis theoretically improves precision traditional data flow analyses little gain obtained actual runtime performance 
bourdoncle developed analysis interpretation computing assertions scalar variables language nested procedures aliasing recursion bourdoncle 
analysis somewhat complex various aspects interest computed parallel factored 
larus similar machinery compute inter procedural alias information larus hilfinger 
analysis proceeds propagating alias information extended control flow graph 
notice approach requires control flow graph statically computable case sagiv computes pointer equalities similar method sagiv francez 
analysis tracks universal existential may pointer equalities precise analysis 
remains extend methods full programming language 
harrison interpretation analyze program intermediate language mil programs compiled harrison iii 
yi developed system automatic generation program analyses yi 
automatically converts specification interpretation implementation 
landi developed inter procedural alias analysis subset language landi ryder landi 
algorithm computes flow sensitive conditional may alias information approximate inter procedural aliases 
analysis cope casts function pointers 
furthermore performance impressive analyze line program reported 
choi el improved analysis obtained algorithm precise efficient 
naming technique heap allocated objects similar employed 
cytron developed similar algorithm analysis programs static single assignment form cytron 
landi shown problem finding aliases language levels pointer indirection runtime memory allocation recursive data structures space hard landi ryder landi 
proof reduction set regular languages known space complete aho alias problem landi theorem 
shown intra procedural may alias analysis conditions recursive author knowledge new implementation improved performance substantially 
landi 
approximating algorithms needed case languages points analysis initial attempt pointer analysis interpretation implemented naive standard iterative fixed point algorithm 
abandoned approach experiments showed analysis far slow feasible 
independently emami developed point analysis traditional gen kill data flow equations solved iterative algorithm emami emami 
analysis computes kind information analysis precise flow sensitive program point specific computes may point information approximates calls functions pointers accurately analysis 
analysis takes input programs language resembling address code aho 
example complex statement converted temp temp temp temp temp temp temp temp temp compile time introduced variables emami page 
simple language may suitable machine code generation unacceptably communication feedback 
intra procedural analysis statement proceeds standard gen kill approach may point information propagated control flow graph 
loops approximated fixed point algorithm 
heap allocation approximated single variable heap represent heap allocated objects 
deliberately chosen approximate function calls pointers conservatively objective accurate information cases definitely purpose useless 
ghiya emami taken advanced approach point analysis perform inter procedural analysis calls pointers 
determined function pointer may point function call graph updated reflect relevant part point analysis repeated ghiya 
inter procedural analysis implemented program extended control flow graph 
technique increases number constraints slightly emami procedure essentially corresponds copying data flow equations practise algorithm traverses representation functions repeatedly 
naturally causes efficiency degenerate 
unfortunately aware runtime benchmarks compare efficiency analysis emami analysis 
unconditional jumps removed preprocess 
approximation data structures closely related analysis pointers analysis heap allocated data structures 
chapter mainly concerned stack allocated variables approximating runtime allocated data structures limit methods 
jones developed data flow analysis inter procedural analysis programs recursive data structures essentially lisp expressions 
analysis outputs program point variable regular tree grammar includes values variable may assume runtime 
chase el improve analysis efficient summary technique chase 
furthermore analysis discover true trees lists data structures contain aliases elements 
larus hilfinger developed flow analysis builds alias graph illustrates structure heap allocated data larus hilfinger 
chapter developed inter procedural point analysis programming language constraint implementation 
analysis integrated mix system proved usefulness 
areas remain investigated 
practical experiments pointer analysis described chapter convincingly demonstrated feasibility analysis especially regard efficiency 
question worthwhile sacrifice efficiency benefit improved precision 
analysis approximates follows flow insensitive summary analysis function bodies arrays treated aggregates recursive data structures collapsed heap allocated objects merged birth place function pointers handled proper inter procedurally way 
consider turn 
considered program specific pointer analysis section 
apparent description amount information analysis final result may big practical purposes 
example case line program global variables say output state variables estimating number local variables 
typical case sparse state description total memory usage may easily exceed byte 
identify main problem irrelevant information maintained constraint analysis 
example state corresponding statement information interest regarding 
state variables propagated may program points 
suspect extra information contributes little realistic programs experiments needed clarify 
belief poor man approach described section provides desired degree precision empirical test support 
analysis treats arrays aggregates 
program tables pointers may suffer 
dependence analysis developed parallelizing fortran compilers progress area gross steenkiste 
language considerably harder analyze pointers may array elements 
see promising extension biggest challenge 
analysis chapter merges recursive data structures 
experience elements recursive data structure way naturally exceptions may constructed 
practical experiments needed evaluate loss precision 
furthermore analysis mainly geared analysis pointers objects simple notion inter procedural birth place describe heap allocated objects 
birth time birth place may improvement harrison iii 
author opinion discovery instance singly linked lists binary trees may find substantial program transformation optimization investigated inference information detail 
consider function pointers 
analysis track interprocedurally function pointers uses sticky treatment 
greatly simplifies analysis program call graph dynamic 
graphs feasible calls static 
experience function pointers rarely justifies coarse approximation naturally programming styles may fail 
approach taken ghiya ghiya appears expensive 
relation benefits procedure cloning polymorphic analysis investigated 
limit notions static call graphs give flexible way adjusting precision respect recursive calls 
polymorphic analyses flexible handle program dynamic call graphs easily 
reported inter procedural flow insensitive point analysis entire programming language 
analysis founded constraint program analysis allows clean separation specification implementation 
devised technique inter procedural analysis prevents copying constraints 
furthermore efficient algorithm 
happens side effect program representation limit easily increased 
chapter binding time analysis develop efficient binding time analysis ansi programming language 
aim binding time analysis classify constructs variables expressions statements functions 
compile time run time initial division input 
evidently division variables classified run time correct value 
seek static annotation break congruence principle construct depends run time value classified run time 
precisely analysis computes polyvariant program point insensitive division 
explicit separation binding times turned crucial successful partial evaluators 
important stepping stone specialization imperative language featuring pointers user defined structs side effects 
binding time analysis driving part generating extension transformation 
program analysis annotates type specifiers binding time 
example integer pointer may classified static pointer dynamic object 
various extensions may enhance result program specialization 
analysis specified means non standard type system 
program run time constructs marked rules check consistency annotation 
program satisfying type systems annotated 
type systems formulated constraint framework bindingtime inference 
constraints capture dependencies expression subexpressions 
constraint system consists constraints binding time attributed types 
shown solution constraint system yields annotated program 
extension allows context sensitive analysis functions program static call graph 
efficient constraint solver developed 
algorithm exhibits amortized runtime complexity linear practice extremely fast 
implemented integrated analysis mix partial evaluator 
part chapter previous binding time analysis partial evaluation andersen andersen 
extended cover full ansi language constraint formulation simplified new faster algorithm developed 
furthermore context sensitive polyvariant inference added 
part chapter andersen 
binding time analysis takes program initial division input static compile time dynamic run time computes division classifying expressions static dynamic 
expression depends dynamic value classified dynamic 
called congruence principle 
explicit separation binding times useful number applications 
constant folding static expressions depend solely available values evaluated compile time 
partial evaluation static constructs evaluated specialization time residual code generated dynamic expressions 
transformation dynamic constructs changed code generating expressions 
binding times binding time analysis introduced partial evaluation means obtain efficient self application specializers 
assume int interpreter consider partial evaluator mix 
mix mix int comp self application second mix mix see natural binding times int program available input delivered 
resulting compiler take account compile time input 
excessively general program available compile time 
problem solved annotating int binding times inform mix program truly compile time jones chapter explicit binding time separation important successful specialization imperative languages featuring pointers user defined structs run time memory allocations side effects 
consider example specialization function 
int foo void int return bar address operator application suspended 
line partial evaluator decide general depends bar usage parameter 
binding time analysis collects global information determine binding time application suspended 
binding time analyses treated small order lisp programs implemented interpretation domain jones 
data structures considered aggregates example alist static key dynamic value approximated dynamic 
various analyses coping partially static data structures higher order languages developed bondorf consel launchbury mogensen 
binding time analyses non standard type inference attracted attention birkedal bondorf rgensen gomard henglein nielson nielson 
capture natural way partially static data structures higher order aspect functional languages accommodate efficient implementations henglein 
efficient binding time analysis program analyses specified means type systems implemented slightly modified versions standard type inference algorithm approach give efficient analyses andersen mossin gomard nielson nielson 
ideas semi unification henglein reformulated problem gave efficient constraint set solving algorithm untyped lambda calculus constants fixed point operator henglein 
analysis exhibits amortized run time complexity linear size input program 
idea capture dependencies expression subexpressions constraints 
example case expression constraints generated te te te te te te te binding time variable assigned expression constraints say binding time expression greater equal binding time returned values 
constraint captures test expression dynamic expression 
solution constraint system substitution type variables constraints satisfied 
analysis proceeds phases 
constraint set collected syntax directed traversal program 
constraints normalized exhaustive application set rewrite rules 
constraint set solved turns trivial normalized systems 
related originally formulated binding time analysis andersen implemented andersen bondorf rgensen developed similar analysis similix partial evaluator bondorf rgensen 
analysis treats higher order subset scheme programming language supports partially static data structures 
semantics similix specializer somewhat different semantics specializer respects simplifies analysis 
example similix structured values passed external function primitive operator suspended 
conservative case birkedal formulated implemented binding time analysis standard ml language birkedal 
chapter contributes main parts 
specify separation binding time annotations giving correctness criteria analysis 
definition naturally depends annotations 
example generating extension transformation chapter imposes restrictions binding times side effects dynamic control suspended 
monovariant binding time analysis extend contextsensitive polyvariant analysis 
normally context sensitive constraint analysis achieved explicit copying constraints give approach constraints vectors generated 
way number constraints grow exponentially 
example consider program 
int int int int pow int base int pow int pow base return suppose static dynamic 
context insensitive analysis merge calls pow henceforth classify dynamic parameters 
contextsensitive analysis annotations function base static dynamic vice versa 
example develop efficient inference algorithm runs linear time 
algorithm efficient find union data structures 
assume existence pointer information 
variable pointer type approximation set objects may point run time 
furthermore assume assignments annotated side effecting conditionally side effecting may assign non local object assign non local object conditional control respectively 
annotations computed pointer analysis chapter side effect analysis chapter 
overview chapter chapter organized follows 
section discusses intriguing constructs language 
section defines annotated programs 
section develops constraint formulation 
section efficient normalization algorithm 
section extend analysis polyvariant analysis 
section contains examples section describes related section holds list topics 
separating binding times classification variables static dynamic called division 
necessary requirement binding time analysis called congruence principle static variable depend dynamic variable 
furthermore fulfill requirements imposed generating extension transformation listed chapter 
briefly review needed 
section consider intricate aspects language 
externally defined identifiers program normally consists set translation units 
identifiers defined modules analyzed external 
externally defined identifier brought scope extern declaration 
global identifiers default exported modules explicitly declared local means static storage specifier 
example program consists files 
file defines function pow file 
file file extern int errno extern double pow double double int int main void double pow double double double pow errno return exp log printf pow errno return errno return looking isolated file determined global variable errno assigned modules 
calls pow unknown 
looking file values assigned errno unknown 
example consequences analysis safe global variables classified dynamic functions annotated dynamic 
restriction alleviated copying functions annotating copy completely dynamic 
naturally excessively strict possible gains specialization 
inter modular information user guidance needed conservative assumptions 
subject chapter considers separate program analysis 
chapter adopt assumptions 
allows complex data structures variables replaced objects 
constraint analyze programs consist translation units 
calls library functions extern 
modules refer global identifiers 
means global identifiers effectively considered static 
chapter develops analysis eliminates requirements 
pure functions calls externally defined functions suspended general operational behavior functions unknown 
example function may report errors global variable case functions defined math library 
example suppose external function count counts number times particular part program invoked 
file file extern void count void int main void void count void static int count return return evaluation call count specialization dubious due side effects variable 
dramatic examples include functions output data abort program execution 
example means calls sin pi annotated dynamic replaced constant specialization expected 
ameliorate situation externally function specified pure 
definition function pure commits side effects assignments nonlocal objects 
chapter assume function pre annotated pure specifiers 
annotations derived side effect analysis chapter user specifications 
program necessary complete 
library function interpreted function defined independently program 
function specialization function handled essentially different ways partial evaluator 
specialized possibly shared residual calls unconditionally specialized sharing introduced unfolded 
treatment function may influence binding times 
example parameters unfolded function may assigned partially static binding times functions completely static completely dynamic parameters 
chapter ease presentation assume functions specialized possibly shared 
describe modifications needed support analysis functions section 
unions common initial members standard specifies common initial members members struct type union shall truly shared cf 
section 
implies fields binding time 
simplicity ignore problem exposition 
rule easy implement ugly describe 
idea generate constraints relate common members 
pointers side effects side effect due assignment left hand side expression evaluates address non local object run time memory allocation side effects heap 
assume assignments annotated side effect information 
annotation assignment means expression may side effect 
annotation assignment means expression may side effect conditional control 
see chapter definition computation side effects annotations 
generating extension transformation requires side effects dynamic control shall suspended 
initially suspend side effects conditional control extension develops suspension side effects dynamic control section 
run time memory allocation run time memory allocation means malloc derived forms shall suspended run time 
allocation mix function alloc may performed specialization time 
assume alloc calls labeled uniquely 
label employed indicate binding time objects allocated th call site 
implicitly assume definitions form struct alloc calls alloc 
heap allocated objects anonymous global objects 
recall order compare function calls detect sharing residual functions call signatures compared 
may time consuming may desirable prevent specialization respect heap allocated data 
broadly assume specifier residual unconditionally shall suspend variable 
example programmer defines residual int pointer shall classified dynamic 
implementation defined behaviour program conforming strictly conforming ansi standard iso 
strictly conforming program allowed depend undefined unspecified implementation defined behavior 
conforming program may rely behavior 
example non strictly conforming feature cast integral values pointers 
implementation defined features shall suspended run time 
example cast int annotated dynamic cast integral value pointer implementation defined 
result sizeof implementation defined 
application shall annotated dynamic 
example special class implementation defined operations casts 
cast base types presents problem value static cast performed specialization annotated dynamic 
ignore casts base types consider casts involving pointer 
pointers casts arithmetic language supports cast pointers integral values pointer arithmetic 
example cast size casts pointer size value increases pointer 
consider cast pointers divided group iso paragraph 

cast pointer integral values 
result implementation defined 

cast integral value pointer 
result implementation defined 

cast pointer type pointer type alignment requirement back 
result shall compare equal original pointer 

function pointer cast function pointer back result shall compare equal original value 
converted pointer call function incompatible type result undefined 
cases cast shall annotated dynamic 
case cast annotated static provided pointers static 
consider pointer arithmetic 
integer value may added pointer pointers may subtracted 
cases operation static operands static 
example consider expression adds pointer 
suppose static pointer dynamic object 
normally operator requires arguments fully static 
case indirection needed carry addition henceforth classified static despite partially static 
consider extension example 
example specifying binding times suppose program functions statements expressions marked static compile time dynamic run time 
section defines set rules checks annotations placed consistently 
program binding time separation fulfills congruence principle additional requirements imposed generating extension transformation annotated 
analysis developed chapter computes annotation expressions 
section describe annotated program derived expression annotation furthermore annotated program derived variable division 
binding time types type expression describes value expression evaluates 
binding time expression describes expression evaluate value 
intimate relationship types binding times 
binding time static dynamic binding time variable ranging range binding times 
model binding time value extend static types include binding time information 
example static pointer dynamic integer value denoted binding time type int definition syntax binding time type bt defined inductively bt bb base type struct type bt pointer type bt array type bt bt function type notion static pointers defined section 
range base type specifiers range struct union enumerator type specifiers 
denotes binding time binding time type bt type attributed type 
range normal types bt types confusion occur 
occasionally bt range bt types needed 
example definitions int consider int int int int int int variable static 
array completely dynamic 
pointer static pointer dynamic object 
example int pointer variable containing address constant null 
address definitely known specialization time pointer classified static 
classified dynamic 
static pointers dereferenced specialization dynamic pointers 
naturally sense classify pointer dynamic static object object dynamic pointer points exist residual program 
captured definition formed types 
definition bt type formed satisfies requirements 


exists bi bj bn 
tn exists ti condition stipulates variable pointer type dynamic dereferenced type 
second part states parameter function type dynamic binding time specifier dynamic 
intuitively binding time function type specifier dynamic function takes dynamic argument 
example type int formed 
type int formed 
example write static type meaning static program type bt type binding times static 
binding time classifications objects arrays treated aggregates entries array assigned binding times 
example bt type int specifies type static array dynamic content 
array said static indexed specialization 
example yield dynamic object 
example suppose pointer classified int consider ex pression 
expression sense point array say 
observe pointer arithmetic change bt type pointer point dynamic object pointer arithmetic allowed move pointer outside array arrays treated aggregates 
example structs classified static dynamic depending split 
static structs split individual variables eliminated specialization 
bt type variable struct type struct binding time indicates struct split 
equals split members shall dynamic 
struct split 
lift relation suppose integer variable consider assignment 
dynamic allowed static lifted run time 
operationally speaking run time constant built value specialization time 
case objects struct type 
obvious solution introduce constructor functions may lead code duplication introduces overhead 
objects struct type lifted 
similarly holds pointers lifting addresses introduces implementation dependency 
notion values lifted captured relation bt types defined follows 
definition define relation btype btype bs bd iff 
definition says static value base type lifted dynamic value base type 
observe determined basis static program types lift possibly occur 
example assignment struct type lift operator possibly applied objects struct type lifted 
example base type value lifted 
happen places index array indexing arguments operator application arguments function calls right hand side expressions assignments 
subexpression comma expression may lifted dynamic 
value returned function may lifted 
example allow lift string constants 
divisions type environment binding time environment id btype map identifiers bt types 
type bt type bt bt suits agree static program type 
environment suits set definitions tx defined suits tx 
type environment tname btype id btype map type names bt types binding time environments 
intuitively struct type name structs indicates struct static split represents bt types members binding time member 
example define struct int struct 
map struct int struct describes member dynamic static pointer struct split 
ease notation omit product projections clear context 
example write binding time binding time member example consistent binding time struct specifier variable agree binding time recorded type environment 
definition binding time environment type environment 
said agree dom contains specifier struct struct similarly union 
operator type assignment map op btype assigning bt types operators binding times variables 
stat btype btype function returns copy bt type binding times dyn btype btype defined similarly 
example consider integer plus int int operator pointer int int ptr int ptr int operator 
int int int int int dyn int int int 
example recall overloading operators assumed resolved parsing 
level binding time annotation adopt level language framework specifying binding times programs nielson nielson gomard jones 
underlined construct dynamic constructs static 
example denotes static array indexing denotes dynamic index 
example known pow program annotated follows base static dynamic 
int pow int base int int base return easy see binding time annotations consistent initial binding time division 
example omit formal specification level level version subset previously defined andersen 
annotated definitions tx annotated declaration 
gives rise bt type suits tx 
relation decl decl btype defined captures 
definition annotated declaration type environment defined type names bt type bt agree type decl bt decl defined 
definition decl uses relation type type btype defined 
case pure declaration binding time type static 
dynamic 
case definitions underlined definition posses dynamic type 
definitions specified residual dynamic 
rule function types uses auxiliary predicate 
satisfied binding time type completely static completely dynamic respectively 
sure function accept partially static arguments 
predicate specified additional set inference rules types omitted due lack space 
correct underline expression constructor underline sake readability expression 
case type specifier struct members checked 
decl def res base struct ptr array fun type bt bt decl pure extern bt type bt bt decl bt type bs struct type struct struct type bt type type bt type bt bt decl di type bt type di bt binding time inference rules declarations type bt bt type extern bt type bt bt decl bt type bt bt decl residual bt type bd struct type struct struct type bt bt bt type type bt bt type bt decl di type bt bt type di bt lemma declaration type decl formed 
proof suppose decl consider condition definition 
satisfied due condition bt dynamic versions rules 
second condition fulfilled due condition static version rule function type specifiers 
suppose type definition type environment 
agreement type definition annotated definition captured defined 
definition annotated type definition 
type environment agrees annotation defined 
lemma type environment define bt declaration decl bt agrees proof obvious 
struct union enum struct type tx struct tx union type tx union tx enum binding time inference rules type definitions annotated expressions struct type tx tx struct tx union type tx tx union tx annotated expression said annotated binding time separation consistent division variables 
captured relation exp expr btype defined figures 
definition suppose annotated expression environments defined identifiers suits underlying types agree expression annotated exists type exp exp defined figures 
rules justified follows 
constant string constants static 
variable annotated dynamic variables bound symbolic locations specialization time cf 
chapter 
type struct member type environment 
struct indexing operator annotated dynamic struct split 
rules pointer dereference array indexing similar style 
type value determined value indirection case arrays index 
index dynamic indexing static 
consider rules address operator 
subexpression static result static pointer 
application annotated dynamic result dynamic pointer 
example rule address operator correctly captures applications dynamic expression unfortunately expression array dynamic values 
rewriting expression problem circumvented 
applications dynamic inevitably suspended 
example assume array expression pointer type 
see section function identifiers 
const string var struct indr array address unary binary alloc call exp bs exp char exp exp struct exp exp exp exp exp bs exp exp exp exp stat exp stat exp ei ti ti stat exp stat struct exp exp tf exp ei ti ti specified pure struct exp 
en stat tf exp exp ei ti ti exp 
en exp struct exp exp exp exp exp exp exp exp exp dyn exp dyn exp ei ti ti dyn exp dyn struct exp exp tf exp ei ti ti dyn exp 
en dyn tf exp exp ei ti ti exp 
en binding time inference rules expressions part struct rules unary binary operator applications map arguments static fresh instance operator type instantiated 
notice usage lift rule dynamic applications assure possibly static values lifted 
rules unary operator applications analogous 
result alloc call environment 
annotation call external function depends function pure 
affirmative case call parameters static annotated static 
call suspended 
consider label alloc name pointer variable 
pre post assign assign se assign dse comma sizeof cast exp exp exp exp exp exp exp aop exp exp stf exp aop exp exp tf exp aop exp exp exp exp type te cast exp binding time inference rules expressions part exp exp exp exp exp exp exp aop exp exp exp aop exp exp exp aop exp dyn exp dyn exp dyn exp sizeof exp type te cast te exp size cases calls user defined functions indirect calls treated simplicity 
function designator possess function type type actual lift able formal argument types 
case static application parameters static 
rules pre post increment expressions straightforward 
consider rules assignments recall assignments non local objects side effects conditional suspended 
pure syntactic criteria conservative 
section ameliorate definition 
rules cover non side effecting assignments 
rules assign se checks side effecting assignments conditional side effecting assignments respectively 
tf denote return type function containing expression 
contains assignment type ti tf 
binding time comma expression depends binding time expressions implementation defined sizeof special form suspended 
rules cast expressions expressed predicate cast defined 
type te type subexpression te new type 
define cast type type boolean cast case true cast false false compare analysis section 
example allow partially static operator applications rule binary plus pointers integers 
exp ei ti ti exp int int pointer specifier integer value demanded static indirection pointer 
example annotated statements statement depends mainly contained expressions 
expressed means inference rules stmt stmt depicted 
definition annotated statement function binding time environment type environment defined identifiers agrees annotated stmt stmt defined 
rules motivated follows 
function contains dynamic statement function residual dynamic return type 
reflected system side condition tf dynamic rules 
empty statement annotated static binding time expression statement depends expression 
switch statement dynamic test expression dynamic 
furthermore sub statements annotated 
consider rules loops 
binding time loop construction depends test expression 
binding time initializers necessarily influence binding time loop typically case 
consider rules return 
containing function residual statement dynamic residual function return value run time specialization time 
case base type values lift operator may applied 
simplicity assume break continue expressed goto 
empty stmt expr switch label goto return block exp stmt exp stmt stmt stmt exp stmt stmt switch exp stmt stmt exp stmt stmt exp ei ti stmt tj tf stmt stmt stmt stmt goto exp tf stmt return stmt si stmt si binding time inference rules statements annotated functions exp tf stmt exp stmt stmt tf stmt exp stmt tf stmt switch exp stmt tf stmt exp stmt tf stmt exp ei ti stmt tf stmt exp tf tf stmt return recall solely consider functions annotated specialization possibly shared 
function depends consistency parameters local variables statements 
expressed rules fun fun defined 
share di xi ti decl xj tj dj xj tj xi xj stmt sk fun tf di dj sk binding time inference rules functions di xi ti decl xj tj dj xj tj xi xj stmt sk fun tf di dj sk definition function program binding type environment defined global identifiers type environment agrees 
function annotated fun fun defined 
rules explained follows 
type function bt type environment includes type parameters 
bt type local variables determined means inference rules definitions 
environment extended bt types parameters locals consistency annotation statements checked 
annotated programs program depends type definitions global declarations function definitions 
type definitions define type environment environment variables agree 
functions annotated context type binding time environment 
definition annotated program 
annotated provided 
type environment 
binding time environment defined identifiers decl tx 
fun cf 
definitions 
theorem annotated program fulfills congruence principle requirements generating extension transformation 
proof justification inference systems 
binding time inference previous section specified conditions program annotated 
problem binding time analysis opposite initial division input parameters find annotated version program 
naturally making constructs dynamic annotated version easily desire static annotation 
analysis constraint works follows 
constraint system collected single traversal program syntax tree 
constraints capture dependencies expression subexpressions 
system normalized set rewrite rules 
show rules normalizing constraint systems normal form 
solution 
turns solving normalized constraint system trivial 
solution easy derive annotated program 
show annotation minimal sense annotations constructs dynamic 
constraints constraint systems give constraint formulation inference systems previous section 
constraint system multi set formal constraints form instance constraint int systems 
equal constraint lift constraint dependency constraint ti range bt types bi range binding times 
addition types constraint agree underlying static program types 
double illegal 
range constraint define btype btype btime btime bs bd lift base dynamic dependency dependency range base type specifiers range binding times 
define def 
intuitively lift constraint corresponds lift relation previous chapter dependency constraint captures dynamic dynamic 
definition constraint system 
solution substitution btime constraint obviously constants kept static 
requirement fulfilled construction constraint systems 
st st st st sb sb application substitution denoted juxtaposition identify binding time variable appearing set solutions denoted sol 
binding times ordered extend point wise solutions 
obviously constraint system solution minimal solution maps binding time variables 
constraint systems interest solution minimal solution 
example system int int int int solution minimal 
system int int solution 
example binding time attributes annotations attribute program types fresh binding time variables type int attributed type int practice step done parsing 
aim analysis instantiate binding time variables consistently 
instantiation variables substitution 
substitution anns annotation function underlines program constructs accordance instantiation 
example array index instantiated type int index shall underlined 
omit formal specification 
key point observe inference rules stating deterministic bt types 
overload ann declarations expressions statements functions 
previous section employed binding time environment mapping identifier bt type 
assume variable definitions declarations assigned unique bt types mapping tx implicit program 
write tx bt type definition function identifier write ti tf type notice tf denotes type returned value 
example partially attributed program kernighan ritchie page shown 
expressions variable definitions annotated type 
bt type char equals 
example si si similarly type environment superfluous struct write ts bt type bt type field 
attributed definition tx say environment agrees tx 
similarly type environments 
application substitution environment denoted juxtaposition 
assume ease presentation unique names 
return position char char si char si int int char char char char char int char char return null char binding time type annotated program decl pure def ctype cdecl extern ctype cdecl pure extern ctype cdecl ctype res cdecl residual base ctype struct ctype struct struct ts ptr array fun ctype ctype ctype ctype xi ti di ti ctype ctype di return char ti ti constraint binding time inference declarations capturing binding times constraints section gives constraint characterization annotated programs 
reformulation inference systems previous section straightforward 
expression constraints connecting bt types expression subexpressions generated furthermore constraints capturing global dependencies return statement dynamic function dynamic added 
prove solution constraint system corresponds annotated program 
declarations type definitions set constraints generated declaration defined inductively 
observe rules deterministic value constraints returned 
constraints generated traversal syntax tree constraints accumulated global data structure 
function rule function types defined follows 
bt type 
returns set constraints 
type occurs adds dependencies ts specifier struct members intuitively type constraints added constraint set solution map binding times dynamic static 
case struct types dependencies assure member dynamic struct dynamic forcing members dynamic 
example assume struct definition struct int int 
ts ts ts assume dynamic ts dynamic follows constraints generated type definitions see 
preventing partially static parameters 
example lemma decl program constraint system defined minimal solution 
environment agrees decl anns td td bt type lemma says annotated solution constraint system 
proof see solution exists notice substitution maps variables solution 
suppose consider type proof induction number type specifiers 
base case base type specifiers struct type specifier 
follows unspecified definition ann 
inductive case ptr array fun cases ptr array obvious 
notice dependency constraints guarantee bt types formed 
consider rule function types 
second dependency constraint sure parameter dynamic solution map binding time variable dynamic required 
follows easily 
suppose type definition 
constraint formulation binding time inference stated 
lemma program constraint system defined minimal solution 
environment agrees anns proof inspection rules 
struct ctype tx struct tx ts tx union ctype tx union tx enum enum constraints generated type definition const cexp string cexp char bs char tu tx char var cexp tv struct cexp struct cexp struct ts tsi indr cexp cexp array cexp cexp cexp address cexp cexp unary binary cexp ctype cexp cexp ei ti ti ctype cexp ti ti alloc cexp tl cexp ei ti ti cexp 
en ti ti cexp ei ti cexp ti call cexp 
en constraint binding time inference expressions part expressions inference system expressions 
recall tv denotes bt type assigned observe value flow analysis described chapter renders unification fields struct assignment superfluous 
types equal 
practice major gain unification struct types expensive 
rules unary binary operator applications extern function application relates type argument equivalent type denoting fresh instance 
implements lifting arguments 
notice lined type suspended application dynamic 
rule casts uses function cast generate constraints defined follows 
pre post assign assign se cexp cexp cexp cexp cexp cexp cexp aop cexp cexp cexp aop assign cse cexp cexp cexp aop comma cexp cexp cexp sizeof cexp sizeof cast cexp cexp tf tf size cast constraint binding time inference expressions part cast case cast notice similarity definition section 
lemma expr program constraint system defined figures minimal solution 
environments agree exp anns te te bt type proof constraint system clearly solution 
proof structural induction 
base cases const string var follow immediately 
inductive cases easy check 
example case array suppose solution maps due constraint induction hypothesis annotated expression annotated static array expression 
suppose solution maps underlining array index expression annotated 
empty cstmt exp cexp cstmt tf switch case cexp cstmt cstmt cstmt cexp cstmt cstmt switch cstmt cstmt case default cstmt cstmt default cexp cstmt cstmt cexp cstmt cstmt cexp ei ti cstmt cstmt cstmt tf tf tf tf ti tf label cstmt goto cstmt goto return cexp cstmt return tf block cstmt si cstmt si constraint inference rules statements statements statement function recall tf denotes return type inference rules constraints statements displayed 
lemma stmt function program constraint system corresponding defined minimal solution 
environments agree stmt anns proof easy see constraint system solution 
proof established structural induction statements 
interesting case return 
suppose solution maps tf due constraint tf binding return value static 
hand function dynamic solution constraint assures value lift able required rules 
share cdecl dj cstmt sk cfun tf di dj sk di constraint binding time inference functions functions defines constraint generated functions 
lemma fun program constraint system defined minimal solution 
environments agree fun anns proof inspection rule lemmas 
program constraint definition program defined definition 
definition program 
type environment agree define 
ct constraint system generated due 
cd constraint system generated due cdecl 
cf constraint system generated due cfun 
txd xd dynamic variables initial division 
constraint system ct cd cf theorem program 
constraint system minimal solution 
anns annotated program 
proof follows lemmas 
state proof minimal solution gives best annotation initial division fixed possible construct static annotation 
normal form section presents set solution preserving rewrite rules simplify structure constraint systems 
allows solution easily constraint system 
denote application rewrite rule yields system substitution notation denotes exhaustive application rewrite rules system stabilizes 
justify definition meaningful system eventually converge 
rewrite rule solution preserving sol sol 
solution transformed system composed substitution solution original system 
suppose constraint system rewritten exhaustively minimal solution desire minimal solution defines set rewrite rules binding time constraints range bt types range binding times 
function unify btype btype btime denotes general unifier binding time types binding times 
notice unify fail case rule discards variables due rule 
lemma rewrite rules displayed solution preserving 
proof case analysis 
case follows definition unify 
case follows definition 
case left right suppose solution definition 
definition solution suppose solution right hand side 
right left similar 
cast solution left hand side maps solves constraint right hand side 
lemma rewrite rules normalizing 
proof rules remove constraint 
constraints introduced rule rewritten 
constraint introduced rules removed rules 
constraint added rule subject rules 
constraints introduced rules left system removed rules constraint introduced rule removed directly indirectly left system 
consider rules number times rules applied limited size bt types 
notice constraint introduced rule subject rule 
lemma proves exhaustive application rewrite rules defined 
constraint system suppose system normal form normal form unique 
theorem characterizes normal form constraint systems 
theorem constraint system 

system normal form exhaustive application rewrite rules 

normal form constraint system consists constraints form constraints 

minimal solution minimal solution proof case follows lemma 
case inspection rules 
case suppose minimal solution observe solution constraint satisfied 
implies minimal solution theorem states minimal solution constraint system follows normalize constraint system find minimal solution normalized constraint system 
composition substitutions minimal solution 
solving constraints finding minimal solution normal form constraint system notably simple solve lift constraints equality map remaining free variables lemma normal form constraint system 
substitution minimal solution proof see solution suppose opposite 
exists constraint satisfied due characterization normal form constraint form solved variables mapped clearly minimal solution 
theorem states constructive procedure binding time analysis 
equal sc sc sc sc sc int int bt bt bt bt bt bt bt int int bt bt lift bs bs bs bd bd bd bd sc bs sc bd bs bt bt bt bt bt bt bt bt bt bt bt bt bt bt dependency int int sc int int int int normalizing rewrite rules theorem constraint system 
minimal solution normal form maps free variables proof substitution minimal solution lemma 
due theorem item minimal solution doing binding time analysis steps binding time analysis follows 
program 

construct constraint system defined definition 

normalize constraint system obtain normal form exhaustive application rewrite rules substitution 
substitution maps variables minimal solution 
apply annotation function anns get annotated program 
step done single traversal program syntax tree 
interpreting un instantiate binding time variables step side stepped 
get efficient binding time analysis construction efficient normalization algorithm remain 
division annotated program analysis developed assigns expression bt type 
implies instance generating extension transformation chapter transform expression looking solely expression type expression determined solely binding times subexpressions 
general excessively information 
price computation transformation division sufficient 
division map identifiers bt types 
propagating information subexpressions expressions binding time constructs 
implies bijection identifiers associated bt types established constraint set kept solved completely separately program 
solution assigns binding times identifiers binding times expressions determined 
fact exploited chapter considers separate binding time analysis 
assume included set identifiers labels alloc calls 
extensions recall chapter conditional side effects dynamic control annotated dynamic 
rule suspends conditional side effects correct conservative 
test static need suspend side effect non sharable function 
incorporated adding dependency constraint test assignment 
rule unions implement sharing initial members struct members union 
correct constraints unifying binding times relevant members added initial members possess binding time 
dwell formal definition 
recall chapter unfold able functions may assigned static binding times sharable functions 
example partially static parameters pointer type allowed propagation non local variables 
extension trivial tedious describe 
consider rule address operator 
implement specialization function pointers changed slightly 
recall application function designator classified static 
case easily detected means static types 
efficient constraint normalization algorithm section presents efficient algorithm constraint normalization core part binding time analysis 
algorithm similar algorithm originally henglein henglein simpler due factorization value flow analysis structs binding time analysis exploitation static types 
representation normalization rules rewrite constraints trivial lift constraints form int int objective variable discarded constraint system included domain solution 
solely technical problem practice bt types attached expressions disappear 
theorem un instantiated binding time variables going mapped normalization anyway safe skip trivially satisfied constraints 
binding time variable assign list dependent binding times 
binding time variable dep list binding time variables unification binding times employ variant union find tarjan 
algorithms union binding time terms performed notational simplicity assume find works bt types returning ecr binding time type specifier 
implemented mix 
efficient constraint normalization algorithm clist switch case bt bt equality constraint union type bt bt case bt bt lift constraint switch find bt find bt case base base case base base case base base case base base break case base base break case base base union break case base base union break case base base dep add dep dep break case struct struct union break default ptr array fun type unify union type bt bt break case dependency constraint switch find find case case case case case case break case union break case dep add dep dep break equal union bt bt void union type btype bt btype bt bt bt bt bt switch find bt find bt case bt bt bt bt bt bt union type bt bt union find find break default union find bt find bt break efficient constraint normalization algorithm union unify simple ecr terms void union btime btime switch case case break case case link break case case dep dep link dep union find break case dep add dep dep dep link break union algorithm adopted normalization algorithm rank normalization algorithm normalization algorithm depicted 
input list clist constraints 
algorithm side effects type representation binding time variables minimal solution map dynamic instantiated case equality constraint type specifiers union ed 
notice type error occur underlying static program types match 
trivial lift constraints skipped 
case bs bd forced respectively binding time variables unioned 
case constraint dependency recorded dependency list 
type base type binding times binding time types shall equal accomplished case equality constraint 
dependency list binding time variable checked union function variable dynamic shown 
simplicity ignore maintenance ranks 
complexity consider algorithm 
clearly algorithm possesses run time linear number constraints 
observe constraints added constraint list processing 
union type take constant time 
case function types arguments processed 
amortized run time analysis linear size constraint system linear size program 
complexity value flow analysis structs added 
practice number constraints generated node close average see benchmarks provided section 
notice imple mentation optimized description 
correctness correctness algorithm amounts showing implements rewrite rules 
provide informal argument 
rules equality constraints captured union type function 
omit proof correctness 
consider rules lift 
rules covered respectively 
rule implemented rule 
rules captured trivial constraints 
case corresponds rule rules implemented default case 
rules dependency constraints 
rules trivial implemented case 
rule implemented case converts constraint internal representation corresponding rewrite rules leave constraints system 
union algorithm dynamic dependent variables variable dynamic normalization algorithm correspond exhaustive application rewrite rules 
improvements binding time analysis efficient room improvements 
normalization algorithm linear number constraints 
easiest way lower run time binding time analysis reduce number constraints 
consider constraints generated binary operator applications 
lift constraints added capture operand possibly may lifted 
case values struct pointer types lifting take place 
equality constraints generated 
key point inspection static program types lift constraints replaced equality constraints faster process 
analysis storage usage linear number constraints 
reduced pre normalization generation 
example equality constraints processed immediately 
reduces number constraints half 
practical experiments show substantial improvement improve algorithm complexity 
polyvariant binding time analysis analysis developed far monovariant function arguments 
parameter assigned binding time approximating calls program function 
polyvariant binding time analysis context sensitive different calls function collapsed 
section outline polyvariant analysis principles employed chapter 
polyvariant constraint analysis describe polyvariant analysis program static call graph 
recall static call graph approximates context sensitive invocations functions 
function called different contexts said variants 
static call graph maps call variant variant called function see chapter 
type specifier appearing function variants assign vector binding time variables 
variables 
describe binding times variants variable summary corresponding monovariant analysis 
summary indirect calls 
example consider program example 
initial binding time assign ment pow int int int pow pow pow length vectors pow appears contexts 
example constraint generation proceeds intra procedural case calls return statements 
consider call 
en function variants 
suppose scg constraints generated ki gj type 
ki gj ki denotes bt type th parameter th variant ki return example pow function int return statements constraints generated ki relating binding time th variant function bt type 
constraints example type specifiers added 
constraints causes variant summary variant 
straightforward extend normalization algorithm interprocedural analysis 
vectors binding time variables processed component wise 
recall static call graph approximate indirect calls 
constraint generating assignments changed accommodate inter procedural side effects dynamic control 
example result inter procedural analysis program example follows 
int int int result value dynamic cases 
example refer chapter detailed description technique 
generation extensions polyvariant binding time information exploited generating extension transformation developed chapter follows 
function generating function generated variant variant 
contexts binding times signature collapsed 
copying functions known procedure cloning cooper 
time writing implemented function cloning basis binding times mix system 
examples implemented binding time analysis mix system 
analysis similar describe chapter optimized 
foremost constraints pre normalized generation 
example equality constraints unified immediately 
timed analysis test programs 
experiments carried sun sparcstation ii mbytes memory 
results shown table 
see chapter description test programs 
program lines constraints normalization analysis gnu strstr sec sec sec sec ray tracer sec sec sec sec seen analysis fast 
notably seemingly non linear relationship number constraints ray tracer modeling system 
reason contains array indexing operators giving rise lift constraints constraints pre normalized case ray tracer 
related binding time analysis originally introduced partial evaluation means obtaining efficient self application specializers 
line approximation binding times opposed online determination includes advantages 
yields faster specializers enables better control desired degree specialization provide useful feedback prospective speedups binding time improvements broadly binding time separation program 
furthermore guide program transformations generation extension transformation 
bta interpretation binding time analysis mix interpretation domain jones 
coarsely classified data structures completely static completely dynamic invoking need manual binding time improvements 
means closure analysis bondorf extended principles higher order scheme bondorf 
render manual binding time improvement superfluous mogensen developed binding time analysis partially static data structures mogensen 
analysis describes binding time data structures means tree grammar 
launchbury developed projection analysis natural way captures partially static data structures launchbury 
mentioned analyses monovariant applicative languages 
developed lifetime analysis heap allocated objects replace dynamically allocated objects variables murtagh 
analysis classify objects compile time run time similar binding time analysis 
classical data flow analysis methods 
bta type inference constraint solving concept level languages invented developed binding time analysis variant lambda calculus nielson nielson 
analysis partly interpretation partly type inference algorithm gomard designed binding time analysis untyped lambda calculus backtracking version algorithm gomard 
analysis conjectured run cubic time 
henglein reformulated problem gave constraint characterization binding time inference henglein 
developed efficient constraint normalization algorithm running linear time 
master thesis outlined constraint binding time analysis subset andersen considerably simplified implemented andersen 
chapter provides new formulation exploiting static types adds 
bondorf rgensen re implemented analyses similix scheme partial evaluator constraint analyses bondorf rgensen birkedal developed binding time analysis core part standard ml birkedal 
heintze develops framework set analysis thesis heintze 
binding time analysis seen instance general set analysis 
suggested polyvariant analysis obtained copying functions constraint sets 
polyvariant bta polyvariant binding time analysis widely acknowledged substantial improvement partial evaluator strength little done successfully 
extended original binding time analysis similix polyvariant version iteration original analysis 
expressions may get assigned incomparable binding times duplicated analysis started scratch 
naturally expensive terms run time 
consel constructed polyvariant analysis partial evaluation treats higher order subset scheme consel 
analysis interpretation uses novel concept filters control degree 
different approach taken consel jouvelot combining type effect inference obtain polyvariant binding time analysis consel jouvelot 
currently analysis handle non recursive programs efficient algorithm developed 
henglein mossin developed polyvariant analysis polymorphic type inference henglein mossin 
idea parameterize types binding times 
example lambda expression may assigned type scheme denotes binding time appears type function arrow symbol denotes static closure 
section list number topics study 
constraint solving tracing error messages seen clean separation constraint generation solving advantageous program needs traversed shown chapter supports separate analysis 
separation renders useful feedback constraint solver hard 
problem constraint system extracted connection program lost 
case binding time analysis solver fail constraint type checker traces value flow useful 
obvious questions forced variable dynamic binding time 
obvious idea tag type variables origin gives partial solution 
suppose example number type variables union ed ecr dynamic 
variables dynamic showed analysis says causes effects 
granularity binding times analysis described chapter flow insensitive summary analysis 
variable assigned binding time function body 
generating extension principle intimately related uniform binding time assignments 
variable change 
poor man approach flow sensitive binding time assignment renaming variables 
clearly automated 
investigated suspect gains possible 
struct variants described polyvariant analysis allows context sensitive analysis functions 
parameters function ascribed different binding times call site 
notice case structs struct member exist variant 
extension analysis accommodate variants struct definitions improve binding time separation 
analysis heap allocated objects binding time assignment heap allocated objects object birth place 
objects allocated call site binding time 
finegrained analysis desirable 
notice inter procedural binding time analysis improves binding time separation objects heap allocation different variants different binding times 
developed constraint polyvariant binding time analysis ansi programming language 
specified non standard type systems justified definition respect generating extension transformation 
gave constraint formulation developed efficient constraintbased analysis 
extension polyvariant analysis static call graphs described 
implemented analysis mix system provided experimental results 
evident figures analysis fast practice 
chapter data flow analysis develop side effect analysis analysis programming language 
aim side effect analysis determine side effecting functions assignments 
analysis approximates set variables objects truly function 
purpose data flow analysis gather static information program running computer 
classical data flow analyses include common subexpression elimination constant propagation live variable analysis definition analysis 
inferred information employed optimizing compiler improve performance target programs valuable program transformations generating extension transformations 
result analysis may analyses 
case chapter explicit point information employed track pointers 
compile time analysis complicated presence pointers functions 
overcome problem pointers factorize analysis separate pointer analysis data flow analysis 
applications pointer analysis developed chapter chapter 
side effect analysis approximates set unconditional conditional sideeffects function 
side effect called conditional execution controlled test statement 
show control dependence calculation determine conditional side effects formulate analysis monotone data flow framework 
iterative algorithm 
analysis similar live variable analysis deviates number ways 
yields fine grained classification objects centered functions program points 
example analysis may give result parameter pointer type address indirection 
analysis specified classical data flow framework 
analyses employed generating extension transformation suspend conditional side effects avoid specialization respect non data respectively 
chapter mainly uses techniques classical data flow analysis 
analyses systematic semantically founded way observe intriguing similarities constraint program analysis 
data flow analysis aims gathering information programs compile time 
chapter consider classical program analyses live variable analysis side effect analysis 
studied extensively fortran community lesser extent programming language 
main reason pointer concept supported solution employ factorize analyses parts explicit pointer analysis data flow analysis 
chapter serves give applications pointer analysis developed chapter illustrate usefulness 
analyses developed chapter application partial evaluation 
side effect analysis employed track conditional side effects suspended binding time analysis analysis prevent specialization respect unused data 
data flow analysis framework recall function represented single exit control flow graph set statement nodes set control flow edges unique start exit nodes respectively 
program represented inter procedural control flow graph monotone data flow analysis framework tuple inter procedural control flow graph semi lattice meet operator monotone function space propagation function assignment marlowe ryder 
assignment associates statements basic blocks propagation function framework called distributive function space distributive 
example constant propagation analysis lattice specified consists functions abstracting usual operators example 
constant propagation monotone data flow problem distributive 
example optimal solution program point data flow problem defined mop path path denotes paths called meet paths solution 
implicit meet paths called data flow analysis assumption paths executable 
maximal fixed point solution framework maximal fixed point equations mfp mfp fn mfp pred give syntax approach omit identify program point statement node 
pred set predecessor nodes fixed point computed standard iterative algorithms 
holds mfp mop monotone mfp mop distributive kam ullman 
case distributive problems maximal fixed point solution coincides optimal solution 
hand exists instances mfp mop kam ullman 
solutions methods solution iterative kildall kam ullman elimination allen cocke graham wegman ryder algorithms 
iterative algorithms propagate values data flow functions obtain solution elimination algorithms reduce control flow graphs compose propagation functions accordingly apply composed function problem 
theoretically elimination algorithms exhibit lower worst case complexity iterative algorithms problems equally fast kennedy 
elimination algorithms guaranteed irreducible flow graphs kind problems 
chapter shall consider iterative methods 
satisfying called rapid kam ullman 
shown iterations needed iterative algorithm compute mfp solution loop connectedness essentially corresponds number nested loops 
essentially means contribution loop independent values loop entry 
loop nesting programs modest rapid data flow problems tractable efficient practice 
example constant propagation fast 
means pass loops sufficient determine contribution marlowe ryder 
example inter procedural program analysis local analysis concerned analysis basic blocks 
global analysis considers data flow basic blocks 
intra procedural analysis focuses analysis function body worst case assumption function calls 
inter procedural analysis centered propagation data functions 
aim inter procedural analysis differentiate contexts function called avoid spurious information propagated 
example consider constant folding analysis program 
int main void int foo int int return foo foo inter procedural analysis merge calls approximate result foo gets bound 
inter procedural analysis avoid interference calls maps 
example chapter chapter conducted inter procedural context sensitive analysis basis program static call graph 
example context function may called separate point information available 
procedure cloning inter procedural analysis mainly concerned propagation information functions 
consider data flow information function body 
traditionally optimizations inter procedural analyses summary calls 
contexts function appears merged 
example constant folding program example give optimization summary bound 
suppose foo copied call sites changed accordingly 
enables constant folding expressions replaced respectively 
explicit copying program analysis undesirable may increase program size exponentially 
copying functions basis context sensitive analyses known procedure cloning cooper hall 
example reasonable cloning strategy create versions foo avoid copying second call foo 
example procedure cloning program example int main void int foo int int foo int int foo return return foo constant folding may replace expressions constants 
example explicit procedure cloning natural pre transformation transformation described chapter 
continue assume functions copied program static call graph transformation 
function exists number variants corresponding number call contexts 
recall static call graph maps call variant number called function variant 
context dependent analyses chapter rely context sensitive point information 
struct computation expression lvalues taming pointers consider live variable analysis expression 
assignment kills variables pointer may point uses variables may aliased 
pointer information worst case assumptions pointers point objects 
degrades accuracy analysis 
pointer analysis chapter approximate usage pointers 
recall pointer analysis computes set locations pointer may point program execution 
shall assume result analysis available form map aloc variant aloc set locations aloc defined chapter 
recall variant summary variant describing effect contexts function called 
definition expr expression 
set approximating lvalues variant defined 
definition justified follows 
constant lvalue location variable denoted name 
lvalue struct indexing lvalues corresponding field 
case pointer dereference expression pointer abstraction employed determine objects subexpression may point 
similarly array index expressions 
expressions lvalue 
recall pointer analysis abstracts unknown externally defined pointers unique location unknown 
example unknown means lvalue unknown 
overview chapter rest chapter organized main section 
section develops sideeffect analysis 
employ standard algorithm computation control dependence side effect analysis monotone data flow problem 
section develops analysis 
analyses point information approximate usage pointers 
section list related section discusses conclude 
may sense definitely point object set 
practice name corresponds declarator locality variable checked 
side effect analysis function commits side effect assigns non local object 
aim side effect analysis determine side effecting statements functions 
accurate determination undecidable due pointers 
analysis computes safe approximation set statements functions may side effect run time 
may side effect side effect occurs function executes object setting operation changes value non local object 
examples include global variable points heap allocated struct side effecting function scanf side effect input buffer 
examples illustrate externally defined functions may side effect 
naturally requires examination function body determine commits side effects 
assume externally defined functions annotated pure commit side effect 
analysis employed derive pure annotations automatically 
exact determination side effects undecidable paths executable assumption 
reason un decidability pointers landi 
consider assignment 
classification depends pointer 
points non local object expression side effecting 
imperfect pointer usage information form may point sets shall approximate side effects may side effect 
side effects conditional side effects differentiate kinds side effects conditional side effects unconditional side effects 
simply called side effect 
assignment non local object called conditional side effect evaluation assignment control test statement appearing function assignment 
conditional side effect intra procedural property 
definition define side effect domain se interpretation side effect non conditional may side effect conditional may side effect order 
elements side effect domain annotate assignments 
annotation denotes expression may side effect unconditionally indicates expression may commit conditional side effect 
conditional sideeffect annotation says test controls side effect 
practice convenient annotate control dependences 
example consider annotated push function 
int stack max stack sp push push stack void push int sp sp max stack stack sp fprintf stderr push overflow assignment side effects global variable sp 
second assignment control 
example side effect information recall generating extension transformation chapter expects side effects dynamic control suspended binding time analysis chapter 
side effect annotations binding time analysis suspend side effects pointer information binding time analysis suspend indirect assignments 
crude approximation set conditional side effects set side effects 
coarsely practical usage 
instance render impossible initialization static global data structures 
result side effect analysis easily employed suspend side effects dynamic control 
assignments annotated candidates 
depend dynamic test suspended 
analysis employed derive pure annotations automatically 
function contains side effects annotated pure 
control dependence function represented single exit flow graph set statement nodes set directed control flow edges unique start nodes respectively 
intuitively node control dependent node branch node contained alternatives 
definition node post dominated path contains node control dependent exists non trivial path node post dominated ii post dominated zima chapman 
node control dependent exit edges paths connect contains 
control dependence easily computed post dominator tree described algorithm 
post dominator trees constructed computation dominators reverse control flow graph aho 
algorithm computation control dependence flow graph 

construct post dominator tree 
define ancestor 

traverse backwards parent node mark nodes control dependent 
see ferrante proof algorithm ferrante 
post dominator tree constructed time log lengauer tarjan 
edge determined set constant time post dominator tree represented bit vectors 
traversing postdominator tree done time worst case path length total marking time 
definition node cd set nodes empty control dependent nodes 
example consider program example 
statement control dependent statement 
likewise 
example 
recall chapter assume conditional expressions transformed statements 
statement control dependent expression 
example consider binding time analysis program fragment 
control dependencies indicated program point 
statement correctly recorded contain conditional side effect relation describes dependency cd 
suspension statement depends test statements transitive closure cd contains dynamic expression 
example conditional may side effect analysis describe context insensitive conditional may side effect analysis 
extension context sensitive analysis straightforward repeat analysis variant 
may side effect analysis factorized parts 
pointer analysis approximate point information chapter 
notice included cd 
hand cd 

control dependence analysis determine control dependencies algorithm 

conditional may side effect approximation definition 
conditional may side effect analysis defined monotone data flow framework follows 
definition conditional may side effect analysis se defined 
function cse se node se conditional side effect defined cse cd cse returns statement contains side effect control dependent statement 
statement denote ns corresponding statement node 
equations determines map id se function identifiers side effect 
solution equations maps function may contain conditional side effect may contain unconditional side effect 
rules pre post increment assignment function determine lvalues expressions 
contains non local object object locally allocated expression side effecting 
approximate effect indirect calls point information 
rules statements checks contained expression may commit sideeffect conditional statement control dependent statement 
lemma analysis function functions defined distributive bounded 
proof inspection rules 
lemma analysis function functions defined rapid 
proof functions check se environments ordered point wise 
obvious definition data flow problem distributive solution standard iterative solving procedure aho kildall 
expressions ei ei alloc ef 
en ef pure ei 
en 
en aop ei ei sizeof statements cse ns cse ns si switch cse ns case cse ns default cse ns cse ns cse ns cse ei ns goto return cse ns 
sn functions si di dj sk di dj sk side effect analysis doing side effect analysis algorithm contains simple iterative algorithm conditional may side effect analysis 
algorithm iterative side effect analysis 
fi fi obviously algorithm optimal 
better performance obtained list algorithm functions visited depth order call graph horwitz 
annotation statements solely depends side effect contained expressions done analysis 
analysis variable program point value needed evaluation redefined 
section develops analysis 
analysis similar live variable analysis aho differs respect back propagation liveness functions 
furthermore analysis section fine grained classical live variable analysis 
analysis applied partial evaluation avoid specialization respect useless static values values computation 
objects information assigned sequence points entry exit statement function 
intuitively object program point exists object path exit node redefined 
definition program point function object aloc locally program point exists intra procedural path assigned 
function define iu aloc set objects entry node notion precise 
intuitively object expression value read store includes uses due function calls 
set locations aloc defined chapter 
ease presentation ignore constitute sequence points 
example iu main iu ptr ip 
int main void int ptr int ip int return ip int ptr return notice ip function ptr 
changed dereferenced parameter get iu ptr ip ip points array 
example opposed classical live variable analysis analysis expresses objects variables 
example classifying ip live example means pointer indirection live 
liveness notions liveness similar coincide 
main difference back propagated functions 
example consider functions 
int global int main void int foo int int local foo local return return global live variable analysis classifies global live foo due return statement main 
analysis reveals parameter foo 
example information appropriate partial evaluation live variables 
recall program points functions need specialized respect dead values gomard jones 
instance specialization live variables function foo example specialized respect global superfluous 
hand information insufficient register allocation dead code elimination rely liveness aho 
languages functions notion live variables variable equal 
generating extensions information employed generating extensions avoid specialization respect useless values 
convenient way convey information bit strings 
number global variables constant functions employ enumeration positions denote globals positions parameters locals 
bit representation defined inductively follows 
object base type denotes 
object pointer type indicates pointer gives indirection 
similarly array types 
case struct type represents fields 
example encoding ptr 
example section describes usage information 
set iu function contains object entry computation indirections parameter pointer type done means point information 
object pointer may point indirection 
analysis functions formulate analysis backward monotone data flow analysis set locations set union meet operator 
function seek set iu fun aloc describes objects uses 
analysis expressions similar live variable analysis 
expression backward data flow equation iu iu exp object objects defined contains formal definition 
definition straightforward 
function employed approximate effect pointers 
case function calls objects added 
apparent definition context insensitive version analysis 
information valid statement denoted iu stmt corresponding information written iu stmt 
analysis functions depicted 
equations straightforward 
case loops information body entry merged 
case return statement imaginary exit statement statement 
allows general rule statement sequences 
definition analysis aloc iu fun iu fun iu stmt functions iu stmt defined 
analysis function 
ei ei alloc ef 
en ei 
en ei iu fun 
en ei eo iu fun aop ei ei sizeof define analysis function dexp aop dexp analysis expression iu exp iu exp dexp analysis functions expressions ordering aloc defined chapter 
lemma analysis distributive data flow analysis 
proof analysis functions union intersect operators 
doing analysis analysis factorized subcomponents 
pointer analysis chapter 

analysis definition 
distributivity implies solution problem standard iterative solving algorithm aho kildall 
iu stmt iu exp iu exp iu stmt iu stmt iu ex iu stmt si iu exp iu stmt iu stmt si iu stmt switch iu exp iu stmt iu exp iu stmt iu stmt iu stmt case iu exp iu stmt iu exp iu stmt iu stmt iu stmt default iu stmt iu stmt iu stmt iu stmt iu exp iu stmt iu stmt iu exp iu stmt iu exp iu stmt iu stmt iu exp iu stmt iu exp iu stmt iu exp iu stmt iu exp iu exp iu exp iu exp iu stmt iu exp iu exp iu stmt iu stmt iu exp iu stmt iu stmt iu stmt iu stmt iu stmt goto iu stmt sm iu stmt return iu stmt iu exp iu stmt iu stmt exit iu exp iu stmt si iu stmt iu stmt si iu stmt si iu iu stmt sn analysis functions statements algorithm iterative analysis 
iu iu stmt fixed point iu implementation sets represented bit vectors enabling fast union intersection operations 
interested information branch statements entry functions storage usage modest 
enhancement minor change enhance accuracy analysis 
consider rules function calls iu exp 
en 
suppose defines global variable implies call part actual arguments 
taken account subtracting set outward defined objects objects 
related data flow analysis framework described distributive problems kildall extended monotone propagation functions kam ullman kam ullman 
refer aho el 
aho marlowe ryder survey marlowe ryder 
side effect analysis side effect analysis programs solves complicated problem def aho 
banning factorized problem direct side effects induced side effects due aliasing banning 
cooper kennedy linear time algorithm problem cooper kennedy 
inter procedural alias analysis landi developed modification side effect analysis subset analysis uses factorization similar banning analysis 
choi constructed analogous analysis choi 
employed interpretation approximate side effects function language 
problem complicated due higher order functions closures repertoire pointer operations limited 
live variable analysis live variable analysis studied extensively literature example problem data flow framework aho 
kildall presents iterative algorithm classical intra procedural problem kildall 
kennedy presents node listing algorithm kennedy 
comparison iterative interval algorithms reveals method general efficient kennedy 
yi harrison designed live interval analysis interpretation imperative intermediate language yi harrison 
computes interval object birth time dead 
procedure cloning specialization procedure cloning creates copies functions better exploitation data flow information 
seen specialization respect data flow properties 
intimate connection procedure cloning function specialization 
formulated side effect analysis distributive data flow analysis problems iterative solving algorithms 
analyses chapter formulated context insensitive 
extension context sensitive analyses straightforward 
analysis time writing implemented 
sideeffect analysis formulated optimal 
traverses program syntax tree repeatedly 
better approach derive data flow equations solve efficient list algorithm 
light analysis similar constraint analysis 
classical data flow analysis framework criticized firm semantically foundation 
correctness proofs analyses specification chapter obvious feasible 
interesting analysis closely resembles constraint analysis 
statement iu denote set variable gives corresponding constraint formulation problem 
difference data flow analysis constraint analyses finite domains minor 
shows classical efficient data flow algorithms may benefit constraint program analysis 
chapter separate program analysis specialization partial evaluation quickly evolving program specialization technique 
technology developed mature applied realistic software engineering 
chapter study problems emerge program transformation systems applied real world programs 
pervasive assumption automatic global program analyses transformers subject program consists module 
existing partial evaluators monolithic analyze specialize programs 
practice software structured modules implementing different aspects complete system 
currently problem side stepped merging modules big file solution infeasible impossible 
storage usage impose upper limit size programs 
chapter investigate separate analysis separate specialization 
example problem consider separate binding time analysis allows modules analyzed independently modules 
objective twofold possible handle large programs convenient way modification module necessarily mean modules analyzed scratch 
may instance reduce analysis overhead manual binding time engineering necessary obtain results 
extend framework consider incremental binding time analysis accommodates modules changed binding time solution having recomputed scratch 
separate incremental analysis constraint solving extensions analysis developed chapter 
sketch principles carry analyses 
part chapter study separate specialization 
partial evaluation inherently global transformation requires access parts program transformed 
outline problems preliminary methods 
separate analysis implemented mix system time writing expected major practical importance 
program transformation means partial evaluation quickly evolving program specialization technology reached state applied nontrivial real life problems 
traditional partial evaluators global transformers monolithic analyze transform programs 
conflicts modern software engineering advocates organization software cleanly separated modules 
practical experiments mix system revealed separate treatment real scale programs matters 
far problem overcome merging different translation units big file 
practice infeasible analyze inspect binding time annotations line program say 
time storage usage critical 
techniques treatment modules obviously needed 
developed separate incremental binding time analysis 
consider separate specialization 
example binding time analysis developed chapter techniques carry constraints analyses 
partial evaluation modules traditional partial evaluation accomplished means symbolic evaluation subject program 
mix partial evaluator subject program specialization respect static input performed mix pgm val ps pgm ps residual program 
practice separated modules 
mn module implements different aspects complete system 
example module opens reads files module carries computations 
large systems infeasible apply partial evaluation modules useless 
specialization modules result significant speedup 
practice want specialize modules 
applying mix module mix mi pgm val solution 
module incomplete may non trivial deliver static input mix 
example mi read complicated data structure built module 
straightforward construct static input hacking modules mix uses representation data 
undesirable feature transformation system programs changed order handled 
modules generating extensions consider program specialization generating extensions 
specialize module mi convert generating extension gegen mi pgm pgm link modules generating static input 
possible generating extension uses representation static data subject program 
generating extension technique superior traditional partial evaluation respect modules 
partial solution 
module specialized mix gegen fall short 
suppose mi mj implement code interest specialization 
mi say contains external function calls function defined module mj 
isolated analysis specialization mi suspend calls functions defined mj probably prevent results 
problem mix gegen precisely binding time analysis faces similar problem type checking presence modules 
check types functions module compiler rely type declarations supplied user 
modules contain binding time annotations binding time analysis worst case assumptions external suspended 
undesirable error prone indicate binding times manually 
time consuming due unnoticed phenomena may wrong 
binding times inferred automatically 
pragmatics far users partial evaluators adopted pragmatically oriented attitude applied various tricks overcome problems 
example merging files externally defined functions may defined 
solve basic problem merging done system 
partial evaluation panacea user binding time engineer program obtain results 
instance may necessary suspend static variable avoid code explosion 
practice inspection program binding separation required 
examination lines code say option programmer 
convenient inspect modules separation 
module changed complete program analyzed scratch 
wasteful modification affects minor part program possibly changed module 
nature binding time analysis possible analyze module completely separately modules uses 
binding time analysis inherently global analysis needs information status externally defined identifiers 
change module may influence binding time division modules 
possible way partial evaluator system maintain global bindingtime solution updated modules added modified removed 
way relevant parts software systems parsed analyzed due change modules merged 
binding time division inspected module module 
possible binding time signature module extracted global binding time solver 
binding time signature capture dependencies module externally defined identifiers 
global analysis set binding time signatures solve global problem 
notice binding time signature computed time module changed 
time division computed 
chapter develops needed techniques 
module module module gegen bt bta separate binding time analysis analysis steps develop separate incremental version binding time analysis chapter 
recall binding time analysis implemented constraint solving 
new analysis proceeds phases 
module parsed binding time information extracted reduced 

global binding time problem initially solved traditional constraint solver 

global solution maintained incremental constraint solver accommodate modifications modules 
represent maintain global binding time solution data base employed 
user interface extract information data base display annotated module code 
illustrates partial evaluation system 
separate specialization motivation separate compilation memory limitation 
large programs may exhaust compiler symbol table build big internal representations 
problem traditional partial evaluators conspicuous generating extensions 
generating extension uses representation static data subject program 
reasons favor separate specialization 
example huge residual program may exhaust compiler give long compilation times 
overview chapter rest chapter organized follows 
section describe interference modules specialization 
section extends previous constraintbased binding time analysis separate analysis 
section develops incremental constraint solver implements incremental binding time analysis 
problems related separate specialization transformation discussed section 
related mentioned section section concludes gives directions 
problem modules trivial programs separated modules 
programming language module translation unit basically file declarations 
section investigate interaction global program analysis specialization modules 
example consider program built translations units 
file file extern double pow double double include errno int errno extern int errno int goal int double pow double double double pow errno return exp log printf result errno return return file function pow declared invoked goal function 
file power function defined 
errors reported variable errno sake presentation defined main module 
external identifiers suppose aim specialize main module dynamic 
argument pow static constant expect call specialized call pow 
pow externally defined function specialized definition unknown specialization time 
gained specialization 
consider binding times identifiers file 
seemingly external variable errno static context defined bindingtime analysis necessarily classify dynamic external variables appear residual programs 
summary externally defined identifiers suspended 
consequence calls library functions sin suspended 
defined library extern declared include files math 
exported data structures functions consider file defined 
apparently errno global variable belonging file 
global identifiers default exported modules explicitly defined local 
global definition principle accessed global meaning program 
translation unit modules interchangeably 
scope global variable restricted translation unit means static storage specifier 
modules declare extern 
looking module isolation reveal modules modify global variable 
example file determined pow file writes errno 
obviously suspension global identifiers conservative practical uses 
practice convenient user option specify file program global identifiers classified static 
functions exported global variables 
means functions explicitly local means static storage specifier potentially called modules 
modules analyzed isolation call sites bindingtime patterns known 
safe binding time analysis suspend arguments 
function specialization take place 
situation alleviated slightly copying functions local calls get specialized 
summary identifiers specified static suspended 
pure external functions suppose call pow file pow 
case expect call replaced result provided definition pow available 
file linked generating extension file 
naturally binding time analysis classify call external defined function static know compiled definition eventually available specialization time 
noted safe binding time analysis global program information unconditionally suspend calls externally defined functions may side effect variables 
way improve provide binding time analysis information function side effects 
define function pure commit side effects execution 
assuming externally defined function linked specialization time calls pure function static arguments classified static 
example pow pure function may side effect non local variable errno 
library functions report errors errno variable 
ways problem exists instance functions math specified pure 
mix system specifier pure applied specify side effect free functions 
example pure extern pow double double erroneously specify pow pure 
separate binding time analysis consider scenario 
software system consists number modules file 
standard libraries 
aim specialize files necessarily 
monolithic binding time analysis relevant files merged analyzed coherently 
mix user means option specify file program 
trouble majority programmers bother check errors 
section describe separate binding time analysis analyse modules separately 
idea perform analysis steps essential binding time information module extracted stored common data base 
global binding time problem solved 
step done time module despite global problem solved times due modifications manual binding time engineering 
ideally possible done phase 
benefits efficiency file parsed analyzed files modified repeatedly 
re usability module contexts analyzed 
prime example library functions 
convenience user analyze inspect binding time having change logical structure program 
software rewritten rearranged meet requirements system issue partial evaluation applied existing programs 
refer static analysis works module boundaries inter modular analysis opposed intra modular analysis 
binding time analysis inter modular binding times module may depend binding times modules due external variables 
output separate analysis shall equal result intra modular analysis union files 
restriction section consider monovariant binding time analysis 
analyze languages inter procedural inter modular analyses may needed instance pointer side effect analysis 
return section 
constraint binding time analysis revisited section briefly reviews binding time analysis mix see chapter 
analysis specified non standard type inference implemented means constraint solving 
practice analysis intermingled parsing static type inference give self contained presentation 
analysis basically consists steps 
generation constraint system capturing binding time dependencies expressions subexpressions 

normalization constraint system exhaustive application set rewrite rules 

computation minimal solution normal form constraint system 
step done syntax directed traversal syntax tree 
normalization accomplished time linear number constraints 
binding time classification variables division easy derive annotation 
example consider assignment errno section 
recall errno extern declared file 
constraints generated int int int int int int errno errno errno errno denotes binding time variable associated errno 
system constraint errno added file analyzed isolation effectively suspending errno 
example constraint system normalized exhaustive application set solution preserving rewrite rules 
normal form constraint system consists constraints form bs solution constraint system substitution binding time variables constraints fulfilled 
minimal solution maps dynamic due dependency constraint suffices consider dependency constraints 
inter modular binding time information binding time global identifier determined module defining modules cf 
section 
global information binding time analysis revert worst case assumptions suspend global 
known identifier eventually defined may necessary suspend 
set identifiers exported module called provided set set identifiers imported module called required set cooper 
language global variables defined static storage specifier provided set 
identifiers declared extern required set 
identifiers declared static required provided call private 
example consider file section 
required set contains errno 
provided set includes pow 
private identifiers 
example constraint system corresponding module normalized general solution 
reasons binding times required identifiers unknown secondly provided identifiers unknown 
division contain binding times allocation calls type definitions 
see corresponding theorem section 
assuming extern declared identifiers referenced 
separate analysis proceeds main phases 
phase generates normalizes constraint systems module 
local modular phase modules analyzed independently 
second phase solves global constraint system corresponding modules 
phase global applies modules separate modules parsed analyzed 
example consider file listed section 
phase generate constraint system containing constraints listed 
global constraint solver applied constraints suspend external identifiers added 
global constraint solver applied constraint systems file file identifiers defined suspension constraints added 
example keep track symbols constraint systems global data base mapping identifiers bt types 
cooper ross 
binding time signatures module binding time signature consists information binding time type global identifiers 
provided required sets 
binding time constraint system 
bt types provide link identifier binding time variables 
provided required sets easily identified extern static storage specifiers 
normalized constraint system set equations binding time variables 
example binding time signature file section listed 
file file extern errno int pow double double double bta constraints follows identification translation unit 
listed type global identifiers possibly storage specifiers 
part contains binding time constraint system 
assume binding time variables unique prefixed module name 
example practice data base distributed kept file importance 
add constraints data flow equations analyses 
generate file cmix containing binding time information 
cmix file read file cmix solve constraints generate file gen cmix file compile generating extension files cc file gen gen link object files produce gen cc file gen gen gen separate generation generating extension number binding time constraints linear number expressions typically lower 
case global identifiers private declared static constraints solved 
convenience add local variables binding time signatures 
allows example user interface data base binding time variables convenient way 
doing inter modular binding time analysis global solving process proceeds phases 
relevant signature files read symbol table mapping identifiers type binding time variables established 
identifiers declared modules identified corresponding binding time variables unified 
practice done adding equality constraints global constraint system 
symbol table updated reflect identifier defined external modules 
static identifier named uniquely name conflicts occur 
global binding time constraint system collected binding time signatures 
symbol table scanned remaining extern declared identifiers 
constraints suspending added 
constraints suspending identifiers added due user annotations 
lastly global constraint system solved 
symbol table provides link identifier binding time 
consumer binding times instance generating extension transformation chapter data base identifiers binding time see 
algorithm inter modular binding time analysis 

read binding time signatures build symbol table set global constraint system 

add suspension constraints externally defined identifiers 

solve global constraint system 
symbol table contains computed division 
consider phase 
session separate analysis illustrated 
symbol table symbol table provides connection identifiers bt types 
model map id storage type 
practice symbol table implemented hash table say 
operations needed lookup insert 
scan binding time signatures storage specifications resolved 
definition previously extern declared identifier met extern flag removed entry 
bt types identical identifiers unified addition equality constraints global constraint system 
step corresponds actions taken linker link separately compiled files 
example consider example program section 
symbol table illustrated 
errno int errno int int goal goal double double double pow files linked identifiers defined evident lack extern specifiers 
extern variable io buffer struct iob appear symbol table struct extern iob static identifiers named uniquely henceforth need static storage specifier 
example analysis symbol table contains computed division example errno int suspension constraints aim phase add constraints suspend external identifiers 
identifier bt type recorded external symbol table constraint added constraint system 
example constraint suspends iob variable 
example implicit exposition program binding time analyzed 
may convenient apply separate analysis parts system 
case constraints suspending global identifiers added global constraint system 
assume user option specifies files constitutes complete program 
declared stdio 
pow example experiments useful suspend static variables avoid code explosion specialization code little prospective speedup 
mix specifier residual employed 
constraints suspending residual declared identifiers added part module constraint system global system 
convenient environment user interactively inspect effect suspensions 
example constraint system solving global constraint system solved techniques developed chapter normalization 
notice constraint system module normalized global constraint system needs normal form 
example identifier may assigned result external dynamic function 
runtime algorithm linear number constraints see section 
solving procedure implemented described chapter binding time variables symbol table destructively updated solution 
binding times approach described deviates framework chapter syntax tree directly annotated binding time result constraint solving 
binding times identifiers recorded symbol table 
described section easy derive annotation division simple bottom traversal syntax tree 
done generating extension transformation separate step 
correctness separate analysis formulate correctness criterion separate binding time analysis prove correct 
correctness follows correctness monolithic analysis chapter 
theorem file 
translation units 
applying separate binding time analysis file 
gives result monolithic analysis applied union files 
proof separate analysis resolves storage specifications way translation units merged manually complies ansi standard iso 
implies suspension constraints added global constraint system monolithic analysis 
monolithic analysis identifier assigned exactly binding time variable 
equality constraints added separate analysis assures identifiers location unified 
constraint system built separate analysis solution system monolithic analysis solves 
incremental binding time analysis separate analysis previous section computes program division scratch time module changed 
section develops incremental analysis allows solution constraint system updated changes modules 
incremental analysis 
existing binding time analyses exhaustive re compute solution scratch time part program changes 
clearly modern analyses tend fast may time consuming task inconvenient interactive programming environment fast response time essential 
incremental analysis affected part solution re computed 
example 
program specialization engineering process user analyzes functions inspects binding times probably manually suspends variable insertion directive residual flag 
analysis point view change typically consists addition new constraint 
exhaustive analysis generate complete constraint system solve 
separate bindingtime analysis renders generating complete constraint system superfluous solution global systems scratch 
example 
automatic binding time annotation programs editing example structured programming environment may provide programmer valuable information 
idea programmer editing file interactively see binding times immediately avoids undesired program constructs 
constraint binding time analyses essentially generate constraints syntax directed manner incremental analysis maintain evolving solution changing constraint set 
section solely consider binding time analysis 
incremental pointer analysis briefly considered section incremental versions classical data flow analyses referenced section 
basic idea basic idea incremental constraint solver maintain solution constraints added removed 
original presentation constraint bindingtime analysis untyped lambda calculus henglein briefly described extension accommodating addition constraints henglein 
algorithm supports deletion constraints 
solution dynamic contrary 
reason destructively updated data structures 
situation resembles conditions re iteration fixed point solver finding solution altered data flow equation system ryder 
necessary condition solution new system bigger old solution 
claim algorithms developed chapter sufficiently fast 
implies user inserted residual specifier removed solution computed scratch 
describe incremental constraint solver allows constraints added removed 
scenario follows 
global constraint solver maintains solution files currently scope program 
file updated old constraints removed new set constraints added 
constraint removed effect solution undone 
components incremental constraint solver incremental constraint solver parts 
map representing bindings identifiers bt type symbol table routines adding deleting constraints 
assume constraint sets pre normalized equality constraints removed substitutions unification 
representation solution solution maps binding time variables un instantiated variables interpreted bindings represented 
binding time variable dynamic reasons due constraint due constraint dynamic 
notice variable may dynamic due constraint 
hand variable dynamic due exactly constraint constraint deleted solution changes variable static 
represent map btype bt ype 
suppose 
component bvar multi set variables directly depends 
variable directly depends exists constraint 
example constraints labeled constraints directly depends due constraints 
number denotes number times forced dynamic 
means static 
intuitively number constraints variable currently mapped dynamic 
example suppose constraint set 
current solution map variables static depend 
variable dynamic variables depends 
notice dynamic count dependency constraints force dynamic 
example reason count opposed boolean flag representing dynamic 
suppose variable dynamic due constraints practice symbol table represents information storage specifiers 
constraint may appear multiple times constraint set 

constraint removed solution change 
second removed solution updated reflect static 
count represents number constraints removed static 
simplicity take undefined mean static 
implementation binding map represented hash table hash methods lookup search recorded binding insert destructively insert new binding 
assume value dynamic pre inserted hash constraints handled constraints 
adding constraint consider addition constraint maintaining current solution 
cases possible 
constraint effect current solution simply add constraint variable dynamic update binding map reflect constraint introduces new dependency variables update binding map reflect 
assume represented variable cases treated 
adding constraint nature solution dynamic 
algorithm add set constraints 
add constraints current constraint system add constraint add dep function add dep defined algorithm 
algorithm uses auxiliary function add dep 
constraint form forces dynamic 
implemented function 
constraints simply causes dependency lists updated 
algorithm add dependency 
dynamic add dependency add dep hash lookup hash lookup hash insert hash insert upd 
dep 
var dynamic function increases dynamic count associated type variable 
variable changes status static dynamic dependent variables 
function add dep adds dependency type variables 
dynamic variable 
example suppose current constraint system defined example 
add constraints algorithm 
new binding map correct solution current constraint system desired 
example deleting constraint removing constraint current constraint system may cause solution dynamic variables may change status dynamic static 
happens constraint forcing variable dynamic removed 
algorithm remove set constraints 
remove constraints current constraint set remove constraint remove dep break remove dep remove dep function defined algorithm 
removal constraint causes dynamic 
implemented function 
cases dependency lists updated 
set difference operator multi set operator removes occurrence element algorithm remove dependency 
variable static remove dependency remove dep hash lookup hash lookup hash insert hash insert dependent variables dependent variable algorithm decreases dynamic count variable 
static zero dependent variables 
function remove dep removes dependency variables 
dynamic 
example suppose constraints added example removed 
removing causes level decreased remains dynamic 
removing constraint eliminates dependency set decreases level zero 
modulo empty static binding solution example expected 
example self dependencies examples handled way 
consider constraint systems graph 
constraint form removed constraint set strongly connected component containing computed 
variables component forced dynamic variables dynamic changed static 
correctness incremental binding time analysis section proves correctness incremental constraint solver 
denotes current constraint set current solution 
definition map called valid solution constraint set variables 
map 
map obtained application algorithms constraint system denoted clearly prove correctness incremental solver suffices consider addition versus deletion single constraint 
lemma constraint set constraint 
assume valid solution map obtained application add constraint algorithm yields valid solution 
proof informal cases consider 


number constraints forcing dynamic number constraints making dynamic dynamic addition valid solution holds depends 
dynamic addition dependent variables correctly updated dynamic 

variables depend set depend inclusion binding time status change due addition dynamic constraint dynamic 
correctness operation follows part proof 
shows correctness add constraint 
lemma constraint set constraint 
assume valid solution map obtained application remove constraint algorithm valid solution 
proof informal proof analog proof lemma 
cases consider 


set constraint forces dynamic 
deletion static dynamic count dependent variables decreased 


dependency map correctly updated reflect dependent due dynamic dynamic due constraint correctness follows part proof 
shows correctness remove constraint 
theorem constraint set valid solution 
solution obtained addition deletion set constraint application add constraint algorithm remove constraint algorithm valid solution resulting constraint system 
proof follows lemma 
demonstrates correctness incremental constraint solver 
doing incremental binding time analysis incremental update current binding time division due modification file summarized follows 
algorithm incremental binding time analysis 

read file signature file remove constraints current constraint set 
possibly remove suspension constraints 

perform modification 

apply local part separate binding time analysis obtain new constraint set 
recall constraint may exist 

read signature files add new constraints current constraint set 

possibly add suspension constraints 
step step uses add constraint remove constraint respectively 
notice removal constraints global symbol table updated changes 
example definition variable removed entry attributed extern storage specifier 
step crucial binding time analysis uses variable names previously 
easily fulfilled making variable names unique 
step symbol table scanned order add suspension constraints due externally defined identifier 
separate specialization described separate binding time analysis developed incremental constraint solver accommodates modifications modules 
section concerned separate specialization specialization program individual specialization modules 
convincing reasons pursuing goal 
partial evaluation inherently global process relies presence complete program 
describe outline necessary conditions separate specialization 
consider specialization library functions 
motivation assume usual scenario program set modules file 
aim specialize 
apply separate binding time analysis transform file individually generating extensions link generating extensions run executable 
idea specialize files separately run generating extension file gen separately 
advantages contained specialized residual program larger origin may exhaust compiler 
separate specialization residual program contained modules file spec 
spec manageable compiler 
manual binding time engineering limited impact specialization 
changing module normally causes residual functions changed 
need specialize program scratch 
separate specialization enables re residual code 
example library specialized typical arguments shared specializations 
procedure run generating extensions file gen 
gen obtain residual modules file spec 
spec compiled linked form specialized program 
section analyze problem explain separate specialization extent conflicts partial evaluation 
conflicts global transformations modules identify main reasons separate specialization fails preservation evaluation order passing static values module boundaries 
imperative languages dynamic functions return static results side effecting non local static variables 
practical reasons desirable allow instance initialize global data structures heap allocates partially static objects 
functions possibly static side effect depth specialization function calls required 
evaluation order may changed 
function calls may module boundaries renders separate specialization difficult 
suppose disallow non local functions side effects 
implies dynamic function call affect subsequent specialization caller called function specialized stage 
requires values static arguments stored value global variables function uses 
may non trivial task case values composed types pointers structs heap allocated data structures 
separate specialization general requires storing establishing computation states program run 
separate specialization say module amenable separate specialization provided functions called modules fulfills static parameters base type uses non local values base type accomplishes side effects 
restrictions justified follows 
function takes base type arguments uses non local values base type easily stored example file module specializations 
requirement assures evaluation order preserved function specialization performed breadth opposed depth execution order 
concretely separate specialization proceed follows 
call function defined module amenable separate specialization met call static arguments values global variables recorded log file 
residual call generated immediately specialization function definition 
specialization module specialized log 
practical experiments needed evaluate usefulness method 
suspect main problem functions amenable separate specialization mixed functions 
libraries hand candidates separate specialization 
example specializing library functions practical experiments revealed worth specializing functions pow 
example specialization pow fixed exponent speeds computation factor 
noted section library functions pure may sideeffect error variable errno 
defining function functions pure suitable specialization 
idea add generating extensions library functions allow partially static calls externally defined functions 
example suppose program contains call pow dynamic variable 
normally call suspended generating extension pow available call function specialized 
example mix generating math lib gen part system 
generating math lib linked generating extensions follows cc file gen gen lm gen mix library 
binding time analysis informed functions defined gen 
example speedup obtained specialization ecological simulation software described chapter extent ascribed specialization power function 
notice library functions binding time analyzed transformed 
separate incremental data flow analysis section briefly consider separate incremental pointer data flow analysis 
developed implemented separate incremental pointer analysis 
separate pointer analysis recall chapter pointer analysis set analysis implemented constraint solving 
uses inclusion constraints form 
techniques developed section carries pointer analysis 
file constraint set written module signature file 
global solver reads signatures sets global constraint system solves sun sun os math library 
algorithm chapter 
result symbol table maps identifier abstraction 
incremental pointer analysis developed lines section 
case map represent inclusions variable set variables related separate compilation pervasive concept modern programming languages natural concept commercial compilers apparently little attention paid separate analysis 
example gnu compiler compiles function function perform inter procedural analyses stallman 
cooper study impact inter procedural analyses modular languages cooper 
burke describes global data base record interprocedural facts modules compiled burke 
knowledge exists partial evaluators incorporate separate analysis specialization 
type inference presence modules mature concept case functional languages 
plausible existing type bindingtime analyses extend able separate analyses 
henglein gave initially thought followed implemented henglein 
consel jouvelot studied separate binding time analysis lambda calculus effect inference consel jouvelot 
lambda calculus contains global data structures side effects problem somewhat simpler 
efficient implementation analysis constraint solving probably look algorithms 
incremental analysis mainly studied framework classical data flow problems 
example reaching definitions marlowe ryder available expressions pollock soffa live variable analysis zadeck 
ramalingam reps developed algorithm incremental maintenance dominator trees ramalingam reps 
analyses extended complex language featuring dynamic memory allocation multi level pointers pointer arithmetic 
freeman benson described incremental constraint solver linear constraints freeman 
constraint systems simpler henceforth maintaining solution easier 
separate compilation re compilation closely resembles separate program specialization 
olsson whitehead describe simple tool allows automatic recompilation modular programs olsson whitehead 
global dependency analysis examines modules generates makefile 
hood developed similar global interface analysis hood 
chapter studied separate program analysis specialization 
algorithms binding time analysis modules developed 
separate analysis enables binding time analysis modules accommodate modifications incremental constraint solver allows maintaining current solution having re compute scratch 
discussed separate specialization modules identified main problems 
material chapter implemented mix system time writing 
problems separate pointer analysis data flow analysis remain solved 
algorithms chapter support polyvariant analysis programs 
complicates separate analysis library functions polyvariant binding time assignment critical 
extension polyvariant analysis possible inter modular call graph 
techniques previous immediately carry 
recall constraints vectors solved 
problem length vectors unknown solve time 
main motivation separate specialization reduce memory usage specialization 
outlined criteria separate specialization modules restrictive practical purposes 
liberal conditions left 
completed development separate incremental binding time analysis algorithms outlined possible implementation 
expect separate analysis major practical importance 
program specialization requires manual engineering programs possibility examine modules complete programs clearly valuable 
techniques far sufficiently developed accommodate separate specialization 
practice residual programs easily huge may exhaust underlying compiler 
envision program specialization environment keeps track functions specialized allows technology applied feasible possible 
environment analyses developed chapter central 
chapter speedup theory analysis partial evaluator automatic program optimization tool pragmatic success yields efficient residual programs panacea 
specialization pays means large speedups times 
chapter study speedup partial evaluation theoretical practical point view 
program optimizer said accomplish linear speedup optimized program constant factor faster original program input 
long suspected accepted partial evaluation constant folding reduction dynamic expressions specialization unfolding transition compressing better linear speedup constant factor depend static input independent dynamic input 
gives upper bound prospective speedup specialization hope specialization exponential time algorithm yields polynomial time program 
hand constants matter practice 
modest speedup may significance program runs hours 
prove partial evaluation accomplish super linear speedup 
faced program usually hard predict outcome specialization careful examination program structure 
developed simple pragmatically successful speedup analysis reports prospective speedups binding time annotated program 
analysis computes speedup interval speedup obtained specialization belong interval 
analysis works computing relative speedup loops objective computation time spent loops 
due simplicity analysis fast feasible practice 
analysis prove correctness give experimental results discuss shortcomings introduce improvements 
furthermore describe various applications analysis 
outline technique takes values static variables account 
enables accurate estimates speedups 
chapter extended version andersen gomard joint carsten gomard 
chapter owes neil jones jones chapter 
years partial evaluation demonstrated usefulness automatic program specialization technique numerous experiments 
cases specialization produced residual programs order magnitude faster 
experiments revealed partial evaluation panacea specialization gives little speedup 
user detailed knowledge partial evaluation underlying principles usually unable predict outcome specialization time consuming manual inspection residual programs 
practice question specialization program worthwhile answered applying partial evaluator running residual program 
goal find better way chapter study speedups partial evaluation viewpoints prove theoretical limit prospective speedups describe analysis predicts speedups 
prospective speedups informative answer question particularly desirable partial evaluation applied computationally heavy problems 
clearly wasteful specialize program run hours just realize gained 
worse specialization time consuming 
partial evaluator ideally slow program upper limit obtainable speedup due simple transformation partial evaluator performs 
particular clever transformations requiring meta reasoning subject programs spectacular change algorithms replaces bubble sort quick sort 
examples include replacing naive recursive definition fibonacci function linear iterative version 
illuminating example string matching pattern searched string 
length pattern length string naive string matcher possesses runtime 
fixed pattern knuth morris pratt matcher knuth runs time 
question partial evaluation naive string matcher fixed pattern give kmp matcher 
turns case 
prove partial evaluation accomplish linear speedup 
implies partial evaluation program respect static input gives program constant factor faster original subject program 
statement contains parts 
speedup obtained specialization depends static input 
provide examples show dependency 
secondly speedup independent dynamic input 
thirdly super linear speedup impossible exponential runtime reduced polynomial runtime 
formulate prove speedup theorem general setting captures imperative programming languages 
predicting speedups estimate prospective speedup available specialization valuable information 
partial evaluation applied feasible possible case 
basis speedup estimate user rewrite program improve speedup proceed specialization speedup estimate satisfactory simply forget 
logical combine speedup analysis binding time debuggers allow inspection binding times 
prospective predicted speedup decide perform operation specialization time suspend 
example unrolling loops contribute little speedup undesirable due increased code size avoided 
speedup estimation clearly undecidable 
shall base analysis approximation relative speedup concentrate loops due fact computation time spend loops 
simple pragmatically successful speedup analysis approximates speedup gained interval 
interpretation static input residual program times faster source program 
partial evaluation may result infinite speedup upper bound may infinity 
consider example program containing completely static loop bound determined static input 
reservation carry analysis speedups simplifications 
shall assume basic operation addition numbers takes fixed time 
general true imply computation time high level expression summing computation time expression parts 
optimizing compilers may change expensive computation cheaper instructions may discard useless expression 
shall mainly ignore aspect 
practical experiments shown speedup analysis gives reasonable useful information despite simplifications 
return depth study interaction specialization classical code optimization chapter 
overview chapter remainder chapter organized follows 
section define measurement speedup linear speedup prove partial evaluation accomplish super linear speedup 
section develops automatic speedup analysis computes speedup interval basis binding time annotated program 
section describes approach prospective speedup computed execution generating extensions 
section cites related section holds list 
technique loop dynamic binding time analysis specialization 
partial evaluation linear speedups consider program represented control flow graph set statement nodes set control edges unique start exit nodes respectively 
languages functions language fits framework see chapter 
statements speedups relate run times subject specialized programs 
tricky subject program input program residual program inputs dynamic data 
measuring execution times computation state program point store mapping locations variables values 
program execution passes control state pi si new state pi si written pi si pi si finite program execution sequence transition steps pi si pi si pj sj pj terminal 
program execution starts program point corresponding store initialized program input 
notice single statement basic block may constitute program point immaterial exposition 
transition cost terms runtime 
example program point pi expression statement followed goto program point pk cost cost expression plus control flow jump 
runtime program applied input approximated length transition sequence leading initial program point final program point 
program input write execution time 
means program input speedup obtained partial evaluation ps ps denotes specialized respect example speedups percentage improvement execution time 
thesis solely state speedups form defined 
example input denote size assume order data sequence data si si meaningful 
assume control flow graph captures extended control flow graphs 
loss generality assume subject programs take inputs 
linear speedup clearly fixed static input actual time occurs running specialized subject programs depends dynamic input 
definition input program static input 

define relative speedup su ps dynamic input 
define speedup bound sb lim su static input specialization program respect static input loops define speedup su speedup bound normally taken speedup obtained specialization 
notion linear speedup defined terms speedup bound jones jones jones 
definition partial evaluator mix accomplishes linear speedup program speedup bound sb finite formulated differently definition requires fixed static input shall exist ps finitely example strict ps 
demand mix optimize arbitrary program means require 
see take empty input 
example largest speedup su exist 
consider example program consisting single loop spending equally time static dynamic computation add static statement outside loop 
bounds su finitely 
correct choice speedup static statement contributes little loop iterated 
examples examples illustrate relation static input speedups 
implicitly assumed mix terminates 
static data intuitively static data speedup expected 
need true 
program contains static data form statically defined arrays specialization may give speedup 
clearly speedup independent dynamic input 
dynamic data suppose program specialized input 
residual program simply returns constant 
obviously speedup determined static input independent dynamic input 
additive run times assume program 
speedup specialization sb lim su cf 
definition 
calculation relies program eventually spends time dynamic computation static computation 
practice static computation may dominate specialization worthwhile 
string matching chapter show naive string matcher specialized yield efficient kmp matcher slight change naive matcher 
speedup bound sb length pattern 
speedup linear depends heavily static input 
super linear speedup 
jones posed open question jones mix uses techniques program point specialization constant folding transition compression unfolding exist programs mix accomplishes super linear speedups 
equivalently exists programs speedup bound definition finite 
example mix unsafe reductions introduces memorization eliminates common subexpressions easy conceive examples super linear speedup 
reductions may change termination properties subject programs 
example assume lim 
prove partial evaluation restricted program point function specialization constant folding transition compression unfolding accomplish superlinear speedup 
done assumption partial evaluator terminates place bound speedup 
provide negative answer question jones jones 
loss generality assume program point computation cost basic statement run time program execution amounts length transition pn sn assume annotation classifying statement static dynamic respect initial division 
theorem speedup theorem andersen gomard jones suppose mix safe partial evaluator program 
assume mix terminates static input mix accomplish super linear speedup 
proof dynamic input consider standard execution pn sn implicitly assumed termination 
initial store contains static input dynamic input step computation involves computing values si variables new program point due execution 
suppose statements marked binding times consider standard execution 
consider partial evaluation done path pn sn expressions marked static evaluated specialization constant folding static control flow statements executed transition compression 
case dynamic expression code generated reduction residual jump generated case dynamic control flow statement specialization 
beware specialization static evaluations executions computation path general performed 
recall consider standard execution imagine done specialization 
usual computations done specialization called static postponed runtime called dynamic 
calculate speedup particular choice simply sum costs static dynamic computation transition sequence 
ts cost static computations similarly td su ts td td fixed 
original residual program terminates theorem trivially fulfilled 
assume wlog 
dynamic computation carried 
assume mix specializer generating extension terminates steps 
means mix applied program static input steps transition sequence intervening code generation step mix executes statement generates code residual statement mix faster standard execution 
dynamic statement static statements implying ts td 
gives su ts td td td td td independent notice mix generates residual statement return value 
estimate far larger speedup expected practice argument shows speedup bounded 
predicting speedups estimate prospective speedup available residual program run valuable information 
basis speedup approximation user decide specialization worthwhile binding time improvements necessary satisfactory result 
especially important case computational heavy problems example scientific computation berlin weise 
speedup estimation performed different stages listed order available information 
time analysis residual program extreme apply original specialized programs dynamic input measure execution times 

analysis subject program static input 

analysis subject program binding time division variables 
clearly approach gives best results requires information 
gives observed value speedup obvious relate empirical speedup instance binding time annotations 
second approach advantageous third procedure exploit exact value static variables 
third way general due absence static dynamic data precise 
useful results obtained see 
speedup analysis third approach study ways implement second 
input speedup analysis binding time annotated program output speedup interval actual speedup may 
safety speedup intervals speedup interval ir ir program captures possible speedup su sense precise 
speedup interval safe speedup su converges element interval grow 
general speedup converge fixed shall require program runs long shall exhibit speedup arbitrarily close interval 
definition safety speedup interval speedup interval safe sequences si di si di su sj dj sj dj psj dj consider scenario section loop contains equally static dynamic computation assume speedup independent choice safe precise speedup interval 
simple loops relative speedup consider programs represented control flow graphs 
precise cycles loops program include function calls 
return section 
loop control flow graph sequence nodes ni nk ni ni edge nk 
simple loop loop nk ni nj statement cost ni execution cost ni 
example ni number machine instructions implementing ni number machine cycles necessary execute ni 
discuss definition cost function greater detail section 
notational convenience define cs ni cost ni ni statement static similarly cd 
sequence statements 
nk cost static statements denoted cs ni 
definition relative speedup loop relative speedup su rel defined nk loop 
cs cd cd su rel cd cs cs ni cd cd ni 
relative speedup loop number ir independent values variables 
addition involving ir doing speedup analysis program easy find set simple loops aho 
practice may convenient compute set natural loops 
basic idea analysis relative speedup program determined relative speedup loops program run sufficiently long time 
algorithm speedup analysis 

simple loops compute relative speedup su rel 

relative speedup interval min su rel max su rel speedup analysis take basic blocks statements outside loops account 
clearly speedup loops dominate speedup program provided execution time large 
analysis easily modified handle remaining basic blocks accumulating relative speedups paths program loops 
revision analysis meaningful say programs loops 
example consider contrived program implements addition 
int add int int int sum sum sum return sum basic blocks second constitute simple loop 
suppose static dynamic 
statements static rest dynamic 
letting cost statements unit relative speedup loops 
relative speedup interval 
example see speedups non simple loops computed speedup interval see safe loops safe loop composed 
lemma simple loops program common start node assume safe 
safe loop number repetitions 
proof assume wlog 
su rel su rel executes times executes times 
su rel cs cd cd mcs ncs mcd ncd mcd ncd mcs mcd mcd mcd ncd mcd ncs ncd su rel mcd ncd mcd suppose su rel su rel su rel su rel mcd ncd mcd su rel mcd mcd mcd su rel similarly su rel 
su rel su rel su rel ncd mcd ncd ncd su rel mcd ncd ncd su rel mcd ncd ncd su rel mcd ncd ncd safe theorem safety speedup analysis assume analysis computes speedup interval program safe proof upper bound trivially safe assume 
consider sequence nodes ni visited terminating computation arising application data nk node ni may occur times delete simple loop ni nj replace ni nj nk delete simple loops possible denote set remaining loops definition remaining nodes occur size program provides bound number non loop nodes 
denote set program data calculate speedup su cs cs cd cd cd cd rewritten su cs cd cd cd cd cd cs cd cd cd cd cd argue exists su choose sequence di di 
right numerator cs cd uniformly bounded cd converges cd 
left denominator converges 
conclude su cs cd cd di 
multi set simple loops conclude safe lemma 
notice choice sequence di di rules completely static loops specialization program assumed terminate 
experiments implemented speedup analysis examined behavior number examples 
implemented version solely considers loops differentiated cost function statements expressions 
analysis fast significant analysis time examples 
experiments conducted sun sparcstation times measured unix time command user seconds 
programs polish int scanner originate book 
add program listed example 
program polish int implements interpreter simple post fix language 
example static input specification computes primes 
dynamic input 
program scanner general lexical analysis inputs token specification stream characters 
specialized specification different tokens appeared times input stream 
example run time speedup original specialized measured estimated add scanner polish int add program speedup factor independent dynamic input converges static input grows 
tight interval 
interval scanner quite satisfactory 
specification unambiguous tokens little done mix time speedup close lower bound example 
hand supplied table contains fail backtrack actions upper bound approached shown 
upper bound polish int correctly interpreter code handling unconditional jumps completely static program pp halt switch program pp case case jump pp program pp break case 
unbounded high speedup obtained specialization respect program sufficiently unconditional consecutive jumps 
justify seemingly non tight speedup interval computed analysis reasonable applied polish form interpreter different programs different static inputs 
program exploits different parts interpreter 
primes program computes primes 
add program equivalent function add example 
jump program consists single loop unconditional jumps 
measured speedups follows 
example run time speedup original specialized measured primes add jump experiments clearly demonstrate actual speedup depend static input previously claimed 
limitations improvements speedup analysis demonstrated pragmatic success limitations suffers significant drawbacks 
lower bound computed analysis usually provides fairly estimate easy construct examples fool analysis 
loops related consider example program fragments 
suppose static dynamic interfere meaning programs observable effect 
program left estimated speedup interval counting kinds statements 
corresponding interval program right due completely static loop 
result safe certainly tight useful 
problem loops considered isolation analysis fails recognize loops iterate number times 
approximating number loop iterations analysis errs conservatively correctly reports infinite speedup due static loops subject program 
cases loop bound program 
computed 
enhance accuracy analysis bounded static loops left speedup computation added speedup case residual loops 
generalized constant folding analysis harrison hendren may applied approximation loop iteration space 
investigated 
relating loops exemplified major shortcoming analysis loops treated completely unrelated 
method loops contribute equally final approximation speedup 
example program loops iterated times speedup iterated times speedup actual speedup clearly close 
speedup analysis report safe loose speedup interval 
methods approximating number loop iterations alleviate problem 
variations speedup analysis far assumed global speedup computed analysis 
variations analysis may useful 
partial evaluation applied huge programs may valuable speedup estimate function collection functions 
basis function speedup interval specialization applied functions contributes significant speedup functions low speedup binding time engineered left consideration 
combined frequency execution time analysis computed unix command prof time spend experiments specialization lowered 
analysis easily extended support 
change needed intra procedural loops collected call expressions appropriate costs 
depending programs result analysis may coarse recursion left speedup approximation 
hand avoided completely static functions distort result global analysis 
final example consider speedup estimates determining feasibility loop unrolling 
suppose loop dynamic statement 
clearly undesirable unroll loop due code duplication 
general impossible say static loop unrolled 
reasonable strategy loops shall unrolled speedup body certain lower limit 
particular loop speedup unrolled 
predicting speedups generating extensions previous section developed analysis estimates speedup value static variables available 
advantage analysis time independent static dynamic variables analysis err conservatively account static values 
section outline approach speedup computed specialization 
concretely shall assume specialization accomplished execution generating extensions 
accounting static values aim program static input compute speedup valid dynamic input actual values static variables available problem unbounded static loops 
drawback execution time analysis depends specialization time experience specialization normally fast generating residual program obtain speedup estimate obstacle practice 
unbounded speedup impossible unbounded speedup manifests non termination precise speedup computed 
residual program may dynamically choose branches different speedups 
describe approach profiling information inserted generating extensions 
speedup analysis generating extensions generating extension run number times static loop iterated counted 
unrolling loop gives straight line code residual program speedup diminish residual loops iterated sufficient times static loops left speedup computation 
beware static loops may unrolled inside dynamic loops 
extend generating function counter dynamic loop count number static statements executed count representing number residual statements generated 
specialization dynamic loop completed counters employed calculate speedup residual loop 
similar analysis previous section analysis result smallest interval includes speedups loops 
experimented analysis practice expect give reasonable results 
related long suspected partial evaluation accomplish linear speedup apparently proved published 
yuri gurevich independently come similar reasoning 
knowledge attempt automatic estimation speedup partial evaluation 
speedup partial evaluation hansen proves setting logic programming fold unfold transformations give rise linear speedup 
restrictions imposed mix assumed 
note unification assumed run constant time may completely accordance reality 
proved chapter partial evaluation give constant speedups uninteresting classical complexity theory point view 
jones shown constant factors add computation power small imperative languages jones 
remain investigated constant speedups encountered program transformation employed classify strength transformers 
answer appears negative partial evaluation extended positive context propagation strictly increases power possible transformations positive context propagation believed give linear speedups 
speedup analysis versus complexity analysis automatic complexity analysis received attention years 
aim program possibly size descriptions input compute worst case complexity function op terms input size tempting apply techniques automatic complexity analysis speedup estimation 
example illustrate linear speedup partial evaluation fit ordinary complexity analysis 
consider loop 
sj assume relative speedup obtained specialization statement sequence 
sj relative speedup program approximately regardless loop static dynamic 
loop static complexity analysis residual program produce answer loop taken constants matter practice 
unrolled 
loop dynamic result 
insight speedup gained way 
techniques automatic complexity analysis adapted aid problem speedup analysis 
properties optimized programs developed analysis predict form residual programs 
output analysis grammar indicates structure specialized programs 
analysis say speedups 
inlining unfolding part compilation partial evaluation effect execution times studied 
davidson holler applied function inliner number test programs measured effect execution times davidson holler davidson holler 
notice pure empirical results prospective savings due inlining estimated 
ball describes analysis estimates effect function inlining ball 
analysis relies call statistics feasible programs exhibit long execution times 
possible directions continuation preliminary results chapter 
believe automatic speedup estimation emerging field important partial evaluation non experts 
costs instructions section simple statement cost assigning statement 
trivial refine function picture cost various expressions 
assignment high level syntax accurate may influenced optimizations 
consider turn 
operation expressed different ways 
consider example versus 
seemingly reasonably assign larger total cost expression 
hand compilers generate efficient machine code practice cost expressions comparable 
known specialization program may enable optimization possible unrolling loop resulting large basic blocks 
optimizations may unexpected effects speedups 
consider loop specialization result straight line code 

suppose loop invariant 
original program moved outside loop executed 
specialized program executed times 
apparently partial evaluation degrades efficiency 
leave investigate relation speedups optimizations subject residual programs 
preliminary study undertaken chapter 
estimation code size run times key measurement judging success automatic transformations optimizations 
case realistic programs code size matters 
large programs may result unexpected loss performance due register allocation pressure increased number cache fails considerable longer compilation times 
size residual program broadly speaking determined factors unrolling static loops inlining unfolding functions statements 
intuitively linear relation code size speedup reasonably gain efficiency price super linear code size blowup prevented 
programs obvious relation code size speedup making automation generalization respect code impossible 
class programs called oblivious algorithms jones chapter exhibits behaviour contain test dynamic data code size grows linearly static input 
obvious way transform non oblivious program behaved program 
unsafe optimizations super linear speedup speedup theorem section assumes mix performs safe reductions 
example partial evaluation allowed throw away possibly non terminating expressions 
cases recognized automatically manually safe discard expression perform unsafe reductions 
natural partial evaluator share computation residual program detect safe 
causes effects unsafe reductions super linear speedup remain investigated 
investigated speedup partial evaluation 
proved mix techniques function specialization function unfolding transition compression constant folding super linear speedup impossible 
see chapter 
example specialization dynamic causes statements inlined branches 
simple useful speedup analysis developed implemented 
analysis computes speedup interval estimating relative speedup simple loops binding time annotated program 
shown interval safe approximation actual speedup 
outlined speedup estimation accomplished execution generating extension yielding tighter speedup intervals 
described experiments showed reasonable results pointed analysis fail miserably programs 
believe speedup estimate valuable information users partial evaluator systems investigation field undertaken 
chapter partial evaluation practice aim program specialization efficiency 
application partial evaluator successful residual program faster subject program 
furthermore system preferably efficient 
previous chapters seen examples partial evaluation apparently pays 
practice unexpected aspects may influence actual speedup 
way assess usefulness technique applying realistic examples 
implemented prototype version system developed thesis 
system implements described techniques generated examples reproduced chapter 
traditional optimization techniques partial evaluation average produce efficient programs 
particular residual programs efficient subject programs generated 
normally believed specialization enables greater classical optimization substantiated large basic blocks partial evaluation tends generate 
specialization give significant speedups enabled optimizations may contribute give result 
investigate relation specialization optimization find astonishing connections 
particular observe partial evaluation may disable optimizations degrade performance programs 
leads discussion order program optimizations applied 
known partial evaluators sensitive changes subject programs 
slight modification may difference insignificant speedups 
furthermore programs amenable specialization 
provide example specialization similar algorithms gives different results 
chapter organized follows 
chapter provide overview implementation status 
chapter concerned relationship size speedup practical point view 
chapter describe intriguing interferences specialization optimization 
experiments reported chapter 
chapter holds lists topics 
mix partial evaluator prototype implementation partial evaluator mix described thesis 
implemented generates programs currently implementation consists approximately lines code 
overview overview system provided 
parser builds syntax tree representing subject program 
parsing type checking type annotation performed various attributes initialized 
types separated value flow analysis carried 
program analyses applied succession static call graph analysis chapter pointer analysis chapter side effect analysis chapter binding time analysis chapter 
speedup analysis chapter implemented previous version mix analysis implemented 
generating extension generator chapter converts binding time annotated program program 
annotated version subject program inspected separate window 
time writing implemented separate binding time analysis incremental constraint solver developed chapter 
mix practice typical session mix shown 
specialize binary search function example section 
time writing implemented coarse converts ugly residual programs ugly residual programs 
specialized program chapter listed generated mix 
notice improve efficiency readability 
speed versus size underlying principle partial evaluation specialization program points values 
consequence algorithms dependent static input data independent dynamic input data specialize 
data dependent algorithms intuitively partial evaluation yields speedups programs controlflow branches determined statically function calls replaced constants 
programs containing control flow decisions dependent dynamic data telling truth 
generation generating extension cmix bdd bsearch bsearch gen cc bsearch annotated version program inspected window 
compiling linking bsearch gen cc main gen cc bsearch gen main gen cc file contains main function calls generating extension static input 
object files linked mix library 
specialization bsearch gen bsearch spec result program 
compilation linking gcc bsearch spec main bsearch spec original main function changed changed type bsearch 
execution time bsearch spec io pf session mix suitable specialization branches dynamic specialized potentially leading residual programs exponential size 
example tests loops matrix multiplication function data independent matrices 
matrix mult multiply matrices result void matrix mult int int int int int int specialization respect static unroll loops produce straight line code 
example algorithm control flow depend dynamic input called oblivious jones chapter 
specialization oblivious algorithm results straight line code size polynomial respect input 
matrix multiplication example oblivious 
huge basic blocks usually enable classical local data flow optimizations elimination common subexpression partial redundancies aho may give better exploitation pipelined computers berlin weise 
due fast development larger computers code size priority speed 
section argue huge basic blocks thing 
program run buy memory 
bsearch return entry key table int bsearch int key int table int low high mid low high mid low high table mid key low mid table mid key high mid return mid return binary search function variant clearly programs oblivious contain oblivious parts 
specialization non oblivious algorithms may result residual program exponential size compared subject programs 
suppose example program contains calls function branches dynamic 
residual program specialized versions appear static differ 
residual program probably efficient subject program code size may render specialization infeasible 
algorithms fulfilling set values bound static variables independent dynamic input called weakly oblivious jones chapter 
desirable property weakly oblivious algorithms specialization static input terminate provided normal execution terminates dynamic input 
reason dynamic input influence values assigned static variables 
specialization non oblivious programs may loop static values accounted 
example binary search function non oblivious table classified dynamic tests depends table 
example case study binary search consider specialization binary search functions 
shows classical binary search function depicts variant bentley 
ignore mix specifier residual 
specialization respect static input may useless notice table size hard coded programs 
static input presence functions 

function bsearch bentley example manual code tuning 
hand derived residual program generate automatically bentley 
return entry key table int bsearch int key int table int mid ifdef cmix residual endif int left table key left mid mid mid table left mid key left mid left table left key return return left binary search function variant specialization bsearch function dynamic key table yields residual program appearance 
program generated automatically int int int return return return return 
programs shown generated mix 
loop unrolled dynamic specialized 
faster program especially huge lines 
consider variant binary search shown 
part residual program shown 
program generated automatically int bsearch int int return return return return return 
result equally bad 
suspend variable left 
indicated mix specifier residual unconditionally forces variable classified dynamic 
result shown 
program generated automatically int bsearch int int int goto cmix label goto cmix label cmix label goto cmix label goto cmix label cmix label goto cmix label goto cmix label 
program better 
size log table size residual programs exhibit size 
table reports speedups code 
upper part table shows result specialization dynamic key table 
runtimes user seconds sizes number program lines 
experiments conducted sun sparcstation ii mbytes memory programs compiled gnu compiler option 
program runtime sec code size lines orig spec speedup orig spec blowup table dynamic bsearch bsearch left stat bsearch left dyn table static bsearch bsearch classical binary search function gave largest speedup compared 
price paid seconds specialized version bsearch faster specialized version bsearch high residual version bsearch times larger residual version bsearch times larger 
lower part table shows speedups specialization static table 
variant yields slightly larger speedup programs comparable respect code size 
pleasing result small experiment speedup obtained specialization bsearch despite modest code blowup 
negative result means obvious classical binary search function replaced slightly efficient routine specialization 
hard discover left suspended looking annotated version program obvious genius suspensions automated 
specialization optimization program specialization aims making programs efficient slower 
section study interference partial evaluation classical optimizations loop invariant motion partial redundancy elimination common subexpression elimination 
traditional partial evaluation technology subsumes inter procedural constant folding dead code elimination loop unrolling 
enabling disabling optimizations small illuminating example 
example consider specialization function parameters classified dynamic 
specialized function shown middle 
loop static unrolled 
int foo int int int foo int int int foo int int int return return return observe expression loop invariant 
right residual program obtained loop hoisting invariant specialization shown 
apparently function foo preferable function foo 
suppose expensive loop invariant 
case foo efficient foo due repeated computations invariant 
apply dead code elimination foo revealed dead foo 
example lesson learned specialization techniques may enable disable optimizations 
partial evaluation normally enables local optimizations inside basic blocks tends produce large basic blocks due unrolling loops 
furthermore larger basic blocks give better exploitation pipelined parallel machines 
seen disable global basic blocks optimizations loop invariant code motion 
seemingly optimizations disabled specialization applied partial evaluation 
classical optimization applied subject partial evaluation improve residual programs 
example indicate affirmative answer 
example binding time analysis takes branches conditionals consideration 
suppose dead code elimination removes branch possibly due result constant folding analysis containing assignment dynamic value variable 
may enable static division 
example order optimization known classical optimizations interact give different results depending sequence applied soffa 
example dead code elimination enable constant propagation elimination code introduce new constants 
hand constant may enable dead code elimination test may constant 
gnu compiler jump optimization phase run common subexpression elimination 
consider classical optimization techniques relation partial evaluation 
interested efficiency residual program 
example applying common subexpression elimination static expressions specialization may reduce specialization time enhance quality residual code 
common subexpression elimination cse 
partial evaluation invariant common subexpression elimination dynamic expressions 
cse improve partial evaluation 
hand specialization may enable candidates elimination due increased size basic blocks 
invariant code motion icm 
specialization tends remove loops new candidates icm introduced 
contrary seen example partial evaluation may disable icm 
constant propagation cp 
partial evaluation includes constant propagation reason apply cp subject programs 
hand residual programs may benefit cp constant folding due lifted constants fact binding time analysis conservative 
loop fusion lf 
loop fusion merges loops objective elimination control instructions 
partial evaluation invariant lf dynamic loops henceforth lf specialization improve lf applied residual programs 
consider matrix multiplication program example suppose inner loop suspended reduce code size 
residual program consists sequence loops 

loop fusion bring 
loop unrolling lu 
partial evaluation includes loop unrolling 
due constant folding specialization may enable loop unrolling subject program 
effect achieved double specialization 
strip mining sm 
aim strip mining decrease number logically related instructions body loop instruction cache active part table held registers 
partial evaluation produce negative effect 
generates large basic blocks loops decreasing likelihood cache hits 
hand exploitation pipelining may enhanced 
consider interaction constant folding 
optimization cse icm cp lf lu sm sr raa lva pe opt 
pe opt 
interaction partial evaluation optimization reduction sr 
strength reduction applied loop 


suppose dynamic 
residual programs result specialization 

obviously sr degrades effect partial evaluation case 
suppose loop appearance 


static dynamic 
case sr benefit separated dynamic sr variable classified dynamic 
register allocation assignment raa 
aim keep active variables registers reduce number load store instructions 
due data structure splitting number variables may grow causing register allocation pressure increased number cache misses 
live variable analysis lva 
seen live variable analysis improves quality residual code respect code size 
considerations summarized 
line means partial evaluation may enable optimization possible improve efficiency code 
means partial evaluation potentially may disable optimizations possible 
second line means specialization benefit optimization 
knowledge optimization programs partial evaluation exploited existing partial evaluator 
automated binding time improvements seen exception 
case strength clearly shows decision apply optimization partial evaluation non trivial 
observations illustrated strength reduction optimizations may change binding time classification variables 
example dead code elimination elimination dead dynamic code may allow variable classified static 
natural procedure automatically inspect binding times detect expressions may benefit classical optimizations specialization 
may require binding time analysis iterated may expensive 
leave characterize optimizations transformations profitably applied binding time analysis 
suspect transformation form expressions cleanly binding time separated may enhance efficiency residual programs 
immediate problems pop residual programs readable high level assembler provision useful feedback rendered hard 
experiments section reports results obtained experiments mix 
provide examples specialization lexical numerical analysis routines ray tracer system ecological modelling 
lexical analysis lexical analysis time consuming task compilers humans compiler 
carefully hand coded scanners perform automatically generated scanners constructed lex practice lex produced scanners employed 
reason straightforward tedious job implement lexical analysis hand 
waite experiment hand coded scanner compared lex generated scanner waite 
hand coded scanner times faster 
example test specialization naive lexical analysis yields efficient lexer 
scanner developed example chapter 
simple program scan uses called trie representation tokens 
conversion language description form lex specification trie trivial 
drive loop consists lines code 
experiment conducted 
specified keywords tokens trie table lex specification 
white space accepted comments 
trie table consisted entries lex scanner dfa states 
scanner specialized respect trie giving program spec 
lex generated scanner lex produced flex default setting table compression 
results shown generated sun sparcstation ii mbytes memory programs compiled gnu compiler option 
robert gl ck directed 
time size sec speedup lines blowup scan spec lex scan lex scan spec lex scan lex input different keywords appearing times input stream 
times reported user seconds 
speedups specialized scanner scan lex respectively 
seen scanner comparable lex produced scanner 
specialized version times faster general version nearly twice fast lex produced scanner 
sizes programs determined follows 
size scan includes driver table 
size lex size file lex yy output flex includes tables driver 
seen specialized version scan times bigger lex produced scanner 
scientific computing scientific computing results programs prime candidates optimization 
example algorithms solving linear algebraic equations taken standard book specialized 
experiment carried peter holst andersen diku 
program implements lu decomposition matrices 
program solves system linear equations forward backward substitution 
programs library programs stem book press 
programs specialized mix respect matrix dimension 
sun sparcstation mbytes memory programs compiled gnu compiler option results measured 
program time size orig spec speedup orig spec blowup specialization lu decomposition program gives speedup 
specialized version solving function twice fast original version 
speedup due unrolling loops 
lu decomposition algorithm complexity size residual program grows fast 
speedup surprising simple algorithms 
ray tracing ray tracer example developed peter holst andersen diku realistic application mix andersen 
ray tracer program showing dimensional scenes screen 
works tracing light rays view point view scene 
idea specialize respect fixed scene 
noted ray tracer highly optimized partial evaluation applied 
experiments performed hp programs compiled gnu compiler option 
program sizes object file size kbytes 
scene time size orig spec speedup orig spec blowup seen speedup obtained specialized program twice fast original 
reduction size due elimination unused scenes original program 
ecological modelling ecological modeling system sesame system simulation biological processes north sea 
system developed netherlands institute sea research kindly disposal collaboration diku 
experiments reported conducted peter holst andersen diku 
system models flow gases fixed called boxes areas 
simulation performed extrapolation development solution number differential equations 
model particular ecological model consists lines code sesame libraries differential equation solver consists lines code 
experiments done sun sparcstation mbytes memory 
model simulated days years respectively 
simulation time orig model spec model speedup days years speedup modest significant long execution times 
surprisingly substantial part speedup due specialization pow function fixed base 
furthermore inlining functions turned essential results 
sizes residual programs comparable original model 
specialization version sesame including advanced features expected yield larger speedups 
considered partial evaluation practice reported experiments mix 
implementation system improved number ways 
separated analysis developed chapter major pragmatic value implementation completed 
investigation interaction partial evaluation traditional program optimization continued 
generally causes effects specialization efficiency need deeper understanding 
considering various transformations subject programs binding time analysis transformation improve efficiency residual programs 
preliminary analysis chapter cast light deficiencies speedup analysis chapter development needed accurate estimation speedups 
case study section illustrated dependency partial evaluators subject programs 
notice particular variable suspended aim binding time improvements normally contrary 
example discouraging respect automation binding time improvements 
static variables suspended avoid unacceptable code blowup 
binding time improvements applied 
practical experiments necessary order get deeper understanding pays 
summary provided number experiments clearly power partial evaluation 
speedups reported considerably smaller obtained functional language community expected 
speedup significant improvement 
speedup compared improvements obtainable classical optimizations advanced register allocation typically shorten execution time 
stress considered realistic programs programs show results 
experiments shown development needed automate simplify application specialization realistic programs 
rewriting code necessary today reduced feedback indicating specialization applied useful 
chapter improvements driving partial evaluator genius program transformer 
gives results times fails optimize simple programs 
naive transformations performed particular decisions intelligence clever insight 
known partial evaluators sensitive changes subject programs 
experience shown minor modifications may propagate programs unexpected ways 
hand program specialization partial evaluation fully automatic stronger transformation paradigms 
limited speedups say matter practice 
nature hard obtain substantial speedups optimization low level efficient languages improvements possible functional languages originate general programming constructs pattern matching 
chapter consider binding time improvements aim give better results 
gradually introduce powerful improvements require insight subject program amenable automation 
shift consider strictly stronger transformation technique driving 
main contribution chapter initial steps automation driving driving transformation technique part supercompilation far automated extent 
show case example positive context propagation essence driving transform naive string matcher knuth morris pratt matcher task partial evaluation accomplish 
introduce generating super extensions supercompilation equivalent generating extensions partial evaluation 
developments reported perspectives discussed 
aim chapter catalogue useful tricks hacks applied subject programs 
opinion necessary rewrite programs order apply program transformation 
ideally strong detect naive program constructs handle convenient way 
manual rewritings option programmer trying optimize big programs 
currently goals fulfilled case simple languages 
evident chapter partial evaluation panacea 
specialization pays form significant speedups programs cases partial evaluation achieves 
theoretically program run time improved constant proved chapter 
unfortunately partial evaluation sensitive minor changes input 
ideally partial evaluator bring programs form suitable specialization 
practice binding time improving rewriting applied programs obtain result 
aim rewriting normally reveal static information 
catalogue transformation techniques program transformation techniques stronger partial evaluation studied literature 
formulated small purely functional declarative languages generalized realistic applications 
furthermore methods amenable automation demonstrated contrived examples 
list program transformation paradigms listed order power 

classical optimizations instance common subexpression elimination loop hoisting elimination partial redundancies aho 

partial evaluation known evaluation expressions reduction unknown expressions specialization unfolding functions jones 

driving generalized partial evaluation gl ck jones 

supercompilation turchin 

fold unfold transformations burstall darlington 
notice mentioned techniques source source optimizations consider language language transformations compilation produce optimized low level implementations efficient high level formalisms 
notable example apts system paige cai compiles set formulas efficient cai paige 
partial evaluation includes classical optimizations differs availability partial input 
naturally partial evaluation may exploit static input program form tables disregard moment 
hand fold unfold transformation methodology may produce considerably improvements program input deforestation wadler 
deforestation aims eliminating immediate data structures functional languages formulated set fold unfold rules 
driving partial evaluation plus context propagation closely related theorem proving 
idea branch know unknown 
branch contains test theorem proving applied show test evaluate false 
propagation information branch called positive context propagation branch negative context propagation 
clearly harder assert false driving positive context propagation uncommon 
driving partly automated small functional languages gl ck generalization realistic languages remain handle prevailing termination problem 
driving seen instance general technique known supercompilation 
currently supercompilation formulated implemented language turchin 
transformation techniques formulated framework fold unfold transformations 
fold unfold consists rules instantiate define fold unfold 
knowledge automation general technique achieved 
special cases 
example restricted version deforestation incorporated glasgow haskell compiler gill 
example genius transformation example genius intelligent optimization framework fold unfold transformations 
consider general definition fibonacci function int fib int return return fib fib ease presentation assume pair structure definition struct pair int function pairs integers returns pair 
step define function iter 
definition eureka 
step invented useful transformation 
step instantiate iter unfold definition fib 
step function definition eliminates common subexpression fib 
step recognize iteration iter transform function loop step 
step unfold iter fib 
unfolding sum function sum splitting pair iterative definition fib step 
case functional languages 
section modelled jones page 
fold unfold step application known transformation schema 

int fib int return return sum iter struct pair iter int int sum struct pair return pair fib fib return 
struct pair iter int return pair return fib fib fib 
struct pair iter int struct pair struct pair int return pair return fib fib return 
struct pair iter int return pair return iter 
struct pair iter int int struct pair pair return 
int fib int return int struct pair pair return sum 
int fib int return int return transformation fibonacci function net effect exponential algorithm transformed linear algorithm 
far partial evaluation accomplish transformation appears hard automate 
overview chapter chapter organized follows 
section case study generation kmp matchers partial evaluation 
section investigate driving automate example section 
section contains related section discuss conclude 
case study generation kmp matcher study specialization naive pattern matcher fixed pattern 
matcher runs time mn length pattern length string 
specialized matcher runs time 
similar experiment chapter specialized strstr respect fixed needle 
section slightly ambitious goal automatically generate efficient knuth morris pratt kmp matcher knuth achieve chapter 
meet goals extend partial evaluation positive context propagation 
positive context propagation means positive outcome tests propagated branch ifs 
theorem proving exploited decide dynamic tests 
example shift static pattern step respect dynamic string 
section obtain effect positive context propagation rewriting string matcher apply binding time improvement 
section initial steps automation technique known driving 
notice partial evaluation described chapter achieve effect transforming naive string matcher kmp matcher apply manual binding time improvements 
driving strictly stronger transformation technique 
naive pattern matcher slightly modified version string matcher kernighan ritchie kernighan ritchie page 
accordance strstr standard library function version returns pointer match string index 
function listed 
considerably simpler slower 
gnu implementation considered chapter works way 
matcher compares characters pattern string shift pattern step case mis match 
partial evaluation static input aab yields residual program 
return pointer null char char char int return return null naive pattern matcher kernighan ritchie page char char return return complexity result number nested ifs partial evaluation unrolled inner loop eliminates tests jumps 
residual program efficient original program improvement modest 
positive context propagation problem naive pattern matcher known information thrown away 
key insight initially observed knuth morris pratt mis match occurs static pattern provides information prefix dynamic string 
employed shift pattern step redundant tests avoided 
consider inner loop rewritten goto goto test dynamic due dynamic string 
partial evaluation specializes 
specialization program depends crucially algebraic reduction operator 
return pointer null char char char char ss strlen sp int ss ss return shift prefix sp ss sp sp sp return null naive pattern matcher positive context propagation consider specialization branch 
dynamic know run time content equal test fulfilled branch taken 
idea save information determine forthcoming tests 
gradually pattern matched dynamic string information inferred 
introduce array ss strlen represent known prefix 
array initialized shown 
modified program shown 
test inner loop changed static prefix ss information available dynamic string 
ss current position pattern compared ss 
test true algebraic reduction assure test comes positively 
information string available manifest ss dynamic test string performed 
body loop prefix string ss updated match fails prefix shifted pattern shifted respect string 
binding time improvement amounts positive context propagation exploit branch statement 
kmp matcher specialization improved matcher pattern aab gives residual program 
restructured output renamed variables aid readability char char cmix label return goto cmix label return return matcher perfect beauty spot test immediately goto cmix label 
remove negative context propagation required 
careful reader recognize kmp matcher 
case match aa character match proceeds position initial 
benchmarks shown 
experiments conducted sun sparc station ii mbytes memory programs compiled gnu compiler option 
match done times 
input runtime sec pattern string naive spec kmp speedup aab aab aab aab naive naive matcher spec specialized version naive kmp specialized version improved version naive 
speedup naive kmp 
experiment similar carried chapter 
see naive matcher faster gnu implementation strstr 
reason expensive calls 
practice gnu version compete naive version large strings 
compare residual programs 
kmp matcher twice fast specialization gnu strstr 
example original exposition kmp matcher knuth 
generating super extensions previous section achieved automatic generation kmp matcher manual revision naive string matcher 
trick introduce positive context propagation 
section consider adding positive context propagation partial evaluation specialization naive matcher gives efficient kmp matcher 
partial evaluation context propagation known driving 
preliminary development form case study 
needed automate technique encounter problems way 
online decisions driving intimately connected online partial evaluation 
specialization variables may change status unknown known due positive context propagation test previously unknown 
information unknown greater represented 
existing experimental drivers notably developed gl ck gl ck symbolic evaluation constraints variables represented lists 
argued previously specialization realistic languages best achieved execution generating extensions 
pursue approach uses mixture direct execution online specialization techniques 
particular idea transform programs generating extensions include context propagation 
call generating extension performs context propagation generating super extension 
development mainly restrict positive context propagation extension limited form negative context propagation easy consider propagation scalar values 
specialization pointers structs described chapter 
furthermore assume subject programs pre transformed sequence points occur test expressions operator transformed nested ifs 
ease presentation program language allows user defined overloading operators 
representation unknown values assume binding time analysis classifies static computations depend unknown input 
problem representation dynamic integer values generating super extension 
execution may change status known represent static value times may unknown possibly constrained 
generating super extension represent dynamic integer values class 
ignore constructs 
enum btime equal greater unknown class int btime binding time int val value known code code piece code public int void equal val int int equal val btime btime void return btime btime btime return int value void return val int value int return val void syntax code code int consists binding time tag indicates status value 
equal means value known value equals val 
means value unknown val 
unknown means value unknown 
cases field code contain code representing value representation unknown 
example consider naive string matcher 
wish infer information unknown input 
problem size array points unknown 
amount information stored unknown 
drivers functional languages dynamic allocation representation inferred information 
shall take simpler restrictive approach 
assume pointer known array unknown content 
define generating super extension follows code char int pointer array unknown chars int array assumed big 
example theorem proving define equality operator int 
int operator int int int switch btime case equal switch btime case equal btime equal value value value break case value value btime equal value return btime unknown syntax break idea check status operands evaluation dynamic operator 
operands happen known test carried result known 
second operand unknown known test definitely false value operand 

notice comparisons implemented underlying operator integers symbolic evaluation concrete values 
similar style operators defined 
example driving known produce terminating programs subject programs 
problem apparent definition 
second case non terminating value anyway known value net effect operand discarded 
non terminating computation may thrown away 
example operator definitions implement limited form theorem proving exploited decide dynamic tests 
example consider program fragment generating extension 
suppose static dynamic currently known value 
int int 
test classified dynamic binding time analysis generating super extension decided case known value 
need specialize branches 
remarks 
integer value lifted int array index expressions 
assume operator int defined 
example practice implemented code generating function follows int test label label switch test btime case equal test value goto true 
goto false 
case test value goto false 
specialize 
don know 
case unknown specialize 
don know 
binding time test value checked see test decided 
similar algebraic reduction operators deciding dynamic tests described chapter 
context propagation context propagation amounts exploiting positive negative outcome tests branches dynamic 
observe 
specialized evaluation test expression generating super extension returns int containing syntactic representation expression 
follows 
branch specialized traverse representation test expression perform positive context propagation 
precisely apply function code test 
void code switch type case btime equal value break case btime value break case btime unknown 
function updates value int variable exploiting test expression evaluate true run time 
similarly function defined 
example side stepped important problem 
context propagation functions applied 
problem functions update values variables generating super extension 
possibility shown 
void int test label label apply theorem proving decide test 
luck 
specialize branches store positive context propagation cmixpendinsert record specialization store negative context propagation cmixpendinsert record return new label active store copied positive context propagation performed negative context propagation 
expensive solution 
works small examples 
situation slightly better positive context propagation performed 
case copy active store branch inserted pending list positive context propagation performed specialization proceed immediately branch 
example final remarks 
approach outlined section relies assumption int values copied specialization points static variables 
representation described represent information greater 
obviously definition int extended support lists constraints price extra memory usage complicate mechanism copying int values 
driving 
shown simple form positive negative context propagation generating extensions 
driving 
methods relate benefits generating extensions direct execution direct representation static values 
techniques sufficient hand coding generating super extension naive string matcher clear transformation automated 
obviously needed handle realistic examples 
theorem proving part section currently mix limited form 
example algebraic reductions operator function results specialization useless 
time writing experimented positive context propagation contrived examples 
generalization straightforward 
argued known values executed directly interpreted 
section side stepped problem language supporting overloading operators 
code similar functions writing symbolic evaluator 
main point binding time analysis classification parallel online driving 
static values represented directly interpretation overhead evaluation 
related various tricks improvement partial evaluation known users partial evaluators jones chapter 
automated program specialization extend 
example similix systems incorporate cps transformation gives better exploitation static values bondorf 
section inspired gl ck supercompilation gl ck 
coen uses theorem proving improve specialization coen 
approaches symbolic evaluation subject programs 
employ theorem proving symbolic validation strong reservation recall assume size known case original example 
pascal programs kemmerer eckmann 
ghezzi uses symbolic evaluation value constraints simplify programs ghezzi 
gl ck rgensen experimented automatic generation stronger specializers information carrying interpreters gl ck rgensen 
interesting results created method suffers need self interpreter subject language 
considered driving illustrated possible structure generating 
generating super extension differs notably driving symbolic evaluation binding time analysis classify static definitely known values 
generating super extensions undertaken remains extend technique larger part believe driving limited base type values avoid problems representations termination memory usage 
experiments needed evaluate benefit driving compared ordinary partial evaluation 
initiated development generating super extension programming language extension partial evaluation 
means case study showed generation kmp string matcher naive matcher result partial evaluation produce outlined approach automates generation 
plan incorporate positive context propagation mix system 
chapter developed partial evaluator mix programming language 
chapter studied program specialization language described generating extension transformation 
chapters developed analyses pointer analysis approximates set objects pointer may point runtime 
binding time analysis computes binding times expressions 
side effect analysis analysis approximates side effects set objects function respectively 
separate incremental binding time analysis support modular languages 
speedup analysis estimates prospective speedups 
provided experimental results discussed interaction partial evaluation program optimization chapter 
considered stronger transformation technique driving chapter 
list contributions thesis contains chapter 
thesis developed documented partial evaluation system ansi programming language 
chapter listed number specific topics 
section provide general directions 
program specialization transformation generating extension transformation developed overcome problems previous version mix traditional specialization symbolic evaluation 
successfully proved usefulness practice 
room improvement 
outline prevailing urgent problems 
long term goal rewriting subject programs necessary obtain results 
ways binding time improvements studied implemented 
particular separation data structures important 
specialization imperative languages problematic due memory usage 
problem tightly coupled notion non oblivious algorithms 
dynamic tests may cause extreme memory usage 
way improve needed 
termination problem hinders practical usage partial evaluation 
trivial rewrite program prevent infinite specialization automated 
methods studied functional languages insufficient imperative languages 
fruitful way proceed may general constant propagation guarantee variable bound finite number static values 
pointer analysis pointer analysis important analysis language 
analyses depend precision efficiency amount gathered information 
analysis developed theoretically coarse fine practice 
experiments accuracy performed improved precision pay price terms efficiency 
obvious step extend analysis flow sensitive analysis avoid spurious propagation unrelated point information 
furthermore analysis exhaustive sense computes information variants functions 
clearly may time consuming way limit static call graph relevant variants investigated 
binding time analysis binding time analysis turned successful practice 
extremely fast accuracy acceptable 
integration binding time directed transformations aiming improving effect specialization undertaken 
data flow analysis developed classical analyses programming language exploring point information 
efficiency analyses improved precision 
analysis coupled analysis improve memory usage generating extensions 
separate analysis separate binding time analysis time writing implemented mix system expected major improvement 
separate pointer analysis needed obtain truly separate analysis 
extension polyvariant analysis considered 
possibility build inter modular call graph 
speedup analysis speedup analysis coarse gives minor informative answer arbitrary high speedup obtained 
lower bound estimate actual speedup tighter approximation useful 
result analysis applied suspend specialization program fragments contributes little speedup 
residual code size analysis un exploited area 
experiments current implementation mix system improved number ways 
long term projects incorporate better separation binding times 
transformation simpler language advantageous experiments clearly demonstrated usefulness informative feedback unwilling give high level representation reasonable compromise 
study interaction partial evaluation classical optimization continued 
application optimizations partial evaluation new approach 
driving investigation driving generating super extensions begun 
needed automate generalize principles 
currently theorem proving turned useful reasonable incorporate generating extensions 
experiments needed assess benefit positive context propagation 
final remarks knowledge mix partial evaluator handling full scale pragmatically oriented language 
techniques developed mature realistic experiments professional software engineering 
believe experiments reveal areas 
applications mix experiments promising results demonstrated basic principles 
hope results thesis may useful software engineering 
bibliography aho aho ullman design analysis computer algorithm addison wesley 
aho aho sethi ullman compilers principles techniques tools addison wesley 
allen cocke allen cocke program data flow analysis procedure communications acm vol march 
control flow normalization algorithm complexity ieee transactions software engineering vol march 
andersen andersen program specialization master thesis diku university copenhagen denmark december 
diku student project pages 
andersen andersen program specialization technical report diku university copenhagen denmark may 
revised version 
andersen andersen binding time analysis taming pointers proc 
acm symposium partial evaluation semantics program manipulation pepm pages acm sigplan june 
andersen andersen partial evaluation chapter partial evaluation automatic compiler generation jones gomard sestoft pages hoare series prentice hall 
andersen andersen partial evaluation applied ray tracing august 
student report 
andersen gomard andersen gomard speed analysis partial evaluation preliminary results workshop partial evaluation semantics program manipulation pepm pages june 
yaleu dcs rr yale university 
andersen mossin andersen mossin binding time analysis type inference october 
diku student project pages 
diku university copenhagen 
baier baier gl ck partial evaluation numeric programs fortran proc 
acm sigplan workshop partial evaluation semantics program manipulation 
appear 
baker baker algorithm structuring flowgraphs journal acm vol january 
ball ball predicting effects optimization procedure body conf 
record sixth annual acm symposium principles programming languages pages acm january 
banning banning efficient way find side effects procedure calls aliases variables conf 
record sixth annual acm symposium principles programming languages pages acm january 
barzdin barzdin mixed computation compiler basis partial evaluation mixed computation edited bj rner ershov jones pages north holland 
beckman beckman partial evaluator programming tool artificial intelligence 
bentley bentley programming pearls code tuning communications acm vol february 
berlin weise berlin weise compiling scientific code partial evaluation ieee computer december 
birkedal birkedal partial evaluation standard ml master thesis diku university copenhagen august 
partial evaluation understanding fortran programs proc 
software engineering knowledge engineering pages 
bondorf bondorf self applicable partial evaluation phd thesis diku university copenhagen 
bondorf bondorf improving binding times explicit cps conversion acm conference lisp functional languages 
san francisco california pages june 
bondorf bondorf handwriting cogen cps partial evaluator proc 
acm sigplan workshop partial evaluation semantics program manipulation 
bondorf rgensen bondorf rgensen efficient analyses realistic line partial evaluation journal functional programming july 
bourdoncle bourdoncle interprocedural interpretation block structured languages nested procedures aliasing plilp pages springer verlag 
ershov ershov ad hoc compiler constructs appear universal mixed computation processes partial evaluation mixed computation edited bj rner ershov jones pages north holland 
burke burke interprocedural optimization eliminating unnecessary recompilation acm transaction programming languages systems july 
burstall darlington burstall darlington transformation system developing recursive programs journal association computing machinery january 
cai paige cai paige increased productivity algorithm implementation proc 
acm sigsoft symposium foundation software engineering edited notkin pages acm december 
callahan callahan cooper kennedy torczon interprocedural constant propagation proc 
sigplan symposium compiler construction acm sigplan notices vol pages acm june 
callahan callahan carle hall kennedy constructing procedure call multigraph ieee transactions software engineering vol april 
chase chase wegman zadeck analysis pointers structures proc 
acm sigplan conference programming language design implementation pages acm june 
choi choi burke carini efficient flow sensitive interprocedural computation pointer induced aliases side effects conf 
record th 
annual acm symposium principles programming languages pages acm january 
chow chow design data flow analyzer proc 
sigplan symposium construction pages acm january 
coen coen de paoli ghezzi mandrioli software specialization symbolic execution ieee transactions software engineering september 
technical rationale american national standard information systems programming language available anonymous ftp 
consel consel polyvariant binding time analysis applicative languages proc 
acm sigplan symposium partial evaluation semantics program manipulation pepm pages acm sigplan june 
consel consel tour partial evaluation system higher order applicative languages proceedings acm sigplan symposium partial evaluation semantics program pages acm june 
consel danvy consel danvy tutorial notes partial evaluation proc 
symposium principles programming languages pages acm january 
consel jouvelot consel jouvelot separate polyvariant binding time analysis 
manuscript 
cooper kennedy cooper kennedy interprocedural side effect analysis linear time proc 
conference programming language design implementation pages acm june 
cooper kennedy cooper kennedy fast interprocedural alias analysis conf 
record sixteenth annual acm symposium principles programming languages pages acm january 
cooper cooper kennedy torczon impact interprocedural analysis optimization programming environment acm transactions programming languages systems october 
cooper cooper kennedy torczon editing compiling programs proc 
acm sig soft sigplan software engineering symposium practical software development environment edited henderson pages acm january 
cooper cooper hall kennedy methodology procedure cloning computer languages vol april 
cousot cousot cousot cousot interpretation unified lattice model static analysis programs construction approximation fixpoints proc 
th annual acm symposium principles programming languages pages acm january 
cytron cytron efficient accommodation may alias information ssa form proc 
acm sigplan conference programming language design implementation pages acm june 
davidson holler davidson holler study function inliner software practice experience vol august 
davidson holler davidson holler subprogram inlining study effects program execution time ieee transactions software engineering vol february 
de de de partial evaluation polymorphically typed functional languages representation problem analyse en programmation logique bordeaux france 
vol 
edited pages irisa rennes france 
smart pointers re smart re pointers proc 
usenix association technical conference 
emami emami practical interprocedural alias analysis optimizing parallelizing compiler master thesis mcgill university montreal september 
draft 
emami emami ghiya hendren context sensitive interprocedural points analysis presence function pointers technical report acaps technical memo mcgill university school computer science university st montreal canada november 
ershov ershov partial computation principle information processing letters april 
ferrante ferrante ottenstein warren program dependence graph optimization acm transactions programming languages systems july 
freeman freeman maloney borning incremental constraint solver communications acm january 
futamura futamura partial evaluation computation process approach compiler compiler systems computers controls 
ghezzi ghezzi mandrioli program symbolic interpretation lecture notes computer science pages springer verlag 
ghiya ghiya interprocedural analysis presence function pointers technical report acaps memo mcgill university school computer science university st montreal canada december 
gill gill launchbury peyton jones short cut deforestation proceeding conference functional programming languages computer architecture pages acm june 
gl ck rgensen gl ck rgensen generating optimizing specializers ieee computer society international conference computer languages ieee computer society press may 
appear 
gl ck gl ck occam razor metacomputation notion perfect process tree proc 
rd int 
workshop static analysis lecture notes computer science edited fil cousot falaschi pages springer verlag 
gomard gomard partial type inference untyped functional programs acm conference lisp functional programming nice france pages acm 
gomard jones gomard jones compiler generation partial evaluation case study structured programming 
gomard jones gomard jones partial evaluator untyped lambda calculus journal functional programming january 
graham wegman graham wegman fast usually linear algorithm global data flow analysis journal association computing machinery vol january 
gross steenkiste gross steenkiste structured dataflow analysis arrays optimizing compiler software practice experience vol february 
gurevich gurevich semantics programming language csl computer science logic pages springer verlag 
errata csl 
hall hall managing interprocedural optimization phd thesis rice university april 
hansen hansen properties unfolding meta level systems proc 
acm sigplan symposium partial evaluation semantics program manipulation sigplan notices vol 
pages acm 
linear time algorithm finding dominators flow graphs related problems proc 
seventeenth annual acm symposium theory computing pages acm may 
harrison harrison compiler analysis value range variables ieee transactions software engineering vol may 
harrison iii harrison iii program eye view proc 
th international workshop languages compilers parallel lecture notes computer science edited nicolau banerjee gelernter padua pages springer verlag august 
hecht ullman hecht ullman simple algorithm global data flow analysis problems siam journal computing vol december 
heintze heintze set program analysis phd thesis school computer science carnegie mellon university pittsburgh pa october 
available technical report cmu cs 
hendren hummel hendren hummel abstractions recursive pointer data structures improving analysis imperative programs acm sigplan conference programming language design implementation pages acm june 
hendren hendren emami gao sridharan designing mccat compiler family structured intermediate representations technical report acaps memo mcgill university school computer science university st montreal canada june 
hendren hendren emami ghiya practical context sensitive interprocedural analysis framework compilers technical report acaps memo mcgill university school computer science university st montreal canada july 
henglein henglein efficient type inference higher order binding time analysis functional programming languages computer architecture cambridge massachusetts august 
lecture notes computer science vol 
edited hughes pages acm springer verlag 
henglein mossin henglein mossin polymorphic binding time analysis proc 
th 
european symposium programming lectures notes computer science vol edited sannella pages springer verlag april 
hennessy hennessy semantics programming languages elementary structural operational semantics john wiley sons 
holst holst finiteness analysis functional programming languages computer architecture cambridge massachusetts august 
lecture notes computer science vol 
edited hughes pages acm springer verlag 
holst launchbury holst launchbury handwriting cogen avoid problems static typing draft proceedings fourth annual glasgow workshop functional programming scotland pages glasgow university 
hood hood kennedy ller efficient recompilation module interfaces software development environment proc 
sig plan symposium compiler construction acm sigplan notices vol pages acm june 
horwitz horwitz demers teitelbaum efficient general iterative algorithm dataflow analysis acta informatica 
hughes hughes backward analysis functional programs partial evaluation mixed computation edited bj rner ershov jones pages north holland 
hwu chang hwu chang inline function expansion compiling programs proc 
sigplan conference programming language design implementation pages june 
iso programming languages iso iec international standard 
jones jones automatic program specialization re examination basic principles partial evaluation mixed computation edited bj rner ershov jones pages north holland 
jones jones computer implementation application kleene sm recursion theorems logic computer science edited moschovakis pages springer verlag 
jones jones partial evaluation self application types automata languages programming 
th international colloquium warwick england 
lecture notes computer science vol 
edited paterson pages springer verlag 
jones jones constant time factors matter stoc 
symposium theory computing edited steven homer pages acm press 
jones jones essence partial evaluation driving logic language computation lecture notes computer science edited jones sato pages springer verlag april 
jones nielson jones nielson interpretation semantics tool program analysis handbook logic computer science oxford university press 
pages 
appear 
jones jones sestoft mix self applicable partial evaluator experiments compiler generation lisp symbolic computation 
jones jones gomard sestoft partial evaluation automatic program generation hoare series prentice hall 
isbn 
kam ullman kam ullman global data flow analysis iterative algorithms journal association computing machinery vol january 
kam ullman kam ullman monotone data flow analysis frameworks acta informatica 
kemmerer eckmann kemmerer eckmann symbolic executor pascal software practice experience vol may 
kennedy kennedy node listing applied data flow analysis conference record nd acm symposium principles programming languages pages acm january 
kennedy kennedy comparison algorithms global data flow analysis siam journal computability vol march 
kernighan ritchie kernighan ritchie programming language draft proposed ansi software series prentice hall second edition edition 
kildall kildall unified approach global program optimization conference record acm symposium principles programming languages pages acm january 
klarlund schwartzbach klarlund schwartzbach graph types conf 
record th 
annual acm principles programming languages pages acm january 
knuth knuth morris pratt fast pattern matching strings siam journal computation vol june 
lakhotia lakhotia constructing call multigraphs dependence graphs conf 
record th 
annual acm symposium principles programming languages pages acm january 
landi landi interprocedural aliasing presence pointers phd thesis rutgers state university new jersey january 
landi landi undecidability static analysis acm letters programming languages systems december 
landi ryder landi ryder pointer induced aliasing problem classification annual acm principles programming languages pages acm january 
landi ryder landi ryder safe algorithm interprocedural pointer aliasing acm sigplan conference programming language design implementation pages acm june 
larus hilfinger larus hilfinger detecting conflicts structure proc 
sigplan conference programming language design implementation pages acm sigplan june 
launchbury launchbury projection partial evaluation phd thesis dep 
computing science university glasgow glasgow qq 
launchbury launchbury strongly typed self applicable partial evaluator functional programming languages computer architecture cambridge massachusetts august 
lecture notes computer science vol 
edited hughes pages acm springer verlag 
lengauer tarjan lengauer tarjan fast algorithm finding dominators flowgraph acm transactions programming languages systems vol july 
leone lee leone lee deferred compilation automation run time code generation technical report cmu cs school computer science carnegie mellon university pittsburgh pa december 
predicting properties residual programs proc 
acm sigplan workshop partial evaluation semantics program manipulation pages yale university department computer science june 
available technical report yaleu dcs rr 
efficient partial evaluation proc 
acm sigplan symposium partial evaluation semantics program manipulation pages acm june 
marlowe ryder marlowe ryder efficient hybrid algorithm incremental data flow analysis conf 
record seventeenth acm symposium principles programming languages pages acm january 
marlowe ryder marlowe ryder properties data flow frameworks acta informatica 
mayer wolfe mayer wolfe interprocedural alias analysis implementation results software practise experience 
meyer meyer techniques partial evaluation imperative languages proc 
acm sigplan symposium partial evaluation semantics program manipulation new haven connecticut 
sigplan notices vol 
september pages acm 
meyer meyer auswertung imperative sprachen phd thesis universit august 
german 
mogensen 
mogensen binding time aspects partial evaluation phd thesis dept comp 
science university copenhagen mar 
static analysis aliases side effects higher order languages phd thesis computer science cornell university ithaca ny feb 
nielson nielson nielson nielson automatic binding time analysis typed calculus science computer programming 
nielson nielson nielson nielson level functional languages cambridge computer science text 
nielson nielson nielson nielson semantics applications john wiley sons 
isbn 
pugh pugh partial evaluation high level imperative programming languages applications hard real time systems conf 
record nineteenth acm symposium principles programming languages albuquerque new mexico january pages acm 
olsson whitehead olsson whitehead simple technique automatic recompilation modular programming languages software practise experience 
partial computation construction language processors prentice hall 
plotkin plotkin structural approach operational semantics technical report daimi fn computer science department aarhus university denmark ny munkegade dk aarhus denmark 
technical report 
pohl pohl language computer languages vol 
pollock soffa pollock soffa incremental version iterative data flow analysis ieee transactions software engineering december 
press press flannery teukolsky vetterling numerical recipes cambridge university press st edition 
ramalingam reps ramalingam reps incremental algorithm maintaining dominator tree reducible flowgraph conf 
record st annual acm sigact sigplan symposium principles programming languages pages acm january 
richardson ganapathi richardson ganapathi interprocedural optimization experimental results software practise experience february 
ross ross integral practical environment programming proc 
acm sigsoft sigplan software engineering symposium practical software development environments edited henderson pages acm january 
ruf weise ruf weise types avoid redundant specialization proc 
acm symposium partial evaluation semantics program manipulation pepm pages acm june 
murtagh murtagh lifetime analysis dynamically allocated objects proc 
fifteenth annual acm sigact sigplan symposium principles programming languages pages acm january 
ryder ryder constructing call graph program ieee transactions software engineering vol se may 
ryder ryder elimination algorithms data flow analysis acm computing surveys vol september 
ryder ryder marlowe conditions incremental iteration examples counterexamples science computer programming 
polyvariant binding time analysis proc 
acm sigplan workshop partial evaluation semantics program manipulation pages yale university department computer science june 
available technical report yaleu dcs rr 
sagiv francez sagiv francez logic approach data flow analysis problems programming language implementation logic programming international workshop plilp edited ski pages springer verlag august 
annotated ansi standard osborne 
isbn 
sestoft sestoft automatic call unfolding partial evaluator partial evaluation mixed computation edited bj rner ershov jones pages north holland 
sharir pnueli sharir pnueli approaches interprocedural data flow analysis chapter pages englewood cliffs nj 
stallman stallman porting gnu cc free software foundation mass ave cambridge edition january 
tarjan tarjan data structures network algorithms society industrial applied mathematics 
turchin turchin supercompiler system langauge sig plan notices february 
turchin turchin concept supercompiler acm toplas july 
wadler wadler deforestation transforming programs eliminate trees european symposium programming pages springer verlag march 
waite waite cost lexical analysis software practice experience vol may 
weihl weihl interprocedural data flow analysis presence pointers variables label variables conf 
record seventh annual acm symposium principles programming languages pages acm january 
soffa soffa approach ordering optimizing transformations second acm sigplan symposium ppopp sig plan notices vol pages acm march 
yi yi automatic generation management program analyses phd thesis center development university illinois champaign 
yi harrison yi harrison interprocedural data flow analysis compile time memory management technical report center supercomputing research development university illinois urbana champaign august 
zadeck zadeck incremental data flow analysis structured editor proc 
acm sigplan symposium compiler construction pages acm june 
zima chapman zima chapman supercompilers vector parallel computers frontier series acm press 
er 
den ene side og programmer der er og 
er 
som er program til en program 
af programmer er og programmer af 
er til se 
er en program som med 
pr og en evaluator sig med og transformation og 
vi en generating extension transformation 
form med er af programmer 
vi en pointer analyse 
form med pointer analyse er programmers af 
pointer analyse er analyse og transformation af som vi en 
form med er om af kan ske overs rst 
vi til vi information af pointer 
vi separate analyse og af programmer 
programmer er stiller til 
vi en der den ved og vi en vre gr nse den 
vi driving er en st 
vi aet ved af en implementation af 

