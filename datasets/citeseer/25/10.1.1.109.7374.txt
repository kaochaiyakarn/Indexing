originally published proceedings rd symposium operating systems design implementation new orleans louisiana february fine grained dynamic instrumentation commodity operating system kernels ariel barton miller university wisconsin madison information usenix association contact 
phone 
fax 
email office usenix org 
www url www usenix org fine grained dynamic instrumentation commodity operating system kernels developed technology fine grained dynamic instrumentation commodity kernels splice insert dynamically generated code machine code instruction completely unmodified running commodity operating system kernel 
technology suited performance profiling debugging code coverage security auditing runtime code optimizations kernel extensions 
designed implemented tool called kerninst performs dynamic instrumentation stock production solaris kernel running ultrasparc 
top kerninst implemented kernel performance profiling tool understand kernel application performance web proxy server workload 
information changes kernel proxy cumulatively reduce percentage elapsed time proxy spends opening disk cache files 
operating system kernels complex entities internals difficult understand measure optimize 
extensible kernels spin exokernel vino designed allow applications extend functionality specify kernel policies :10.1.1.100.6047
allows specialized versions certain kernel functions installed runtime providing dynamic optimization 
design proposed self measuring self adapting extensible kernel :10.1.1.15.6112
performed customized kernels difficult evaluate real world programs workloads 
introduces finegrained dynamic kernel instrumentation low level technology allows arbitrary code spliced inserted kernel machine code location runtime 
dynamic kernel instrumentation allows runtime measurements optimizations extensions ariel barton miller computer sciences department university wisconsin madison wi bart cs wisc edu performed unmodified commodity kernels 
provide motivation fine grained dynamic kernel instrumentation describe dynamically instrument unmodified commodity kernel 
show kernel profiler dynamic instrumentation provides way benefit insight kernel application performance 
show information optimize web proxy server 
discuss safety security issues introduced finegrained dynamic kernel instrumentation 
dynamic instrumentation supports monitoring functionality debugging profiling alongside mechanisms extensibility adaptability single infrastructure 
kernels evolving entities able measure adapt accommodate real world runtime usage patterns 
main contribution design implementation fine grained splicing mechanism stock commodity kernel 
contents inserted code performance profiling annotations optimized versions functions process specific kernel extensions orthogonal issue splice commodity kernel 
implemented kerninst instrumentation tool solaris kernel 
main features fully dynamic 
kerninst loaded instruments running kernel need recompile reboot pause kernel 
fine grained 
instrumentation points locations code spliced machine code instruction kernel 
contrasts kernels allow coarser grained code changes function granularity vino allow entire kernel modules changed commodity kernels allow 
runs commodity kernel 
allows immediately run real world programs 
runs unmodified kernel 
ultrasparc system running solaris immediately kerninst 

supported part department energy de fg er nsf eia cda darpa contract 
government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon 
applications dynamic kernel instrumentation section describes applications finegrained dynamic instrumentation unmodified commodity kernels 
performance profilers dynamic instrumentation insert performance gathering code annotations incrementing counter start function basic block 
annotation code start timers access hardware performance counters 
complex code sequences control structures predicate measurements kernel state currently running process 
detail dynamic kernel instrumentation performance profiling section 
dynamic instrumentation kernel tracing splicing logging code desired kernel code locations runtime 
desired trace collected kernel code restored original contents overhead incurred tracing desired 
contrasts static kernel instrumentation system binary rewriter insert code lasting entire run kernel 
code coverage measured splicing code sets flag basic block indicating code reached 
instrumentation basic block removed soon flag set overhead code coverage decreases time 
basic block coverage demonstrates need instrumentation fine grained 
kernel debuggers implemented finegrained dynamic instrumentation 
breakpoints inserted machine code instruction splicing code displays kernel state optionally pauses executing thread informs debugger 
conditional breakpoints easily accommodated breakpoint appropriate condition 
security auditing annotations installed dynamic instrumentation 
solaris audit thread creation deletion file system pathname lookups file system vnode creation successful unsuccessful credential checks super user access process forks core dumps stream device operations file opens closes 
auditing code turned default turning requires kernel recompile reboot 
dynamic instrumentation auditing package distributed independent kernel add installed running system 
requires fine grained splicing mechanism auditing checks take place middle kernel functions 
dynamic instrumentation enables automated runtime code optimization performance feedback gathered dynamic profiling annotations 
example function specialization input parameter 
function dynamically instrumented collect histogram desired parameter examined frequent value 
annotation code removed specialized version function machine code generated constant propagation applied specialized parameter 
function code spliced entry input parameter equals common value jump optimized version fall original version 
optimization bypass check sites function called examined actual parameter equals specialized value 
call site altered directly call optimized version function 
moving seldom executed basic blocks line improve instruction cache behavior performed fine grained dynamic instrumentation 
function entry exit point annotated measure number icache misses incurs 
value high function basic blocks instrumented count execution frequency 
optimized version function infrequently executed blocks moved line installed splicing code entry original function unconditionally jump optimized version 
parameter specialization extra jump overhead eliminated altering sites function called 
dynamic kernel instrumentation may change kernel functionality installing process specific version kernel policy 
extensible operating systems download process specific code kernel improved performance perform kind adaptation :10.1.1.100.6047:10.1.1.100.6047:10.1.1.100.6047:10.1.1.142.6054:10.1.1.142.6054
dynamic instrumentation easily provide similar operation commodity kernel splicing code desired kernel function currently executing process id equals customized pid jump customized version patch area fall 
applications dynamic kernel instrumentation varying requirements kernel source code 
kern inst provides kernel runtime symbol table function names starting locations memory control flow graph basic blocks machine code level 
information applications readily identify machine code locations function entries exits function calls 
benefit working machine code effect compiler optimizations reorder remove code visible 
certain applications require information kernel 
kernel developer dynamic kernel instrumentation trace specific source code line needs compiler debugging line number information map line numbers kernel addresses 
fortunately kernel developers access information 
applications may require knowing names specific kernel functions 
application wanting profile file system pathname vnode translation solaris needs know relevant function 
users application need know 
applications solely information kerninst provides example optimizer moves seldom executed basic blocks line run time works machine code level 
mechanisms dynamic kernel instrumentation process splicing dynamically generated code sequences specified points kernel code space 
splicing overwrites machine code instruction instrumentation point jump patch code 
kerninst fine grained instrumentation points machine code instruction kernel discuss exceptions section section 
code patch contains dynamically generated code inserted overwritten instruction jump back instruction instrumentation point 
net effect splicing insert dynamically generated code kernel machine code instruction 
important feature dynamic instrumentation splicing independent code generation 
kerninst splice machine code created code generation packages vcode interpreter performing just time compilation precompiled position independent code :10.1.1.25.8634
structure kerninst system shown ioctl application dynamic kernel instrumentation kernel profiler tracer optimizer dev kerninst instrumentation request kerninstd patch area heap timers counters heap kernel address space kerninst system architecture kerninstd acts instrumentation server performing kernel instrumentation requests arrive applications 

applications wish instrument kernel interact kerninstd user level daemon 
small runtime loaded kerninst driver dev kerninst run time allocated patch area heap heap timers counters instrumentation code contains performance gathering annotations 
kerninstd maps heaps address space mmap dev kmem 
minimize tool presence kernel functionality kerninstd 
needs perform actions kernel address space kerninstd assistance dev kerninst 
section discusses kerninst performs finegrained dynamic instrumentation commodity operating system kernel 
specific examples current solaris implementation believe dynamic kernel instrumentation possible modern operating systems 
bootstrapping kerninst kernel instrument running kernel kerninstd needs allocate patch area heap parse kernel runtime symbol table obtain permission write portion kernel address space 
code patches hold dynamically generated code inserted allocated patch area heap kernel address space 
kerninstd allocate kernel memory dev kerninst perform necessary kmem alloc ioctl 
instrument kerninstd needs know functions reside memory 
needs access kernel runtime symbol table 
symbol table disk kernel unix insufficient incomplete kernel contained runtime loaded modules 
dev kerninst reads kernel runtime symbol table directly kernel memory behalf kerninstd 
solaris provides similar interface driver dev label functions associated kernel module 
emitting code patch area splicing require write permission kernel address space 
kerninstd writes patch area heap directly mapped address space mmap dev kmem 
splicing existing kernel code difficult solaris operating systems allow certain parts kernel code modified kernel 
specifically solaris kernel modules collectively termed kernel nucleus written ultrasparc platforms mapped tlb read permission 
write code nucleus dev kerninst maps appropriate page 
solaris kernel modules unix architecture specific part kernel kernel runtime linker architecture independent part kernel 
performs write 
structural analysis dynamic code generators perform machine code transformations compiler runtime 
benefit greatly information compilers linkers unfortunately discard part symbol tables control flow graphs live register analysis 
kerninstd constructs similar information analyzing kernel core machine code creating interprocedural control flow graph basic blocks finding live registers basic block 
kerninstd builds control flow graph kernel machine code partitioning functions basic blocks 
graph needed performing live register analysis dynamic code generation splicing 
source code debugging information process 
runtime symbol table parsed determine memory start kernel functions 
function machine code read memory parsed basic blocks 
basic block ends instruction potentially interrupts program control flow function call encountered 
jump tables jumps constant addresses determined backwards slice register jump 
register relative jumps marked 
kerninst controlflow graph construction similar done binary user programs eel atom 
kerninst performs processing runtime code available including runtime loaded modules 
furthermore controlflow graph interprocedural aggressive data flow analyses possible 
kerninstd performs interprocedural live register analysis kernel code 
basic block set live registers entry calculated stored code generation splicing 
conserve storage kerninstd store live registers kernel machine code instruction fine grained analysis performed instrumentation needed 
summarizes code components solaris running ultrasparc 
kerninst performs time structural analysis efficiently shown 
structural analysis optimized making results persistent need recalculated kernel module loaded unloaded 
start processing time seconds pursued optimization 
kernel component number modules functions basic blocks instruction bytes mb solaris kernel overview structural analysis step time get kernel runtime symbol table dev kerninst sec parse functions basic blocks create cfg sec perform live register analysis basic block sec total sec structural analysis time start costs code generation issues code generation splicing phases dynamic instrumentation decoupled kerninstd splice code generated runtime code generator coordinate kerninstd overwrite registers kerninstd says free instrumentation point emit machine code directly memory location specified kerninstd 
vcode code generator fits model interpreters runtime compilers :10.1.1.25.8634
statically generated code instrumentation runtime kerninstd resolves procedure calls brackets code register spills ensure free registers overwritten 
compiler kerninst concerned inserting splicing generated code midst existing kernel code 
safety dynamically generated code write registers free contain live information instrumentation point 
registers required free kerninstd brackets code stack frame set tear free additional registers 
sparc involves emitting save restore instructions 
instructions safely executed trap handlers register window overflow underflow kerninstd instrument routines lists kerninstd dynamic instrumentation steps 
section describes live register analysis allocating patch hold generated code code generation 
step live register analysis determines registers available scratch instrumentation point 
finding live registers classic backwards data flow problem operating control flow graph 
set live registers top basic 
instrument routines explicitly saving live registers stack making sparc register window save restore instructions 
plan add feature version kerninstd 
instrumentation step cost described 
finding free registers instrumentation point time retrieve live registers bottom basic block calculated startup code spliced calculate live registers instrumentation point machine code instruction 
cost machine code instruction instrumentation point basic block 
cost assumes instructions 
return result instrumentation point results cached section 
calculate size patch allocate 
generate emit code patch add counter example 
emit relocated instruction necessary jump instruction instrumentation point 
creating installing splice patch assuming springboard required 
section patch area mapped kerninstd quick writing 
allocate springboard tation request generate springboard code write springboard contents kernel springboard nucleus section write springboard contents kernel springboard nucleus overwrite instruction instrumentation point nucleus overwrite instruction instrumentation point nucleus section total worst case instrumentation point springboard nucleus total instrumentation point springboard nucleus total best case springboard needed instrumentation point nucleus dynamic kernel instrumentation main steps 
timing measurements taken mhz ultrasparc running solaris 
block calculated stored kerninstd structural analysis start phase finding live registers instruction basic block done quickly 
free registers point live 
live register analysis averages current implementation 
second step code generation allocates patch space hold dynamically generated code 
patch size sum size machine code inserted extra instructions spill registers stack scratch registers needed available space original instruction instrumentation point space jump back instruction instrumentation point 
pieces instrumentation inserted instrumentation point kerninstd simply compounds code patch 
rule code patch spliced instrumentation point 
usually possible code sequences varying number instructions returning jump depending required displacement 
number instruction bytes required code patch determined allocated 
circular dependency broken assuming maximum number instructions needed perform jump instructions sparc assuming bit addresses 
space code patch allocated patch heap 
calculating patch size allocating typically takes patch space allocated dynamically generated code emitted 
step take place patch allocation machine code representation pc relative instructions sparc call instruction depend instruction addresses 
entire patch area heap mapped kerninstd space writing generated code written directly patch 
simple annotation incrementing bit integer counter code generation takes cost due kernel policy deferring page mapping time written 
explicit kernel calls write mapped kernel memory kernel performing noticeable write 
subsequent warm writes require mapping complete just patches typically written times normally fall slower cold value 
code splicing fast fine grained code splicing kerninst major technology contribution 
splicing action inserting runtime generated code desired kernel code location instrumentation point 
kerninst splicing fine grained instrumentation points kernel machine code instruction 
kerninstd splices overwriting instrumentation point instruction branch patch code 
code patch contains dynamically generated code original overwritten instruction jump back instruction stream instrumentation point 
illustrates basic design 
kernel code instrumentation code patch point dynamically generated code inserted branch overwritten instruction equivalent sequence branch back insn instrumentation point code splicing machine code instruction overwritten branch patch code contains desired instrumentation code overwritten instruction branch back instruction stream 
ideally runtime code finegrained able splice code machine code instruction splice quickly need pause synchronize executing threads splice need customized code instrumentation point unmodified kernels multi threaded kernels allow splicing safely occur time threads potentially executing near instrumentation point splicing 
kerninstd fulfills goals 
splicing multi threaded kernel pausing requires replacing machine code instruction instrumentation point branch code patch 
section discusses safety motivation single instruction splicing 
displacement issue single instruction splicing branch instructions insufficient range reach code patch instrumentation point 
section discusses solution problem 
discuss contents code patch 
code patch contents dynamically generated code inserted code patch ends original instrumentation point instruction jump back instruction instrumentation point 
original instruction instrumentation point overwritten needs relocated code patch 
relocated instruction placed generated code instrumentation code effectively inserted machine code instruction 
note instructions semantics pc dependent branches relocated verbatim code patch 
cases kerninstd emits sequence instructions combined semantics equivalent original instruction 
patch code ends jump back instruction instrumentation point 
tion point instruction unconditional branch jump step skipped 
single branch instruction sufficient range scratch register written destination address jump 
jump executes relocated instruction available scratch register set registers free instrumentation point 
contrasts instrumentation code executes context free registers instrumentation point 
integer registers available kerninstd available spilling stack kerninstd generates relocated instrumentation point instruction returning jump splicing control transfer instructions having delay slot requires extra step 
control transfer instruction successor delay slot instruction copied code patch 
ensures delay slot instruction executed proper semantics control transfer instruction changed pc 
example shown 
code splicing tcp err ack 
call mov 
code splicing tcp err ack 
ba patch addr mov 
code patch dynamically generated code omitted call relocated overwritten instruction mov relocated delay slot instruction jump return instruc 
delay slot splicing delayed control transfer instructions 
overwritten instruction call delay slot instruction mov relocated patch 
delay slot instruction left longer executed 
note code patch completes returns instruction delay slot ensure executed twice 
control transfer instruction unconditional need emit jump back instruction stream executed 
splicing delay slot control transfer instruction difficult branch code patch occur control transfer instruction 
cheaper alternative spilling integer register store available floating point register 
unfortunately sparc architecture instructions raw non converting integer floating point register move 
changed pc 
code patch completes jump instruction delay slot effects control transfer instruction need executed 
unfortunately valid return locations control transfer instruction conditional branch taken fall 
solution effectively relocate control transfer instruction code patch 
instruction falls code patch returns instruction delay slot usual 
approach works instrumentation point instruction executed delay slot preceding control transfer instruction 
rare occasions solaris kernel delay slot instruction target branch executed delay slot preceding control transfer instruction 
kerninstd instrument cases code patch choose different instruction sequences returning 
case detected noticing delay slot instruction start basic block 
overwriting single instruction instrumentation point safety kerninstd splices overwriting single instruction instrumentation point branch code patch 
code patch written kernel memory instruction instrumentation point overwritten branch 
take time new instruction way instruction cache fetched icache threads continue safely execute original code sequence 
pre instrumentation post instrumentation code sequence executed mix single instruction splicing hazard free 
fine grained splicing replacing single instruction inherently unsafe unmodified commodity kernel thread execute mix pre slice post splice sequences 
shows instructions kernel routine kmem alloc 
pc kernel thread located third instruction instruction splice replaces second third instructions 
instrumentation point second instruction kmem alloc instructions splice third instruction function replaced 
thread executed sub instruction successor sra splice occurs unsafe sequence instructions executed shown 
note problem occurs architecture write instructions atomically 
theory hazard avoided pausing performing backtrace kernel threads check execution currently code splicing kmem alloc save sp sp sub sra pc code splicing kmem alloc save sp sp call code patch pc nop dual instruction splicing executed sequence save sp sp sub nop inconsistent instruction sequence multiple instruction splicing hazardous return instructions replaced 
hazard detected splicing deferred 
strategy currently paradyn instrumentation system user programs 
kernel reasons 
pausing kernel allowed involve freezing kernel threads presumably kerninstd thread performing splice possibly disrupting critical background activities 
second performing necessary backtrace threads thousands solaris kernel expensive 
third pausing possible practical jump destination longjmp may jump middle splice sequence resulting execution inconsistent code sequence 
fourth problem multiple instruction splicing occurs instrumentation point basic block splice sequence spills basic block ifb reachable block say branch block code path execute second half splice sequence inconsistent code sequence crash kernel 
reasons conclude fine grained dynamic instrumentation unsafe splicing 
single instruction splicing difficult architectures branch instructions delay slot mips 
forces delayed branch instruction splicing resulting unusual execution sequence jumping patch code 
instruction instrumentation point implicitly delay slot splice branch instruction executed code patch reached 
particular instruction instrumentation point executed instruction nally instrumentation point gets relocated code patch 
execution ordering instruction originally instrumentation point successor reversed 
cases worked 
instrumentation point instruction successor mutually independent reversing execution order safe 
instrumentation point instruction independent successor successor instruction idempotent instrumentation point instruction successor placed code patch 
resulting execution sequence successor original instrumentation point instruction successor 
mentioned constraints step equivalent nop 
course independence idempotency constraints met making single instruction splicing delayed branch architectures difficult 
final possibility splice replacing instrumentation point instruction trap illegal instruction 
immediately jump trap handler safely instrumented check offending instruction pc perform long jump appropriate code patch 
note current implementation kerninstd sparc architecture non delayed branch instruction ba splicing avoiding difficulties 
single instruction splicing variable architectures challenging depending existing code instrumentation point jump instruction splicing bytes may overwrite exactly instruction 
jump instruction smaller instruction overwritten new instruction stream contain newly written jump instruction followed tail original instruction executed 
hand instrumentation point contains instruction smaller jump instruction splicing overwrites instruction 
cause problems instruction overwritten instruction destination branch corrupted instruction stream executed 
case handled splicing byte trap illegal instruction 
transfer control trap handler instrumented conventional jump instruction look address offending instruction hash table undo processor state side effects trap transfer control appropriate code patch 
trap instructions possible overwrite just instruction hazard free 
current implementation kerninst ultrasparc splices instrumentation points outside kernel nucleus dev kmem 
instrumentation point nucleus kerninstd dev kerninst perform necessary map write sequence see section completes seen safety requires single instruction splicing risc architectures provide ideal instruction branch instrumentation point code patch 
ideal splicing instruction displacement reach patch instrumentation point delay slot cause second instruction executed code patch reached side effects changing pc absolute pc relative register relative 
register relative jumps reach part address space require register set 
leads hazardous multiple instruction splicing 
reviews features branch jump instructions architectures best suited single instruction splicing 
arch instruction range delay slot 
side effects sparc call ba jump pc gb pc mb register writes powerpc pc mb mips iv current mb aligned region cond pc alpha branch jmp pc mb register jmp pc gb suitability various instructions single instruction splicing 
risc architectures ideal splicing instruction unfortunately risc architectures instruction suitable 
key limitation displacement 
patch area heap allocated arbitrarily far code kernel modules 
need means reaching patch matter required displacement splicing single instruction safety 
kerninst implements general solution displacement problem called 
springboard scratch area reachable instrumentation point suitable jump instruction 
idea splice instruction merely branch available nearby springboard turn takes instructions needed jump code patch 
shows example code splicing presence 
code patch springboard written branch instruction written original code kmem alloc save sp sp sub sra code splicing spliced code kmem alloc save sp sp ba cb sra springboard cb call call overwrites free 
cb nop code patch inserted code omitted 
sub ba call ba nop code splicing instrumentation point instrumentation point kernel thread execute springboard code splice completed 
safety properties single instruction splicing maintained 
springboard approach requires chunks scratch space collectively springboard heap tobe conveniently located various spots kernel kernel instruction reach nearest chunk suitable jumps 
fortunately unix svr kernels including solaris linux windows nt ideally suited available scratch space initialization termination routines dynamically loaded kernel modules 
kernel allows modules loaded runtime unloaded memory tight module initialization termination routines called just module loaded just unloaded respectively code splicing springboard instrumentation point far code patch reached branch kerninstd places branch nearby springboard cb turn performs multi instruction long jump code patch 
kerninstd locks kernel modules memory guarantees initialization termination routines longer called 
solaris routines called init fini module 
svr unix standard routines called module load module unload 
linux called init module cleanup module 
windows nt device drivers routine installs pointer cleanup routine 
free springboard space 
addition preventing module unloading reloading obviates need re insert splicing code changes lost module gets re loaded 
practice single kernel module approaches megabyte size jump instruction modest range sparc ba easily reach nearest springboard 
solaris kernel modules nucleus subject runtime loading unloading initialization termination routines 
furthermore practice nucleus modules loaded kernel virtual memory far dynamically loaded ones reach initialization termination routines potential springboard space 
routines nucleus start main invoked kernel booting 
executed kerninstd adds routines springboard heap 
summarizes springboard space set aside current solaris ultrasparc implementation kerninstd 
location size bytes nucleus start main outside nucleus initialization termination routines kernel modules available springboard space solaris springboard technique may ad hoc applicable kernels experience 
furthermore bit operating systems running architecture bit instructions possibility finding single branch instruction bits displacement 
limited single instruction springboard code arbitrary displacement making general solution problem reaching patches 
springboard needed kerninstd allocates generates contents contents copied kernel space 
springboard reside kernel nucleus kerninstd fills single dev kmem springboard nucleus kerninstd invokes dev kerninst perform write see section dynamic instrumentation performance profiling section presents case study kerninst locate performance bottlenecks kernel application web proxy server workload 
kernel metrics kerninst implement kernel profiling tool 
due space constraints discuss representative sample performance primitives 
include basic counters cycle timers accumulators time accumulators 
primitives nonblocking safe multi threaded environment compare swap instruction changing values 
primitives combined complex control flow code 
basic counters implemented inserting increment operations appropriate point 
cycle timers insert start operations code function basic block entries exits 
accumulators collect values kernel variables hardware counters icache misses calculate total 
accumulators calculate average value counter variable time average number threads executing function average number threads waiting condition variable 
instrumentation code calculate area curve value averaged 
area calculated instrumentation code sums rectangles time event value changes 
performance metrics formed applying primitives 
metrics tool kit library call counts average number executing threads average number waiting threads virtual timers 
call counts simply record number times function called 
calls curve shows example number calls kernel function copen 
average number executing threads uses counter record number threads section code incremented entry block decremented exit value recording time value averaged changed calculated values 
concurrency curve shows example average number threads function copen 
average waiting threads counts number threads waiting kernel mutex variable instrumenting mutex enter primitive applied counter 
underlying processor cycle counters kerninst measure elapsed wall time 
virtual processor time important trying isolate bottlenecks 
kerninst measures virtual time instrumenting context switch handler detect kernel thread dispatched re start timer primitive appropriate times 
metrics constrained process kernel thread primitives 
find average number kernel threads belonging process executing function time primi tives spliced entry exit points predicated current pid equals 
sparc compilers instrumenting function return challenging 
function called ends calling tail call optimized unwind stack frame delay slot call return directly instrument exit point kerninst splices code sequence de optimizes tail call sequence 
done paradyn 
web proxy server benchmark kerninst study performance solaris running version squid web proxy server 
version wisconsin proxy benchmark running client processes drive squid 
squid files stored local disk running unix file system ufs 
kerninst squid run machine ultrasparc mb ram running solaris 
kerninst instruments entirely runtime gathering kernel performance information interactive process 
previous studies proxy servers shown file opens common bottleneck measured squid file creation called times second copen clear bottleneck kernel function copen handles file open file creation 
shown called times second averages threads executing code time 
squid single threaded program means average squid elapsed time spent opening existing files reading creating new files writing 
copen performs major calls allocate entry process file descriptor table vn open file system specific opening 
squid maintains disk file cached object expected bottleneck performs linear search find available table entry 
consume negligible run time copen time spent vn open 
vn open paths creating files calls vn create opening files 
vn create path called times second accounted vn open bottleneck 
file creation squid case call open creat flag bottleneck 
vn create calls important routines ufs create 
translates full path name vnode structure 
ufs create creates ufs file vnode 
measurements routines shown shows bottlenecks 
vn create components ufs create distinct bottlenecks better known namei obtains vnode parsing path components calling file system lookup routine ufs lookup ufs 
general case ufs lookup go disk obtain inode location directory file read inode contents 
optimize path name lookup solaris uses directory name lookup cache hashes path name components entries inode cache 
hit bypasses reading directory file ufs reading inode ufs 
dynamically instrumenting kernel count calls ufs hit rate 
penalty execution ufs high account ufs lookup bottleneck shown 
squid preponderance small cache files benchmark overwhelmed contains entries default 
address bottleneck increased size maximum allowed value 
shown eliminates ufs lookup bottleneck accounts just squid elapsed time 
permanent solutions suggest 
grow needed avoid conflict misses 
ufs lookup ufs called accounts ufs lookup bottleneck curves entirely overlap 
note lookup time essentially zero 
effect increasing size penalty routine ufs called infrequently accounts just squid elapsed time 
flip side argument squid simply uses small files redesigned large fixed size file disk cache 
recall ufs create second bottleneck vn create accounting squid elapsed time 
ufs create time spent ufs invoked squid passes trunc flag open system call 
squid time spent truncating existing cache files zero size opening 
ufs time spent ufs synchronizes updates inodes 
truncation slow ufs synchronizes changes meta data 
squid reuses obsolete disk cache files deleting obsolete file creating new scratch 
motivation avoid expensive meta data operations required file deletion updating parent directory file freeing inodes 
ufs bottleneck shows squid strategy 
address bottleneck note deleting file inodes truncation added synchronously new version file written 
new file size equal old size inode deletions creations amount expensive op 
new file size original size lesser optimization delete inodes file longer needed 
modified squid implement changes effect shown 
time spent synchronously effect improving squid truncation ufs accounts squid elapsed time updating inodes reduced squid run time 
combined effect optimizations shown 
open system call vn create performance optimizations component reduced larger ufs create component reduced open system call longer uses trunc flag 
note ufs create time essentially zero 
consumed squid run time takes 
added time spent truncating cache files done explicitly trunc flag open 
took squid elapsed time takes 
safety security issues splicing code running kernel introduce race conditions kernel threads executing instrumentation point spliced splicing hazards adversely disrupt kernel execution safety violations introduce undesirable information flows security violations 
single instruction splicing section solves splicing hazard problem 
plan harness rich body existing safety security commodity kernel written extensibility mind fine grained patching issues complex 
summarize issues outline initial directions 
trusted code 
approach authority certifies code behaved 
certification may generator code code lies specially protected directory system administrator update 
alternatively code may come trusted party network digital signature 
strategy fall back position current kerninstd currently requires applications written top super user privileges 
dynamically safe code 
safety issues addressed executing inserted code 
safety violations detected inserting extra instructions dynamic code 
second corrective action taken violation detected 
action simple exiting dynamic code killing kernel thread executed offending code complex 
dynamic code local executing behalf single user process modifying shared kernel data structures exiting dynamic code sufficient 
software fault isolation sfi techniques augment dynamic code run time checks insure code stays local space :10.1.1.142.4909
vino exokernel systems technique :10.1.1.100.6047
dynamic code global common parts kernel accessing data structures shared kernel threads 
case terminating offending code may leave locks held shared data structures inconsistent state 
sfi techniques need significantly extended handle shared resources 
kernel data structures transaction semantics vino simplify constructing recovery mechanism 
statically safe code 
code identified statically safe advantages 
code potentially efficient run time checks needed 
second code misbehave recovery scheme needed 
proof carrying code pcc example approach :10.1.1.142.6054
pcc requires safety policy formally defined resources accessed extension 
inserted code access kernel data structures call kernel functions gone rigor formally defined safety policy 
combined approaches 
combination static dynamic checking done safe languages java modula spin potentially requires fewer run time checks needs recovery strategy 
extension code classified interaction underlying kernel 
annotations performance measurement debugging code orthogonal underlying computation 
annotation writes data transfer control outside annotations code bounded time resource requirements recovery strategy easy annotation removed 
annotations call kernel functions locking routines may temporarily modify system state 
safety annotations requires specification semantics kernel routines dynamic code calls :10.1.1.126.9884
plan design specifications cover common synchronization scenarios 
recovery commodity operating system open annotation fault area actively researching 
code adaptations intentionally change behavior underlying system way 
examples include fly optimizations specialization outlining 
adaptation may take part kernel replace code accomplishes task efficient reliable manner 
currently developing mechanisms closed looped dynamic measurement optimization 
adaptations may include adding new functionality kernel 
safety recovery issues fine grained adaptations complex open annotations 
security issues distinct safety issues 
security restricting information flows authenticating data modifications 
annotations adaptations may efficient safe secure 
example sensitive kernel structures process address spaces copied file quickly safely open large security holes 
security addressed safety verifying formally defined policies resources accessed inserted code respected 
related extensible operating systems spin exokernel vino allow processes download code kernel differ approach ways :10.1.1.100.6047
unmodified commodity kernels 
second perform coarse grained instrumentation example vino allows classes customize object methods 
third limited number instrumentation points pre coded way allows easy instrumentation example replaces function called preexisting level indirection overwriting appropriate function pointer 
requiring special code process specific customization take place incurs small overhead methods customized 
limits granularity instrumentation impractical place level indirection kernel basic block 
note kerninst complementary research kernels provide additional splicing capabilities 
digital continuous profiling system dcpi measures detailed performance metrics cycles icache misses instruction level commodity kernel 
kerninst dcpi instrument kernel code way precludes metrics readily sampled 
kerninst concert continuous profiling create additional metrics software 
paradyn dynamically instruments user programs 
differs paradyn ways applies kernels instrumentation fine grained paradyn limits instrumentation points function entries exits calls sites kerninst instruments pausing paradyn incurs substantial overhead pausing application walking stack ensure safe splicing instrumentation request 
static binary eel atom fine grained allow arbitrary code inserted user programs potentially kernels 
static rewriting requires program taken line instrumentation instrument case may turn interest 
contrast dynamic instrumentation allows user refine runtime instrumentation interest 
traces kernel code locations 
replaces instructions traced trap transfers control custom handler 
handler appends entry trace log resumes execution 
trap instructions inserted kernel instructions fine grained 
differs ways requires kernel recompile insert general code kernel method resuming execution trap expensive dynamic instrumentation 
finegrained dynamic instrumentation subsumes insert arbitrary code just trace gathering code 
slic provides extensibility commodity operating systems rerouting events crossing certain kernel interfaces system calls signals virtual memory routines extensions downloaded kernel run user level process :10.1.1.143.5553
slic interposes extensions kernel interfaces rewriting jump tables binary patching kernel routines 
performs binary patching slic replaces instructions start kernel function seen section multiple instruction patching unsafe 
addition slic fine grained example interposing system calls provides dozen kernel instrumentation points 
fine grained dynamic kernel instrumentation uses including performance profiling debugging testing optimizing extending kernel 
shown design implementation dynamic kernel instrumentation combines fine grained splicing dynamic code generation 
shown technology feasible implementing solaris running ultrasparc investigating ports architecture os combinations including 
kerninst opens areas opportunity general creates safety security concerns 
currently formulating formal access control model goal automating checking dynamic code 
acknowledgments pei cao kevin beach group supplying wisconsin proxy benchmark stephen sun microsystems technical assistance suggestions matt carlos karen tia brian wylie xu comments manuscript 
almeida cao 
wisconsin proxy benchmark 
www cs wisc edu cao html 
anderson dean ghemawat henzinger leung sites waldspurger weihl 
continuous profiling cycles gone 
th acm symposium operating systems principles sosp saint malo france oct 
auslander philipose chambers eggers bershad 
fast effective dynamic compilation 
acm sigplan conference programming language design implementation pldi philadelphia pa may 
bershad savage pardyak sirer becker chambers eggers 
extensibility safety performance spin operating system 
th acm symposium operating systems principles sosp copper mountain dec 

sun performance tuning java internet 
sun soft press 
engler kaashoek toole jr exokernel operating system architecture application level resource management :10.1.1.100.6047
th acm symposium operating systems principles sosp copper mountain dec 
engler :10.1.1.25.8634
vcode retargetable extensible fast dynamic code generation system 
sigplan conference programming language design implementation pldi philadelphia pa may 
rodrigues petrou anderson :10.1.1.143.5553
slic extensibility system commodity operating systems usenix technical conference new orleans june 
hollingsworth miller 
dynamic program instrumentation scalable performance tools scalable high performance computing conference knoxville may 
hollingsworth miller gon alves xu zheng 
mdl language compiler dynamic program instrumentation 
international conference parallel architectures compilation techniques san francisco nov 
kuenning 
precise interactive measurement operating systems kernels software practice experience january 
larus schnarr 
eel machine independent executable editing 
acm sigplan conference programming language design implementation pldi la jolla ca june 
mosberger peterson bridges malley 
analysis techniques improve protocol processing latency 
acm sigcomm stanford ca aug 
necula lee :10.1.1.142.6054
safe kernel extensions run time checking 
nd usenix symposium operating systems design implementation osdi seattle wa oct 
necula lee :10.1.1.126.9884
design implementation certifying compiler 
acm sigplan conference programming language design implementation pldi montreal canada june 
pu black consel cowan inouye walpole zhang 
optimistic incremental specialization streamlining commercial operating system 
th acm symposium operating systems principles sosp copper mountain dec 
seltzer endo small smith 
dealing disaster surviving misbehaved kernel extensions 
nd usenix symposium operating systems design implementation osdi seattle wa oct 
seltzer small :10.1.1.15.6112
self monitoring self adapting operating systems 
th workshop hot topics operating systems cape cod ma may 
small 
tool constructing safe extensible systems 
th usenix conference object oriented technologies systems coots santa fe nm april 
srivastava eustace 
atom system building customized program analysis tools 
acm sigplan conference programming language design implementation pldi orlando fl june 
wahbe lucco anderson graham :10.1.1.142.4909
efficient software fault isolation 
th acm symposium operating systems principles sosp asheville nc dec 
