logical foundations object oriented frame languages michael kifer georg lausen james wu propose novel formalism called frame logic abbr logic accounts clean declarative fashion structural aspects object oriented frame languages 
features include object identity complex objects inheritance polymorphic types query methods encapsulation 
sense logic stands relationship objectoriented paradigm classical predicate calculus stands relational programming 
logic model theoretic semantics sound complete resolution proof theory 
small number fundamental concepts come object oriented programming direct representation logic secondary aspects paradigm easily modeled 
discusses semantic issues pertaining programming deductive object oriented language subset logic 
categories subject descriptors database management languages query languages arti cial intelligence deduction theorem proving deduction logic programming nonmonotonic reasoning mathematical logic formal languages mathematical logic logic programming mechanical theorem proving general terms languages theory additional key words phrases object oriented programming frame languages deductive databases logic programming semantics proof theory typing nonmonotonic inheritance journal association computing machinery may department computer science suny stony brook stony brook ny email kifer cs sunysb edu 
supported part nsf dcr iri ccr 
institut fur informatik universitat freiburg freiburg germany 
email lausen informatik uni freiburg de renaissance software san antonio rd los altos ca email wu rs com 
supported part nsf iri 
contents object oriented vs declarative programming logic example syntax semantics structures attaching functions methods attaching types methods discussion satisfaction formulas structures predicates semantics properties structures properties equality properties relationship properties signature expressions miscellaneous properties skolemization clausal form herbrand structures herbrand theorem proof theory substitutions uni ers core inference rules inference rules type inference rules miscellaneous inference rules remarks soundness proof theory sample proof completeness proof theory data modeling logic logic programs semantics examples hierarchies examples type declarations examples object bases set manipulation querying database schema representation analogies list manipulation relational algebra interpreter typed programs type errors encapsulation example modules type correctness inheritance structural inheritance behavioral inheritance informal approach fixpoint semantics non monotonic inheritance strategies overriding behavioral inheritance issues data modeling existing non existent objects empty sets vs unde ned values complex values path expressions primary classes immediate superclasses version control ii extensions logic sorted logic uses multiset valued methods hilog inspired extensions logic dynamic behavior anatomy logic appendix perfect model semantics logic appendix perfect models presence inheritance appendix uni cation algorithm molecules iii past decade considerable interest arose called object oriented approach database community researchers programming languages 
object oriented approach loosely de ned term number concepts complex objects object identity methods encapsulation typing inheritance identi ed salient features approach :10.1.1.44.5524
important driving forces interest object oriented languages databases promise show called impedance mismatch programming languages writing applications languages data retrieval 
time di erent deductive approach gained enormous popularity 
logic computational formalism data speci cation language proponents deductive programming paradigm arguing approach overcomes mismatch problem just 
form approaches shortcomings 
main problems object oriented approach lack logical semantics traditionally playing important role database programming languages 
hand deductive databases rely data model support data abstraction 
expected combining paradigms pay 
great number attempts combine approaches reported literature opinion entirely successful :10.1.1.45.8055
approaches seriously restrict object structure queries sacri ce adding extra logical features omit important aspects object oriented systems inheritance 
propose formalism called frame logic abbr logic achieves goals listed addition suitable de ning querying manipulating database schema 
logic full edged logic model theoretic semantics sound complete proof theory 
sense logic stands relationship object oriented paradigm classical predicate calculus stands relational programming 
apart object oriented databases important application logic area frame languages ai languages built concepts complex objects inheritance deduction 
connection name frame logic derived 
terminology comes object oriented parlance ai 
talking objects attributes frames slots 
reasoning inheritance knowledge base exploration logic language greatly aided higher order capabilities 
higher order logics approached caution order preserve desired computational properties 
past number researchers suggested useful higher order concepts knowledge representation languages encoded predicate calculus 
programmer point view encoding satisfactory direct semantics important higher order constructs retain spirit objectoriented programming 
contrast logic represents higher order object oriented concepts directly syntactically semantically 
builds previous papers turn borrowed important ideas maier logic turn inspired kaci terms :10.1.1.48.7149
described logic adequately covered structural aspect complex objects short capturing methods types inheritance 
earlier version logic reported perspective object oriented vs declarative programming step higher order syntax 
particular supported querying database schema structural inheritance built semantics 
early version logic aws 
problems universe objects required form lattice turned impractical logic language 
problem semantics appropriate modeling object types object states 
problems recti ed logic extended accommodate typing non monotonic inheritance features 
aspect knowledge systems dealt database dynamics involves changes internal state objects 
experience shows database dynamics orthogonal structural aspects object oriented systems focus 
extensive formalizing updates logic 
reader referred transaction logic comprehensive discussion problem overview related eld solutions previously outstanding problems 
section brie touch issue extending logic direction transaction logic combination captures dynamic aspects object oriented languages including updates methods side ects 
important aspect logic extensibility combined broad range specialized logics 
section outline combinations hilog transaction logic 
possible candidate annotated predicate logic logic reasoning inconsistent uncertain information 
extensibility places logic center powerful unifying formalism reasoning data knowledge 
organized follows 
section discusses relationship object oriented paradigm relational paradigm 
section informal main features logic 
sections describe syntax semantics logic 
section discusses various semantic properties logic 
sections develop proof theory 
section demonstrates modeling power logic number non trivial examples 
section discusses typing 
section introduce notion encapsulation 
propose view encapsulation kind type correctness policy show semantically rich encapsulation disciplines represented way 
section presents semantics inheritance 
array issues data modeling complex values versions control path expressions covered section 
extensions logic discussed section 
section provide retrospective view internal structure logic relate logic classical predicate calculus 
section concludes 
object oriented vs declarative programming anumber researchers argued object oriented languages fundamentally di erent incompatible paradigms especially logic programming 
point view re ecting disappointment lack early success formalizing aspects object oriented programming 
compounding problem lack framework compare various approaches di erences similarities seen common framework 
section attempt clarify issues 
customary de ne notion object orientation long list properties object oriented system possess 
works divide properties perspective object oriented vs declarative programming tory optional :10.1.1.44.5524:10.1.1.44.5524
surveys helped identify issues de ning paradigm enumerating features somewhat 
fundamental features allegedly set object oriented approach apart relational paradigm 
features claimed object oriented 
believe answer lies way various languages represent data 
view central feature relational model data conceptually grouped properties 
instance information regarding person normally scattered di erent relations manager describing di erent properties attributed persons 
hand pieces data describe di erent persons property projects grouped single relation 
contrast object oriented representation seeks group data objects conceptual level 
philosophy language design user access directly inheritance public information object handle object obtained 
handle usually referred physical object identity implementational notion conceptual counterpart object identity 
logical oid introduced subsequently utilized works 
concept object identity widely discussed database literature 
early attempt bring notion fold logical theory reported maier 
re ecting ullman concluded concept object identity incompatible logic 
feel maier di culties ullman pessimism arise confusion traced lumping physical logical object identities notion 
having decided group data objects natural try tap potential representation making class hierarchies inheritance typing 
di erence optional mandatory properties put forward subjective matter perceives important features style data representation :10.1.1.44.5524
sum view main di erence object oriented relational languages data representation paradigm 
classi cation dimension programming languages programming paradigm consists mainly categories procedural functional deductive 
shows various languages may framework 
contention misconception incompatibility deductive object oriented languages comes overlooking fact classi cation axes really orthogonal 
commonly referred deductive database languages simply class languages characterized relational data model deductive programming paradigm 
contrast systems perceived objectoriented procedural 
anumber upward compatible object oriented logics introduced clearer perceived incompatibility gap bridged :10.1.1.48.7149
continues line research closing gaps rectifying aws earlier attempts 
note practical considerations force di erent paradigms exist roof 
instance prolog control primitives give procedural avor 
logical object oriented languages allow grouping data properties relationally objects 
iql relies small number procedural features 
pascal ers declarative access data structure language procedural 
believe belongs multi paradigm languages aforementioned impurity logic example deductive functional procedural programming paradigm ldl nail 
relational algebra glue qk prolog pascal relational orion exodus hhh hj object oriented classi cation database programming languages logic logic logic iql data representation paradigm necessarily drawback 
clean integration various paradigms important research issue 
clear deductive domain relational object oriented data representation paradigms go hand hand 
unaware clean solution integration problem procedural object oriented relational languages likewise generally agreed framework integrating functional deductive paradigms 
logic example development logic guided desire capture logically clean way anumber knowledge representation scenarios 
salient features logic described section way example 
hierarchy shows part hierarchy classes individual objects solid arcs represent subclass relationship dotted arcs represent class membership 
hierarchy asserts faculty manager subclasses empl student empl subclasses person mary cs members class string mary faculty sally member class student 
note classes logic example 








datatype person young string integer child person empl student cs bob john mary phil manager child john faculty dept sally report alice mary bob cs degree article hy cs cacm jacm 
ms phd codd part hierarchy rei ed belong domain individual objects 
endows logic great deal uniformity making possible manipulate classes objects language 
particular viewed object class member class 
instance classes string integer members class datatype 
actual syntax logic represent class membership denote subclass relationship 
instance hierarchy recorded shown 
statement person says empl subclass person john empl says john instance class empl 
notice objects denoted usual rst order terms john empl person point assume object primary class unique lowest class class hierarchy object member class hierarchy path connects pair classes goes nite number intermediate classes 
primary classes discrete hierarchies assumed object oriented systems fundamental deserve canonization logic 
section shows features represented logic 
logic example object base empl person young student person young faculty empl child person person john student cs string john empl bob string cs dept alice child john 
logic representation hierarchy presents database fragment describing employees students entities 
rst statement says object bob attribute name takes value bob 
bob logical id object supposedly represents person 
fact represents faculty 
contrast bob member class string represents value bob attributes called name 
note logic emphasize objects values 
believe complications introduced dichotomy justify bene ts 
inf logic bob viewed oid represents string bob 
object ids atomic values integers strings easily represented sorted version logic section 
addition section discuss modeling called complex values structures similar complex objects oid 
statement says bob works department denoted oid cs department name represented oid cs manager described object oid bob 
note bob cyclic 
statement ii represents similar information mary 
attributes name highestdegree return single value attribute friends set valued 
syntactically indicated double headed arrow braces fg 
statements iii vi provide general information classes signatures 
signature class speci es names attributes methods applicable class type arguments method takes type result returns 
statement iii instance says object class faculty attributes age highestdegree types degree respectively attribute boss returns results simultaneously belong classes faculty manager 
object oriented systems method function form objects objects 
objects objects objects objects wherep power set operator 
object methods encapsulated inside object constitute interface rest system 
rst argument method object method invoked host object invocation 
arguments called proper arguments invocation 
reader mayhave noticed double headed arrows 
conjunction set valued attributes signify scalar attributes 
double arrows specify types arrows 
describe values attributes 
double arrow logic example database facts bob name bob de ning scalar property name bob age de ning scalar property age bob liation 
cs dname cs bob assistants ii mary name mary highestdegree ms friends de ning set valued property liation 
cs dname cs general class information iii faculty boss faculty manager typing scalar attribute boss returns objects belonging age simultaneously classes faculty manager 
highestdegree degree attribute returning objects class degree 
papers article returns sets objects class article 
highestdegree 
phd de ning inheritable property highestdegree 
de ning non inheritable property 
iv person name string friends person typing attribute friends returns sets persons 
children child person returns sets elements class child person 
empl liation dept boss empl empl report typing method takes argument class empl returns set report objects 
vi dept assistants student empl returns sets objects simultaneously empl belong classes student empl 
deductive rules vii boss empl dept liation empl viii faculty faculty papers papers queries ix empl boss age liation 
dname cs mary jacm xi mary phil sample database logic example speci es attribute method de ned single arrow may attribute 
instance cl attr write obj attr 
obj class cl specify value attr attr speci ed class obj 
note incl attr signi es conjunction types value attr object class cl simultaneously belong classes set types right double arrow singleton set attr empl shall omit surrounding parentheses write attr empl 
di erent kinds information objects mixed statement 
instance statement iii expression highestdegree degree speci es type attribute highestdegree expression highestdegree 
phd speci es inheritable property faculty non inheritable property faculty 
asserting inheritable property class object ect member object class inherits property overwritten 
instance assertion bob highestdegree 
phd derivable inheritance iii fact bob faculty 
note property inherited member class non inheritable explains inheritance derives bob highestdegree 
phd bob highestdegree 
phd 
inheritable property may inherited subclass 
case inherited property remains inheritable subclass passed hierarchy objects 
example lecturer subclass faculty lecturer highestdegree 
phd derivable inheritance lecturer inheritable property highestdegree 
ms inheritance 
inheritance discussed detail section 
contrast inheritable properties property iii inheritable members subclasses faculty 
sense inherit average salary aggregate property members class meaning individual members 
inheriting subclass meaningless subclass members lecturers di erent average salary members larger class faculty 
observe property may inheritable non inheritable time depending context 
duality take place object 
instance format attribute speci es space needed represent object 
integer format 
byte format 
word asserts representing object integer takes byte representing member class integer takes machine word 
words format 
byte non inheritable property object format 
word inheritable property class objects 
individual object class inherit format word non inheritable property 
confuse reader assert datatype format 
byte 
case presumably integer datatype holds integer format 
byte derivable inheritance property need stated explicitly 
statements iv vi specify typing constraints classes person empl dept precisely said statements de ne signatures methods attached classes 
things worth noting 
expression empl report describes method expects proper argument class empl returns set elements class report 
object oriented terms means person object obj receives message argument class empl reply message returned obj consist set objects member class report 
note essential di erence methods attributes simply methods arguments 
strictly speaking written name string age 
name string age logic example short hand notation convenient arguments expected 
second thing note expression children child person iv speci es type constraint attribute children 
child unary function symbol person constant denoting class 
term child person logical id class 
logic function symbols constructors object class id 
shall omit braces surrounding singleton sets write say friends bob friends 
friends statement ii assistants braces kept indicate sets 
cs assistants equivalent toa conjunction cs assistants john assistants sally braces leads concise notation 
statement vii deductive rule de nes new attribute boss objects class empl 
says employee boss manager department employee works 
follow standard convention logic programming requires names logical variables capital letter 
statement viii de nes method signature 
object class person function takes argument oftype person returns set objects type report object set represents authored people 
informally rule read follows report object simultaneously belongs sets papers papers faculty objects belong set returned method invoked host object argument emphasize variable ranges members set papers papers instantiated set 
note need restriction report rule body object faculty attribute papers speci es set article objects iii article subclass report 
interested jacm papers restriction asz jacm necessary body viii 
uses method shown xi 
statement query authors mary represented oid jacm query xi requests joint papers mary authored phil 
statement ix query middle aged employees working cs departments 
particular employee attributes boss age anda liation requested 
expected answer ix xii bob boss 
bob age liation 
cs 
object mary qualify answer ix unknown age 
context fact attributes methods partial functions 
may de ned objects class unde ned 
logic distinguishes reasons unde nedness attribute method may object may applicable value unknown 
case arises due typing discussed 
case hand essentially form null value known database theory 
example rest term type object interchangeably refer classes object declared signatures 
exact meaning clear context 
dual term appropriate generally notion type refers arbitrary collections values 
classes signatures specify collections 
denotes papers denotes set oid returned attribute papers object set papers holds 
similarly papers 
logic example collections class members semantically related objects denotes collections objects structurally related 
semantic similarity usually implies structural similarity uses term type closely related 
features bidding introductory example highlight features logic 
suppose statement replace bob phil 
type error 
hand deductive rule vii implies bob boss 
phil hand phil faculty manager 
violates typing constraint attribute boss iii 
seen section notions typing type error precise model theoretic meaning logic 
related aspect type system logic signature declarations enforced 
instance methods declared members class faculty name friends children methods inherited person liation methods inherited empl boss age highestdegree methods directly speci ed class faculty 
enforcing signature declarations means methods applicable members class faculty method illegal scope class 
type error invoke method argument member class empl 
similarly atype error invoke methods group objects represent employees faculty liation objects members class empl 
example invocations methods sanctioned signatures declared appropriate classes 
method hand covered signature violation typing conditions discussed section 
correct problem class faculty role object member class say members various categories employees faculty 
give declare integer 
observe di erence treatment non inheritable method methods example inheritable method highestdegree 
covered signature declared class faculty member covered signature declared class faculty subclass 
non inheritable method property object faculty inheritable method highestdegree ectively property objects members class faculty 
important aspect logic type system polymorphism 
means methods invoked di erent classes arguments di erent types 
instance signatures integer plus integer integer real plus real real note phil employee bob boss phil complies typing boss class empl speci ed 
bob member class faculty iii imposes stricter type attribute boss class requiring phil faculty manager 
class faculty subclass relationship logic non strict 
logic example say plus method returns integer invoked integer object 
plus invoked object class real argument comes class method returns object class real 
general just specifying polymorphic types requires signature 
polymorphism kind illustrated called overloading 
examples polymorphic types including parameterized types section 
form polymorphism method invoked varying number arguments called arity polymorphism 
instance student grade year grade may legal invocations say rst implicitly assuming current year 
arity polymorphism popular logic programming languages prolog 
prolog arity polymorphism logic controlled signatures just kind polymorphism 
means able invoke method number arguments appropriate signature speci ed 
instance signature invoked argument 
way arity polymorphism turning logic sorted language 
extension described section 
kind polymorphism arises method declared set valued scalar 
instance suppose types de ned student grade course integer student grade course integer rst case grade set valued method argument student course returns set student scores course say scores projects examinations 
second case grade course returned 
instance sally student query sally grade db return set sally scores database course query sally grade db return nal grade 
kind polymorphism controlled signatures controlled sorts similarly arity polymorphism 
observe logic manipulates higher order concepts 
attribute friends set valued function 
similarly view classes hierarchy sets ordered subset relation 
furthermore attributes methods viewed objects 
instance implies names returned query answers 
way schema information turned data manipulated language 
useful tasks require schema exploration databases section inheritance overriding section applications sections 
despite higher order syntax underlying semantics logic formally remains rst order circumvented di culties normally associated higher order theories 
important issues scope complete discussion appears 
rst order means variables range complex domains domain sets domain functions range intensions higher order entities 
syntax syntax alphabet logic language consists set object constructors nite set variables auxiliary symbols 
usual logical connectives quanti ers 
object constructors elements play role function symbols logic 
function symbol arity nonnegative integer determines number arguments symbol take 
symbols arity called constants symbols arity construct larger terms simpler ones 
id term usual rst order term composed function symbols variables predicate calculus 
set ground variable free id terms denoted 
set commonly known herbrand universe 
conceptually ground id terms play role logical object id logical abstraction implementational concept physical object identity 
logic term object id abbr oid logical id 
objects represented compound id terms usually arise complex object class constructed simpler components example 
denote set function symbols ground terms respectively language known context 
molecular formulas language logic henceforth called language brevity consists set formulae constructed alphabet symbols 
logics formulas built simpler formulas usual connectives ers 
simplest kind formulas called molecular formulas abbr molecules just molecules 
adopt convention inspired prolog syntax symbol begins lower case letter denotes ground id term symbol begins capital letter denotes id term may non ground 
de nition molecular formulas molecule logic statements assertion form form ando id terms 
ii object molecule form separated list method expressions 
method expression non inheritable data expression data expression expression 
non inheritable data expressions take forms syntax non inheritable scalar expression qk 
non inheritable set valued expression rl fs smg inheritable scalar set valued data expressions non inheritable expressions replaced 
replaced 
signature expressions take forms scalar signature expression vn ar set valued signature expression ws bt rst assertion states nonstrict subclass inclusive case denote class 
second assertion states member class ii id term denotes object 
id terms 
syntactic context indicates invoked scalar method context indicates set valued invocation 
terms variables term represents family methods single method 
double headed arrows 
indicate denotes set valued function 
single headed arrows 
indicate corresponding method scalar 
data expressions si id terms represent output respective methods invoked host object arguments qk rl respectively 
arguments id terms 
signature expressions ai bj id terms represent types results returned respective methods invoked object class arguments types vn ws respectively arguments id terms 
notation signature expressions intended say output method belong classes listed parentheses right 
order data signature expressions molecule immaterial 
convenience method data signature expression occurrences molecule 
likewise id term may occur multiple times braces inside data expression parentheses inside signature expression 
furthermore method expect arguments omitted 
instance write mthd 
val mthd 
val similarly 
likewise element appears wemay write fsg similarly shall write andq 
assertions person turn tautologies class subclass 
syntax discussion informally object molecule ii asserts object denoted properties speci ed method expressions listed inside brackets 
data expressions de ne properties objects terms methods supposed 
inheritable data expressions may inherited subclasses individual members object plays role class contrast properties speci ed non inheritable inherited 
signature expression ii speci es type constraints methods applicable objects class typing method arguments results 
instance scalar signature expression ii says scalar method indicated invoked host object class proper arguments coming classes vn result simultaneously belong classes ar 
similarly typing ii says set valued method indicated host object class proper arguments classes ws element resulting set simultaneously belong classes bt 
notice molecule asa attr attr fc dg attr 
syntactically formed despite fact attr specify non inheritable scalar property object data expression non inheritable set valued property inheritable scalar property third part 
apparent contradiction easily resolved semantic level attribute attr value object invoked non inheritable scalar method arrow returns dg called non inheritable set valued method returns value called inheritable scalar method arrow 
happens class object properties attr band attr fc dg inheritable members subclasses attr 
inheritable speci ed 
follows syntax logical id denote entity method depending syntactic context id formula 
occurs method id denote scalar function set valued function 
scalar set valued determined context viz type associated arrow 
assertions atomic decomposed simpler formulas 
molecular formulas atomic 
seen shortly molecule attr 
attr equivalent conjunction atoms attr attr 

property call formulas molecular atomic 
atomic formulas de ned section 
complex formulas formulae built simpler formulae means logical connectives quanti ers molecular formulae formulas formulae formulae variables 
addition de ne literal molecular formula negation molecular formula 
semantics section shall implication connective 
logic connective de ned classical logic shorthand tradition refer logical statements written implications rules 
terminology example section shall continue practice 
convenient di erent kinds molecules vii viii ix write say abbreviation scalm setm scalm 
setm furthermore symbols right hand side arrows denote id terms de nition convenient fact customary combine molecules ii 
instance scalm 
setm ft sg de ned abbreviation semantics scalm 
setm ft sg pair sets shall otal denote set total functions 
similarly stands set partial functions 
power set denoted byp 
collection parameterized natural numbers si denote cartesian product si set nite sn structures logic semantic structures called structures 
language anf structure tuple hu domain irre exive partial order binary relation 
usual write ub ub extend tuples natural way write corresponding relationships hold component wise 
ordering semantic counterpart subclass relationship ub interpreted statement subclass binary relation model class membership ub taken mean member class binary relationships related follows ub uc uc 
just way extension subclass set members subset extension superclass 
impose restrictions class membership relation lets accommodate wide range applications 
particular acyclic possibility class may member viewed object 
reader misled exibility required ai applications interpreted typical element class semantics thinking uv subset contains actual meaning statement element ofu denotes subset contains analogy classical logic view set actual objects possible world ground id terms elements play role logical object id 
interpreted objects mapping otal 
mapping interprets ary object constructor function 
identi ed element ofu 
function symbols interpreted way predicate calculus 
remaining symbols denote mappings interpreting method expressions logic 
mappings described 
attaching functions methods mappings classical logic mapping associate element ofu id term 
logic id terms denote methods 
method function takes host object list proper arguments maps object set objects depending method invoked scalar set valued function 
assign meaning methods structure attach appropriate function method 
id terms play role method names id term function representing actual method named term 
subtlety 
id terms method names particularly useful variables method names allowed querying database schema possible 
turns give meaning molecules method variables necessary associate functions elements elements 
furthermore method name di erent arities id term needs separate function possible arity 
formally role methods objects interpreted assignment appropriate functions element ofu maps 
speci cally object incarnation scalar method obtained mappings 
mappings associates tuple partial uj element ofu exactly fk tuple method arity 
words method invoked di erent arities 
addition di erent arities method invoked scalar set valued function sally grade db grade db section 
semantically achieved interpreting set valued incarnations methods di erent pair mappings 
partial method arity mappings associates partial function element ofu 
note element ofu di erent provided 
provided 
subtle technical point necessity apparent notion truth structures de ned 
semantics di erence versions 
versions mappings versions interpret non inheritable data properties 
versions inheritable ones 
distinction inheritable non inheritable properties explained section formal treatment section 
seen de nitions andi 

nite tuple functions parameterized arity 
refer th component tuple notation 
resp 



method occurs scalar non inheritable data expression proper arguments interpreted 
occurs set valued non inheritable data expression arguments interpreted 

note 
mappings ary functions 
rst argument host object invocation method arguments correspond proper arguments invocation 
parlance object oriented systems 
obj ak isa request object obj invoke scalar method ak 
attaching types methods mappings methods interpreted functions meaning signature expressions functional type role specify type method 
specify functional type describe types arguments function applied types results returned function 
furthermore description account polymorphic types cf 
earlier 
model theoretically functional types described mappings satisfy usual properties polymorphic functional types spelled 
case 
related functions mappings attached elements 
start succinct de nition continue discussion properties mappings 

set upward closed subsets aset upward closed uv imply viewed set classes upward closure simply means class set contains superclasses denotes set partial anti monotonic functions top 
partial function anti monotonicity means de ned de ned 
discussion relationship 
de nition structures complete 
rest subsection discuss properties show coincide standard properties functional types signatures constitute fairly advanced level logic basic features hierarchy data expressions depend speci cs type system 
reason rst reading possible skip signature related aspects logic including remaining part subsection 
functions monotone respect smyth ordering 
upward closed sets smyth semantics albeit expressed di erent model theoretic notation 
refer th component tuple 
similar notation set valued methods 
intended meaning type ary function 

words main de nition tuples classes cl arg cl arg cl ki specify type tuples arguments ho arg 
meaningfully applied argument tuples arg cl arg cl arg cl ki holds 
tuple classes cl 
arg ifi host cl 
type 

args tuple arguments 


args de ned uw hold class arg cls de ned represents cl arg 
means arg cls 
host cl 
particular set types interpreted essentially extended members 
reason notation signatures cf 

similarly meaning de ned type set valued function 

case 

class ini host cl 
args objects object 

arg cls relationship uw hold 
args belong rationale conditions anti monotonicity upward closure de nition andi clear intended meaning functions 
instance object 

args cl 

args ucl clearly 

args member superclass cl 

args ucl cl cl ucl host cl 
arg cls upward closed 
similarly ifi 
member class host cl proper arguments type 
arg cls invocable member host cl host cl arguments 
args 
args arg cls cl 
arg cls cl arg 
furthermore result application 
ho 
typed host cl 
arg cls 
type host cl 
obtain host cl 
arg cls host cl 
arg cls viz anti monotonicity 
arg cls relationship part de nition structures 
captured meta level de nition type correctness section 
relationship captured notion type correctness 
slightly di erent relationship described fully explained section 
satisfaction formulas structures variable assignment mapping set variables domain variable assignments extend id terms usual way ifd arity recursively 
molecular satisfaction structure avariable assignment 
intuitively molecule istrue respect variable assignment denoted ij object ini properties formula says 
special case molecules form specify properties semantics vacuously true 
molecule true objects involved related 
de nition satisfaction molecules structure molecule 
write ij holds assertion object molecule form separated method expression conditions hold ii non inheritable scalar data expression form scalm qk element 
scalm qk de ned equal 
similar conditions hold inheritable scalar data expressions replaced 
iii non inheritable set valued data expression form setm rl 
fs smg set 
setm rl de ned contain setf sm similar conditions hold inheritable set valued data expression replaced 
iv scalar signature expression scalm qn ru set scalm qn de ned ru 
valued signature expression form setm vs wv set setm vs de ned wv says object subclass member class 
conditions ii iii say case data expression interpreting function de ned appropriate arguments yield results compatible speci ed expression 
conditions iv say signature expression type method scalm setm speci ed expression comply type assigned method observations may help shed light rationale aspects de nition structures follows iv signature form ck inside parentheses tautology 
structures ck unde ned 
similarly 
empty signature intuitively says respective scalar method applicable objects class arguments drawn classes ck specify actual type result 
method applied context signature ck true 
constraints part typing conditions discussed section 
predicates semantics ck true ak unde ned ck ak value kind value missing situation known database theory 
ck false conditions section mandate ak unde ned 
analogous null value kind value inapplicable meaning value invocation arguments exist 
deceptive simplicity items iv direct result upward closure codomain scalm setm 
upward closure iv looked scalm qn de ned element set ri 
similar change needed 
serious consequence dumping upward closure condition elegant anti monotonicity constraint scalm setm replaced awkward condition needed coerce signatures behaving functional types see section 
notice de nition determines meaning molecules form 
subtlety method functions associated variable ranges methods 
variable assignment notin 
associating method functions ground id terms useless interpreting molecules 
explains earlier insisted functions form 
form 
models logical entailment meaning formulae de ned standard way ij ij ij ij resp ij ij resp 
meaning quanti ers standard ij ij resp agrees possibly 
closed formula omit mention simply write ij meaning closed formula independent choice variable assignments 
structure closed formula ij ifs set formulae formula write sj read logically implied entailed true model predicates semantics convenient tohave usual rst order predicates par objects cf 
certain things easier specify value setting experience shows predicates alongside objects leads natural speci cations 
instance program may predicates semantics manipulate objects occasionally symmetric relationship equality holds objects 
relationships encoded objects encodings may contrived cumbersome 
subsection rst explain predicates encoded molecules 
show minor extensions logic incorporate predicates directly syntax semantics 
predicates simulated di erent ways 
approach described adaptation 
encode ary predicate symbol weintroduce new class conveniently reuse symbol tuple new ary function symbol 
assert xn tuple xn write classical atoms form tn molecules form tuple tn arg argn tn easily seen oid template tuple tn value sense uniquely determined values attributes 
term tuple tn viewed oid object represents relationship tn relationship exists statement asserts relationship tn 
incorporate predicates directly extend notion language new set predicate symbols 
ifp ary predicate symbol tn id terms tn predicate molecule abbr molecule 
toavoid confusion id terms molecules assume predicates function symbols belong disjoint classical logic 
practical logic programming language restriction may necessary prolog advantages overloading symbols letting predicates function symbols time see section 
generalized molecular formula molecule old sense molecule including case equality predicate 
literal molecular formula negated molecular formula 
predicate symbols interpreted relations function part de nition structures ary predicate symbol 
structure hu variable assignment write ij tn tn 
diagonal interpretation equality predicate def fha ug 
obviously implies id terms ij 
term molecule include molecules 
deal signatures molecules studied 
properties structures fully integrate molecules logic formulae built kinds molecules introduced far 
truth formulas structures notion model de ned 
predicates serve useful purpose classical predicate calculus viewed subset logic 
practical implication classical logic programming thought special case programming logic 
additional ort classical logic programming theory adapted logic compatible existing systems 
section appendix rst step direction 
complimentary way incorporating predicates logic attach data molecules syntactically methods 
earlier integration scheme predicative methods increase expressive power language may lead natural representation 
instance point position inside shape viewed shorthand oint position inside oint shape oint position 
inside shape 
true 
representation suggests theory developed methods sections including behavioral inheritance section applicable predicative methods 
properties structures get better grip notions developed previous sections anumber simple important lemmas structures directly follow de nition de nitions sections 
express properties assertions logical entailment assertions true arbitrary structure simplicity assertion deals ground formulas immediate consequence de nitions easy proofs left exercise 
section shall see properties form basis logic inference system 
properties equality lemmas express usual properties equality 
express fact congruence relation 
re exivity ij symmetry ij ij transitivity ij ij ij substitution ij obtained replacing occurrence ij properties structures properties relationship states speci es partial order 
re exivity ij transitivity ij ij ij acyclicity ij ij ij subclass inclusion ij ij ij rst claims direct consequences fact relation domain partial order property follows interplay properties signature expressions properties symbol denotes 
rst rules symbol stands element ofu empty conjunction types 
type inheritance ij mthd qk ij ij mthd qk input restriction ij mthd qi qk ij qi ij mthd qk output relaxation ij mthd qk ij ij mthd qk rst claims follow directly anti monotonicity constraint mappings mthd mthd section variable assignment 
property follows upward closure mthd qk mthd qk 
structural inheritance typing properties signatures quite interesting merit comments 
rst type inheritance structural inheritance states structure propagates classes subclasses 
logic inheritance monotonic sense additional structure speci ed subclass added structure inherited superclass 
structure inherited di erent superclasses adds 
instance suppose class cl signature expressions method mthd 
signatures speci ed directly inherited cl adding means function invoked member class cl method mthd belongs intersection properties structures functional types determined signatures speci ed directly inherited cl illustrate consider example empl person person name string assistant student student drinks beer drives bargain assistant empl empl salary int drives car assistant drives oldt hing signature accumulated assistant sources follows assistant name string drinks beer drives bargain car salary integer words assistant inherits type name class person type salary employee drinking habits come class student 
structure attribute drives determined factors explicitly signature drives oldt hing signatures inherited classes student empl 
resulting signature states assistants drive old cars bought bargain prices 
note additive monotonic signature inheritance kind logic applicable cases 
fact object oriented systems allow overriding signatures certain circumstances 
instance example suppose student drives 
monotonic inheritance logic derive drives bargain 
expensive car kind rich student drive bargain inheritance drives bargain student leads unintended results 
appropriate action block inheritance drives bargain 
monotonic signature inheritance appropriate wide variety cases easier formalize signature overriding 
easy see monotonic inheritance blocked giving anti mappings onthe rst argument see section 
non monotonic signature inheritance achieved technique analogous simpler developed section 
properties signature expressions input restriction output relaxation say methods viewed functions usual properties far typing concerned 
instance input restriction says method mthd returns values class passed arguments certain types mthd return values class invoked arguments restricted types 
similarly output relaxation states mthd returns values class values belong superclass output relaxation may redundant property strictly speaking logically follow properties 
miscellaneous properties rst lemma category simply states scalar methods supposed return value set arguments 
second statement says object molecules assert properties trivially true structures 
claim raison etre name molecular formula 
property molecule true may spin bunch simpler formulas true formulas decomposed sense viewed subformulas original molecule 
skolemization clausal form ij scalm qk 
ij scalm qk 
ij ij scalm qk 
ij scalm qk 
ij trivial object molecules id term wehave ij constituent atoms molecule ij ij holds constituent atom constituent atoms mentioned property essentially indivisible formally de ned follows de ne constituent atoms arbitrary molecules just ground ones molecule assertion constituent atom object molecule separated constituent atoms signature expression mthd qk rn ing corresponding constituent atoms mthd qk mthd qk ri scalar data expression mthd qk 
corresponding constituent mthd qk set valued data expression mthd qk ft tmg 

constituent atoms mthd qk fg mthd qk tj property follows simple fact scalar invocations methods interpreted single valued functions 
claims straightforward de nition 
skolemization clausal form classical logic rst step developing resolution proof theory convert formulas prenex normal form 
skolemized formulas transformed equivalent clausal form 
easy verify usual de morgan laws hold formulas 
logic formula prenex normal form 
formula converted equivalent prenex normal form skolemized 
skolemization logic analogous classical case id terms identical terms predicate herbrand structures calculus quanti cation de ned similarly cases 
instance skolem normal form molecule fx yg 
fx new unary function symbol 
theorem cf 
skolem theorem formula skolemization 
unsatis able proof theorem virtually identical standard proof predicate calculus omitted 
assume formulas skolemized 
de morgan laws ensure formula conjunctive disjunctive normal form 
transform skolemized formula logically equivalent set clauses clause disjunction literals 
herbrand structures language sets function symbols set predicate symbols herbrand universe set ground id terms 
herbrand base ofl hb set ground molecules including molecules equality 
subset herbrand structure abbr structure ofl closed logical implication introduced section 
requirement closure convenient ground molecules may imply molecules non trivial way 
instance fa fa gj 
reminiscent situation predicate calculus equality sets ground atomic formulas may imply atomic formulas fa gj closure respect congruence similar reasons 
structures closed easy see closure properties similar section 
closure properties obtained properties section replacing statement form ij statement form molecule structure herbrand structure 
instance transitivity property ij ij ij de ne truth logical entailment structures shall sets clauses 
de nition satisfaction formulas structures structure 
ground molecule istrue denoted hj ground negative literal istrue hj ground clause ln istrue li true clause istrue ground instances true clause set clauses true wesay herbrand model model herbrand structures correspondence structures structures de nition structures indicates classical logic construct structures structures vice versa 
minor problem herbrand universe domain structures serve domain structure 
di erent domain elements represent di erent objects 
case herbrand universes 
instance john father mary belongs structure terms john father mary represent thesame object di erent elements herbrand universe 
phenomenon encountered classical logic equality cure problem known 
section remarks follows equality congruence relation herbrand universe 
construct domain structure factoring relation 
correspondence structures structures stated follows structure set clauses corresponding structure set ground molecules true structure 
conversely structure corresponding structure ih hu de ned follows 
domain isu quotient ofu induced equalities equivalence class 

ordering class membership relation determined assertions assert 

ary function symbol 

tk tk ary function symbol 


scalm obj tk unde ned obj scalm tk 



setm obj tk obj setm tk hg obj setm tk fg unde ned 
mappings de ned similarly inheritable data expressions non inheritable ones 

scalm obj tk obj scalm tk hg obj scalm tk unde ned 

setm obj tk obj setm tk hg obj setm tk unde ned 
observe similarity corresponding construction classical logic equality 
herbrand theorem 
fh tk tk hg 
di erence set 
setm obj tk unde ned empty 
unde ned contains atoms form obj setm tk 
obj setm tk fg 
contrast 
setm obj tk empty contain obj setm tk fg atoms form obj setm tk 
similar remarks apply 
easy see ih hu de ned structure 
correspondence immediately leads result proposition set clauses 
unsatis able model 
proof easy verify structure entailment hj takes place ih structure corresponds de ned earlier 
herbrand theorem classical logic set clauses unsatis able nite set ground instances clauses property commonly referred herbrand theorem 
logic herbrand theorem plays fundamental role 
establish theorem considering maximal nitely satis able sets similarly proof compactness theorem 
set ground clauses nitely satis able nite subset satis able 
nitely satis able set maximal set ground clauses containing nitely satis able 
useful properties nitely satis able sets stated 
lemma nitely satis able set ground clauses exists maximal nitely satis able set proof collection nitely satis able sets ground clauses xed contain set partially ordered set inclusion 
non empty 
furthermore growing chain upper bound chain contains nitely satis able elements nitely satis able 
zorn lemma maximal element 
lemma maximal nitely satis able set ground clauses 
ground molecule 
ii ground clause ln isint li proof part nitely satis able ftg tg 
contain maximal 
part ii proved similarly 
proof theory lemma maximal nitely satis able set ground clauses 
set ground molecules structure 
proof set closed maximal 
theorem cf 
herbrand theorem set clauses unsatis able nite subset ground instances clauses proof part assume nite subset ground clauses unsatis able 
unsatis able 
part proved contradiction 
denote set ground instances clauses suppose nite subsets satis able implies nitely satis able 
show satis able 
lemma extended maximal nitely satis able set leth set ground molecules structure lemma 
claim hj ground clause consider cases ground molecule 
de nition hj 
negative literal hj contains ground molecules lemma 
disjunction ground literals ln 
hj ln hj li de nition li cases ln ii lemma 
wehave shown satis es clause model proposition satis able 
herbrand theorem basis resolution proof theory classical logic 
section herbrand theorem logic develop similar result extends results 
just classical proof theory fundamental theory logic programming anticipate proof theory logic play similar role object oriented domain 
proof theory section describes sound complete proof theory logical entailment relation section 
theory consists twelve inference rules axiom 
rules resolution factoring paramodulation form core deductive system 
predicate calculus rules 
deductive system complete additional rules capturing properties types hierarchies needed 
large number inference rules logic compared predicate calculus stems rich semantics object oriented systems case logical system attempts adequately capture paradigm 
proof theory seen shortly rules quite similar may deal data expressions signatures molecules 
possible reduce number rules half increasing power resolution rule 
analogous classical logic factoring combined resolution 
prefer simple rules complex ones easier see rationale rule 
substitutions uni ers logic theory uni ers carries classical case 
notion needs adjustments accommodate sets syntactic features molecules 
substitutions language set 
substitution mapping fid terms identity outside nite set dom domain classical logic substitutions extend id fid follows tn tn substitution extended mapping molecules molecules distributing molecules components 
instance de ned mthd mthd 

similarly substitutions extend formulae distributing logical connectives quanti ers 
substitution ground dom variables 
substitution 
ground instance contains variables 
formula ground variables 
uni ers uni cation id terms molecules molecules di erent classical logic 
pair id terms molecules molecules 
substitution uni er 
uni er general written mgu uni er exists substitution object molecules requiring identity uni cation merely ask uni ers map molecules molecules 
de nition asymmetric uni cation object molecules andl bea pair object molecules object id say denoted constituent atom de ned section constituent 
substitution uni er note asymmetry 

proof theory instance 
uni able 

uni er way atom 
turned constituent atom 
di erent molecule 

uni able uni 
complete sets general uni ers de ning general uni ers object molecules requires 
consider set set fb cg 
intuitively uni ers called general 
clearly uni ers general de nition mgu works molecules assertions 
common approach situations consider complete sets general uni ers 
de nition general uni ers pair molecules pair uni ers wesay general denoted substitution uni er general abbr mgu uni er implies set general uni ers complete uni er just unique equivalence mgu classical case easily follows de nitions complete set uni ers unique equivalence 
algorithm computes complete set mgu appears appendix predicate calculus notion uni er works arbitrary number terms uni ed 
extension de nitions accommodate arbitrary number id terms molecules assertions obvious 
object molecules say substitution uni er ln li vl generalization notion mgu straightforward left exercise 
convenience de ne mgu tuples id terms 
pni uni able substitution pi qi uni er general written mgu hp pni hq uni er tuples substitution easy see mgu pni coincides mgu pn andf qn ary function symbol 
mgu pair tuples unique 
sequel denote general uni er molecule earlier object molecules may exist 
hand uni cation id terms assertions molecules symmetric operation 
talk uni cation expression convention simplify language 
simplify notation inference rules atoms molecules 
predicate calculus prior application inference rule clauses involved application standardized apart 
means variables set uni ers vice versa 
proof theory consistently renamed resulting clauses share 
clauses inference rule may instances clause identical variables involved 
core inference rules simplicity loss generality binary resolution considered 
inference rules symbols denote positive literals denote clauses denote id terms 
resolution pair clauses standardized apart 
mgu resolution rule follows derive notice object molecules resolution asymmetric may di erent mgu may exist 
classical case binary resolution called factoring rule seeks reduce number disjuncts clause 
factoring factoring rule forms depending polarity literals factored 
positive literals consider clause form positive literals 
uni able mgu rule follows derive case negative literals uni able mgu factoring rule derive clauses inferred factoring rules called factors note inference rules uni able rst case literal survives second rule account equality relation need paramodulation rule 
need focus speci occurrence id term expression literal id term standard practice write 
single occurrence replaced result denoted 
paramodulation consider pair clauses common variables 
id terms uni able mgu paramodulation rule says derive tnt proof theory resolution factoring paramodulation inference rules mgu tnt summary core inference rules axiom rules capture semantics subclass relationship interaction class membership 
re exivity re exivity axiom acyclicity clauses variables common 
suppose mgu qi id terms 
acyclicity rule follows derive note re exivity acyclicity imply re exivity equality 
axiom acyclicity derive transitivity standardized apart mgu theis transitivity rule derive subclass inclusion standardized apart mgu subclass inclusion rule says type inference rules derive signature expressions properties type inheritance input restriction output relaxation captured inference rules proof theory re exivity acyclicity transitivity subclass inclusion mgu hp qi hp mgu mgu summary inference rules type inheritance mthd qk pair clauses common variables suppose mgu thetype inheritance rule states derive mthd qk words inherits signature similar rule exists set valued methods 
mthd qk derive mthd qk input restriction mthd qi qk standardized apart 
suppose qi restriction rule states derive mthd qk replaces qi 
similar rule exists set valued methods 
noted inference rules stands id term 
output relaxation consider clauses mthd qk common variables suppose output relaxation rule states derive mthd qk similar rule applies set valued methods 
miscellaneous inference rules requirement scalar method return value built rule consider pair clauses share common variables mthd qk 
mthd proof theory type inheritance input restriction output relaxation mthd qk mgu mthd qk similarly set valued methods mthd qi qk mgu qi mthd qk similarly set valued methods mthd qk mgu mthd qk similarly set valued methods summary type inference rules suppose mgu uni es tuple id mthd tuple hp mthd ki 
rule says derive similar rule exists inheritable scalar expressions 
di erence 
replaced 
miscellaneous rule called merging information contained di erent object molecules 
pair molecules object id object molecule called merge set constituent atoms precisely union sets constituent atoms 
pair molecules merged di erent ways common set valued methods 
example terms merge scalm setm setm scalm setm setm scalm scalm setm setm setm setm scalm scalm setm setm setm fb cg distinguish certain kind merges uniqueness property 
call canonical merges 
invocation method consists method name arguments arrow specifying type invocation scalar set valued 
instance example scalm setm proof theory mthd qk 
mthd mgu hp mthd hp mthd ki similarly inheritable scalar expressions replaced 
merging elimination mgu merge summary miscellaneous inference rules setm 
distinct invocations 
canonical merge denoted merge merge contain repeated identical invocations set valued methods 
canonical merge 
clearly merge unique permutation atoms id terms ranges set valued methods 
merging consider pair standardized apart clauses object molecules 
mgu unifying oid parts denote canonical merge 
merging rule sanctions derivation derive id term molecule tautology wehave elimination rule elimination clause id term derive notice empty clause elimination rule derive clause 
remarks multitude inference rules natural concern cient evaluation procedure logic queries 
answer question believed positive major evaluation strategies developed deductive databases oldt magic sets applicable 
important point need inference rules run time 
instance proof theoretic terms purpose static type checking obviate need typing rules run time 
likewise compile time algorithm checking acyclicity get rid acyclicity rule run time 
practical system limit rule 
instance rule may generate run time warnings regarding possible inconsistencies detected scalar methods may inference 
proof theory soundness proof theory set clauses deduction clause nite sequence clauses dn dn dk member derived di possibly additional clause dj core type miscellaneous inference rules 
deduction empty clause deducible shall write theorem soundness logic deduction sj proof directly follows closure properties section form inference rules 
sample proof consider set clauses iv 
attr ii 
attr iii 
vi refute set sequence derivation steps denotes uni er corresponding step vii 
attr resolving ii viii 
input restriction iii ix 
attr resolving viii vii rule iv ix xi 
paramodulation ii xii 
resolving vi xi steps derivation self explanatory 
wewould topoint step ix asymmetric uni er uni es atom molecule viii 
completeness proof theory follow standard strategy proving completeness adapted classical logic 
herbrand theorem establish completeness ground case 
analogue lifting lemma shows ground refutations lifted nonground case 
lemma set ground literals 
unsatis able pv 
molecules assertions pv taken mean identical 
proof theory proof suppose contrary molecules pv show satis able 
consider set molecules def fpj molecule qg section shows structure corresponding structure ih hj applying construction section obtain structure closed deduction easy verify structure 
claim molecule mj direction follows soundness derivation rules 
direction assume mj consider cases assertion predicate assertion item construction section show mj 
predicate item show 
ii object molecule composed mj mj items section depending method expression scalar set valued data signature expression follows mj 
de nition molecules qn deducible qi fori canonical merge qn 
constituent atom constituent atom deducible qn deducible merge qn 
proves 
de nition positive literal 
mj negative literal molecule deducible assumption proof 

mj satis es literal model theorem completeness ground deduction set ground clauses unsatis able proof herbrand theorem assume nite 
suppose unsatis able 
show refutation technique due anderson bledsoe 
proof carried induction parameter excess number excess literals excess def number occurrences literals number clauses basis excess 
case number clauses equals number occurrences literals done clause literal 
case lemma molecules pv applying resolution rule obtain empty clause 
data modeling logic induction step excess 
case clause ins contains literal 
distinguish clause clauses write fcg assumed contains literal 
distributivity law fl unsatis able fc flg excess nand excess induction hypothesis ensures refutations separately 
empty clause 
denote deduction derives 
applying deductive wewould derive 
produced refuted done 
produced means denote derivation refutes flg exists inductive assumption 
follows apply follow steps shall refute proposition exists uni cation algorithm yields set mgu 
proof algorithm appendix correctness proved lemma 
lemma lifting lemma suppose clauses instances respectively 
derived derivation rules exists clause derivable factors resp single derivation step derivation step uses inference rule derived instance ofd 
proof consider derivation rule separately 
proof case similar corresponding proof predicate calculus notion substitution logics 
simple tedious details left exercise 
theorem completeness logic inference system set clauses unsatis able proof proof standard 
consider set ground instances ground case theorem refutation help lifting lemma refutation lifted refutation data modeling logic section de ne notions logic program database query illustrate logic number simple non trivial examples 
shall terms deductive database simply database logic program interchangeably 
rst cut say logic program logic abbr program arbitrary set formulae 
classical logic programming de nition general pragmatic semantic considerations call various restrictions form allowed formulas 
data modeling logic logic programs semantics popular class logic programs class horn programs 
horn program consists horn rules statements form head body head molecule body conjunction molecules 
clause implies variables implicitly universally quanti ed 
just classical theory logic programs easy show horn programs property 
intersection models horn program model model model respect set inclusion recall structures sets molecules 
analogy classical theory horn logic programs see de ne logic counterpart known operator horn program maps structures structures structure de ned smallest structure contains set head ln ground instance rule ln ig standard recipe easy prove xpoint oft coincides model ground molecule model pj 
horn programs large number applications expressive power limited 
expressiveness necessary relax restrictions form rules allow negated molecules body 
programs called generalized normal programs 
generalized programs elegant connection xpoints minimal models logical entailment holds 
fact programs may minimal models right choice obvious 
generally accepted semantics generalized logic program set canonic models subset set minimal models program 
alas cases agreement models deserve called canonic 
vast class programs called locally strati ed programs agreement reached shown program unique canonic model 
strati ed program unique canonic model goes name perfect model 
appendix develops perfect model semantics locally strati ed programs adaptation 
current needs shall assume canonic model exists program consideration details models matter discussion follows 
examples horn programs canonic model program coincides unique minimal model 
canonic models equality equality thorny issue logic programming easily cient treatment 
result logic programming systems commercial ones set may structure closure properties structure satisfy see section 
consider de nite rules rules disjunctions head 
data modeling logic called freeness axioms built 
practice boils restriction equality predicates heads program clauses 
clearly programming logic avoid problems 
furthermore equality plays prominent role object oriented programming classical logic programming 
logic instance equations generated implicitly program mention equality 
example consider simple program john father bob john father dad john father scalar attribute program entails bob dad john 
likewise car automobile automobile car entail car automobile class hierarchy acyclic 
apart usual computational problems associated equality predicate implicit generation equations may problematic practical point view 
multiply de ned scalar methods cycles class hierarchy may unintentional programmer mistake 
may desirable regard certain programs inconsistent dad john bob de ned explicitly 
course program obviously models inconsistency taken mean absence canonic models 
furthermore notion canonic models needs special adjustment equality programs generate implicit equality canonic models usual sense 
instance certainly minimal model consists atoms equation bob dad john plus tautological atoms 
canonic models take special care equality henceforth called equality restricted canonical models de ned 
rst step split program necessarily disjoint subsets rest equality de nition part determines equality theory second part rest speci es rest 
implicit assumption programmer specify part program determines intended equalities problem domain 
equality implied interpreted inconsistency 
simplicity shall assume equality de nition canonic model 
assume speci theory canonic models 
canonical model eq set non trivial equations 
equation non trivial identical 
de nition equality restricted canonical models canonical model assume unique 
say equality restricted canonical model set nontrivial equations coincides eq 
coming back example suppose bob dad john equality de ning part 
bob dad john hold canonic models program 
bob dad john logical consequence program equality restricted canonic model 
logic programming freeness axioms known clark equality theory 
data modeling logic queries query statement form molecule 
set answers respect program smallest set molecules contains instances canonic model closed 
rst condition obvious need comments 
second condition needed reason 
suppose database contains john children query john children 
instances query implied database john children bob john children sally 
john children instance query 
closure respect molecule part answer set logical consequence rst answers 
hand molecule answer set logically equivalent query john children fx yg 
closure respect eliminates anomalies easier talk query equivalence containment getting bogged minor syntactic di erences may occur essentially similar queries 
structure logic programs programs specify method supposed de ne method signatures organize objects class hierarchies 
program split disjoint subsets type information specify hierarchy declaration 
part program consists rules head literal assertion 
signature declaration 
part contains rules head literal object molecule built signature expressions 
object base de nition 
part consists rules head literals contain signatures expressions rules heads predicates object molecules built exclusively data expressions 
note classi cation considers rule heads 
legal rules subsets body literals de ned subsets 
fact shall see certain applications may need exibility 
informally object base de nition speci es method supposed 
object de nitions may explicit facts implicit speci ed deductive rules 
class hierarchy declarations name suggests organize objects classes hierarchies 
signature declarations specify types arguments method type output produce 
limit generality query reduced form adding appropriate rules 
data modeling logic examples hierarchies program canonic model hierarchy de ned program set atoms satis ed canonic model 
simple example class hierarchy declaration figures section 
hierarchy john student employee time phil employee student 
stated explicitly derived normal logical implication section 
phil student holds minimal model program section 
semantics determined model phil student considered valid statement class hierarchy 
idea class hierarchies important ingredient phenomenon known inclusion polymorphism 
instance stating students employees persons implies properties methods applicable persons automatically applicable employees students 
section properties name scalar ary method returns objects class string friends set valued attribute returns objects class person 
logic inclusion polymorphism built semantics 
manifested property discussed section called structural inheritance 
classes objects represented ground id terms 
suggests parametric families classes represented non ground id terms provides needed support parametric polymorphism 
example pair clauses de nes parametric polymorphic class list nil list cons list list list list list denotes parametric family classes form list ground id cons list constructor 
instance int denotes class integers list int class lists integers containing elements nil cons nil cons cons nil 
clause states subclass list subclass list 
note follow rest de nition stated explicitly property lists wanted course 
family list classes de ne parameterized types list manipulation methods 
logic hierarchy may depend data atoms occur rule heads 
classes de ned way analogous views relational databases 
instance car ear car car ype 
diesel ear year de nes family derived classes parameterized year class populated diesel cars appropriate year 
instance populated objects represent diesel cars 
data modeling logic previous example population classes determined properties objects 
desirable classes determined structure objects properties 
instance rule merchandise price de nes derived class merchandise consists objects attribute price applies 
note object fall class merchandise attribute price price merchandise set 
observe classes int sense extensions sets members speci ed indirectly logical rules 
hard see virtual classes akin views relational databases 
example concerns set theoretic lattice theoretic operators class hierarchy 
logic require classes form lattice pair classes tohave lowest superclass greatest subclass 
required union class class extension intersection resp union extensions ne class constructors accomplish tasks 
instance rules de ne andor union classes arguments note canonical model subclass superclass 
rules relate sets members classes involved classes 
relate classes write gsub gsub gsub constructor de nes lowest superclass de nes greatest subclass 
note instance gsub doesnot equal intersection extensions may strict subset 
words gsub construct lower upper bounds class hierarchy hierarchy class extensions 
combining rules gsub de ne constructors lower upper bounds hierarchies 
examples type declarations typing popular concept programming languages 
primitive form appears traditional database systems disguise schema declaration 
programming typing useful debugging aid means maintaining data integrity 
allows user de ne data modeling logic correct usage objects system detect ill typed data queries 
purpose type declarations impose type constraints arguments methods results returned methods 
instance empl salary year integer person birthdate year rst molecule states salary function empl object return object class integer argument class year 
second clause says birthdate attribute returns year person object 
section discusses typing constraints imposed logic 
section shall give examples type de nitions leaving semantic considerations till 
previous subsection seen example parametric family classes list 
signature family follows list rest list length int append list list signatures parametric declare attributes rst rest length method append polymorphic functions take arguments di erent type 
clause logic program variables universally quanti ed 
instance signature append says append invoked list int object argument class list int result object class list int 
argument say list real output object class list real 
invocations append conform signature list real append list real list real instance 
note output invocation class list int signature instance list int append list int list int cover invocation question method append invoked list reals integers 
examples object bases section illustrates expressive power logic number interesting non trivial examples include manipulation sets database schema analogical reasoning list processing 
cases shall omit signatures usually obvious discussed 
inheritance properties discussed separately data expressions subsection non inheritable variety 
set manipulation ability manipulate sets ease important litmus test object oriented data language 
subsection illustrates set manipulation expressing number popular operators nesting unnesting set comparison power set operator 
examples set intersection union operators 
nesting unnesting 
set related operations ability restructure objects nesting unnesting important ones 
specifying operations logic quite easy 
consider class objects structure attr attr data modeling logic way nest class say specify class nest attr signature nest attr attr attr class populated rule nested nest attr attr attr attr attr easy see semantics proof theory rule meaning nest attr populate class nest attr objects form nested attribute attr groups occur object class similarly consider class signature attr attr unnest class attribute attr de ne class unnest attr signature unnest attr attr attr identities objects class depend source objects class values returned attr unnested unnest attr attr attr 
attr attr rule says unnesting attr involves specifying objects form unnested object value attr unnested objects attributes attr attr scalar de ned atten structure original objects class set comparison 
grouping easy express logic computationally cient languages ldl col lps 
reason languages grouping second order operation requires strati cation 
refer reader complete discussion 
gain ciency price 
instance ldl set equality easy express ldl treats sets value entities particular ldl equality operator applicable sets 
contrast logic built equality operator sets set represented oid 
set equality containment de ned logical rules 
see suppose want result returned set valued attribute stands certain relation equals contains value attribute object 
de ning relationships logic akin comparing relations classical logic programming obj attr obj attr obj attr obj attr subset obj attr obj attr obj attr obj attr obj attr obj attr obj attr obj attr obj attr obj attr obj attr obj attr obj attr obj attr obj attr obj attr noted expressing set equality logic cumbersome ldl implementing equality operator ldl involves negation failure 
comparing sets logic ldl complexity 
data modeling logic data restructuring 
example adaptation 
issue representation data functions col grouping ldl 
consider relation graph tuples represent edges graph 
task re structure graph representing set nodes node points set descendants 
corresponding program simple nodes node descendants graph node oid chosen represent object describes rebuilt graph 
rule shows way nesting 
time nesting relation graph class 
reader familiar hilog may note rule general extend syntax logic include variables range predicate names rebuilt rel nodes node descendants rel node rel relation rel variable relation appropriately de ned class binary relations 
rule restructure binary relation passed parameter 
instance rebuilt nodes node descendants return rebuilt version 
example suppose method grade declared follows course grade student integer method appropriate administrator 
students denied access method class course exposes grades students 
hand students may see grades 
implement policy student access object represents achievements particular student 
de ne method grade student objects follows stud grade crs 
crs course grade stud 
way student say mary access grades posing queries mary grade vlsi 
access grades querying course object vlsi grade mary 
power set operator 
interesting problem try express power set operator operator takes arbitrary set computes subsets 
de ne class sets consists objects oid form add add 
intended meaning set object denoted add add add cg 
class sets de ned follows set add set set add add add add add add add rst equation asserts order adding elements sets immaterial equation says insertion elements sets idempotent operation 
data modeling logic de ne attribute self set object returns set members set powerset method de ned follows self fg add self set add self set self powerset set powerset 
add set self powerset set self rst clause says empty set member power set 
second rule says set obtained subset ofs adding element subset member power set querying database schema higher order syntax logic possible query manipulate certain meta information database schema 
schema querying discussed 
treatment general integrated logic relational object oriented language 
typically database queries speci ed respect xed known scheme 
experience shows assumption unrealistic ad hoc schema exploration may necessary 
means user apply intuitive exploratory search structure scheme database time query cf 

commercial databases support browsing extent 
purpose examples demonstrate logic provides unifying framework data schema exploration 
refer example section 
object class faculty pair rules collects attributes avalue class person attributes faculty person attributes faculty person faculty object rules de ne object attribute attributes 
intuitive reading attribute de ned object person value thenl belong result attributes object 
example section obtain bob mary 
deleting restriction person add attributes just person object 
case bob contain name age liation mary include name highestdegree liation 
interesting problem arises needs obtain objects object directly indirectly subobjects 
method nd returns set objects data modeling logic stu browser find stu stu browser find stu stu browser find stu browser find stu browser find stu browser find stu example section query browser find cs return set fcs cs bob 
representation analogies reasoning analogy active see survey 
apart semantic heuristic issues nding suitable languages specify analogies challenge 
subsection shows certain kinds analogies speci ed logic 
section de ned method applied host object type person returns set joint works persons involved 
method just instance general situation joint projects common hobbies commonalities may 
concept de ne generic method joint things joint nil joint cons obj rest obj joint rest rst rule describes things common empty list objects nil 
second rule says object common member list cons obj rest common object shares rest list 
second example describes similarities classes speci ed relationship cf 

instance say concept whale concept fish habitat pig person pig nose legs 
similarity expressed means ternary predicate 
instance pig pig cons legs cons nose nil third argument list attributes relate rst arguments 
de ne attr attr member attr member membership predicate de ned standard prolog program 
technique works specifying similarity ary methods 
represent similarity methods arbitrary arities need predicate arity rule form xn xn member list manipulation logic counterpart canonic textbook example nil append list cons append cons list append data modeling logic andn list objects append method applies list objects invoked list object argument list object host append returns concatenation parametric family list classes list signatures de ned earlier section section respectively 
relational algebra interpreter writing intelligible prolog interpreter relational algebra somewhat challenging task 
parse relational expression input 
example expression cond converted term form join union prod minus cond part job quite standard guides prolog 
expression parsed evaluated 
surprisingly evaluators joins cartesian products cumbersome may take couple pages prolog code 
main di culty fact arities expressions joined unknown compile time calls various nonlogical features arg functor 
shall see program relational join evaluator written just rules logic 
relations represented section relation class tuple objects 
pair relations join condition cond program de nes relation object represented oid form join cond 
join conditions assumed equalities represented lists pairs form cond cond 
instance cond cond nil encodes equi join condition 
rst deductive rule says oid tuples relations respectively new oid tuple nil join cartesian product 
second rule recursively computes oid tuple objects equi join 
tuple objects fully de ned speci ed values attributes 
third rule needed extract values source tuples new join nil new join cond rest new join rest new rename 
note rule attributes coming second relation join renamed order avoid name clashes 
relations common attributes interested natural joins equi joins renaming needed symbol rename rule dropped 
additionally natural joins join condition simpli ed list attributes list pairs 
dept attributes dname relation empl attributes dname ename query join dept empl cond dname dname nil return join relations attribute dname 
program general job joins classes just relations 
demonstrates di erence syntax prolog purely logical speci cation join entails sophisticated encoding relations results code hardly called declarative 
typed programs type errors typed programs type errors strongly typed language method invoked invocation allowed signatures speci ed method 
instance relational model attributes de ned particular relation hand attempting attribute de ned relation normally result error 
illustrate reproduce example section empl person empl salary year integer person birthdate year illegal empl object call methods birthdate salary 
similarly persons employees prohibit attribute salary altogether covered suitable signature class person 
words example signature person objects consists precisely method birthdate signature empl objects precisely methods salary birthdate 
methods scalar birthdate expects arguments salary needs year object 
unfortunately declarations ensure corresponding typing constraints hold canonic model connection missing signatures data expressions 
missing link provided form typing conditions de nition typed structures non inheritable data expressions structure 
suppose non inheritable data atom form ak signature atom form bk 
shall say covers wehave ai bi stand respectively 


shall say typed structure respect non inheritable data expressions conditions hold non inheritable data atom covered signature atom non inheritable data atom ak signature form bn 
note rst condition restriction domain de nition methods method invoked scalar set valued method 
plain terms says expression covered signature 
second condition says expression satisfy constraints imposed signatures cover expression 
comes typing inheritable expressions fully analogous non inheritable expressions despite semantic proof theoretic similarities 
inheritable expressions di erently 
consider highestdegree 
phd property class faculty de ned section 
expression supposed inherited members class faculty property members 
obey typing constraints imposed faculty 
idea formalized de nition 

invocation mean tuple form host object invocation 
args list arguments invocation 
typed programs type errors instructive compare expression monotonic non inheritable property 
expression applies members class faculty object faculty comply signatures speci ed faculty class 
de nition applies means signature de ned class contains faculty member covers invocation faculty 
de nition typed structures inheritable data expressions structure 
suppose inheritable data atom form ak signature atom form bk stand respectively 


shall say covers ai bi 
structure inheritable data expressions conditions hold inheritable data atom covered signature inheritable data atom ak signature form bn 
note essential di erence de nitions way coverage de ned 
de nition atom things holds 
contrast de nition ifc rst case class membership required second case subclassing 
words object non inheritable properties signatures matter speci ed classes object member 
contrast inheritable properties signatures count come classes object subclass 
de nition typed structures data expressions conditions de nitions called typing conditions 
structure typing conditions satis ed ifi typed respect inheritable non inheritable data expressions 
ready de ne notion typed programs de nition typed canonic models typed canonic model model typed structure canonic model usual sense 
de nition typed programs program typed type correct canonic model typed canonic model 
said ill typed 
plain words notion type correctness amounts typed structure data atoms comply relevant signatures signatures cover 
saying canonic models program typed tantamount program imply data atoms comply signatures implied program 
property adequacy 
class called introduced section 
determined theory canonic models theory perfect models described appendix typed programs type errors illustrate consider program bob faculty bob manager year manager empl mary faculty john manager int faculty empl mary boss bob empl boss manager salary year integer faculty boss faculty minimal model contain signature faculty inherited empl faculty boss faculty manager salary year integer obvious atoms empl john empl 
clearly model satis es typing conditions de nition typed structure 
typed 
suppose mary boss john mary boss bob 
type error atom mary boss john clashes typing empl boss faculty 
john known faculty john faculty holds minimal model likewise clause mary salary caused type error signature speci ed ary version method salary unary version salary signature faculty salary empl salary hold minimal model mary salary defeats rst typing condition de nition 
example consider ibm john liation 
ibm employee liation 
liation employee program typed minimal model typed model 
contrast rule replaced name string employee program cease typed attribute liation declared signature liation hold model class john liation 
ibm defeats rst typing requirement structures de nition 
modi ed program minimal model typed model program ill typed 
discussion de nition provides semantic grounds developing algorithms static type checking supplies verifying correctness 
provides uniform framework comparing various algorithms 
better see role type correctness schema things observe notion part logic se belongs meta theory logic 
typed programs type errors semantics proof theory depends particular typing de ned 
signatures independent de nition 
principle de nitions type correctness adapted conjunction logic 
need new notion type correctness logic arose existing theories su ciently general adequately type kinds programs adapted restricted classes programs 
semantically rich logical theory logic calls semantical model notion type correctness notion apply meaningful untyped programs compatible informal meaning usually associated correct typing product concrete ad hoc type veri cation procedure 
general notion missing literature 
hand de nition accommodates vast class programs weaker may 
noted earlier type correctness logic amounts saying typed programs guaranteed imply facts inconsistent signatures speci ed programs 
clearly minimum require correct logic program 
source type errors comes rules re body literal false signature incompatible literals body 
unfortunately kind errors captured de nition 
terminology means notion type correctness syntactically inadequate 
detailed discussion issues solutions 
notion typing general comes surprise undecidable check arbitrary program typed 
devise algorithms su cient various special classes programs 
algorithms topic research classical logic programs similarly de ned notion type correctness studied semantically algorithmically 
give reader better idea envisioned logic type system brie mention concept type inference 
originally notion type correctness applied strongly typed languages languages require programmer supply complete type speci cation program 
logic programming complete type speci cation seen burdensome requirement 
adapting ideas ml prolog mishra proposed type inference determining implied type predicate program inferred types troubleshooting 
program inferred type taken mean strongest type declaration typed 
strong typing may logic languages pure type inferencing extreme 
absence additional constraints type inferred program 
inferred type advice programmer may trigger alarm user feels inferred type match intuition 
believe suggested type inference combined type checking suitable compromise 
roughly idea type inference methods explicitly declared signatures 
types inferred methods user inspection 
inferred types wrong user may try nd error program 
hand methods explicit signatures type checked system semantics earlier section 
details approach sketched 
sense discussed see 
encapsulation encapsulation encapsulation major concept suite notions comprising object oriented paradigm 
encapsulation software engineering technique requires special designations method class 
methods designated public de ne methods classes 
contrast methods designated private class declared 
methods may exported speci classes classes 
idea encapsulation simple logical rendition 
miller suggested way represent modules logic programming intuitionistic embedded implication 
chen de nes modules second order objects data encapsulation inside modules represented existential quanti ers 
form approaches su ciently general logic 
interesting see approaches extended suitable method encapsulation object oriented logic 
mention jamil 
language notion encapsulation limited encapsulation part syntax semantics proof theory promising direction area 
contrast encapsulation mechanisms type correctness policies albeit somewhat elaborate usual 
approach quite general model wide variety encapsulation mechanisms 
advantage require extensions logic 
encapsulation treated type correctness discipline logical notion approach 
general outline encapsulation type correctness approach follows 
program clauses grouped modules 
module checked type correctness separately 
notion type correctness mind somewhat elaborate section 
main di erence set signatures determining type correctness module include signatures speci ed module signatures exported module modules 
noted object oriented systems encapsulation policies centered concept class module 
language classes virtual de ned logical clauses encapsulating class feasible 
modules exactly class de nition provide way encapsulate xed number classes current systems capable doing anyway 
traditionally object oriented systems idea encapsulation hiding implementation details approach erent respect 
combination modules serve useful purpose authorization control access objects 
achieved lines 
associate module user rule query user adds system automatically part user module 
simple scheme control unauthorized access user query constitute type error rejected method exported user module 
interesting feature achieve encapsulation purely logical means 
public signatures considered exported module 
encapsulation example illustrate ideas consider program consisting modules module person public year age int name string age 
person returns current year 
module attributes said public readily available modules 
module faculty public funding project int projects project liation dept project public title string principal faculty export accounting account account budget budget funding faculty projects budget 
total faculty projects account balance 
represents fragment module faculty 
methods account budget visible modules faculty module accounting exported 
particular case reason shielding account budget protection encapsulation assume project expenditures public domain 
total amount funds available public method funding accessible faculty objects 
inside module faculty balance project readily available public method balance class account de ned 
clause break encapsulation 
module budget public salaries int equipment int supplies int total int account private project project public expended int int balance int total budget salaries 
equipment supplies committed 
account expended balance 
account project 
budget total expended 
project account 
balance 
module person modules faculty accounting built speci class 
serve method de nitions authorization domains members faculty 
note faculty exports methods budget account module accounting legal invoke methods clauses accounting 
information accounts public module accounting information identifying projects associated account 
achieved making project private attribute class account 
example construct keywords private public export part logic meta annotations modify notion type correctness section meta logical concept 
section gives formal account oftype correctness programs module structure 
encapsulation modules type correctness example contains major elements treatment encapsulation 
key idea elaborate notion type correctness preclude illegal method invocations 
requires imposition module structure program speci ed meta logical annotations 
new notion type correctness builds notion introduced section reduces old notion entire program viewed big module 
de nition module structures program 
module structure consists decomposition set clauses collection named necessarily disjoint subsets called modules ii annotations private public module attached signature expression occurs head rule modules necessarily consist disjoint sets clauses module may sub module module 
note illustrated modules may represent authorization domains various classes users 
clauses queries introduced users assumed enter appropriate modules automatically 
de nition assume correspondence modules classes desired modules exactly class class nite set 
important mind modules ect canonical models notion type correctness ected see 
practical de nition module structures needs specialization 
thing immediately comes mind certain module structures contradictions 
instance method may declared public module private 
view module structure incoherent signature di erent annotations covers data atom 
situation module structure may incoherent method expression declared private separate modules 
allowed module import signature declaring private loose control exported 
turn prevent sensible policy access authorization 
purely software engineering arguments duplicate private declarations generally leads system designers adopting idea controlled export controlled import 
related restriction assume signature exported module module declared 
includes public declarations considered exported modules 
ideas formally captured conditions ii de nition 
formulate notion coherence need simple de nitions 
language program module structure module denote set clauses belong 
notation denote set annotated ground instances resp 
shall assume rule instantiation preserves annotations signature expressions occur heads rules instances signatures di erent annotations merged 
instance instantiating private public yields private public identical instances kept separately due di erence annotations 
encapsulation structure 
note annotations 
ground rule query active premises true model heads active rules true de nition coherent module structures module structure coherent respect canonic model data atom covered pair signatures occur heads active rules possible holds signatures annotated symbol ii rules belong module 
module structure coherent coherent respect canonic models de nition observe assumed cover atom signatures refer method number arguments 
program model module ofp denoted ij smallest structure contains atoms data atom atom atom occurs active rule signature atom publicly annotated signature occurring head active rule module annotated signature occurs head active rule signature explicitly exported module provided signature occurs head active rule 
words ij takes data atoms relevant module signature atoms derivable module exported modules 
instance consider program includes modules canonic model 
restriction module accounting contains data atoms occur active instances rules signatures declared accounting signatures modules faculty person 
de ne notion type correctness meta annotations follows de nition type correctness meta annotations program coherent module structure 
said type correct typed typed usual sense respect de nition module typed 
module typed lj typed model canonic model illustrate de nition consider module structure 
program typed signatures modules properly exported 
suppose ask query faculty age projects account covering de ned de nitions 
export export considered symbol purpose 
inheritance query posed module person violates encapsulation method account exported person 
expect modi ed module person typed 
caveat case 
see canonic model program 
restriction contain signature project account account appear head active rule local person exported module 
single faculty say fred say years old project blu active account query instance fred faculty age 
projects blu account active blu account 
data atom covered signature typed structure 
caveat notion type correctness model encapsulation drawback notion section purely semantic weaker desired 
instance suppose faculty object satis es query 
adding clause person leave program typed 
remain typed rst year old faculty active account inserted 
update program ill typed method account inside module person illegal 
emphasized problem arises weakness notion type correctness due treatment encapsulation 
small repertoire meta annotations su ces representing fairly complex encapsulation policies 
instance declaration export akin friend function declaration 
support delegation mechanism objectoriented languages 
useful encapsulation policies represented lines 
inheritance concept inheritance fundamental ai object oriented programming number researchers combining idea programming languages 
main aspects inheritance structural inheritance behavioral inheritance 
structural inheritance mechanism propagating method declarations superclasses subclasses 
hand behavioral inheritance propagates methods declared 
structural inheritance structural inheritance subject functional logic languages 
cardelli considers inheritance framework functional programming 
described type inference procedure sound respect denotational semantics system 
sound type inference systems functional languages discussed papers 
login life incorporate structural inheritance logic programming uni cation algorithm terms complex structures related signatures logic fundamentally di erent semantical point 
important di erences 
instance logic query answers sets atoms logically entailed program life query answers constraints turn queries true formulas 
inheritance contrast works logic full edged logic structural inheritance built semantics proof theory sound complete respect semantics 
structural inheritance discussed section 
behavioral inheritance main di culty dealing behavioral inheritance fact non monotonic due property called overriding phenomenon multiple inheritance 
overriding means explicit de nition method takes precedence de nition inherited superclass 
instance consider program elephant elephant color 
grey group mammal clyde color 
white clyde member class inherits color 
white class turns non inheritable data expression color white context clyde 
principle clyde inherited color 
grey class elephant 
clyde belongs speci class overriding inheritable property color 
white 
likewise inherit color 
grey elephant overriding property 
hand inherits group 
mammal inheritable property inherits non inheritable property group mammal 
note uses inheritable expressions indicate inheritance take place 
remind section inheritable expressions way expression inherited object say clyde class clyde member non inheritable property clyde play role class context 
contrast inheritable expression group 
mammal inherited class subclass relationship remains inheritable expression subclass passed subclasses members class 
illustrate rationale dichotomy inheritable non inheritable data expressions shall expand example section bob represented member faculty 
suppose information bob high school years years yale needs added database 
way accommodate new information create objects completely unrelated existing object bob 
disadvantage approach duplicate bob date birth gender better way turn new objects members class bob follows graduation 
bob faculty graduation bob faculty highestdegree 
phd bob bob birthdate gender 
male address 
newyork bob class faculty members class bob 
additionally second third clauses state bob graduated high school yale 
member faculty bob inherits highestdegree 
phd yielding new fact bob highestdegree 
phd 
notice property highestdegree 
phd inherited faculty turns non inheritable property inheritable properties passed class members inheritance non inheritable properties 
highestdegree 
phd longer propagated members class bob 
little sense attribute scholarly degree bob high school student 
likewise bob property address 
newyork inheritable likelihood bob di erent address high school certainly di erent address yale 
hand birthdate gender speci ed inheritable properties characteristics change time 
turning multiple inheritance phenomenon illustrated example commonly known nixon diamond nixon quaker quaker policy 
pacifist nixon republican republican policy 
hawk member classes quaker republican nixon inherit policy 
pacifist policy 
hawk 
properties say policy 
pacifist inherited nixon non inheritable property policy pacifist property longer inherited new state attribute policy de ned object nixon de nition overrides inheritance 
case inheritance leads indeterminate result derivation nixon policy pacifist policy hawk depending inheritance step done rst 
overriding multiple inheritance may cause non monotonic behavior 
relation logical entailment monotonic possible pj classical logic hand monotone pj implies non monotonic logics generally corresponding proof theories rarely complete 
see overriding may cause non monotonic behavior consider example logical entailment relation right thing inheritance 
denote program 
previously wehave argued intended inference pj clyde color 
white suppose add clyde color 
silver set assertions 
overriding property color 
white longer inferred clyde clyde color 
white 
multiple inheritance causes non monotonic behavior similar reasons 
consider part nixon diamond known nixon quaker 
case nixon inherit policy 
hawk class republican belongs 
full blown nixon diamond nixon quaker known hold nixon policy hawk longer certainty just possibilities 
nonmonotonic inheritance subject intensive research years 
main di erence approach works developing inheritance theory general purpose object oriented logical language 
contrast papers tend study inheritance general philosophical standpoint isolation logic programming issues 
mirrored languages 
languages propositional importantly distinguish properties attributes terminology classes 
second languages quite limited particular part general logic programming system 
important complex issue interaction inheritance ordinary logical deduction considered 
semantics inheritance developed section credulous variety means presence inheritance con icts willing accept multiple canonical models 
inheritance phenomenon interpreted di erent ways 
view canonical model viable possible world models chosen non deterministically interpretation facts belong intersection models trusted 
primary concern programming adopt view 
words inheritance con ict occurs due multiple inheritance canonic models selected non deterministically answer queries 
di erent setting non monotonic inheritance discussed 
approaches logical object class set rules represent knowledge embodied object resp class 
rules inherited objects placed lower hierarchy 
inheritance overwritten various criteria existence overriding rules higher priority rules due exception 
apart di erent setup behavioral inheritance takes place works fundamental di erence approach matter related works 
inherited set program clauses logic ground data expressions passed hierarchy 
approach exible 
shown section logic easily account inheritance clauses forms inheritance see section representation framework obvious 
informal approach integrate inheritance object oriented logic programming system logic issues addressed interaction inheritance ordinary logical deduction ii inheritance set valued properties iii dependence hierarchy prior inheritance steps iv negative literals rule bodies 
issues appear closely related fact ii iii hard problem 
di culty inheritance done program clause may active causing facts derived 
derivation may ect recipient object inheritance curiously source class inheritance 
illustrate consider program attr 
attr 
attr inherits attr 
atom attr rule activated 
leads derivation attr 
third rule 
question inheritance undone case 
reasoned attr fc dg holds object inherited attr fc dg entirety 
di erent decisions possible cases choice may matter taste 
choice undo inheritance situation time inherit newly derived fact attr 

reason primarily computational causes inheritance backtracking 
reason aesthetic leads uniform de nitions 
justi cation initial inheritance taken place attribute attr de ned time attr 
derived inheritance attr 
blocked 
illustrate complications arising due iii consider program attr 
attr attr 
attr example inherits attr deductive rules program activated derived 
words propelled middle inheritance path unusual fact attribute attr de ned avalue di erent means sitting inheritance path right start inheritance attr 
blocked inherited attr 
inheritance path initially argument apply 
argue subsequent derivation undermines basis inheritance step 
question inheritance step undone 
choice undo steps 
important reason computational 
semantic simplicity 
resulting model called inheritance canonic 
resulting semantics may bit procedural taste believe captures intuition 
development declarative semantics topic 
nutshell idea decompose inheritance step pair sub steps pure inheritance step new facts output structure may longer model original program derivation step turns result previous step model 
operations repeated inheritance done 
connection mention proposes semantics inheritance language derived logic 
particular allows inheritance deduction interact certain ways deal negation dynamically changing hierarchies 
approach fundamentally di erent way semantics de ned 
calls canonic model program model usual sense 
structure certain blocked rules satis ed 
aspect semantics analogous ordered logic discussed earlier 
contrast semantics traditional particular canonic models models usual sense 
fixpoint semantics non monotonic inheritance section limit attention case horn programs 
extension semantics programs negation bodies rules appendix structure ground id terms 
de ne result application method arguments invocation type 
inheritance follows 



jif fg ig 

jif fg ig observe 
empty fg false set contains special element denotes empty set possibly elements 
scalar invocations 
empty subset herbrand universe include 
note set may contain element scalar invocation equality operator 

similar observations apply 

special value matter convenience 
cl cl true method returns empty set cl wewould inheritance blocked 
case say inherited special domain value leads uniform de nitions 
de nition inheritance triggers structure 
consider pair cl obj cl ground id terms denotes relations 
shall say active inheritance just trigger brevity conditions hold obj cl intervening class mid mid cl mid obj obj mid mid cl method de ned inheritable property arguments cl 
fg unde ned invoked obj arguments 
precisely member cl case obj 
fg 
subclass relationship obj 
fg 
triggers set valued invocations methods de ned similarly replacing 


clear de nition inheritance trigger loaded gun poised re 
firing trigger leads derivation inheritance new facts derived classical deduction 
red trigger deactivated longer trigger resulting structure 
trigger form obj recipient impending inheritance step cl source 
note obj may class cl subclass cl intention ring trigger form cl inherit recipient object obj result application source class object cl capture inheritance idea introduce operator ring active trigger structure operator de ned follows cl 
note obj member cl inheritable properties cl passed obj properties 
hand obj subclass cl trigger form cl properties cl passed obj inheritable properties 
cl 
scalar invocations operator de ned similarly replacing 



easy see monotonic operator structures active trigger 
trigger red previously inactive program rules may applicable facts may derived ordinary classical deduction 
instance consider program attr 
attr attr minimal model consists attr 
firing attr adds new fact attr resulting structure longer model violates rule 
obtain model accommodates inherited fact apply rule derives attr 
note derivations performed ring trigger may ect recipient object trigger shown source class shown earlier 
ideas captured notion step inheritance 
de nition step inheritance transformation horn program trigger say obtained step inheritance written structure minimal models contain 
easy see horn intersection models contain unique 
note monotonic respect structures trigger monotonic structures 
ready notion canonical models presence inheritance 
heart notion call principle minimally necessary inheritance refers preference ordinary logical deduction deduction inheritance 
means inheritance ought attempted ordinary deduction longer possible 
principle minimally necessary inheritance embodied step inheritance operator 
model extends minimally possible inheritance 
de ne inheritance canonical models models obtained minimal model sequence extensions 
general sequence may trans nite 
note cl may contain special element 
obj read obj 
inheritance de nition canonical models inheritance structure 
shall denote structure possibly trans nite sequence models ordinal number ii active triggers iii non limit ordinal trigger iv limit ordinal horn program 
structure ofp inheritance canonical canonical represented minimal model shall see lemma canonical structures fact models furthermore operator de ned non deterministic sense di erent outcomes may result di erent choices triggers step iii 
program may canonic model di erent classical case horn program exactly canonic model coincides minimal model 
lemma horn program structure forp 
trigger denotes countably nite iteration model proof rst claims direct consequences de nitions 
claim follows fact de nition model union growing chain models universal set clauses 
general reaching canonical model de nition may take trans nite number iterations application introduce countably new triggers trigger orderings number iterations may reach ordinal 
fair orderings number iterations 
lemma fair trigger ordering trigger orderings iterative process de nition compute canonic model iterations 
proof fair trigger ordering de ned 
time new iteration performed operator newly introduced trigger assigned pair natural numbers iteration number unique index set new triggers countable 
order set jn kantor diagonalization process apply triggers order 
mn denote model obtained iii de nition applying labeled pair 
remains show mn model active triggers 
clearly model triggers suppose contrary 
triggers may deactivated way rule applications trigger rings 
case trigger simply skipped 
inheritance active construction assigned pair red ms shall illustrate notions step inheritance canonical model series examples 
examples derived nixon diamond example 
consider program nixon republican republican policy 
hawk states nixon belongs class republican generally hawks 
interesting models summarized object republican policy 
hawk policy 
hawk nixon policy hawk nixon republican nixon republican minimal model canonical 
see note republican policy trigger derived inheritance step 
easy verify canonical model program 
contained fact nixon policy pacifist inheritance taken place speci value pacifist overrides inheritance value hawk class republican means trigger minimal model fcg 
example illustrates multiple inheritance 
program models interest nixon republican republican policy 
hawk nixon quaker quaker policy 
pacifist object republican policy 
hawk policy 
hawk policy 
hawk quaker policy 
pacifist policy 
pacifist policy 
pacifist nixon policy hawk policy pacifist nixon republican nixon republican nixon republican nixon quaker nixon quaker nixon quaker republican policy quaker policy furthermore easy check canonical models model minimal canonical 
see obtained albeit ring di erent triggers 
triggers associated attribute policy recipient object nixon di erent source classes quaker republican 
reason inheritance steps obtained ring trigger separately combined ring trigger deactivates vice versa 
existence pair triggers properties formal explanation phenomenon multiple inheritance 
inheritance program illustrates ways inheritance interact deduction attr 
attr attr triggers hp attr hr attr observe applying activate rule 
minimum model models emerge ring triggers 
easy verify applying deactivates ring deactivate trigger re inheritance possible 
red leading model 
table shows relevant parts models canonical models 
object attr 
attr 
attr 
attr 
attr attr attr attr attr attr existence canonic models program may somewhat case trigger red ring deactivates yielding subset view inherent nondeterminism semantics unclear legitimate model 
example illustrates phenomenon inheritance dynamically changing hierarchies 
program attr 
attr attr 
attr 
attr minimum model ha attr active trigger firing causes derived 
turn activates trigger ha attr attr inheritance 
note inheritance attr 
attr de ned interesting aspect example act inheritance alters hierarchy inheritance heavily depends 
derivation fact attr 
inheritable property right middle path inherited attr 
issue discussed connection example earlier argued inheritance step undone despite changes hierarchy 
see dynamic situation taken care semantics consider table presents relevant parts models interest inheritance object attr 
attr 
attr 
attr 
attr 
attr 
attr 
attr 
attr 
attr 
attr 
attr 
attr attr attr attr attr attr attr models canonical obtained ring previously de ned triggers subtle point true model atom attr 
lurking path blocked inheritance attr 
semantics post blocking inheritance path invalidate earlier inheritance steps steps inheritance path 
strategies overriding behavioral inheritance section illustrate various ways logic inheritance model overriding strategies object oriented programming languages 
pointwise overriding suppose rules provide de nition method grade class instructor instructor grade stud vlsi instructor grade stud db 
default de nition method grades supposed provide way computing students grades di erent courses 
instructor say bob assuming bob instructor holds access method query form bob grade mary vlsi 
suppose instructor grade mary vlsi 
holds class instructor 
grade mary vlsi inherited bob yielding atom bob grade mary vlsi 

similar inheritance take place db courses 
suppose instructors allowed modify default grade computation de ning algorithms 
instance bob may de ne policy database course bob grade stud db 
provide explicit de nition grade object bob method invoked arguments stud db stud represents arbitrary student 
explicit de nition inheritance override default 
notice overriding taken place speci arguments default de nition arguments course vlsi 
property logic inheritance called pointwise overriding 
seen pointwise overriding provides great deal exibility letting user modify methods subdomains 
contrasted languages methods overwritten entirety overwritten 
called global overriding discussed 
global method overriding addition pointwise overriding easy arrange methods overwritten globally asin object oriented languages 
consider example bob instructor instructor stud crs 
instructor bob 
bob stud crs 
grade stud crs 
instructor 
stud crs 
example value name method grade computation 
method de ned third clause instructor object 
fourth clause speci es name grading method bob prefers 
method de ned object bob fth clause 
clause de nes grade method obtained attribute 
normally value inherited class instructor 
bob default value overwritten 
bound bob bound grade behave exactly 
mary instructor override attribute value clause inherited instructor 
bound mary method grade behave exactly 
shows global method overriding object oriented systems modeled logic pointwise overriding 
user controlled inheritance semantics inheritance described section non deterministic case inheritance con ict system re active triggers non deterministically 
cases user may want tohave control trigger ring 
approach common programming languages ei el programmer resolve inheritance con icts explicitly 
user de ned inheritance expressed logic follows 
resolve con ict say binary method mthd rst parameterize mthd de ning family methods mthd class class mthd class 
class mthd 
issues data modeling sup denote classes obj belongs method mthd applies 
obj inherit methods mthd sup mthd 
time con ict methods due parameterization 
obj invoke mthd superclass obj obj mthd sup analogous scope resolution operators object oriented languages asc 
issues data modeling logic wide range object oriented concepts represented directly semantics ideas left 
include complex values path expressions 
section propose ways model missing concepts rich arsenal built features available logic 
existing non existent objects easy verify pj holds id term program sense logic object exists long named 
hand databases object oriented systems common practice distinguish existing objects exist 
come existence empty rst created stark contrast logic trivial atoms ast time 
fortunately concept existence easily expressed property object designated attribute say exists 
instance exists true canonical model object said exist 

preprocessor modify clause away object molecule contains data expression augmented data expression exists true 
queries modi ed accordingly 
instance query changed exists true ensures existing objects retrieved 
action object creation adding property exists true involves transaction logic 
logic brie illustrated section see full treatment 
empty sets vs unde ned values semantics set valued methods distinguishes cases value method empty set cases method unde ned 
user may care distinction di erence important 
instance asserting john children fg means john children provided statements form john children 
contrast john children fg hold means unknown john children 
explained earlier method unde nedness analogous null values classical database theory 
problem user poses query john children issues data modeling gets bindings unclear john children attribute value 
verify user ask query john children fg 
clearly asking queries nd simple thing questionable practice highly desirable single query su cient 
easy way problem introduce special constant language axiom schemata fg fg technically speaking axioms ensure methods return empty sets empty set represented singleton set consists 
complex values works suggested pure object languages may burdensome identity certain objects immaterial program 
point section advocating predicates par objects recall predicates viewed objects uninteresting id 
convenient simple predicates allow object structures associated object id 
structures called complex values 
instance adapting example write ei name ei el tower address 
city paris street city paris street complex value representing address 
constructs distinct objects 
rationale user shoulder responsibility assigning id objects going accessed id anyway 
spirit may try adapt concept complex values logic follows id term value ii fval value provided vali value iii attr val value attr id term val value arrows 

may occur data expressions 
account complex values de nition data expressions section modi ed allow complex values just oid appear right hand side data expressions 
note item legal data expressions 
ii legal generalization set construct previously sets id terms allowed right hand side data expression 
question semantics values introduced way 
answer depends intended usage values 
taken literally terms assignable logical variables jeopardize proof theory logic 
variables values unify values 
atom attr uni able say obj attr fa cg issues data modeling unify cg 
words entails variables range sets rendering semantics second order sense 
fortunately experience object oriented database systems orion suggests complex values fairly restricted ways primarily weak entities entity relationship approach 
words second rate objects accessible objects 
leads values sake matter convenience user omit oid immaterial 
extent similar prolog don care variables represented underscores 
analogy permit don care object id 
instance re cast previous example follows ei name ei el tower address 
city paris street remains decide suitable semantics don care symbol 
scalm sn 
molecule don care symbol 
meaning encoding scalm sn valn scalm sn valn new ary function symbol speci cally chosen kind encoding 
provide interpretation don care symbols inside set construct setm rm meaning utility context clear 
introduce don care symbol occur inside sets 
need don care oid emphasized ilog special notation introduced purpose 
invention atom tn ilog semantically close molecule form tuple tn arg argn tn section tuple function symbol speci cally chosen represent invented objects class words invention atoms essentially value molecules logic 
style don care symbols useful modeling value objects relations meaningful attribute names 
instance represent supplier relation class suppl declared follows suppl name string parts part addr string de ne contents relation follows suppl name 
xyz assoc parts addr main st usa suppl name 
info parts know addr box oo 
ilog entirely value language way albeit indirect create multiple copies distinct objects contents 
issues data modeling symbol short hand notation intended relieve programmers tedium specifying oid explicitly suppl tuple xy assoc main st usa suppl tuple info box oo case 
clear semantics style objects di erent semantics style objects 
instance style objects entirely value id uniquely determined structure 
style object live independent life 
oid replaced simply oid uniquely determined values scalar attributes object making explicit mention id redundant 
contrast objects value 
identity object depends syntactic position occupied object inside molecule 
don care styles share cases explicit mention object identity redundant determined context object structure 
path expressions calculus object oriented languages syntactic constructs known path expressions 
instance select employees working cs departments path expression liation dname cs liation 
dname cs 
idea path expressions signi cantly extended build objectoriented extension sql 
syntax expression ix written liation dname cs 
cs plays role selector selects sequences objects liation 
dname cs true 
path expressions explicitly part logic syntax added syntactic sugar help reduce number variables programs notation familiar database users 
instance write empl name friends name bill liation dname cs query empl name friends name bill liation 
dname cs formal translation path expressions de ned logic left reader easy exercise example illustrates main ideas translation 
complete discussion path expressions logic 
primary classes immediate superclasses object oriented systems notion object primary class unique lowest class class hierarchy object belongs 
systems assume discrete class hierarchies class immediate superclasses properties strict superclass superclass class distinct objects incomparable class hierarchy 
assumption primary classes discrete class hierarchies simpli es inheritance type checking adequate data knowledge modeling 
issues data modeling represent relationships logic introduce pair atoms meaning primary class immediate superclass 
atoms model theoretically interpreted binary predicates 
addition usual inference rules logic need axioms state primary class membership special kind usual class membership immediate superclass superclass old sense axioms say immediate superclasses class incomparable class hierarchy object may primary class 
addition need ensure class membership consequence membership primary class done restricting programs atoms occur rule heads axioms 
ensures subclass relationship nite composition immediate subclass relation 
version control version control intrinsically object oriented feature associated object oriented databases importance versioning classical object oriented applications computer aided design 
conceptually version control distinct functionalities creation new versions navigation existing versions 
example outline possible schemes realizing versions logic 
suppose mary john working cooperatively computer chip denoted chip 
time mary modi cation version chip creates new object version mary 
similarly john constructs versions form version john 
versions chip form version pn version chip pi mary john 
mary john access current version chip name current chip 
turn aversion say version mary version john version john chip current assert equation form current chip version mary version john version john chip delete equation form previously asserted 
navigation versions quite easy 
instance access previous version chip query current chip version way organize versions logic de ne method version returns appropriate versions depending argument 
access version chip chip version arg version extensions logic arg suitable encoding desired version 
parameterize attributes version id suggested 
extensions logic section outline extensions logic 
included main text left help focus main issues 
extensions include sorted flogic multisets 
extensions discussed combining logic hilog modeling methods side ects 
sorted logic uses may necessary distinguish set valued scalar attributes syntactic level 
previously distinguish meta level notion type correctness 
times designate certain objects true individual objects objects play role class 
instance objects represent people mary may category 
cases user may prefer distinguish oid represent atomic values strings characters oid represent objects complex internal structure companies 
sorts separate things supposed domain old idea 
advantage having sorts addition types formedness respect sorts easy verify 
illustrate idea applied logic suppose wanted keep distinction classes individuals able manipulate kinds objects uniform way 
separate variables function symbols categories di erent name spaces 
instance represent individuals id terms outermost symbol name begins represent classes may id terms symbol id terms legal symbol letter represent object individual class 
symbols provide access kinds objects uniformly making possible talk sorts 
semantically sorts accommodated standard way 
domain structure consist disjoint parts interpret class objects individual objects 
variables symbol range subdomain classes variables restricted domain individuals 
variables allowed range entire domain wish allow class objects constructed class objects individual objects function symbol type 
suitable function symbol symbol type 

alternatively ect achieved introducing pair new unary predicates class individual class individual true precisely ground id terms outermost symbol starts respectively 
addition rules queries relativized follows individual id term body rule head body query query add individual conjunct obtaining head body individual resp query individual 
likewise id term represents class add class asa conjunct body rule query 
extensions logic restrict logical formulas 
instance mthd vn may insist vn represent classes signatures look mthd vn 
likewise assertions form cl cl cl wemay require cl cl classes 
aforementioned atomic values object ids introduced similar lines object id denote atomic values integers assigned distinct logical sort placed separate subdomain 
sorted language restricted ensure atomic values occur role oid object molecule role class assertion 
utility sorts limited distinguishing individuals values methods objects 
principle users may want de ne naming conventions 
case add new sort symbols logic harbor oid objects user believes worth distinguishing 
shall discuss language engineering issues scope 
multiset valued methods years multiset data type attracted attention database community 
set element nite count indicates number times element isa member set 
relations multisets de ned analogously standard relations sets 
instance mean member multiset mean times 
sub multiset relation holds member member times 
incorporation multisets logic fairly easy 
idea valued methods accept multisets values ectively turns multiset methods 
introduce counted id terms expressions form wheret usual id term natural number 
terms occur right 
set valued method expressions 
instance attr means triple member multiset returned attribute attr object old notation attr treated syntactic sugar attr semantics molecules multiset methods needs modi cations 
mappings return multisets 
second de nition iii molecular satisfaction set valued methods term containment understood sense multiset containment 
shall write ij setm rl fs smg sm counted id terms multiset 
setm rl exists contains sm proof theory need take uni cation 
instance molecule attr unify attr attr 
achieved properly de ning notion de nition 
precisely changing notion need adjust concept constituent atoms de ned section handle multisets properly 
postulate constituent atom molecule alternatively introduce multiset methods distinct set valued methods 
counted id term stands 
extensions logic atom lower membership count constituent instance attr attr constituent atoms attr yg 
rest de nitions need change 
hilog inspired extensions hilog higher order extension predicate calculus allows variables range names function predicate symbols 
furthermore names may complex structure particular usual rst order terms variables may appear predicate positions 
applications hilog described clear extending logic direction idea 
section seen example graph restructuring combination hilog logic may useful 
illustrate hilog example closure graph rom graph closure graph rom graph rom mid closure graph mid hilog program computes closure binary relation passed predicate constructor closure argument 
graph variable ranges predicates closure graph isa non ground term denotes parameterized family predicates 
binary predicate graph term closure graph binary predicate true toi precisely graph directed path connecting 
ideas underlying hilog applicable wide range logical languages reader familiar hilog di culty logic providing semantics hilog style terms 
needs done change interpretation id terms 
logic dynamic behavior logic cover important aspect object oriented languages dynamic behavior 
logic de ne methods querying object internal state logic provides means de ning methods change state 
new logical theory called transaction logic proposed 
formulated terms classical predicate logic ideas underlying transaction logic equally applicable logic extending dynamic behavior 
elaborate transaction logic example shows way transaction logic logic combined 
example illustrates style programming possible logic 
consider power set example section 
suppose member class set assume fact true self fa cg 
easy see power set de ned rules follows powerset add add add add add add add add add add add add oid inside braces denote di erent subsets set represented examination reader may discover oid duplicates contents entire set extensions logic represents 
instance molecule entailed power set program add add self fb cg add add represents cg members occur set returned attribute self oid 
duplication hardly desirable 
natural way invent new oid time new subset computed 
unfortunately natural way oid invention logic 
languages introduce oid invention basic mechanism de ning new objects 
iql syntax motivated datalog iql logic 
contrast transaction logic provides logical basis oid invention aspects database dynamics 
illustrate power sets de ned combined language logic transaction logic introduce predicate new id binds new constant time predicate evaluated 
novice transaction logic accept faith logical way fact ways achieve ect binding new value successful evaluation new id 
program constructs power sets duplicating elements sets oids 
algorithm resembles usual procedural way constructing power sets time bears strong similarity set program section 
building program rst de ne new relation sets added represents fact oid denotes set obtained set denoted adding element 
re ected rule assuming rule de nes attribute self self fx yg set set added self de ne powerset attribute start postulating empty set member power set set powerset set step de ne method transaction terminology transaction logic creates new subset set adding single element known subset set self powerset new id added ins powerset ins powerset rst rule says construct new subset set determined attribute powerset rst nd known subset say generate new id dynamic predicate new id mentioned earlier 
inserts added record fact obtained adding represented predicate added ins see 
represent computed subset insert fact newly computed element set actual insertions take place predicate added ins atom powerset ins evaluated 
rst insertion conditional depends validity post condition prunes away wrong choices choices computed old subsets observe de ne new set explicitly 
inserting added database attribute self gets new value rule 
anatomy logic symbol new logical connective logic called serial conjunction 
informally says 
important point method side ect 
process computation database state changes initial state added true values ands changes changed state addition powerset true 
logic executions 
rule says object represents old subset represents set objects set equal object powerset set equality ed predicate analogous predicate de ned earlier section 
de ne transaction actual job building power sets build powerset build powerset build powerset rst rule says new subset constructed keep going 
second rule termination condition 
says transaction build powerset succeeds longer possible construct new subset operator necessity operator transaction logic de ned 
anatomy logic having survived heavy de nitions get opportunity take retrospective look structure logic clarify various relationships exist di erent components 
careful examination reveal components independent semantically proof theoretically 
high level view internals logic depicted 
logic bag ideas classi ed main categories 
monotonic part logic sections section 
nonmonotonic part comprised number techniques canonic model semantics 
techniques described sections appendices non monotonic part logic monotonic part especially model theory 
proof theory section sound complete monotonic part 
non monotonic extensions possess complete proof theory making strong assumptions syntax sound evaluation strategies developed monotonic proof theory 
analogous classical logic logic programs strati ed negation complete proof theory 
main components monotonic department logics data expressions logic signatures 
independent seen inspecting semantics proof theory earlier 
glue provided typing semantic conditions section belong non monotonic part logic 
furthermore notice far monotonic logic concerned inheritable non inheritable data expressions completely independent fact properties virtually identical 
di erence seen comes typing non monotonic inheritance 
third component de ning sorts logic discussed section 
fourth component consists ideas borrowed hilog 
extends syntax logic alternatively de ne powerset method side ects writing build powerset null build powerset 
null oid designated represent methods return answers 
anatomy logic non monotonic part monotonic part canonic model semantics non monotonic inheritance semantics typing hilog related enhancements sub logic sorted logic sub logic data expressions signatures internal structure logic allowing variables complex terms appear positions predicate function symbols discussed section 
non monotonic part logic composed collection distinct ideas 
canonic model semantics programs equality discussed section appendix determine semantics non monotonic inheritance typing idea canonic model 
notion encapsulation belongs view simply elaborate policy type correctness 
note appendix de nes perfect models example canonic model semantics treatment inheritance typing largely independent speci theory canonic models 
independence various components logic viewed tool kit building customized deductive object oriented languages 
fact ner division logic 
instance semantics scalar methods independent set valued methods consider type methods separate tool kit 
likewise require oid classes methods constants method overloading controlled number ways sorts example 
tool kit structure logic extremely helpful lets address di erent aspects logic separation theoretically 
anatomy logic issue discuss relationship predicate calculus logic 
direction predicate calculus subset logic may 
turns logic encoded classical logic theorem mappings ff formed formulas predicate ff structures predicate mj pc structure formula pc entailment logic predicate calculus respectively 
proof sketch proof easy tedious left exercise 
main idea introduce new predicates encode meaning methods arity type invocation 
new predicate shall encode ary non inheritable scalar data expressions 
similarly shall encode non inheritable set valued data expressions 
split molecules constituent atoms represent atom appropriate tuple predicates 
addition shall need predicates sett encode scalar set valued signature expressions 
instance represented bob phil empl budget integer bob phil ype budget empl int class membership subclassing represented appropriate binary predicates 
complete encoding specify axioms achieve ect built features structures 
instance necessary write transitivity axioms subclassing type inheritance axioms semantic mapping de ned similar lines 
mappings de ned way verifying simple albeit lengthy task 
examples kind proofs 
idea object logics encoded classical predicate logic rst appeared embeddings sort known prolog community quite time 
instance provide syntactic sugar roughly amounts incorporation earlier called complex values 
similar transformation extend prolog object style syntax 
reader faith fact logic sense equivalent predicate calculus may nd comfort arguments 
semantics encoding theorem inadequate indirect provides insight user comes understanding meaning program 
goal provide logical rendition class languages collectively classi ed object oriented mapping theorem meaning logic misnomer 
merely algorithm sheds little light nature object oriented concepts logic designed model 
proof sketch theorem clear simple programs image easily understandable 
argument articulated concluding section summarized follows syntax programming language great importance shapes way programmers approach solve problems 
syntax direct semantics conducive programming 
third direct semantics logic suggests ways de ning proof theories tailored logic 
proof theories better basis implementation general purpose classical proof theory 
lastly theorem relates monotonic part logic classical logic 
mapping non monotonic components logic non monotonic theory predicate calculus lead useful logic 
relational approach theoretical grounds objectoriented approach databases dominated grass roots activity systems built accompanying theoretical progress 
result researchers felt area object oriented databases misguided lacking direction needing spokesman codd coerce researchers area common set terms de ning common goal hoping achieve 
contention problem lies deeper 
codd uential proposal relying large body knowledge classical predicate logic 
insight practical twist theoretical ideas mathematical logic led develop theory revolutionized entire database eld 
logical foundations object oriented databases parallel underlying relational theory lacking major factor uneasy feeling 
pioneering maier proposed framework de ning model theoretic semantics logic object oriented syntax 
encountered di culties approach subsequently abandoned promising direction 
turned di culties insurmountable theory repaired signi cantly extended 
proposed novel logic takes works reported new dimension logic capable representing virtually aspects known object oriented paradigm 
provided formal semantics logic showed naturally embodies notions complex objects inheritance methods types 
logic sound complete proof procedure computationally attractive renders suitable basis developing theory object oriented logic programming 
logic extensible logic combined proposed logics knowledge representation hilog transaction logic annotated predicate logic 
combinations sketched section 
extensibility puts logic center emerging uni ed logical formalism knowledge data representation 
acknowledgments indebted beeri detailed comments length rivals length 
improvements due suggestions rodney topor 
grateful alexandre lefebvre heinz pointing problem earlier version semantics inheritance 
wish serge abiteboul mira balaban joachim biskup chen stephen rick hull david maier sergio martin ken ross sagiv appendix perfect model semantics logic moshe vardi david warren gio wiederhold discussions helped shape 
goes anonymous referees constructive critique 
appendix perfect model semantics logic adapt various semantics negation logic general principle method names contexts predicates classical setting 
perfect model semantics means strati cation ensured respect method names program wants strati ed despite recursion negation object note ground terms means set value attribute mean empty unde ned 
contrast consider rule program adapted os pos os pos pos pos locally strati ed logic recursion negation attribute os pos pos instantiated constant say os 
process adapting perfect models logic involved discussion may suggest 
solution steps 
apply general principle directly come preliminary de nition 
point problems de nition show corrected 
preliminary de nitions language general program 
de ne dependency graph follows 
denote set ground instances rules nodes ofd correspond ground atoms herbrand base hb 
positive arc connects pair nodes rule inp constituent atoms respectively 
arc rule form possible pair nodes connected positive negative arc time 
shall write atoms ifd directed path write negative path arcs path negative 
general partial orders 
partial order cycles contain negative edges negative cycles 
de nition locally strati ed programs preliminary program strati ed relation founded ifd nite decreasing chains form 
de nition implies locally strati ed programs irre exive asymmetric nite chain 
appendix perfect model semantics logic similarly de nition implies negative cycles locally strati ed 
introduce preference quasi order structures follows structure preferable denoted pl atom atom 
de nition perfect models preliminary locally strati ed program associated quasi order models 
models minimal respect called perfect models general quasi order partial order 
shown locally strati ed partial order models classical theory shown locally strati ed program unique perfect model 
provide direct characterization perfect models need de ne program strati cation 
extend pre orders atoms rules conveniently done help rule dependency graph dr information plain dependency graph 
graph needed appendix rule dependency graph dr graph nodes rules ground instances rules arc exists constituent atom molecule head occurs molecule body arc exists constituent atom molecule head occurs negatively witha sign molecule body pre orders de ned way de ned ofd path resp negative path 
locally strati ed program partition rules accordance priority relations 
partitions satisfy called strati cations 
classical theory shown perfect model computed ring rules strati cation order 
generalized step inference operator de ned follows head ln ln ln rule ln ln ln ig perfect model computed follows 



mi classical case result iteration independent strati cation 
appendix perfect model semantics logic revised de nitions unfortunately straightforward adaptation classical perfect models logic inadequate 
problem arises due equality predicate 
perfect models introduced assuming called freeness axioms equality postulate ground terms equal identical 
axioms perfect models provide natural semantics simple locally strati ed programs 
instance consider pair programs unique perfect model fp bg andm fp unique perfect model 
models obtained de nitions simple minded way doing minimization ordinary predicate 
trouble models supported rule 
fact programs derived assuming true 
classical logic programming equality problem side stepped rule heads 
alas shortcut appropriate logic equality may derivable mentioned explicitly 
instance fa attr attr gj di culty comes closure properties inherent programs 
instance signature inheritance corresponds deductive rule 
args 
args rule lead situation similar recursive cycles negation 
illustrate problem consider program attr attr cause problems 
obtain negative cycle going attr top toa attr tob attr 
fortunately simple way semantic works classical logic programs equality 
idea account equality built constructs logic augmenting additional axioms 
new axioms called closure axioms corresponds inference rule section 
inference rules lead new axioms rules resolution factorization merging elimination 
axioms paramodulation 
arity predicate symbol including axioms stands arrow types yn yi yn yi similar rules needed 
notice paramodulation accounts transitivity symmetry equality predicate 
additionally account paramodulation subterms axiom schema needed xn xi xn xi appendix perfect model semantics logic function symbol language 
note similar axioms needed classical case de ne perfect models presence equality 
axioms hierarchy 
transitivity acyclicity subclass inclusion axioms typing 
arity standing type inheritance ai ai input restriction output relaxation axioms 
arity standing 
de nition augmented programs program augmentation union relevant ground instances closure axioms 
ground instance closure axiom relevant atoms premises relevant 
atom relevant occurs head rule recursively head axiom instance relevance established previously 
rectify earlier de nitions considering order augmented programs original programs 
de nition locally strati ed programs program strati ed relation founded 
de nition perfect models models minimal respect pa called perfect models returning programs see locally strati ed respect de nition locally strati ed respect preliminary de nition 
consider instance paramodulation axiom atoms premise relevant 
negative cycle ind goes top back top ind cycle goes toa back 
similar cycles exist rule dependency graphs programs 
appendix perfect models presence inheritance similarly show negative cycle 
consider instance type inheritance axiom attr attr rule belongs augmentation premises relevant 
dl negative cycle attr attr back tob attr 
proposition locally strati ed program unique perfect model 
proof sketch proof similar 
albeit indirect proof obtained theorem 
translation classical logic 
prove result show founded order ground atoms usual de nition local strati cation 
show notation theorem maps minimal models minimal models 
appendix perfect models presence inheritance appendix extend results section appendix de ning perfect model semantics negation inheritance working 
principle minimally necessary inheritance section continue guide 
needs extended semantics general logic programs relies making negative assumptions essential ways 
negative data derived jumping nonclassical inference rule 
avoid contradiction negative override inheritance just positive facts 
practically means negative reached earlier thrown de nitions section possible derive positive inheritance 
inheritance blocked positive con ict negative 
principle realized modifying iterative procedure computing canonic model take account subtleties deriving inherited negative facts 
alternative declarative characterization canonic model terms priority relation appendix strati cation inheritance extend rule dependency graph appendix include new type arcs 
resulting extended rule dependency graph symbolizes inheritance nodes dr includes positive negative arcs 
addition inheritance arcs exist cases 
form rule form stands form inheritance arcs inheritance negative path just inheritance path brevity ind path contains negative arc inheritance arc negative path path contains negative arc inheritance arcs negative positive arcs 
negative path inheritance path opposite true 
appendix perfect models presence inheritance new rule dependency graph extend relations exist clauses de ned appendix 
new orderings lead modi cation notion strati cation directly ects program de ned 
pair rules shall write negative path ind goes inheritance path part cycle ind path ind negative path goes take inheritance paths consideration rules comparable note new preorders extend old ones implies implies strati ed programs de ned similarly de nition extended ordering explained appendix really augmented programs equality predicate accounted 
de nition local strati cation inheritance program strati ed inheritance locally strati ed founded relation pa note due strati ed programs strati ed earlier sense 
strati ed programs may strati ed 
see consider program cl attr 
attr cl clearly program locally strati ed de nition 
show strati ed rt denote instance rule replaced term example follows cl attr 
attr easy see pa inheritance arc rf path goes way 
nite chain pa rf pa rf pa ra shows pa founded locally strati ed inheritance 
note inheritance cycles ones go negative arcs necessarily turn programs ed ones 
seen examples appendix 
perfect models de ned mentioned earlier need modify de nition triggers protect negative assumptions computation perfect models 
need modify de nitions order assumptions explicit 
structure set ground atoms 
new style trigger set negative assumptions trigger sense de nition empty ring contradict negative assumptions appendix perfect models presence inheritance appendix shall deal new style triggers kind triggers operators de ned section 
ready de ne perfect models presence inheritance perfect models 
de nition combines operator modi ed new style triggers iterative procedure appendix locally strati ed program strati cation de ned 
perfect models de ned product iteration triggers subject negative assumptions triggers subject negative assumptions triggers subject negative assumptions 
operator non deterministic may perfect model 
negative assumptions constructed follows 
rst set empty 
de ne flj body mij body occurs words negative assumptions stage consist assumptions previously plus atoms occur negatively bodies active rules examples illustrate concepts number examples 
rst program somewhat outdated ideology illustrating technical idea 
says managers paid employees paid poorly manager empl empl salary 
low manager salary 
low arc 
manager employee computed rst stratum 
second stratum negative assumption salary 
low leads derivation employee salary 
low stratum 
point de nition manager inherit salary 
low 
employee salary new style trigger due negative assumption inheritance take place 
program bit involved political message writing time attr 
attr attr attr attr appendix unification algorithm molecules 
rst inherits attr 
blocks ring 
result attr derived attr derived second stratum 
involved example consider attr attr attr 
attr 
note involved inheritance cycle extended rule ordering graph 
program ed 
incomparable respect founded 
example computed rst 
apply generalized step inference operator compute second stratum 
negative assumptions fp attr attr enables derivation attr 
andd attr 

note de nition sanctions inheritance triggers ha attr attr new style triggers con ict negative assumptions 
example attempt capture phenomenon academic world theoretician professor joe professor theoretician funding 
low theoretician programmer 
travels funding low thing note instantiated joe applied 
computing facts jump negative programmer 
derive joe theoretician rule 
activates trigger theoretician funding sanctions inheritance joe funding 
low 
newly inferred atom prevents rule ring computation terminates 
appendix uni cation algorithm molecules appendix presents algorithm nding complete set mgu pair molecules 
remind section complete sets mgu equivalent su ces nd just set 
recall molecule represented conjunction constituent atoms 
pair molecules mgu general substitution turns constituent atom constituent atom 
di erent correspondences constituent atoms may lead di erent mgu 
nd complete set mgu take correspondences account 
atom forms method qk denotes types arrows allowed method expressions 
ii method qk fg denotes 

iii method qk denotes 
appendix unification algorithm molecules input molecules 
output complete set mgu 
id uni able unify id id 
uni able 

form degenerated molecule mgu 

fg 

mapping map hold potential mgu atom atoms 
unify tuples method arg argn val method arg argn val 
val treated constant uni cation purposes unify unify discard jump inner select fg 
endfor endfor 
return complete set mgu 
computing complete set mgu notation uni cation algorithm id method method qi val form form ii iii addition molecule atoms denote set atoms molecules map denotes collection atoms 
atoms preserve method arities type method expression type arrow expressions 
noted section mgu pair tuples id terms hp pni coincides mgu terms pn andf qn arbitrary ary function symbol 
standard uni cation procedure unify tuples id terms 
pair tuples id terms unify denote procedure returns mgu exists 
lemma algorithm correctly nds complete set mgu 
proof clearly elements mgu sowe show complete 
consider uni er 
de nition mapping map atoms atoms maps atoms appropriate atom 
clearly substitution constructed inner loop step algorithm general uni er maps atoms atoms 
instance summarizing shown element mgu uni er instance element complete set mgu 
hard see uni cation problem molecules polynomial time isomorphic called rst order subsumption problem isknown np complete 
surprising worst case complexity algorithm exponential worst case size set uni ers 
complexity due factors 
uni cation sets problem speci logic 
language allows sets essential way put exponential worst case complexity set uni cation 

permutation methods inside molecules methods may denoted nonground id terms di erent ways 
instance unifying 
andp method denoted match similarly added complexity expected due higher order syntax logic 
key factor estimating complexity uni cation practical cases number atoms comprising molecule bodies rules 
number atoms number uni ers bounded resolve rules data signature molecules need unify parameter denotes number atoms crucial 
experience programs examples show number usually small 
believe combinatorial explosion happen practice 
abiteboul beeri 
power languages manipulation complex objects 
technical report rapport de recherche inria 
appear tods 
abiteboul grumbach 
col logic language complex objects 
workshop database programming languages pages france september 
abiteboul kanellakis 
object identity query language primitive 
acm sigmod conference management data pages 
abiteboul lausen waller 
methods rules 
acm sigmod conference management data pages may 
order subsumption problem nding general substitution turns set rst order terms subset set 
abiteboul vianu 
procedural declarative database update languages 
acm sigact sigmod sigart symposium principles database systems pods pages 
kaci 
algebraic semantics approach ective resolution type equations 
theoretical computer science 
kaci nasr 
login logic programming language built inheritance 
journal logic programming 
kaci podelski 
meaning life 
journal logic programming august 
anderson bledsoe 
linear format resolution merging new technique establishing completeness 
journal acm 
atkinson bancilhon dewitt dittrich maier zdonik :10.1.1.44.5524
object oriented database system manifesto 
intl 
conference object oriented databases dood pages 
balaban 
generalized concept formalism frames logic representation model 
proceedings canadian arti cial intelligence conference pages 
balaban 
relational object oriented system knowledge representation 
intl 
symposium methodologies intelligent systems ismis pages 
bancilhon 
object oriented database systems 
acm sigact sigmod principles database systems pods pages 
bancilhon 
calculus complex objects 
journal computer system sciences april 
banerjee kim kim 
queries object oriented databases 
proc 
th intl 
conf 
data engineering los angeles ca february 
beeri 
formal models object oriented databases 
intl 
conference object oriented databases dood pages 
elsevier science publ 
beeri naqvi shmueli tsur 
sets negation logic database language ldl 
technical report mcc 
beeri nasr tsur 
embedding terms horn clause logic language 
third international conference data knowledge bases improving usability responsiveness pages 
morgan kaufmann 
beeri ramakrishnan 
power magic 
journal logic programming april 
blair subrahmanian 
paraconsistent logic programming 
theoretical computer science 
bonner kifer 
transaction logic programming logic declarative procedural knowledge 
technical report csri university april 
revised february 
available csri technical reports report ps anonymous ftp csri toronto edu 
bonner kifer 
transaction logic programming 
intl 
conference programming iclp budapest hungary june 
bonner kifer 
overview transaction logic 
theoretical computer science october 
brass 
semantics inheritance logical object speci cations 
intl 
conference object oriented databases dood pages december 
brewka 
logic inheritance frame systems 
intl 
joint conference onarti cial intelligence ijcai pages 
jamil 
logic encapsulation object oriented languages 
proceedings th international symposium programming language implementation logic programming lecture notes computer science pages madrid spain september 
springer verlag 
buneman frankel 
functional query language 
acm sigmod conference management data pages 
buneman ohori 
powerdomains generalize relational databases 
theoretical computer science 
cardelli 
semantics multiple inheritance 
information computation february 
carey dewitt 
data model query language exodus 
acm sigmod conference management data 
chang lee 
symbolic logic mechanical theorem proving 
academic press 
chen 
theory modules second order logic 
ieee symposium logic programming slp pages september 
chen kifer 
polymorphic types higher order logic programming 
technical report department computer science suny stony brook december 
chen kifer warren 
hilog foundation higher order logic programming 
journal logic programming february 
chen warren 
logic complex objects 
acm sigact sigmod sigart symposium principles database systems pods pages march 
clocksin mellish 
programming prolog 
springer verlag 
cook hill canning 
inheritance subtyping 
acm symposium principles programming languages popl pages 
dietrich 
extension tables memo relations logic programming 
ieee symposium logic programming slp pages 
ieee september 
topor 
declarative procedural semantics deductive object oriented systems 
journal intelligent information systems february 
enderton 
mathematical 
academic press 
etherington reiter 
inheritance hierarchies exceptions 
national conference onarti cial intelligence aaai pages washington 
fikes kehler 
role frame representation reasoning 
communications acm 
lausen access objects path expressions rules 
intl 
conference onvery large data bases vldb pages santiago chile 
garey johnson 
computers intractability guide theory np completeness 
freeman san francisco ca 
ge ner verma 
inheritance chaining defeat 
intl 
symposium methodologies intelligent systems ismis pages 
gelfond lifschitz 
stable model semantics logic programming 
logic programming proceedings fifth conference pages 
hall 
computational approaches analogical reasoning comparative study 
arti cial intelligence 
hayes 
logic frames 
editor frame conception text understanding pages 
walter de gruyter 
hill topor 
semantics typed logic programs 
pfenning editor types logic programming pages 
mit press 
horty thomason touretzky 
theory inheritance nonmonotonic semantic nets 
national conference onarti cial intelligence aaai pages 
hull yoshikawa 
ilog declarative creation manipulation object identi ers 
intl 
conference onvery large data bases vldb pages brisbane australia 
sergot 
evolution objects logic programming framework 
proceedings intl 
conference fifth generation computer systems pages tokyo japan june 
copeland 
object identity 
inproceedings international conference object oriented programming systems languages oopsla pages 
kifer kim sagiv 
querying object oriented databases 
acm sigmod conference management data pages june 
kifer lausen 
logic higher order language reasoning objects inheritance schema 
acm sigmod conference management data pages 
kifer 
logic reasoning inconsistency 
journal automated reasoning november 
kifer subrahmanian 
theory generalized annotated logic programming applications 
journal logic programming april 
kifer wu 
logic object oriented logic programming maier logic revisited 
acm sigact sigmod sigart symposium principles database systems pods pages march 
kifer wu 
rst order theory types polymorphism logic programming 
intl 
symposium logic computer science lics pages amsterdam netherlands july 
expanded version tr title department computer science university brook july 
kifer wu 
logic programming complex objects 
journal computer system sciences august 
kim banerjee 
chou woelk 
composite object support object oriented database system 
proceedings international conference object oriented programming systems languages oopsla 
kolaitis papadimitriou 
negation xpoint 
acm sigact sigmod sigart symposium principles database systems pods pages 
krishnamurthy naqvi 
real horn clause language 
intl 
conference onvery large data bases vldb 
kifer warren 
circumscriptive semantics inheritance networks 
intl 
intelligent systems ismis pages 
kifer warren 
declarative semantics inheritance networks 
intl 
joint conference onarti cial intelligence ijcai pages 
kuper vardi 
new approach database logic 
acm sigact sigmod sigart symposium principles database systems pods 
kuper 
extension lps arbitrary sets 
technical report ibm yorktown heights 
kuper 
logic programming sets 
journal computer system sciences august 
vermeir 
extending logic programming 
acm sigmod conference management data pages june 
vermeir 
xpoint semantics ordered logic 
journal logic computation 
richard 
database programming language 
intl 
conference onvery large data bases vldb august 
lloyd 
foundations logic programming second edition 
springer verlag 
maier 
logic objects 
workshop foundations deductive databases logic programming pages washington august 
maier 
database languages bad idea position 
proc 
workshop database programming languages france september 
maier 
isn object oriented data model 
technical report oregon graduate center may 
mccabe 
logic objects 
prentice hall international london england 
mccarthy 
order theories individual concepts propositions 
hayes michie editors machine volume pages 
edinburgh university press 
meyer 
object oriented software construction 
prentice hall englewood cli nj 
miller 
logical analysis modules logic programming 
journal logic programming 
minsky 
framework representing knowledge 
haugeland editor mind design pages 
mit press cambridge ma 
mishra 
theory types prolog 
ieee symposium logic programming slp pages 
mitchell 
typed foundation method specialization inheritance 
acm symposium principles programming languages popl pages 
morris naughton ullman van gelder 

window nail 
ieee database engineering 
motro 
baroque browser relational databases 
acm transactions ce information systems 
naqvi tsur 
language data knowledge bases 
computer science press 
neuhold stonebraker 
directions dbms research laguna beech report 
sigmod record march 
ross 
glue nail deductive database system 
acm sigmod conference management data pages 
przymusinska gelfond 
inheritance hierarchies autoepistemic logic 
intl 
symposium methodologies intelligent systems ismis 
przymusinski 
declarative semantics deductive databases logic programs 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann los altos ca 
przymusinski 
logic program natural strati cation iterated xed point model 
acm sigact sigmod sigart symposium principles database systems pods pages 
ramakrishnan 
magic templates approach logic programs 
ieee symposium logic programming slp pages 
ross 
relations relation names arguments algebra calculus 
acm sigact sigmod sigart symposium principles database systems pods pages may 
roth korth batory 
sql nf query language nf relational databases 
information systems 
schmidt 
high level language constructs data type relation 
acm transactions database systems september 
shipman 
functional data model data language 
acm transactions database systems pages 
ste bobrow 
object oriented programming themes variations 
ai magazine pages january 
stroustrup 
programming language 
addison wesley reading ma 
tamaki sato 
old resolution tabulation 
intl 
programming iclp pages 
kifer 
theory nonmonotonic inheritance annotated logic 
arti cial intelligence march 
touretzky 
mathematics inheritance 
morgan kaufmann los altos ca 
touretzky horty thomason 
clash intuitions current state nonmonotonic multiple inheritance systems 
intl 
joint conference onarti cial intelligence ijcai pages 
ullman 
database theory past 
acm sigact sigmod principles database systems pods pages 
ullman 
principles database knowledge base systems volume 
computer science press 
van gelder 
alternating xpoint logic programs negation 
acm sigact sigmod sigart symposium principles database systems pods pages 
van gelder ross schlipf 
founded semantics general logic programs 
journal acm 
warren 
memoing logic programming 
communications acm march 
wegner 
object oriented classi cation paradigm 
shriver wegner editors research directions object oriented programming pages 
mit press 
wu 
theory types polymorphism logic programming 
phd thesis suny stony brook 
xu 
theory types type programming languages 
phd thesis suny stony brook 
shapiro 
polymorphically typed logic programs 
intl 
conference programming iclp paris france june 
shapiro 
type system logic programs 
shapiro editor concurrent prolog volume 
mit press 
zaniolo 
database language gem 
acm sigmod conference management data pages 
zaniolo kaci beech cammarata kerschberg maier 
object oriented database knowledge systems 
technical report db mcc 
