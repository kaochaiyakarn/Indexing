aversion appeared proceedings fifteenth symposium operating systems principles extensibility safety performance spin operating system brian bershad stefan savage law pardyak emin gun sirer marc fiuczynski david becker craig chambers susan eggers describes motivation architecture performance spin extensible operating system 
spin provides extension infrastructure core set extensible services allow applications safely change operating system interface implementation 
extensions allow application specialize underlying operating system order achieve particular level performance functionality 
spin uses language link time mechanisms inexpensively export ne grained interfaces operating system services 
extensions written type safe language dynamically linked operating system kernel 
approach ers extensions rapid access system services protecting operating system code executing kernel address space 
spin extensions written modula run dec alpha workstations 
spin operating system dynamically specialized safely meet performance functionality requirements applications 
spin motivated need support applications demands poorly matched operating system implementation interface 
poorly matched implementation prevents application working poorly matched interface prevents working 
example implementations disk bu ering research sponsored advanced research projects agency national science foundation 
cda ccr equipment digital equipment 
bershad partially supported national science foundation presidential 
chambers partially sponsored national science foundation presidential young investigator award 
sirer supported ibm graduate student fellowship 
fiuczynski partially supported national science foundation gee fellowship 
department computer science engineering university seattle wa paging algorithms modern operating systems inappropriate database applications resulting poor performance stonebraker 
general purpose network protocol implementations frequently inadequate supporting demands high performance parallel applications von eicken 
applications clients servers realtime fault tolerant programs demands poorly match operating system services 
spin application extend operating system interfaces implementations provide better match needs application performance functional characteristics system 
goals approach goal research build general purpose operating system provides extensibility safety performance 
extensibility determined interfaces services resources exported applications depends infrastructure allows ne grained access system services 
safety determines exposure applications actions requires access controlled granularity extensions de ned 
performance requires low overhead communication extension system 
design spin re ects view operating system extensible safe fast language runtime services provide lowcost ne grained protected access operating system resources 
speci cally operating system implemented level language runtime location 
operating system extensions dynamically linked kernel virtual address space 
location enables communication system extension code low cost 
enforced modularity 
extensions written modula nelson modular programming language compiler enforces interface boundaries modules 
extensions execute kernel virtual address space access memory execute privileged instructions explicit access interface 
modularity enforced compiler enables modules isolated low cost 
logical protection domains 
extensions exist logical protection domains kernel namespaces contain code exported interfaces 
interfaces language level units represent views system resources protected operating system 
kernel dynamic linker resolves code separate logical protection domains runtime enabling cross domain communication occur overhead procedure call 
dynamic call binding 
extensions execute response system events 
event describe potential action system virtual memory page fault scheduling thread 
events declared interfaces dispatched overhead procedure call 
location enforced modularity logical protection domains dynamic call binding enable interfaces de ned safely accessed low overhead 
techniques guarantee system extensibility 
ultimately extensibility system service interfaces de ne set resources operations exported applications 
spin provides set interfaces core system services memory management scheduling rely location ciently export ne grained operations enforced modularity logical protection domains manage protection dynamic call binding de ne relationships system components extensions runtime 
system overview spin operating system consists set extension services core system services execute kernel virtual address space 
extensions loaded kernel time 
loaded integrate existing infrastructure provide system services speci applications require 
spin primarily written modula allows extensions directly system interfaces requiring runtime conversion communicating system code 
spin relies language features ensure safety kernel applications written language execute virtual address space 
code requires low latency access system services written system safe extension language 
example implement unix operating system server 
bulk server written executes address space applications 
server consists large body code implements dec osf system call interface small number spin extensions provide thread virtual memory device interfaces required server 
extensions specialize spin needs individual application programs 
example built client server video system requires control data transfers images move server disk client screen 
spin server de nes extension implements direct stream disk network 
client viewer application installs extension kernel decompresses incoming network video packets displays video frame bu er 
rest rest describes motivation design performance spin 
section motivate need extensible operating systems discuss related 
section describe system architecture terms protection extension facilities 
section describe core services provided system 
section discuss system performance compare operating systems 
section discuss experiences writing operating system modula 
section 
motivation operating systems forced balance generality specialization 
general system runs programs may run 
contrast specialized system may run programs runs 
practice general systems ort specialized address performance functional requirements particular application needs interprocess communication synchronization thread management networking virtual memory cache management draves bershad bershad maeda bershad felten young cheriton mcnamee armstrong anderson fall pasquale wheeler bershad romer romer cao 
unfortunately existing system structures suited specialization requiring substantial programming ort ect change system behavior 
changes intended improve performance class applications degrade 
result system specialization costly error prone process 
extensible system changed dynamically meet needs application 
need extensibility operating systems shown clearly systems ms dos windows macintosh operating system 
systems designed extensible weak protection mechanisms allowed application programmers directly modify operating system data structures code schulman 
individual applications bene ted level freedom lack safe interfaces operating system services operating system extension services created system con guration chaos draves 
related previous orts build extensible systems demonstrated way tension extensibility safety performance 
example hydra wulf de ned infrastructure allowed applications manage resources multi level policies 
kernel de ned mechanism allocating resources processes processes implemented policies managing resources 
hydra architecture highly uential high overhead due capability protection mechanism 
consequently system designed large objects basic building blocks requiring large programming ort ect small extension 
researchers investigated microkernels vehicle building extensible systems black mullender cheriton zwaenepoel cheriton duda thacker 
microkernel typically exports small number abstractions include threads address spaces communication channels 
abstractions combined support conventional operating system services implemented user level programs 
application speci extensions microkernel occur level kernel interfaces 
unfortunately applications require substantial changes microkernel implementation compensate limitations interfaces lee davis waldspurger weihl 
microkernel communication facilities provide infrastructure extending nearly kernel service barrera forin extended 
believe high communication overhead bershad draves chen bershad limits extensions coarse grained services golub stevenson 
protected interaction system components occurs frequently system extensions limiting performance factor 
performance cross domain communication improved substantially years ton engler approach procedure call encouraging construction monolithic non extensible systems 
example microkernel aggressive design protected procedure call implementation overhead nearly procedure call times liedtke liedtke int 
point comparison intel int provided hardware support protected cross domain transfer cross domain communication overhead order procedure call times generally considered unacceptable 
systems rely little languages safely extend operating system interface interpreted code runs kernel lee mogul 
systems su er problems 
languages little expression arbitrary control data structures cumbersome limit range possible extensions 
second interface language programming environment rest system generally narrow making system integration di cult 
interpretation overhead limit performance 
systems provide interfaces enable arbitrary code installed heidemann popek rozier 
systems right de ne extensions restricted extension bring entire system extensibility possible 
projects lucco engler small seltzer exploring software fault isolation wahbe safely link application code written language kernel virtual address space 
software fault isolation relies binary rewriting tool inserts explicit checks memory branch instructions 
checks allow system de ne protected memory segments relying virtual memory hardware 
software fault isolation shows promise location mechanism relatively isolated code data segments 
unclear mechanism appropriate system ne grained sharing extensions may access large number segments 
addition software fault isolation protection mechanism de ne extension model service interfaces determine degree system extended 
aegis engler operating system relies cient trap redirection export hardware services exception handling tlb management directly applications 
system de nes abstractions minimally provided bythe hardware engler kaashoek 
conventional operating system services virtual memory scheduling implemented libraries executing application address space 
system service code executing library changed application needs 
spin shares ofthe goals aegis approach quite different 
spin uses language facilities protect kernel extensions implements protected communication procedure call 
infrastructure spin provides extension model core set extensible services 
contrast aegis relies hardware protected system calls isolate extensions kernel leaves unspeci ed manner extensions de ned applied 
systems cooper redell organick spin relied language features extend operating system services 
pilot instance single address space system ran programs written mesa ancestor modula 
general systems pilot depended language protection system just protection operating system extensions 
contrast spin reliance language services applies extension code kernel 
virtual address spaces isolate operating system programs 
spin architecture spin architecture provides software infrastructure safely combining system application code 
protection model supports cient ne grained access control resources extension model enables extensions de ned granularity ofa procedure call 
system architecture biased mechanisms implemented lowcost conventional processors 
consequently spin demands hardware relies language level services static typechecking dynamic linking 
relevant properties modula spin extensions written modula general purpose programming language designed early 
key features language include support interfaces type safety automatic storage management objects generic interfaces threads exceptions 
rely language support objects generic interfaces threads exceptions aesthetic reasons nd features simplify task constructing large system 
design spin depends language safety encapsulation mechanisms speci cally interfaces type safety automatic storage management 
interface declares visible parts implementation module de nes items listed interface 
de nitions implementation module hidden 
compiler enforces restriction compile time 
type safety prevents code accessing memory arbitrarily 
pointer may refer objects referent type array indexing operations checked bounds violation 
rst restriction enforced compile time second enforced combination compile time run time checks 
automatic storage management prevents memory live pointer referent returned heap reused object di erent type 
protection model protection model controls set operations applied resources 
example protection model address spaces ensures process access memory particular range virtual addresses 
address spaces frequently inadequate ne grained protection management resources expensive create slow access lazowska 
capabilities kernel resources spin referenced capabilities 
capability unforgeable resource system object interface collection interfaces 
example physical page physical page allocation interface entire virtual memory system 
individual resources protected ensure extensions resources access 
interfaces collections interfaces protected allow di erent extensions di erent views set available services 
operating systems capabilities rely special purpose hardware carter virtual memory mechanisms wulf probabilistic protection engler protected message channels black spin implements capabilities directly pointers supported language 
pointer block memory type declared interface 
demonstrates de nition interfaces capabilities pointers spin 
compiler compile time prevents pointer forged dereferenced way inconsistent type 
run time overhead pointer passing interface dereferencing overhead going memory access pointer referent 
pointer passed kernel user level application assumed type safe externalized 
externalized index application table contains type safe kernel data structures 
recovered index 
kernel services intend pass user level externalize table pass index 
protection domains protection domain de nes set accessible names available execution context 
conventional operating system protection domain implemented virtual address spaces 
name domain virtual address relationship name domain 
explicit mapping sharing operations possible names meaningful protection domains 
interface console interface 
type read console opaque 
const global name procedure open open returns capability console 
procedure write msg text procedure read var msg text procedure close console module console implementation module 
implementation console type buf array char reveal ref record pointer buf record buf device specific info implementations interface functions direct access revealed type 
procedure open 
console module gatekeeper client import console var console capability console device procedure console open console write intruder alert console close gatekeeper gatekeeper module interacts spin console service console interface 
gatekeeper manipulates objects type console unable access elds object executes virtual address space console module 
spin naming protection interface level language virtual memory system 
consequently namespace management occur language level 
example name instance type console console occupy portion symbolic namespace 
extension rede nes type console creates instance new type passes module expecting console original type creates type con ict results error 
error avoided placing extensions global module space modules procedures variable names visible programmers felt introduce overly restrictive programming model system 
spin provides facilities creating coordinating linking namespaces context protection domains 
interface domain type domain opaque procedure create returns domain created specified object file standard object file format 
procedure create domain containing interfaces defined calling module 
function allows modules name export runtime 
procedure resolve source target resolve undefined symbols target domain exported symbols source procedure combine create new aggregate domain exports interfaces domains 
domain 
domain interface 
interface operates instances type domain described type safe pointers 
implementation domain interface unsafe respect modula memory semantics manipulate linker symbols program addresses directly 
spin protection domain de nes set names program symbols referenced code access domain 
domain named capability control dynamic linking corresponds safe object les exported interfaces 
object le safe unknown kernel signed modula compiler kernel assert object le safe 
example spin lowest level device interface identical dec osf driver interface dig allowing dynamically link vendor drivers kernel 
drivers written kernel asserts safety 
general prefer avoid object les safe assertion compiler veri cation tend source fair share bugs 
domains intersecting disjoint enabling ap plications share services de ne new ones 
domain created create operation initializes domain contents safe object le 
symbols exported interfaces de ned object le exported domain imported symbols left unresolved 
unresolved symbols correspond interfaces imported code domain implementations 
resolve operation serves basis dynamic linking 
takes target source domain resolves unresolved symbols target domain symbols exported source 
resolution text data symbols patched target domain ensuring resolved domains able share resources memory speed 
resolution resolves target domain unde ned symbols cause additional symbols exported 
common idiom occurs pair resolve operations 
combine operation creates linkable namespaces union existing domains bind collections related interfaces 
example domain combines system public interfaces single domain available extensions 
summarizes major operations domains 
domain interface commonly import export particular named interfaces 
module exports interface explicitly creates domain interface exports domain kernel nameserver 
exported name interface speci ed interface coordinate export import rpc systems schroeder burrows 
constant console de nes name uniquely identify particular version service 
interfaces devices restrict access time import 
register authorization procedure nameserver called identity interface imported 
ne grained control low cost authorizer interact direct procedure calls 
extension model extension changes way system provides service 
software extensible way extension model determines ease transparency ciency extension applied 
spin extension model provides controlled communication facility extensions base system allowing variety styles 
example model allows extensions passively monitor system activity provide date performance information applications 
extensions may er hints sys tem guide certain operations page replacement 
cases extension may entirely replace existing system service new appropriate speci application 
extensions spin de ned terms events handlers 
event message announces change state system request service 
event handler procedure receives message 
extension installs handler event explicitly registering handler event central dispatcher routes events handlers 
event names protected domain machinery described previous section 
event de ned procedure exported interface handlers de ned procedures having type 
handler invoked arguments speci ed event raiser 
kernel preemptive ensuring handler take processor 
right call procedure equivalent right raise event procedure 
fact indistinguishable spin procedure exported event 
dispatcher exploits similarity optimize event raise direct procedure call handler event 
dispatcher uses dynamic code generation engler proebsting construct optimized call paths raiser handlers 
primary right handle event restricted default implementation module event module statically exports procedure named 
example module console default implementation module event console open shown 
modules may request dispatcher install additional handlers remove primary handler 
request dispatcher contacts primary implementation module passing event 
implementation module deny allow installation 
denied installation fails 
allowed implementation module provide guard associated handler 
guard de nes predicate expressed procedure evaluated dispatcher prior handler invocation 
predicate true event raised handler invoked handler ignored 
guards restrict access events granularity ner event name allowing events dispatched instance basis 
example spin extension implements ip layer processing event ip pkt ip packet raises ip packet received 
ip module de nes default event installation constructs guard compares type eld header incoming packet set ip protocol types handler may service 
way dispatcher allows handler specify additional closure passed handler event processing 
closure allows single handler context 
export separate interface event instance 
handler stack additional guards event constraining invocation 
may handlers installed particular event 
default implementation module may constrain handler execute synchronously asynchronously bounded time arbitrary order respect handlers event 
constraints re ects di erent degree trust default implementation handler 
example handler may bounded time quantum aborted executes long 
handler may asynchronous causes execute separate thread raiser isolating raiser handler latency 
multiple handlers execute response event single result communicated back raiser associating event procedure ultimately determines nal result pardyak bershad 
default dispatcher mimics procedure call semantics executes handlers synchronously completion unde ned order returns result nal handler executed 
core services spin protection extension mechanisms described previous section provide framework managing interfaces services kernel 
applications ultimately concerned manipulating resources memory processor 
consequently spin provides set core services manage memory processor resources 
services events communicate system extensions export interfaces ne grained operations 
general service interfaces exported extensions kernel similar secondary internal interfaces conventional operating systems provide simple functionality small set objects 
spin straightforward allocate single virtual page physical page create mapping 
overhead accessing operations low procedure call feasible provide interfaces separate abstractions build higher level abstractions direct composition 
contrast traditional operating systems aggregate simpler abstractions complex ones cost repeated access simpler abstractions high 
extensible memory management memory management system responsible allocation virtual addresses physical addresses mappings 
systems demonstrated signi cant performance improvements specialized tuned memory management policies accessible interfaces exposed memory management system 
interfaces possible manipulate large objects address spaces young khalidi nelson direct expensive operations example cheriton mcnamee armstrong entirely user level 
enabled control relatively small objects cache pages romer tlb entries bala entirely kernel 
allowed fast ne grained control physical virtual memory resources required applications 
spin virtual memory system provides control enabled system low overhead invocation protection services 
spin memory decomposes memory services basic components physical storage naming translation 
correspond basic memory resources exported processors physical addresses virtual addresses translations 
application speci services interact services de ne higher level virtual memory abstractions address spaces 
basic components memory system provided separate service interface described 
physical address service controls allocation physical pages 
clients raise allocate event request physical memory certain size optional series attributes re ect preferences machine speci parameters color contiguity 
page represents unit high speed storage 
purposes entity addressed directly extension user program 
clients physical address service receive capability memory 
virtual address service allocates capabilities virtual addresses capability referent composed virtual address length address space identi er address unique 
translation service express relationship virtual addresses physical memory 
service interprets virtual physical addresses constructs mappings installs mappings processor memory management unit mmu 
translation service raises set events correspond various exceptional mmu conditions 
example user program attempts access unallocated virtual memory address translation event raised 
accesses allocated unmapped virtual page translation event raised 
implementors higher level memory management abstractions events de ne services demand paging copy write rashid distributed shared memory carter concurrent garbage collection appel li 
physical page service may time reclaim physical memory raising reclaim event 
interface allows handler event volunteer alternative page candidate page 
translation ser interface type opaque procedure allocate size size attrib attrib allocate physical memory particular attributes 
procedure deallocate procedure reclaim candidate request reclaim candidate page 
clients may handle event alternative candidates 

interface type opaque procedure allocate size size attrib attrib procedure deallocate 
interface translation import type translation opaque procedure create procedure destroy context create destroy addressing context procedure context prot protection add named translation context specified protection 
procedure context procedure context protection events raised illegal translations procedure procedure procedure translation 
interfaces managing physical addresses virtual addresses translations 
vice ultimately invalidates mappings reclaimed page 
spin core services de ne address space model directly implement range models variety optimization techniques 
example built extension implements unix address space semantics applications 
exports interface copying existing address space allocating additional memory 
new address space extension allocates new context translation service 
context subsequently lled virtual physical address resources obtained memory allocation services 
kernel extension de nes memory management interface supporting mach task abstraction young 
applications may interfaces may de ne terms lower level services 
extensible thread management operating system thread management system provides applications interfaces scheduling concurrency synchronization 
applications require levels functionality performance thread management system unable deliver 
userlevel thread management systems addressed mismatch wulf cooper draves marsh anderson partially 
example mach user level threads implementation cooper draves anomalous behavior integrated kernel ser vices anderson 
contrast scheduler activations integrated kernel high communication overhead davis 
spin application provide thread package scheduler executes kernel 
thread package de nes application execution model synchronization constructs 
scheduler controls multiplexing processor multiple threads 
packages allow application de ne arbitrary thread semantics implement semantics close processor kernel services 
spin de ne thread model applications de ne structure implementation thread model rests 
structure de ned set events raised handled schedulers thread packages 
scheduler multiplexes underlying processing resources competing contexts called strands 
strand similar thread traditional operating systems processor context 
thread strand minimal requisite kernel state name 
application speci thread package de nes implementation strand interface threads 
thread package scheduler implement control user space contexts 
describes interface 
interface contains events block unblock raised signal changes strand execution state 
disk driver direct scheduler block current strand operation interrupt han unblock strand signal completion operation 
response events scheduler communicate thread package managing strand checkpoint resume events allowing package save restore execution state 
interface strand type strand opaque procedure block signal scheduler runnable 
procedure unblock signal scheduler runnable 
procedure checkpoint signal save processor state required subsequent rescheduling 
procedure resume signal placed processor reestablish state saved prior call checkpoint 
strand 
strand interface 
interface describes scheduling events ecting control ow raised kernel 
application speci schedulers thread packages install handlers events raised behalf particular strands 
trusted thread package scheduler provide default implementations operations ensure extensions install handlers strands possess capability 
application speci thread packages manipulate ow control application threads executing outside kernel 
safety reasons responsibility scheduling synchronization kernel belongs kernel 
thread transfers user mode kernel mode checkpointed modula thread executes kernel behalf 
modula thread leaves kernel blocked application speci thread resumed 
global scheduler implements primary processor allocation policy strands 
additional application speci schedulers placed top global scheduler checkpoint resume events relinquish receive control processor 
application speci scheduler presents global scheduler thread package 
delivery resume event indicates new scheduler schedule strands checkpoint signals processor reclaimed global scheduler 
block unblock events raised strands scheduled application speci schedulers routed dispatcher appropriate scheduling implementation 
allows new scheduling policies implemented integrated kernel provided application speci policy con ict global policy 
global scheduling policy replaceable replaced arbitrary application replacement global ects 
current implementation global scheduler implements round robin preemptive priority policy 
strand interface implement kernel extensions variety thread including dec osf kernel threads dig threads cooper draves modula threads 
implementations interfaces built directly strands layered top 
interface supporting dec osf kernel threads allows incorporate vendor device drivers directly kernel 
threads implementation supports unix server uses mach threads interface concurrency 
kernel trusted thread package scheduler implements modula thread interface nelson 
implications trusted services processor memory services instances spin core services provide interfaces hardware mechanisms 
core services trusted means perform interface speci cation 
trust required services access underlying hardware facilities times step outside protection model enforced language 
trust protection extension mechanisms described previous section function safely rely proper management hardware 
trusted services mediate access physical resources applications extensions trust services trusted kernel 
designing interfaces spin trusted services worked ensure extension failure interface correctly isolated extension rely 
example spin scheduler raises events handled application speci thread packages order start threads 
handler best interests respect interfere semantics implied event enforced 
application speci thread package may ignore event particular user level thread runnable application thread package ected 
way failure extension catastrophic failure code executing runtime libraries conventional systems 
system performance section show spin enables applications compose system services order de ne new kernel services perform 
speci cally performance spin perspectives system size 
size system terms lines code object size demonstrates advanced runtime services necessarily create operating system kernel excessive size 
addition size system extensions shows implemented reasonable amounts code 
microbenchmarks 
measurements low level system services protected communication thread management virtual memory spin extension architecture enables construct communication intensive services low overhead 
measurements show conventional system mechanisms system call cross address space protected procedure call comparable conventional systems 
networking 
measurements suite networking protocols demonstrate spin extension architecture enables implementation highperformance network protocols 
performance 
show application performance bene spin architecture describing applications system extensions 
compare performance operations operating systems run platform spin august dec osf isa monolithic operating system mach microkernel 
collected measurements dec alpha mhz axp workstations rated specint 
machine mbs memory kb uni ed external cache hp gb disk drive mb sec lance ethernet interface fore tca mb sec atm adapter card connected fore asx switch 
fore cards programmed maximally deliver mb sec pair hosts bershad 
avoid comparisons operating systems running di erent tend scale poorly variety reasons anderson 
measurements taken operating systems run single user mode 
system components spin runs standalone kernel dec alpha workstations 
system consists main components sys core rt lib sal support di erent classes service 
table shows size component source lines object bytes percentages 
rst component sys implements extensibility machinery domains naming linking dispatching 
second component core implements virtual memory scheduling services described previous section device management disk network le system network debugger redell 
third component rt contains version dec src modula runtime system supports automatic memory management exception processing 
fourth component lib includes subset standard modula libraries handles ofthe mundane data structures lists queues hash tables generally required operating system kernel 
nal component sal implements lowlevel interface device drivers mmu ering functionality install page table entry get console read block scsi unit 
build sal applying dozen le di small subset les dec osf kernel source tree 
approach increasing size kernel allows track vendor hardware requiring new system con guration 
component source size text size data size lines bytes bytes sys core rt lib sal total kernel table table shows size di erent components system 
sys core rt components contain interfaces visible extensions 
column labeled lines include comments 
dec src modula compiler release 
microbenchmarks microbenchmarks reveal overhead basic system functions protected procedure call thread management virtual memory 
de ne bounds system performance provide framework understanding larger operations 
times section measured alpha internal cycle counter average large number iterations may overly optimistic regarding cache ects bershad 
protected communication conventional operating system applications services extensions communicate protected mechanisms system calls cross address space calls 
rst enables applications kernel services interact 
second enables interaction applications services part kernel 
overhead mechanisms limiting factor conventional system extensibility 
high overhead discourages frequent interaction requiring system built coarse grained interfaces amortize cost communication large operations 
spin extension model ers third mechanism protected communication 
simple procedure calls system calls communication extensions core system 
similarly simple procedure calls cross address procedure calls communication applications services installed kernel 
table compare performance different protected communication mechanisms invoking null procedure call dec osf mach spin 
null procedure call takes arguments returns results re ects cost control transfer 
protected kernel call spin implemented procedure call domains dynamically linked 
test measure data transfer overhead passing arguments domains large arguments small passed 
system call overhead re ects time cross user kernel boundary execute procedure return 
mach dec osf system calls ow trap handler generic xed system call dispatcher requested system call written 
spin trap handler raises trap event dispatched modula procedure installed handler 
third line table shows time perform protected cross address space procedure call 
dec osf supports cross address space procedure call sockets sun rpc 
mach provides optimized path cross address space communication messages draves 
spin cross address space procedure call implemented extension uses system calls transfer control kernel cross domain procedure calls kernel transfer control address spaces 
operation dec osf mach spin protected kernel call system call cross address space call table protected communication overhead microseconds 
dec osf mach support protected kernel communication 
table illustrates points communication system structure 
overhead protected communication spin procedure call extensions executing kernel address space 
spin protected kernel calls provide functionality cross address space calls dec osf mach ability execute arbitrary code response application call 
second spin extensible architecture preclude traditional communication mechanisms having performance comparable non extensible systems 
performance protected call mechanisms encourages kernel extensions 
spin kernel protected procedure call time conservative 
modula compiler generates code call roughly twice slow call 
version modula compiler corrects disparity 
addition compiler perform inlining important optimization calling small procedures 
optimizations ect semantics language change system protection model 
thread management thread management packages implement concurrency control operations underlying kernel services 
previously mentioned spin kernel threads implemented trusted thread package exporting modula thread interface 
application speci extensions rely threads executing kernel implement concurrent operations 
userlevel thread management overhead determines granularity threads control concurrent user level operations 
table shows overhead thread management operations kernel user threads di erent systems 
fork join measures time create schedule terminate new thread synchronizing termination thread 
ping pong re ects synchronization overhead measures time pair threads synchronize rst thread signals second blocks second signals rst blocks 
measure kernel thread overheads native primitives provided thread sleep thread wakeup dec osf mach locks condition variables spin 
user level measure performance program threads mach threads threads superset dec osf 
table shows measurements implementations threads spin 
rst implementation labeled layered implemented user level library layered set kernel extensions implement mach kernel thread interface 
second implementation labeled integrated structured extension exports threads interface system calls 
version uses spin strand interface integrated scheduling behavior rest kernel 
table shows spin extensible thread implementation incur performance penalty compared ones integrated kernel services 
virtual memory applications exploit virtual memory fault path extend system services appel li 
example concurrent generational garbage collectors write faults maintain invariants collect information 
longstanding problem fault dec osf mach spin kernel user kernel user kernel user operation layered integrated fork join ping pong table thread microseconds 
strategies overhead handling page fault application thekkath levy anderson 
sources overhead 
handling fault user application requires crossing user kernel boundary times 
second conventional systems provide quite general exception interfaces perform functions 
result applications requiring subset interface functionality pay 
spin allows applications de ne specialized fault handling extensions avoid user kernel boundary crossings implement precisely functionality required 
table shows time execute commonly referenced virtual memory benchmarks appel li engler 
line labeled dirty table measures time application query status particular virtual page 
dec osf mach provide facility 
time shown table extension invoke virtual memory system additional microseconds system call time required invoke service user level 
trap measures latency page fault time handler executes 
fault perceived latency access standpoint faulting thread 
measures time re ect page fault application enable access page handler resume faulting thread 
prot measures time increase protection single page 
similarly prot measure time increase decrease protection range pages 
mach faster protection operation performed lazily spin extension lazily evaluate request enables access requested 
appel appel measure combination traps protection changes 
appel benchmark measures time fault protected page resolve fault handler protect page handler 
appel measures time protect pages fault resolving fault handler appel shown average cost page 
spin outperforms systems virtual memory benchmarks reasons 
spin uses kernel extensions de ne application speci system calls virtual memory management 
calls provide access virtual physical memory interfaces described previous section install handlers translation events occur application virtual address space 
contrast dec osf requires applications unix signal mprotect interfaces manage virtual memory requires external pager interface young 
signals external pagers especially cient implementations focus generalized functionality thekkath levy 
second reason spin dominance virtual memory event requires series interactions kernel application re ected application fast kernel protected procedure call 
dec osf mach communicate events means expensive traps messages 
operation dec osf mach spin dirty fault trap prot prot appel appel table virtual memory operation overheads microseconds 
dec osf mach provide interface querying internal state page frame 
networking spin extension architecture implement protocol stacks ethernet atm networks fiuczynski bershad 
illustrates structure protocol stacks similar kernel hutchinson spin permits user code dynamically placed stack 
incoming packet pushed protocol graph events pulled handlers 
handlers top graph process message entirely kernel copy application 
rpc extensions example implement network transport remote procedure call package active messages von eicken 
video extension provides direct path video packets network er 
udp tcp extensions support internet protocols 
forward extension provides transparent udp ip tcp ip forwarding packets arriving speci port 
extension implements hypertext transport protocol berners lee directly kernel enabling server respond quickly requests splicing protocol stack local le system 
latency bandwidth table shows round trip latency reliable bandwidth applications udp ip dec dec osf tcp engine spin extension manually assert code written safe 
ping icmp rpc video icmp udp tcp event handler event ether lance device driver udp tcp ip ip forward atm fore device driver gure shows protocol stack routes incoming network packets application speci endpoints kernel 
ovals raised route control handlers represented boxes 
handlers implement protocol corresponding label 
osf spin 
dec osf application code executes user level packet sent involves trap copy operations data moves user kernel boundary 
spin application code executes extension kernel low latency access device data 
incoming packet causes series events generated layer udp ip protocol stack ethernet atm ip udp shown 
spin protocol processing done separately scheduled kernel thread outside interrupt handler 
networking measurements mach system provides path ethernet cient dec osf supports atm card 
latency bandwidth dec osf spin dec osf spin ethernet atm table network protocol latency microseconds receive bandwidth mb sec 
measure latency small packets bytes bandwidth large packets ethernet atm 
table shows processing packets entirely kernel reduce round trip latency compared system packets handled user space 
throughput tends latency sensitive roughly systems 
vendor device drivers dec osf spin isolate di erences due system architecture due characteristics underlying device driver 
lance ethernet driver fore atm driver optimized latency thekkath levy lance ether net driver optimized throughput 
di erent device drivers achieve round trip latency secs ethernet secs atm reliable atm bandwidth pair hosts rises mb sec 
estimate minimum round trip time hardware roughly secs ethernet secs atm 
maximum usable ethernet atm bandwidths pair hosts roughly mb sec mb sec 
protocol forwarding spin extension architecture provide protocol functionality generally available conventional systems 
example tcp redirection protocols balakrishnan required kernel modi cations straightforwardly de ned application spin extension 
forwarding protocol load balance service requests multiple servers 
spin application installs node protocol stack redirects data control packets destined particular port number secondary host 
wehave implemented similar service dec osf user level process splices incoming outgoing socket 
dec osf forwarder able forward protocol control packets executes transport layer 
result maintain protocol semantics 
case tcp connection establishment termination semantics violated 
user level intermediary interferes protocol algorithms window size negotiation slow start failure detection congestion control possibly degrading performance connections hosts 
user level forwarder packet trips protocol twice copied user kernel boundary 
table compares latency implementations reveals additional done user level forwarder 
tcp udp dec osf spin dec osf spin ethernet atm table round trip latency microseconds route byte packets protocol forwarder 
performance implemented applications exploit spin extensibility 
networked video system consists server client viewer 
server structured kernel extensions uses local le system read video frames disk sends video network third registers handler event transforming single send multicast list clients 
server transmits frames second client 
client extension awaits incoming video packets decompresses writes directly frame bu er structure shown 
outgoing packet pushed protocol graph client stream spin server support larger number clients processes packet isolation 
show measure processor utilization function number clients spin server server runs dec osf 
dec osf server executes user space communicates clients sockets outgoing packet copied kernel pushed kernel protocol stack device driver 
determine processor utilization measuring progress low priority idle thread executes server 
fore interface nd spin dec osf consume roughly fraction server processor number clients 
spin server protocol stack majority server cpu resources consumed programmed copies data network word time 
network interface supports dma nd spin server processor utilization grows slowly dec osf server 
shows server processor utilization function number supported client streams server con gured digital pkt adapter 
experimental network interface send mb sec dma 
device driver operating systems 
streams spin dec osf saturate network spin consumes half processor 
compared dec osf spin support clients faster network clients slower processor 
application bene spin architecture web server 
service requests quickly web server cache accessed objects cache large objects infrequently accessed chankhunthod avoid double bu ering caching agents stonebraker 
server cache built top conventional caching le system avoids double bu ering problem unable control caching policy 
contrast server controls cache top le system su ers double bu ering 
spin allows server control cache avoid problem double bu ering 
spin web server implements hybrid caching policy le type lru small les cache large les tend accessed infrequently 
clientside latency transaction spin web server running kernel extension milliseconds requested le server cache 
server goes non caching le sys cpu utilization spin driver dec osf driver number clients server utilization function number client video streams 
stream requires approximately mb sec 
tem nd le 
comparable user level web server dec osf relies operating system caching le system double bu ering takes milliseconds request cached le 
issues scalability dispatcher spin event dispatcher matches event handlers 
procedure system ectively event latency dispatcher critical 
mentioned case single synchronous handler raise implemented procedure call raiser handler 
cases handlers registered particular event dispatcher takes active role event delivery 
guard handler pair installed event dispatcher evaluates guard true invokes handler 
consequently dispatcher latency depends number complexity guards number event handlers ultimately invoked 
practice overhead event dispatch linear number guards handlers installed event 
example round trip ethernet latency measure secs rises secs additional guards handlers register interest arrival udp packet guards evaluate false 
guards evaluate true latency rises secs 
presently perform guard speci optimizations common subexpressions representing guard predicates decision trees 
system matures plan apply optimizations 
impact automatic storage management extensible system depend correctness unprivileged clients memory integrity 
previously mentioned memory management schemes allow extensions return objects system heap unsafe rogue client violate type system retaining freed object 
spin uses trace copying garbage collector bartlett safely reclaim memory resources 
collector serves safety net untrusted extensions ensures resources released extension inaction result premature termination eventually reclaimed 
clients allocate large amounts memory trigger frequent garbage collections adverse global ects 
practice problem expected spin extensions avoid allocation fast paths 
example measurements section change disable collector tests 
systems garbage collection generalized allocation avoided high latency 
subsystems implement allocators optimized expected usage pattern 
spin services reason dynamic memory allocation relatively expensive 
consequence pressure collector pressure applied critical path 
size extensions table shows size extensions described section 
spin extensions tend require amount code commensurate functionality 
example null syscall ipc extensions conceptually simple simple implementations 
extensions tend import relatively dozen interfaces domain event system fairly stylized ways 
result building extensions exceptionally di cult 
contrast trouble correctly implementing benchmarks dec osf mach forced follow circuitous routes achieve particular level functionality 
mach external pager interface instance required implement complete pager user space interested discovering write protect faults 
experiences modula decision modula care 
originally intended de ne implement compiler safe subset programmers certain infeasible build cient operating system language having syntax semantics performance design safe subset proceeded faced dif component source size text size data size lines bytes bytes null syscall ipc dec osf threads vm workload ip udp tcp tcp forward udp forward video client video server table table shows size di erent system extensions described 
cult issues typically arise language design redesign 
major issue considered context safe version type semantics objects storage management naming issue satisfactorily addressed modula 
understood de nition service interfaces important language implemented 
ultimately decided modula system extensions 
early evidence abandon main prejudices language programs written slow large programmers ective language 
terms performance remarkable language code size execution time shown previous section 
terms programmer ectiveness takes day competent programmer learn syntax obvious semantics modula days pro cient advanced features 
anecdotal experience portions spin kernel written modula robust easier understand portions written spin operating system demonstrates possible achieve performance extensible system compromising safety 
system provides set cient mechanisms extending services core set extensible services 
location enforced modularity logical protection domains dynamic call binding allow extensions dynamically de ned accessed granularity procedure call 
past system builders relied programming language translate operating system policies mechanisms machine code 
programming language appropriate features believe operating system implementors heavily rely compiler language run time services construct systems structure performance complementary 
additional information spin project available www spin cs washington edu alpha workstation running spin extension described 
people contributed spin project 
david dion responsible bringing system unix server 
jan possible dec osf scsi driver spin 
anthony lamarca dylan mcnamee geo voelker alec wolman assisted understanding system performance dec osf mach 
david nichols hank levy watson provided feedback earlier drafts 
david boggs provided cards video server experiment 
special due dec src provided compiler infrastructure 
rozier shapiro generic virtual memory management operating system kernels 
proceedings thirteenth acm symposium operating systems principles pages eld park az december 
anderson anderson levy bershad lazowska interaction architecture operating system design 
proceedings fourth international conference support programming languages operating systems asplos iv pages santa clara ca april 
anderson anderson bershad lazowska levy scheduler activations ective kernel support user level management parallelism 
acm transactions computer systems february 
appel li appel li virtual memory primitives user programs 
proceedings fourth international conference support programming languages operating systems asplos iv pages santa clara ca april 
bala bala kaashoek weihl software prefetching caching translation lookaside bu ers 
proceedings usenix symposium operating systems design implementation osdi pages monterey ca november 
balakrishnan balakrishnan seshan amir katz improving tcp ip performance wireless networks 
proceedings acm conference mobile computing networking november 
barrera barrera fast mach network ipc implementation 
proceedings second usenix mach symposium pages monterey ca november 
bartlett bartlett compacting garbage collection ambiguous roots 
technical report wrl tr digital equipment western research labs february 
berners lee berners lee cailliau luotonen nielsen world wide web 
communications acm august 
bershad bershad practical considerations non blocking concurrent objects 
proceedings thirteenth international conference distributed computing systems pages pittsburgh pa may 
bershad bershad anderson lazowska levy lightweight remote procedure call 
acm transactions computer systems february 
bershad bershad draves forin microbenchmarks toevaluate system performance 
proceedings third workshop workstation operating systems pages key fl april 
bershad bershad redell ellis fast mutual exclusion uniprocessors 
proceedings fifth international conference architectural support programming languages operating systems asplos pages boston ma october 
black black microkernel operating system architecture mach 
proceedings usenix workshop micro kernels kernel architectures pages seattle wa april 
orr rozier new look microkernel unix operating systems lessons performance compatibility 
proceedings spring conference norway may 
inside ole 
microsoft press 
bershad bershad simple protocol processing high bandwidth low latency networking 
technical report cmu cs carnegie mellon university march 
cao cao felten li implementation performance application controlled file caching 
proceedings usenix symposium operating systems design implementation osdi pages monterey ca november 
carter carter bennett zwaenepoel implementation performance munin 
proceedings thirteenth acm symposium operating systems principles pages paci grove ca october 
carter carter dally hardware support fast capability addressing 
proceedings sixth international conference architectural support programming languages operating systems asplos vi pages san jose ca october 
chankhunthod chankhunthod danzig neerdaels schwartz worrell hierarchical internet object cache 
technical report cu cs dcs university colorado july 
chen bershad chen bershad impact operating system structure memory system performance 
inproceedings fourteenth acm symposium operating systems principles pages asheville nc december 
cheriton duda cheriton duda caching model operating system kernel functionality 
proceedings usenix symposium operating systems design implementation osdi pages monterey ca november 
cheriton zwaenepoel cheriton zwaenepoel distributed kernel performance diskless workstations 
proceedings ninth acm symposium operating systems principles pages woods nh october 
performance ects functional migration architectural complexity oriented systems 
technical report cmu cs carnegie mellon university august 
cooper draves cooper draves threads 
technical report cmu cs carnegie mellon university june 
cooper cooper harper lee fox project advanced development systems software 
technical report cmu cs carnegie mellon university august 
davis davis mcnamee lazowska adding scheduler activations mach 
proceedings third usenix mach symposium pages santa fe nm april 
dig digital equipment 
dec osf writing device drivers advanced topics 
draves draves case run time replaceable kernel modules 
proceedings fourth workshop workstation operating systems pages napa ca october 
draves draves control transfer operating system kernels 
technical report cmu cs carnegie mellon university may 
draves draves bershad rashid dean continuations implement thread management communication operating systems 
proceedings thirteenth acm symposium operating systems principles pages paci grove ca october 
engler kaashoek engler kaashoek operating system abstractions 
proceedings fifth workshop hot topics operating systems pages orcas island wa may 
engler proebsting engler proebsting dcg cient dynamic code generation system 
proceedings sixth international conference architectural support programming languages operating systems asplos vi pages san jose ca october 
engler engler kaashoek toole operating system kernel secure programmable machine 
proceedings acm european sigops workshop september 
engler engler kaashoek jr exokernel operating system architecture application level resource management 
proceedings fifteenth acm symposium operating systems principles copper mountain december 
fall pasquale fall pasquale improving continuous media playback performance kernel data paths 
proceedings ieee international conference multimedia computing systems pages boston ma may 
felten felten case application speci communication protocols 
intel supercomputer systems technology focus conference pages april 
fiuczynski bershad fiuczynski bershad extensible protocol architecture application speci networking 
proceedings winter usenix conference san diego ca january 
forin forin golub bershad system mach 
inproceedings second usenix mach symposium pages monterey ca november 
morris satterthwaite early experiences mesa 
communications acm august 
golub golub dean forin rashid unix application program 
proceedings summer usenix conference pages june 
hamilton hamilton spring nucleus microkernel objects 
proceedings summer usenix conference pages cincinnati oh june 
cheriton cheriton application controlled physical memory external page cache management 
proceedings fourth international conference support programming languages operating systems asplos iv pages santa clara ca april 
heidemann popek heidemann popek file system development stackable layers 
communications acm february 
architectural overview qnx 
proceedings usenix workshop micro kernels kernel architectures pages seattle wa april 
hutchinson hutchinson peterson abbott malley rpc kernel evaluating new design techniques 
proceedings thirteenth acm symposium operating systems principles pages eld park az december 
int intel 
architecture 
int intel 
microprocessor programmer manual 
khalidi nelson khalidi nelson implementation unix object oriented operating system 
proceedings winter usenix conference pages san diego ca january 
lazowska lazowska levy fischer fowler architecture eden system 
proceedings eighth acm symposium operating systems principles pages december 
lee lee chen chang high performance external virtual memory caching 
proceedings usenix symposium operating systems design implementation osdi pages monterey ca november 
liedtke liedtke fast thread management communication continuations 
proceedings usenix workshop micro kernels kernel architectures pages seattle wa april 
liedtke liedtke improving ipc kernel design 
proceedings fourteenth acm symposium operating systems principles pages asheville nc december 
lucco lucco high performance microkernel systems 
proceedings usenix symposium operating systems design implementation osdi page monterey ca november 
maeda bershad maeda bershad protocol service decomposition high performance networking 
proceedings fourteenth acm symposium operating systems principles pages asheville nc december 
marsh marsh scott leblanc markatos class user level threads 
proceedings thirteenth acm symposium operating systems principles pages paci grove ca october 
mcnamee armstrong mcnamee armstrong extending mach external pager interface accommodate user level page 
proceedings usenix mach symposium pages burlington vt october 
mogul mogul rashid accetta packet filter cient mechanism user level network code 
proceedings eleventh acm symposium operating systems principles pages austin tx november 
extensibility oberon system 
nordic journal computing february 
mullender mullender rossum tanenbaum renesse van staveren amoeba distributed operating system 
ieee computer pages may 
nelson nelson editor 
system programming modula 
prentice hall 
organick organick editor 
computer system series 
academic press 
pardyak bershad pardyak bershad group structuring mechanism distributed object oriented language objects 
proceedings fourteenth international conference distributed computing systems pages poznan poland june 
rashid rashid tevanian jr young golub baron black bolosky chew machine independent virtual memory paged uniprocessor multiprocessor architectures 
proceedings second international conference support programming languages operating systems asplos ii pages palo alto ca april 
redell redell experience topaz 
proceedings acm sigplan sigops workshop parallel distributed debugging october 
redell redell dalal lauer lynch mcjones murray purcell pilot operating system personal computer 
communications acm february 
romer romer lee bershad dynamic page mapping policies cache con ict resolution standard hardware 
proceedings usenix symposium operating systems design implementation osdi pages monterey ca november 
romer romer karlin bershad reducing tlb memory overhead online superpage promotion 
proceedings third international symposium computer architecture pages 
rozier rozier armand herrmann leonard chorus distributed operating system 
computing systems 
schroeder burrows schroeder burrows performance fire rpc 
acm transactions computer systems february 
schulman schulman undocumented windows 
addison wesley 
small seltzer small seltzer vino integrated platform operating system database research 
technical report tr harvard university 
stevenson stevenson mach unix generic os object servers 
proceedings winter usenix conference new orleans la january 
bershad chen fast interrupt priority management operating system kernels 
proceedings second usenix workshop microkernels kernel architectures pages san diego ca september 
stonebraker stonebraker operating system support database management 
communications acm july 
thacker thacker stewart satterthwaite jr fire multiprocessor workstation 
ieee transactions computers august 
thekkath levy thekkath levy limits low latency rpc 
acm transactions computer systems may 
thekkath levy thekkath levy hardware software support cient exception handling 
proceedings sixth international conference support programming languages operating systems asplos vi pages san jose ca october 
von eicken von eicken culler goldstein schauser active messages mechanism integrated communication computation 
proceedings nineteenth international symposium computer architecture pages gold coast australia may 
wahbe wahbe lucco anderson graham cient software fault isolation 
proceedings fourteenth acm symposium operating systems principles pages asheville nc december 
waldspurger weihl waldspurger weihl lottery scheduling flexible proportional share resource management 
proceedings usenix symposium operating systems design implementation osdi pages monterey ca november 
wheeler bershad wheeler bershad consistency management virtually indexed caches 
proceedings fifth international conference support programming languages operating systems asplos pages boston ma october 
wulf wulf levin harbison hydra mmp experimental computer system 
mcgraw hill 
young young tevanian rashid golub chew bolosky black baron duality memory communication implementation multiprocessor operating system 
proceedings eleventh acm symposium operating systems principles pages austin tx november 
bershad maeda moss cient packet demultiplexing multiple endpoints large messages 
proceedings winter usenix conference pages san francisco ca january 
