appear math 
struct 
comp 
science computation classical sequents steffen van bakel department computing imperial college london queen gate london sw bz doc ic ac uk pierre lescanne cole normale sup rieure de lyon lyon lescanne ens lyon fr received untyped continuation style formal language typed subset provides curry howard isomorphism sequent calculus classical logic 
viewed language describing nets composition basic components connected wires 
features expressive platform algebraic objects different applicative programming paradigms mapped 
syntax reduction rules order demonstrate expressive power show elaborate calculi embedded calculus rose calculus explicit substitutions parigot curien herbelin 

exist number systems literature link classical logic notion computation 
past say herbelin phd herbelin urban phd urban study relation computation programming languages logic concentrated mainly natural deduction systems 
fact carry predicate natural comparison example sequent style systems natural deduction systems easy understand reason 
holds strongly context non classical logics 
example relation intuitionistic logic lambda calculus types studied understood resulted vast investigated area research resulting functional programming languages linear logic 
example approach representing classical proofs parigot calculus parigot natural deduction system main manipulated possibly alternative ones 
adding conflict pseudo type calculus corresponds minimal classical logic ariola herbelin 
link classical logic continuations control established calculus stands griffin operator griffin krivine extensively studied ong stewart ariola herbelin ariola herbelin sabry see 
partially supported cole normale sup rieure de lyon france van bakel lescanne sequent calculus introduced gentzen gentzen logical system rules introduce connectives sides sequent contrary natural deduction uses elimination rules 
way eliminate connective eliminate formula appears application cut rule 
gentzen calculus classical logic lk allows sequents form 

bm 
understood 

bm understood 
bm 
lk appears symmetrical system 
symmetrical lambda calculus defined berardi essentially allowing application interpreted ways encapsulating duality cut elimination gentzen lk 
hand exists sequent calculus necessity rules manipulate hypotheses studied herbelin herbelin curien herbelin herbelin 
cut rule increase expressive power system cut elimination procedure defined eliminates applications cut rule proof sequent generating proof normal form sequent cut 
defined rewriting steps local reductions proof tree discrepancies flavour evaluation explicit substitutions de bruijn abadi cardelli curien vy 
typing rule explicit substitution say rose variant cut rule lot done better understand connection explicit substitutions local cut reduction procedures 
continuation presents correspondence la curry howard lk bringing various features different approaches compare urban urban urban bierman urban curien herbelin curien herbelin 
curien herbelin insist calculus urban urban analyses thoroughly things gentzen procedures defines general reduction system proofs lk strongly normalising proofs represented syntax terms 
part calculus new syntax 
try break spear sequent style approach steps development programming language cut elimination sequent calculus classical logic 
language called describes nets reduction rules join nets 
logic consider contains implication mainly initial phase aim simplicity cut elimination sequent calculi notorious great number rules increase manifold considering logical connectors 
break natural deduction paradigm comes price longer abstraction application corresponding implication modus ponens basic tools extracted language 
fact language obtain continuation style models parameter context call 
abstraction application faithfully implemented show describe behaviour functional programming languages low level granularity 
computation classical sequents language describing nets basic pieces understood components entrance exit wires ways describe connect build larger nets 
components quickly surveyed receive detailed treatment section 
call nets structures build components connected wires 
syntax sequent calculus approaches need mention girard herbelin danos schellinx danos schellinx barendregt generally connections linear logic girard 
relation call name call value fragment lk negation conjunction wadler dual calculus studied wadler calculi extensions dual calculus considers logic active formulae 
origins lie defined approach definition calculus called enjoy curry howard property gentzen sequent calculus 
starting point results 
discussions authors clear similar notations sequent calculus urban phd thesis urban 
studied relation curien herbelin calculus 
study connection reported fortuitous taken starting point investigations 
changed name calculus order avoid clash rule calculus suggests abstraction part syntax 
show detail interplay 
natural context study role context cut elimination naturally typed 
natural straightforward step extend research untyped opens possibility study relation untyped calculi express recursion fixed point construction studying normalisation normalising reduction strategies semantics 
strongly believe importance syntax better grasping concepts contributions notation intuitive readable moving infix notation insist computational aspect achieved studying context normal functional programming languages paradigms importantly cut link classical logic 
achieve studying language types way consider nets correspond proofs 
particular consider non termination nets 
fact aim study outside context classical logic way calculus studied outside context intuitionistic logic 
relation predecessors say mini ml clement lambda calculus 
van bakel lescanne fine grained operational model computation calculus model programming languages operational behaviour provided contraction 
known contraction expresses calculate value function applied parameter 
parameter instantiate occurrences bound variable body process substitution 
description basic says actual cost substitution quite high run time 
usually calculus explicit substitutions rose abadi lescanne lescanne dougherty dezani ciancaglini van bakel considered better suited accurate account substitution process implementation 
refer calculus explicit substitution intend calculus explicit substitution explicit names due rose rose 
gives better account substitution integrates substitutions class citizens decomposes process inserting term atomic actions explains detail substitutions distributed terms eventually evaluated variable level 
show level description reached explicit substitutions fact greatly refined 
reach level decomposing explicit substitutions smaller components 
level calculus explains substitutions terms interact 
calculus symmetric berardi substitution applied term term applied substitution 
interaction subtly gently term substitution direction chosen 
see kinds interaction direct connection call value call name strategies natural description ingredients syntax important note variables calculus possible places terms inserted wires called connectors occur free bound term 
calculus binding wire indicates active computation calculus binding part term involved interaction part interaction 
kinds wires sockets reminiscent values plugs corresponding variables respectively wadler reminiscent continuations 
wires supposed denote location term variables calculus 
wires seen bit ropes knotted tightened chemical bonds ropes components 
fact corresponds way practice sailing 
give specific name rope main sail port sheet modern competition rope colour sure rope appropriate encourage reader confused names class connectors called plugs names fact inherited 
computation classical sequents place appropriate rope loosening wrong rope catastrophic 
colours naturally types rope colour wire type 
specificity syntactic constructors bind wires kind bound wires receive hat show bound write whitehead russell whitehead russell 
wire bound net implies naturally wire unknown outside net interacts opposite wire bound net 
interaction differs constructor ruled basic reductions see section 
addition bound wires rule exhibits free wire exposed 
exhibition corresponds creation wire 
contents formal definitions syntax reduction rules show system behaved stating number essential properties 
define notion simple type assignment terms define system derivable judgements terms witnesses show soundness result system showing subject reduction result holds 
compare number predecessors 
fact show number know calculi easily elegantly surprisingly effectively implementable familiar problem expressibility view fact substitution free result truly novel 
possible easily naturally embed calculi way major properties preserved 
easily understood fact vast majority calculi area confluent church rosser 
tool downloaded www doc ic ac uk jr developed term graph rewriting technology allows users input nets terms calculus interpretation specified 
details implementation van bakel van bakel 
presents extended version results appeared van bakel lescanne deeply inspired urban bierman urban urban bierman urban 

calculus nets objects built kinds building stones constructors called capsule export import 
addition operator call cut handy describing net construction eliminated eventually rules 
case urban urban bierman urban fact explicit principia notations 
van bakel lescanne 
operators nets connected wires named 
description wires oriented 
means know direction ether running nets moves say wire provides entrance net wire provides exit 
distinction exit wires call plugs inputs enter wires call sockets outputs 
plugs named greek letters 
sockets named latin letters 
connecting nets operator say may suppose plug socket want bind create flow link established wires plugged name plug name socket forgotten 
precise xq name reachable outside name reachable outside reminds construction logic name known outside expressions 
names said bound 
likewise construction xq plug socket bound names bound interaction 
hat notation keeping line old tradition principia mathematica whitehead russell writing say bound 
definition syntax 
nets calculus defined grammar 
range infinite set sockets infinite set plugs 
yp xq xq illustration represent basic nets diagrammatically notice intuition sketched example connector supposed occur outside formalised definition barendregt convention see 
see sockets points nets input plugs output write inputs left output right done wadler 
justify constructions example translations huge international organisation arguments better established formalised section speak types correct framework 
course basically untyped language 
suppose wires carry words language estonian portuguese translators language language french dutch capsule connects inside socket plug 
entering capsule language leave language 
export xp seen follows provides device transforms words language received words language returned yp translator seen higher order language returned seehttp europa eu int comm translation index en htm computation classical sequents specific wire connected 
export seen diagrams compiling technology bootstrapping see aho sethi ullman section 
import xq required tries connect wires carry words different languages 
able communicate translator needed received wire socket 
operator called cut term form xq called cut term corresponds operation switch board 
cut specific just connects precisely cuts nets connecting socket plug assumes language expected agrees language delivered 
cut expresses need rewiring switch board language offer plug demanded socket dealing cut expresses need connection established cause cut eventually eliminated building connection 
calculus defined reduction rules section explains detail cuts distributed nets eventually erased level capsules 
table gives correspondence notations urban uses 
urban uses letters latin alphabet plugs sockets expresses input output behaviour calculus notation putting sockets parentheses plugs angles 
ax xp impr yq impl xq cut noted calculus input output actions consumed communication written pre fix computation runs left right urban notation brackets different meaning example impr inputs outputs actions descriptions 
notice urban notation pre fix distorts notion flow expresses impl clear interface spoke bound names introduce formally notions free sockets plugs definition 
free sockets free plugs net fs fs xp fs fs xq fs fs fs xq fs fs fp fp xp fp fp xq fp fp fp xq fp fp socket plug occurring free called bound written bs bp 
write fs fs fs 
normally adopt barendregt convention called convention variables barendregt convention names 
van bakel lescanne convention names 
term statement name bound free context 
consider example bound 
main concept name define renaming substitution name name sense define substitution name term 
definition renaming relies barendregt convention names binding say xp violates barendregt convention get back renaming yp renaming internalised see section 
definition renaming sockets plugs 
zp zq zq zq zp zp zq zq renaming play important part dealing conversion problem discuss subsection 

rules important know socket plug introduced exposed unique 
nets introduce sockets plugs play important role reduction rules 
informally net introduces socket constructed subnets contain free socket occurs top level means import middle connector capsule left part similarly net introduces plug export creates capsule right part 
say formally means terms introduce socket plug urban uses terminology freshly introduce urban 
definition 
introduces yq fs 
introduces xq fp 
computation classical sequents simple family reduction rules 
say reduce net cuts subnets introduce connectors 
naturally divided categories capsule cut capsule export capsule capsule import export import 
pattern plug introduced left socket introduced right 
definition logical reduction 
logical rules assume terms left hand sides rules introduce socket plug cap exp yp yp med zq zq exp imp yp zr yp zr illustration give representation zr notice rule exp imp addition conditions connectors active cut fp fs state fp fs due barendregt convention 
rule exp imp reader may noticed right hand sides 
right hand sides appearance non determinism noticed lafont intrinsic part cut elimination classical logic 
need define reduce cut case sub nets introduce socket plug 
requires extend syntax new operators call activated cuts 
xq xq nets cuts activated called pure representation activated cuts straightened activated cuts 
activated cuts propagated terms 
van bakel lescanne definition activating cuts 
act xq xq introduce act xq xq introduce notice side conditions valid simultaneously validating rewrite rules moment 
gives fact critical pair superposition notion reduction cause loss confluence 
define propagate activated cut sub nets 
direction activating shows direction cut propagated sets reduction rules 
definition propagation reduction 
rules propagation left propagation xp xp cap xp exp outs yq xp xp xp fresh exp ins yq xp xp imp yr xp xp xp cut yr xp xp xp right propagation cap exp yq xq imp outs yr xq xr fresh imp ins yr xq xr cut yr xq xr definition 
write compatible closure step term rewriting induced rules write transitive closure 
subscript arrow represents reduction indicate certain sub systems defined reduction strategy example write reduction uses rules left propagation right propagation 
fact reduction pushes inward 
write exists common reduct 
rules exp outs imp outs deserve attention 
instance left hand side exp outs introduced occurs yq dot occurrence dot dealt separately creating new name 
note cut associated cut pushed xp leaves net activated cut computation classical sequents resulting term yr xp needs considered entirety know introduced know thing happens imp outs new name created external cut 
lemma shows right hand side rule written right hand side rule written terms chosen 
choice reasons 
firstly operations explicit want rely operations defined meta theory 
name substitutions required put rules theory identities definition 
secondly small step approach closer philosophy tends decompose operations fine grained possible 
thirdly notice introduced yq exp outs gives lemma yq xp yq xp reduction play similar roles deactivating cuts 

call name call value section define sub systems reduction correspond roughly callby name cbn call value cbv reduction 
notice essentially different approach wadler notion reduction defined cbn cbv result obtained different interpretation functions cbn cbv calculi 
mentioned introduce introduce xq superposition meaning rules act act fired 
critical pair xq xq may lead different irreducible terms 
say reduction relation confluent 
non determinism key feature classical logic rewriting logic 
introduce sub reduction systems favour kind activating critical pair occurs 
consider term xq introduce introduce intuitively cbv tends push cbn tends way 
definition 
cut activated ways cbv strategy allows activate act write case 
reformulate reduction system obtained replacing rule act act xq xq introduces introduce cbn strategy activate cut act write likewise reformulate reduction system obtained replacing rule act act xq xq introduce introduces van bakel lescanne show basic properties essentially show calculus wellbehaved 
recall term pure contents activated cuts 
lemma cancellation 
xq fp pure 
xq fp pure 
xq fs pure 
xq fs pure 
proof 
induction structure nets 
xq cap yr yr xq exp ins xq ih yr ys ys xq imp xq xq ih ys ys ys xq cut xq xq ih ys introduces fp impossible 
introduce xq act xq result follows part 
induction structure nets 
cap yr yr exp xr ih yr ys ys imp ins xr xs ih ys ys ys cut xr xs ih ys introduces fs impossible 
introduce xq act xq result follows part 
show cut capsule leads renaming give reader opportunity see reduction give full proof 
lemma renaming 
pure 
pure 
xp pure 
computation classical sequents xp pure 
proof 
induction structure nets 
cap cap yq yq exp outs fresh exp ih yq yq yq exp ins ih yq yq yq yr yr imp ih yr xr xr cut introduces ih xr xq fp xq exp xq cap yr xr xq 
introduce result follows part 
induction structure nets 
cap cap yq yq exp xq ih yq yq yr yr imp outs xq xr ih yr med yr yr van bakel lescanne yr yr imp ins xq xr ih yr yr yr cut xp introduces xq xr ih yr yr occur free yr med yr cap yr yr yr introduce xp xp result follows part 
results motivate extension sub systems reduction rules formulating new rules shape results 
gc xq fp pure gc xq fs pure ren pure ren xp pure admissibility rules nets pure shown van bakel 

conversion normally renaming essential part conversion process renaming bound objects language avoid clashes computation 
familiar context occurs course calculus reducing term xy xy xy xy conversion essential 
section briefly discuss solution van bakel deals accurately problem example 
take reduction act imp outs exp exp imp computation classical sequents clear breach barendregt convention free bound continue reduction obtain exp notice introduced fp 
cut propagated obtain act exp outs cap exp 
correct converges introduced obtained 
clear example conversion needed extent implementation solutions problem proposed van bakel van bakel compared terms efficiency 
uses strategy avoid sharing bound connectors second enforces barendregt convention renaming bound connectors nesting created third avoids capture names allows breaches barendregt convention 
achieved changing example rule exp imp zr yp zr yp zr conflict barendregt convention generated rule fact occurs striving capture avoidance occurs free case connectors need renamed great plus points done language calculus 
fact lemma give conflict free version see 
contrast notice possible calculus 
reduction rule reducing term xy xy xy xy conversion essential 
get xy xy xy xy xy xy yy yy conflict caused fact second step right brought binder causes variables bound outer binding swap scope reducing get inner binding 
particular problem dealing conversion reduction rule substitution right hand side supposed immediate structure anonymous impossible detect conflict typically depends bindings occurring inside example step reduction term identical xy xy xy actual performance substitution brings right binder left part reduction system van bakel lescanne specified auxiliary definition substitution 
conversion difficult tackle context pure calculus 
consider substitution separate syntactic construct implies moving calculus situation slightly different say preventing conflict possibly free expensive performed substitutions abstractions detect conflict just prevents 
conflict solved detected reduction system essentially expressing free shown van bakel accurately deal conversion case capture avoidance rule exp imp needs replaced assume introduced fresh yp zr zr fs yp zr yp zr fs yp zr yp zr fp yp zr zr fp course rules need dealing 

typing sequent calculus mentioned inspired sequent calculus worthwhile recall principles 
sequent calculus consider implication structural rules changed axiom 
offers extremely natural presentation classical propositional calculus implication variant system lk 
rules axiom right arrow left cut 
ax cut knows rule cut plays major role proofs proof theoreticians proofs enjoy nice properties proof reductions cut elimination proposed gentzen 
reductions fundamental principle computation nice property proof systems known curry howard correspondence definition curry howard isomorphism 
terms proofs types propositions closed term type type read logical formula provable corresponding logic proof structure corresponds computation classical sequents isomorphism expresses fact associate term proof propositions types proof reductions term reductions computations 
phenomenon discovered combinatory logic connection calculus intuitionistic logic put evidence 
curry howard correspondence classical propositional calculus sequent calculus described 
propositions receive names appear left part sequent receive names 
appear right part sequent receive name 
notion type assignment section basic system classical logic gentzen system lk described 
curry howard property easily achieved erasing term information 
definition types contexts 
set types defined grammar types considered normally known simple curry types 
context sockets mapping sockets types denoted finite set statements subject statements distinct 
write context defined defined notice second case implies 
writing context implies defined write mean union coherent contains contains 
contexts plugs defined similar way 
definition typing 
type judgements expressed ternary relation context sockets context plugs net 
say witness judgement 
type assignment defined sequent calculus cap med xq exp xp cut xq write exists derivation judgement bottom line write want name derivation 
carry types free connectors unordered sets 
notion type derivable statement shows 
van bakel lescanne lemma weakening 
rule admissible 
proof 
proof induction proof tree 
going consider cases way 
cap holds 
med xr xr 

write write notice 
induction xr follows med 
example proof peirce law 
proof peirce law classical logic ax ax inhabiting proof gives derivation cap exp cap med exp soundness result simple type assignment respect reduction stated usual theorem witness reduction 

proof 
induction length reduction sequences show interesting base cases notice occasionally weakening 
logical rules cap computation classical sequents exp yp yp yp med zr zr yp yp zr zr zr exp imp yp zr zr yp zr yp zr yp yp zr exp imp yp zr zr zr zr propagation exp outs yq xp xp xp yq yq xp van bakel lescanne xp xp xp xp imp yr xp xp xp yr yr xp xp xp xp xp cut yr xp xp xp yr xp yr xp xp xp xp propagation imp outs yr xq xr yr yr computation classical sequents xq xr xq xr xq xr cut yr xq xr yr xq 
interpreting calculus yr xq xr xr section illustrate expressive power showing faithfully interpret calculus barendregt similar results shown urban sections show similar result 
notion curry type assignment show assignable types preserved interpretation 
part interpretation results seen variants similar results obtained curien herbelin curien herbelin 
defined mappings mappings calculus concatenating mapping encoding detailed precise deals explicit substitution 
fact show interpretation encompasses cbv cbn reduction achieved curien herbelin argue fact expressing explicit substitution 
notice curien herbelin preservation cbv evaluation cbn evaluation relies distinct translations terms 
instance cbv cbn calculus encoded cps appel jim clear accounts distinction cbv cbn encodings way cps reduces encoded terms 
contrast need separate interpretation functions define 
combining sub reduction systems encode cbn calculus 
van bakel lescanne assume reader familiar calculus barendregt just recall definition lambda terms contraction 
definition lambda terms contraction barendregt 
set lambda terms defined syntax mn terms called values 
reduction relation defined contextual compatible barendregt closure rule contraction fired value reduction called call value cbv short written confusion possible reduction name terms reductions apply syntactic category 
calculus notion type assignment corresponds nicely implicational propositional logic framework natural deduction 
rules natural deduction define manipulate logical objects called sequents form formula propositional logic set formulae 
sequent means proved axioms rules natural deduction introduce eliminate connectives right hand side proposition sequent 
instance implication introduced rule eliminated modus ponens add rule allows axiom rules form intuitionistic logic 
notice logic expressive classical logic instance rules peirce law example proved 
simulate easily sequent calculus modus ponens rule natural deduction computation classical sequents simulated short reasoning ax cut situation rule connective followed directly elimination rule traditionally called cut natural deduction van dalen 
case proof easily transformed simpler process cut elimination 
instance transformed simpler proof time axiom replace axiom proof required 
formulae propositional logic seen types functional programming especially simply typed calculus vice versa 
implication corresponds functional type inference rules intuitionistic propositional logic isomorphic typing rules simply typed calculus definition type assignment calculus 
ax mn define direct encoding calculus definition interpretation calculus 
mn observe sub term exactly free plug 
unique free plug precisely 
urban similar interpretation defined differs case states mn van bakel lescanne definition depends additional notion substitution defined recursive transformation cuts 
substitution defined manner urban interpretation ignores certain reduction paths accessible interpretation urban results shown achievable fact possible show cbn reduction modelled urban interpretation 
substitution reasoning interpretation proofs complicated proofs lose elegance 
example prove type assignment preserved interpretation substitution lemma needs shown giving involved proof achieve theorem 
possible show 
feel choice justified 
worthwhile notice interpretation function generate confluent sub calculus 
illustrate example 
notice xx med reduction unique deterministic 
write xx yy xx xx yy xx yy exp imp yy xx ren yy xx net cut activated ways notice computation classical sequents introduced 
results yy xx yy xx xx act imp xx xx cap act xx imp outs med yy xx yy xx cap cap act yy imp outs yy yy yy act cap yy yy yy imp yy yy imp cap cap act cap med notice reductions return normal forms different 
show cbn reduction calculus respected interpretation 
show substitution result 
lemma 
proof 
induction structure lambda terms 
van bakel lescanne pq ren cap exp ih pq cut imp ins cap ih cases pq introduces definition possible 
ren notice introduce act result follows part 
theorem simulation cbn calculus 
proof 
induction number steps show base case 
turn proven induction structure terms show base case need show 
exp imp ren notice reduction version exp imp computation classical sequents got result exp imp ren notice reduction reduction steps allowed notice introduces introduces rule cap exp applied 
introduce cut needs activated leading allowed rule act side conditions satisfied 
encoding cbv calculus interpretation 
notice pq redex cbv calculus 
get pq pq pq pq pq particular introduced outer cut act applied 
cbv reduction guarantee act applied propagation blocked produce pq lemma 
notice apply rule act introduces introduce case test fails 
hand value variable abstraction introduces fact value introduces 
reduced rule act rule act logical rule 
proof theorem enables reduction cbv reduction calculus respected interpretation function theorem simulation cbv calculus 
proof 
proof theorem show case notice true strategies 
reduction reduction steps allowed activation cut required application ren introduced allowed rule act show value van bakel lescanne value introduces 
proof theorem cases introduces definition possible 
ren introduce side conditions rule act satisfied get act proof theorem get lemma 
pq 
pq cuts activated get 
introduce result applying appropriate logical rule notice introduced cases reduction continue inside left hand side outermost nonactive cut 
cbv reduction allow right activation outer cut reduction returns net introduces capsule export 
case reduction lead pq results significance example clearer 
remember xx yy xx yy calculus xx yy different normal forms respect cbv cbn reduction respectively xx yy yy yy interpreted term xx yy normal form contains cuts 
true nature cbv reduction return yy yy returns term yy duplication zz waiting applied continuation 
show preserved theorem 
proof 
induction structure derivations notice weakening 
computation classical sequents ax notice cap induction derivation exists construct exp notice 
pq exists tion exist derivations construct notice pq derivation corresponds course simulation modus ponens rule discussed 
strengthen fact consider just nets represent proofs show example non terminating reduction sequence 
example reducing 
remember xx reduces follows xx xx xx xx exp imp xx xx ren xx xx xx act imp outs xx xx xx cap xx xx ren xx xx van bakel lescanne 
interpreting section interpret calculus explicit substitutions introduced rose rose reduction calculus split atomic steps computation 
show fine level atomicity simulates reduction step describing explicit substitutions interact terms 
rose introduce concept substitution syntax calculus making explicit add operator definition rose 
syntax extension calculus mn type assignment defined calculus added syntactic construct dealt cut rule ax cut mn notice cut rule enable prove sequents provable 
derive cut rule admissible replacing explicit substitution implicit explicit substitution describes explicitly process executing reduction express syntactically details computation succession atomic constant time steps order rewriting system reduction split steps 
definition rose 
reduction relation defined rules app mn abs vari gc fv notion reduction obtained deleting rule gc notion reduction obtained deleting rule 
rule gc called garbage collection removes useless substitutions 
notion cbv naturally inspired calculus 
definition call value 
just calculus term value variable abstraction 
cbv reduction argument value means simulated cbv substitutions created form value variable abstraction 
build cbv syntactic restriction computation classical sequents cbv reduction reduction generated rules definition rule applied value 
notice value introduces 
subject reduction holds see computation cut elimination process consists discarding situations elimination connective follows cut rule moving applications disappears 
definition interpretation 
define interpretation adding case explicit substitution mn notice interpretation calculus just rules 
proof theorem theorem 
straightforward extension theorem 
show reductions simulated preserving evaluation strategies 
theorem simulation rule 
cbn cbv iff value 
proof 
exp imp ren notice reduction sequence valid cbn evaluation proves point 
cbv evaluation step act possible introduces value 
proof concludes lemma 
theorem simulation rules 
rules app abs vari gc proof 
show interesting cases van bakel lescanne pq pq pq cut imp ins cap exp ren fv 
cap gc state reduction preserved interpretation terms theorem simulation 
add composition rule reduction system rule trivially breaks strong normalisation property typed terms geuvers computation classical sequents simulated 
useful reasoning equivalence 
abandon strong normalisation merge kinds cuts 
done instance setting equivalence xq xq xq 
case composition rule simulated strategies cbv cbn follows interesting issues deserves explored 

interpreting parigot calculus parigot proof term syntax classical logic expressed setting natural deduction 
extend syntax formulae constant false 
natural deduction deals classical logic allowing logical rule assumption discharged rule assumption form 
leads splitting set axioms parts assumptions discharged second assumptions discharged reasoning contradiction 
part form 
comma thought conjunction sequent 
logically equivalent multi sequent 
classical logic logically equivalent thought disjunction 
reasoning contradiction exhibits neutrality disjunction notice implicitly assume truly classical assumed may liked reasoning van bakel lescanne contradiction implication multi style sequent add rule neutrality disjunction exhibited 
parigot parigot created calculus typing system isomorphic multi logical system achieved extending syntax new constructs act witness rules discussed 
uses disjoint sets variables roman letters greek letters 
sequents typing terms form marking active 
definition terms 
terms mn definition typing rules 
type assignment defined natural deduction system main active labelled term calculus alternative labelled set greek variables 
mn think storing type alternative giving name set greek variables called set name variables 
binds notion conversion extends naturally bound names 
note weakening property interesting note included language type stay classical logic collapsing rules computation classical sequents force naming followed abstraction 
definition terms alternative definition 
terms defined grammar set values defined mn type system consider variant system study relation example illustrating fact system powerful system calculus proof peirce law due ong steward ong stewart system natural deduction style cut situations want eliminate 
rules computation definition reduction 
reduction terms defined compatible closure rules logical structural renaming erasing occur stands term obtained pseudo sub term form substituted fresh variable notation herbelin herbelin 
call value reduction defined restricting rules follows note calculus computation substitutions implicit 
definition interpretation 
define interpretation van bakel lescanne adding alternative terms mn similarly previous sections add notice alternative justified show lemma 
rule admissible proof 
ren notice similarity net mn result running difference lies bound plug 
show definition encoding substitution correct notice calculus show interpretation preserved modulo equivalence modulo reduction similar restriction holds interpretation achieved curien herbelin 
lemma 

proof 
simultaneous induction structure terms show interesting cases 
ih computation classical sequents ih ih ih ih number reverse reduction steps proof avoided defining discussed theorem 
evident case proof part give proof interpretation preserved reduction 
van bakel lescanne notice renaming erasure rules renaming reduction sequences valid cbn cbv 
show cbn cbv reduction preserved interpretation 
theorem simulation cbn 
proof 
proof induction length reductions sequence show base case need focus rules 
theorem 
cases lemma know notice introduced 
separate cases introduced notice zn zn occur notice introduced reduces lemma notice computation classical sequents lemma know introduced reduces lemma notice cbv block right propagation cuts interpreted term left value 
calculus achieved noticing value interpretation introduces interpretation term value introduce plug 
notice holds interpretation incorrect right activation excluded cbv preserved 
notice define introduced longer case values interpreted values 
imply cut right activated left hand term reduced value directly represent contraction cbv redex 
problematic show interpretation correct modulo need show interpretation redex reduces interpretation contractum just share common reduct 
case show theorem simulation cbv 
show types preserved interpretation theorem 

proof 
proof theorem need focus rules dealing abstractions 
assume induction 
alternative similar 

interpreting typed version proof term syntax classical sequent calculus 
proposed variant classical sequent calculus curien herbelin calculus curien herbelin 
interesting relate formalisms realize interpreted 
van bakel lescanne calculus curien herbelin sets variables 
label types hypotheses 
label types 
syntax different categories commands terms contexts terms 
correspondingly typed kinds sequents usual sequents type commands sequents typing terms resp 
contexts form resp 
marking resp 
hypothesis active 
definition commands terms contexts 
commands contexts terms respectively bind usual consider terms contexts commands conversion writing way satisfying barendregt convention 
context variable complex typing rule introducing left hand side sequent commands fill hole context term 
definition typing 
cut ax li ax ri note type context type term expected order fill hole import circuit conventional notations contexts thought 
see term context built introducing right hand side left hand side sequent just activating hypothesis sequent typing command inherited parigot parigot thought proofs simplified commands computed eliminating cuts computation classical sequents definition reduction 
system critical pair applying case rule gives callby value evaluation applying rule gives call name evaluation 
interesting see system rules confluent connected fact cut elimination classical sequent calculus 
herbelin calculus expresses elegantly duality lk left right symmetrical syntax 
duality goes instance symmetry reduction rules display syntactically duality cbv cbn evaluations see wadler 
call value reduction obtained forbidding reduction redex redex call name reduction forbids reduction redex redex 
show accounts duality 
duality notwithstanding fully represent lk 
lk proof lk lk lk lk lk cut lk inhabited left hand side rule exp imp reduces lk lk lk lk lk lk lk lk lk lk lk lk result represented normal reduction system second represented right hand sides rule exp imp 
show exists obvious translation definition translation 
xp yq xq 

fact origin curien herbelin curien herbelin give hint way connect lk lk 
proofs lk embed lk considering sub syntax van bakel lescanne typing rules correspond respectively axiom rule right left rule cut 
discovered corresponded directly urban approach urban discussed approaches differ significantly 
fact sub syntax expressive 
contrary logical side proofs sequent considered differently lk just naming formulae activation deactivation formulae done way 
consider proofs differences equivalence classes unique proof class eagerly naming formulae deals 
concrete terms translation preserves typing definition translation 
example 
lescanne shown peirce law inhabited term term normal form reduction translation term ong stewart see section typeable follows remove term information derivation obtain semi proof peirce law classical logic 
computation classical sequents notice activation steps abstractions derivation correspond logical rule 
means provable judgements inhabited derivations correspond proofs 
translation function term obtain notice process obtained translation cuts removing produces side reduction sequence 

term exactly example 
interpretation function preserves lemma 



proof 
straightforward simultaneous induction structure derivations 
show simulate implicit substitution lemma 
proof 
simultaneous induction structure nets 
likewise show lemma 
van bakel lescanne strengthen results stating simulation preserves evaluations theorem simulation 
proof 
induction length reduction sequence show base cases lemma 
lemma 
notice defined shown implies fact show theorem 
curien herbelin define encodings respectively definition curien herbelin 
interpretation interpretation defined follows mn mn corresponds right left call value relates left right call value 
curien herbelin result computation classical sequents theorem simulation curien herbelin 
expansion 
expansion 
theorem holds restriction traditional calculus restriction expansion 
disappointed preservation cbv evaluation cbn evaluation relies distinct translations terms 
accounts distinction cbv cbn encodings distinction cbv cbn relies curien herbelin distinct encodings features 
holds wadler 
intuitive apparently need twist complex way order give accurate interpretation cbv calculus show lemma 
proof 
induction structure terms interesting case np ih np result bit disappointing cbn encoding turns refined cbv encoding 
course theorem lemma 
mv mn show take simplest translation cbv cbn evaluation strategies reflects distinction 
show interpretation refined composition lemma 
mn 
proof 
induction structure terms xn ih van bakel lescanne pq pq 
qn ren pn qn pn qn pn qn ih pq seen continuation style formal language provides curry howard isomorphism sequent calculus classical logic 
interest seen suited generic machine running applicative programming languages building interpretation wealth research lies step seed 
intend study strong normalisation confluence cbn cbv strategies extend order represent logical connectives study relation linear logic typed untyped express recursion functions details implementation tool van bakel van bakel 
polymorphism introduced summers van bakel encoding connectors summers interpretation van bakel 
relation currently investigation 
alexander summers daniel harry mairson jamie gabbay luca cardelli luca maria dezani ciancaglini philippe ronchi della rocca fruitful discussions topic 
especially grateful st phane stood start research kindly integrate papers 
abadi cardelli curien 
vy 

explicit substitutions journal functional programming 
aho sethi ullman 

compilers principles techniques tools addison wesley 
appel jim 

continuation passing closure passing style proceedings th acm sigplan sigact symposium principles programming languages acm press pp 

ariola herbelin 

minimal classical logic control operators baeten computation classical sequents lenstra parrow woeginger eds icalp vol 
lecture notes computer science springer pp 

ariola herbelin sabry 

type theoretic foundation continuations prompts proceedings ninth acm sigplan international conference functional programming icfp snowbird utah september acm pp 

van bakel 

understanding 
consistent interpretations sequent calculus natural deduction 
submitted 
van bakel lescanne 

language circuits computations classical logic coppo eds proceedings ninth italian conference theoretical computer science siena italy vol 
lecture notes computer science springer verlag pp 

van bakel 

implementing electronic proceedings second international workshop term graph rewriting rome italy electronic notes theoretical computer science 
van bakel 

capture avoidance garbage collection third international workshop term graph rewriting vienna austria 
berardi 

symmetric lambda calculus classical program extraction information computation 
barendregt 

lambda calculus syntax semantics revised edn north holland amsterdam 
barendregt 

lambda terms natural deduction sequent calculus journal functional 
geuvers 

explicit substitution edge strong normalisation computing science reports eindhoven university technology box mb eindhoven netherlands 
appear theoretical computer science 
rose 

preservation strong normalisation named lambda calculi explicit substitution garbage collection csn computer science netherlands pp 

url ftp ftp diku dk diku semantics papers ps de bruijn 

lambda calculus facilities internal definition expressions segments th report technological university eindhoven netherlands department mathematics 
clement 

simple applicative language mini ml technical report inria centre sophia antipolis france 
curien 
herbelin 

duality computation proceedings th acm sigplan international conference functional programming icfp acm pp 

corrected version available inria fr herbelin icfp duality errata ps gz van dalen 

logic structure springer verlag 
danos 
schellinx 

computational isomorphisms classical logic extended electronic notes theoretical computer science 
danos 
schellinx 

new logic linear logic journal symbolic logic 
gentzen 

untersuchungen ber das logische mathematische zeitschrift 
english translation szabo pages 
lescanne 

classical proofs typed processes intersection types berardi coppo damiani eds types 
forthcoming lecture notes computer science 
girard 

linear logic theoretical computer science 
van bakel lescanne girard 

new logic classical logic mathematical structures computer science 
griffin 

formulae types notion control proceedings th annual acm symposium principles programming languages orlando fla usa pp 

herbelin 

qu de interpr tation du calcul des comme calcul de termes comme calcul de strat gies th se universit universit paris 
herbelin 

est qu au ur de la de habilitation universit paris 
krivine 

classical logic storage operators second order lambda calculus ann 
pure appl 
logic 


computational interpretation cut rule classical sequent calculus master thesis mathematical institute computing laboratory university oxford 


call value call name strong normalization classical sequent calculus gramlich lucas eds post proceedings rd workshop reduction strategies rewriting programming wrs vol 
electronic notes theoretical computer science elsevier 


normalisation equivalence proof theory type theory phd thesis university paris vii university st andrews 
lescanne dougherty dezani ciancaglini van bakel 

intersection types explicit substitutions information computation 
lescanne 

journey calculi explicit substitutions boehm ed proceedings st annual acm symposium principles programming languages portland usa acm pp 

ong 
stewart 

curry howard foundation functional computation control proceedings th annual acm symposium principles programming languages paris france pp 

parigot 

algorithmic interpretation classical natural deduction proc 
int 
conf 
logic programming automated reasoning lpar vol 
lecture notes computer science springer verlag pp 

summers 

computational representation classical logical connectives 
nd international workshop developments computational models dcm venice italy 
summers van bakel 

approaches polymorphism classical sequent calculus sestoft ed proceedings th european symposium programming esop vienna austria vol 
lecture notes computer science springer verlag pp 

szabo 
ed 

collected papers gerhard gentzen studies logic foundations mathematics north holland 
urban 

classical logic computation phd thesis university cambridge 
urban 

strong normalisation gentzen cut elimination procedure proceedings typed lambda calculus applications tlca vol 
lecture notes computer science pp 

urban bierman 

strong normalisation cut elimination classical logic informaticae 
wadler 

call value dual call name proceedings eighth acm sigplan international conference functional programming pp 

whitehead russell 

principia mathematica nd edn cambridge university press 
whitehead russell 

principia mathematica cambridge mathematical library nd edn cambridge university press 
computation classical sequents appendix rules order rules recall 
give admissible rules 
logical reduction left propagation right propagation cap exp yp yp med zq zq exp imp yp zr yp zr xp xp zr cap xp exp outs yq xp xp xp fresh exp ins yq xp xp imp yr xp xp xp cut yr xp xp xp cap exp yq xq imp outs yr xq xr fresh imp ins yr xq xr admissible rules cut yr xq xr gc xq fp pure gc xq fs pure ren pure ren xp pure 
