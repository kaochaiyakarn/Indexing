runtime verification concurrent haskell programs volker rwth aachen university aachen germany frank huch christian albrecht university kiel kiel germany article model checking techniques debug concurrent haskell programs 
ltl formulas specifying assertions properties verified runtime 
run falsifies formula detected debugger emits warning records path leading violation 
possible dynamically add formulas runtime giving degree flexibility available static verification source code 
give comprehensive example new techniques detect lock reversal concurrent haskell programs introduce template mechanism define ltl formulas ranging arbitrary set threads communication abstractions 
key words runtime verification ltl checking haskell today larger software application longer sequential program entire concurrent system varying number processes 
processes share resources adequately protected concurrent access 
usually achieved concentrating actions critical sections protected semaphores 
semaphore taken process wishing take suspended semaphore released 
combining semaphores easily lead situations deadlock occur 
record trace actions leading event crash program give developer useful advice try debug error 
limit recording events semaphores 
useful unique markers program detailing periodically position state preprint submitted elsevier preprint august current run 
technique resembles hello debugging show traces offer added value runtime verification running program means runtime verifier embedded system 
usually interested conditions hold specific places entire execution program 
properties easily determined verified compile time possible verify possible paths program execution 
violation conditions detected post mortem analysis runtime intensive testing 
especially aggregate information runs detect behaviour lead crash indicates condition violated subsequent runs 
regularly case program behaviour dependant scheduling external input 
properties interested necessarily classic model checking properties liveness fairness properties program known developer hold certain times 
commonly called assertions verified additional code placed ambitious programmers appropriate locations source usually removed delivering product increase program size runtime 
temporal logic linear time logic ltl lends naturally describing properties depending changing states program time 
formulas evaluated false program execution 
system allows dynamic addition new formulas hold system evolves 
show employ technique specifying formula verifying runtime significant help testing concurrent haskell programs 
additionally system records path leading state property violated aids developer debugging program 
article structured follows section gives brief haskell technique recording traces debugging 
section provides background ltl describes ltl runtime verifier 
section shows sample verification lock reversal problem general solved templates introduced section 
section concludes presents 
tracing haskell programs remind reader purely functional lazy programming language haskell 
extensive debugging haskell see comparison focus difficulties debugging evaluation expressions lazy functional language evaluation deferred value required subsequent calculations 
leads evaluation order easily derived program source code feasible single step program execution java 
limit debugging io behaviour haskell programs monad omit problems resulting haskell lazy evaluation strategy 
especially interested extension concurrent haskell integrates concurrent lightweight threads haskell io monad 
threads communicate different schedules lead different results 
communication take place means mvars mutable variables 
mvars take role semaphores protecting critical sections especially interesting analyse 
io monad threads create mvars read values mvars takemvar write values mvars putmvar 
thread tries read empty mvar write full mvar suspends mvar filled respectively emptied thread 
mvars simple semaphores assure mutual exclusion simple inter thread communication 
mvars higher level communication objects built scope 
developed tool visualising communication concurrent haskell threads called concurrent haskell debugger possible explicitly manipulate scheduling threads 
debugger able replay recorded concurrent executions bug techniques 
simple example consider small client server application implemented concurrent haskell server client req takemvar putmvar putmvar req takemvar server req client main forkio client forkio client server notation example syntactic sugar haskell io monad 
user familiar haskell just read sequence actions parallel assignment 
comments start 
action needed debugging purposes explained 
system consists server clients 
server provides counter accessed incremented client requests 
client sends request mvar server responds mvar answer contains request int current value counter 
mvars globally communication synchronisation server clients 
recursive call server increments state request 
system initialised main creating empty mvars forking client threads 
main thread switches server 
example motivates approach run time verification 
view program fulfils property client sends request client receives answer contains current counter state server 
want check property means run time verification 
step add atomic state propositions system identify relevant points execution 
insert action takemvar action client definition 
execution action global state proposition valid 
necessary condition execution system properties occur answer belongs corresponding request developing variety algorithms checked execution provide general purpose checker powerful logic ltl 
programmer may specify properties means data type ltl add ltl assertions program point 
example sensible add ltl assertion check program 
formula expresses state system globally valid state propositions 
assertion named activated execution check 
discuss embedding ltl concurrent haskell section 
running program shows property violated 
asserted ltl property hold race condition 
background record trace performed concurrent actions replayed means concurrent haskell debugger 
helps user understand reason bug 
trace produced overloading concurrent haskell function writes trace output file similarly 
small system bug results scheduling execution client interrupted scheduler directly sending request 
servers answers request 
client sends request reads answer mvar obtains response request client 
program corrected generating fresh answer mvars request submitting server request 
model checking ltl linear time temporal logic ltl subset computation tree logic ctl extends propositional logic operators describe events computation path 
operators ltl meaning property holds step eventually hold state globally state path holds combines properties sense hold holds 
semantics ltl defined respect paths kripke structure transition system states labelled atomic propositions ap 
path semantics ltl defined follows definition path semantics ltl ap set atomic propositions 
infinite word atomic propositions 
ap called path 
path satisfies ltl formula cases iff iff iff iff 
iff 

operations defined terms ff tt ff tt example consider formula valid path 
valid path 
path 
definition path semantics easily derive equivalence equivalence easy implement checker successively checks formula path 
runtime verification traditional model checking complete state space derived specification possible paths checked 
reasons formal verification practice real programs specification derived source code checked 
usually involves parsing source additional annotations comments 
furthermore model checking applicable large systems state space explosion 
cases system may infinite state space model checking problem undecidable 
runtime verification need state space simply tracks state changes running program 
limits verifying formula holds path program takes 
means errors detected current run may state space program 
various runs different paths may necessary find path violates formula 
runtime verification enables understood formal techniques systematic validation concurrent systems 
atomic propositions state set deleted explicitly program necessary statements introduced developer tool derived sort specification 
implementing ltl haskell section sketch rough details ltl runtime checking engine 
haskell ltl formulas simply implemented algebraic data type data ltl prop atomic proposition tt true ff false ltl ltl negation ltl ltl ltl ltl release ltl ltl ltl ltl allow arbitrary types atomic propositions 
ltl polymorphically defined type variable define disjunction release operator model checking approaches dual operator deal negation pushing negations front atomic propositions 
similarly definition handle abbreviations phi tt phi phi phi checking engine separate thread maintains global state atomic propositions ltl formulas checked 
accepts requests user program modify set valid atomic propositions 
ord prop io extend respectively restrict set valid atomic propositions 
check ord string ltl io adds new formulas pool formulas runtime 
step message produced concurrent action causes check thread evaluate active formulas respect currently holding atomic propositions 
evaluation formula different results map data type bool ltl left true formula proven removed pool 
ii left false verification failed 
case condition coincide program crash user want proceed check remaining formulas 
iii right step formula reduced true false 
new formula checked remaining path 
evaluation function called check thread follows due lack space restrict basic propositions operator ord ltl set bool ltl left elem phi psi phi case psi left true left true left false case left false left false left true right right phi right phi right psi case left false right psi left true right psi right phi right psi phi ord haskell class constraint type atomic propositions stored set ordering propositions defined 
haskell type union arbitrary types 
underlying types identified constructors data left right cases outer case expression build new formula checked step 
model checking know finite set formulas occur 
avoid multiple checking equal formulas resulting nested fixed point operators check thread stores formulas checked set 
verifying concurrent programs long process generating debugging trace verification interpretation debugging trace clear 
new entry trace corresponds transition kripke structure 
happens allow process manipulate global state 
consider example processes want set different proposition unaware process see 
states processes aligned time axis wrong assume proceed lock step 
concurrent haskell interleaving semantics join propositions processes obtain model 
notice path resembles possible execution order haskell 
left branch indicates process step right branch corresponds step process 
transition leaving state possible step processes reached final state final propositions underlined 
fig 

separate state spaces fig 

interleaved state spaces interleaving clear explicitly formula fixed point operator changes propositions relevant formula may affect evaluation 
enforce implementation hiding constructor programmer haskell module system 
ltl check assertions section simple application ltl runtime checker 
example set single atomic proposition means 
useful set propositions period time represent thread critical section 
function defined sequence step 
step messages check engine thread automatically generated extended versions concurrency actions 
consider concurrency actions system steps calculations independently time take interpreted steps state space 
permissible computation affect concurrent system long result communication 
executing program containing specified bug giving time favourable scheduling runtime verifier program soon formula falsified 
furthermore prints message formula falsified stores trace concurrent haskell debugger 
example application lock reversal section discuss implement complex check ltl runtime verifier locks taken specific order release steps debugger warn user uses locks swapped order lock reversal concurrent programs mean processes deadlock execution scheduled unfortunate order 
warning adequate possible construct program takes locks reverse order deadlock 
achieved adding lock called gate lock program assures mutual exclusion prevents system 
algorithm avoids kind false warnings presence gate locks detailed 
particular technique noticing inadvertent lock reversal runtime employed development phase freebsd operating system kernel name witness 
technique java pathfinder model checker java applications 
consider concurrent processes competing repeatedly locks possible acquire locks go locks obtained sequentially 
assume process tries obtain order second see sooner system ends state process holds lock waits available process holds waiting 
situation exactly circular holding pattern indicates deadlock cf 
chapter 
small programs bug easy spot 
larger applications conclude hard prevent error simply source code 
testing program error occur various runs 
example may possible process executed interleaved sequential manner 
debugging concurrent haskell programs provide algebraic data type contains threadid corresponding thread formulas contain thread expressions 
additionally record name mvar held 
data type predefined atomic propositions 
automatically set released concurrency actions follows takemvar threadid putmvar threadid strategy applied concurrency functions 
approach program generate trace containing propositions possibly order indicating erroneous behaviour 
detect warn developer application potential enter deadlock certain conditions 
give sample ltl formula locks evaluate false case locks reverse order 
notice provide fixed lock names haskell program detect specific situation 
section see solve elegantly templates usually impractical dynamic system generate formulas 
algebraic data type assertion write holds pi lx formula process holds lock effect globally check formula step program holds pj lx holds pj ly holds pj lx holds pj ly 
better understanding formula consider program main take check lock takemvar phi takemvar putmvar putmvar take helper function phi program executed formula passed verifier 
overloaded invocations trigger statements model checker instrumented putmvar internally 
current state contains properties effect 
take function invoked set corresponding proposition execute transition ltl checker takemvar formula evaluated current state holds la holds lb reduced holds lb holds la holds la holds lb 
stepping formula mvar see new state holds la holds lb evaluates true turn gets negated invalidates formula 
model checker determined specified property hold current path acts accordingly prints warning user 
formula templates previous section static formula demonstrate mechanism 
dynamic system mvars may generated fly impossible generate formulas 
able manage problem elegantly introduce templates 
templates contain free variables instantiated properties occurring program run 
includes instantiating new formulas new proposition 
ideally able specify template problem form observe process lock holding lock install formula invalidates iff process takes reverse order rephrase ltl holds pi lx holds pi ly holds pi lx holds pi ly holds pj ly holds pj lx holds pj ly holds pj lx implementing haskell mean devising new syntax writing different ltl front formula template easily captured algebraic data type ltl syntax extended new proposition 
far easier real haskell function gets passed currently known propositions time new proposition set time decides instantiate formula 
haskell guarded expression syntax closely resembles syntax including additional conditions 
possible type system collect functions different arities data structure necessary implementation template mechanism simple trick propositions single type template function simply takes list propositions argument 
template engine generate possible permutations required length propositions pass function 
propositions unsuitable template function returns ltl formula returned just 
haskell function implements proposed template ord prop ltl just phi phi pattern matching extract arguments list parameters discard rest placeholder 
arguments second definition tells template engine propositions unsuitable instantiation returning 
template received actual content tested additional constraints guard tests really instantiating pattern different threads different locks required mathematical specification 
possible variable multiple times pattern matching expression prolog fresh variables thread lock explicitly test guard variables coincide 
tests succeed saved expressions build formula 
notice template instantiated time different propositions fulfilling necessary requirements set program 
point add instantiated formula formulas checking starting current state 
observe modifications example ordering arguments template instantiated leading redundant formulas formula commutative 
optimise generation permutations new proposition set generate new permutations maintaining list propositions 
predefined haskell data type defined follows data just partial instantiation formulas including possible formula evaluates true false requiring arguments action leading required proposition proposition invalidated formula 
temporal formulas instantiate template sufficient number arguments partial instantiation template instantiate left hand side implication soon appropriate arguments 
partial formula evaluated stepped time 
case left hand side implication evaluate false rendering remainder formula redundant 
actual implementation doing partial instantiation evaluation leads complex bookkeeping projecting feature haskell partial application implement function returning unsuitable propositions new partially instantiated formula requiring arguments complete formula 
newtype tf new data type templates prop ltl ord prop ltl just left tf xs xs return anonymous function partial application ord prop ltl just right phi phi partial instantiation allows avoid testing huge amount argument combinations fraction arguments positions valid 
just second set arguments generated providing enormous benefit example 
general worst case behaviours equal previous behaviour plain templates 
system additionally offers ability record entire trace program configurable trailing part thereof check new formulas trace 
course amount memory storage required keeping trail prohibitive programs 
stepping partially instantiated templates supported version 
related debugging framework concurrent haskell records way points program execution allows developer trace particular path program concurrent haskell debugger draw erroneous behaviour 
conditions hold program execution specific times expressed formulas lineartime temporal logic ltl 
debugging trace provides state transition annotations checked ltl model checking engine set formulas 
addition specific debugging modules developer explicit annotations add information debugging trace 
debugger supports printing tail trace point started proving particular formula turned false 
furthermore extend previous powerful template mechanism allows dynamic instantiation formulas exact propositions known parameterised mvars 
approaches runtime verification exist especially java 
java pathfinder instrumentation java virtual machine able collect data problematic traces run traditional model checking algorithm 
java picks idea runtime verification uses maude rewriting logic tool implement past time ltl 
approaches require components haskell library self contained 
java offers called error pattern analysis user implemented algorithms 
compaq visual threads debugger posix threads applications allows scripted rule verification 
temporal rover checks time dependent specifications handles assertions embedded comments source source transformation 
intend integrate information ltl checking graphical concurrent haskell debugger provide comprehensive debugging facility concurrent haskell 
effect runtime verification performance memory requirements examined larger examples 
expect profit inherent sharing sub formulas choice lazy functional programming language 
information library ltl runtime verification www informatik rwth aachen de haskell 
pnueli 
temporal logics programs 
proceedings th ieee symposium foundations computer science pages 
silberschatz 
operating system concepts 
addison wesley th edition 
huch 
debugger concurrent haskell 
proceedings th international workshop implementation functional languages madrid spain september 

temporal rover atg rover 
visser havelund brat park editors spin model checking software verification th international spin workshop volume lecture notes computer science pages stanford ca usa august september 
springer 
havelund ro su 
java runtime verification tool 
proceedings th international symposium artificial intelligence robotics automation space montreal canada june 
baldwin 
locking multithreaded freebsd kernel 
samuel leffler editor proceedings february san francisco california usa 
usenix 

runtime checking multithreaded applications visual threads 
visser havelund brat park editors spin model checking software verification th international spin workshop volume lecture notes computer science stanford ca usa august september 
springer 
peyton jones haskell report 
technical report www haskell org 
peyton jones gordon finne 
concurrent haskell 
conference record popl rd acm symposium principles programming languages pages st petersburg beach florida 
clarke jr grumberg peled 
model checking 
mit press cambridge massachusetts 
havelund 
runtime analysis guide model checking java programs 
visser havelund brat park editors spin model checking software verification th international spin workshop volume lecture notes computer science stanford ca usa 
springer 
clavel dur eker lincoln mart oliet meseguer quesada 
maude system 
proceedings th international conference rewriting techniques applications rta volume lecture notes computer science trento italy july 
springer 
runciman wallace 
hat hood comparative evaluation systems tracing debugging lazy functional programs 
koopman editors proceedings th international workshop implementation functional languages ifl volume lecture notes computer science 
huch 
runtime verification concurrent haskell progress 
proceedings th international workshop functional constraint logic programming technical report ii universidad polit cnica de valencia spain 
visser havelund brat park 
model checking programs 
proc 
ase th ieee international conference automated software engineering 
ieee cs press september 

