bugnet continuously recording program execution deterministic replay debugging satish gilles brad calder significant time spent companies trying reproduce fix bugs occur released code 
assist developers propose bugnet architecture continuously record information production runs 
information collected crash program developers working execution environment deterministically replay instructions executed crash 
bugnet insight recording register file contents point time recording load values occur point enable deterministic replaying program execution 
bugnet focuses able replay application execution libraries uses operating system 
approach provides ability replay application execution context switches interrupts 
bugnet obviates need tracking program interrupts dma transfers required complex hardware support 
addition bugnet require final core dump system state replaying significantly reduces amount data sent back developer 
decades witnessed exponential growth processor performance 
sophisticated software systems built leverage performance growth unfortunately cost software reliability 
tandem os lines code windows xp lines code 
unfortunately software engineering verification techniques complex software system undergoing rigorous quality assurance bound bugs 
addition explosion internet trivial distribute software patches encouraged vendors rapid release schedules results released software bugs 
tracking fixing bugs released software nightmare costing significant amount time money 
main difficulty lies able reproduce bug developer site 
current debugging systems rely core dump represents final state system crash 
unfortunately solution inadequate difficult determine source error responsible program state department computer science engineering university california san diego satish calder cs ucsd edu proceedings nd international symposium computer architecture isca ieee represented core dump 
solution problem provide architecture support capture information production run developer deterministically replay program execution happened moments program crashed 
deterministic replay debugging drd ability replay exactly sequence instructions led bug 
believe drd effective way isolate source problem fix 
flight data recorder fdr system proposals architecture enable drd 
fdr builds top 
checkpointing scheme provide reliability shared memory multiprocessor systems 
fdr employs additional hardware track data races program interrupts dma accesses required deterministic replay full system checkpoint 
information recorded fdr possible replay entire system execution includes interrupt handler system call routines addition user code 
architecture focused continuously tracing program execution called bugnet 
bugnet focuses deterministically replaying instructions executed user code shared libraries 
significant number application level bugs replayed approach attractive software development tool 
bugnet focuses application level bugs replay full systems execution fdr 
bugnet allows replaying interrupts system calls log sizes generated amount hardware significantly fdr focus application level bugs 
related microsoft dr watson tool mozilla examples current solutions gather analyze reason program crash 
tools collect information represent final snapshot execution state program crashed 
crash reports utility highly desirable ability exactly replay sequence instructions executed crash 
example replayer de 
built software debugger logs information enable go back time repeatedly re execute program sequence instructions 
checkpoint schemes enable replaying prior uses form checkpointing 
body prior various checkpointing schemes designing checkpoint restart cpr systems improve reliability 
encountering fault transient error hardware software error system rollback previous checkpoint continue execution thereon 
purpose checkpointing schemes cpr systems provide mechanism retrieve consistent full system state execution continued error 
usually involve mechanisms retrieve full system state checkpoint 
cpr done os support hardware support 
fdr adopts checkpoint mechanism retrieve consistent full system state corresponding prior instance time 
additionally records inputs coming system interrupts dma transfers enable replaying 
recorded information starting retrieved full system state original program execution replayed 
checkpointing scheme propose retrieve consistent full system state 
concentrates just tracking input program read load instructions 
show information record register state checkpoint sufficient replay instructions executed 
checkpoint scheme recreate consistent full system state suitable checkpoint restart systems useful reproducing application level bugs 
deterministic replayers debugging multithreaded applications past studies deterministic replayers goal provide support debug multithreaded applications 
software deterministic replayer records memory access order hardware assisted version bacon goldstein 
amount information needs logged record memory access ordering reduced applying transitive properties 
assumes multithreaded application running single processor limit amount recording just scheduler decisions 
alternative just record control flow threads 
proposals record necessary information detect data races 
logs synchronization races races detected offline analysis 
eraser takes slightly different approach tries find errors arising due incorrect usage locks shared variables 
provides approach rolling back replaying execution thread level speculation support 
detection data races rollback previously logged checkpoint replay execution 
flashback provides lightweight os support fine grained rollback replaying program execution 
proceedings nd international symposium computer architecture isca ieee opposed techniques fdr provides complete history happened program crash enables deterministically replay program execution 
needed order communicate back developer trace faithfully reproduce problem 
architecture support debugging great interest providing support enable better software reliability correctness 
provides sophisticated debug applications 
associates tags memory locations locations accessed specific function executed perform monitoring 
proposals provide architectural support catch memory violations dynamically program execution 
architecture support efficiently implementing breakpoints offline debugger discussed corliss 
flight data recorder goal fdr provide architectural support collecting information enable deterministically replay second full system execution crash 
fdr strives replay full system having support replay interrupts system call routines 
contrast bugnet limits focus replaying execution user code shared libraries deterministically replay application interrupts 
fdr continuously records kinds information checkpoint fdr uses checkpoint mechanism retrieve consistent system state start replaying execution 
interrupts external inputs order perform deterministic replay fdr records interrupts memory mapped dma transfers 
memory races support debugging data races multithreaded applications shared memory access ordering recorded additional memory race buffer mrb 
combined sizes logs needed replay fdr mb 
hardware complexity fdr collect required information enable full system replay mb chip hardware mb main memory space 
addition final snapshot entire physical memory image communicated developer order gb depending memory footprint application main memory sizes 
bugnet focuses just capturing application level bugs amount information needs recorded replay significantly reduced 
addition smaller trace sizes encourage users network bandwidth constraints communicate trace back developer 
bugnet architecture bugnet provides architecture support record information deterministically replay window instructions preceding program crash 
give overview architecture discuss component detail 
pc registers pipeline dictionary control cache coherence controller checkpoint buffer cb bugnet architecture 
memory mrb main memory bugnet architecture overview goal bugnet record information needs communicated back developer enable deterministic replay debugging 
fdr limit focus replaying just user code shared libraries enable debugging application level bugs 
bugnet supports deterministic replay interrupts system calls developer able analyze goes execution interrupts systems call routines 
bugnet new checkpoint created checkpoint interval allow execution replayed starting instruction interval 
checkpoint interval represents window committed instructions captured checkpoint logged 
tracing maximum size number committed instructions specified checkpoint interval 
limit reached new checkpoint interval initiated checkpoint prematurely terminated encountering interrupt context switch 
checkpoint interval information recorded log start replay program execution start checkpoint interval 
bugnet built observation program execution essentially driven values read executing load instructions 
order replay checkpoint interval needs record just initial register state record values load instructions executed interval 
checkpoint interval memory values modified interrupts especially interrupts dma transfers 
addition case shared memory multithreaded programs shared memory modified threads checkpoint interval 
logging load values ensure recorded information required deterministic replay including memory values updated interrupt handlers threads shared memory processor 
represents major components bugnet architecture 
components shaded gray new additions baseline architecture 
bugnet operates creating checkpoints checkpoint intervals 
start checkpoint interval snapshot architectural state proceedings nd international symposium computer architecture isca ieee recorded checkpoint buffer cb 
recorded architectural state includes program counter register values 
initialization load instruction executed new log entry created record load value stored cb 
recording result value load instruction clearly expensive 
note load value needs recorded access memory location checkpoint interval 
result value loads trivially generated replay 
associate bit word cache identify temporal hits recorded 
applying optimization special care needs taken handle interrupts shared memory accesses remote threads 
memory address modified external entities sure load address logged 
order optimize trace size employ dictionary compressor shown exploits frequent value locality load values 
log contains load values initial architectural state information checkpoint interval referred load log fll 
information recorded fll checkpoint interval sufficient replay interval 
allows re execute instructions exactly input output register memory values original execution 
true case multithreaded programs fll thread contains necessary information replay thread independent threads 
order debug data races threads need record synchronization information reproduce ordering memory operations threads 
memory race buffer mrb record synchronization information building approach fdr kept memory race logs mrl 
cb mrb fifo queues memory backed allow collection larger logs stored dedicated hardware buffers 
operating system provides support managing memory space needs allocated bugnet 
goal continuously log program execution memory overwriting older logs memory dump logs disk bug 
memory contain logs corresponding multiple consecutive checkpoints logs different threads 
allocated memory space fills logs corresponding oldest checkpoint thread discarded 
kept memory threads traced replay tens millions instructions execution thread 
developer interested replaying instructions determine cause bug 
number instructions replay window captured bugnet 
replay window number instructions replayed thread sequence 
operating system detects program encountered fault terminating application records instruction count current fll program counter faulting instruction current fll stores logs collected application persistent storage device 
logs sent back developer debugging 
checkpoint scheme checkpointing program execution divided multiple checkpoint intervals interval length specified terms number instructions executed 
program interval current checkpoint terminated new created 
addition interrupts system calls terminate checkpoint interval describe 
fault execution terminate checkpoint interval initiate collection logs sent back developer debugging 
new checkpoint recorded creating new fll checkpoint buffer cb initializing checkpoint interval fll header information process id thread id required associate fll thread execution created 
program counter register file contents needed represent architectural state checkpoint interval 
information replayer initialize architectural states replay program execution recorded load values 
checkpoint interval identifier id identify checkpoint interval mrl corresponding fll 
timestamp system clock timer checkpoint created 
useful ordering collected thread time creation 
checkpoint interval created id generated provide unique identifier interval 
id incremented new checkpoint interval created 
number bits counter id dependent maximum number checkpoints reside memory instant time 
counter set zero overflows 
fll getting initialized information appended output values load instructions executed checkpoint interval 
tracking load values checkpoint interval load accessing memory location needs logged access memory location 
values loads re generated replay 
logging just loads memory location significantly reduce number load values need recorded 
order optimization associate bit word caches 
start checkpoint interval bits cleared 
load accesses word bit set load value logged checkpoint buffer bit turned 
bit set word cache implies value word logged load accesses need logged 
proceedings nd international symposium computer architecture isca ieee approach adapted fdr 
fdr goal track checkpoint interval store particular location log value overwritten 
focus stores store values repair final core image retrieve memory state start checkpoint interval 
bugnet access particular memory location store set bit log value store 
load accesses memory location logged bit set 
store values logged mechanism works stores generated execution instructions replay 
cache block replaced cache load bits associated words cache block cleared 
logged values addresses blocks evicted block brought back addresses accessed 
bits cache initialize load bits cache bringing block 
block evicted load bits stored load bits cache 
load optimization effective long checkpoint intervals 
greater number loads stores executed higher probability memory location logged 
result amount information recorded replay instruction decrease longer checkpoint intervals 
replay need determine value load instruction recorded log 
recorded load executed replay needs get value fll 
recorded certainly access memory location accessing 
simulating memory state replay value obtained reading simulated memory state 
determine consume load value replay part log entry field specify number load instructions skipped load instruction logged 
format log entry checkpoint record information load instruction lc type reduced full count lv type encoded full load value second field reduced full count represents number load instructions skipped logged current load instruction logged load instruction logged 
record full count value require log checkpoint interval length bits count greater maximum checkpoint interval size 
majority count values represented just bits 
record count bits value 
count value exceeds resort recording full count value 
logs contain full count values distinguished logs contain bit count values additional bit lc type 
fourth field encoded full load value record load value 
try avoid recording full bit load value 
achieve entry dictionary captures frequently occurring load values 
load value dictionary bits represent position value dictionary 
load value full bit value recorded 
lv type bit distinguish cases 
track load instructions just record output values log 
effective address address pc load instruction logged produced replay thread execution 
section describe replaying mechanism detail 
dictionary compressor bugnet load values compressed dictionary compression scheme 
shown load values exhibit frequent value locality 
load values captured small number frequently occurring values 
addition value predictors shown provide impressive compression ratios 
approach entry fully associative table called dictionary table capture frequently occurring load values 
dictionary table emptied checkpoint interval updated execution load instruction 
logging load value fll value looked dictionary table 
hit storing full bit value store bit encoding 
bit encoding corresponds rank value dictionary table 
design rank corresponds index dictionary table find matching value 
checkpoint interval dictionary table continuously updated load instructions executed 
result position value dictionary table keep changing interval 
encoding compress value change course fll 
valid simulate dictionary state replay 
replay know initial dictionary state empty state start checkpoint interval subsequent executed load instructions update table 
instant time executing load instruction replay state dictionary table state original execution 
load gets executed interval dictionary table updated follows 
entry table bit saturating counter keep track frequency value stored entry 
load value entry dictionary table bit saturating counter corresponding entry incremented saturates 
updated counter value greater equal counter value previous entry table values swap positions rankings table 
ensures frequently occurring values percolate top table 
load value dictionary table inserted entry smallest counter value 
multiple candidates entry occupying lowest position table chosen replacement 
handling interrupts context switches interrupts asynchronous synchronous 
asynchronous interrupts caused sources external exe proceedings nd international symposium computer architecture isca ieee application code timer interrupts 
hand synchronous interrupts commonly referred traps triggered executing program instructions 
reasons traps include arithmetic overflow exceptions invoking system call event page fault 
goal replay debug application code record goes interrupts 
record output load instructions executed part interrupt handler operating system routines servicing interrupts 
need track interrupt affects execution application 
interrupts modify memory state interrupt change architectural state program execution modifying program counter registers 
straight forward solution solve problem prematurely terminating current checkpoint interval encountering interrupt create new control returns application code 
create new checkpoint servicing interrupt guaranteed right program counter value initialized header new fll 
bits track loads reset ensuring necessary load values logged replay instructions executed interrupt 
architecture model discussing results section assumes approach 
aggressive solution allow load bits tracked checkpoints interrupts 
help reducing number load instructions logged restarting new checkpoint interrupt 
solution needs sure load bits correctly invalidated memory state updated interrupt context switch 
examining approach detail left research 
handling external input mechanism described previous section handle interrupts adequate handle interrupts 
memory mapped mechanism works mapping address space device program virtual address space 
values read device load instructions virtual address corresponding program address space 
os initiate dma transfer service system call 
cases control return application code dma transfer proceed parallel 
fdr assume dma write directory cache coherence protocol invalidate cache block processor executing application 
ensure bits load optimization reset values modified memory location recorded get referenced application load 
scheme recording load values avoids logging data copied process address space referenced application 
large amount data get copied process address space necessarily program execution preceding crash 
scheme ensures log just necessary values fact consumed instructions need replayed 
support multithreaded applications assume shared memory multiprocessor system execute multithreaded programs 
shared memory multithreaded applications remote threads executing processors modify shared data checkpoint interval 
problem discussed regarding dma transfers 
thread corresponding cache block invalidated update 
reset bits track loads cache block 
result load cache block result recording value written remote thread fll 
fll corresponding checkpoint interval sufficient replay instructions executed interval 
true case multithreaded applications 
thread replayed independent threads recorded input values required executing thread 
order assist debugging data races require ability infer order instructions executed threads 
record synchronization information adapt mechanism proposed fdr record separate memory race buffer mrb 
memory model fdr assume shared memory multiprocessor sequential consistency memory model directory cache coherence protocol 
sequential consistency memory model memory accesses appear occur time 
execution program represented interleaving instructions different threads sequential order 
order get valid sequential order replay adapt mechanism fdr record order memory operations threads 
asynchronous checkpointing multithreaded programs fdr checkpoint mechanism uses barrier synchronization support shared memory multithreaded applications 
mechanism ensures checkpoint intervals threads start instant time 
approach desirable bugnet architecture overhead terms performance especially want create checkpoints smaller interval length 
want flexibility terminating checkpoint independent threads interrupt events encountered 
allow threads create terminate checkpoints intervals independent threads 
result checkpoint intervals different threads may start time 
support asynchronous checkpoints threads record checkpoint identifiers part memory race log entry described section 
memory race log new checkpoint created addition creating new fll explained create new memory race log mrl stored memory race buffer 
thread records synchronization information local mrl 
thread kept synchronization 
new checkpoint interval created addition proceedings nd international symposium computer architecture isca ieee creating new fll new mrl created initialized header information process id thread id id associate memory race log thread corresponds 
checkpoint interval identifier id checkpoint interval fll corresponding memory race log 
timestamp system clock timer checkpoint created 
timestamp order replay different threads 
goal memory race log track shared memory ordering threads 
fdr proposal creating mrl piggy back coherence reply messages write invalidation acknowledgment executing writes write update reply executing load remote thread execution state 
entry mrl created coherence reply message shared memory access 
mrl entry logged executing load store memory location non shared exclusive state coherence reply received memory operations 
bugnet mrl initialized information checkpoint interval 
log appended information coherence reply message received local ic remote tid remote cid remote ic purpose record synchronize execution remote thread sending coherence reply message execution local thread recording instruction counts 
having information allows retrieve ordering memory operations threads 
remote thread sends execution state part coherence reply local thread executed memory operation 
local ic represents number instructions executed current checkpoint interval till current memory operation local thread 
size local ic needs large log checkpoint interval length 
fields represent state remote thread 
remote id identifies thread id size field large log max live threads 
remote cid represents checkpoint interval identifier corresponding checkpoint interval currently active remote thread 
number bits required checkpoint identifier dependent number checkpoints simultaneously reside memory 
remote ic represents instruction count remote thread coherence reply sent 
detailed description order replaying multiple threads discussed section 
fdr optimizes size memory race logs providing architecture support implement netzer algorithm assume 
see fdr details memory race log optimization 
memory backing load logs stored checkpoint buffer memory race logs stored memory race buffer mrb memory backed different locations memory 
amount memory space devoted purpose managed user operating system ensure performance impact tolerable limits 
amount memory space disk space devoted determine number instructions replayed 
contents buffer lazily written back memory memory bus idle 
compress log entries generated contents buffer lazily written back memory point 
memory backed solution potentially impact memory bandwidth requirements due extra traffic main memory 
processor accessing main memory encountering cache probably stalled waiting data obtained main memory 
rate loads logged fll reduced 
simulating spec benchmarks sufficient bandwidth write logs back memory memory bus idle chip buffers need large hold bursts logging 
detecting fault operating system know program executes instruction causes thread terminated 
arithmetic exception due division zero memory operation accessing invalid address examples trigger program crash 
operating system detects program executed faulting instruction records fll current instruction count checkpoint interval program counter faulty instruction 
determine replaying correctly identify faulty instruction 
addition os collects corresponding application main memory hardware buffers 
scans headers logs uses process identifier header identify logs correspond application 
collected logs stored persistent storage sent developer debugging 
replayer implemented prototype replayer proof concept bugnet 
section describe bugnet replayer works experiences building replayer system 
replaying single thread pin dynamic instrumentation tool running linux os collect described section programs listed table 
multiple collected thread leading program crash 
goal replayer execute instructions checkpoint interval leading bug 
replaying program execution replayer access exact binaries application shared libraries creating fll 
proceedings nd international symposium computer architecture isca ieee replay fll start program execution red hat linux simulated break execution executing instruction 
clear data memory locations sure shared libraries needed replay loaded virtual address space 
header information fll initialize register values program counter 
execution application allowed proceed breaking execution load instruction 
encountering load instruction replayer sure memory location accessed load contains right value 
achieve needs decompress record fll format described section 
bit lc type decode value lc count recorded second field record fll determine load retrieve value fll memory 
load value come log full bit value log lv type bit set 
bits represent dictionary entry provide value described section 
corresponding dictionary entry read value load 
note generate correct values dictionary table update dictionary executed load simulated replay exactly described section 
obtain correct values load instructions replay starts instructions executed update register file memory normal execution allowing deterministically replay thread execution 
replay encounter synchronous interrupts turned nops need simulate goes interrupt 
replay past interrupt just continue replaying fll recorded thread execution 
replaying multiple threads inferring data races individual threads replayed multi threaded application procedure described previous section 
debug multi threaded programs need able retrieve valid sequential order memory operations threads 
provided information logged 
thread corresponding multiple checkpoint intervals replayed 
associate fll mrl collected checkpoint interval checkpoint interval id time stamp stored header logs 
fll generate trace instructions executed fll checkpoint interval just replaying single threaded application described 
generates instruction count memory operation thread map mrl entries synchronization points thread 
effectively infer ordering constraints threads memory operations 
checkpoint identifier remote cid thread id remote id mrl checkpoint interval remote thread identified 
remote ic determine application bug location bug description window size bc storage line misuse bounds variable corrupts heap objects gzip gzip line byte long input filename overflows global variable compress line byte long input filename corrupts stack return address lines byte long input filename corrupts stack return address tar line incorrect loop bounds leads heap object overflow ghostscript line line dangling pointer results memory corruption gnuplot trm line null pointer dereference due setting file name plot line buffer overflow corrupts stack return address tidy line null pointer dereference parser line memory corruption parser memory corruption xv line incorrect bound checking leads stack buffer overflow line line long file name results buffer overflow line buddy list remove operations causes null pointer dereference napster nap line dangling pointer corrupts memory resizing terminal python line line arithmetic computation results buffer overflow line null pointer dereference leads crash istream line null obsolete function pointer dereference causes crash table open source programs known bugs 
window size source bug crash instructions average 
programs study rest programs sourceforge net 
set programs multithreaded programs 
committed instruction remote thread local memory operation executed 
way deduce ordering constraints memory operation local thread relative instruction count mrl entry remote thread 
valid sequential order retrieved know far replay thread waiting threads get synchronization point 
replay implementation issues issue replaying need ensure instructions user shared library code loaded virtual addresses fll generated 
required guarantee program counter value recorded fll right instructions 
provide information operating system driver manage checkpoint logs hook load library routine record program execution current starting location binary shared library user space operating system code 
associated thread bug occurs binary starting address log replayer correctly set code virtual address space starting execution 
related issue replaying self modifying code 
checkpoint memory race logs contain loaded data code code modified outside replay interval regenerated 
solution log load instructions 
option support self modifying code done profiling tools industry 
results bugnet principle bugs reproduced isolated fixed replaying window execution corresponding moments leading program crash 
debugging replaying program considered effective technique software engineering community clear result length replay proceedings nd international symposium computer architecture isca ieee window execution required capture majority bugs 
section try quantify length studying popular desktop applications 
replaying instructions adequate characterize significant number bugs 
result study trace sizes amount hardware required bugnet draw comparison fdr 
methodology evaluate bugnet handful programs spec suite evaluate online compressor analyze size log required different interval sizes 
include art bzip crafty gzip mcf parser vpr 
programs compiled platform optimizations 
provide results programs study handful programs top programs downloaded sourceforge net web site 
programs bc gzip tar 
single threaded sourceforge programs ghostscript gnuplot tidy xv 
multithreaded sourceforge programs napster python 
pin binary rewriting tool create logs examined section 
bug characteristics table lists applications known bugs studied 
goal quantify number instructions required replayed order reproduce fix bug 
second column table gives details location source code applications needed changed order fix bug 
third column describes nature bug 
fourth column quantifies length replay window required capture bug 
determine size window calculating number dynamic instructions executed point program root cause bug point program crashed 
fll size kb bc ghostscript gnuplot gnuplot gzip tar size replay window execution required capture bugs listed table 
analysis assumed root cause bug program execution dynamic instance instruction corresponding bug fix source code location listed second column 
set bugs listed table covers large variety bugs 
includes memory corruption bugs dangling pointer accesses ghostscript buffer overflow gzip null pointer dereferences gnuplot 
includes bugs result arithmetic overflows python 
worst case study dangling pointer bug ghostscript 
capture bug require replay window length instructions 
majority bugs listed table captured having support replay instructions 
presents sizes needed capture replay bugs listed table 
results assume running bugnet checkpoint interval length 
fll sizes programs kb number instructions need replayed reproduce bugs order instructions 
applications ghostscript tidy xv rest require kb fll information 
worst case require mb data 
sensitivity analysis section discuss fll sizes vary checkpoint interval lengths replay window lengths 
study efficiency dictionary compression algorithm discussed section 
study spec programs standard inputs analyzed 
presents fll sizes collected replay window instructions different checkpoint interval lengths ranging instructions represented axis 
clearly interval size increases fll sizes decrease 
result applying load optimization described section 
longer checkpoint interval lengths probable particular memory location referenced load recorded frequency recording load instruction decreases resulting smaller fll sizes 
shows sizes needed replay window instructions 
results assume constant checkpoint interval length proceedings nd international symposium computer architecture isca ieee tidy tidy tidy xv xv napster python python fll size instr art bzip crafty gzip mcf pars er vpr avg interval total size required replay instructions captured different checkpoint interval lengths 
fll size kb art bzip crafty gzip mcf parser vpr avg window length total size required replay window instructions 
collected checkpoint interval length 
instructions 
average size kb required replay instructions mb replaying instructions 
results far assume entry dictionary table compression 
discuss efficiency compression technique described section 
shows percentage values compressible table dictionary table approach varying dictionary size 
dictionary size capable compressing values average size rest results 
shows compression ratio achieve various dictionary sizes 
average achieve compression entry dictionary 
larger dictionary table results higher compression ratio increase hardware costs especially dictionary table fully associative 
simplescalar examine performance overhead bugnet spec programs 
spec programs overhead bugnet due fact incremental compression scheme allows lazily write compressed log entries memory bus free spec programs lot interrupts system calls 
values ound dictionary art bzip crafty gzip mcf pars er vpr avg dictionary ize percent load values dictionary table various sizes 
compression ratio art bzip crafty gzip mcf parser vpr avg compression ratios achieved compressing different sizes dictionary table 
results gathered checkpoint interval length 
complexity fdr vs bugnet fdr proposal ability replay second execution approximated replay window length instructions vary depending processor speed ipc program 
fair comparison fdr discuss bugnet architecture capture instructions 
results shown table replay interval instructions sufficient fix bugs applications examined 
discuss bugnet generate logs replay instructions 
rest section results bugnet assume checkpoint interval size instructions 
note checkpoint interval different replay window 
replay window execution logs multiple checkpoints checkpoint interval length desired replay window length 
encountering interrupt terminate create new checkpoint described section 
log size complexity table compares sizes bugnet fdr logs 
compare amount memory storage required replaying instructions bugnet 
result replaying instructions fdr corresponds replaying second execution 
entry nil table implies log mechanism 
fll sizes required replay instructions kb mb average proceedings nd international symposium computer architecture isca ieee log size bugnet vs fdr bugnet bugnet fdr fll kb mb nil memory race log fdr fdr mb cache chk pnt log nil nil mb mem chk pnt log nil nil mb core dump nil nil mb gb interrupt log nil nil depends prg log nil nil depends dma log nil nil depends table comparison log sizes fdr bugnet 
interrupt program dma log sizes depend characteristic program 
intensive applications require large sizes logs 
hardware complexity bugnet vs fdr bugnet bugnet fdr cb kb kb nil mrb kb kb kb compression entry cam entry cam lz hw chk pnt interval instr instr sec 
cache chk pnt buf nil nil kb mem chk pnt buf nil nil kb interrupt buffer nil nil kb input buffer nil nil kb dma buffer nil nil kb total hw area kb kb kb table comparison hardware complexity fdr bugnet 
bugnet consider support replaying instructions adequate capture replay window programs table 
hardware complexity shown bugnet capture replay window window size assumed fdr 
spec applications 
assumes checkpoint interval length 
addition debug data races require memory race logs roughly size fdr 
fdr support replaying instructions require mb cache memory logs described plus memory race logs size mb 
combined size roughly sizes capturing instructions 
fdr requires additional information enable full system replay 
fdr records interrupt dma logs sizes may vary widely depending nature application 
intensive applications logs prohibitive sizes 
addition fdr requires core dump image size range gb application memory footprint main memory size 
results show log size kb replay instructions application execution 
reproduce debug majority bugs program examined 
addition bugnet small traces order hundreds kb encourage users communicate logs back developer 
hardware complexity table compares hardware complexity bugnet fdr 
previous section compare configuration bugnet capture instructions 
main hardware structures bugnet cb mrb hardware buffers fully associative entry dictionary table shown 
size cb needs large tolerate bursts logging 
addition perform incremental compression log entry allows lazily write logs main memory free space cb 
sizes cb mrb dictionary table constant irrespective length replay window trying capture logs memory backed 
comparison fdr requires kb chip hardware record information full system replay 
fdr assumes hardware implementation lz compression 
lz compressor block hardware buffer size needs large collect block information compressing storing back main memory needs large tolerate bursts 
cache memory checkpoint buffers record information required checkpoint mechanism sizes mb kb respectively 
fdr aims achieve full system replay record external inputs requires additional buffers kb interrupt buffer record interrupts kb input buffer record program kb dma buffer record dma writes 
summary total chip hardware requirement bugnet kb fdr requires kb 
limitations section discuss limitations bugnet architecture providing support capture bugs released software 
primary limitation bugs occur due complex interactions application program system code difficult fix track application code 
limitation amount memory space devoted bugnet limited bugs require large replay window may captured 
debugging focus bugnet assist debugging user code complex interactions operating system routines drivers interrupt handlers 
approach useful debug problems drivers operating system complex interactions user code 
bugnet replay system code provides deterministic replay program execution servicing interrupts context switches 
user examine values parameters passed interrupts values loaded consumed servicing interrupt 
trace allow user debug bugs interrupt operating system interactions 
replay operating system shared library code 
user code os library code consist significant portion program execution sufficient track majority application level bugs 
note bugnet logs contain core dump representing final state entire system main memory 
proceedings nd international symposium computer architecture isca ieee result examine arbitrary memory locations data structures 
memory location accessed instruction window replayed value examined replaying 
cause slight inconvenience inferring cause bug prevent user isolating bug expect memory addresses untouched program execution prior crash responsible faulty behavior 
bugnet detect bug operating system application identify program encountered fault exception 
example bugs resulting incorrect results captured bugnet know right time capture bug 
replay window size potential issue replay window size turned small capture bug 
replay window size knob tuned operating system user 
replay window size essentially dependent amount main memory space allocated storing capture desired number instructions replay 
user able specify desired replay window size maximum performance penalty willing pay 
input operating system dynamically tune memory space allocation 
os determine applications running particular instant time memory intensive considerable amount free space available increase memory space allocation bugnet 
hand performance degradation goes tolerable limits tune space allocated 
addition customer application specify minimal replay window size capture majority bugs 
replay window size instructions capture majority bugs 
bug occurred state kept track bug customer may asked increase replay window size 
computer industry long realized fact released software bound contain bugs 
key challenges faced today software developers reproducing bugs manifest customer site 
address problem proposed bugnet architecture continuously records information production runs 
recorded information mb communicated back developer characterize bug deterministically replaying program execution crash 
bugnet focuses replaying user code shared libraries find application level bugs 
achieve bugnet logs checkpoint interval contain register state start interval trace load memory accesses 
information achieve deterministic replay program execution having replay goes interrupts system calls 
results small log sizes log size kb capture replay window size instructions 
small motivate users communicate log back developer 
bugnet little performance overhead area overhead kb hardware buffers required 
acknowledgments zhou students providing set programs known errors inputs expose 
jack sampson anonymous reviewers providing useful comments 
funded part st microelectronics intel microsoft 
bacon goldstein 
hardware assisted replay multiprocessor programs 
proceedings acm onr workshop parallel distributed debugging pages 
acm press 
burger austin 
simplescalar tool set version 
technical report cs tr university wisconsin madison june 
sam 
automatic generation high performance trace compressors 
proceedings international symposium code generation optimization pages washington dc usa 
ieee computer society 
candea 
enemies dependability software lecture notes cs 
choi srinivasan 
deterministic replay java multithreaded applications 
proceedings sigmetrics symposium parallel distributed tools pp 
oregon 
corliss lewis roth 
low overhead interactive debugging dynamic instrumentation 
proceedings th international symposium high performance computer architecture feb 
netscape communications netscape quality feedback system 
wp netscape com 
microsoft 
dr watson overview 
oca microsoft com en dcp asp 
dieter jr user level checkpointing library posix threads programs 
proceedings ninth annual international symposium fault tolerant computing page 
ieee computer society 
elnozahy alvisi wang johnson 
survey rollback recovery protocols message passing systems 
acm computing survey 
leblanc mellor crummey 
debugging parallel programs instant replay 
ieee transaction computers 
luk cohn muth patil lowney wallace 
pin building customized program analysis tools dynamic instrumentation 
programming language design implementation chicago il june 
magnusson larsson werner 
full system simulation platform 
ieee computer 
netzer 
optimal tracing replay debugging shared memory parallel programs 
proceedings acm onr workshop parallel distributed debugging pages 
acm press 

thread level speculation mechanisms debug data races multithreaded codes 
th annual international symposium computer architecture san diego ca june 
zhang torrellas 
cost effective architectural support rollback recovery shared memory multiprocessors 
proceedings th annual international symposium computer architecture pages 
ieee computer society 
proceedings nd international symposium computer architecture isca ieee qin lu zhou 
exploiting ecc memory detecting memory leaks memory corruption production runs 
eighth international symposium high performance computer architecture february 
de 
non intrusive fly data race detection execution replay 
proceedings automated algorithmic debugging nov 
de 
debugging backwards time 
proceedings fifth international workshop automated debugging bug sep 
savage burrows nelson sobalvarro anderson 
eraser dynamic data race detector multithreaded programs 
acm transactions computer systems 
martin hill wood 
improving availability shared memory multiprocessors global checkpoint recovery 
proceedings th annual international symposium computer architecture pages 
ieee computer society 
srinivasan andrews zhou 
flashback lightweight extension rollback deterministic replay software debugging 
usenix annual technical conference general track pages 
geodesic systems 
geodesic traceback application fault management monitor 
xu bodik hill 
flight data recorder enabling multiprocessor deterministic replay 
th annual international symposium computer architecture san diego ca 
yang gupta 
energy efficient frequent value data cache design 
ieee acm th international symposium microarchitecture pages 
zhou liu long lu qin zhou midkiff torrellas 
automatically detecting memory related bugs program counter invariants 
th international symposium microarchitecture micro nov 
zhou qing liu zhou torrellas 
efficient architecture support software debugging 
st annual international symposium computer architecture june 
ziv lempel 
universal algorithm sequential data compression 
ieee transactions information theory 
