axiomatic basis computer programming hoare queen university belfast northern ireland attempt explore logical tions computer programming techniques applied study geometry extended branches mathematics 
elucidation sets axioms rules inference proofs properties computer programs 
examples axioms rules formal proof simple theorem displayed 
argued important advantages theoretical prac tical may follow topics 
key words phrases axiomatic method theory programming proofs programs formal language definition programming language design machine independent programming program documentation cr category 
computer programming exact science properties program consequences executing environment principle text program means purely deductive reasoning 
deductive reasoning application valid rules inference sets valid axioms 
desirable interesting elucidate axioms rules inference underlie reasoning computer programs 
exact choice axioms extent depend choice programming language 
illustrative purposes confined simple language effec tively subset procedure oriented languages 

computer arithmetic requirement valid reasoning pro gram know properties elementary operations invokes example addition multiplication integers 
unfortunately respects computer arithmetic arithmetic familiar mathematicians necessary exercise care selecting appropriate set axioms 
example axioms displayed table small selection axioms relevant integers 
incomplete set computer science axioms possible deduce simple theorems proof second axioms course true tradi tional infinite set integers mathematics 
true finite sets integers manipulated computers provided con fined nonnegative numbers 
truth independent size set furthermore largely independent choice technique applied event flow example strict interpretation result overflowing operation exist overflow occurs ing program completes operation 
note case equalities strict sense sides exist fail exist 
firm boundary result overflowing opera tion taken maximum value represented 
modulo arithmetic result overflowing operation computed modulo size set integers represented 
techniques illustrated table ii addition multiplication tables trivially small model integers repre sented 
interesting note different systems satisfy ing axioms may rigorously distinguished choosing particular set mutually exclusive supplementary axioms 
example infinite arithmetic satisfies axiom finite arithmetics satisfy vx max max denotes largest integer represented 
similarly treatments overflow may distinguished choice relating value max alls max strict interpretation max max firm boundary max modulo arithmetic having selected axioms possible deducing properties programs communications acm volume number october table xx yx xx xx xx xd xx xxl 
nonexistent 
table ii 
modulo arithmetic addition commutative multiplication ative addition associative multiplication associa tive multiplication distrib addition addition cancels tion properties necessarily program executed implementation satisfies chosen axiom 

program execution mentioned purpose study provide logical basis proofs properties program 
important properties program carries intended function 
intended function program part program specified making general assertions values relevant variables take execution program 
assertions usually ascribe particular values variable specify certain general properties values relationships holding 
normal notations mathematical logic express assertions familiar rules operator precedence possible improve legibility 
cases validity results program part program depend values taken variables program initiated 
initial preconditions successful specified type general assertion describe results obtained termination 
state required connection precondition program description result execution introduce new notation may interpreted assertion true initiation program assertion true completion 
preconditions imposed write true treatment essentially due floyd applied texts flowcharts 

axiom assignment assignment undoubtedly characteristic feature programming digital computer clearly distinguishes branches mathematics 
surprising axiom governing reasoning assignment quite simple elementary logic 
consider assignment statement identifier simple variable expression programming language side effects possibly containing assertion true value assignment true value expression taken assignment old value true assignment true assignment 
fact may expressed formally axiom assignment variable identifier expression obtained substituting occurrences may noticed really axiom axiom schema describing infinite set axioms share common pattern 
pattern described purely syntactic terms easy cheek finite text conforms pattern qualifying axiom may validly appear line proof 
proved formal system familiar logical symbol theoremhood volume number october communications acm 
rules consequence addition axioms deductive science requires rule inference permits deduction new theorems axioms theorems ready proved 
rule inference takes form assertions form proved theorems proved theorem 
simplest example inference rule states execution program en sures truth assertion ensures truth assertion logically implied known precondition program pro duce result assertion logically implies rules may expressed formally rules consequence 
rule composition program generally consists sequence statements executed 
statements may separated semicolon equivalent symbol denoting procedural composition 
order avoid awkwardness dots possible deal ini tially statements longer se quences reconstructed nesting 
removal brackets nest may regarded convention associativity operator way brack ets removed arithmetic expression 
inference rule associated composition states proven result part program identical precondition second part program produces intended result program produce intended result provided precondition part satisfied 
formal terms rule composition 
iteration essential feature stored program computer ability execute portion program re condition goes false 
simple way expressing iteration adapt algol notation executing statement computer tests con dition false omitted execution loop complete 
executed tested 
action repeated false 
reasoning leads formulation inference rule iteration follows 
suppose assertion true completion provided true initiation 
obviously true number iterations statement iterations 
furthermore known con condition false iteration terminates 
slightly powerful formulation pos sible light fact may assumed true initiation rule iteration 
example axioms quoted sufficient construct proof properties simple programs example routine intended find quotient remainder obtained dividing variables assumed range set nonnegative integers conforming axioms listed table simplicity trivial inefficient method successive subtraction 
pro posed program rdo important property program terminates recover numerator adding remainder product divisor quo 
furthermore remainder divisor 
properties may expressed formally true rax stands program displayed 
expresses necessary sufficient condition correctness program 
formal proof theorem table iii 
formal proofs excessively tedious fairly easy introduce notational conventions significantly shorten 
power ful method reducing tedium formal proofs derive general rules proof construction simple rules accepted postulates 
general rules shown valid demonstrating theorem proved assistance equally proved 
powerful set supplementary rules developed formal proof reduces little informal indication formal proof constructed 

general reservations axioms rules inference quoted implicitly assumed absence side effects evaluation expressions conditions 
proving prop erties programs expressed language permitting side effects necessary prove absence ease applying appropriate proof technique 
main purpose high level programming language assist construction verification correct programs doubtful functional notation call procedures side effects genuine advantage 
deficiency axioms rules quoted communications acm volume number october give basis proof program suc terminates 
failure terminate may due infinite loop may due violation imple mentation defined limit example range numeric operands size storage operating system time limit 
notation interpreted provided program successfully terminates properties results described 
fairly easy adapt axioms predict results nonterminating programs actual axioms depend knowledge implementation dependent features example size speed computer range numbers choice overflow technique 
apart proofs avoidance infinite loops probably better prove conditional correctness program rely implementation give warning table iii line number formal proof justification true yx true true yx lemma bq bq ty true rdo rax notes left hand column number lines right hand column justify line appealing axiom lemma rule inference applied previous lines indicated brackets 
columns part formal proof 
example line instance axiom assignment line obtained lines application rule composition 

lemma may proved axioms 

lemma follows directly theorem proved see 

abandon execution program result violation implementation limit 
necessary list areas covered example real arithmetic bit character manipulation complex arithmetic fractional arithmetic arrays records overlay definition files input output declarations subroutines parameters recursion parallel execution 
characterization integer arithmetic far complete 
appear great difficulty dealing points pro vided programming language kept simple 
areas real difficulty labels jumps pointers name parameters 
proofs programs features elaborate surprising reflected complexity underlying axioms 

proofs program correctness important property program accomplishes intentions user 
intentions described rigorously making assertions values variables intermediate points execution program techniques described may prove correctness program provided implementation pro gramming language conforms axioms rules proof 
fact established deductive reasoning axiom set describes logical properties hardware circuits 
correctness program compiler hardware computer established mathematical certainty possible place great reliance results program predict properties confidence limited reliability electronics 
practice supplying proofs nontrivial programs widespread considerably power ful proof techniques available easy 
practical advantages program prov ing eventually outweigh difficulties view increasing costs programming error 
method programmer uses convince correctness program try particular cases modify results produced cor respond intentions 
reasonably wide variety example cases program believes 
time spent program testing half time spent entire programming project realistic costing machine time thirds cost project involved removing errors phase 
cost removing errors discovered program gone greater particularly case items computer manufacturer software large part expense borne user 
cost error certain types program may volume number october communications acm lost spacecraft collapsed building crashed aeroplane world war 
practice program proving theoretical pursuit followed interests academic serious recommendation reduction costs associated programming error 
practice proving programs alleviate problems computing world 
example problem program docu mentation essential firstly inform potential user subroutine accomplishes secondly assist development necessary update program meet changing circumstances improve light increased knowledge 
rigorous method formulating purpose subroutine conditions proper assertions values vari ables execution 
proof cor assertions proof program calls subroutine 
large program structure clearly mirrored structure proof 
furthermore necessary modify program valid replace subroutine satisfies criterion correctness 
examining detail algorithm probable proof helpful explaining happening 
problem solved insofar soluble practice program proofs trans programs design computer 
written called machine independent programming language large programs take advantage machine dependent prop erty particular implementation unpleasant expensive surprises result attempting transfer machine 
presence machine dependent feature revealed advance attempt prove program ma chine independent axioms 
programmer choice formulating algorithm machine independent fashion possibly help environment enquiries involves effort inefficiency deliberately construct machine dependent pro gram rely proof machine dependent axiom example versions section 
case axiom explicitly quoted preconditions successful program 
program complete confidence trans machine happens satisfy machine dependent axiom neces sary transfer implementation places changes required clearly annotated fact proof point appeals truth offending machine dependent axiom 
practice proving programs lead solution pressing problems software programming reliability tation compatibility 
program proving cer difficult programmers high may applicable quite simple program designs 
areas reliability pur chased price simplicity 

formal language definition high level programming language alc ol fortran cobol usually intended implemented variety computers differing size configuration design 
serious problem define languages sufficient rigour ensure compat implementors 
purpose com facilitate interchange programs ex pressed language way achieve insist implementations language shall sat axioms rules inference underlie proofs properties programs expressed language predictions proofs fulfilled event hardware failure 
effect equivalent accepting axioms rules inference ultimately definitive specification meaning language 
apart giving immediate possibly provable criterion correctness implementation axiomatic technique definition programming language semantics appears formal syntax report sufficiently simple understood implementor reasonably sophisticated user language 
bridging widening communication gap single document provably consistent maximum advantage obtained formal language def 
great advantages axiomatic approach axioms offer simple flexible tech nique leaving certain aspects language undefined example range integers accuracy floating point choice overflow technique 
absolutely es standardization purposes language impossible implement efficiently differing hardware designs 
programming language standard consist set axioms universal applicability choice set supple axioms describing range choices facing implementor 
example axioms purpose section 
objectives formal language definition assist design better programming languages 
regularity clarity ease implementation algol syntax may part due elegant formal technique definition 
axioms may lead similar advantages area semantics language continued communications acm volume number october hoare cont page described self evident axioms proofs relatively easy construct preferable language obscure axioms dif apply proofs 
furthermore axioms enable language designer express general intentions quite simply directly mass detail usually accompanies algorithmic descriptions 
ax formulated manner largely independent designer freely axiom group axioms fear unexpected effects parts language 
acknowledgments 
axiomatic treatments com puter programming tackle problem proving equivalence correctness algorithms 
approaches take recursive functions programs starting point theory 
suggestion axioms defining primitive opera tions computer appears 
importance program proofs clearly emphasized formal technique providing described 
suggestion specification proof techniques pro vides adequate formal definition programming language appears 
formal treatment pro gram execution clearly derived floyd 
main contributions author appear suggestion axioms may provide simple solution problem leaving certain aspects language undefined comprehensive evaluation possible benefits gained adopting approach program proving formal language defini tion 
formal material expository status represents minute propor tion remains done 
hoped fascinating problems involved taken 
received november revised may yu logical operator schemes 


igarashi axiomatic approach equivalence problems algorithms applications 
ph thesis 
rep compt 
centre tokyo pp 


de axiomatics simple assignment statements 
mathematisch centrum amsterdam june 

mccarthy mathematical theory computation 
proc 
ifip cong 
north holland pub 
amsterdam 

burstall proving properties programs structural duction 
experimental programming reports edinburgh feb 

van wijngaarden numerical analysis independent science 
bit 

laski sets types 
algol bull 


floyd assigning meanings programs 
proc 
amer 
math 
soc 
symposia applied mathematics vol 
pp 


ur proof algorithms general snapshots 
bit 
volume number october communications acm 
