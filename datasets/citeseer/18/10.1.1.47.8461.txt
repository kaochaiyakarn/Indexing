compiling standard ml efficient execution modern machines zhong shao dissertation faculty princeton university degree doctor philosophy recommended acceptance department computer science november fl copyright zhong shao rights reserved ii language theoreticians taken great efforts designing higher level programming languages elegant expressive conventional languages 
new languages implemented efficiently 
result software engineers prefer conventional languages new higherlevel languages offer better simpler programming model 
dissertation concentrates improving performance programs written standard ml sml statically typed functional language today risc machines 
sml poses tough challenges efficient implementations frequent function calls polymorphic types recursive data structures higher order functions class continuations 
dissertation presents design evaluation new compilation techniques meet challenges advantage higher level language features sml 
type directed compilation exploits compile time type information optimize data representations function calling conventions 
inserting coercions type instantiation abstraction site data objects sml unboxed representations presence polymorphic functions 
measurements show simple set type optimizations improves performance non type compiler decstation 
space efficient closure representations utilizes compile time control data flow information optimize closure representations 
extensive closure sharing allocating closures registers possible new closure conversion algorithm achieves asymptotic space usage improves performance old compiler decstation stack 
empirical analytic studies show execution cost stack allocated heap allocated activation records similar heap allocation simpler implement allows efficient class continuations 
iii unrolling lists takes advantage higher level language abstraction sml support efficient representations lists 
representing cons cell multiple car fields cdr field unrolled list reduces memory links significantly shortens length control dependence data dependence chains operations lists 
iv foremost advisor andrew appel huge amount effort spent guiding research 
years share quick wit clarify enhance thinking spark new ideas 
careful guidance impossible 
dissertation really considered joint 
addition helping improve writing hacking skills teaching scientist 
readers john reppy doug clark providing timely suggestions valuable comments document 
john gave dissertation kind close reading rarely privileged receive time patience refining thoughts correcting syntax 
want david hanson anne rogers serving thesis committee interests 
special go david macqueen john reppy lal george bell laboratories encouragement advice provided various stages 
dave introduced world programming language theory spring course princeton greatly interested standard ml 
john lal taught aspects sml nj compiler 
john actively participated research described chapter 
making sml nj compiler pleasant project 
people places helped ways am grateful kai li doug clark illuminating computer architecture classes kai li david dobkin david hanson anne rogers helping decide thesis topics teaching research really hans boehm john ellis giving opportunity xerox parc summer learned things outside sml nj world gun sirer marcelo gon implementing adapting mipsi instruction simulator measurements chapter hans boehm scott amer diwan damien doligez lorenz trevor jim xavier leroy paul wilson useful comments early drafts chapter people administrative offices princeton particularly melissa lawson helping sharon rodgers helping settle arrived princeton jim roberts matthew providing memory disk space running memory eating sml nj job 
matthias blume dimitrios gunopulos wonderful playing water gun fight friend english tutor michael patiently improving english writing skills sharing interesting discussions friends princeton richard alpert alvaro campos pei cao xue fang yan huo krishnan chen lin liu qiang ren bin wei zhao zhong name just making quiet boring town lot fun live 
want parents sister hong brother law constant love support 
deepest go wife giving great emotional support love patience understanding 
able got rejected 
happiness self confidence impossible 
research funded part national science foundation ccr ccr ccr 
vi contents iii motivation outline dissertation background evolution functional languages lambda calculus lisp ml haskell standard ml basic expressions values types value bindings functions polymorphism datatypes pattern matching values exceptions class continuations modules summary compiling functional languages stack allocation heap allocation higher order functions closures space safety vii experimental measurements type directed compilation data representations overview compiler front issues core language module language minimum typing derivation translation lexp typed lambda language lexp translating static semantic objects lty translating lexp practical issues typed cps back typed cps language converting lexp cps cps optimizations closure conversion machine code generation performance evaluation related summary space efficient closure representations safely linked closures continuations closures continuation passing style closure passing style closure conversion extended cps call graph raw free variables lifetime closure strategy analysis viii closure representation analysis access path non local free variables remarks case studies function calls sequence lambda lifting known functions general recursion measurements related summary heap vs stack garbage collected frames creation frame pointers copying sharing space safety locality write misses read misses simulations read misses analytically disposal finding roots class continuations implementation summary unrolling lists compiling refinement types source language src target language tgt refinement types source target translation definition meta operations correctness translation ix compiling multiple continuations experiments avoiding code explosion measurements related summary bibliography list tables flat closures linked closures general information benchmark programs signature matching transparent abstraction matching opaque comparison execution time comparison total heap allocation comparison compilation time comparison code size comparison closure representations raw free variables closure strategies raw free variables closure strategies function comparison execution time comparison garbage collection time comparison total heap allocation comparison compilation time comparison code size breakdown closure access allocation cost breakdown different frame allocation strategies shared limit checks copying sharing cost heap allocation data garbage collection cost standard vs unrolled list representations performance benchmark programs combined performance improvement execution time xi list figures type deduction rules core ml higher order functions space safety standard boxed representations flat unboxed representations simple descriptors flat unboxed representations sophisticated descriptors compact representations concrete data type list overview new type sml nj compiler front issues core language front issues module language typed lambda language lexp translating ml type lty flexible constructor type recursively boxed typed cps language comparison execution time illustration example standard ml function iter standard ml syntax cps function iter cps optimizations function iter closure conversion closure strategy analysis known functions function cps making sequence function calls function map special calling conventions comparison execution time illustration simulations write allocate vs write cache xii execution line cache 
procedure call write bold procedure returns read misses 
execution line cache 
bold procedure returns read misses 
left source language src right target language tgt definitions top refinement types translation expressions translation declarations translation matches translation patterns example map function definitions combine coerce pseudo cps code filter xiii chapter important component software development programming formalization ideas expression forms suitable interpretation computers 
programming start mental picture computational behavior refine clarify idea ramifications better understood write formalized detail programming language formal notation designed specifying computational behaviors 
resulting program translated machine instructions executed real machines perform desired task 
ultimate goal software research find right programming model write best quality reliable efficient portable program amount time effort 
researchers programming languages believe effective way achieve goal write programs higher level languages languages representations allow greater distance low level machines 
fact higher level languages support simpler cleaner programming models making easier develop large complex software 
higherlevel languages abstracted away real machines difficult implement efficiently conventional languages 
result software engineers unwilling sacrifice code efficiency products prefer write programs conventional languages 
believe new higher level languages designed carefully implemented efficiently modern machines 
dissertation documents set new compilation techniques significantly improve performance programs written standard ml sml statically typed functional language today risc machines 
higher level languages sml poses tough challenges efficient implementations chapter 
frequent function calls polymorphic types recursive data structures higher order functions class continuations 
dissertation presents design evaluation new techniques meet challenges advantage higher level language features sml 
motivation nearly decades programming languages fortran lisp came programming world 
thousands programming languages designed implemented 
languages imperative languages fortran algol pascal ada object oriented languages modula smalltalk functional languages lisp scheme ml haskell logic programming languages prolog 
language designers implementors agree ultimate goal finding programming model write best quality software amount time effort language research carried different directions ffl language theoreticians design new higher level languages cleaner semantics usually care efficient implementations ffl software today industrial world written conventional languages software engineers prefer simply efficient implementations easy interface libraries operating system difference reflected dilemma people encounter choosing languages 
conventional languages popular run fast little memory 
hacker heaven arbitrarily manipulate machine level data representations source program programs written languages core dump difficult debug difficult reason 
hand higher level languages ml relatively known run slower consume memory 
cleaner safer 
founded semantics easy reason easy write code 
clearly want best worlds find languages clean programming models efficient implementations 
chapter 
best way settle dilemma develop new compilation techniques higher level languages run faster 
long term research centered provide benefits ffl higher level languages compiled efficiently conventional languages step closer ideal achieve ultimate goal software research 
ffl programs written higher level languages different run time behaviors allocations fewer side effects conventional languages new compiler technologies discovered higher level languages may offer new insights best way achieve successful high performance computer systems 
ffl doing research compile higher level languages efficiently give language theoreticians feedback language features difficult compile give hardware designers feedback support modern machines offer order achieve best performance 
dissertation concentrates improving performance programs written standard ml sml mth modern risc machines 
sml may representative elegant higher level language today world serves great test bed explore modern compilation technologies 
reasons believe sml compiled run efficiently ffl sml statically typed language type checking done compile time 
means type tags need carried run time operators need check types arguments run time 
ffl sml uses call value evaluation semantics sml programs understandable control flow conventional data flow control flow optimizations asu 
ffl pure functional languages haskell sml just functional language 
side effects allowed sml making possible support efficient mutable data structures arrays hash tables 
ffl efficient compiler sml standard ml new jersey compiler sml nj am explore new compiler optimizations :10.1.1.55.9444
chapter 
sml contains contemporary language features rarely seen conventional languages frequent function calls control structures sml expressed function applications 
example loops conventional languages expressed recursive functions sml 
higher order functions scheme languages derived calculus functions sml class values may passed arguments returned values put data structures 
polymorphic types sml allows polymorphic functions data structures function may take arguments arbitrary type fact function depend type 
example map function operate list similarly common list functions cons length append 
immutable recursive data structures recursive data structures declared concrete data type definitions 
pure functional languages sml encourages heavy immutable data structures 
example order insert element list sml copy list directly attaching new element 
class continuations sml supports call current continuation call cc primitive support tasking coroutines exceptions 
compiler technologies developed conventional languages apply new language features major challenge compiling sml efficiently naturally find new techniques successfully deal new features 
dissertation presents design evaluation new techniques significantly improve performance sml programs ffl type directed compilation exploits compile time type information optimize data representations function calling conventions 
inserting coercions type instantiation abstraction site data objects sml unboxed representations presence polymorphic functions 
measurements show simple set type optimizations improve performance non type compiler decstation 
really standard ml new jersey dialect supports class continuations 
chapter 
ffl space efficient closure representations utilizes compile time control data flow information optimize closure representations 
extensive closure sharing allocating closures registers possible new closure conversion algorithm achieves asymptotic space usage improves performance old compiler decstation stack 
empirical analytic studies show execution cost stack allocated heap allocated activation records similar heap allocation simpler implement allow efficient class continuations 
ffl unrolling lists takes advantage higher level language abstraction sml support efficient representations lists 
representing cons cell multiple car fields cdr field unrolled list reduces memory links significantly shortens length control dependence data dependence chains operations lists 
outline dissertation development dissertation may easier follow readers background standard ml ull har mth basic compilation techniques functional languages app pey 
chapter contains survey various functional languages sml may skipped reader familiar sml notation review important aspects compiling functional languages 
chapter explains experimental methodology sml benchmarks rest chapters 
chapters constitute core dissertation 
chapter describes design implementation evaluation type directed compilation technique context standard ml new jersey compiler am new technique allows data objects sml efficient unboxed representations presence polymorphic functions :10.1.1.55.9444
chapter describes design implementation evaluation new heap environment allocation scheme uses space efficient closure representations new scheme supports efficient function calls returns activation records allocated heap 
chapter empirical analytic study heap scheme described chapter conventional scheme shows compiling languages sml efficient heap scheme attractive stack scheme 
chapter describes unrolling chapter 
lists technique supports efficient representation lists unrolled list reduces memory links significantly shortens length control dependence data dependence chains operations lists 
chapter describes areas research summarizes results dissertation 
history idea allocating continuation closures callee save registers described chapter published 
new closure conversion algorithm chapter developed published sa 
measurement data sa different chapter different versions sml nj compiler 
comparison stack heap closure allocation scheme described chapter previously appeared 
unrolling lists technique described chapter previously published sra 
ideas chapter evolved recompilation sa sa described dissertation 
chapter background chapter sets stage presentations chapters 
review fundamental concepts notations evolved development functional languages standard ml explain space usage assumption experimental methodology dissertation 
evolution functional languages section representative functional languages lambda calculus lisp ml haskell explain fundamental concepts notations evolved development functional languages 
complete survey history functional languages hudak hud 
section describes core ml language polymorphic type system detailed description standard ml mth section 
lambda calculus development functional languages influenced time time sources fundamental church chu lambda calculus 
lambda calculus regarded functional language modern functional languages thought nontrivial lambda calculus 
interested readers referred excellent book barendregt bar detailed explanations 
chapter 
background syntax pure untyped lambda calculus name chosen distinguish versions defined embodies called lambda expressions defined grammar denotes arbitrary identifier 
expressions form called abstractions form called applications 
captures notion function captures notion application function 
convention application assumed left associative 
rewrite rules lambda calculus depend notion substitution expression free occurrences identifier expression write understand substitution understand notion free variables expression write fv define simple rules fv fxg fv fv fv fv fv fxg 
say free fv 
substitution inductively defined follows fv fv fv fv 
rule subtle name conflict occur resolved making name change 
complete lambda calculus define simple conversion rules lambda expression ff conversion renaming ff fv fi conversion application fi conversion ex chapter 
background notion reduction conversion restricted fi conversion conversion happen direction fi reduction fi reduction ex write derived zero fi reductions ff conversions derived zero ff fi conversions 
summary captures notion reducibility captures notion 
lambda expression normal form reduced fi reduction 
example xy xy normal forms normal form fi reduced note lambda expressions normal form xx xx possible fi reduction leads identical term reduction process nonterminating 
famous church rosser theorem says exists third term possibly reduced 
corollary lambda expression reduced distinct normal forms 
suppose normal form church rosser theorem exists third term reduced 
normal form 
corollary essentially means long reduction reaches normal form way carried evaluation order irrelevant 
known ways carry reduction normal order reduction applicative order reduction normal order reduction corresponding call name evaluation strategy sequential reduction reducible sub expression called redex leftmost chosen applicative order reduction corresponding call value evaluation strategy sequential reduction leftmost innermost redex chosen 
expression applying normal order reduction yield normal form 
applicative order reduction adequate 
consider example xx xx xx xx normal order reduction yield chapter 
background xx xx nice thing lambda calculus ability express recursive functions 
lambda expression fixpoint ee example just expression combinator defined xx xx 
combinator recursive function form written 
example factorial function written lambda calculus extended conditional expressions constants fac fac gamma written fac fac fac gamma 
ability lambda calculus simulate recursion way key power accounts persistence useful model computation 
shown turing tur functions computable turing machines exactly definable functions lambda calculus 
lisp lisp mcc ste functional language world developed john mccarthy 
core lisp essentially lambda calculus plus constants new features lisp commonly functional languages 
example lisp language uses expressions 
expression symbol number pair expressions 
restricted form expression list data structure 
list notations primitive cons car cdr operations introduced lisp 
lambda calculus lisp strict call value language 
allows side effect expressions primitive replace car replace cdr operations 
lisp language supports dynamic storage allocation 
cons applied cons cell allocated heap 
memory garbage collection triggered reclaim unused cells 
chapter 
background lisp programs untyped lisp associate types expressions 
type checking lisp done program execution 
called dynamic typechecking done inserting extra code program watch impending errors 
data object lisp type tag attached 
ml fundamental difference ml lisp ml statically typed lisp dynamically typed 
type checking ml done compile time 
lisp ml functional language meaning ml programs side effect free ml facilities creating manipulating mutable objects 
evaluation order ml call value function arguments strictly evaluated left right 
ml known powerful polymorphic type system 
ml programs checked type correctness compile time 
compiler infer types identifiers type checking programmer need declare explicitly 
briefly explain ml type system core ml language looks lambda calculus statement just syntactic language construct equivalent additional structure support ml powerful polymorphic type system developed independently hindley hin milner mil 
suppose tyvar infinite set type variables tycon set nullary type constructors tycon fint bool ff tyvar ffi fl ff set types type ranged set type schemes ranged oe defined ff oe ff oe type environment finite map program variables type schemes 
oe te set type variables occur free oe te respectively 
type generic instance type scheme oe ff ff written oe oe exists substitution domain subset fff ff chapter 
background var oe te te abs te sigma fx 
te app te te te te te sigma fx 
gen te te type deduction rules core ml 
type scheme oe general oe denoted oe oe oe generic instances oe generic instances oe generalization type type environment te denoted gen te type scheme ff ff fff ff te 
core ml type system form type deduction rules te listed 
general expression different typings deduction rules type environment te 
particularly concerned principal type te type te te gen te oe damas milner dm shown expression type environment principal type environment unique choice bound type variable names inferred known type assignment algorithm dm 
standard ml mth just core ml extended constants pattern matching data type definitions exceptions sophisticated module system mac 
ll explain details standard ml section 
haskell haskell nonstrict purely functional programming language developed hudak peyton jones wadler 
core haskell core ml described section statically typed language hindley milner type system 
main differences ml haskell follows chapter 
background ffl ml functional language side effects ml allowed 
haskell purely functional language side effects permitted 
ffl ml strict call value language uses applicative order reduction 
haskell hand non strict language uses lazy evaluation 
ffl ml supports expressive powerful module system haskell 
example ml supports parametrized modules functors module abstractions haskell 
ffl type system haskell supports type classes general form overloading wb 
details efficiently compile pure functional languages haskell discussed peyton jones pey pey 
techniques described dissertation apply lazy languages haskell rest dissertation mainly focus compiling strict functional languages standard ml 
standard ml section provides standard ml sml allow reader follow examples notations dissertation easily 
readers referred har ull pau complete 
formal definition commentary sml mth mt 
basic expressions values types sml expression language traditional statement constructs blocks conditionals case statements assignment packaged expressions 
expression statically determined type evaluate values type 
illustrate basic values types sml example unit type unit consists single value written 
type expression interesting value function arguments 
booleans type bool consists values true false 
ordinary boolean negation available 
booleans commonly argument conditional expression chapter 
background sml clauses type 
integers type int set integers 
integers written usual way negative integers written tilde character minus sign 
ml supports usual arithmetic operators div mod usual relational operators 
strings type string consists set finite sequences characters 
strings written conventional fashion characters double quotes hello world foo 
real numbers type floating point numbers known sml real 
real numbers written usual fashion programming languages 
tuples type types type ordered pairs component type second component type ordered pairs written expressions 
ordered tuple written comma separated expressions parentheses 
example true pair int bool bar triple sml type string int real 
records record type quite similar pascal records structures 
record consists finite set labelled fields value type tuples different fields may different types 
record values written giving set equations form label expression enclosed curly braces 
type record set pairs form label type enclosed curly braces 
example name bar true record type name string bool 
value bindings functions polymorphism principal mechanism associating values variables sml value declarations function declarations 
value binding starts leading key word val val chapter 
background evaluated evaluating expression right hand side setting value variable left hand side value 
example bound integer 
function declaration uses leading key word fun example factorial function defined fun fac fac type function fac int int 
functions sml class values passed arguments embedded data structures returned results 
example fun compose fn 
function compose takes functions arguments returns composition result 
described section sml supports polymorphic types 
compose function polymorphic type ff fi fl ff fi fi fl 
ff fl applied pair functions long application satisfies ml type deduction rules see 
datatypes pattern matching important feature sml programmer declare new concrete data types datatype constructs 
commonly data type list defined datatype list nil list type variable denote greek symbol ff 
data type declaration defines list empty nil cons element list 
sml cons operator pre declared infix operator lists represented syntactically really denotes nil 
important predefined data type sml sml nj am polymorphic option type datatype option chapter :10.1.1.55.9444
background structured data type values decomposed powerful pattern matching notation 
pattern data template 
datum matches pattern variables pattern bound corresponding components datum 
match fails datum pattern concur 
pattern matching useful defining functions series patterns select function cases 
symbol separates pattern case pairs 
matching proceeds serially left right 
successful match causes evaluation corresponding function case 
matching process faults pattern matches function argument value 
patterns function compute lengths lists fun length nil length xs length xs length applied empty list pattern nil matches length returns length argument matches cons cell list constructor second pattern xs 
match binds head element list xs tail 
length function require binding list head element pattern xs written xs wildcard matches bind 
values sml functional allow side effects 
cells contents may changed creation assignment 
ref datatype constructor corresponding value constructor defined declaration datatype ref ref initial contents string foo may created altered follows val ref foo bar string concatenation operator infix assignment operator infix dereferencing operator 
final content string 
exceptions sml exception mechanism signaling run time errors exceptional conditions 
example chapter 
background exception head fun head nil raise head head xs fun head head handle head 
line exception binding declares head exception 
function head defined usual pattern matching constructors list type 
case non empty list value head simply element 
nil function head unable return value raises exception 
complete way doing error sml called exception handler 
expression handle exn 
evaluated follows evaluate returns value value expression raises exception exn returns value raises exception raise exception 
function head return argument empty list 
class continuations extension standard ml new jersey sml nj am typed class continuation defined follows type cont val callcc cont :10.1.1.55.9444

val throw cont 

cont type constructor denotes weak type variable typing mac callcc capture current state representing rest program just call current continuation function scheme rc captured continuation applied throw function 
class continuations support tasking coroutines exceptions 
modules sml provides powerful module system partition programs clean interfaces 
simplest form module syntactically just collection declarations viewed unit semantically environment defined definitions 
form chapter 
background structure expression struct dec 
example structure expression represents implementation stacks struct datatype stack empty push stack exception pop top fun empty empty true empty false val push push fun pop push pop empty raise pop fun top push top empty raise top structure expressions ordinary expressions distinct classes structure expressions may bound structure keyword structure identifiers 
example structure stack structure expression shown structure stack struct datatype stack 
useful explicitly constrain structure binding limit visibility fields 
done signature structure binding type constraint value binding 
example write signature stack sig type stack exception pop top val empty stack val push stack 
stack val empty stack 
bool val pop stack 
stack val top stack 
signature mentions structure components visible outside structure 
signatures may bound identifiers signature declaration key word signature example signature bound identifier stack declaration signature stack sig type stack signature constrain structure called signature matching including structure declaration structure stack stack stack chapter 
background constructor push visible component stack structure appear signature 
constructor empty mentioned val signature constructor part data type specification stack empty may applied function matched pattern 
sml supports parametrized modules called functors 
functors functions structures manage dynamics program development sml 
functors defined functor declarations key word functor 
syntax functor declaration similar clausal form function definition example functor stack struct fun init empty fun nil xs push xs val pop pop val top top functor defines function structure matching stack returns structure contains components init pop top 
summary summary sml functional language contains features frequently seen modern higher level programming languages ffl sml safe programs corrupt runtime system execution program faithful language semantics 
ffl sml supports class functions functions passed arguments returned results stored variables 
principal control mechanism sml recursive function application 
ffl sml statically typed powerful polymorphic type system 
legal expression sml uniquely determined general typing determined automatically compiler 
ffl sml module system supporting data types hiding representations type checked interfaces 
ffl sml functional language 
sml programs written immutable data structures side effects allowed 
chapter 
background compiling functional languages mentioned chapter major challenges compiling functional languages compile function call return efficiently optimize runtime data representations 
aspects compiling functional languages attacked techniques described dragon book asu 
section reviews basic issues involved compiling function call return functional languages 
background efficient data representations discussed section section 
stack allocation heap allocation stack allocation commonly method implement function call return 
stack scheme contiguous region memory runtime stack 
activation record pushed stack function call popped stack function returns 
activation record normally contains formal parameters returned values access link saved registers temporaries local data 
access link pointer activation record function activation record enclosing function decided compile time 
access links function access non local variables stored activation records outer functions 
region memory static data code segment area fixed size program store code segment global variables 
third region heap dynamically allocated data stored 
languages pascal programmers responsible freeing dead data objects explicitly calling free dispose library function programs 
functional languages memory allocation deallocation done implicitly dead data objects reclaimed garbage collector 
function call return implemented stack scheme heap scheme 
stack scheme pushes activation record stack function call pops activation record stack function returns 
heap scheme allocates activation record heap function call function return activation record left heap reclaimed garbage collector 
chapter 
background fun fun val hd fun fun fun big big fun loop res res val big loop res val result loop higher order functions space safety higher order functions closures functions functional languages class values may passed arguments returned results put data structures implementing function call return complicated imperative languages pascal 
example presents example sml uses higher order functions 
function returns result nested function returns nested function returns nested function value computed selecting head list function big list length loop list copies function result function application big 
higher order functions implemented just lifo stack may called environments activation records popped stack 
usual solution problem represent functions closures lan 
function free variables said open closure data structure containing machine code address open function bindings non local variables free variables function 
machine code chapter 
background implementation function knows find values non local variables closure data structure 
table flat closures linked closures flat closures linked closures example table shows commonly closure representations flat closure linked closure 
flat closure car record holds free variables needed function 
example flat closure denoted contains just code pointer denoted plus values variable linked closure lan record contains bound variables enclosing function pointer enclosing function closure 
example linked closure contains code pointer locally bound variable pointer enclosing function closure 
space safety language common programmer variables scope dead current values needed 
garbage collected language garbage collector need variables roots live data 
implementors independently discovered really important collector traverses dead variables memory program increase large factor bak cha rw app jon 
fact collector starts statically determinable live variables keep asymptotically data live careful collector system space uses space size input 
theorem examples description compiler techniques safe space complexity described appel app chapter 
example shown illustrate problem 
flat closures evaluation yields closure contains just integers chapter 
background final result result contains copies closure uses space 
linked closures closure contains pointer closure contains list size final result keeps closures different instantiations simultaneously different large value variable requires space consumption 
space leak caused inappropriately retaining dead objects garbage collected earlier 
space leaks unacceptable 
closure frame representations cause space leaks see chapter 
instances real programs live data size memory unnecessarily large factors compiled early versions compiler introduced kind space leak 
versions sml nj obeyed safe space complexity ssc rule users really notice improvement 
ssc rule stated follows local variable binding unreachable scope see appel app formal definition 
assumption discussions dissertation assumption compiler satisfy safe space complexity rule 
experimental measurements measurements dissertation done dec workstation mega bytes memory ultrix 
table shows set benchmarks benchmark show source program size number lines degree modularity number modules files 
measurements file basic separate compilation unit 
benchmarks nucleic simple ray involves intensive floating point operations sieve kb comp frequently class continuations exceptions vliw kb comp heavy higherorder functions 
execution time measured standard unix timer facility interface provided sml nj compiler 
benchmark run times specific compiler 
performance different runs different pick fastest measurements treat file module separate compilation unit 
experience difference fastest run slowest run executable factor depending executable put main memory 
chapter 
background table general information benchmark programs program lines modules files description barnes hut body problem solver bh translated standard ml john reppy 
boyer standard theorem prover benchmark bm translated gabriel benchmark gab 
sieve cml implementation prime number generator written john reppy rep 
kb comp implementation knuth bendix completion algorithm implemented gerard huet processing axioms geometry 
lexgen lexical analyzer generator implemented james mattson david tarditi amt processing lexical description standard ml 
life game life written chris described book rea running generations gun 
ray simple ray tracer written don mitchell translated standard ml john reppy 
simple spherical fluid dynamics program developed realistic fortran benchmark chr translated id ea translated standard ml lal george 
vliw long instruction word instruction scheduler written john 
yacc lalr parser generator implemented david tarditi ta processing grammar standard ml 
mandelbrot curve construction written john reppy 
nucleic program computes dimensional structure part nucleic acid molecule ftl translated scheme standard ml peter lee 
chapter 
background run final performance data recommended example spec benchmark consortium sta 
compilers mentioned dissertation simple generation copying garbage collector app 
available memory divided half spaces allocation occurs low upper space called new space 
new space full live data new space old space typically fill old space 
allocator reset filling new space 
number minor collections old space occupies half total available memory data longer live 
garbage collection time dependent heap size 
measurements benchmark version compiler run amount memory ratio improvements space usage improvements garbage collection time 
amount memory benchmark ratio base case version 
chapter type directed compilation compile time type information valuable efficient compilation statically typed functional languages standard ml 
type directed compilation real compilers performance gain type optimizations yield 
order support efficient data representations gain experience compilation implemented new type middle back standard ml new jersey compiler 
chapter describes basic design new compiler identify number practical issues compare performance new compiler old non type compiler 
measurement shows combination simple type optimizations reduces heap allocation improves efficient code generated old non type compiler decstation 
compilers languages run time type checking lisp smalltalk compilation strategies oblivious actual types program variables simply type information available compile time 
statically typed languages standard ml sml mth sufficient type information compile time guarantee primitive operators applied values wrong type 
sml parametric polymorphism contexts types polymorphic variables completely known 
cases program manipulate values inspecting internal representation 
manipulate pass arguments store data structures necessary know size 
usual solution discard static type information adopt chapter 
type directed compilation approach dynamically typed languages represent program variables standard boxed representation 
means variable function closure argument function represented exactly word 
natural representation value fit word floating point number pointer heap allocated object 
source great inefficiency 
leroy ler representation analysis technique core ml require variables boxed word 
scheme data objects types polymorphic represented multiple words machine registers variables polymorphic types boxed representations 
polymorphic functions applied monomorphic values compiler automatically inserts appropriate coercions necessary convert polymorphic functions representation 
example sml code fun quad fun val res quad quad polymorphic function type ff ff ff ff ff calls standard calling convention passing argument general purpose register 
hand monomorphic function type real real monomorphic applications efficient calling convention passing argument floating point register 
passed polymorphic function quad quad wrapped standard calling convention called correctly inside quad 
representation analysis possible interesting type compiler optimizations 
existing compiler fully implemented representation analysis complete sml language practical implementation issues unclear 
example leroy ler shown detail insert coercions core ml address issues ml module system insert coercions functor application signature matching see section 
propagating type information middle back compiler incur large compilation overhead done carefully intermediate optimizations preserve type consistencies 
order answer questions gain experience compilation implemented new type middle back standard ml new jersey compiler sml nj am :10.1.1.55.9444
chapter describe chapter 
type directed compilation basic design new compiler identify solve number practical problems involved implementation detailed performance evaluation various type compilation techniques 
major contributions chapter follows ffl new compiler type compiler entire standard ml language 
ffl extend leroy representation analysis sml module language support module level abstractions functor applications 
ffl improve compilation speed code size partial types module boundaries memo izing coercions 
ffl evaluate utility minimum typing derivations bjo method eliminating unnecessary wrapper functions introduced representation analysis 
ffl show type annotations simplified successive phases compiler representation analysis interact continuation passing style sml nj compiler optimizer 
ffl compare representation analysis crude effective known function parameter specialization implemented kranz kra 
ffl measurements show combination type optimizations reduces heap allocation improves efficient code generated old non type compiler 
data representations important benefit type directed compilation allow data objects specialized types efficient data representations 
section explain detail standard boxed representations efficient alternatives type compilers 
non type compilers polymorphic languages old sml nj compiler am standard boxed representations data objects :10.1.1.55.9444
specifically primitive types integers reals tagged boxed argument result function field closure record tagged integer pointer objects standard boxed representations 
example value element record containing real numbers strings field boxed separately put top level chapter 
type directed compilation hello val hello world world val val standard boxed representations record 
similarly record containing real numbers field separately boxed standard boxed representations 
concrete data types variable element boxed standard boxed representations 
hello val hello world world val flat unboxed representations simple descriptors type compiler know types program variables efficient data representations depending complicated descriptor chapter 
type directed compilation want support runtime example sml nj compiler app rep am descriptor runtime objects just kind tag plus length object object may contain tagged boxed objects untagged unboxed objects 
scheme records contain real numbers represented real vectors records contain unboxed values real numbers boxed values pointer string represented layers extra box real number 
hello world hello world reordering fields compact descriptor val hello world val hello world naive way bitmap descriptor flat unboxed representations sophisticated descriptors sophisticated object descriptors represented efficiently shown 
naive way bitmap descriptor indicate field unboxed real numbers just mixed arbitrarily pointers see problem quite expensive garbage collector interpret descriptor 
know type element statically compile time better way reorder fields put unboxed fields ahead boxed fields see descriptor kind object just integers indicating length unboxed part indicating length boxed part 
concrete data types list efficient data representations possible 
know type real real list represented compactly shown 
major problem passed polymorphic function unzip function fun unzip fun rev rev statically typed languages sml descriptors kept runtime garbage collector trace pointer data structures 
chapter 
type directed compilation val compact representations concrete data type list list needs coerced efficient representations shown standard boxed representation shown 
coercions expensive costs proportional length list 
solutions solve problem ffl approach proposed leroy ler standard boxed representations concrete data type objects 
words know type real real list represent way shown car cell pointing object uses standard boxed representation 
example pairs normally represented flat real vectors added fetched list coerced flat representations standard boxed representations 
type compiler described uses approach 
lexp language described section special type called express requirements 
ffl approach described harper morrisett hm represent concrete data types efficient representations shown 
passed unzip pass type descriptor unzip indicating extract car field approach behaves practice clear see discussion section 
overview compiler section gives overview new type compiler 
organization new compiler similar old standard ml new jersey compiler described appel macqueen am :10.1.1.55.9444
compilation sml program grossly divided chapter 
type directed compilation type inference type checking elaboration module core language minimum typing derivations uncurrying inline expansions loop unrolling lexical analysis syntactic analysis elaborator type checker lambda translator target binary machine code machine code generator lexer parser raw syntax standard ml source program typed lambda language lexp continuation passing style cps continuation passing style cps closure passing style clo lexp types lty cps types cty ml semantic objects types inlining primitive operations translating lexp lty compilation pattern matches representations records concrete datatypes contractions eta reductions beta reductions closure strategies representations classic dataflow optimizations machine code scheduling generation register spilling allocation converting lexp cps cty argument passing conventions function calls closure converter cps optimizer cps converter inserting coercions representation analysis syntax overview new type sml nj compiler phases shown center column phase denoting certain set program transformations parsing input stream sml source program broken tokens lexical analyzer parsed context free grammar 
phase rewrites source program raw syntax tree ast intermediate language looks concrete syntax punctuation tokens discarded 
elaboration type checking raw syntax tree contain static semantic information furthermore contains syntactic sugar derived chapter 
type directed compilation forms 
phase elaborates program declarations specifications modules module interfaces type value declarations semantic objects static semantics mth types program variables inferred checked ml type inference algorithm dm mth 
raw syntax tree rewritten compact form called syntax declaration annotated corresponding static semantic type information calculated elaboration 
support representation analysis new compiler remembers details abstraction instantiation program 
details described section 
lambda translation phase syntax annotated static semantic information translated strict call value lambda calculus lexp augmented data constructors records primitive operators 
untyped lambda language older sml nj compiler am lexp explicitly typed simple monomorphic type system described section :10.1.1.55.9444
type information lexp converted directly static semantic information attached 
coercion functions style leroy ler inserted abstraction instantiation site correctly support abstraction polymorphism 
addition phase inserts proper implementation equality test assignment operator pattern match compilation 
details described section 
cps conversion phase typed lambda language lexp converted continuation passing style cps 
cps language designed match execution model von neumann register machine functions cps multiple arguments variables function arguments correspond closely machine registers 
lexp language cps language typed simpler set types cty described section 
lty information available lexp phase determines argument passing convention function calls returns representation records concrete data types 
details described section 
specifically polymorphic object referenced compiler remembers type instantiation type abstraction occurs functor application signature matching actual type type recorded 
chapter 
type directed compilation cps optimizations resulting cps expression fed rounds cps optimizations app contraction eta reduction beta reduction inlining expansion loop unrolling 
type correctness preserved optimizations transformations 
closure conversion phase explicit access nonlocal variables converting cps expressions closure passing style clo aj app 
clo cps functions clo contain free variables translated machine code directly 
new closure conversion algorithm described chapter extended utilize cps type information support efficient closure representations see section 
machine code generation clo expression cty information compiler register allocation instruction scheduling writes machine code 
summary new type compiler achieves type directed compilation performing sequence program transformations typed intermediate languages 
source program annotated static semantics translated intermediate lambda language lexp annotated simple monomorphic types lty module constructs polymorphic functions translated simple lambda functions records leroy representation analysis ler 
lambda expression converted continuation passing style cps annotated simpler cps types cty conversion determines representation records concrete data types argument passing convention function calls returns lty information 
back compiler uses cty information help generate efficient code 
fun square real fun real list fun real map square front issues core language chapter 
type directed compilation front issues main task front phases parsing elaboration 
elaboration determines source program typed formed definition mth records relevant semantic type information static environment 
type compiler elaboration remember details abstraction instantiation types modules program order implement module constructs polymorphic functions 
signature sig sig type val val 
structure struct type real real val fun val functor sig struct val structure sig abstraction sig structure front issues module language core language previous ml compilers take advantage static type information know deal polymorphism 
leroy representation analysis technique ler solves problem memorizing actual instantiation polymorphic type inserting proper coercions 
compiler 
polymorphic variable data constructor expression pattern syntax annotated ml types gathered type inference polymorphic type actual instantiation particular 
example sml program shown map standard map function lists polymorphic type ff fi ff fi 
ff list fi list map annotated chapter 
type directed compilation polymorphic type plus instantiation real real 
real list real list 
similarly data annotated original polymorphic type ff ff ff list ff list plus instantiation real real list real list 
table signature matching transparent type structure type structure real real 
real real real real ff ff 
ff real real real real real real table abstraction matching opaque type structure type structure 
ff ff 
ff real real real real module language sml module language contains instances type abstractions type instantiations dealt carefully order correctly support type directed compilation 
sml basic modules called structures encapsulated environments module interfaces called signatures environments associating specifications component names describe constrain structures 
parameterized modules called functors functions structures structures 
functor argument specified signature result structure expression may optionally constrained result signature 
module constructs abstraction instantiation may occur signature matching abstraction declaration functor application functor signature matching higher order modules tof mt 
example explain information recorded syntax tree elaboration phase ffl signature matching checks structure fulfills constraints specified signature creates new instantiation structure restricted view original structure 
elaboration phase automatically generates thinning function specifies visible components types thinning functions chapter 
type directed compilation substructures original structure new types instantiation structure 
example bound result matching structure signature sig 
signature matching sml transparent mt ler hl instantiation structure respectively type real real 
real real real real real real see table 
new types old types structure shown table recorded thinning function 
ffl abstraction treated signature matching 
matching abstraction opaque mt ler hl elaboration phase records result signature addition thinning function 
example abstraction structure signature sig 
remembers thinning function generated doing signature matching sig plus actual signature sig 
elaboration abstraction type ff ff 
ff real real instantiated real real 
real real real real signature matching abstracted 
see table 
ffl functor application remember argument thinning function actual instantiation functor 
example functor takes sig argument signature returns body structure contains value declaration type applied structure matched argument signature sig get actual argument instance say elaborator reconstructs new body structure say assuming argument component type real real real real real real 
elaborator records thinning function generated matched sig actual functor instance argument result 
ffl functor signatures essentially types functors 
functor signature functor elaborating functor signature matching functor equivalent elaborate functor declaration functor 
functor signature matching elaborator memorizes occurred functor application see case functor application plus thinning function generated matching result signature 
chapter 
type directed compilation minimum typing derivation damas milner type assignment algorithm dm elaboration phase compiler infers general type schemes sml programs 
result local variables assigned polymorphic types polymorphically 
example fun fun equal andalso equal variable type real real bool bound function equal assigned polymorphic type ff ff ff ff bool assuming ff equality type variable type real real real bool implemented minimum typing derivation phase compiler give local variables polymorphic types 
derivation done elaboration applied type correct programs 
algorithm similar bj rner algorithm bjo bottom traversal syntax 
traversal mark variables local bound hidden signature matching 
marked polymorphic variable gather actual type instantiations say reassign new type general type scheme generalizes new type assigned propagated declaration constraining variables referenced example bound equal function reassigned new type real real real bool operator implemented primitive equality function real numbers efficient polymorphic equality operator 
equal longer polymorphic coercion necessary applied monomorphic values 
translation lexp middle compiler translates syntax simple typed lambda language called lexp 
translation static semantic objects including types signatures structures functors translated simple lambda types lty coercions inserted abstraction instantiation site marked front correctly support representation analysis 
section explain details translation algorithm solutions practical implementation problems 
chapter 
type directed compilation datatype lty lty list lty lty type var int datatype option type lty datatype con int string string datatype lexp var var int int real string string string prim lty fn var lty lexp app lexp lexp fix var list lty list lexp list lexp switch lexp list con lexp list lexp option con lexp decon lexp record lexp list select int lexp raise lexp lty handle lexp lexp wrap lty lexp unwrap lty lexp typed lambda language lexp typed lambda language lexp lambda expression lexp data type lexp shown ffl variable var integer int real number real string string primitive operator prim ffl lambda abstraction fn argument argument type function body ffl function application app ffl set mutually recursive function definitions fix var list denotes function names lty list denotes types functions lexp list denotes corresponding function definitions ffl switch expression detects constant data constructor con lexp list build data type value evaluates corresponding expression see appel app details chapter 
type directed compilation ffl data constructor applied argument con injection value carrying data constructor removed argument decon projection data constructor essentially constructor representation plus lambda type information ffl record expression field evaluated expression ffl select expression selects ith field evaluated expression ffl raise ing exception annotated result type evaluation expression scope exception handler ffl primitive wrapper expression wrap wraps evaluated expression type exactly word ffl primitive expression unwrap evaluated expression natural unboxed representation type type lty data type lty shown ffl primitive integer type primitive real type ffl record type types fields specified ffl functor type argument type result type ffl machine level pointer type points objects arbitrary representations ffl special machine level pointer type point objects standard boxed representations details discussed section lty information essentially characterizes possible data representations runtime 
order support coercion data objects representation define coerce operation lambda language just wrap unwrap functions leroy ler 
specifically coerce compile time operation coerce returns coercion function coerces lexp type lexp type ffl equivalent coercion necessary coerce returns identity function 
chapter 
type directed compilation ffl requires coercing arbitrary unboxed object pointer vice versa coercion primitive wrap unwrap operation written coerce unwrap coerce wrap 
ffl requires coercing arbitrary unboxed object pointer vice versa object coerced standard boxed representation vice versa coercion similar recursive wrapping operations defined leroy ler 
defined coerce coerce dup coerce coerce dup function dup defined follows dup dup dup lty ffl build list coercions field coerce assume new lambda variable corresponds old record coercion record field new record defined select var expression lexp idiom equivalent expression app fn 
ffl build coercions argument result coerce coerce assume new lambda variables coercion fn app var 
translating static semantic objects lty syntax translated lambda language lexp simple top traversal tree 
traversal static semantic types translated 
signature structure object translated field lty translated corresponding component functor object translated argument signature argument lty body structure result lty 
translation ml type lty done algorithm see function ty lty pseudo code chapter 
type directed compilation fun ty lty mark type variables appear constructor type return lty fun lty ff oe lty oe lty lty lty lty lty lty lty int lty bool lty unit lty real lty ff ff marked type variable lty constructor type rigid translating ml type lty signature vector sig type vec val tabulate int 

vec val real vec real vec 
real functor vector struct val tabulate fn 
val structure struct type vec fun tabulate val real structure flexible constructor type recursively boxed ffl type variables divided kinds appear constructor types ff type ff ff list ff list fi type fi ref fi unit translated type variables fl fl fl fl translated record type constructors function type constructors counted 
chapter 
type directed compilation ffl polymorphic type form ff ff quantifications just ignored lty just lty translated ffl primitive types int bool unit translated real translated primitive types translated ffl arrow type constructor functions translated record type constructor translated fields symbolic label 
ffl rigid constructor types ff list real real ref translated ffl flexible constructor types translated 
example signature vector translated lty component tabulate lty component lty 
functor translated lty result type lty 
structure lty component tabulate lty component lty 
result structure functor application lty 
understand flexible constructor types arity translated look functor closely 
type vec argument signature flexible know exact data representation definition commentary mth mt type constructor names defined type specification signatures flexible type constructor names rigid 
chapter 
type directed compilation know actual instantiation vec functor application time 
body functor type vec may instantiated real vec done function application tabulate fn 

clearly know coerce vec int vec exactly data representation standard boxed representation 
flexible constructor types signature matching functor application may instantiated type 
example type vec functor signature instantiated tuple type see definition structure functor application 
rigid constructor types concrete data types 
rigid constructor type bound non data type sml type done type abbreviation 
type abbreviations expanded elaboration see definition mth 
discussed section concrete data types polymorphic data representations 
data object needs put fetched certain concrete data type representation recursively wrapped unwrapped 
type variables appear constructor types translated 
doing expensive coercions polymorphic monomorphic data type objects avoided 
translating lexp explained translate static semantic objects lty coerce lty translation lexp straightforward polymorphic variables polymorphic variable front annotated polymorphic type oe plus actual instantiation assume oe translated variable translated lexp expression coerce var 
pattern matching pattern matches compiled way old compiler ar am app 
difference insert coercions polymorphic data constructor projections decon see item 
polymorphic data constructors polymorphic data constructors treated polymorphic variables coercions applied data constructor injections con projections decon 
example projection function list chapter 
type directed compilation cons constructor appearing function polymorphic type ff ff list 
ff ff list translated lty 
projection function instantiated type real list 
real real list translated lty projection coerced applied actual argument list 
polymorphic primitive operators polymorphic primitive operators implementations known compile time specialized actual type instantiations 
example polymorphic equality translated primitive equality integer assignments updates unboxed update function composition operator nicely specialized avoiding expensive coercions 
signature matching suppose structure matched signature sig result instantiation structure thinning function generated front translated coercion fetches component coerces type specified denoted translation signature matching simply 
abstraction abstraction translated way signature matching result coerced lty signature sig 
assume sig respectively abstraction structure sig coerce 
functor application suppose argument signature functor sig applied structure front recorded thinning function matching sig actual functor instance assume result matching sig denoted lexp expression respectively lexp expression coerce functor application translated app 
order support generational garbage collection lh ung compilers bookkeeping update pointers older generation youngest generation correctly identified 
unboxed update special operator assigns unboxed value cell updates unboxed updates introduce new pointers extra bookkeeping necessary 
chapter 
type directed compilation practical issues practice naive implementation translation algorithm lead particularly large lexp expressions large excessive coercion code 
problem extremely severe programs contain functor applications large structure signature expressions 
example top level linking program sml nj compilation manager cm contains lines source code functor applications signatures involved externally defined extremely large 
result lexp expression orders magnitude larger form 
compilation programs orders magnitude slower consume large amount memory 
simplest way decrease size coercion code avoid unnecessary eta redexes introduced coerce procedure 
sure coercing equivalent introduces coercion code 
example suppose coerce builds list coercions field coerce identity functions coercion code built proceeds usual 
check done coercing 
certain cases naive translation may drag large useless 
example compile code val compiler control cg compiler reset really need know variable type int variable reset type unit unit translation algorithm include type structure compiler may contain hundreds components 
extend lty lexp language new constructs datatype lty 
int lty list lty list datatype lexp 
lexp list record particularly module constructs structure signature objects 
lty type external structures compiler structure specifies subset actual fields corresponding interesting current compilation unit 
external structure identifiers inferred translation phase translated corresponding static chapter 
type directed compilation semantic objects 
example lty structure compiler example assume control respectively th th fields compiler cg th field control th field cg reset th field 
effective way avoid excessive coercions share coercion code equivalent pair 
specifically build hash table translation phase pair index contents hash table lambda variable corresponds shared coercion code expressed lexp expression fn coerce 
time need insert coercion check hash table retrieve corresponding lambda variable table add new entry table 
translation phase shared coercions defined top level resulting lexp expression 
coercions introduced coerce procedure normally inlined cps optimization phase applied just 
shared coercions inlined may cause excessive code explosion 
shared coercions expensive general inlined coercions hashing approach coercions module objects 
compromise works extremely practice mainly large module objects causing excessive coercion code problem 
module level coercions executed generated code noticeably slower 
typed cps back nice thing compiler phases shown completely independent 
phase collection transformations intermediate form internal interfaces clean 
example front checks source program verify typed formed static semantics 
middle translate lexp implementation decision pattern matching module constructs polymorphic functions requires translating static semantic objects inserting proper coercions instantiation abstraction sites need chapter 
type directed compilation datatype value var var int int real string string string datatype int datatype cexp record value list var cexp select int value var cty cexp app value value list fix function list cexp switch value var cexp list branch value list var cexp cexp value list cexp value list var cty cexp arith value list var cty cexp pure value list var cty cexp withtype function var var list cty list cexp datatype cty int option funt typed cps language worry records functions represented runtime 
cps back compiler contains phases conversion lexp cps cps optimization closure conversion machine code generation 
cps conversion phase converts lexp expression continuation passing style cps implementation decisions records data constructors function applications switch statements 
resulting cps expression annotated cps types cty fed rounds cps optimization described appel app converted closure passing style clo closure converter 
clo expression cty information compiler register allocation instruction scheduling writes machine code 
typed cps language presents new typed cps language defined data type cexp new cps types cty defined data type cty 
old cps language app see appel app details cps convert data constructors switch statements 
chapter 
type directed compilation arguments function primitive operators values variables constants defined data type value 
cps expression ffl record ul ce expression specifies record kind vector closure ul list elements direct value value accessible certain path result binds cps variable referenced rest cps expression ce notice cty specified reconstructed ffl select ce expression binds th field cty ffl function continuation application app ffl set function definitions fix function type function specifies function kind continuation escaping function function variable name list arguments arguments function body ffl primitive switch expression switches integers ffl set branch primitive operations branch ffl set primitive operations side effects ffl set access arithmetic arith miscellaneous pure primitive operations operations takes arguments value list binds result cps variable cty specified 
pure operators include special primitive wrapper operators integers reals pointer objects wrap unwrap 
cps type language cty simpler lty 
specifies cps variable integer real function funt continuation pointer heap record 
pointer type carries length value option denotes length heap object points object length unknown compile time objects concrete data types polymorphic objects length field contains 
translation lty cty quite straight forward shown lty cty function chapter 
type directed compilation fun lty cty lty cty lty cty funt lty cty lty cty lty cty length specifically translated funt length record 
notice cps conversion phase implementation decisions records functions cty concerned details 
converting lexp cps structure algorithm cps conversion phase described appel app 
conversion function takes arguments lexp expression continuation function type value cexp returns cps expression result 
appel app conversion process gather lty information lexp expression maintain lty environment cps variables 
lty information help implementation decisions records function calls translated cty annotate cps variables 
converting lexp records interesting case 
lexp expression record suppose lty represent record virtually layout ffl simplest way box field integers tagged reals boxed see 
approach old non type sml nj compiler am app 
approach clearly inefficient 
ffl record represented flat real vector shown section 
ffl runtime system supports descriptors bitmaps specify field boxed unboxed field simply mixed bitmap descriptor record inferred lty shown section 
ffl way layout boxed unboxed values reorder fields unboxed values put ahead boxed values shown section 
chapter 
type directed compilation advantage simple descriptor specifies length unboxed chunk boxed chunk 
kind descriptor cheaper garbage collector interpret bitmap 
clearly lexp select expressions converted layout convention records 
cps conversion decides argument passing convention function calls returns 
lexp function fn depending convert multi argument function arguments essentially correspond registers 
record type length record say sufficiently small pass arguments registers 
assume new cps variables denotes th field type suppose vl cl return continuation fn fix fk vl cl ce var ce cps conversion lambda expression record var 
var return continuation fk function kind 
similarly function defined new cps variables ul var var converting function application defined app fix kl hdr app ul return continuation defined kl hdr series select expressions fetch fields cps conversion function definition application may introduce redundant record creation selection code 
fortunately eliminated cps optimization phase app 
primitive coercion operations wrap unwrap converted corresponding cps primitive operations 
pointer types wrap unwrap translated wrap unwrap 
cps optimizations cps conversion phase finished compiler implementation decisions program features objects structures functors compiled records functions polymorphic functions coerced properly polymorphically pattern matches compiled switch statements compilation parameter serves threshold value current value 
chapter 
type directed compilation concrete data types compiled tagged data records constants records laid appropriately types function calling conventions decided 
resulting cps program inefficient 
job cps optimizer apply simple transformations fi reduction constant folding reduction uncurrying rewrite cps program smaller efficient semantics 
cps annotated cty information cps optimizer faithfully preserve propagate cty information transformations 
turns easy cps optimizations naturally carried type consistent fashion 
extra copy cty information function inlined unrolled overhead minimal simple set cps types 
described appel app new cps optimizations performed ffl cancel pairs wrapper operations long kind wrap unwrap 
optimization useful eliminating extra introduced lambda translation phase 
ffl eliminate record copying operations example suppose cps value selected th field record built fields order cty tell just copy object identity records ml replace uses eliminate copying operations 
impossible old compiler am app length information record known cps 
closure conversion representations cps functions fixes exactly von neumann machine functions nested lexical scope 
closure conversion phase explicit access nonlocal variables converting cps expressions closure passing style clo 
clo really subset language cps clo function contains extra arguments denote environment non local variables 
compiler uses new space efficient closure conversion algorithm described chapter 
new problem caused typed cps language decide put unboxed values untagged integers unboxed reals heap allocated closures machine registers 
divided cases chapter 
type directed compilation ffl known functions call sites known compile time environment allocated general purpose floating point registers depending cty information free variables 
ffl continuation functions assign floating point registers callee save registers approach described chapter 
floating point portions closure type allocated floating point callee save registers 
ffl closure containing boxed unboxed values allocated heap layout scheme normal program records described section 
optimization commonly closure conversion share closures functions 
unfortunately closure sharing done carefully safe space complexity app see section 
typed cps back object size information cps variable known time cty type easily identify safe share closures 
long extra objects held constant size sharing closures cause asymptotic increase space usage 
machine code generation variable clo annotated proper type information register allocation spilling straightforward 
real numbers unboxed representations variables cty assigned floating point register 
number free variables register class certain point program exceeds number available registers spilling necessary 
believe cty information benefit instruction scheduler explored current implementation 
performance evaluation type directed compilation support efficient data representations 
order find performance gain get different type optimizations measured performance different compilers twelve sml benchmarks see section 
chapter 
type directed compilation compilers simple variations standard ml new jersey compiler version 
compilers new closure conversion algorithm described chapter general purpose callee save registers tagged bit integer representations 
aspects compilers close described appel app 
sml nrp version support representation analysis 
type information propagated compiler middle back 
data objects uniform standard boxed representations 
functions take exactly argument return result 
sml fag sml nrp compiler argument flattening optimization turned app 
specifically function call sites known compile time cps optimizer check argument length record tuple case argument record flattened transformed argument function 
sml rep new type compiler supports basic representation analysis 
version minimum typing derivations see section bj rner bjo 
floating point numbers boxed representations 
functions pass arguments return results floating point registers 
sml mtd sml rep compiler plus implementation minimum typing derivations 
sml ffb sml mtd compiler extended support unboxed representations floating point numbers 
function call return pass floating point arguments floating point registers 
records contain just float point numbers represented flat real vectors see 
records contain boxed unboxed values represented layers unboxed value boxed separately see 
sml fp version completely sml ffb compiler floating point callee save registers 
unfortunately sml nj version uses old runtime system app 
memory fetch store floating point number implemented normal word memory load instructions 
flat real vectors need aligned double word boundary 
chapter 
type directed compilation name benchmark programs ffi sml nrp ffl sml fag sml rep sml mtd pi sml ffb sml fp boyer sieve kb life simple ray vliw nucleic ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl pi pi pi pi pi pi pi pi pi pi pi pi comparison execution time illustration measurements done dec workstation mega bytes memory methodology described section 
table list compare execution time running benchmarks compilers 
execution time user time plus system time seconds sml nrp compiler shown performance compilers denoted relative ratio sml nrp compiler 
similarly table table table respectively compares total amount heap allocation mega bytes compilation time seconds code size bytes 
draw comparisons chapter 
type directed compilation table comparison execution time program base sml nrp sml fag sml rep sml mtd sml ffb sml fp seconds ratio ratio ratio ratio ratio ratio boyer sieve kb comp lexgen yacc life simple ray vliw nucleic average table comparison total heap allocation program base sml nrp sml fag sml rep sml mtd sml ffb sml fp mbytes ratio ratio ratio ratio ratio ratio boyer sieve kb comp lexgen yacc life simple ray vliw nucleic average ffl type compilers perform uniformly better older compilers support representation analysis 
sml ffb compiler gets nearly speedup execution time decreases total heap allocation average older sml nj compiler sml fag uses uniform standard boxed representations 
comes average increase compilation time 
generated code size remains 
chapter 
type directed compilation table comparison compilation time program base sml nrp sml fag sml rep sml mtd sml ffb sml fp seconds ratio ratio ratio ratio ratio ratio boyer sieve kb comp lexgen yacc life simple ray vliw nucleic average table comparison code size program base sml nrp sml fag sml rep sml mtd sml ffb sml fp kbytes ratio ratio ratio ratio ratio ratio boyer sieve kb comp lexgen yacc life simple ray vliw nucleic average ffl simple non type argument flattening optimization sml fag compiler gives impressive speedup 
optimization slow compilation little bit 
ffl sml rep compiler supports passing argument registers floatingpoint registers improves performance non typed sml fag compiler 
decrease heap allocation impressive 
believe chapter 
type directed compilation computation intensive parts loops recursions known functions argument flattening get performance benefits type compiler sml rep ffl minimum typing derivation technique intended useful eliminating coercions major speedup sml mtd compiler sml rep life benchmark minimum typing derivation polymorphic equality tight loop testing membership element set successfully transformed monomorphic equality operator 
polymorphic equality implementation sml nj extremely slow uses runtime life times faster 
benchmarks sml mtd performs sml rep larger number coercions lambda language sml rep coercions eliminated cps optimization phase app eta reduction inlining constant folding 
ffl observation sml mtd compiler compilation faster sml rep 
probably extra pass deriving minimum types took away gains coercion eliminations sml mtd 
ffl floating point callee save registers sml fp compiler better floating point callee save registers 
slowdown comes benchmarks sieve kb comp tight loops frequently class continuations exception handlers callee save registers register state bigger see section discussions 
addition certain floating benchmarks nucleic gets slower 
believe current implementation closure conversion heuristic tuned floating point callee save registers 
related statically typed languages hindley milner polymorphism long compiled uniform boxed representations just dynamically typed languages lisp scheme 
representation analysis technique proposed leroy ler ml languages peyton jones launchbury pl haskell languages allows data objects types polymorphic efficient unboxed representations 
leroy ler implemented representation analysis gallium compiler chapter 
type directed compilation caml light dialect ml shown result important speedups certain benchmarks 
described chapter re implementation leroy techniques standard ml new jersey compiler am :10.1.1.55.9444
leroy ler concentrate practical issues implement type directed compilation entire sml language caml simpler module system sml efficiently propagate type information rounds transformations optimizations 
people worked eliminating unnecessary wrapper functions introduced representation analysis 
proposes way tag type annotation statically determine boxed representations unboxed representations 
major problem technique easy extend sml module system 
henglein jorgensen hj presents term rewriting method translates program coercions contains minimum number coercions statically 
clear technique easily extended sml module language 
compiler uses simple minimum typing derivation bjo round front decrease degree polymorphism local hidden functions 
easy extend module system 
believe approach achieve result formally optimal unboxing hj 
shown wrapper eliminations effect performance highly optimizing compiler sml nj simply simple compile time contraction eliminate wrap unwrap pairs see section 
peterson pet presents way decide boxed unboxed representations data flow analysis 
clear performance gain get kind expensive analysis 
harper morrisett hm proposed type compilation framework called compiling intensional type analysis core ml language 
typed lambda calculus explicit type abstractions type applications intermediate language 
scheme avoids recursive coercions passing explicit type descriptors monomorphic value passed polymorphic function 
implemented scheme unclear behave practice 
proposal addresses core ml language know easily scheme extended sml module language 
chapter 
type directed compilation summary believe type compilation techniques widely compiling statically typed languages ml 
beauty type representation analysis places burdens user source language change programmers need write coercions separate compilation works cleanly interfaces types 
implementing fully working type compiler entire sml language gained experience type directed compilation solved practical problems involved implementations 
performance evaluation shows type compilation techniques achieve significant speedups range benchmarks 
number ways type information help generate better code endless chapter discusses evaluates small number optimizations 
intend evaluate optimizations 
chapter space efficient closure representations modern compilers implement function calls returns steps closure environment properly installed provide access free variables target program fragment second control transferred target jump arguments results 
closure conversion decides represent closures runtime crucial step compiling functional languages 
new algorithm exploits compile time control data flow information optimize closure representations 
extensive closure sharing allocating closures registers possible new closure conversion algorithm reduces heap allocation memory fetches local global variables improves efficient code generated standard ml new jersey compiler decstation 
approaches new closure allocation scheme satisfies strong safe space complexity rule achieving asymptotic space usage 
compilers functional languages take great efforts optimize function calls returns fundamental control structure 
function call context information saved registers frame 
compiler continuationpassing style cps frame closure continuation function ste 
cps compiler closure environment constructed function continuation definition site provides runtime access bindings variables free chapter 
space efficient closure representations function continuation body 
function call implemented installing corresponding closure environment setting arguments normally registers jumping target 
function returns implemented way cps represented calls continuation functions 
closure combination registers memory data structures gives access free variables kkr 
compiler free choose closure representation minimizes stores closure creation fetches access free variables memory reachable data 
developed new algorithm choosing closure representations 
far know new closure allocation scheme satisfy important properties ffl stack allocation traditional linked closures shared closure representations safe space complexity see section time allow extensive closure sharing 
ffl closure allocation scheme exploits extensive compile time control data flow information determine closure representations 
ffl source language functions sequential function calls build shared closure continuations advantage callee save registers 
ffl activation records frames allocated heap freely shared heap allocated closures 
stack allocation impossible stack frames normally shorter lifetimes heap allocated closures 
ffl tail recursive calls quite troublesome implement correctly stack han implemented easily 
ffl closure optimizations cleanly represented continuation passing closure passing style aj intermediate language 
ffl closure created writes generational garbage collection call cc efficient reduces need alias analysis compiler side effect operations 
ffl closures allocated heap registers class continuations call cc efficient requiring complicated stack hdb :10.1.1.40.6828
chapter 
space efficient closure representations new closure allocation scheme runtime stack 
closure environments allocated heap registers 
decision may controversial stack allocation widely believed better locality deallocation stack frames cheaper garbage collection 
heap allocated closures contiguous memory extra memory write read frame pointer necessary function call 
assumptions hold algorithm reasons 
show section parts continuation closures allocated callee save registers extra memory write read call avoided 
help compile time control data flow information combination shared closures callee save registers comparable better stack allocation 

chapter show stacks significantly better locality heap allocated activation records modern cache memory hierarchy 
stacks better write ratio better read ratio 
modern machines write penalty approximately zero jou dtm rei 

amortized cost collection low app see chapter especially modern generational garbage collection techniques ung 
major contribution chapter safe space closure conversion algorithm integrates improves previous closure analysis techniques kra ste han joh simple general framework expressed continuationpassing closure passing style aj 
new algorithm extensively exploits compile time control data flow information optimize closure allocation strategies representations 
measurements show decstation new algorithm reduces heap allocation memory fetches local global variables improves efficient code generated standard ml new jersey compiler 
safely linked closures optimization closure representations dangerous unsafe space usage see section 
traditional stack allocation schemes linked closures obviously chapter 
space efficient closure representations fun fun val hd fun fun fun big big fun loop res res val big loop res val result loop example standard ml table comparison closure representations flat closures linked closures safely linked closures qs phi phi phi phi violate ssc rule see section local variable bindings live function exits scope may 
flat closures satisfy ssc rule require variables copied times closure 
closure strategies described appel jim aj stack frame implementations violate ssc dead variables remain frame function returns 
chapter 
space efficient closure representations obeying ssc require extra copying pointer values old closure contains contains values needed new context new closure 
simply zap unneeded values old closure known old closure 
challenge find efficient closure strategies obey ssc minimizing copying 
new algorithm uses safely linked closures rd column contain variables needed function avoids closure copying grouping variables lifetime sharable record 
example consider sml program program shown section 
denote closure code pointers 
flat closures st column variables copied closure closure closure expensive 
traditional linked closures nd column closures re closure retaining variable free accessing variables inside quite expensive links needs traversed 
noticing lifetime safely linked closure puts separate record shared closures linked closures nesting level safely linked closures exceeds enjoy fast variable access time 
continuations closures illustrate cps conversion new plo ste kra app new closure analysis algorithm example 
function iter iteratively applies function argument converges satisfy predicate fun iter fun function iter standard ml chapter 
space efficient closure representations variable integer constant real constant arithmetic operator fun val select val val syntax cps continuation passing style continuation passing style cps subset calculus certain syntactic properties 
calculus order evaluation cps pre determined 
purposes chapter express cps ml notation albeit severely constrained see 
atom variable constant record constructed sequence atoms 
bound element record th field fetched select syntax building records selecting fields applying primitive arithmetic operators defining mutually recursive functions fun specify continuation expression result expressions 
hand function application shown line right specify continuation expression functions return conventional sense 
expected functions pass continuation functions arguments 
function defined ordinary way fun presumably invoked callee order continue computation 
shows code function iter translation cps loop invariant continuation argument hoisted loop app 
chapter en 
denote sequence expressions en 
chapter 
space efficient closure representations fun iter fun fun fun function iter cps optimizations optimizations performed cps conversion closure analysis subject chapter 
ease presentation capital letters denote continuations 
call functions declared source program user functions iter introduced cps conversion continuation functions 
continuation variables formal parameters commonly placed argument introduced cps conversion serve return continuations 
functions iter called escaping functions may passed arguments stored data structures means compiler identify places called 
functions escape called known functions 
extensive optimizations known functions know call sites compile time 
closure passing style continuation passing style meant approximate operation machine language function machine language just address executable program convention registers hold parameters jump arguments 
notion function cps cps nested lexical scope may contain free variables 
problem solved adding closure explicit access nonlocal variables 
kranz kkr kra showed different kinds functions different closure allocation strategies 
example closure known function allocated registers know call sites compile chapter 
space efficient closure representations time require caller pass free variables extra arguments hand closure escaping function may allocated heap record contains machine code address function plus bindings free variables 
conventional compilers caller save registers may destroyed procedure call callee save registers preserved calls 
variables live call allocated caller save registers cuts register saving 
fun iter fun cr fun val select val select val select val select fun val select val select val select cr val cr cr function iter closure conversion wanted adapt idea continuation passing intermediate representation 
follows cps converted user function passed ordinary arguments continuation function extra arguments function returns invoking result argument additional arguments callee save arguments handed back continuation 
cps code translated machine instructions stay registers execution needed registers purposes case chapter 
space efficient closure representations save restore 
say continuation represented registers 
previous outlined framework demonstrated reduce allocation memory traffic 
really algorithm exploit flexibility callee save registers provide 
closure creation represented cps language aj kh 
call closure passing style clo 
main difference clo cps functions clo contain free variables translated directly machine code 
clo formal parameters function correspond target machine registers heap allocated closures represented cps records 
lists code function iter translation clo 
continuation function variable represented machine code pointer plus extra callee save arguments 
original function free variables callee save registers variables effective total 
passed line free variables plus machine code pointer entry point squeezed formal parameters 
free variables callee save arguments heap allocated records containing variables cr closure record appears call line 
previous closure conversion algorithms ste kkr aj require memory stores continuation function 
important advance new allocate example record cr functions record carefully chosen contain loop invariant components built outside loop 
escaping user function iter represented closure record th field machine code pointer iter 
escaping function call implemented selecting th field placing closure special register formal parameter doing jump arguments lines 
closure conversion section new closure conversion algorithm framework defined section 
algorithm takes cps expression argument determines closure representation function definition converts clo chapter 
space efficient closure representations expression function definition closed 
presentation algorithm organized steps 
construct extended cps call graph captures control flow information cps expression 

gather set raw free variables lifetime information cps function 

closure strategy analysis determine machine allocate closure 

closure representation analysis determine actual structure closure runtime 

find variable access path non local variables cps function 
step necessarily correspond separate pass real implementation example steps done single pass 
extended cps call graph cps expression divide set function definitions categories escaping user functions known user functions escaping continuation functions known continuation functions see paragraph section definitions 
cps variables directly calls possibly function call inside function definition example directly calls call inside extended cps call graph directed graph set function definition variables nodes edge directly calls directly calls function return continuation 
example extended cps call graph function iter follows pi iter directly called conservatively assume function call return continuation chapter 
space efficient closure representations extended cps call graph essentially captures simple set control flow information cycles graph imply loops recursions path 
nested hierarchies loops recursions revealed running tarjan interval analysis algorithm tar rp assuming reducible flow graph 
flow graph tarjan interval essentially single entry strongly connected subgraph interval analysis rp partitions set nodes disjoint intervals interval representing proper loop recursion layer 
purpose closure analysis control flow information choose closure representations allow efficient variable accesses frequently executed program fragments loops 
function definition define loop level nesting depth interval extended cps call graph interval depth 
variables defined loop levels defined 
loop level call defined min 
loop level arbitrary cps expression inside function definition inductively defined follows ffl max ffl ffl continuation max user function return continuation 
loop level number guide static branch prediction control flow example function iter loop level loop level iter 
cps expression definition calls return continuation calls continuation variable clearly call inside loop call 
closure representations biased branch taken runtime 
function definition expression define pred predecessor set set variables edge extended cps call graph 
shivers shi presents sophisticated techniques find better approximations control flow information 
chapter 
space efficient closure representations table raw free variables closure strategies function stage number raw free variables closure strategy iter slot slots slots slots raw free variables lifetime implement safely linked closures described section want group variables closure records similar lifetimes 
defined may registers hold waiting earlier record obey ssc rule 
closure conversion algorithms app kra ste start phase gather set raw free variables function definition free variables called raw free variables may substituted set free variables closure representation analysis phase term true free variables denote set variables put closure environment 
algorithm gathers raw free variables lifetime information 
define lifetime variable assign stage number denoted sn function definition method ffl function definition sn ffl user function sn sn nearest enclosing function definition ffl continuation function sn maxf sn pred definition valid continuation functions recursive 
intuitively stage number meant characterize temporal relation different cps functions 
definition sn observation user function called enclosing function called 
addition sure call graph particular user function continuations higher stage numbers called lower stage numbers 
stage number define time cps variable sn nearest enclosing function definition set chapter 
space efficient closure representations free variables function definition set triples fut lut variable fut time denoting smallest stage number uses inside lut time denoting largest stage number uses inside reflect control flow lut fut numbers calculated predicted execution frequency example cps expression ignore uses calculation 
higher preference uses inside loop body lead efficient closure representation runtime 
example stage number set raw free variables function definitions shown table 
notice variable different lut fut numbers inside different function definitions 
closure strategy analysis closure strategy analysis essentially determines machine allocate closure 
previous cps compilers kra ste escape analysis simply runtime stack 
closure strategy analysis decides slots registers closure going denoted function calculate simple algorithm see code escaping user function 
essentially means free variables put heap 
closure pointer linked data structure heap 
escaping continuation function number callee save registers 
call sites known compile time continuation functions uniform convention callee save registers 
special cases escaping continuation functions represented differently discussed section 
known functions call sites known compile time closures environments may allocated completely registers 
number registers target machine limited may desirable allocate free variables registers see section 
run iterative algorithm calculate appropriate number slots registers known function escape analysis refers analysis decides function environment allocated stack 
chapter 
space efficient closure representations notations free set raw free variables max gamma free free algorithm initialized number target machine registers repeat foreach set variables pred enclose definition foreach min reach fixpoint closure strategy analysis known functions initially known function assigned slots maximum number available registers target machine minus number formal parameters function assuming passed registers known function substitute min ft 
subset functions pred enclose definition free value max gamma number variables free substitution process repeated longer changes fixed point reached 
step observation called inside function free number slots assigned bigger number slots available environment kind spilling inevitable 
choosing subset calculating step take advantage control flow information extended cps call graph 
specifically want favor program fragments executed choose higher value call loop 
apply algorithm function iter 
suppose registers initially 
assuming iterative process clearly terminates sum functions gets smaller round 
chapter 
space efficient closure representations available registers target machine calls free min gamma shown table 
notice call iter considered free iter 
closure representation analysis closure representation analysis solves problem function contains free variables assigned slots place values slots 
cps expression closure representation analysis done processing function definition preorder traversal traversal maintain update data structures static environment maps function definition processed far closure representation 
list currently visible closures variables 
current contents callee save registers 
traversing processing function definition 
suppose set raw free variables step section rfv 
recursive mutually recursive function compute transitive closure rfv raw free variables 
example shown table function recursive rfv remove replace raw free variables 
propagate fut lut numbers free variables minimum fut numbers maximum lut numbers 
result transitive closure rfv 
find set true free variables replacing continuation variable rfv corresponding callee save variables function definition closure contents slot variables 
example suppose callee save registers continuation variable represented code pointer callee save variables 
set true free variables notice naturally inherit fut lut numbers 

assume contains variables assigned slots closure strategy analysis section 
done 
chapter 
space efficient closure representations assigned slots number free variables unused slots just filled integer zeros 
search current list visible closures maintained data structure see closure record reuse share 
ssc rule mentioned section satisfied making sure reuse closures contents subset 
closures heap safely linked closures certain closure sharings anticipated processing enclosing function definitions 
multiple sharable closures best fit heuristic decide reuse 
example function iter closure cr line sharable continuations 
size closure sharing larger heap allocate part closure 
putting gamma variables individual slots packing remaining gamma variables heap closure 
criteria choosing gamma variables priorities priority smaller lut number variables die earlier second smaller fut number variables referenced earlier third variable current callee save registers 
contents decide variable goes slot reduce register moves 
example function assigned slots true free variables put free variable register smallest fut number variables lut number 

decide actual layout spilled heap closure gamma variables variable lut number 
satisfy ssc shared closures distinct lut number requires separate record 
example closure split records lut number different finish processing function definition updating environments closure representation 
cr shared creation outside loop 
iteration manages call unknown escaping functions memory traffic 
important strengths new algorithm 
case possible escaping continuation functions 
specifically suppose function encloses safely linked closure built contain separate chunks free variables free chunks shared 
chapter 
space efficient closure representations access path non local free variables computing access path non local free variable done breadth search environment 
lazy display technique kra keep cache access paths loads common paths shared 
specifically look function innermost function inside assuming uses safely linked closure shown accessing non local variable inside requires traversing links load nd field closure register access directly load 
intermediate variables register may available machine registers cause unnecessary register spilling avoided selectively keeping limited number intermediate variables lazy display registers 
remarks graph coloring global register allocation targeting cha implemented sml nj lal george accomplishes control transfers function calls line register register moves 
allows flexible boundary callee save caller save registers normal compilers 
programs scheme tend accumulate values registers dump closure infrequent intervals 
may useful callee save fewer caller save registers optimize reduce total heap allocation closure scheme handles tail calls nicely simply re arranging registers 
hanson han shows complicated things necessary re arrange stack frame 
source language function calls functions sequence previous cps compilers including allocate continuation closure call 
callee save registers safely linked closures allow allocate simple shared closure 
general deep recursions handled efficiently scheme 
conventional stack implementation tends high space overhead frame frame contains variables live current scope violates ssc rule see section 
safely linked closures contains variables actual live quite concise 
memory usage deep recursion 
chapter 
space efficient closure representations case studies environment allocation scheme implement frequently control structures efficiently 
compilers identify special control structures compile time assign special closure allocation strategy 
example kranz orbit compiler kra tail recursions assigned called stack loop strategy general recursions assigned stack recursion strategy 
new closure conversion algorithm hand uniformly decides closure strategy number slots closure representation function solely lifetime information free variables simple control flow information 
section described algorithm implements tail recursion efficiently function iter 
section examples show new algorithm effectively deals common control structures sequence function applications calling known function general recursion 
function calls sequence common control structure functional programs making sequence function applications shown example fun val val val function formal parameter called times row inside function traditional stack scheme function called activation record containing formal parameters local variables pushed stack 
time called certain local variables registers saved stack 
example assuming function arguments return results passed registers call registers holding saved retrieved returns 
activation records allocated heap things get worse 
time registers need saved function call closure record built heap 
heap allocated closures contiguous memory extra memory write memory read frame pointer necessary function call 
chapter 
space efficient closure representations fun fun fun fun val function cps table raw free variables closure strategies function function stage number raw free variables closure strategy slot slots slots slots new closure analysis technique callee save registers activation records efficient stack allocation see chapter 
idea allocate parts current activation record callee save registers 
careful lifetime analysis register save restore function calls eliminated amalgamated function calls sequence need allocate heap record 
list cps clo code function table lists stage numbers raw free variables closure strategies function continuations closure conversion shown continuations represented code pointer plus callee save registers denoted capital letters 
escaping function calls calls line implemented selecting th field placing closure special register formal parameter doing jump arguments lines 
chapter 
space efficient closure representations fun fun fun fun val select val val select val select val select val select val select val select val cr val select cr making sequence function calls call line put variables smaller lut numbers callee save registers spill rest heap record cr line 
second third calls line register save restore necessary 
lifetime overlap just share callee save register 
lambda lifting known functions lambda lifting joh known transformation rewrites program equivalent function free variables 
lambda lifting known functions essentially corresponds special closure allocation strategy allocates free variables registers possible 
special strategy generate efficient code kra 
example program assume known function free variables 
fun fun chapter 
space efficient closure representations closure allocated registers call inside free variables saved heap assuming callee save registers 
call returns variables reloaded back registers passed function entering saved calls 
clearly allocating environment registers dramatically increases need callee save registers inside leads memory traffic limited number callee save registers 
closure strategy analysis described section uses iterative algorithm decide number registers assigned known function 
number registers assigned restricted callers return continuation return continuation call result assigned slot closure allocated heap 
general recursion closure strategy analysis algorithm described section conservatively represents continuation functions fixed number callee save registers 
cases restriction relaxed continuations passed known functions represented number callee save registers 
special calling convention especially desirable general recursion case cps translation map function fun map fun val car val cdr fun fun val notice recursive function called places function map return continuation inside return continuation 
second call recursive call executed 
chapter 
space efficient closure representations represent normal continuation functions callee save registers represent continuations callee save registers 
lists code function map translation clo special calling convention 
fun map fun val select val select val select fun val car val cdr fun fun val val select val select val select val cr val select cr val cc cc function map special calling conventions known function environment free variable allocated register treated extra argument see line 
continuation uses normal calling convention passed function line new coercion continuation line built adjust normal convention callee save registers special convention callee save registers 
return continuation represented chapter 
space efficient closure representations callee save registers build smaller heap closure size line continuation represented callee save registers heap closure size 
measurements implemented space efficient closure conversion algorithm standard ml new jersey compiler version 
order find performance gain get new closure conversion algorithm measured performance different compilers sml benchmarks see table section 
compilers simple variations sml nj compiler version 
compilers satisfy safe space complexity rule type directed compilation techniques described chapter allow arguments passed registers support efficient data representations 
lazy display technique implemented compilers effectively compilers new closure conversion algorithm extensive shared closures 
sml occ version uses old closure conversion algorithm app 
specifically uses linked closure representation space safe uses flat closure representation 
continuation closures represented registers 
sml gp sml gp sml gp sml gp compilers new closure conversion algorithm described chapter 
respectively generalpurpose callee save registers represent continuation closures 
sml gp compiler exactly sml ffb compiler chapter 
sml fp compiler uses new closure conversion algorithm described chapter 
continuation closures represented general purpose callee save registers floating point callee save registers 
measurements done dec workstation mega bytes memory methodology described section 
table illustrate list execution time running benchmarks compilers 
execution time user time plus garbage collection time plus system time seconds sml occ compiler shown performance compilers chapter 
space efficient closure representations ffi ffl boyer sieve kb comp pi lexgen sml occ sml gp sml gp sml gp sml gp sml fp ffi ffi ffl ffl pi pi ffi ffi ffi ffi 
ffl ffl ffl ffl 
pi pi pi pi 
names compilers ffi yacc ffl life simple ray pi vliw sml occ sml gp sml gp sml gp sml gp sml fp ffi ffi ffl ffl pi pi ffi ffi ffi ffi 
ffl ffl ffl ffl 
pi pi pi pi 
comparison execution time illustration denoted relative ratio sml occ compiler 
garbage collection time corresponding data table listed separately table 
similarly respectively compare heap allocation mega bytes compilation time seconds code size bytes 
chapter 
space efficient closure representations table comparison execution time program basis sml occ sml gp sml gp sml gp sml gp sml fp seconds ratio ratio ratio ratio ratio ratio boyer sieve kb comp lexgen yacc life simple ray vliw average table comparison garbage collection time program basis sml occ sml gp sml gp sml gp sml gp sml fp seconds ratio ratio ratio ratio ratio ratio boyer sieve kb comp lexgen yacc life simple ray vliw table listed number memory fetches millions local global variables allocation profile various kinds closures sml occ sml gp compilers 
escape known cont respectively total size closures mega words allocated escaping user functions known user functions continuation functions heap allocation non closures listed table included table 
draw comparisons ffl sml gp compiler exactly setup sml occ compiler uses new closure conversion algorithm uses old algorithm 
average sml gp compiler reduces heap allocation closure allocation chapter 
space efficient closure representations table comparison total heap allocation program basis sml occ sml gp sml gp sml gp sml gp sml fp mbytes ratio ratio ratio ratio ratio ratio boyer sieve kb comp lexgen yacc life simple ray vliw average table comparison compilation time program basis sml occ sml gp sml gp sml gp sml gp sml fp seconds ratio ratio ratio ratio ratio ratio boyer sieve kb comp lexgen yacc life simple ray vliw average memory fetches local global variables improves efficient code generated sml occ compiler 
sml gp compiler uniformly generates compact code achieving average reduction code size sml occ compiler 
vliw achieve respectively speedup execution time get significant benefits safely linked closures 
ffl varying number callee save registers new closure conversion algorithm little effect execution time range average chapter 
space efficient closure representations table comparison code size program basis sml occ sml gp sml gp sml gp sml gp sml fp kbytes ratio ratio ratio ratio ratio ratio boyer sieve kb comp lexgen yacc life simple ray vliw average table breakdown closure access allocation closure access closure allocation mem reads millions escape known cont mega words program sml occ sml gp saving sml occ sml gp saving boyer sieve kb comp lexgen yacc life simple ray vliw average large effect total heap allocation 
sml gp compiler faster sml gp compiler total heap allocation 
ffl effect new closure algorithm garbage collection time time see table varies dramatically depending benchmarks 
benchmarks measured spend time garbage collection heap allocation time ray doubled 
surprising new closure algorithm complete different allocation behavior old algorithm 
having callee save registers especially sml fp compiler chapter 
space efficient closure representations generally increases time sort reflects heap allocation data table 
ffl allocation profiling data table see reduction heap allocation continuation closures closure analysis effect non closures 
ffl new closure conversion algorithm surprisingly improves compilation time nearly 
probably old algorithm sml occ compiler contains expensive ad hoc heuristics new algorithm systematic 
reason new algorithm generates code requires instruction scheduling time 
ffl floating point callee save registers sml fp compiler achieve better performance floating point callee save registers 
slowdown comes benchmarks sieve kb comp frequently class continuations exception handlers 
class continuations exceptions may put record stored cell representable just word separate callee save registers continuation captured register representation packaged single word making record heap continuation triggered throw single word representation callee save registers 
overhead higher callee save registers 
related guy steele rabbit compiler ste compiler uses continuationpassing style intermediate language represents stack frames continuation closures 
compiler closure analysis choose specialized representations different kinds closures kranz orbit compiler kkr kra uses different closure allocation strategies different kinds functions appel jim investigated closure sharing strategies aj proposed alternative closure representations 
unfortunately closure analysis techniques violate safe space complexity rule due unsafe closure sharing 
closure conversion algorithm described chapter combines analyses stack allocation satisfying safe space complexity rule 
chapter 
space efficient closure representations hanson han showed complexity implementing tail calls correctly efficiently conventional stack 
heap scheme correctness straightforward dead frames automatically reclaimed garbage collector efficiency achieved loop header technique app hoist loop invariant free variables tail recursion callee save registers simulate top reusable stack frames 
compilers ste kkr car perform closure conversion closure analyses part translation lambda calculus continuation passing style machine code 
useful separate closure machine code generation compiler modular done compilers ordinary calculus lambda lifting ccm joh continuation passing style closure passing style aj kh 
tried call cc efficient hard achieve traditional stack schemes 
ordinary contiguous stack implementation entire stack copied creation invocation class continuation 
clinger cho hieb hdb mixed stack heap strategies intended support call cc efficiently presence stacks :10.1.1.40.6828:10.1.1.40.6828
basic idea stack chunk holds stack frames fills linked chunk allocated heap 
turns complicated implement 
danvy dan proposed free list re usable frames quasi stack support fast call cc method may incur extra overhead function call return 
chow cho steele ss observed dataflow analysis help decide put variables caller save callee save registers 
show represent callee save registers continuation passing style app compile time variable lifetime information better job 
local variables different functions nonoverlapping live ranges allocated register global save restore gs cho 
achieve allocating part closures known functions continuations callee save registers graph coloring global register allocation targeting algorithms cha 
summary new closure conversion algorithm great success 
closure conversion algorithm faster previous algorithm see table 
programs smaller chapter 
space efficient closure representations average faster average 
decreases rate heap allocation obeying safe space complexity rule keeping closures small helps reduce amount live data preserved garbage collection 
closure analysis technique introduced chapter applied compilers cps intermediate language 
safely linked closures callee save registers essential building compilers satisfy safe space complexity rule 
chapter heap vs stack proposed allocating procedure activation records garbage collected heap efficient stack allocation 
previous comparisons heap vs stack allocation simplistic neglecting example frame pointers better locality stacks 
chapter comprehensive analysis components creation access disposal heap allocated stack allocated activation records 
results ffl stack frames known better cache read rate heap frames simple analytical model backed simulation results shows difference trivial matter 
ffl cache write rate heap frames high show variety handling strategies exemplified specific modern machines give performance 
ffl write policy primary cache important policy secondary cache 
ffl stacks restrict flexibility closure representations higher order functions important costly ways 
ffl extra load placed garbage collector heap allocated frames small 
ffl demands modern programming languages stacks quite complicated implement efficiently correctly 
chapter 
heap vs stack table cost breakdown different frame allocation strategies stack heap stack chunks stack see see see creation frame pointers copying sharing cache write misses cache read misses disposal pop total cost call cc implementation easy hard hard hard execution cost stack allocated heap allocated frames similar heap frames simpler implement allow efficient class continuations call cc 
garbage collected frames programming language implementation uses garbage collection procedure activation records frames allocated heap 
convenient higherorder languages scheme ml closures indefinite extent convenient languages class continuations 
think expensive allocate procedure call heap storage garbage return 
necessarily app modern generational garbage collection algorithms ung reclaim dead frames efficiently cheap instruction cost pop stack 
costs involved creating accessing destroying activation records heap stack 
table cost component frame creation access disposal heap allocated stack allocated frames shown measured instructions frame tail recursions leaf procedures frames 
numbers cache write misses depend critically design machine primary cache show cost alternatives 
column section number chapter explanation component 
row stack depth size stack chunk 
costs explained analyzed remainder chapter 
chapter 
heap vs stack numbers table depend assumptions 
critical assumptions ffl language question static scope higher order functions garbage collection 
question investigated activation record stack addition garbage collection objects 
ffl compiler garbage collector required safe space complexity statically dead pointers dataflow sense keep objects live 
see section ffl side effects compiled programs generational garbage collection efficient 
assumptions explained rest chapter 
table clearly shows important criteria choice stack heap representation 
write policy machine primary cache discussed section 
machines fetch write write write policies heap allocated frames significantly expensive 

stacks harder heaps implement space leaks explained section 

programming language supports class continuation call cc lan primitive support multi threading exceptions stacks higher cost see section 
startling result heap allocated frames cost stack frames 
point absolute differences small instructions frame total execution cost calculated 
count instructions cycles 
general load store instructions frame management usually scheduled avoid stalls rarely critical path loop example 
branch instructions heap limit testing predictable hundreds frames allocated heap limit exceeded garbage collections heap limit exceeded branches heap limit tests cause stalls 
instruction counts plus separate accounting cache misses form suitable cost model 
chapter 
heap vs stack table shared limit checks frame allocations extended basic block non frame allocations 
cases heap limit check done anyway charged frame allocation 
table shows proportion frame allocations block non frame allocation 
results shown measurements ml benchmark programs see table section details compiled standard ml new jersey am compiler :10.1.1.55.9444
program limit checks frame boyer knuth lexgen life yacc simple vliw average creation allocate stack frame program add constant stack pointer 
takes instruction 
necessary check stack overflow overflow rare usually done cost inaccessible virtual memory page 
allocating heap frame complicated 
heap overflow checked 
explained appel li contrary ideas appel app done virtual memory fault operating system fault handling expensive heap overflow unrelated locality technique impossible machines precise interrupts 
comparison conditional branch required keeping free space pointer limit pointer registers takes instructions 
frame allocations occur extended basic block allocations require limit checks see table 
actual cost delta 
extended basic block entry point followed tree control flow exits 
chapter 
heap vs stack 
free space pointer incremented 
costs instruction 
frame allocation basic block allocation increment shared 
cost instructions frame average 

descriptor word written frame garbage collector understand 
frame usually contains return address garbage collector mapping return addresses descriptors frame need explicitly contain descriptor 

free space pointer copied frame pointer takes move instruction 
total cost instructions average 
frame pointers stack frame popped frame pointer set back caller frame 
implementations stack frames put copy previous frame pointer frame fetched back function return 
contiguous stack frames known size clearly unnecessary stack pointer frame pointer pop just subtraction stack pointer 
common modern practice 
frames contiguous heap allocated frame contain pointer caller frame 
instruction necessary store previous frame pointer new frame instruction necessary fetch back 
heap allocated frames instruction cost frame frame pointer manipulation stack allocated frames incur cost 
registers efficient heap allocation uses free space pointer free space limit kept registers 
cost reserving registers charged heap allocation frames assuming implementation question sml nj write explicit descriptor frame simplicity 
implementations big bag pages han scheme allocates kind object different contiguous space descriptor required space object 
requires free space pointer limit pointer space 
chapter 
heap vs stack garbage collection presumably efficient allocation purposes lists closures example 
copying sharing language scheme ml smalltalk higher order functions needs closures hold free variables functions created called 
function free variables overlap closure point saves expense copying contents 
kinds objects activation records lifetimes behavior higher order function closures indefinite extent 
stack allocated heap allocated allocated heap 
furthermore stack frames may point heap closures heap closures may point stack frames dangling pointers 
means compiler wants build closure containing free variables available stack frame variables copied closure closure just point stack frame 
activation records heap allocated closures may point 
flexibility allows closure analysis phase compiler choose better smaller shallower representations closures sharing copying see chapter 
restriction heaps point stacks counted cost stack allocated frames 
quantify cost measured versions standard ml new jersey compiler am app new closure conversion algorithm described chapter 
version shown ordinary heap table allocates frames closures heap 
heap obeys restriction closures point frames frames point closures 
frames objects lifo lifetimes 
heap proceeds allocate frames closures heap stack gain advantages stack 
difference execution time versions attributable slightly cumbersome representations imposed closures point frames restriction 
frames bigger closures point frames data frames copied closures 
chapter 
heap vs stack table copying sharing cost heap allocates frames heap careful divide kinds stack frames point stack frames heap frames point kind 
lack flexibility significant cost shown table 
columns show thousands instructions executed third column shows thousands frames created 
count frames calls tail calls leaf procedures frames stack heap 
stack extra nary stack instrs instrs program heap heap frames frame frame boyer knuth lexgen life yacc simple vliw average table heap allocation data table shows amount frame allocation amount non frame allocation proportion allocation due heap frames heap compiler 
column shows average frame size calculated previous columns 
number frames heap compiler slightly number stack compiler improved copying sharing stack frame count calculation comparison compilers meaningful 
heap avg 
stack frame frame program frames alloc 
alloc 
size words words words boyer knuth lexgen life yacc simple vliw average chapter 
heap vs stack programs suffer average difference quite significant extra instructions executed frame creation restriction 
lambda lifting closure analysis algorithm better tuned heaps stacks copying vs sharing cost difficult tell 
space safety assumption results table assumption compiler safe space complexity see section put restrictions heap allocated stack allocated frames 
possible allow dead variables frames closures garbage collector knows dead 
accomplished special descriptors reduce copying sharing penalty stack frames 
example chalmers lazy ml compiler aug gallium compiler ler associated return address descriptor telling variables caller frame live return 
sufficient heap closures point stack frames 
fully flexible system able stack frame point heap closure contains variables may die frame 
return address descriptor need indicate variables frame dead live variables point records fields dead 
complicated implement know done 
locality stacks excellent locality moving small region memory access stack hit cache matter small cache heap allocated frames scattered memory creating accessing cause cache misses 
machines days primary caches small bytes secondary caches penalties long cycles serious concern 
bibliographic citations merely pro forma author described technique print 
chapter 
heap vs stack analysis cache behavior garbage collected systems differs qualitatively depending size cache 
large caches large secondary caches generational garbage collection algorithm ung keep youngest generation entirely cache wlm zor 
rare objects survive collection promoted older generation cause cache misses 
collector helps improve locality mutator 
locality large cache basically solved problem 
furthermore activation records die especially young 
extremely rare activation record promoted higher generation sm 
higher generations cause cache misses heap allocated frames cause cache misses 
may secondary cache misses garbage collected system non frame objects closures records difference heap allocated frames insignificant 
john reppy empirical measurements collector machine large mb secondary cache 
total cpu time reaches minimum significantly collector chapter allocation arena size secondary cache 
provides empirical evidence claim sizing allocation space fit cache improve performance 
rep unfortunately measurements chapter older generation collector app 
small caches small primary caches size kbytes impractical keep youngest generation cache doing cause garbage collections frequent expensive 
consider locality small primary cache 
assume cache kbytes cycle penalty programs achieve better hit rate small cache machine designers forced small penalty balanced performance 
essence locality argument heap allocation stacks exploit small primary cache heap allocated frames 
stacks locality small cache 
typical sequence procedure calls stack pointer expected go log frames re slight oversimplification 
chapter 
heap vs stack 
frames easily fit smallest cache 
heap allocated frames locality large cache analyzed locality small cache 
demonstrate heap allocated frames adequate locality small cache read penalty large write penalty zero 
write misses standard ml new jersey compiler am uses stack frames allocated garbage collected heap :10.1.1.55.9444
system poor cache locality 
diwan tarditi moss dtm simulated memory hierarchy performance sml nj decstation things ffl sml nj program executions high write ratio 
ffl sml nj programs delayed cache misses 
reason statements inconsistent discovered penalty machine approximately zero write buffer easily keep enormous write rate 
read misses stall processor continue computing data shows write misses handled write buffer cpu continues 
modern machines zero write penalty especially primary caches jou 
simulating machines high write penalty diwan sml nj performs badly expected 
machines zero write penalty average cost frame write misses zero 
machines nonzero write penalty cost frame high 
average number cache write misses caused creation frame ratio frame size cache line size fragmentation heap allocation sequential contiguous 
assuming cache line size words example frame size words table number write misses frame 
cost write misses shown table zero write penalty cycle write penalty 
see section 
write allocate important write written data put cache 
cache line usually larger single word write traditional fetch write caches read rest line memory reinhold rei similar observations interaction garbage collection caches compiler heap allocated frames 
chapter 
heap vs stack cause write misses slow causes unnecessary traffic memory bus common case sequential writes overwrite just read data 
simulations diwan analysis section show policy costly 
heap allocation system copying garbage collection consists sequential writes large contiguous free region 
discipline equally cache implementation strategies permit simulate write allocate zero write penalty 
sub block placement sub block placement called write validate write word written cache rest cache line marked allocated invalid 
write require reading rest written cache line memory 
subsequent sequential writes fill rest line 
word cache line decstation cache line size word lines read dtm 
applications better subblock placement sequential writes equally 
expensive implement requires full tag just valid bit word 
diwan excellent memory subsystem performance sml nj machine 
cache line zero instruction machines ibm hhh powerpc ab power hp pa cache line bytes allocated zeroed special instruction 
avoids write instruction cost frame 
cache control hint hp pa store instruction cache control hint specifying block overwritten read avoids read write misses aad 
machines large primary caches anyway locality handled generational collection 
smart write buffer sub block placement complicates cache add feature write buffer write misses normally bypass cache write buffer accumulates full cache line line put cache 
detail allocation pointer point exactly bytes ahead word 
heap limit check cache line clear performed 
clear line currently stored overwrite frame allocated line soon entered 
heap limit check shared non frame allocation see table average net cost frame instructions 
idea discovered andrew appel 
chapter 
heap vs stack sequential writes sub block placement 
multiprocessor cache coherence technique easier implement sub block placement cache line dirty partially full different caches 
garbage prefetch machine write allocate write cache simulated long read misses nonblocking fetching cache line ordinary read instruction advance write app 
technique works providing modest performance enhancement dec alpha dig example 
machines heap allocated data incur write penalty 
assumption small cache write allocate write latency write allocate emulated 
true machines vax vax pentium write bypassing primary cache write misses causing subsequent read misses pre designs fetch write stalling processor write jou 
fact bad performance garbage collected systems machines write penalty reason build machines 
note write penalty large caches particularly problematic explained generational garbage collection solves problem 
analysis rest section applies small caches 
read misses simulations see effect small caches heap allocated frames simulated standard sml benchmarks selected table versions sml nj compiler heap version heap allocated frames stack version stack allocated frames 
simulations run direct mapped cache various sizes infinite cache 
simulations counted read misses write misses total instruction count sml programs compiled mips instruction set 
total instruction count includes instructions cache misses garbage collection 
diwan dtm measured heap ml system reinhold rei measured stack frame scheme system 
order direct comparison measured stack frames vs heap frames ml system 
simulated primary data cache 
simulated direct mapped caches sizes ranging kbytes mbytes byte line size 
modern machines chapter 
heap vs stack write allocate cache size bytes boyer ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
write cache size bytes boyer ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
kb comp ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
kb comp ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
lexgen ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
lexgen ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
life ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
life ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
yacc ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
yacc ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
simple ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
simple ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
write allocate cache size bytes vliw ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
write cache size bytes vliw ffl stack ffi heap ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi 
ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl 
simulations running direct mapped cache various sizes infinite cache 
vertical axis shows execution cycles millions 
cycle count stack programs reduced theta number frames discount instruction quasi stack allocation deallocation sequence 
simulations write allocate vs write cache chapter 
heap vs stack direct mapped caches especially level memory hierarchy tag comparison overlapped computations value fetched hil 
detailed cycle level simulation approximation cache stalls instruction execution pipeline cycles penalty 
modern machines stall non memory instructions cache machines simulation provide upper bound cache delays sufficient analysis 
simulate conventional contiguous stack 
implemented free list word re usable frames quasi stack 
frames popped putting back free list 
takes instructions conventional pushing popping cause cache misses programs go tiny set noncontiguous frames small cache able hold frames frequently data 
measurements sml nj show frames smaller words see table load frames lots useless overhead 
larger frames needed stack simulation simply links word byte frames 
aggregate objects arrays records kept frames 
free list handling costs instructions stack pointer incrementing subtract cost presenting results simulation 
garbage collector marks frame survives collection marked frames put back freelist procedure return 
enables stacks generational garbage collection class continuations 
youngest generation collection freelist set nil collection new frames obtained heap freed put back freelist 
free list frames considerable cost allocate deallocate frame 
test freelist register 

set freelist register free frame 
deallocate fetch mark field 
wait fetch finish 
freelist empty heap allocate freelist heap allocated frame deallocated back freelist 
case rare won count average cost 
chapter 
heap vs stack marked put back free list 
store free list register newly freed frame 
set free list register point frame 
overhead instructions stack allocation 
ordinary contiguous stacks instruction penalty just single pop instruction 
adjust execution time stack version program subtracting cycles frame 
shows run times adjustment benchmarks heap stack frames running simulated caches different sizes 
simulated write allocate cache partial fill left hand side write cache right hand side 
jouppi jou simulated kinds cache programs garbage collection diwan dtm simulated caches purely heap allocating ml programs 
simulating caches stack heap allocation programs compare straightforwardly 
results surprising write allocate better programs heap allocation sensitive cache policy stack allocation 
differences heap stack implementations affect run time clear shapes curves cache locality behavior heap stack write allocate cache identical 
curves translated vertically large cache points coincide rest curves extremely close 
simulation measurements show cache read cost cache cycles frame 
calculate averaging heap gamma heap gamma stack gamma stack benchmarks number read misses data cache size frame strategy penalty number frames created taken table 
nonzero write penalty usually processors fetch write 
processors allocate line cache average read cost low described previous paragraph 
cycle penalty write cost frame explained section cycles 
cost chapter 
heap vs stack read misses write allocate cache included total cost read write misses cycles frame 
write caches need stall processor write behaved sequential writes performed heap allocator 
write cost zero newly written cache line soon fetched sm rei expect read cost frame write caches similar cost frame fetch write caches 
write cache cost read misses calculated simulations cycles frame somewhat smaller cycle read write cost fetch write caches 
shown write caches table total cost similar slightly smaller heap frames fetch write caches 
clearly small size frames sml nj important achieving performance especially fetch write write caches 
execution line cache 
procedure call write bold procedure returns read misses 
execution line cache 
bold procedure returns read misses 
read misses analytically stacks continually re frames new purposes heap allocated frames thrash cache sequential order 
possibly case write validate cache equally locality 
simulations give analytical understanding really happening focus typical patterns procedure call return chapter 
heap vs stack 
tail recursion call re uses frame allocation performed 

deep single recursion recursive factorial function deep sequence calls followed returns 

towers hanoi lots short motion nth call briefly returns depth log 
shown graphically figures 
claim patterns represent extremes middle procedure call patterns 
furthermore towers hanoi worst case heaps compared stacks stack implementation excellent locality analysis instructive 
assume cache direct mapped hold frames line size equal size frame different line sizes affect results constant factor 
assume heap allocated frames allocated sequential addresses 
assume heap allocations memory accesses performed activation records 
tail recursion easy analyze new frames allocated stack heap methods 
rate zero 
deep single recursion bad stacks heaps recursion depth read misses calls returns hit rest returns read misses 
ratio approaches larger towers hanoi ideal demonstrate better locality stacks small cache 
analyze cache behavior carefully 
fun 
executing requires gamma procedure calls 
stack frames fit cache read rate zero ignore write misses 
return call number returns gammac gamma 
rate number misses divided number calls approximately gammac kbyte cache rate stacks negligible 
consider executing heap allocated frames 
frames allocated sequentially 
clock counts tick procedure call time frame results simple programs set associative caches lru replacement set 
chapter 
heap vs stack created time gamma removed cache newly allocated frame 
exactly procedures return time units entered cause cache return callers 
executing requires gamma calls gammalog take time units execute 
amortized number misses call gamma log calls 
illustrates running tiny cache 
cache misses clustered intervals returns average misses cluster 
shows traditional towers hanoi calls print move disk step 
cache hold byte frames stack version calls heap version calls 
assuming primary cache secondary cache hit costs cycles cost cycle calls 
analytical prediction cycles call completely agree simulation 
believe simulation directly measure cache cost stack heap programs execute instructions number instructions 
measure total cost different implementations different frame creation sequences frame disposal sequences different garbage collection times garbage collectors cache different frame layout attempt subtract components related cache behavior 
small errors estimation components additive 
hand simulation capture effect real programs analyzed closed form paradigmatic examples 
programs interference effects old objects objects 
reinhold rei finds interference affect cache behavior allocated objects case frames 
say confidence simulation analytical prediction accurately characterizes cache behavior 
conservative worse number cache read misses table 
consider happens write allocate write cache 
vast majority reads towers hanoi example blocks caused write misses 
write misses stall processor read misses 
costs cycles frame assuming average frame size roughly half cache line size cycle penalty 
chapter 
heap vs stack cache designs cache write policies expect 
assume hardware designs commodity microprocessors driven spec benchmark suite arguments best functional programs garbage collection 
jouppi measurements fortran programs jou may influential 
concludes write validate write allocate fetch write policy best performance 
exactly policy dtm rei sm find best garbage collected strict functional programs 
hand jouppi points write validate difficult impossible implement shared memory multiprocessor cache coherence 
machines require writable cache line single owner 
manufacturers wish multiprocessor compatible cpu chips won wish different primary cache designs mean write validate common multiprocessors uniprocessors 
disposal de allocate stack frame instruction required subtract constant stack pointer 
explicit pop instruction necessary deallocate heap frame 
previous frame pointer fetched counted heading frame pointers 
garbage collection cost heap allocated frames 
components 
live heap frames copied older generation scanned live stack frames need scanned 

allocating frames causes frequent garbage collection leading premature promotion non frame objects died just little time 

frequent collections means frequent executions garbage collector entry exit sequence 
analyze costs separately 
chapter 
heap vs stack copying frames analyze cost instructions garbage collection typical patterns discussed previous section 
assume generational collector youngest generation holds frames generation size kbytes frame size bytes 
youngest generation collection live frames promoted generation 

tail recursion allocate amortized cost call zero 

towers hanoi garbage collect calls 
collection log live frames log new promoted 
cost collecting log cost copying frame instructions 
amortized cost call log instruction call 

deep recursion deeper calls promote frame cost cg instructions calls instructions call 
costly recursions deep secondary cache 
particularly size youngest generation size secondary cache zor rep 
secondary cache misses occur stacks heaps probably just important garbage collection overhead 
summary instructions frame 
frequent collections stack allocated frames garbage collections average cost occur entry exit overhead collector cost copying non frame live data 
heap allocated frames collections average cost occur cost copying frames 
accounted delta previous subsection 
account gamma nl subsection 
calculate gamma 
gamma simply number frames created divided number frames youngest generation hold 
cost frame just assuming instructions instructions frame 
include cost scanning frame pointers done stack heap case 
chapter 
heap vs stack table garbage collection cost mutator time garbage collection time fl shown seconds benchmark 
mips ae garbage collection overhead frame calculated shown accompanying text 
heap heap stack mips instrs frame fl fl fl ae boyer knuth lexgen life yacc simple vliw average premature promotion non frames principle heap allocation frames cause frequent collection undesirable promotion non frame data 
lifetime statistics reported moss sm find objects survive calls delta 
proportion proportion frames total heap allocation see table 
shape object survival curve objects rare object allocations 
consider program allocates ordinary non frame random lifetime object procedure call 
objects promoted excess heap frame version frame allocations cause frequent collection 
cost promotion instructions 
average cost frame instructions 
sum collection costs components sum instructions frame attributable garbage collection 
direct measurement garbage collection support analytical calculations garbage collection overhead measured garbage collection time stack vs heap frames benchmark programs 
table shows measurements done moss sm older version sml nj compiler new closure conversion algorithm described chapter 
chapter 
heap vs stack garbage collection costs execution benchmark programs dec computer 
benchmark versions program run heap heap allocated frames stack stack allocated frames implemented free list re usable frames different frame layout choice closures heap heap allocated frames exactly frame layout padding words stack frames 
mutator time garbage collection time fl shown benchmark 
times calculated executing benchmark command times consecutively unix execution dividing 
runs test fastest taken recommended example spec benchmark consortium sta 
time spent operating system shown small cases differ versions program 
calculated ae effective mips millions instructions seconds dec program dividing instructions executed heap version program taken table fl peak performance machine mips 
calculate extra garbage collection cost attributable heap allocated frames compared stack time heap time converted seconds instructions divided number frames taken table fl gamma fl ae cases negative 
indicates garbage collection overhead heap allocated frames important benefit gained copying sharing costs 
tried alternate method calculation 
heap stack exactly frame layout difference failure heap free frames 
garbage collection overhead consistently isolated 
heap frames artificially padded words 
overestimate load collector expect added load roughly proportional total size heap allocated frames 
estimate overhead multiply proportion frames just padding fl gamma fl ae chapter 
heap vs stack average frame size benchmark taken table 
yacc benchmark anomalous showing high cost extra garbage collection heap allocated frames 
closer examination yacc execution showed major generation collections heap frames stack frames 
excluding yacc average instructions frame close analytically predicted value 
yacc foreseen analytical methods 
table show measured value instructions disposal frames 
finding roots garbage collected system local variables activation records stack frames may point heap 
garbage collection collector scan frames locate roots live data 
system generational garbage collection little live data youngest generation 
scanning large stack take time rest collection 
collector scan stack frames created collection popped 
trivial treat heap allocated frames way 
promoted live data older generations older generation data need scanned collection 
newly allocated dead frames scanned typical collection 
stacks special trick required 
collection collector mark top stack frame 
frames underneath known old 
collection stack scanned top stack high water mark frames contain pointers youngest generation 
complication 
collections high water frame popped mark moved lower frame wil 
simplest way test mark return expensive 
mark consists special return address replaces real return address frame 
control returns point program special location executes chapter 
heap vs stack placing mark special return address lower frame jumping real return address 
cost technique quite low 
cost placing removing mark instructions 
frame survives garbage collection eventually hold high water mark 
cost moving high water mark stack system similar cost promoting live stack frame older generation heap system exactly frames new frames live collection need service case 
proportion new stack frames live collection usually extremely low cost negligible stacks heaps 
rare cases deep way recursions cost higher stack systems heap systems pay approximately price 
doligez gonthier dg suggested collector put bit mark live stack frame scans mark ignored collector cleared new frames 
fine word frame free bit 
keeping track high water mark heap system implementation complexity natural consequence garbage collecting live frames 
contrast stack system similar results achieved requires extra 
updating activation records order guarantee new heap frames roots garbage collection necessary prohibit writes frames allocated 
compilers continuation passing style rabbit ste orbit kkr sml nj aj naturally initialize frames soon allocated write 
effect save changes registers dump 
callee save registers app see chapter easier accumulate changes registers write immutable frames big chunks 
stack compiler update topmost frame time collector scan frame roots 
heap compiler wants support efficient call cc see section update frame initialization continuation invoked invocations complicates compiler runtime system particularly implementation exception handlers pop stack 
chapter 
heap vs stack data 
compiler best keep top frame callee save registers memory 
class continuations notion class continuations call current continuation call cc primitive originated scheme language rc adopted systems 
class continuations useful implementing coroutines wan concurrency libraries rep 
call cc harder implement efficiently stack 
ordinary contiguous stack implementation entire stack copied creation invocation class continuation 
unacceptably slow example call cc primitive implementing concurrency library exception handling system 
purely heap allocated frames updated initialization call cc expensive ordinary procedure call live registers written closure record 
mixed stack heap implementations intended support call cc efficiently presence stacks cho hdb 
basic idea stack chunk holds stack frames fills linked chunk allocated heap 
turns complicated implement 
stack chunks require stack overflow test frame creation costs instructions add sp compare branch 
danvy dan free list re usable frames call quasi stack reduce load garbage collector locality expensive create destroy require frame pointer 
stack implementation implemented measured simplification danvy method 
applications class continuations call cc simplification need extra mechanism copy part continuation danvy method 
methods suffer copying sharing penalty ordinary stacks 
performance summarized table appear competitive especially implementation complexity 
simplicity efficiency call cc pure heap discipline strong motivation avoiding stacks 
unfortunately experience memory exceptions tenable means detecting stack overflow 
hdb chapter :10.1.1.40.6828
heap vs stack implementation reason avoid stacks complicated implement especially tricks necessary achieve performance 
compare implementation complexities heaps vs stacks garbage collected environment implementation heap frames 
achieve performance heap frames necessary sophisticated algorithm choose closure representations 
algorithm preserve space complexity promote closure sharing callee save registers minimize number distinct frames written 
chapter described implementation algorithm particularly hairy 

avoid having descriptor frame runtime system maintain mapping return addresses frame layout descriptors 
kranz orbit compiler technique kra 
standard ml new jersey bother pay price descriptor frame 
implementation stacks 
closure analysis algorithm preserve space complexity trying avoid copying 
clear algorithm simpler pure heaps 
particular conventional stack implementations safe space complexity 

preserve space complexity correctly implement tail recursion certain activation records require complicated scheme determine popped han 
frames heap allocated stack discipline identified static analysis 

high water mark maintained achieve efficiency generational collector 

call cc supported stack copying complicated technique implemented hdb :10.1.1.40.6828

avoid having descriptor frame runtime system maintain mapping return addresses frame layout descriptors 
chapter 
heap vs stack 
system multiple threads thread stack 
large contiguous region virtual memory reserved 

stack overflow detection implemented 
cases handled automatically operating system virtual memory page faults 
stack implementation know handles necessary complexities 
result safe space complexity implement call cc scan frames collection 
open question tricks fit real system 
summary heap allocation activation records simple competitively efficient 
fact heap allocation cheap stack allocation effects including cache locality counted certainly conventional wisdom 
heap frames easier implement correctly tricky stacks safe space complexity support generation garbage collection efficiently class continuations call cc 
standard ml new jersey compiler supports features heap allocation activation records proved great success 
call current continuation needed heap frames better stack frames 
various hybrid systems stack chunks quasi stacks designed support call cc efficiently stack efficient heaps normal call return call cc 
machines write penalty writes entirely bypass cache results different heap frame handling twice expensive stack frame handling penalty performance class continuations 
languages nested class functions static scope copying sharing cost 
case stacks performance advantage 
closures call cc issue course 
contrast heap allocation region necessary processor thread 
heap overflow detection implemented true stack 
chapter unrolling lists lists ubiquitous functional programs supporting lists efficiently major concern compiler writers functional languages 
lists normally represented linked cons cells cons cell containing car data cdr link inefficient space storage links 
loops recursions lists slow modern machines long chains control dependences checking nil data dependences fetching cdr fields 
chapter data structure unrolled lists cell data items car fields link cdr 
reduces memory links significantly shortens length control dependence data dependence chains operations lists 
efficient compile time analysis transforms programs written ordinary lists programs unrolled lists 
new representation requires change existing programs 
sketch proof soundness analysis refinement types preliminary measurements technique 
efficient implementation lists major concern compiler writers functional languages occur frequently functional programs 
lists normally represented linked cons cells cons cell represented contiguous memory locations car data cdr link 
inefficient space half storage links 
furthermore traversing list requires twice memory traversing vector 
chapter 
unrolling lists loop recursion traverses list long chain control dependences link checked nil long chain data dependences link fetch dependent previous 
modern superscalar hardware dependences serious bottleneck 
order save storage links cdr coding proposed han gre cla cg bc bob 
main idea try avoid links arranging second cons cell directly follow car encode information bits contained car field cell cell need cdr field 
depth breadth bak copying garbage collector helps ensure lists arranged sequentially storage take advantage encoding 
cdr coding solves space usage problem mit version allows random access subscripting lists gre control dependence problem worse cdr coding tag car checked 
cdr coding popular lisp machines circa wm deu attractive solution modern machines 
new compile time cdr coding method works statically typed languages ml 
scheme allows compact runtime representation lists require runtime encoding 
furthermore encoding allows loops recursions lists unrolled efficiently possible conventional representation lists 
table standard vs unrolled list representations length old standard size new unrolled size representation representation idea simple put items link list cell 
illustrate idea 
list length simply represented linked series bigger cons cells list odd length represented header cell contains data element word record representing nur empty list shared uses empty list 
sharing introduced garbage collector avoid complicating compiled code necessary 
chapter 
unrolling lists link length list 
table gives simple comparison space usage new unrolled representation nur old standard representation osr 
table represents data element represent tag word distinguish odd length length lists runtime 
represent empty list easily see lists length greater new representation requires space usual representation 
furthermore traversing list new representation requires fewer loads fewer tests nil cdr pointers nur fewer cdr links 
new unrolled representation nur promises extremely useful superscalar machines 
suppose representation items link 
unroll loops lists factor overlap standard software pipelining techniques executions original iterations 
unrolling software pipelining fruitful performed standard list representation osr reasons tests nil introduce chain gamma extra control dependencies fetches cdr introduce chain gamma extra memory latencies 
chains serious obstacle software pipelining 
note fetches car fields unrolled loop nur done parallel possible standard representation 
programmers standard list notation list cell head tail compiler appropriate translation utilize new unrolled representations 
possible statically typed language ml type identifier statically known compile time computation lists expressed pattern matching recursive functions 
example integer list ml represented concrete datatype matches standard representation osr table datatype list nil int list infix cons constructor 
known function map written follows pattern matching fun map fun nil nil standard ml mth lists declared datatype list nil list 
simplify presentation omit type variable considering integer lists 
results described chapter easily carry polymorphic case 
chapter 
unrolling lists new unrolled representation nur table expressed ml concrete datatypes datatype list olist int tail elist tail tail tail int int tail data constructors olist elist thought tags lists length odd length correspond table 
efficient map function nur lists looks fun map fun olist olist elist elist tail tail test nil pattern matching done half 
map line expanded evaluations pipelined 
simply unrolling original map function changing list representation attractive extra control data dependence fun fun nil nil case nil 
nil 
static list unrolling transformation advantages traditional representation runtime cdr coding techniques ffl loops recursions lists automatically unrolled 
ffl avoid nil tests cdr fetches 
ffl memory storing links 
ffl extra runtime cost incurred cdr coding handling encoding bits parity testing list header 
chapter 
unrolling lists ffl cdr coding technique varies dynamic behavior program cons cells adjacent method guarantees gamma savings space usage long list structures fold unrolling 
ffl interface garbage collectors extremely simple ordinary record structures 
ffl transformation relies static type information usually available module interfaces interacts module system separate compilation 
compiling refinement types section formally describe compile time analysis translation algorithm automatically transforms program written osr notations uses nur 
describe simple syntactic transformation gets goal 
simple way implement nur compiler interpret normal constructor abstractly just aitken reppy deal value constructors ar 
compilation constructor function takes data element list returns list cons implemented function fun olist elist tail elist olist function called projection takes non empty list returns head tail list implemented function fun olist elist elist tail olist approach extremely easy implement compilers 
cause kinds runtime inefficiencies traversing building list map function ffl need check length parity list time applied old requires check 
ffl build list alternately allocate olist cell olist heap discard elist cell take build chapter 
unrolling lists elist cons cell elist tail discard olist 
expensive traditional cons operation just requires allocating element record 
ideally nur version avoid list length parity checks alternative allocations olist elist cells space time efficient osr version 
function map shown previous section behaves way checks argument length odd length body code knows length parity argument 
source source program transformation translates osr version map efficient version map 
basic idea rely static analysis distinguish lists length odd length compile time allow functions take lists arguments entry points dispatch function list length parity unknown specialized version list length odd length 
specialized versions knowledge length parity information extra runtime costs operations avoided 
statically typed languages ml keep track length parity information program variables compile time lists accessed data constructors pattern matching immune side effects borrow refinement type inference algorithm freeman pfenning fp fre introducing refinement list type type olist odd length lists type elist length lists 
example empty list length list consing element length list yields odd length list consing element odd length list yields length list 
map function returns list length parity argument list append ing lists length parity results length list append ing lists opposite length parity gives odd length list define source language src uses traditional osr notation target language tgt uses nur representations 
pass translation algorithm infers length parity information time compiling src expressions tgt expressions 
sketch correctness proof state main theorems 
functional languages lisp scheme operator ml list cells ml immutable 
chapter 
unrolling lists fn fix nil cons fn fn fix olist elist tail tail tail tail left source language src right target language tgt source language src target language tgt gives syntax expressions ranged declarations matches patterns source language src target language tgt 
denote constants program variables keywords underlined 
declarations inside fix expression may mutually recursive functions 
source language data constructors nil osr denoted nil cons expressions patterns 
target language data constructors nur denoted olist elist tail tail expressions tail tail patterns 
underlying datatype definition nur version lists tgt written ml follows datatype list olist olist elist elist olist tail int elist elist tail int int elist chapter 
unrolling lists essentially list tail type defined section 
constructor tail tail introduced avoid dealing tuple expressions toy language 
source language src thought typed intermediate language typical compilers 
variables constants annotated types assume src programs typed simple monomorphic types list denotes base types 
mean algorithm applied polymorphic languages polymorphic expressions easily translated typed intermediate language representation analysis technique proposed leroy ler peyton jones pl 
space limitations simplifications ease presentation ffl assume src programs typed standard static typing rules matches complete contain redundant patterns 
ffl record patterns expressions omitted pose problems technique 
ffl multi argument functions omitted translations similar translating curried versions 
target language tgt constructs operators term fn represent function takes list argument entry points lists parity unknown lists length odd length 
unknown parity header function checks parity dynamically immediately dispatches entry points 
special operators extract appropriate entry point term fn get denotes basic cons operation know length parity arguments described section denotes special operator integer length list integer odd length list 
understand implemented efficiently notice expression transformed tail avoids parity checking allocation intermediate odd length list cell 
practice tail transparent data constructor require extra storage represent car app 
chapter 
unrolling lists refinement types section give brief refinement type system translation algorithm see section 
notation concepts directly borrowed freeman pfenning fp fre system just simplified version theirs 
basically refine list type introducing elist length lists olist odd length lists 
functions take lists arguments refined type ae olist ae meaning result type ae applied length list ae applied odd length list 
refinement types ranged ae formally defined follows ae olist elist ae ae olist ae src type represents bottom refinement type 
say refinement type ae refines src type written ae deduced rules 
notice refine domain function type list type 
say refinement type ae subtype refinement type ae written ae ae deduced rules 
similarly refinement types ae ae equal denoted ae ae ae ae ae ae equivalence relation refinement types 
chapter talk refinement type ae refer equivalence class src type finite number refinement types 
refinement types form lattice subtype relation top bottom 
example lattice refinement types src type list list elist olist list gamma gamma gamma gamma gamma gamma refinement type ae possible find src type refines 
denoted top operation defined rules 
refinement types ae ae top ae top ae union type written ae ae refinement type inductively defined rules 
easy see refinement types ae ae ae ae ae ae ae ae ae proven structural induction ae 
chapter 
unrolling lists operation applying refinement type ae refinement type ae defined rules 
operation extensively meta operation translation see section 
freeman pfenning fre fp give refinement type inference algorithm typed core ml 
inference algorithm section language src just adaption algorithm refinement type system 
source target translation translation source language term target language src types refinement types inferred term subterms 
translation proceeds computing refinement types translated term simultaneously 
translation functions expressions declarations matches patterns source language src 
function takes src expression substitution src program variables tgt expressions refinement type environment gamma arguments returns tgt expression inferred refinement type ae translation application simple recursive call proper coercions inserted depending inferred refinement types done meta operation ae ae defined section 
translation abstraction fn divided cases 
argument list simple recursive call 
argument list corresponding matches translated specialized twice assuming argument length list par elist assuming argument list par olist 
resulting tgt matches correspond specialized entry points lists length odd length 
special entry point lists unknown length built combine meta operation combine ae ae tgt function checks length parity argument dispatch special versions see section 
takes src declaration substitution refinement type environment gamma returns tgt declaration resulting refinement type environment loop inside computes fixed point refinement types guaranteed terminate finitely refinement types src type proof freeman fre chapter 
redundant matches form fn 
chapter 
unrolling lists elist list olist list ae 
ae ae olist ae 
list ae ae 
ae ae ae ae ae ae ae ae ae ae ae ae ae ae ae list ae ae olist ae ae ae ae ae ae olist ae list ae ae ae ae ae ae olist ae ae olist ae ae ae ae ae 
top top 
top elist list top olist list top ae 
top ae top ae olist ae list 
top ae 
ae ae ae ae ae ae ae ae olist elist list elist olist list ae ae 
ae ae ae olist ae list ae ae ae olist ae aei list ae ae olist ae ae ae olist ae aei ae olist ae ae olist ae ae ae olist ae ae 
ae ae ae top ae ae ae ae ae ae list top ae ae ae list ae ae ae elist ae ae olist ae ae ae olist ae definitions top refinement types chapter 
unrolling lists gamma gamma gamma nil gamma elist cons gamma int gamma ae gamma ae elist cons ae respectively olist ae olist cons ae respectively elist cons ae ae cons ae fn list gamma ae gamma olist ae gamma elist new program variables fn combine ae ae fn fn fix ae olist ae fn gamma ae sigma fx 
xg gamma sigma fx 
fn ae gamma ae gamma ae gamma ae ae fix gamma gamma gamma fx 
dom gamma ae sigma gamma sigma gamma fix ae translation expressions argument par function represents length parity elist olist argument match simple src rule compatible par compatible par compatibility src pattern parity inductively defined follows variable pattern compatible elist olist compatible elist compatible elist olist compatible olist elist 
translation src match resulting refinement types different cases may different 
coerce meta operation defined section coerce chapter 
unrolling lists gamma assume gamma result fx 
kg loop gamma start gamma result ae gamma sigma gamma start gamma result fx 
ae kg gamma start gamma result gamma result translation declarations gamma par assume fp kg rules compatible par gamma par ae sigma gamma sigma gamma ae ae ae coerce ae ae ae translation matches elist elist fx 
olist tail fx 
tail fx 
new program variables olist tail sigma fx 
yg gamma sigma fx 
intg gamma elist new program variable elist tail sigma fx 
yg gamma sigma fx 
intg tail gamma olist new program variable 
translation patterns chapter 
unrolling lists different representations refinement types ae ae unified union type ae 
function translates src pattern tgt pattern parity assumption derives substitution refinement type environment variables src expression fix fn nil cons tgt expression fix fix fn fn olist elist fn tail fn tail tail example map function example shows target expression translating simplified version map function shown section 
function maps function list 
algorithm infers refinement type elist olist yield target expression notice real implementation expression inside inside contracted application tail inside inline expanded consecutive application contracted tail exactly form desired section 
notice src expression type translation algorithm returns tgt expression refinement type ae ae happens type tgt tgt set simple monomorphic typing rules tgt expressions ae defined extended elist ae olist ae 
example typing rule expression gamma tgt int gamma tgt elist gamma tgt olist rule fn gamma tgt list ae gamma tgt elist ae gamma tgt olist ae ae ae ae gamma tgt fn ae olist ae typing rules straightforward omitted 
chapter 
unrolling lists combine ae ae fn olist coerce ae ae elist coerce ae ae ae ae ae new program variables coerce ae ae coerce ae coerce elist list elist coerce olist list olist coerce ae ae fn coerce ae ae coerce ae olist ae list ae fn coerce ae ae ae coerce list ae ae olist ae fix fn new program variables combine ae ae coerce ae ae coerce ae ae coerce ae olist ae ae olist ae fix fn new program variables combine ae ae coerce ae ae coerce ae ae ae ae coerce ae ae ae ae ae ae ae fetch ae ae ae ae olist ae fetch respectively ae elist olist ae ae ae ae cases 
definitions combine coerce chapter 
unrolling lists definition meta operations section formally define meta operations coerce combine translation algorithm 
gives definition combine 
target expressions refinement types ae ae operation combine ae ae constructs dispatch tgt function calls respectively depending length parity argument 
occasionally necessary introduce code coerce result term representation 
target expression refinement types ae ae ae ae operation coerce ae ae returns new target expression defined 
notice combine coerce mutually recursive 
operation inserts appropriate coercions function applications 
tgt expressions refinement types ae ae operation ae ae returns tgt expression refinement type defined 
correctness translation type semantic correctness translation proven technique similar leroy ler 
sketch proof method state main theorem 
src denote type deduction rule src tgt denote refinement type deduction rule tgt 
specifically suppose te src type environment variables src types gamma refinement type environment te src means typed te src gamma tgt ae means refinement type ae gamma tgt define straightforward call value operational semantics gamma 
source language src gamma 
target language tgt value environments variables values 
notion equivalence typed src values corresponds osr typed tgt values corresponds nur defined written ae 
relation defined pair values type type ae ae te gamma denote dom te gamma 
type semantic correctness translation algorithm stated proposition proven structural induction proposition src expression src type environment te refinement type environment gamma te src valid gamma te chapter 
unrolling lists dom te id gamma ae succeed ae gamma tgt ae valid value environment gamma 
value environment gamma te gamma gamma 
exists value gamma 
ae 
compiling multiple continuations fun filter fun fu olist ce fo ce fu elist ce fe ce fo ce fun ke fun ko ce fe ke ko fe ce fe ce ce fe tail ce fun ke fun ko ce fo ke ko fo ce fu pseudo cps code filter algorithm section successfully translates program written osr notation nur 
cases pleasantly eliminates costs extra length parity checks alternating allocations olist elist cells incurred 
demonstrate tried algorithm frequently list processing library functions 
cases algorithm successfully eliminates extra costs 
exception filter function selects elements list matching predicate 
problem filter list functions hd tl length append rev map fold app nth exists filter 
taken initial basis standard ml new jersey compiler am :10.1.1.55.9444
chapter 
unrolling lists know length parity argument know length parity result 
filter function fun filter fun nil nil turns problem easily solved continuation passing style cps framework ste app specialize return continuation length parity result multiple entry points 
idea follows converting src expression cps method similar section infer refinement type sure length parity list expression duplicate return continuation accepting length list accepting odd length list 
example source language filter function cps converted filter function written pseudo cps notation ml 
ce ke ko continuation variables 
length parity variable return result fe fo statically unknown duplicating return continuation ke ko assumed length list odd length list parity check necessary efficient version 
heap allocation intermediate olist cons cell avoided representation analysis see chapter leroy ler 
transformation improve performance underlying compiler uses representation analysis see chapter leroy ler sophisticated closure construction register usage see chapter 
extra cost closure creations outweigh elimination cons operations 
note extra costs testing elist olist fewer tests nil 
result shown section nur version filter fast osr version specialized cps version analysis 
experiments implemented algorithm described section experimental version standard ml new jersey compiler sml nj am app 
compiler uses continuation passing style intermediate language multiple continuation chapter 
unrolling lists approach described section easily added done 
sml nj compiler supports representation analysis see chapter ler intermediate odd length lists represented unboxed records normally stay registers specialized versions length odd length lists operations require memory allocation 
table performance benchmark programs lists allocated cpu time code size mega words seconds bytes benchmark osr nur ratio osr nur ratio osr nur ratio life ray quicksort intset mmap avoiding code explosion translating osr nur involves function specialization recursion unrolling 
function takes list arguments way unrolled representation need entry points 
list processing functions take list argument functions take multiple list arguments append function concatenates lists exponential blowup serious concern 
avoid blowup system parameter called unroll level control depth specialization unrolling 
example suppose function arguments type list suppose unroll level compiler specialize arguments 
slight runtime cost specializing arguments problem practice frequently list functions take list arguments 
example functions initial list library sml nj compiler list argument append function list arguments 
chapter 
unrolling lists measurements technique guarantees savings memory usage way unrolling long lists 
execution time savings achieved operations removed 
demonstrate savings execution time compared performance benchmarks standard representation osr unrolled representation nur 
benchmarks include life game life implemented lists written rea see table chapter ray simple ray tracer see table chapter quicksort sorting list real numbers quicksort algorithm taken paulson pau sorting list real numbers variation mergesort algorithm taken paulson pau intset set operations sets integers implemented sorted lists mmap runs map function long list 
table gives total size lists allocated execution program execution time decstation code size increase unroll level set cons cell way unrolled 
cases nur version allocates memory runs faster osr version 
notice life benchmark frequently calls filter function functions list arguments specialized 
total size lists allocated nur osr nur requires fewer memory nil tests runs faster osr 
code size explode unroll level parameter increase factor 
currently exploring ways cutting code size nur maintaining performance gain 
problem current implementation nur compiler dead code detection algorithm believe refined implementation achieve code sharing produce smaller code 
related cdr coding techniques proposed early researchers mit xerox han gre cla cg bc bob 
schemes differ encoding methods rely hardware support nur allocates memory osr certain benchmarks table cons cell compiler contains extra descriptor word 
chapter 
unrolling lists lisp machines wm deu alleviate high costs incurred runtime encoding bits 
modern machines tend offer kinds special hardware support runtime cdr coding technique quickly obsolete 
static technique chapter simple compile time method doing list compaction 
attractive modern machines require runtime encoding bits 
li hudak lh proposed cdr coding scheme list compaction parallel environments 
lists constructed simultaneously heap non contiguous nature cells allocated eliminate opportunity compaction traditional cdr coding techniques 
overcome represent list linked fixed length vectors consing pre allocating vector consecutively filling elements 
technique relies runtime encoding bits distinguish state vector cell filled empty quite expensive 
static cdr coding method hand exploits compile time analysis eliminate runtime checks time poses problem parallel environments ordinary allocation 
side statically typed languages hall hal list compaction technique haskell 
scheme lists represented old standard representation osr place optimized representation place 
optimized representation scheme adapted lazy languages tail list may evaluated length parity known 
put extra elements list making test unrolled iteration complicated 
part scheme requires runtime checks 
hall analysis hindley milner type inference determines insert coercions different representations 
representations programs 
effect means library functions explicitly programmed different representations programs improved library functions 
idea special efficient representations frequently data objects type analysis originally leroy ler peyton jones pl 
propose type program transformation scheme allows objects monomorphic ml types special unboxed representations 
unboxed object interacts boxed polymorphic object appropriate coercions inserted 
mentioned leroy ler representation analysis techniques ml recursive data types list type 
coercion chapter 
unrolling lists unboxed boxed representation lists expensive costs proportional list length 
translation scheme hand allows commonly list objects uniformly efficient unrolled representations monomorphic type element values standard representation 
coercions representations length lists odd length lists lists length parity unknown quite cheap 
refinement type system section simplified version freeman pfenning refinement type system fp fre 
underlying framework type inference algorithm quite similar motivation different 
system refinement type declared programmer refinement type information detect program errors compile time 
reason refinement types hand compile time program transformations optimizations 
refinement type declaration scheme embedded compiler completely hidden programmers 
wadler views mechanism wad standard unrolled representations lists scheme linked pair functions function section 
introduce unrolled representation lists mainly improve space time efficiencies programs lists wadler uses views mechanism hide representations concrete data types reconcile pattern matching data abstraction 
summary list unrolling technique allows compact efficient list representation statically typed languages 
list unrolling technique generalizes depth unrolling ary trees dm entry points necessary function tree arguments 
reasoning lists trees languages easier pointers languages lists trees accessed data constructors pattern matching 
higher level language abstraction permits compiler automatically transform program uses efficient data representations permits loop unrolling eliminating certain control data dependences 
chapter ultimate goal software research find right programming model write best quality reliable efficient portable program amount time effort 
language researchers believe effective way achieve goal write programs higher level languages 
higher level languages provide simpler cleaner programming model difficult implement efficiently 
dissertation uses standard ml sml statically typed functional language test bed explore new compilation techniques modern higher level languages 
sml poses tough challenges efficient implementations frequent function calls polymorphic types recursive data structures higher order functions class continuations 
new compilation techniques meet challenges exploiting higher level language features sml ffl type directed compilation exploits compile time type information optimize data representations function calling conventions 
inserting coercions type instantiation abstraction site data objects sml unboxed representations presence polymorphic functions 
measurements show simple set type optimizations improve performance non type compiler decstation 
ffl space efficient closure representations utilizes compile time control data flow information optimize closure representations 
extensive closure sharing chapter 
allocating closures registers possible new closure conversion algorithm achieves asymptotic space usage improves performance old compiler decstation stack 
empirical analytic studies show execution cost stack allocated heap allocated activation records similar heap allocation simpler implement allow efficient class continuations 
ffl unrolling lists takes advantage higher level language abstraction sml support efficient representations lists 
representing cons cell multiple car fields cdr field unrolled list reduces memory links significantly shortens length control dependence data dependence chains operations lists 
table combined performance improvement execution time benchmark basis nrp occ rep occ nrp ncc rep ncc boyer sieve kb comp lexgen yacc life simple ray vliw average table summarizes combined improvement type directed compilation technique rep new space efficient closure conversion algorithm ncc 
code generated new compiler rep ncc average faster benchmarks generated old sml nj compiler nrp occ supports compilation nrp uses new closure algorithm occ 
techniques developed context sml apply languages share sml properties 
example type directed compilation technique chapter useful statically typed languages especially hindley milner polymorphic type system 
closure analysis technique chapter context continuation compilers applied compilers cps intermediate language 
safely linked chapter 
closures callee save registers essential building efficient compilers languages closures 
unrolling list technique chapter may lazy functional languages lazy evaluation difficult reason list length compile time 
strict languages lists frequently benefit great new unrolled representation especially modern machines 
new techniques dissertation significantly improved performance sml programs remains done sml programs run efficiently programs 
type directed compilation technique possible efficient data representations sml small subset implemented evaluated dissertation 
valuable support flat unboxed representation sophisticated descriptors shown 
avoid expensive coercions current implementation uses standard boxed representation recursive data structures 
currently looking scheme supports unboxed representations recursive data structures incurring runtime overhead 
type directed compilation technique chapter implements polymorphic functions inserting coercions type instantiation abstraction site 
way implement polymorphic function efficiently compile time type specializations 
support general specialization polymorphic functions cross module boundaries may lambda language explicit type abstractions type applications 
translate sml module lambda language kind typed lambda calculus remains research problem 
possible extensions done new closure analysis chapter 
example section way different numbers callee save registers represent continuation closures 
technique implemented evaluated 
extension register spilling analysis closure conversion phase 
machine code generator layout closure known closure conversion phase possible avoid building extra spilling record know variables accessed closure variables 
type information specifically object size information useful supporting better closure representations 
allow closure sharing chapter 
satisfying safe space complexity rule see section compiler type information guide check safe share closures 
long extra objects held constant size sharing closures cause asymptotic increase space usage 
unrolling lists technique described chapter implemented experimental version sml nj compiler evaluated mainly toy benchmarks 
unrolled list significantly shortens length control data dependence chains operations lists interesting implement evaluate technique modern superscalar machines 
hand done control code explosion 
new direction efficient compilation higher level languages see languages sml support better instruction level parallelism conventional languages 
reasons believe sml ffl sml value oriented functional language sml programs contain significantly fewer side effects programs 
means pointer aliasing analysis necessary calculate control data dependence compile time 
ffl sml compiled efficiently heap environment allocation scheme see chapter 
heap scheme closure created writes 
eliminates number side effects occurring run time 
stack scheme hand needs side effect stack frame times 
ffl sml statically typed language 
type directed compilation compiler knows static information object size variable static information may useful better instruction scheduling 
ffl sml uses concrete datatype declaration pattern matching define access data structures 
higher level abstraction gives compiler freedom choose efficient data representations fit superscalar machines unrolling lists 
summary higher level languages sml hold great promise efficient implementation modern machines 
languages easier easier analyze compile time programs provide opportunities advanced compiler optimizations 
near programs written chapter 
certain higher level languages may able get better performance machines programs written languages 
certainly hope dream software researchers 
bibliography aad tom gregory eric russ mason bill weiner jeff yetter 
performance features pa microprocessor 
ieee micro june 
ab michael allen michael becker 
multiprocessing aspects powerpc 
ieee compcon spring pages 
ieee computer society press february 
aj andrew appel trevor jim 
optimizing closure environment representations 
technical report dept computer science princeton university princeton nj 
aj andrew appel trevor jim 
continuation passing closure passing style 
sixteenth acm symp 
principles programming languages pages new york 
acm press 
andrew appel kai li 
virtual memory primitives user programs 
fourth int conf 
architectural support programming languages operating systems sigplan notices pages 
acm press april 
am andrew appel david macqueen :10.1.1.55.9444
standard ml new jersey 
martin wirsing editor third int symp 
prog 
lang 
implementation logic programming pages new york august 
springer verlag 
amt andrew appel james mattson david tarditi 
lexical analyzer generator standard ml 
distributed standard ml new jersey december 
app andrew appel 
garbage collection faster stack allocation 
information processing letter 
bibliography app andrew appel 
simple generational garbage collection fast allocation 
software practice experience 
app andrew appel 
runtime system 
lisp symbolic computation 
app andrew appel 
compiling continuations 
cambridge university press 
app andrew appel 
emulating write allocate write allocate cache 
technical report cs tr princeton university june 
app andrew appel 
loop headers calculus cps 
lisp symbolic computation page appear 
available princeton university tech report cs tr 
ar william aitken john reppy 
value constructors 
acm sigplan workshop ml applications pages june 
longer version available cornell univ tech 
report 
andrew appel zhong shao 
callee save registers continuationpassing style 
lisp symbolic computation 
andrew appel zhong shao 
empirical analytic study stack vs heap cost languages closures 
technical report cs tr princeton university department computer science princeton nj march 
appear journal functional programming 
asu alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley reading ma 
aug lennart augustsson 
garbage collection machine 
technical report pmg memo dept computer sciences chalmers university technology goteborg sweden december 
bak henry baker 
buried binding stale binding problems lisp 
unpublished june 
bak henry baker 
list processing real time serial computer 
communications acm april 
bibliography bar barendregt 
lambda calculus syntax semantics 
northholland amsterdam 
bc daniel bobrow douglas clark 
compact encodings list structure 
acm transactions programming languages systems october 
preston briggs keith cooper ken kennedy linda torczon 
coloring heuristics register allocation 
proc 
acm sigplan conf 
prog 
lang 
design implementation pages new york july 
acm press 
bh barnes hut 
hierarchical logn force calculation algorithm 
nature december 
bjo bjorner 
typing derivations 
acm sigplan workshop ml applications pages june 
bm boyer moore 
sharing structure theorem proving programs 
meltzer michie editors machine intelligence 
edinburgh university press 
bob daniel bobrow 
note hash linking 
communications acm july 
car luca cardelli 
compiling functional language 
proc 
acm conference lisp functional programming pages august 
car luca cardelli 
semantics multiple inheritance 
semantics data types international symposium pages berlin june 
springer verlag 
ccm cousineau curien mauny 
categorical machine 
jouannaud editor functional programming languages computer architecture lncs vol pages new york 
springer verlag 
cg douglas clark green 
empirical study list structure lisp 
communications acm february 
cha gregory chaitin 
register allocation spilling graph coloring 
symposium compiler construction pages new york june 
acm sigplan 
bibliography cha david chase 
safety considerations storage allocation optimizations 
proc 
acm sigplan conf 
prog 
lang 
design implementation pages new york june 
acm press 
cho fred chow 
minimizing register usage penalty procedure calls 
proc 
acm sigplan conf 
prog 
lang 
design implementation pages new york june 
acm press 
cho william clinger anne eric ost 
implementation strategies continuations 
acm conference lisp functional programming pages new york june 
acm press 
chr crowley hendrickson rudy 
simple code 
technical report lawrence livermore laboratory livermore ca february 
chu church 
calculi lambda conversion 
princeton university press 
cla douglas clark 
list structure measurements algorithms encodings 
phd thesis carnegie mellon univ pittsburgh pa august 
dan olivier danvy 
memory allocation higher order functions 
proceedings sigplan symposium interpreters interpretive techniques pages 
acm press june 
deu deutsch 
lisp machine compact programs 
proc 
rd pages 
dg damien doligez georges gonthier 
re stack scanning generational mail message aa lix polytechnique fr march 
bruce duba robert harper david macqueen 
typing class continuations ml 
eighteenth annual acm symp 
principles prog 
languages pages new york jan 
acm press 
dig digital equipment maynard ma 
tm aa microprocessor hardware manual edition october 
bibliography dm luis damas robin milner 
principal type schemes functional programs 
ninth annual acm symp 
principles prog 
languages pages new york jan 
acm press 
dtm amer diwan david tarditi eliot moss 
memory subsystem performance programs copying garbage collection 
proc 
st annual acm sigplan sigact symp 
principles programming languages pages 
acm press 
ea arvind 
simple exercise scientific programming 
technical report computation structures group memo mit cambridge ma july 
simultaneously published ibm watson research center research report yorktown heights ny 
fp tim freeman frank pfenning 
refinement types ml 
proc 
acm sigplan conf 
prog 
lang 
design implementation pages new york july 
acm press 
fre tim freeman 
carnegie mellon university personal communication 
fre tim freeman 
refinement types ml 
phd thesis carnegie mellon univ pittsburgh pennsylvania march 
cmu cs 
ftl feeley lapalme 
multilisp solving constraint satisfaction problems application nucleic acid determination 
lisp symbolic computation page appear 
gab richard gabriel 
performance evaluation lisp systems 
mit press boston ma 
lal george guillaume john reppy 
portable optimizing backend sml nj compiler 
proceedings international conference compiler construction pages 
springer verlag april 
gre greenblatt 
lisp machine progress report memo 
technical report lab cambridge ma august 
gs carsten gomard peter sestoft 
globalization live variables 
proceedings symposium partial evaluation semantics program manipulation pages 
acm press june 
bibliography hal cordelia hall 
hindley milner type inference optimize list representation 
acm conference lisp functional programming pages new york june 
acm press 
han hansen 
compact list representation definition garbage collection system implementation 
communications acm sep 
han david hanson 
portable storage management system icon programming language 
software practice experience 
han chris hanson 
efficient stack allocation tail recursive languages 
acm conference lisp functional programming pages new york june 
acm press 
har robert harper 
standard ml 
technical report ecs lfcs univ edinburgh dept computer science edinburgh eh jz august 
hdb robert hieb kent dybvig carl bruggeman :10.1.1.40.6828
representing control presence class continuations 
proc 
acm sigplan conf 
prog 
lang 
design implementation pages new york 
acm press 
hhh william hicks lawrence howell warren robert david tuttle 
data cache storage control units 
ibm risc system technology pages 
ibm 
hil mark hill 
case direct mapped caches 
ieee computer december 
hin roger hindley 
principle type scheme object combinatory logic 
trans 
amer 
math 
soc 
hj fritz henglein jesper jorgensen 
formally optimal boxing 
proc 
st annual acm sigplan sigact symp 
principles programming languages pages 
acm press 
paul hudak simon peyton jones philip wadler report programming language haskell non strict purely functional language version 
sigplan notices may 
bibliography hl robert harper mark lillibridge 
type theoretic approach higherorder modules sharing 
annual acm symp 
principles prog 
languages pages new york jan 
acm press 
robert harper peter lee frank pfenning eugene rollins 
incremental recompilation standard ml new jersey 
acm sigplan workshop ml applications june 
hm robert harper greg morrisett 
compiling polymorphism intensional type analysis 
second annual acm symp 
principles prog 
languages page appear new york jan 
acm press 
hud paul hudak 
conception evolution application functional programming languages 
acm computing surveys september 
joh thomas johnsson 
lambda lifting transforming programs recursive equations 
second international conference functional programming languages computer architecture pages new york september 
springer verlag 
jon mark jones 
theory qualified types 
th european symposium programming pages berlin february 
spinger verlag 
jou norman jouppi 
cache write policies performance 
proceedings th annual international symposium computer architecture pages 
acm press may 
kh richard kelsey paul hudak 
realistic compilation program transformation 
sixteenth acm symp 
principles programming languages pages new york 
acm press 
kkr kranz kelsey rees hudak philbin adams 
orbit optimizing compiler scheme 
sigplan notices proc 
sigplan symp 
compiler construction july 
kra david kranz 
orbit optimizing compiler scheme 
phd thesis yale university new haven ct 
lan landin 
mechanical evaluation expressions 
computer journal 
bibliography lan landin 
correspondence algol church lambda notation part acm 
ler xavier leroy 
unboxed objects polymorphic typing 
nineteenth annual acm symp 
principles prog 
languages pages new york jan 
acm press 
longer version available inria tech report 
ler xavier leroy 
manifest types modules separate compilation 
annual acm symp 
principles prog 
languages pages new york jan 
acm press 
lh henry lieberman carl hewitt 
real time garbage collector lifetimes objects 
communications acm 
lh kai li paul hudak 
new list compaction method 
software practice experience february 
mac david macqueen 
modules standard ml 
acm conference lisp functional programming pages new york august 
acm press 
mac david macqueen 
weak types 
distributed standard ml new jersey 
mcc john mccarthy 
recursive functions symbolic expressions computation machine part communications acm 
mil robin milner 
theory type polymorphism programming 
comput 
syst 
sci march 
mt robin milner mads tofte 
commentary standard ml 
mit press cambridge massachusetts 
mt david macqueen mads tofte 
semantics higher order functors 
th european symposium programming pages berlin april 
spinger verlag 
mth robin milner mads tofte robert harper 
definition standard ml 
mit press cambridge massachusetts 
bibliography pau lawrence paulson 
ml working programmer 
cambridge university press cambridge 
pet john peterson 
untagged data tagged environments choosing optimal representations compile time 
fourth international conference functional programming languages computer architecture pages new york september 
acm press 
pey simon peyton jones 
implementation functional programming languages 
prentice hall new york 
pey simon peyton jones 
implementing lazy functional languages stock hardware spineless tagless machine 
journal functional programming april 
pl simon peyton jones john launchbury 
unboxed values class citizens non strict functional language 
fifth international conference functional programming languages computer architecture pages new york august 
acm press 
plo gordon plotkin 
call name call value calculus 
theoretical computer science 

representation analysis efficient implementation polymorphism 
master thesis diku university copenhagen 
rc rees clinger 
revised report algorithmic language scheme 
sigplan notices 
rea chris 
elements functional programming 
addison wesley reading ma 
rei mark reinhold 
cache performance garbage collected programs 
proc 
sigplan symp 
prog 
language design implementation pages 
acm press june 
rep john reppy 
cml higher order concurrent language 
proc 
acm sigplan conf 
prog 
lang 
design implementation pages 
acm press 
bibliography rep john reppy 
high performance garbage collector standard ml 
technical memorandum bell laboratories murray hill nj january 
guillermo juan 
liar algol compiler scheme 
thesis mit dept computer science electrical engineering june 
rp barbara ryder marvin 
elimination algorithms data flow analysis 
acm computing surveys september 
rw colin runciman david wakeling 
heap profiling lazy functional programs 
journal functional programming april 
sa zhong shao andrew appel 
recompilation 
technical report cs tr princeton univ dept computer science princeton nj october 
sa zhong shao andrew appel 
recompilation 
proc 
twentieth annual acm sigplan sigact symp 
principles programming languages pages 
acm press 
sa zhong shao andrew appel 
space efficient closure representations 
acm conference lisp functional programming pages new york june 
acm press 
shi olin shivers 
control flow analysis higher order languages 
phd thesis carnegie mellon univ pittsburgh pennsylvania may 
cmu cs 
sm darko eliot moss 
characterization object behaviour standard ml new jersey 
acm conference lisp functional programming pages new york june 
acm press 
sra zhong shao john reppy andrew appel 
unrolling lists 
acm conference lisp functional programming pages new york june 
acm press 
ss guy steele gerald jay sussman 
dream lifetime lazy variable extent mechanism 
proceedings lisp conference pages stanford 
sta standards performance evaluation spec benchmark suite release october 
bibliography ste guy steele 
rabbit compiler scheme 
technical report ai tr mit cambridge ma 
ste guy steele 
common lisp language 
digital press digital equipment 
ta david tarditi andrew appel 
ml yacc version 
distributed standard ml new jersey april 
tar robert tarjan 
testing flow graph reducibility 
journal computer system science december 
tof mads tofte 
principal signatures high order ml functors 
nineteenth annual acm symp 
principles prog 
languages pages new york jan 
acm press 
tur alan turing 
computability definability 
symbolic logic 
ull jeffrey ullman 
elements ml programming 
prentice hall englewood cliffs nj 
ung david ungar 
design evaluation high performance smalltalk system 
mit press cambridge ma 
wad philip wadler 
views way pattern matching cohabit data abstraction 
fourteenth annual acm symp 
principles prog 
languages pages new york jan 
acm press 
wan mitchell wand 
continuation multiprocessing 
conf 
record lisp conf pages new york august 
acm press 
wb wadler blott 
ad hoc polymorphism ad hoc 
sixteenth annual acm symp 
principles prog 
languages pages new york jan 
acm press 
wil paul wilson 
issues strategies heap management memory hierarchies 
sigplan notices march 
wlm paul wilson michael lam thomas moher 
caching considerations generational garbage collection 
acm conference lisp functional programming pages new york june 
acm press 
bibliography wm weinreb moon 
lisp machine manual 
technical report symbolics cambridge mass 
zor benjamin zorn 
effect garbage collection cache performance 
technical report cu cs university colorado boulder may 
