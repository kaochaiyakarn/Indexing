reversible dac improvements solving max csp javier larrosa univ pol 
de catalunya pau barcelona spain larrosa lsi upc es pedro meseguer iiia csic campus uab spain pedro iiia csic es thomas schiex de rouge bp castanet cedex france toulouse fr rard verfaillie cert av 
belin bp toulouse cedex france verfaillie cert fr wallace max csp improved larrosa meseguer tested number possible improvements usage directed arc consistency partial forward checking algorithm pfc 
main improvement consists exploiting non standard form dac called reversible dac constraint exploited direction necessarily determined variable ordering change dynamically search 
improvements include avoiding constraint checks forward checking exploiting constraint checks performed dac preprocessing ii dynamic variable ordering search iii maintaining directed arc consistency counts search values get deleted 
improvements assessed empirically random csp instances 
lead large performance gains respect initial algorithm 
constraint satisfaction problems csp consist assigning values variables set constraints 
solution total assignment satisfies constraint 
practice assignment may exist may interest find total assignment best respects sense constraints 
type problem interest applications captured general frameworks semiring valued csp frameworks defined montanari rossi schiex fargier verfaillie 
focus called max csp problem solution total assignment minimizes number violated constraints reader aware algorithms easily extended valued csp framework needed 
efc dac algorithm larrosa meseguer pfc dac short improvement dac algorithm introduced wallace 
best complete algorithms max csp 
branch bound algorithm forward checking directional arc consistency preprocessing step 
research javier larrosa pedro meseguer supported spanish cicyt project tic copyright american association artificial intelligence www aaai org 
rights reserved 
prune search tree lower bound number unsatisfied constraints computed takes account constraints assigned variables ii constraints assigned unassigned variables forward checking iii constraints unassigned variables directed arc consistency counts dac 
needs static variable ordering 
improvements algorithm 
main improvement relax condition dac computed direction defined variable ordering 
save constraint checks forward checking exploiting constraint checks performed dac preprocessing ii possible dynamic variable ordering search iii maintain dac search values get deleted simply precomputing 
organized follows 
section related algorithms solving max csp 
provide preliminaries definitions required sequel 
consider original algorithm improvements 
result improvements assessed empirically random max csp instances 
related general scheme algorithms solving branch bound scheme 
algorithm performs systematic traversal search tree node corresponds set assigned past variables set unassigned variables 
node variable selected current variable feasible values considered instantiation 
search proceeds branch bound keeps track best solution obtained far total assignment violates minimum number constraints explored part search tree 
order avoid exploration complete search tree algorithm computes node lower bound cost best solution possibly current node 
lower bound larger equal cost best solution far called upper bound current line search abandoned lead better solution current 
practice efficiency branch bound algorithms deeply depends quality lower bound large possible cheap compute possible 
node simplest lower bound imagine defined number constraints violated partial assignment associated node called distance node 
pfc algorithm uses forward checking improve lower bound see freuder wallace detailed description 
improvements introduced russian doll search algorithm verfaillie tre schiex algorithms directed arc consistency 
notion directed arc consistency introduced dechter pearl context classical csp 
dac max csp method improve lower bound quality pfc algorithm proposed wallace improved larrosa meseguer wallace 
preprocessing step called directed arc consistency counts computed value variable ordering 
order static variable ordering variable instantiation dac branch bound algorithm 
preliminaries discrete binary csp defined finite set variables ng 
variable takes values finite domain subject constraints ij constraint ij subset theta defines allowed pairs values variables note number variables constraints maximum cardinality domains sequel denote variables denote values pair denotes value variable usual arc consistency algorithms associate csp symmetric directed graph 
directed arc consistency define directed graph csp graph vertex variable edge constraint ij graph uniquely defined csp 
edges denoted edges 
note pred resp succ set variables resp 
edge define direc tion gamma constraint directed arc consistency defined variable ordering define directed graph induced variable ordering directed graph csp edges 
directed graph edges oriented direction opposed variable ordering 
directed arc consistency count associated value variable noted dac ia defined number variables pred arc inconsistent value value domain compatible 
dac simply precomputed ed time nd space 
min dac ia lower bound number inconsistencies variables ordering total assignment 
pfc dac algorithm larrosa meseguer branch bound algorithm 
described functions pfc dac lookahead 
variables lower bound exploits directed arc consistency counts defined combined called inconsistency counts introduced pfc algorithm freuder wallace 
partial assignment inconsistency count associated value variable noted ic ia number constraints assigned variable violated value assigned variable freuder wallace 
fv set variables sum fv min ic ia dac ia lower bound number constraints violated currently unassigned variables csp variables total assignment extending current partial assignment 
lower bound prune branches line prune values lines 
function pfc dac main function current partial assignment distance fv fd variables domains pfc dac fv fd fv fv fv fv values fd values values newd newd fv min ic jb dac jb lookahead fv fd pfc dac newd fv values values function pfc dac propagation function assignment propagate fv fd variables domains lookahead fv fd foreach fv foreach fd newd fv minc ic jb dac jb prune inconsistent increment ic jb newd fv minc ic jb dac jb prune return updated domains dac improvements basic procedure pfc dac max csp improved different ways provided dac cessing produces data structure records contribution variable connected count dac ia information contained data structure search perform improvements detailed 
size data structure ed 
different independent improvements dac usage 
saving checks associated dac 

dynamic variable ordering 

reversible dac 

maintaining dac 
saving checks associated dac true oe means value compatible 
variable current assigned value know ic feasible value variable incremented arc inconsistent ic updating values done constraint check 
practice incrementing ic jb increase current distance prevent updating ic jb true 
simple idea allows lookahead reuse results obtained dac preprocessing saves repetition constraint checks associated detected arc inconsistencies 
dynamic variable orderings original pfc dac requires follow static order variable selection dac computation 
longer required provided individual contributions dac available 
variables true 
dac propagate effect ij violation constraint recorded dac variable variable instantiated lookahead propagate possible violation ij incrementing ic particular ic ia 
inconsistency recorded dac ia forward edge adding ic ia dac ia count twice inconsistency 
problem overcome far lookahead detects situation avoids redundant contribution lower bound 
know ij safely instantiated far prevent updating ic ia true 
way guaranteed inconsistencies counted ic dac values added form lower bound inconsistencies value 
reversible dac originally wallace discarded full arc inconsistency counts record inconsistency twice addition safely compute lower bounds 
proposed directed arc inconsistency counts suffer drawback 
dechter pearl directed arc consistency wallace required static variable ordering dac computed direction corresponding edge lower bound computation restriction arbitrary removed 
constraint contribute dac possible directions avoid inconsistency repetition selected direction induced variable ordering 
idea mind directed graph csp define directed arc inconsistency counts dac ia graph number variables pred arc inconsistent 
lower bound number violated constraints may exist complete assignment defined min dac ia search lower bound far dac contributions past variables removed distance fv min ic ia dac ia node try find optimal directed graph determine order constraint maximizes lower bound 
taken simpler approach locally optimize node tree search simple greedy heuristics 
approach start graph inherited previous search state reverse constraints variables improves lower bound 
process iterates constraints 
constraint reversed dac need appropriately modified 
data structure suitable efficiently 
dynamic variable ordering case forward edges may met assignment know ij safely instantiated far prevent updating ic ia true 
maintaining dac pfc dac requires strong condition variables contribute dac counts need hold search starts value pruned 
pfc dac algorithm prunes values execution 
implies dac counters precomputed initially search updated search 
maintaining dac approach consists keeping updated dac search account current domains 
causes higher dac computed leads higher lower bound branches may pruned value deletions occur propagated perform maintaining dac arc consistency algorithm adequate datastructures adapted propagate effect value removal static direction constraints basic pfc dac procedure directions reversible dac approach taken 
implementation improvements introduced 
sake simplicity limited space define version algorithm includes refinements 
data structure described previous section true iff variable contributes dac ia needed improvements 
order implement fourth improvement dac maintainance ac datastructures contains number supports value variable contains list values supported 
data structures space complexity ed ed respectively useless dac maintained 
observe true datastructure redundant removed case 
extra data structures introduced easily maintain quantities argmin ic ia dac ia min ic ia dac ia sum minima variables 
quantities respectively maintained arrays variable 
data structures updated simple function noted sequel described simplicity 
function pfc mrdac main function current assignment distance fv fd variables domains current directed graph pfc mrdac dvo fv fd fv fv fv fv values fd values values newd newd lookahead fv fd newd newd pfc mrdac dvo newd fv values values algorithm embodied main function dvo 
reader aware context restoration mechanisms code sake simplicity main function pfc mrdac dvo called initialize datastructures dac fourth improvement 
initialization straightforward described 
performed time ed 
compared initial pfc dac algorithm line modified order implement improvement 
lines inserted implement reversible dac improvement 
function line implements greedy optimization current directed graph 
call new lower bound may available new values may pruned 
done function line 
lookahead function charge propagating assignment 
lines inserted update data structure needed 
improvements need prevent updating ic jb cases corresponding costs taken account pfc mrdac dvo line 
done test lines 
change function consists calls new function lines implements fourth improvement function charge propagating deletion value previous line updating directed arc consistency counts 
function pfc mrdac propagation function assignment propagate fv fd variables domains lookahead fv fd foreach fv false foreach fd newd gamma ic jb dac jb prune fv direction gamma direction inconsistent increment ic jb ic jb dac jb true newd gamma ic jb dac jb prune fv return updated domains propagation done simply ac datastructures number supports feasible values supported value deleted decremented 
value loses supports constraint context done lists memorize changes undo changes backtrack 
correct direction constraint directed graph corresponding dac incremented data structures updated function needed 
note function lookahead completely maintain dac 
deletion lookahead propagated deletion propagated 
appeared useless experiments 
function updating dac deletions deleted value fv set variables fv false foreach fv foreach feasible decrement direction increment dac jb ic jb dac jb true return function charge optimizing current directed graph order improve current lower bound 
simple greedy function edge reversed directed arc consistency counts modified accordingly 
lower bound recomputed change kept leads improvement 
function stops improvement obtained 
note edge reversed simple test performed line test obvious necessary condition improvement possible 
function finding directed graph current directed graph false foreach fv 
edges minf mint reverse minf mint reverse true return updated graph function charge value deletions lower bound improved function 
considered simplified lookahead function 
value deletion propagated function 
contrarily function lookahead fix point reached value deletions propagated new deletion occurs 
useful practice gains minor 
function pruning values lower bound improvement current distance fv set variables fv false copy foreach fv foreach fd gamma ic jb dac jb prune fv wipe empty true copy true return empty experimental results evaluated performance algorithms constrained random csp 
random csp characterized hn number variables number values variables graph connectivity defined ratio existing constraints constraint tightness defined ratio forbidden value pairs 
constrained variables forbidden value pairs randomly selected prosser 
model experimented problems classes 





observe highly connected problems problems medium connectivity sparse problems 
problem class parameter setting generated samples instances 
problem solved algorithms described larrosa meseguer pfc reversible dac dynamic variable ordering dvo pfc maintaining reversible dac dvo 
refer algorithms pfc dac pfc pfc mrdac respectively 
pfc dac forward degree breaking ties backward degree larrosa meseguer static variable ordering 
pfc dvo uses minimum domain breaking ties graph degree dynamic variable ordering 
dvo pfc mrdac observed give gain algorithm 
values selected increasing ic dac 
algorithms share pfc dac pfc dvo pfc mrdac cpu time pfc dac pfc dvo pfc mrdac pfc dac pfc dvo pfc mrdac cpu time pfc dac pfc dvo pfc mrdac pfc dac pfc dvo pfc mrdac cpu time pfc dac pfc dvo pfc mrdac measure cpu time various locations random csp space random class pfc pfc pfc dac dvo mrdac table visited nodes algorithms hardest class pfc dac 
code data structures possible 
experiments performed sun sparc workstation 
reports average cost required solve problem classes 
overhead produced consistency check free cpu time compare search effort 
observed pfc improves pfc dac practically problem classes 
gain grows problem tightness 
pfc times faster pfc dac tightest sparse instances 
typical improvement ratios range tightness greater 
regarding contribution individual improvements state doubt reversible dac main responsible gain 
avoiding repetition checks associated dac dvo limited effect cause improvement ratios 
regarding pfc mrdac observe maintaining pay tightest instances sparse problems 
sparse problems times faster pfc 
fact understandable ac implementation 
loose constraints lists support longer supports higher 
propagating deletion costly produce new dac contribution 
believe moving elaborated local consistency algorithms ac increase range problems maintaining pays 
regarding number visited nodes table contains average number algorithm hardest problem class pfc dac 
observe decrease order magnitude pfc dac pfc orders class 
dvo pfc mrdac average number visited nodes divided constant 
savings cpu time large visited nodes improved algorithms perform node pfc dac 
observations may extracted 
quite surprisingly observed dynamic variable orderings brings provides minor savings 
contradicts traditional wisdom classical csp studies needed check better dvo heuristics 
fact reversible dac improvement brings largest savings confirms importance lower bound quality branch bound algorithms max csp 
feeling lower bound quality remains major issue complete algorithms max csp 
considering simplicity greedy optimization algorithm optimizing probably opportunity improve lower bound 
montanari rossi 
constraint solving semirings 
proc 
th ijcai 
dechter pearl 
network heuristics constraint satisfaction problems 
artificial intelligence 
freuder wallace 
partial constraint satisfaction 
artificial intelligence 
larrosa meseguer 
exploiting dac max csp 
proc 
cp 
prosser 
binary constraint satisfaction problems harder 
proc 
st ecai 
schiex fargier verfaillie 
valued constraint satisfaction problems hard easy problems 
proc 
th ijcai 
verfaillie tre schiex 
russian doll search 
proc 
aaai 
wallace 
directed arc consistency preprocessing 
meyer ed selected papers ecai workshop constraint processing number lncs 
berlin springer 

wallace 
enhancements branch bound methods maximal constraint satisfaction problem 
proc 
aaai volume 
portland aaai press mit press 
