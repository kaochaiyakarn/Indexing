buckets heaps lists monotone priority queues boris cherkassky central econ 
math 
inst 
st moscow russia cher su andrew goldberg nec research institute independence way princeton nj avg research nj nec com craig silverstein computer science department stanford university stanford ca theory stanford edu introduce heap top hot priority queue data structure combines multi level bucket data structure fox heap 
new data structure obtain log ffl expected time implementation dijkstra shortest path algorithm improving previous bounds 
implement hot queues efficiently practice sorted lists represent small priority queues 
experimental results context dijkstra algorithm show implementation hot queues performs robust implementations heap multi level bucket data structures 
priority queue data structure maintains set elements supports operations insert decrease key extract min 
priority queues fundamental data structures applications 
typical applications include graph algorithms event simulation 
important subclass priority queues applications event simulation dijkstra shortest path algorithm class monotone pri done author visiting nec research institute 
supported department defense partial support nsf award ccr matching funds ibm schlumberger foundation shell foundation xerox 
queues 
intuitively priority queue monotone time keys elements queue big key element extracted queue 
deal monotone priority queues 
mentioned refer priority queues operation time bounds depend number elements queue heaps 
fastest implementations heaps described 
alternative implementations priority queues buckets 
operation times implementations depend maximum event duration defined section 
see related data structure 
heaps particularly efficient number elements heap small 
bucket priority queues particularly efficient maximum event duration small 
furthermore done bucket implementations amortized elements buckets yielding better bounds number elements large 
sense heaps buckets complement 
introduce heap top priority queues hot queues combine multi level bucket data structure fox heap 
queues heap buckets buckets sparsely occupied 
resulting implementation takes advantage best performance features data structures 
give alternative insightful description multi level bucket data structure 
concurrently independently similar description raman 
hot queues related radix heaps rh ahuja 
rh similar multi level buckets uses heap find nonempty buckets 
get best bounds heap operation time rh depend number distinct keys heap 
complicated part modifying fibonacci heaps meet requirement 
contrast hot queue bounds require special heap 
fibonacci heaps modifications achieve bounds rh 
heap thorup obtain better bounds 
side effect obtain log ffl expected time implementation dijkstra shortest path algorithm improving previous bounds 
thorup bounds depend total number elements heap rh take immediate advantage data structure 
believe data structures especially interesting theory practice 
preliminary version hot queue data structure perform practice 
experimental feedback modified data structure practical 
developed techniques hot queues efficient practice 
compare implementation hot queues implementations multi level buckets ary heaps context dijkstra shortest paths algorithm 
experimental results show hot queues perform best robust data structures 
especially significant multi level bucket implementation dijkstra algorithm compared favorably implementations algorithm previous study shown robust 
problem classes hot queue implementation dijkstra algorithm best theory practice 
due page limit omit proofs details experimental data 
full version appears 
preliminaries priority queue data structure maintains set elements supports operations insert decrease key extract min 
assume elements keys compare elements denote key element ae 
mentioned assume keys integral 
value element mean key element 
insert operation adds new element queue 
decrease key operation assigns smaller value key element queue 
radix heap operation time bounds depend extract min operation removes minimum element queue returns element 
denote number insert operations sequence priority queue operations gain intuition definition think event simulation applications keys correspond processing times 
latest element extracted queue 
event insert decrease key operation queue 
event element inserted queue element key decreased 
event duration ae gamma ae 
denote maximum event duration application monotone event durations nonnegative 
monotone priority queue priority queue monotone applications 
definitions valid insertion assume initialization special element inserted queue deleted immediately 
loss generality assume value element zero 
subtract value element values 
heap mean priority queue operation time bounds functions number elements queue 
assume heaps support find min operation returns minimum element heap 
call sequence operations priority queue balanced sequence starts ends empty queue 
particular implementations dijkstra shortest path algorithm produce balanced operation sequences 
ram model computation 
result model appears attributed schieber 
result machine words find constant time index significant bit words differ 
multi level buckets section describe level bucket data structure fox 
give simpler description data structure treating element keys base delta numbers certain parameter delta 
consider bucket structure contains levels buckets positive integer 
top level level contains array delta buckets 
top level contains infinitely buckets 
top level bucket corresponds interval delta delta gamma 
choose delta delta consecutive buckets top level nonempty need maintain buckets 
denote bucket level 
bucket contains set elements way allows additions deletions doubly linked list 
choose delta small possible subject constraints 
top level bucket contain delta integers 
definition keys elements belong delta top level buckets 
second delta power manipulate base delta numbers efficiently ram operations words bits 
constraints mind set delta smallest power greater equal maintain key latest element extracted queue 
consider base delta representation keys element definitions delta significant digits base delta representation ae uniquely determine ae 
ae numbers represented significant digits ae respectively ae ae gamma ae ae delta ae gamma 
denote th significant digit base delta representation 
denote number obtained deleting gamma significant digits similarly denote th significant digits ae denote number obtained deleting gamma significant digits ae levels numbered top bottom buckets level numbered delta gamma 
index significant digit ae differ ae 
ae say position respect 
inserted inserted 
element store position 
element significant digits ae equal corresponding digits lemma follows fact keys elements queue 
lemma 
level buckets empty 
level maintain number elements level 
maintain total number elements extract min operation change value 
side effect positions elements may change 
suppose minimum element deleted simplest way implement top level wrap modulo delta 
value changes 
value deletion value deletion 
definition keys elements queue deletion position significant digit differ 
differ digit element deletion position deletion 
elements bucket respect exactly position different respect elements longer prefix common belong lower level respect bucket expansion procedure moves elements new positions 
procedure removes elements puts positions respect key properties bucket expansions follows ffl expansion elements correct positions respect ffl element moved expansion moved lower level 
ready describe multi level bucket implementation priority queue operations 
ffl insert insert element compute position insert 
ffl decrease key decrease key element position follows 
remove 
set ae new value insert described 
ffl extract min need find delete minimum element update move elements affected change 
find lowest nonempty level find nonempty bucket level delete element set ae return 
case old new values differ digit element positions remain 
examine elements delete minimum element 
set ae expand 
return deal efficiency issues 
lemma 
compute position respect constant time 
iterating levels find lowest nonempty level time 
binary search find level log time 
better power ram model lemma 
log lowest nonempty level time 
see best bounds achieved log simple way finding nonempty bucket level go buckets 
takes delta time 
lemma 
find nonempty bucket level delta time 

better 
divide buckets level groups size dlog ce group containing consecutive buckets 
group maintain dlog ce bit number bit equal th bucket group empty 
find nonempty group delta log time nonempty bucket group time 
construction gives log factor improvement bound lemma 
iterating construction times get delta log bound 
observation improves multilevel bucket operation time bounds small values bounds optimal value improve 
simplify presentation lemma improved version rest 
theorem 
amortized bounds multi level bucket implementation priority queue operations follows insert decrease key extract min 
proof 
insert operation takes worst case time 
assign amortized cost charge moves elements lower level insertions elements 
decrease key operation takes worst case time assign amortized cost 
extract min operation show worst case cost plus cost bucket expansions 
cost bucket expansion proportional number elements bucket 
cost amortized insert operations minimum element element examined bucket expansion moved lower level 
excluding bucket expansions time operation plus delta finding nonempty bucket 
completes proof delta 
note sequence operations number insert operations number extract min operations 
balanced sequence numbers equal modify proof obtain result 
theorem 
balanced sequence amortized bounds multi level bucket implementation priority queue operations follows insert decrease key extract min 
extract min bound 
bound 
best bound log log log obtained log log log 
level bucket data structure uses theta kc space 
hot queues hot queue uses heap multi level bucket structure intuitively hot queue data structure works multi level bucket data structure expand bucket containing elements parameter set optimize performance 
elements bucket copied processed heap operations 
number elements bucket exceeds bucket expanded 
analysis charge scans buckets lower levels elements bucket expansion levels obtain improved bound 
level hot queue uses level bucket structure additional special level needed account scanning buckets level buckets top level nonempty time 
note queue nonempty buckets nonempty 
bucket scans special level add constant amount processing element 
wrap level active bucket bucket elements bucket active time empty active bucket 
denote active bucket 
bucket active making heap containing bucket elements inactive heap empty heap 
elements active bucket bucket 
describe details hot queues need definitions 
denote number elements 
delta say element range ae obtained replacing gamma significant digits delta gamma 
ram operations check element range bucket constant time 
maintain invariant range active bucket 
detailed description queue operations follows 
ffl insert empty element inserted range active bucket insert multi level case 
belongs active bucket 
insert 
inactive add expand bucket 
ffl decrease key decrease key element follows 
decrease key position remove 
set ae new value insert described 
ffl extract min empty extract return minimum element proceed follows 
find lowest nonempty level find nonempty bucket level examining buckets starting 
delete element set ae return examine elements delete minimum element 
set ae 
expand 
active 
return correctness hot queue operations follows correctness multi level bucket operations lemma observation ae ae 
lemma 
cost finding nonempty bucket level amortized insert operations delta 
proof 
scan nonempty bucket search nonempty bucket 
scan empty bucket level period time prefix including gamma digits remains 
furthermore scan buckets level nonempty 
happen higher level bucket expanded period prefix change 
charge bucket scans insertions elements queue 
elements expanded charged times giving desired bound 
theorem 
time bounds heap insert decrease key find min extract min operations 
amortized times hot queue operations follows insert decrease key kc extract min 
proof 
key facts crucial analysis 
fact number elements exceeds level accounts elements 
second fact lemma 
fact theorem bounds straightforward 
fibonacci heaps amortized time bounds logn 
gives log kc amortized bounds queue operations insert decrease key extract min respectively 
setting log get log log amortized bounds 
radix heaps achieve bounds complicated 
thorup heaps expected amortized time bounds log ffl 
gives log ffl kc expected amortized time bounds queue operations insert decrease key extract min respectively 
ffl positive constant 
setting log get log log ffl expected amortized time 
similarly theorem get bounds balanced sequence operations 
theorem 
time bounds heap insert decrease key find min extract min operations consider balanced sequence hot queue operations 
amortized bounds operations follows insert decrease key kc extract min 
fibonacci heaps get log kc amortized bounds queue operations 
consider extract min operation nonconstant bound 
setting log get bound 
setting log get bound 
setting log get log bound 

bounds valid heap 

consider level implementations 
time bounds level implementation advantages uses space time bounds remain valid wider range values thorup heaps setting log get log ffl expected amortized time bounds 
time bounds allow get improved bound dijkstra shortest path algorithm 
suppose graph vertices arcs integral arc lengths range 
running time dijkstra algorithm dominated balanced sequence priority queue operations includes insert extract min operations decrease key operations see 
maximum event duration sequence operations bounds queue operations immediately imply result 
theorem 
network vertices arcs integral lengths range shortest path problem solved log ffl expected time 
improves deterministic bound log 
hot queue implementation fibonacci heaps matches deterministic bound 
implementation details previous papers describe implementations multi level buckets :10.1.1.10.9520
implementation hot queues augments multi level bucket implementation :10.1.1.10.9520
see details multi level bucket implementation :10.1.1.10.9520
consider level hot queue 
multi level bucket implementation set delta smallest power greater equal analysis section experimental results set maximum size active bucket log number elements active bucket small 
take advantage fact maintaining elements active bucket sorted list heap operations list expensive 
point switch heap 
heap worked best tests 
see 
implement priority queue operations sorted list doubly linked list sorted nondecreasing order 
implementation designed shortest path application 
application number decrease key operations elements active bucket tends small fact proven random graphs 
elements inserted list moved decrease key operation tend close list 
different implementation may better different application 
insert operation searches element position list puts element position 
start search different places 
implementation starts search list 
starting list point insertion may better applications 
extract min operation removes element list 
decrease key operation removes element list finds new position puts element position 
implementation starts search list 
starting previous position element list place insertion may better applications 
bucket active put elements list number elements bucket heap 
code uses 
switch list heap rule suggested satish rao personal communication switch insert decrease key operation examines elements 
alternative may better applications performed worse switch number elements list exceeds experimental setup experiments conducted pentium pro mhz processor running linux 
machine meg 
memory problem instances fit main memory 
code written compiled linux gcc compiler version optimization option 
effort code efficient 
particular set bucket array sizes powers 
allows word shift operations computing bucket array indices 
full reports experimental results types graphs 
graph types chosen exhibit properties algorithm extremes paths start vertex vertices tend order theta path lengths order theta 
third graph type random sparse graphs 
fourth type constructed lot decrease key operations active bucket 
meant test robustness implementations violate assumption section decrease key operations 
fifth type graphs meant easy hard specific implementation specific number bucket levels 
tested type graph implementations ary heaps level buckets ranging level hot queues ranging 
parameters tune results show best parameter values tested 
problem families previous :10.1.1.10.9520
sections describe problem families 
graph types graphs explored grids produced generator 
graphs characterized length width graph formed constructing layers path length order layers vertices layer connect vertex corresponding vertex adjacent layers 
vertices layer connected source 
type graph long grid constant width vertices tests 
graphs different lengths ranging vertices 
arcs lengths chosen independently uniformly random range varied 
second type graph wide grid type 
graphs length limited layers width vary vertices 
long grids 
third type graphs includes random graphs uniform arc length distribution 
random graph vertices arcs 
fourth type graphs type new compared :10.1.1.10.9520
cycle vertices numbered addition vertex connected gamma distinct vertices 
length arc equal number arcs cycle path fifth type graphs includes hard graphs 
parameterized number vertices desired number levels maximum arc length compute number buckets level assuming implementation levels 
graphs consist paths connected source 
vertices path distance 
distance source path vertices path occupy bucket bottom level bins 
distance source path gamma making vertices occupy bucket bottom level bin 
addition source connected vertex path arc length vertex second path arc length summary graph types appears table 
problem graph type examined relative performance implementations changed increased various parameters 
type modification constitutes problem family 
families summarized table 
general family constructed varying parameter holding constant 
different families vary parameter different constant values 
experimental results level bucket structures robust :10.1.1.10.9520
cases level hot queues perform similarly usually slightly better corresponding multi level bucket structures 
level hot queues significantly robust level buckets robust level hot queues 
due shortage space experimental results hard problems 
problems separate hot queues multi level buckets 
tables denotes implementation heap bi buckets levels hi hot queue levels 
report running times counts operations give insight algorithm performance 
heap implementation count total number insert decrease key operations 
bucket implementations count number empty buckets examined empty operations 
hot queue implementations count number empty operations number insert decrease key operations active bucket 
plot data addition 
unable run level bucket hot queue implementations problems memory limitations 
leave corresponding table entries blank 
tables give data hard hard families designed hard level bucket implementations respectively 
elements heap time heap implementation efficient hard problems 
hot queue implementations bucket expanded action confined special top level buckets 
hot queues perform heaps 
exception largest value handle running time times greater value explanation discrepancy 
hard problems hard expected implementations poorly family 
similarly bucket implementation worse implementations hard family 
concluding remarks theory hot queue data structure better heap multi level bucket data structures 
experiments show resulting implementation robust heap multi level bucket data structures 
new heap raman thorup heap improves time bound factor log ffl replaced log log hot queues practical radix heaps 
data structure requires bookkeeping 
addition hot queue heap usually contains fewer elements implementation takes advantage fact 
level hot queue data structure robust level hot queue usually somewhat faster 
data structure best applications 
level structure may robust large values value smaller reducing sensitivity parameters active buckets 
level hot queue may useful applications viewed robust version calendar queue data structure 
acknowledgments bob tarjan stimulating discussions insightful comments satish rao suggesting adaptive strategy switching lists heaps harold stone useful comments draft 
aho hopcroft ullman 
design analysis computer algorithms 
addison wesley 
ahuja mehlhorn orlin tarjan 
faster algorithms shortest path problem 
assoc 
comput 
mach april 
van emde boas 
design implementation efficient priority queue 
math 
systems theory 

worst case efficient priority queues 
proc 
th acm siam symposium discrete algorithms pages 
brown 
queues fast priority queue implementation simulation event set problem 
comm 
acm 
cherkassky goldberg 
heap top priority queues 
technical report nec research institute princeton nj 
available url www neci nj nec com homepages avg pub ps 
cherkassky goldberg 
shortest paths algorithms theory experimental evaluation 
math 
prog 
cherkassky goldberg silverstein 
buckets heaps lists monotone priority queues 
technical report nec research institute princeton nj 
available url www neci nj nec com homepages avg pub ps 
cole vishkin 
deterministic coin tossing applications optimal parallel list ranking 
information control 
cormen leiserson rivest 
algorithms 
mit press cambridge ma 
fox 
shortest route methods 
reaching pruning buckets 
oper 
res 
dial 
algorithm shortest path forest topological ordering 
comm 
acm 
dijkstra 
note problems connexion graphs 
numer 
math 
fredman tarjan 
fibonacci heaps uses improved network optimization algorithms 
assoc 
comput 
mach 
goldberg silverstein :10.1.1.10.9520
implementations dijkstra algorithm multi level buckets 
technical report nec research institute princeton nj 
goldberg tarjan 
expected performance dijkstra shortest path algorithm 
technical report nec research institute princeton nj 
raman 
fast algorithms shortest paths sorting 
technical report tr king london 
tarjan 
data structures network algorithms 
society industrial applied mathematics philadelphia pa 
thorup 
ram priority queues 
proc 
th acm siam symposium discrete algorithms pages 
name type description salient feature long grid grid vertices high path lengths theta vertices long wide grid grid vertices high path lengths theta vertices long random random degree path lengths theta log cycle cycle gamma results decrease key operations hard paths path vertices occupy path gamma buckets bottom level bins table graph types experiments 
number buckets level 
graph type graph family range values values long grid modifying modifying modifying wide grid modifying modifying modifying random graph modifying modifying modifying cycle modifying hard modifying table problem families experiments 
maximum arc length length width respectively grid graphs degree vertices cycle graph number buckets level 
comparison hard data set heap buckets buckets time heap ops 
time empty time empty time empty time empty act 
bucket time empty act 
bucket time empty act 
bucket table hard problems level implementation 

comparison hard data set heap buckets buckets time heap ops 
time empty time empty time empty time empty act 
bucket time empty act 
bucket time empty act 
bucket table hard problems level implementation 

