xsb efficient deductive database engine sagonas swift david warren department computer science state university new york stony brook stony brook ny cs sunysb edu describes xsb system memory deductive database engine 
xsb began prolog foundation traditional prolog systems known serious deficiencies database systems 
accordingly xsb fundamental bottom extension introduced tabling memoing appropriate underlying query engine deductive database systems 
eliminates redundant computation tabling extension xsb able compute modularly stratified datalog programs finitely polynomial data complexity 
non stratified programs properties provided 
addition xsb significantly extends improves indexing capabilities standard prolog 
syntactic basis hilog lends flexibility data modelling 
implementation xsb derives wam common prolog engine 
xsb inherits wam efficiency take advantage extensive compiler technology developed prolog 
result performance comparisons indicate xsb significantly faster deductive database systems wide range queries stratified rule sets 
xsb continuous development version available anonymous ftp 
appeared proceedings acm sigmod international conference management data pages 
language order horn clauses extended closed world negation arithmetic predicates proven elegant language data oriented problems 
making various syntactic restrictions obtains languages equivalent known database languages 
example excluding function symbols recursion constraining rules safe obtains simple domain calculus language equivalent relational algebra traditional relational databases 
relaxing restriction excludes recursion obtains datalog negation language underlies deductive databases 
logic programming efficient computational mechanism full horn clause language backtracking search tree sld refutations 
sld computational mechanism serves needs programming language clearly inadequate database computation strategy 
serious drawback terminate datalog language 
datalog decidable language reason reasonable candidate database language sld refutation finite 
lack finiteness serious problem programming language necessary property turing complete languages unacceptable database language 
problem sld tendency recompute answer 
programming context acceptable programmer responsible avoiding poor programs database context poser query expected control evaluation serious problem 
practical problem sld implementations prolog systems support indexing tended primitive 
programmer expected write programs form effectively available indexing 
prolog implementations tuple time appropriate strategy programming language usually considered useful disk resident data set time strategies deemed important 
deductive database community adopted datalog leading database query language identified problems rectified 
rewriting techniques developed introduce goal directedness bottom set time evaluation strategy 
techniques solve sld problems lack finiteness redundant computation 
interaction closed world negation recursion datalog proven major issue deductive database community significant contributions developing necessary underlying semantics 
prototype deductive database systems exemplified ldl glue nail coral designed developed incorporate advances 
mentioned systems process recursive data memory 
xsb offers alternative approach creating deductive database system 
depending rewriting techniques extends prolog sld resolution ways adding tabling evaluations finite non redundant datalog adding scheduling strategy delay mechanisms treat general negation efficiently 
resulting strategy called slg resolution complete finite non floundering programs finite models stratified 
xsb engine currently implements version slg restricted left right modularly stratified programs 
meta interpreter provided evaluate programs founded semantics equivalently valued stable model semantics program 
xsb query engine extension wam warren machine 
developed prolog technology take advantage advanced techniques efficient compilation 
xsb evaluates stratified queries faster current bottom program atom truth proven making call non ground negative literal 
implementations claim substantiated section 
significant difference xsb implementation conventional deductive database implementations xsb tuple time evaluation strategy 
gives advantage object oriented applications information kept complex terms distributed relations 
addition syntax hilog extended prolog operators offers useful means knowledge representation object schemas 
hilog predicates fully compiled slg wam instructions execute marginally slower traditional prolog predicates 
advantage top approach xsb efficiency relies rewriting techniques alternate control strategies usual bottom approaches 
allows xsb maintain operational interpretation program elegant manner prolog relying user knowledge interpretation avoid infinite loops redundancy 
addition declarative language features xsb offers flexible indexing efficient mechanisms link xsb modifiable backing store 
xsb offers hash wam style indexing alternate arguments tuple combinations arguments 
implements original indexing technique called transformational indexing stores parts clauses non deterministic discrimination network 
xsb offers fast dynamic compilation linking dynamic code 
version xsb tested dozen hardware operating system platforms databases relations order hundreds thousands tuples 
available anonymous ftp cs sunysb edu 
intended overview xsb lesser extent slg resolution widely known 
give pointers papers provide fuller treatments slg hilog xsb performance topics 
briefly discussing related presents overview slg derivation section 
main body section provides overviews functionality hilog syntax slg wam xsb indexing performance results reported section 
related table summarizes aspects deductive database systems developed 
table adapted provides wider comparison 
name evaluation syntactic restrictions negation data requirements magic sets datalog mod 
strat disk resident coral magic templates order mod 
strat 
main memory ldl magic sets order mod 
strat 
main memory glue nail magic rewriting restricted hilog extensions founded main memory inferencing datalog stratified disk resident xsb slg hilog optimisations founded main memory table deductive database systems xsb systems table extension magic set approach 
seki proves programs negation top resolution method currently sparc mips intel motorola ibm rs chips tested operating systems sunos solaris irix ultrix linux bsd dos hp ux system sco unix mach tested 
asymptotically bottom method alexander templates 
number technical details need worked order seki result compare slg definite programs magic templates 
similarities methods striking 
instance magic facts magic template method appear correspond tabled subgoals slg evaluation 
terms syntax table describes systems allow functions arguments non range restricted queries order 
interesting note glue nail provides restricted hilog functionality outer functor predicate datalog term general order term 
instance term allowable glue nail xsb 
glue nail xsb able evaluate programs founded semantics fall back interpretive techniques non stratified negation 
able manipulate disk resident relations including xsb need copy relations main memory 
mentioned xsb slg precludes tabling non recursive predicates computed externally database system 
extension xsb evaluate queries datasets large main memory active sets queries fit memory 
active set recursive query fit main memory efficient evaluation open problem slg magic evaluation 
table classify various systems basis treatments sets aggregation 
ldl coral allow sets objects universe hilog systems glue nail xsb terms names sets negation construct predicates set equality subset checks operations 
approach discussed section 
differences reflected table 
systems automatically optimize programs queries lines traditional database systems task xsb 
xsb thought engine optimizations literal reordering index selection implemented 
implication results section optimizer added xsb relatively straightforward manner due termination properties slg 
final distinction xsb code compiled lower level usual database systems 
section clarifies distinction provides performance comparisons xsb systems table 
slg evaluation slg resolution evaluation strategy underlying xsb system called slg resolution uses memoing evaluate general logic programs 
details slg evaluation scope give short summary important features slg 
definite programs slg reduces sld resolution memoing 
call selected subgoal check variant subgoal previously called evaluation 
subgoal copied global table program clauses resolved subgoal exactly sld 
evaluation subgoal completely resolved away corresponding answer instance copied back table 
time call variant subgoal previously called subgoal resolved answer clauses table 
evaluation completed program clauses answer clauses resolved applicable subgoals 
answer clauses may created course evaluation uses resolving called subgoal answer clause may lead generation answer clause resolved subgoal 
evaluation may seen sort fixpoint computation 
subgoals evaluation converged fixpoint termed completely evaluated 
programs negation stratified slg suspends evaluation necessary guarantee subgoals lower strata completely evaluated negations required 
strategy gives slg polynomial data complexity datalog programs negation 
non stratified programs require complex handling negative subgoals stratified programs 
slg non stratified programs delay calls negated subgoals 
delaying literal corresponds temporary assumption undefined founded model 
delayed literals show conditions answers table 
delayed literal may false true case simplified away simplification may lead answers 
case subgoal proven true false may cyclic dependencies delayed subgoals set subgoals 
case subgoals delays eliminated truth value unknown founded semantics 
fact answer clauses answers conditioned delays seen constituting transformed program sets valued stable models computed explained 
implementation slg similarity slg sld definite programs natural ask slg meta interpreter preprocessor written prolog sldnf 
meta interpreter written speeds turned unacceptable general programming 
preprocessor transforms program prolog program evaluates slg strategy expected better efficiency fixpoint nature slg strategy difficult 
effect strict backtracking nature prolog search broken branch sld search tree suspended branches searched resumed 
interpreters preprocessors try compute slg oldt needing computational mechanisms natural wam result performance suffers 
slg wam contains wam extensions efficient evaluation slg roughly times faster meta interpreter running similar emulator 
separate memory area table space added wam table manipulation routines added copy derived answers slg wam program stacks table space back 
associated discuss extensions detail 
slg wam execute prolog sld resolution incurs minimal overhead 
small overhead due complex trailing testing involving memory pointers 
comparisons slg wam psb prolog derived indicate slg wam usually slower psb prolog wam faster 
prolog system sld xsb runs bit slower emulated sicstus standard benchmarks times slower quintus 
practical matter existential negation provide alternative behavior slg programs explained 
current implementation limited stratified programs detailed design begun full slg wam 
comparison fact numerous improvements emulator course implementing slg wam preparing xsb release 
xsb engine section presents aspects xsb deductive database programmers users 
aspects include hilog syntax novel high level mechanisms control evaluation tabling declarations table cut different operational models negation 
addition discuss traditional deductive database features indexing interfaces features set manipulation 
syntax xsb syntax hilog 
hilog provides higher order syntax logic programs allowing arbitrary terms occur functor term predicate symbol atom 
example bob formed hilog term 
hilog terms encoded order logic family apply function predicate symbols 
full development sketch intuition 
briefly hilog term arity encoding uses apply symbol arity argument apply encoding functor remaining arguments encodings arguments hilog term translate term apply bob 
encoding provides order semantics hilog 
precise language countably infinite set variables countable set logical symbols set hilog terms minimal set strings alphabet ffl ffl 
xsb consists prolog constants integers consists prolog variables 
examples hilog terms xsb terms parent john mary parent mary 
logically order terms simply subset hilog terms operationally compiled somewhat efficient code 
terms john parent mary functors deduced hilog functors compiled accordingly 
terms functor constant possible determine taken hilog functors order functors 
xsb design decision require explicit declaration hilog constants 
hilog 
declares appears functor predicate position read hilog symbol appropriate translation done 
example term read apply 
section discuss hilog implementation xsb 
xsb fact simply hilog term followed period 
hilog terms section define database facts 
rules xsb define logical predicates 
full xsb syntax described 
proper hilog rule clause form term literal atom hilog simply hilog term negation atom term 
convenience xsb integrates prolog ability define operators hilog syntax 
architecture top level architecture xsb shown 
components coded drawn predicates system interpreter programs user compiler engine interface system functions user programs overview xsb architecture boxes coded hilog drawn circles 
hilog programs compiled byte code object files loaded executed slg wam emulator written loading byte code files done dynamically run time needed 
system code compiler routines underlying xsb written mixture hilog system user code interface essentially causes engine trap calls functions relinquish control 
platforms code dynamically linked just hilog code 
simplicity architecture allows structure system easily understood extensions easily 
xsb normally invoked read eval print loop interpreter directly execute compiled user programs 
direct execution object files allows programs written xsb execute directly shell unix dos xsb compiler assumes predicates static change execution defined rules facts mixture 
compilers unsuitable handling large amounts data 
alternate compilation xsb provides dynamic predicates code modified execution 
extensional database normally stored dynamic predicates 
facts rules asserted time retracted time clause level predicate level 
xsb implementation static code fully compiled take full advantage dynamic code compiled uses simplified compilation method order faster 
dynamic clause compiled defined rule single literal body 
result dynamic database facts identical representation compiled facts execute essentially speed 
section discuss interfaces dynamic predicates backing store 
xsb supports grouping predicates modules 
module system permits encapsulation allowing terms predicates structures constant symbols hidden imported exported 
module systems logic programming predicate 
xsb large amount data currently means files lines code 
complication treatment indices dynamic clauses currently support hash indexing static clauses support hash transformational indexing 
module system term believe presents coherent way structure hilog programs 
module system compiler number ways import declarations provide information allow dynamic loading predicates module declarations define scoping number declarations described sections 
declaring predicates tabled mentioned section predicates xsb executed sldnf default declared tabled predicate basis 
alternative system decide predicates table declaration 
causes compiler table predicates avoid infinite loops due redundant calls 
determining precisely predicates need tabled predicting particular goal repeated path sld tree undecidable general 
version table simplicity speed chosen refinements precision algorithm 
intuitively table constructs call graph chooses table predicates ensure loops broken 
may happen table chooses predicates 
happens user specify explicitly table alternatively separate definitions offending predicates module scope table declaration limited module 
cuts negation prolog implementation sld tuple time strategy means tuples relations produced demand tuple time 
computation may avoided aborting generation tuples predicate computation assuming remainder tuples desired 
computational savings may significant terminating tuple generation predicate terminates tuple generation predicates computation 
prolog cut operator 
allows programmer specify early termination 
cuts course changes semantics programs 
prolog programmers depend efficient implementation conditional operator exemplified definition simple predicate transform null values null date unknown 

transform null joined relation determines argument clause matches result date unknown returned second field cut indicates answers 
clause match second clause simply returns argument 
case single tuple appear relation transform null 
example cut prolog definition 
consider definition fail 

assuming joined relations way arguments bound safe tuple cut indicates answer needed fail predicate causes computation immediately fail indicate false 
false cut executed second clause 
height xsb def 
slg xsb sldnf xsb neg table comparisons slg implementations complete binary trees crucial point defined number relations cut executed close computation relations possibly leading significant computational savings 
effects cuts obtained set time framework choice operators 
discussion prolog cut relevant slg resolution tuple ata time strategy 
context tabling cut complicated 
problem may arise tabled predicate occurs scope cut 
cut indicates current user table doesn desire tuples may case users table 
case closing table time result incorrect answers 
general predicates tabled completely evaluated order insure complete correct answers 
fact xsb compiler give error static analysis program shows cut close partially computed tabled predicate 
dynamically determined table subgoals depending may inadvertently affected cut 
ancestors table scope cut ancestors cut table safely deleted 
accordingly version xsb contains operator checks tables scope cut safely freed frees 
simple noop 
xsb types negation evaluating modularly stratified programs slg slg negation existential negation 
difference basically slg negation completely evaluates tables existential negation uses delete tables finding answer positive subgoal generated negative literal safe 
types negation guarantee correctness modularly stratified programs radically efficient depending context 
example existential negation efficient slg negation consider known game example consider program win move win 
win modularly stratified iff move acyclic 
table shows times evaluating program complete binary trees varying height slg negation sldnf prolog existential negation 
times normalized time existential negation 
note ratio times existential negation sldnf essentially constant relative time slg negation increase depth tree increases 
see slg evaluation worse sldnf consider calls sldnf query win binary tree height nodes 
calls represented circled nodes 
sldnf checks existence solution negative subgoal possible subgoals evaluated sldnf general execution win binary tree grows proportionally sldnf exact formula gamma gamma 
calls win binary tree existential negation differs slg default cuts away goals created negative context fully evaluating 
subgoal created negative context reused existential negation slg results exactly nodes visited sldnf cases existential negation 
possible existential negation delete tables needed 
case existential negation result slower execution times 
datalog programs existential negation slg negation cause exponential increase amount 
determined tables default slg negation 
indexing traditionally prolog systems index main symbol field relation clearly inadequate database applications 
database applications require multi field indices multiple distinct indices single relation 
recall xsb kinds predicates static predicates change processing reloaded entirety dynamic predicates modifiable execution 
xsb supports different kinds indexing different types predicates 
dynamic predicates xsb supports various indexing options hashing main symbol field 
default hashing argument 
declarations may indicate desired options 
indices constructed field set fields size 
number distinct indices predicate supported 
addition hash table sizes specifiable 
take example dynamic predicate index declaration index 
cause indices maintained retrieval index argument ground second ground third fifth combined 
static predicates compiler accepts declaration indicates field hash index constructed 
alternative hash indexing version xsb offers transformational indexing static predicates 
transformational indexing novel technique uses sequence folding unfolding operations construct non deterministic indexing automaton compile time 
transformational indexing discussed fully separate compares quite favorably techniques time simpler implement 
example consider predicate 



compiled transformational indexing 
mode transformational indexing factors structure indexing argument factors structure indexing terms automaton produced seen sequential trie leaf nodes correspond input clause heads furthermore occur order 
var var trie transformational indexing default indexing compiled predicates hash 
number clauses known compiler chooses optimal hash table size 
user provide declarations invoke transformational indexing single predicates predicates module 
addition indices user predicates uses indices processing tables generated engine index call patterns find quickly call previously index answers determine quickly new answer duplicate previous answer 
indices tables important reasons ffl answer clauses need indexed check duplication 
answer duplicate answer exists table call path leading failed way duplicate computation avoided 
answer added eventually resolved calls tree variants answer resolution 
ffl tabled subgoals require indexing action taken subgoal depends previously called evaluation 
subgoal indexing xsb uses simple argument hash index 
answer clause indexing xsb uses hash index includes arguments answer 
cases xsb user may specify size hash table explicitly override default 
currently way improve indexing xsb 
new implementation variant string indexing development allow efficient apply variables indexed clauses 
trie indexing currently developed answer clauses tables 
index integrated actual storing answers decrease space time necessary saving answers 
interface persistent store xsb compute directly disk efficient mechanisms bulk communication backing store especially important 
xsb provides interfaces ascii text files object files 
code part xsb database read originally ascii file partially compiled dynamic code 
dynamic code loaded unloaded system time updates dynamic code assert retract 
development xsb allow dynamic code backed object file user specified point 
ascii data read general reader handles operators arbitrary hilog terms 
generality terms read default ascii reader slower database readers usually takes milliseconds simple terms 
database applications case data files highly structured require sophisticated parsing 
read files xsb provides formatted read allows read assert fact millisecond sparc including simple index maintenance 
time roughly equivalent data load times deductive database systems 
static code translated xsb compiler object files contain slg wam bytecode 
object files contain precompiled code loading object file faster loading formatted read assert 
currently object files supported static code 
extending object files dynamic code allow loading data time roughly equivalent time commercial databases require bulk loads followed index 
intelligent management large segments data disk remains research topic xsb memory resident deductive database systems 
xsb reclaim space allocated tables entries completed compromising correctness 
space reclamation may compromise efficiency 
hilog sets section describe briefly hilog implemented xsb system manipulate sets 
xsb implements hilog translation order form applying source level optimizations compiling optimized order form 
translation simply wraps arguments hilog term symbol apply treating term functor position argument 
fragment table path 
path 
path path 
hilog 



encoded table apply path 
apply path apply 
apply path apply path apply 
apply 
apply 
apply 
apply 
note transformed program compiled prolog program 
problem may efficiency 
address efficiency issues note obvious problem nrev query path map hilog hilog specialised prolog table normalized performance hilog indexing solved xsb transformational indexing 
discrimination graph fragment shown essentially union graphs predicates fragment 
var var apply path hilog discrimination graph clearly hilog brings little overhead overhead introduced path may significant 
fact xsb optimises predicate automatically performing source code transformation path compile time specialization known calls hilog predicates 
example path predicate apply path 
table 
apply 
apply 
form path predicate efficient written firstorder syntax minimal overhead extra argument predicate generic 
table provides performance results sets example programs 
set consists naive reverse prolog benchmark nrev database program query searches populations areas find countries approximately equal population density 
second set benchmarks path map programs compares generic higher order versions transitive closure maplist predicate non generic versions predicates base relation hard coded 
example generic transitive closure predicate path right recursive tabled non generic transitive closure follows hilog symbol 


took form chain 
table presents relative times hilog encoded programs specialization 
hilog syntax provides elegant way construct manipulate sets 
recall complex term predicate symbol 
term represent predicate set arity 
example database package required 
package optional 
package required 
package optional 
package optional 
benefits john package 
benefits bob package 
term package denote set john benefits 
benefits set binary tuples indicating type benefit optional required 
query benefits john 
binds name set john benefits package retrieves tuples describe benefits explicitly 
simple representation extended include set intersection union 
example represent intersection union sets binary tuples term intersect union define extension follows intersect 
union 
union 
find common benefits john bob benefits john benefits bob intersect 
set functions set membership set equality defined correspondingly simple manner 
see examples 
hilog order semantics certain second order functions count sum hilog tabling compute 
solve problems xsb offers findall bagof setof defined prolog 
xsb includes extension findall slg predicates called 
findall called slg predicate subgoal completed capture solutions incomplete list answer clauses 
avoid problem suspends table completed 
assumption programs stratified correct answer computed just case negation 
xsb performance detailed comparisons deductive comparisons complete systems publicly available directly comparable 
case glue nail publicly available comparisons provided published times certain queries 
multi user system allows direct computation disk resident data comparisons single user system memory resident queries pointless 
ldl presents comparison coral ldl indicates simple queries coral usually significantly faster ldl assessment largely echoed 
result comparisons section primarily coral include supporting information glue nail ldl performance appropriate 
section summarizes results detailed includes range restricted datalog queries queries involving functions non range restricted queries negation 
simple range restricted datalog program path edge 
path path edge 
path fail 
edge predicates form edge 
edge 
edge 
serve initial basis comparison xsb coral 
indicates time needed iterate times cycles length length 
range data structures reflect limitations xsb coral handling larger relations 
elements cycle xsb coral def coral fac xsb coral cycles xsb times appear order magnitude faster coral times 
figures lines labeled coral def denote times coral default settings coral fac denote times factoring option turned 
noted memory management indexing coral somewhat sophisticated xsb comparisons factors account small percentage speed difference 
argued comparison potentially unfair bottom algorithm returns single answer iteration path evaluated chain 
leads bias favor tuple time evaluation xsb set time evaluation coral 
account bias second comparison fanout structures form edge 
edge 
edge 
trivial data structures answers iteration bottom fix point called path 
results shown indicate coral xsb ratios data structures similar ratios cycles 
generally similar ratios hold xsb compared coral linear right recursive path predicate double recursive path predicate generation program program win move win 
program property modularly stratified iff move acyclic 
results indicate xsb order magnitude faster coral program 
glue nail published results provide preliminary means compare performance xsb win 
provides numbers indicate xsb engine may faster glue nail modularly stratified programs xsb number leaves xsb coral def coral fac xsb coral fanout structures meta interpreter run quintus prolog comparable glue nail stratified non stratified programs 
alternative datalog programs tests coral xsb performed append top techniques sld xsb pipelining coral bottomup techniques slg various compilation options coral 
version xsb table copy optimizations ground structures complete 
result slg quadratic query 
expected sld fastest approaches 
pipelined coral faster slg lists length greater coral compiled bottom suggested optimizations faster slg lists length greater 
versions xsb include table copy optimizations ground structures 
non ground lists xsb quadratic length list coral quadratic number variables list 
fuller analysis results able 
hypothesize reason xsb efficiency deductive database applications compilation relatively low level slg wam code interpretive code deductive database systems 
partially substantiate claim consider time needed join relations xsb quintus prolog ldl coral sybase 
table gives approximate relative times indexed join various systems 
data ram control unix sybase system buffer 
sybase uses fundamentally different paradigm systems sybase optimized memory resident queries sybase special provisions concurrency recoverability 
wam oriented systems fastest problem quintus times faster xsb due fact quintus written directly assembler 
results indicate usefulness separating concurrency query engine advantages specialized indexing techniques memory resident queries 
quintus xsb ldl coral sybase table approximate relative join speeds clearly join times table indicate factor xsb efficiency engine relies fact data rules fully compiled 
xsb executes restricted slg speed compiled prolog seen comparing path predicate right recursive sld form edge predicates representing binary trees chains 
prolog evaluation linear queries chain tree contains redundant path 
left recursive slg derivation takes nearly time sld chain tree longer course terminate presence cycles 
similarities speed chain especially significant slg times include time taken copy answer clauses table space reclaim table space iteration 
instruction profiles indicate xsb spends majority time wam instructions new slg wam instructions 
hypothesize xsb faster datalog programs wam refined execution model available set atime 
set time evaluations doubt efficient 
creation execution model level wam prove difficult best wam depends fundamentally tuple time strategy 
furthermore prolog evaluation progressed wam 
optimizations native code generation mode analysis may bypass wam heavily predicates shown give order magnitude improvement certain problems 
number datalog optimizations recursive selection projection pushing factoring xsb currently employ 
unreasonable expect full implementation techniques way lead significant speedup execution time version xsb 
deductive database systems address declarative procedural issues glue nail different languages ldl coral integrate tuple time pipelined mode set time default 
xsb approach maintain tuple time strategy extend bottom slg expressive syntax hilog 
performance measurements displayed previous section may provide strongest evidence viability approach 
advantages approach rich proven environment prolog included xsb tight efficient coupling procedural declarative aspects 
half decade research advanced database languages distinct branches object oriented deductive databases 
case fundamental computational distinction object oriented databases strategy analogous tuple time traditional deductive databases set ata time strategy bottom engines 
approach xsb uses tuple time strategy bottom engine indicates possibility true integration 
acknowledgments authors express chen major contributions slg evaluation steve dawson implemented transformational indexing 
xsb benefited involvement kate silva suggestions ramakrishnan research group 
users helped port code reported bugs fixed 
chen ramakrishnan ramesh 
multistage indexing algorithms speeding prolog execution 
proc 
int conf 
symp 
logic programming pages 
chen kifer warren 
hilog foundation higher order logic programming 
logic programming 
chen swift warren 
efficient implementation general logical queries 
logic programming 
appear 
chen warren 
computation stable models integration logical query evaluation 
ieee transactions knowledge data engineering 
appear 
chen warren 
effective evaluation general logic programs 
technical report suny stony brook 
shortened version appeared proceedings th pods 
krishnamurthy naqvi tsur zaniolo 
ldl system prototype 
ieee transactions knowledge data engineering 
morishita 
design implementation glue nail database system 
proc 
sigmod conf pages 
acm 
hsu zaniolo 
new user impressions ldl coral 
technical report ilps workshop programming logic databases 
morishita 
alternating fixpoint tailored magic programs 
proc th pods 
naughton ramakrishnan sagiv ullman 
argument reduction factoring 
proc 
th int conf 
large data bases pages 
vldb 
przymusinski 
founded semantics coincides valued stable semantics 
fundamenta informaticae 
ramakrishnan srivastava sudarshan 
coral control relations logic 
proc 
th int conf 
large data bases pages 
vldb 
ramakrishnan ullman 
survey research deductive database systems 
journal logic programming 
appear 
ross 
modular stratification magic sets datalog programs negation 
proc 
th pods pages 
sagonas swift warren 
xsb programmer manual 
seki 
power templates 
proc 
th pods pages 
acm 
swift warren 
xsb performance measurement 
technical report suny stony brook 
swift warren 
machine slg resolution definite programs 
proceedings symposium logic programming pages 
ullman 
implementation logical query languages databases 
acm transactions database systems 
kemp somogyi stuckey 
design overview deductive database system 
seventh int conf 
data engineering pages 
van gelder ross schlipf 
founded semantics general logic programs 
jacm 
van roy 
prolog 
ieee computer 
walker 
iteration practical inference method simple proved terminating sound complete 
automated reasoning 
warren 
memoing logic programs applications partial deduction 
communications acm 
warren 
prolog instruction set 
technical report sri 
