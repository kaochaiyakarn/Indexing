power languages manipulation complex objects serge abiteboul le chesnay cedex france serge abiteboul inria fr beeri department computer science hebrew university israel beeri huji ac il december various models languages describing manipulating hierarchically structured data proposed 
algebraic calculus logic programming oriented languages considered 
presents general model complex objects languages paradigms 
algebraic language generalizes literature shown related functional style programming advocated backus 
notion domain independence familiar relational databases defined syntactic restrictions referred safety conditions calculus queries formulated guarantee domain independence 
main results domain independent calculus safe calculus algebra logic programming oriented language equivalent expressive power 
particular recursive queries transitive closure expressed languages 
result algebra needs powerset operation 
restricted version safety restricted safe calculus equivalent algebra powerset 
results extended case arbitrary functions predicates languages 
research supported national council research development israel association franco pour la recherche scientifique 
normal form restriction forces components tuples relational databases atomic 
decade widely recognized restriction imposes unacceptable constraints database technology variety application domains engineering computer aided design office systems 
models incorporate semantics databases introduced studied 
mid variety models generalized relational model allowing hierarchically structured data nested relations complex objects models :10.1.1.45.8055
decade emphasis shifted semantic particularly object oriented models 
models support features object identity modelling behaviour encapsulation isa relationships 
extension model object oriented features 
variety languages proposed models encompassing known paradigms query languages algebraic calculus logic programming oriented 
variety features operations languages quite confusing 
commonly agreed approach design query languages generalization known paradigms new models 
goals improve understanding issue 
overview results compare query languages model complex objects 
values obtained atomic ones set tuple constructors 
restrictions placed order application constructors depth constructed objects 
model lacks features object identity behavior modelling 
believe complex structures important component object oriented semantic models languages allow access structures important worthy study 
consider calculus language similar proposed jacobs algebra logic programming language similar 
note word object complex object refer notion object known object oriented database models 
particular objects identity distinct values 
essentially composite values 
main results concerning languages ffl show classical equivalence domain independent calculus algebra valid model 
ffl domain independence semantic undecidable property 
consider syntactic restrictions guarantee domain independence 
syntactically restricted formulas called safe 
result algebra safe calculus equivalent 
implies particular syntactic restriction captures semantic notion domain independence 
ffl algebra equivalent calculus include powerset operation generates subsets set 
expensive operation output size may exponential size input 
allows express queries computed polynomial time size database 
interesting characterize power algebra powerset operation 
restricted notion safety prove calculus restricted corresponds algebra powerset characterizing power algebras literature 
ffl known simple recursive queries transitive closure expressed relational calculus 
hold languages turns algebra safe domain independent calculus language complex objects recursive rules equivalent 
follows powerset algebra equivalently unrestricted calculus 
expressing recursive queries powerset leads un intuitive resource consuming computations indication powerset included 
addition technical results described tried address issue generalizing linguistic paradigms new models 
believe approach issue contribution theorem 
describe briefly 
interested generalizing relational model allow structure represented directions go 
may generalize notion tuple allowing complex type constructors construction elements stored database collections 
may include tuple set list array orthogonality principle implies able constructors order 
second may allow arbitrary atomic domains arbitrary collections functions predicates 
database users allowed define types database 
additionally add features object identity behavior considered 
important consider directions 
particular ability construct generalized tuples important means structure user interested defined terms constructors part data model known database system 
storage structures access paths structures domain database system efficient organization access optimization possible 
needs users anticipated captured set constructors important allow arbitrary data types arbitrary operations stored manipulated 
consider directions bulk concerned 
basic idea classical language paradigms viewed linguistic frameworks accept arbitrary type systems parameters 
regarding direction complex object model generalizes relational model allowing set tuple constructors recursively applied 
type constructor equipped operations predicates specific 
typically include constructors selectors 
example tuples records tuple construction constructor selection attributes selectors 
sets membership predicate plays role selector 
additional useful operations predicates normally included 
approach consider collection operations predicates type constructor 
classical languages extended adding operations predicates 
approach emphasizes orthogonality notions minimality set operations 
model set tuple constructors approach clearly applies constructors model languages easily generalized include constructors 
furthermore languages designed assumption underlying atomic type functions predicates types freely 
second direction taken care 
main results apply general setting restrictions see section 
generalizes example results 
approach works smoothly calculus logic programming paradigms 
algebra effort needed 
include operations allow describe explicitly quite complicated restructuring complex objects 
obtained essentially compositions type specific operations 
needs operations manipulate collections elements combine various ways apply restructuring functions 
relational model classical relational algebra operations 
model adapted change relational model particular deal restructuring generalized 
added operation help restructuring generalization emphasizes view algebra functional language relies notion higher order operations generalization classical operations 
issue considered dual nature set constructor model 
hand sets organize database traditionally view database vector named collections 
algebra operations tailored manipulation collections 
set constructor construction elements need set operations manipulation elements contain set components 
approach allow algebraic operations sets 
algebra recursive language algebraic operations nested 
nesting operations queries allows deal straightforward manner nesting database values 
emphasis algebra composition selected higher order operations closely related research query languages bulk types uses framework particular notions monads comprehensions see monadic algebra 
comprehensions viewed pure form generalized sql paradigm considered 
see section discussion 
comparison previous model generalizes non normal form relational models 
objects deal seen objects resulting semantic database modeling aggregation tuple constructors classification operation powerset added need felt algebra algebra expressive calculus 
mentioned believe practical purposes opposite approach adopted calculus restricted expressive algebra powerset 
set constructors 
sets homogeneous objects considered 
respect data structure study strictly weaker considered believe results easily extended heterogeneous sets allowed 
types described trees objects values 
cycles allowed type definitions 
note model objects identities cycles allowed query result defined expression applied object set contains conditions object objects values reachable attribute application satisfy 
objects values reachable object form virtual tree 
languages applied models 
equivalence results algebraic calculus languages 
equivalence relational algebra calculus aggregates considered extended relations set valued attributes 
comparison proposed non normal form relational model 
chosen restrict case nest unnest operators commute equivalence proof uses unnest reduce problem case flat relations nest restore original relations 
introduce algebraic operators access set valued components tuples 
nest unnest general commute need operations algebra need direct proof 
equivalence result different sense general model objects identities cycles allowed kv 
characterizations syntactic safety comparison recursive languages new 
equivalence results obtained presence interpreted functions predicates new 
model slightly general 
allow nested structures internal nodes sets leaves relations 
extend results concerning completeness query languages model 
techniques extended model completeness languages sense treated 
results completeness model see 
languages strictly powerful relational calculus 
mappings relations relations defined languages expressed relational calculus 
consequence ability manipulate richer structures temporary results 
particular powerset operation allows increase set height values 
hull su exhibit hierarchy languages restrictions types intermediate results 
main technical results included previous unpublished version 
current differs version important respect approach described extending existing languages new models 
consequences particular algebra 
algebras literature wide variety operations differ quite lot restructuring problem tackled 
algebra simpler previous version believe provides understanding operations essential operations general algebra 
additional consequence simplicity proofs major results simpler better structured 
minor errors earlier proofs corrected 
organization organized follows 
section data model section define databases functions queries 
calculus introduced section algebra section 
section deals equivalence algebra domain independent calculus 
section introduce syntactic safety restrictions calculus compare power resulting languages algebra powerset 
section arbitrary functions predicates introduced algebra calculus 
section deals recursive queries 
summary section 
complex types values relational model instances sets tuples 
basic constructors set tuple constructors construction type relation schema precisely tuple constructor set constructor 
nested relational model constructors required alternate type 
extend model removing restriction requiring set constructor 
assume existence set domain names infinite set names called attributes types structure definitions domain names set tuple constructors attributes 
assume domain names associated domains nature elements domains irrelevant 
frequently omit domains type value definitions 
examples integers 
naturally collections domains equipped operations functions map domain domain 
disregard domain specific functions consider functions operate tuples sets basic building blocks model 
domain specific functions treated section 
elements domains called atomic values 
complex values constructed atomic elements constructors 
type associated value obvious way value instance type formally types values defined follows 
domain name atomic type 
value type 

types distinct attributes tuple type 
values types resp value type 
include type 
value type empty tuple 

type ftg set type 
finite set values type value type ftg 
types values viewed trees 
type tree leaves labeled atomic types value tree leaves labeled values 
internal nodes labeled cases constructors 
tuple constructor includes sequence attributes edges outgoing tuple node labeled attributes 
type tuple set respectively constructor root tree atomic tree consists single node 
tuple types defined record types component attribute label 
allow unlabeled tuples assuming unlabeled tuple implicitly labels labels confused integers example specific domain 
distinction clear context 
statement type assumes assignment domains domain names 
assume unlabeled tuple length element 
identify attributes serve selectors functions select components tuples assumption implies function identity function defined domain 
assumption commensurate definitions tuples literature simplifies arguments sequel type different domain names domains 
set values type contain values leaves type denoted dom alternatively defined follows 
replace definition tree leaf labeled 
replace labels internal nodes follows tuple constructor replaced labeled cross product operator set constructor replaced finite powerset operator 

evaluate tree 
note set values independently domains 
variations principal variation structure nested relation core nested relation model 
nested relations type complex object set type set tuple constructions alternate 
instance types nested relations 
observe adjacent tuple constructions set constructions second 
readability notation id identity function 
restriction imposed structure nested relations 
fundamental limitation considered describes data structure language verso system 
nested relations set tuple constructors alternate 
relation defined recursively set tuples component may relation atomic 
type acceptable verso relation type intermediate set construction contains tuples atomic attribute 
assumption verso model verso instance set tuples atomic attributes form key 
observe implies cardinality set verso instance bounded polynomial number atomic elements occurring instance 
bound certainly apply nested relation type essentially set sets 
databases queries database scheme pair db set types involving domain names instance db structure db domains value dom 
refer db database type db database value called relation 
query signature db set type partial function instances db instances db input output types query 
db obvious context may refer type query 
assume domain names db 
assumption set type follows accepted convention database systems models query returns set values 
result applying query database instance db denoted db 
query language notation expressing queries coupled mechanism assigning meaning expressions associating queries expressions 
concerned known paradigms query languages calculus algebra rule deduction 
general value db query may depend relations say query domain independent database structure changing domains keeping large contain atomic entries appearing database relations query change result query 
known expressions relational algebra assuming complement define domain independent queries 
holds algebra 
calculus formulas necessarily define domain independent queries 
domain independence semantic property defined terms structures known undecidable classical relational calculus 
holds calculus contains relational calculus 
relational calculus exist syntactic restrictions guarantee domain independence limit expressive power 
consider syntactic restrictions prove similar result 
introduce languages comment important issue needs dealt 
important class operations complex values absent relational model perform restructuring changing structure member set 
restructuring defined function applied member set 
relational projection operation restricted special case 
call queries function applied element set restructuring filters 
relational selection illustrates type filter predicative filter predicate applied element set 
elements value true output unchanged ignored 
relational model elements flat tuples restructuring limited adding deleting fields tuples 
model elements set may particular type result restructuring may quite different type 
able express interesting queries need able express functions possibly complex input output types 
presenting languages place special emphasis explaining mechanisms expressing functions 
quite rich class functions relatively powerful functional language may needed possibly version lambda calculus 
approach illustrated show languages consider functions expressed resorting formalism preserving traditional database approach 
domain names appear signature queries 
complex values calculus section calculus query languages 
language subsection 
variations language considered second subsection 
calculus calculus essentially standard order sorted calculus 
sorts types defined section 
domain names atomic types non atomic types constructed tuple set constructors 
customary sorted calculi constant variable associated sort type functions predicates associated signatures 
ary predicate signature tuple types ary function tuple types 
database languages functions predicates generic families functions predicates indexed types 
types constants variables signatures functions predicates usually omitted irrelevant inferred context 
terms language defined usual smallest set contains atomic constants variables closed application functions 
functions language tuple set constructors attributes considered unary functions tuple values 
just mentioned parameterized families functions 
attributes types ary constructor tn term obtained applying terms type respectively tn 
customary database literature denote 
types irrelevant known denote constructor refer generic constructor attributes omitted 
similarly type constructor fg standard notation term obtained applying constructor terms type denoted ft indexes omitted 
constructors type parameter 
case obtain empty tuple type emptyset type 
term tuple type component term 
notation viewed unary function 
notation customary database area 
language atomic constants constructors selectors 
construct ground terms denote non atomic constants 
convenience standard abbreviations 
predicates applied terms proper type restrictions yield atomic formulas 
set predicate includes names database relations 
includes binary predicates equality membership set containment 
formulas obtained atomic formulas applications connectives quantifiers 
follows database scheme db defines language domain names type expressions predicates relation names 
consider semantics language 
interpretation database instance scheme defined section mapping assigns domains names sets values appropriate types domains non atomic types interpretation defined section domain tuple type labeled cross product domains component types domain set type obtained applying finitary powerset operation domain element type 
note differs usual definition interpretations sorted calculi domains sorts arbitrary 
treat tuple set type constructors having fixed predefined meaning 
domains non atomic types determined atomic types 
furthermore tuple set constructors interpreted functions map elements tuple set constructed attributes interpreted selectors tuples functions interpreted fixed way 
built predicates standard interpretation 
identify scheme instance language interpretation respectively 
db instance db 
type uses domain names choice interpretation db implicitly assigns range variable type dom defined section 
interpretation assigns distinguish equality language formulas equality metalanguage expressing syntactic equality formulas 
meaning quantifiers truth values formulas defined standard way 
truth value associated formula free variables assigned value domain 
note definitions types truth value formula depends values assigned domains assigned domains determine ranges variables 
standard approach 
formula defines query databases follows 
query expression fx free variables 
list free variables called target list query 
types query expresses mapping instances db instances follows db db defined db type db identify query formula write db db 
example illustrate expressive power calculus 
particular show composition queries expressed calculus express restructuring filters queries transform element set value type 
example consider schema dg domain omitted brevity 
queries 
union set constant tuples fr 
select tuples component member second component fs free variables included target list suffices principle write formula 
notation extended adding attributes name components 
tuples legal types principle restrict attention formulas free variable 
note formula contains free variable convention component tuples definition written db fv type db 
classical cross product ft type fg 

join express query composition cross product expressed selection 
denote formula describing cross product write query expressing selection predicate type ft ft bg replace query ft bg ft bg 
flatten produce set flat tuples contains component tuple elements second component 
known unnest operation ft type 
note conjuncts formula viewed formula free variables expresses relation domains domain prefixing transformed restructuring filter 
note filter creates tuple set tuples result union 
expresses relation function 

powerset relation ft rg type 
collection subsets second component tuples contain values ft part formula expresses relation composing existential quantifier produces required filter 
summary example shows compose queries connecting output query input 
technique generally applicable 
fact subformula form replaced formula 
technique illustrated example combine formula free variables representing relation create restructuring filter query 
generally applicable technique 
techniques allow calculus express algebra expressible queries 
considered prove equivalence languages 
recall definition domain independence previous section 
queries domain independent 
simple example query domain independent ft type 
term domain independent calculus meaning calculus restricted domain independent formulas queries 
variations illuminating compare calculus relational calculus 
considered sorted language 
lifted restriction tuple set constructors richer type system 
type system normally included type specific functions predicates 
calculus differs relational calculus precisely aspect allows unrestricted functions predicates associated tuple set type constructors 
chosen reasonable small set functions predicates 
include constructor selector tuples constructor sets 
functional selector sets membership predicate viewed selector 
added convenience comparator sets 
naturally may ask set functions predicates added best 
consider possibilities 
note set functions predicates small minimal 
tuple set constructors removed 
example term viewed abbreviation variable appropriate type anded finite enumerated set represented variable anded formula 
empty tuple simply represented variable type instance type 
tuple set constructors language redundant 
reasons quite simple 
definitions types domains constructors fact variables typed determines variable range values specific form 
second calculus allows construct formulas describe relationships values 
writing value explicit term obtained applying constructor arguments represent variable describe relationship arguments 
precisely eliminated tuple constructor 
sets membership predicate serves selector purpose 
note set comparator redundant expressed 
consider direction inclusion additional functions predicates possibly features language 
extensions show considered abbreviations augment expressive power language 
sets data type natural consider additional operations sets union intersection 
general inclusion additional operations language easier express queries 
example difference query example expressed ft gamma easy show defined language 
example union sets represented variable anded 
matter fact prove section show calculus express algebraic operations introduced section 
augment calculus introducing algebra operations changing expressive power 
contrast relational case possible fact employ orthogonality type constructors 
useful feature augment class terms allowing definition set terms classical mathematical notation set comprehension fx formula free variable idea set terms calculus complex values appeared 
course set terms mathematics long time 
similar notation functional languages close database algebraic languages proposed proposed query language formalism papers 
expression fx replaced new variable anded 
example consider query standard suppliers parts database asking suppliers supplying parts fy part pno yg fy sp supply sp sp sp yg query written calculus auxiliary variables formulation difficult write understand 
note kind terms allowed definitions terms formulas mutually dependent 
set comprehension viewed macro facility effect formal definition language 
summary type system interest represented set constructors general quite lot flexibility choice functions predicates go language 
practical language considerations orthogonality ease play major role design 
concerned languages practice 
choice functions predicates motivated considerations 
extending calculus additional functions features probably load proof equivalence algebra additional details having additional features shedding light 
course added calculus operations algebra proof trivial 
hand opted minimal language constructors felt proof involved hide structure 
complex values algebra framework algebra essentially calculus sorted universes sorts types 
essential difference predicates 
database relations simply named sets values appropriate types database instance environment assigns values names predicates handled boolean valued functions predicates defined base types 
query functional expression evaluated database 
algebra functional language 
viewpoint emphasized literature true relational algebra 
functional languages variables lambda abstraction relational algebra uses different paradigm small set operations encapsulate useful iterations relations composed express queries 
seminal paradigm functional programming 
algebra approach 
classical relational operations union intersection difference change algebra generic respect types elements sets 
cross product definition needs slightly changed 
introduce operations role clarified sequel 
major issue need consider perform restructuring complex objects 
classical projection primary means cross product restructuring relational algebra 
sufficient restructuring relational model map flat record structures flat record structures 
obviously need general mechanism 
address issue follows algebra sublanguage expressions denote restructuring functions 
algebra classes expressions queries restructuring functions 
second introduce operation restructuring operation scheme 
needs supply function parameter 
function parameter operation takes set input produces output set elements restructured function 
function parameters fashion allows deal substructures complex recursively defined values 
approach projection leads additional details difference viewpoint calculus algebra see 
compact powerful notation 
functional language terminology operation higher order function 
idea function parameter straightforward allow functions predicates base type parameters 
considered section 
construction algebraic expressions elaborate calculus formulas relational algebra expressions 
explain meaning operations 
define classes queries functions examples illustrate expressive power programming style algebra 
consider properties classes functions queries 
consider calculus issues redundancy possible variations 
operations start listing operations explaining semantics 
operations set input output types 
discussion general remarks possible types operation aside consider issue type checking inference 
set operations binary operations 
arguments set type produce result type 
cross product type ft cross type value set tuples component note classical relational algebra product sets tuples lengths set tuples length operation produces set pairs tuples 
show express classical product 
definition allows take cross product sets sets tuples 
powerset type ftg powerset collection subsets new operation exist relational algebra 
role clarified sequel 
set collapse operation simply extended union operation 
argument allow cross creates unlabeled tuples 
follows convention regarding component tuples cross equal set sets result union member sets 
set collapse fx rg new operation 
select classical relational select predicative filter set predicates restricted 
extend allowing comparators arbitrary functions set functions defined 
operator accepts function parameter higher order operation 
notation oeh operation predicate boolean valued function 
set predicate applicable values type element type oeh set containing elements satisfy notation chosen show clearly instance select obtained general scheme supplying function argument 
replace main tool performing restructuring complex values may include application functions substructures values 
higher order operation function parameter describes restructuring 
function set functions defined aeh replace operation 
set value compatible sense defined aeh ff rg operation appears various names functional languages example fp map 
embodies idea set construction expressed replacement axiom set theory 
justified consider operation algebraic operation 
relation type assume want project components written 
addition value argument expression attribute parameters determine structure type result 
simple conceptual step regard projection list function transforms member desired format 
precisely attributes regarded unary function attribute combined tuple constructor restructuring occasionally explicitly select readability 
occasionally explicitly replace 
function 
algebra written aeh see 
replace generalization classical project 
example restructuring operation extend operation relation allows addition component tuple 
name new component expression defining function compute specified operation 
function applied tuple produce value new attribute tuple 
obviously project extend special cases general concept apply function element set 
replace additional advantage generalizing general type system change 
queries functions queries functions obtained building blocks 
presenting definitions note intuitively queries functions fundamental difference 
query expression relation names appear 
database query denotes constant 
functional language viewpoint query expression relational names free variables association names database relations environment substitution binds variables values 
binding query expression denotes constant 
function consider possible environments function consider databases applied 
query expression type ary function 
contrast function parameter select replace represents function database 
consider query aeh 
bound relation denotes value order expression defined denote unary function applied element note true function expression contains relation names bound environment expression denote unary function binding 
type function expression unary function 
similarly oeh pi denote boolean valued function unary function type bool 
difference queries functions entails somewhat different constructions queries functions 
define class algebraic query expressions queries 
note complete definition include definition functions 
base queries set constant fcg query relation name query 
class queries class ary expressions contains closed application operations listed 
qm queries op ary operation op qm query particular aeh fi replace operation compatible aeh fi query similarly oeh pi 
emphasize higher order operations definition disallows higher order queries query expression value type 
valid query 
noted expressions denoting functions predicates replace select types unary functions 
consider notation expressing functions 
example consider notation written aeh 
case variables basic functions combined complex functions 
explicit notation input 
assumed tuple relation function applied 
algebraic approach base set function names obtain additional functions combining 
variables 
input determined context function 
define set function expressions 
need unary functions includes non unary functions 
base functions constant constant function function expression similarly database relation name function expression 
abusing notation respectively 
additionally attribute function expression 
id denoting identity function tuple set constructors included function expressions 
algebraic operations select replace function expressions 
select replace instantiated appropriate functions parameters included basis see closure clause 
boolean valued 
class function expressions class contains base functions closed 
composition 
definition emphasizes application 
viewpoint centered composition 
calculus id obviously redundant term id replaced algebra function turns useful illustrated 

function construction select replace 
function construction mean unary predicate oeh function expression unary function aeh function expression 
note aeh obtained composition 
application higherorder operation function produces function 
replace compositions example aeh ffi differs function construction 
applies select 
set function expressions includes expressions denoting non unary functions unary functions parameters replace called replace specifications 
similarly unary predicates selection specifications 
detail regarding notation need consider 
unary functions ffi sufficient expression compositions 
non unary functions 
notation application 
example binary function unary functions denote function give examples id cross function expressions 
note second expression tuple type component expression set valued 
type compatibility functions arguments enforced 
obviously expressions id denote function 
particular composing function left redundant simplified respectively 
example aeh associated relation nonempty 
test set emptiness aeh replace operation adds additional level set nesting relation 
note id means handling implicit input 
example involving id aeh id set sets adds contents elements 
id needed illegal 
notation standard mathematics functional languages cases cumbersome database area uses different simpler notations 
alternative approach higher order operation creates tuples functions regard non unary functions unary functions tuple inputs 
functions unary ffi suffice 
tuple construction appear construction composition 
generally values type representing truth value done 
consider examples 
expression denotes binary function composing unary functions obtain 
applied tuple attributes generates tuple attributes attribute input value new attribute similarly essentially projection renaming 
convenient notation expression 
tuple constructor list component names function define style target lists relational languages 
applying expression obtain 
new attribute function name compact notation simply write 
expression aeh denoting classical projection attributes abbreviation aeh 
similar notation set constructor 
dot notation definitions functions queries complete 
remarked expression aeh fi legal query 
type compatibility required additional condition considered 
examples queries starting calculus example example recall schema fg example 
queries 
union set constant tuples 
select tuples component member second component oeh 
classical cross product aeh cross 
join easily expressed composition oeh aeh cross 
flatten produce set flat tuples contains component tuple elements second component set collapse aeh cross fbg expression replace transforms tuple set pairs 
note cross operates sets need transform fbg 
component called value value tuple 
second component called value member set original tuple 
effect pushing making element pair 
set collapse needed remove extra set brackets result 

powerset relation powerset 

collection subsets second component tuples contain values set collapse aeh powerset gamma examples illustrate complex queries particular functions replace select expressions manipulation deeply nested components complex values 
example 
recall relation fg example 
relation type fg obtained adding value component component deleting component aeh fbg 
complex query construction stages helpful 
scheme 
query add third attribute value tuples member eliminate component 
replace operation set type ae aeh abbreviations ae aeh type ff gg want perform restructuring set member ae aeh aeh id observe necessary id function 
component type valid replace specification 
obtain replace add level ae aeh aeh id suppose want component 
done ae aeh aeh id observe expression apply tuples inner level attributes exist 
inner replace meaning outer level tuples 
particular observe inner replace specification meaning strict context type essentially expression free 
remains free level bound meaning larger context complete query 
definitions queries functions replace specification query aeh query replace specification aeh replace specification 
forms replace operation aeh far placed restrictions constructions 
seen example replace specification aeh sense allow attribute appear operand attribute presumably meaning replace specification larger context 
sense query aeh 
example set tuple type type tuple type meaning aeh query 
related problem suppose aeh tuple type contains necessarily refer component 
assume aeh attribute 
presumably refers function elements issue bindings names scopes names known 
intuition formalized 
function expression divide set attributes functions bound free 
definition uses induction structure function expressions 
expression free 
basic functions include attributes 
function obtained composition form basic function algebraic operation functional expressions 
free bound attributes remain free bound respectively expression 
contain attributes know free bound attributes expression 
cases consider contains attributes attribute expression form 
expression legal tuple type component 
bound expression 
second case application aeh obtain aeh 
selection treated similarly 
bound free attributes remain bound free respectively expression bound attributes remain bound 
free attributes remain free set tuples type attribute free bound 
cases summarized follows function operation applied argument free attribute meaningful argument attribute bound 
case consider function construction 
function expression aeh function expression constructed form 
bound free attributes remain bound free expression 
summary binding function attributes meaning done inside attribute bound smallest subexpression meaning exists 
note cases user intention may different 
example expression aeh aeh relations contain user want refer component necessary rename attribute new attribute see rename construct required expression 
similar problems may arise identity function solving may complicate note fn attributes functions 
expression queries 
summarize conditions terms bound free attributes construction replace specifications queries replace 
restriction replace specifications 
expression aeh query free attributes appear type members tuple 
examples discussion follows query aeh contains replace operation query nested replace nested replace may contain free attributes 
attributes necessarily meaning context type remain free 
illustrated example 
possible characterize attributes nested replace 
answer 
tree representing set type node tree set type 
idea attribute replace specification appears type appears second case value type node value type interpreted denoting unique node relative cases plays essentially role constant relative value set attributes attributes nodes reached going possibly sideways crossing set constructor way 
tuple tuples type includes attributes reachable going crossing set constructor 
captured definition 
type 
associate set dynamic constants subtype relative follows 
set dyn smallest set attributes satisfies conditions 
ffl tuple type dyn dyn dyn dyn ffl set type ft dyn dyn 
relation example dynamic constants inner tuple node inside attributes replace specification node query illustrated bottom construction queries 
example illustrates topdown construction query containing replace specifications dynamic constants 
example consider relation scheme fg fg want restructure elements leaving transformed dropping component tuples leaving component elements furthermore want delete tuples new component contain value component 
start replace specification transformed aeh 
replace obtain replace specification aeh oeh id 
add selection condition apply resulting expression replace specification obtain aeh oeh aeh conclude state properties queries function expressions 
proposition query function expression 
note value function depend implicit input 
proof remarked query interpreted database denoting constant 
viewed unary constant function proof uses induction structure queries 
details left reader 
query containing relation names defines function databases relation names treated variables 
compose queries replacing relation name query query 
similarly replace specification contains relation names may replace replace specifications types 
proposition class queries closed composition 
query contains query output type type expression obtained replacing occurrence query 
ii class replace specifications closed replacement relation names replace specifications 
contains replace specification output type expression obtained replacing occurrence replace specification 
proof proof uses induction structure fixed case deserves attention aeh occurrence replaced case ii 
ii proved similar manner 
details left reader 
note closure replace specifications composition part definition 
conclude subsection observation 
theorem algebra domain independent language 
variations observations expressive power algebra 
particular consider additional operations expressed 
consider certain operations removed restricted changing expressive power 
naturally interested done replace nested expressions nesting structures model expressions language distinguishes model language relational analogues 
kinds restructuring perform relation 
increase level nesting adding set tuple constructors set constructor transform element singleton set tuple constructor transform element single component tuple attribute label direction decreasing level nesting cases consider 
set sets values set collapse transform set values 
special case sets singleton effect operation query language 
similarly tuple select components drop leave component tuple constructor 
example aeh type ftg 
related operation set tuples components tuple transform set flat tuples 
example aeh type derived operation called tuple collapse 
analogue set collapse 
operation easy obtain classical cross product sets tuples perform cross label desired identity transformation 
followed tuple collapse 
obtain various joins composing selections 
assume change name component aeh 
similarly change attribute substructure nested replace 
expressions quite cumbersome repeat attributes need changed 
renaming useful operation useful practice add operation rename purpose 
notation rename changing attribute uniformly previous discussion follows express relational algebra operations 
consider nested relational model 
known operations model nest unnest 
assume scheme nesting attribute accomplished follows 
delete tuple component extend copy aeh attributes copy renamed prevent ambiguity expression 
perform selection embedded copies tuple component contain tuples positions 
project resulting attribute 
accomplished aeh aeh oeh expressions course collected single algebraic expression 
matter fact projection selection pushed inside final expression aeh aeh oeh rename expression description nest computed practice 
unnest consider relation unnesting accomplished set collapse aeh aeh stated operations relational nested relational algebra expressed algebra 
reason basic derived operations expressions non trivial un bundled set tuple constructors operations basic functions treat separately 
relational nested algebras operations deal type constructor set tuple 
algebras nested relations literature include facility replace nesting applying algebraic operations substructures 
facility essential 
argue informally theoretically 
show nested replace replace replace eliminated 
consider query aeh aeh 
equivalent way express follows 
extend attribute copy unnest calling new attributes say perform replace function applied nest result project 
note kept unnest original attributes subsequent nest reconstructs original relation copy replaced aeh required 
inside replace algebraic operations replace 
consider relation query aeh op op algebraic binary operation 
consider cross concrete example 
equivalent expression obtained project relation perform set collapse union values 
values 
perform cross results extend tuple result 
call new attribute problem value tuple contains addition pairs cross pairs 
simple selection eliminates extra pairs 
similar arguments apply operations 
summary define algebra construction replace specifications algebraic operations 
analogy calculus complete 
note eliminating nesting forced express functions expressed naturally nesting complicated manner 
practical language model nested structures nesting extremely useful tool 
language contains operators defined recursively verso relations 
example assume instances recall definition verso instances fa bg fdg keys respective levels 
define union instances type define union instances type fu generally define recursively union verso instances 
operation adding levels nesting relations expressions complicated algebra 
conjecture single expression algebra express verso union operations arbitrary relations 
equivalence calculus algebra section prove known equivalence holds model algebra domain independent calculus expressive power 
seen language paradigms variety possible dialects 
details proof vary choice dialect paradigm 
proof languages sections respectively 
theorem algebra domain independent calculus equivalent 
query exists equivalent domain independent query domain independent query exists equivalent query 
calculus algebra follow lines classical proof 
modifications mainly richer structure terms 
prove type exists query applied database generates set values type constructed atomic values appear database query 
show construct query query generates answer database domains called active domains 
claim follows 
database instance db denote adom db set elements appear db including appear components complex values adom db vector sets adom db adom db 
atomic values appear database 
query may include constants appear database 
extend notation adom db adom db denote appropriate set vector sets atomic values appear database query 
discussion assume 
assume database schema db fixed 
claim domain name occurring db exists query denoted database db db adom db 
proof construct query db set elements domain database appear query constructed applying recursive procedure ffl set atoms type atoms atomic domain 
ffl type apply procedure set collapse 
ffl tuple type am tm apply procedure expressions 
take union queries generated 
note cases procedure applied simpler types termination guaranteed 
note expression generated cases procedure terminated immediately value returned 
finite set constants query returns database add constants query queries claim 
corollary query domain name exists query db adom db 
adom stands active domain 
recall section type vector sets atomic values corresponding domain names dom set values type constructed atomic values particular dom adom db set values type constructed atomic values appear db claim type exists query database db db dom adom db 
proof prove claim induction structure types 
basis atomic type induction cases consider 
ffl fsg powerset 
ffl cross tn 
finished stage proof showing active domain type expressed query 
follows variable query denote computes set values constructed atomic values appear database variable take 
query simply type note set collapse powerset operations proof 
place translation calculus algebra operations 
state prove main claim subsection part theorem follows 
query database db denote db database relations db domain adom db 
database relations preserved domains smallest domains contain values database query 
results variable type database db db dom adom db db query computes db precisely set values variable ranges database domain type database 
show algebra expressive domain independent calculus 
proposition domain independent query 
exists query database db db db db db proof suffices show db db db db domain independent db db algebra domain independent 
formula proof induction structure 
explained section associate query formula number variables including 
refer queries correspond subformulas subqueries construct queries subqueries structural induction 
consider structure atomic formulas 
may forms terms comparators 
note term set values take database db deal atomic formulas need show existence queries compute set values term 
know queries exist variables surely exist constants 
existence arbitrary terms proven induction structure terms 
need prove slightly stronger claim 
consider atomic formula query target list query term terms formula list variables term 
answer computed term satisfy formula assignment variables output value term 
really need construct query computes set possible assignments variables term value term 
find formula satisfied assignment assignment output 
claim term variables may exists query db set tuples combinations values db possible assignments variables database db component tuple value assignment represented components 
ii terms variables may exists query db set tuples represent assignments variables values terms assignments 
proof proof uses induction structure terms 
variable computes domain db obtain take aeh id id constant simply fcg 
note works non atomic constants relation names contains variables construction complete 
contains variables simple variable obtained applying function terms 
consider functions applied 
case tuple type defined 
induction hypothesis variables aeh second case alternative notation 
set variables union sets variables 
aeh permute join common variables cross expression computes tuples length variables values 
cross product variable appears components corresponding 
join contains selection forces variable values followed projection leaves just copy value 
cross product position terms 
join permute moves positions tuple constructor final replace collects tuple required 
case obtained application set constructor 
construction case similar omitted 
ii case treated essentially application constructor previous case 
perform natural join common attributes move terms positions 
consider atomic formulas 
case formula 
assume variables 
want construct query equivalent construction algebraic expression computes possible values database required query aeh oeh note case selection outputs answer type set tuples arity 
result replace instantiation 
case atomic formulas 
query aeh oeh case holds 
example query formula aeh oeh aeh id formula element formula aeh oeh easy see subformula atomic denotes formula constructed db db consider induction structure formulas 
suffices consider cases formula obtained simpler formulas applying 
proof essentially 
natural join negation take complement course doing permutation proper column numbers final replace 
respect cross product appear free variables formula negated projection existential quantifier 
cases assume induction hypothesis queries equivalent queries correspond subformulas formula prove query exists formula 
nontrivial step association projection existential quantifier 
database db range existentially quantified variable db follows projection effect existential quantifier 
construction described terminates formula query db db 
required concludes proof direction equivalence theorem 
observations interest 
proof set collapse construction queries active atomic domains 
fsg set type set possible objects type powerset set objects type need powerset algebra construct domains non atomic types variables place proof 
imply operators auxiliary away approach computing domains 
powerset particular expensive operator really necessary query language 
issue considered sequel 
note nesting operations replace operations main part proof 
essentially operations relational algebra combined weak restructuring facilities powerset set collapse sufficient provide algebra expressive power comparable calculus 
demonstration nesting crucial obtaining required expressive power 
idea different section 
showed description query function databases express function convoluted way require nesting 
expressing query function mean query describes components answer computed input 
alternative formulation simulates procedural approach 
calculus procedural component weaker 
free variables take complement respect existence typed variables allows specify form result input way actual results related input set conditions 
algebraic simulation constructs domains certain types including type result simulates conditions restrict domains result left 
quite obviously proves equivalence calculus direction go designing practical languages 
algebra calculus principle assume algebraic operations inside replace deal proof queries arbitrary replace specifications 
suffices prove 
proposition query exists equivalent domain independent query single free variable formula 
replace specification exists formula represents 
types input output holds iff 
select specification unary predicate exists formula represents type input holds iff true 
proof claim need needed induction step proof 
claims proved simultaneously induction structure algebraic expressions 
basis queries fcg represented queries fx fx respectively 
replace specifications represented formulas respectively 
note functions ignore input variable missing 
course add 
representation works non atomic constants 
function calculus 
corresponding formula id represented tuple set constructors binary algebraic operations replace specifications need considered 
unary algebraic operations base replace specifications set collapse represented powerset represented 
boolean functions binary base select specifications 
induction consider operations 
construction essentially classical proof 
assume queries formulas corresponding queries single free variable query constructed show construct ffl set operations change formulas necessary free variable 
ffl cross product cross 
change formulas free variables different 
ffl powerset powerset 
formula single free variable type say new variable type ftg 
note write fx reduction described section 
ffl set collapse set collapse single free variable set type 

ffl select oeh 
assume represents tuple types real distinction variables convenient proof single variable 
ffl replace aeh 
formula represents function consider replace select specifications 
replace specifications obtained composition construction 
select specifications obtained composition 
consider composition 
treat cases unary functions expressions 
composition associative may assume construct new function function operation composed left possibly complex function expressions 
assume fm unary function expressions represented fm unary predicate represented function necessarily unary 
consider represent result applying composing left functions 
consider possible cases base functions ffl attributes identity function represented 
function id represented id ffl tuple constructor function am fm represented vm fm vm am vm ffl set constructor ff fmg represented vm fm vm fv algebraic operations ffl set operations show union 
intersection difference treated similarly 
function represented ffl cross treated similarly union example function cross represented ffl powerset function powerset represented extends obvious way treatment operation base function 
ffl set collapse function set collapse represented obvious extension treatment operation base function 
ffl select function oeh represented ffl replace function aeh represented boolean functions illustrate cases 
ffl membership function represented ffl negation represented 
representing boolean connectives calculus easy built 
consider construction 
ffl replace 
formula formula aeh ffl select formula oeh fact calculus formulas obtained part domain independent follows immediately equivalence queries 
concludes proof proposition equivalence algebra domain independent calculus 
syntactic safety powerset domain independence semantic concept undecidable relational model va 
section syntactic restrictions formulas guarantee domain independence 
formulas restricted called safe 
contrast domain independence restrictions easily checked 
furthermore domain independent formula safe show domain independent calculus safe calculus algebra equivalent 
particular domain independent formula exists equivalent safe formula 
show strengthening restrictions obtains calculus equivalent algebra powerset 
safety accepted approach making formula safe require variable attached range formula 
simplest forms range formulas name database objects certain boolean combinations thereof 
forms relational model 
allow nested structures possibilities exist 
consider example scheme may want variable range set tuples occurring sets tuples restrict range collection need variable say range restricted range restrict define range formulas range restricted variables safe formulas 
ff formula assume partial ordering variables 
assume free bound variables distinct 
say variable range restricted ff relative ordering type empty tuple type holds 
basis ff term may contain constants variables precede ordering 
recall functions construct terms tuple set constructors attribute application 
variables including precede ordering 
note similarity construction powerset translation algebra calculus 
equivalent fy closure ff constructed subformulas holds cl ff conjunct formulas restricted 
cl ff disjunct formulas holds free case appear restricted disjuncts bound case appears precisely disjuncts restricted disjunct appears 
cl ff obtained formula restricted adding existential quantifier variable 
cl ff obtained formula bound restricted adding negation 
formula safe relative partial ordering variables restricted 
includes subformula form 
safe exists ordering safe relative 
rules define notion range restricted free bound variables 
clearly empty tuple type needs range restriction value 
base cases formulas directly restricted ff required database relation required equal member subset value obtained constants variables precede construction decomposition functions calculus required subset result query expressed formula variables formula precede note term contains variables range restriction depends variables sense restricts variables properly restricted 
ff safe variables range restrictions restricting formulas depend directly indirectly variables 
guaranteed assumption range restriction variable depends variables precede ordering 
similar applies 
call formulas formulas obtained range formulas 
included definition constructions possible simulate algebra resulting calculus 
additional forms safety course added needed proof equivalence domain independent calculus show preserve domain independence 
note existential quantifier closure rules 
free restricted formula necessarily restricted universal quantifier appended 
negation loss generality formulating closure rule existential case 
particular formulas form restricted 
taken short notation restricted view form derived restriction rule universal quantification 
universal quantifier constructing formula subformula create new atomic range restriction 
avoid confusion resulting construction shall equivalent notation fy powerful construction role clarified 
quantifiers occur safe formulas 
customarily called bounded quantifiers formulas written respectively 
refer calculus restricted safe formulas safe calculus 
theorem safe calculus algebra equivalent 
query safe formula exists equivalent query query exists equivalent query safe formula 
corollary safe calculus equivalent domain independent calculus 
direction theorem follows proposition proposition safe calculus domain independent 
proof say formula query domain independent variable database changing domain variable requiring contains elements type variable active domain change result query 
formula domain independent domain independent variables 
assume formula safe respect ordering variables prove domain independent proved induction number variables prove domain independent number variables induction structure formula 
variable base cases 
terms cases ground 
immediate formulas define domain independent queries 
easy see domain independence preserved closure rules 
assume claim proved variables consider consider base formulas formula domain independent 
formula contain contains variables precede ordering 
induction assumption domains variables restricted active domain 
follows subformula domain independent assigned values active domain 
similarly terms may contain variables precede reasoning applies 
conclude induction closure rules 
follows proposition safe query equivalent query 
conclude proof theorem just need show translation algebra safe calculus 
direct translation safe calculus algebra necessary 
reasons direct translation 
translation constructs queries domains variables need construct active domain database 
queries range formulas variable 
translation provides useful insight translation calculus algebra 
second see precisely powerset operation translation 
derive version calculus equivalent algebra powerset 
translation appendix 
algebra calculus prove proposition query exists equivalent safe query 
replace specification exists formula represents variables possibly restricted relative ordering 
similarly select specification exists formula represents variables possibly restricted relative ordering 
proof follow translation algebra calculus previous section show formulas constructed satisfy proposition 
just need check constructed formulas safe part variables possibly restricted second part 
base queries fcg corresponding queries defined safe 
induction assume obtained applying operation corresponding queries safe 
note variables bound restricted formulas remain bound restricted formulas construct 
need consider happens free variables new variables restricted 
case ordering variables new variables 
set operations union intersection difference queries respectively 
safety follows cl disjunction cl cl cases conjunction 
cross translation formula obviously restricted remain restricted quantifiers applied cl 
follows variables restricted formula safe 
powerset formula fx variables known restricted restricted 
set collapse formula 
clearly safe cl 
left select replace 
complex contain function parameters 
consider replace 
query aeh 
formula represents function 
note induction hypothesis restricts variables possibly restricted 
cl formula safe 
select treated similarly 
formulas replace specifications id uv respectively 
third restricted 
second rewritten form fy 
restricted derived closure rule universal quantification 
represented denoting formula equivalent fx ux yg restricted 
easy see restricted order 
formula satisfies claim 
powerset represented similarly converted formula satisfies claim 
specifications situation need check happens free new variables 
checking variables possibly restricted cases straightforward illustrate cases 
attribute formula 
restricted know variables possibly restricted 
powerset translation powerset 
second part rewritten fz conjunct restricts previous conjunct bound bounded quantifier restricted know restricted 
replace similar construction formula 
rewriting previous case obtain fs restricted part restricts restricted part bound bounded quantifier 
variables restricted induction hypothesis 
cases base functions algebraic operations boolean functions similar simpler left reader 
consider construction 
formula formula aeh transformation previous cases formula fy 
restricts eliminate existential quantifier implication variables restricted 
select treated similarly 
strictly safe calculus powerset operator algebra unique algebraic operations may argue directly useful expressing real life queries 
additionally may cause exponential cost increases size argument exponentially 
interest consider algebra powerset 
seen previous section proof equivalence domain independent calculus place construction queries domains 
notion safety constructions queries domains possibly operator 
consider equivalence proof algebra safe calculus observe translation domain independent calculus algebra appendix powerset translation 
forms subset predicate 
conclude remove powerset algebra need remove safety definition 
direction translation algebra calculus situation bit complex 
translation powerset part 
similarly translation powerset part 
translations translating 
observe cases relevant part formula form fy 
claimed safety formula breaking components form suitable 
holds cases 
offer replace weaker condition fy 
weaker yield exponential growth 
allows translate cases translations powerset 
note particular translation fy 
simply states obtained applying elements just needed 
note similarity replacement axiom set theory 
call safe calculus replaced strictly safe calculus 
theorem strictly safe calculus algebra powerset equivalent 
proof considered translation algebra calculus argued algebra contain powerset carried provided clauses defining range restrictions 
need consider direction particularly removed need powerset algebra 
claim calculus included domain independent calculus complete proof section 
need transform translation safe calculus algebra appendix translation powerset 
easy fy query returns set values applying nest query returns set pairs form fy far steps performed proof appendix 
step apply powerset dealing fy fy simply need apply powerset second component 
interpreted functions predicates section consider arbitrary interpreted functions predicates query languages 
practical language need predefined built functions sum average predicates user 
call functions predicates interpreted interpretations including interpretation input output domains fixed 
contrast function symbols logic programming functions assigned meaning herbrand universe interpreted inclusion arbitrary function predicate symbols languages easy 
calculus paradigm allows function predicate name 
algebra operations replace select defined explicitly function predicate parameter appropriate types 
add arbitrary functions predicates collection base functions need change definitions problem consider domain independence related notions defining notion domain independence presence interpreted functions problem 
consider approach deal issue particular show equivalence enhanced algebra suitably restricted version note predicates equality membership languages interpreted fixed meanings 
note aggregates average count may require bags sets producing correct results 
problem addressed including bag type constructor klug approach 
consider issue 
enhanced calculus provided course predicates functions included languages 
assume set delta fn functions set delta pr predicates 
functions delta fn predicates delta pr typed 
furthermore domain names types associated fixed domains 
serve algebra calculus 
assume 
function delta fn gamma delta fn note function inverse set valued sets model problem 
assumption implies set gamma finite 
reasonable assumption 
instance consider difference function integers satisfy property gamma contains pairs 
prohibit functions may cause problems query fx gamma expect compute answer query finite time 
query considered domain independent definitions 
briefly consider extension allows difference function certain contexts 
extend calculus introduce terms form delta fn allow formulas 
extend set formulas adding atomic formulas form delta pr cases assume correct types 
examples queries fx count fx extend algebra allow predicate delta pr select operation 
allow functions delta fn replace specifications 
instance queries expressing queries queries count select need reconsider definitions database scheme instance 
database scheme domain names attached fixed domains 
may name int scheme interpretation fixed integers 
addition sets delta pr delta fn included scheme fixed interpretations 
database instance constrained interpretations domains fixed described scheme 
contains interpreted functions predicates 
denote database structure dbi ii vector relations interpretations fixed domains additional functions predicates 
consider domain independence 
query consider active domain values appear database query closed applications functions inverses 
example database contains functions include queries ask integers domain contain integers 
hand having infinite sets included active domain defeat intention definition domain independence 
order useful notion domain independence restricted semantic notion domain independence 
intuition definition algebraic expression bound number times functions inverses applied 
database dbi set constants atom set atomic values atomic type appear object atom set atomic values appear closure atom denoted close defined follows ffl close atom ffl close close delta fn atom close gamma atom gamma close natural numbers succ succ gamma initially numbers closure steps generate set 
want define query depth domain independent depends values closure atom set constants query set finite 
implies able evaluate query database interpretations interpreted domains agree fixed interpretations closure may quite different outside 
necessarily interpreted functions predicates interpretation new domains 
require interpretations agree fixed interpretations closure 
notion depth domain independence precise relax restriction interpretations functions predicates delta fn delta pr domains 
formally depth independence allow domains include close computation closure domains gives results original domains 
requirement ensures particular apply inverse function elements close gamma obtain elements close functions may arbitrary behavior outside set 
assuming relaxation query depth domain independent dbi dbi dbi agrees dbi close described 
query bounded depth domain independent depth domain independent theorem delta fn delta pr 
equivalent query expressible query expressible bounded depth domain independent query proof show associate depth query 
queries replace specifications contain functions depth 
replace specification constructed tuple construction set construction attribute selection depth maximum depths argument replace specifications 
holds function operator applied replace specifications case applying replace 
assume constructed replace specification depths respectively depth depth delta fn depth 
queries depth op qm maximum depths op replace 
depth sum depths easy see depth query depth domain independent 
construction section construct equivalent query depth independent 
extensions constructions treatment replace specifications select may predicates delta pr just built predicates may apply function delta fn replace specifications addition able apply algebraic operations 
example formula replace specification formula 
details left reader 
opposite direction assume depth domain independent query 
translate query construction section extension 
having constructed queries sets atomic values atomic type appear database query atomic part active domain need perform closure steps construct domains non atomic types 
queries close need generate queries close 
query say representing subset domain function query represents set ff sg forward closure step 
similarly inverse functions represented functions perform backward closure step 


cross powerset projection set collapse union create sets complex types decompose elements sets components needed allow apply functions collect new atomic elements 
original construction predicates 
clearly problem predicates delta pr 
interpreted functions may construction terms 
incorporating fact proof creates problem 
easy see query depth domain independent translation generates equivalent query 
generalize notions range formulas safety adding clause func precede ordering 
immediate consequence extension 
fact formula safe bounded depth domain independent 
consider translation algebra safe calculus section augmented described 
easy see claim variables possibly restricted remains valid 
case interpreted function applied func 
theorem extended safe calculus delta fn delta pr equivalent extended algebra delta fn delta pr 
ii extended strictly safe calculus delta fn delta pr equivalent extended algebra delta fn delta pr powerset restrictions impose quite 
instance allow functions integer difference limited manner 
instance consider query fx gamma fx gamma difference inverse may argue constructions safe allowed 
clearly done see 
recursive queries section show domain independent calculus algebra permits specification queries require fixpoint relational calculus 
particular show power language recursive rules 
presentation brief 
transitive closure binary relation expressed relational calculus 
example shows operation corresponds safe calculus query world complex objects 
example consider relational schema type 
transitive closure computed way ffl formula obtain set tuples built values variable type 
ffl formula gives set subsets powerset 
fx type ffl formula gives set elements containing 
ffl formula gives set elements transitively closed ffl transitive closure obtained intersecting elements fx extend calculus fixpoint operator language fixpoint 
technique previous example generalized demonstrate result gain expressivity complex value fixpoint expressive complex value calculus 
spirit introducing recursion simple language recursive rules 
handle negation concept layers 
database scheme relation names called base relations 
language names additional relations called derived relations 
language calculus 
define atomic formulas derived relation names may 
important note derived predicates signature 
language typed 
signature predicate specifies element type particular elements form 
literal atomic formula negated atomic formula 
rule expression form derived predicate literal 
rule interpreted formula xm variables appearing 
recursive query pair hp qi finite set rules derived relation 
rules programs queries need domain independent 
extended discussion see 
purposes suffice 
section consider ordering variables appearing rule 
say variable restricted body relative ordering follows rules cl cl section 
body safe ordering variables variables restricted 
rule safe variable appears head appears body body safe 
assume henceforth rules safe 
assume familiarity semantics programs negation 
negation poses difficulties possible assign meaning program negation 
subject received considerable attention years 
consider stratification suggested 
stratification program partition program set rules hold 
rules defining derived relation contained single stratum 
facts defining base relations 
rule rules defining 
rule rules defining element partition called stratum 
program stratified exists stratification 
note stratification program induces partition predicates appearing predicate associated stratum rules defining appear 
semantics stratified programs simple extension semantics programs negation computes fixpoint rules stratum applied database fixpoint rules second stratum applied result stage 
known final result independent specific layering chosen program 
semantics stratified recursive queries defined obvious way compute extensions derived relations result extension selected derived relation 
example database object type query defines derived relation contains tuples component replaced transitive closure 
assume ternary predicate ins ins interpreted obtained inserting 
show express language 
ins 
rules compute pairs corresponding pairs second component pair contains corresponding component pair possibly additional elements derived transitivity 
obviously pair pair transitive closure tuples 
answer query need select unique tuple maximal third rule puts tuples maximal rule selects maximal negation 
show type program defines ins sets type ftg variables type ftg super min super super super ins super min super note program type specific dependence types variables 
program computes ins type assume variables type 
note program safe 
safe derived relations range restrict various variables 
assume simplicity column key 
easy change rules case hold 
note example built predicate expressed membership stratified negation 
union predicate defined program similar ins 
main result theorem query expressible safe stratified recursive query expressible safe calculus 
proof sketch recursive queries safe calculus consider positive program program negation 
assume base relation schemes 
variables type type cross product relations base derived 
obviously express calculus requirement value variable cross product projections corresponding individual relations 
restrict variable atomic component elements atomic value appears database program 
corresponds example note guarantees variable restricted consequently safety query 
body safe rule safe query head rule obtained projection 
rules defining predicate combine 
product variable express requirement components corresponding base relations equal corresponding database relations component corresponding derived relation satisfies corresponding rules program 
express requirement contains fixpoint program 
construction carried relational calculus 
difficulty force value precisely fixpoint 
assume formula described far 
rest mimic steps example showed select smallest set collection sets 
general stratified program similar construction stratum 
strata including applied treat derived relations strata base relations construction stratum 
formula defining values derived relations easy select values query 
safe calculus recursive queries query transform described section subquery associated range restriction free vari ables 
assumed eliminate universal quantifiers 
construct recursive program induction structure query 
subquery treated associated range restriction guarantees safety rules new derived predicate subquery 
conjunction course poses problem disjunction modeled having rule disjunct 
negation leads step stratification hierarchy existential quantifier simulated projection rule 
note claim true non typed language 
allow relations heterogeneous write simple rule large fxg large adding appropriate exit rule program computes infinite relation external function 
program simulated algebra calculus 
conclude section consider interpreted functions predicates rulebased language 
similar problem independently studied aggregate functions introduced language resembling 
interpreted functions leads problems ffl interpreted functions may introduce new values database finiteness results application programs guaranteed 
ffl programs interpreted functions programs negation may unique minimal model 
second problem arises example aggregates applied sets set fully computed sense apply function 
negation stratification provides solution second problem 
turns provide solution problem 
appropriate stratification programs interpreted functions predicates leads language exactly power algebra safe calculus 
stratification defined additional constraint interpreted function rule rules defining condition relaxed 
instance rule presence stratum cause problem rule uses positively introduce new values 
intuitively stratification restrictive guarantee function applied result new stratum 
complete informal description language need extend notion safety follows body contains range restricted precedes considered range restricted 
theorem delta fn delta pr 
query expressible layered recursive program functions predicates sets expressible bounded depth safe query functions predicates 
noted stratification condition relaxed 
dropped 
example rule applies unbounded number times expressed calculus 
rule calculus formula safe safe formula expresses query 
approach generalization query language paradigms models allow structure relational model 
considered calculus algebraic logic programming paradigms 
generalized paradigms complex object model considered validity relationships known hold paradigms relational setting 
equivalence algebra domain independent calculus safe calculus hold distinction calculus algebra language allows recursion longer holds 
results depend inclusion powerset operation algebra equivalently unrestricted calculus 
considered algebra operation restricted version calculus equivalent algebra 
believe right algebra complex objects monadic algebra essentially algebra powerset arguments support claim 
algebra principles type specific operations type constructors particular constructors selectors user supplied functions base types main ingredients restructuring functions composition major tool construction queries restructuring functions small number higher order operations generate set functions element functions 
concept composition exists relational model form closure requirement query expressions 
complex structure values particularly possibility recursively set constructor require inclusion higher order operations 
believe approach taken design generalized algebras 
emphasis composition brings mind category theory composition central concept 
turns semantic domain algebra category replace functor set collapse single construction singleton sets natural transformations furthermore satisfy axioms monad 
empty set union 
definitions related see instance 
addition general framework specific results described interest consider languages best practical 
context important note considered sql extensions 
implemented systems languages paradigm see 
comprehensions considered viewed pure form generalized sql 
conjecture language paradigms comprehensions similar ideas suitable user interfaces algebra may suitable language 
issues outside scope deserve study 
appendix calculus algebra show safe query exists equivalent query 
follow translation calculus algebra section major difference 
recall translation queries domains variables constructed queries active domains database 
variables range restricted queries express range restrictions domain expressions variables 
query constructed previous section query equivalent general case db query construct equivalent databases 
raises technical problem general range formulas associated query subqueries subqueries 
prove claims induction structure formulas need associate subformula range restrictions variables free 
show safe formula converted equivalent safe formula satisfies requirement prove claim formulas 
transformation works follows push existential quantifiers outside possible 
recall commutes assuming variables occur bound subformula free outside 
transformation formula ff negated subformulas start possibly empty string existential quantifiers quantifiers 
transformation leaves variables restricted formula safe 
variable appears formula cases appears negated subformula free restricted ff 
bound quantifier 
free appear outside subformula bound enclosing negated subformula bound prefix ff free ff 
think ff tree leaves atomic formulas internal nodes labeled 
internal node corresponds subformula ff 
nodes just existential quantifier prefixes ff negated subformulas distinguished sense precisely case corresponds range formula form fy 
atomic formula subformula 
node denoted occurrences bound occur node associated prefix contains free ff node just prefix ff 
transformation associate range formula nodes corresponding subformulas contain variable time starting order 
describe process case variable describe briefly changes needed variables 
going mark internal node free corresponding subformula 
clearly marked restricted ff exists atomic subformulas range restrictions 
appear scope negation contribute making restricted ff 
example subformula range formula subformula restricts formula 
going replace certain nodes mark signify restricted subformula corresponding node considered 
finish unmarked nodes appear nodes marked free restricted nodes marked free range restriction 
marking process done follows node marked restricted corresponding subformula 
marked node compute mark child ren follows node mark marks descendants changed 
need describe inheritance rules marks form node labeled occurs restricted children 
child inherits mark node labeled similar case may free child restricted corresponding subformula 
recall restricted restricted regardless structure 
child free restricted corresponding subformula inherits child 
example marked similarly marked child free restricted remains marked node labeled corresponding subformula restricted 
node may mark mark case changed 
marking process stops negations quantifiers occur negations need consider quantifiers 
marking process terminates range formulas marked formula safe 
useful range formulas 
stage push range formulas upward sideways subformulas marked reach conjunctions disjunctions range formulas merged sense conjunction disjunction considered indivisible subformula 
proceed continue merge range formulas possible 
denote range formula 
steps ffl subformula contain range formula transformed contains free just contains marked just 
subformula form merge range formulas obtain 
second conjunct simpler form obtained 
ffl subformula transformed note appears disjunction restricted restricted disjuncts 
note treat negation 
stated useful range restrictions variable inside negated subformula bound case quantifier prefix subformula 
essentially reason go existential quantifier 
quantifier prefix ff go prefix 
quantifier prefixes occur just negations prefix occurs negated formula range restriction note current case variable ordering range restriction variable form need go formula 
finish transformation need describe range restriction associated subformula marked pushed subformulas 
cases ffl formula transformed clearly say contain pushed ffl formula transformed 
ffl formula transformed 
need push formula form 
may need push existential quantifier 
result transformation viewed follows subtree formula contains range formulas considered indivisible inner structure concern 
subformula atomic anded range formula contain 
convenient carry structure stages 
example subformula considered disjunction 
note perform transformation may appear range restriction uses 
consider appearing subformula cases occurs 
important associate range formula subformula transform 
collect range formulas associated node tree 
economical pushing range formulas separately 
transformation applied variables differences 
mark nodes going may go subformula appearing range restriction form fz new case may restriction fy yg 
precedes ordering treat performed transformation possibly creating occurrences range formula 
anyway start transformation occurs need consider outside subformula 
second going may push range formula subformula form 
example fy zg push outside obtain fy zg 
pushing may push subformula form 
equivalence fy fy call conjunction range formulas closed uses variable range formula variable variables precede closed conjunction ordered conjunct uses variables preceding conjuncts 
implies particular conjunct forms boolean combinations thereof uses variables 
transformation terminates formula subformula closed conjunction range formulas conjunction formula closed conjunction contains range formulas free variables 
prove translated query induction number variables 
claim closed conjunction range formulas construct equivalent query 
query produces set tuples 
recall cross product 
value set values pair values set values 
query exists proved induction number variables conjunction 
proof uses double induction number variables formula number number variables range formulas 
basis construction variable fact range restriction uses variables 
forms combinations thereof combinations taken care intersection union respectively consider basic forms similarly variables 
query cases constant queries ftg powerset respectively 
note case dealing variable real powerset constant set powerset just constant set 
variables depend previous variables real powerset 
formula just variable part finished skip second part proof 
variables closed conjunction cases 
restriction form domain independent variables construction take cross product query preceding variables 
restrictions form proof claim proved term contains variables construct query produces relation columns contain values variables column contains corresponding value 
case gamma 
need apply operator column replace operation form range restriction set collapse query need powerset real operator 
case consider fy contain smaller number variables formula considering 
induction hypothesis query 
keep mind may contain free variables illustrate construction example 
assume query fy vg 
transformation range formula form fy vg 
formula contains free variables type result type result corresponding query set pairs values 
need transform set values possible value value included sets 
need simulate nest operator 
seen section 
obtain query return set pairs form fy supposed subset sets second column apply powerset column powerset inside replace 
note domain expression position parameter project column loose connection set second column value 
translate full query part join query obtained range formula variable depends common column perform projection existential quantifier 
general case free variables addition produces set tuples perform nesting apply powerset 
free variables appear formula effect transformation subformula dealing form fy free variables appears 
join result range formula queries domain variables appropriate equalities 
queries closed conjunctions range formulas appear formula proceed construct query formula induction structure 
atomic construction preceding section query closed conjunction domain expression 
constructions join complement projection 
note treat single construction similarly 
negated subformula closed conjunction range formulas attached contains variables free complement 
note treated previous section 
translated union 
free variable appears disjunct appears safety 
abiteboul bidoit non normal form relations algebra allowing data restructuring jcss 
abiteboul beeri power languages manipulation complex objects 
inria tr may 
abiteboul beeri van gucht gyssens completeness languages complex objects nested relations nested relations complex objects lecture notes computer science springerverlag 
abiteboul grumbach logical approach manipulation complex objects proc 
edbt march springer verlag lecture notes computer science 
abiteboul hull ifo formal semantic database model tods 
abiteboul hull object restructuring semantic database models 
proc 
icdt roma 
abiteboul kanellakis object identity query language primitive proc 
acm sigmod conf full appear acm 
aho ullman universality data retrieval languages 
proc 
popl 
apt blair walker theory declarative knowledge 
foundations deductive databases logic programming minker ed morgan kaufmann publishers backus programming liberated von neuman style 
functional style programming algebra programs 
turing award lecture cacm aug 
bancilhon delobel kanellakis object oriented database system story morgan kaufmann san mateo california 
bancilhon khoshafian 
calculus complex objects 
proc 
th pods march 
beeri naqvi ramakrishnan shmueli tsur sets negation logic database language 
proc 
th pods march 
beeri naqvi shmueli tsur set constructors logic data language journal logic programming 
beeri milo functional predicative database programming proc 
th pods march 
breazu tannen buneman naqvi structural recursion query language primitive 
proc 
rd dbpl workshop greece august morgan kaufmann 
breazu tannen buneman wong naturally embedded query languages 
icdt 
chen 
extension datalog aggregation functions 
iv bases de 
codd 
relational model large shared data banks 
cacm june 
chandra harel 
computable queries relational database systems 
jcss 
cluet delobel richard algebra query language object oriented database system 
data knowledge engineering pp 

recursive unsolvability decision problem class definite formulas journal association computing machinery 

computable directory queries 
manuscript technion august 
fagin 
horn clauses database dependencies 
jp jacm oct 
fischer thomas operators non normal form relations 
proc 
th compsac chicago nov 
grey logic algebra databases ellis norwood series computers applications 
hammer mcleod 
data description sdm semantic database model 
tods 
hull survey theoretical research typed complex database objects 
manuscript usc 
hull su 
expressive power database queries intermediate types proc 
th pods march 
hull yap 
format model theory database organization 
jacm july 
jacobs database logic 
jacm april 

schek 
remarks algebra non normal form relations proc 
st pods 
klug equivalence relational algebra calculus query languages having aggregate functions 
jacm july 
kobayashi overview database management technology 
tr cs college japan 
korth roth silberschatz 
extended algebra calculus relational databases 
tods 
kuper logic programming sets 
proc th pods kuper vardi 
new approach database logic 
proc 
rd pods macleod 
database management system document retrieval applications 
information systems 
consideration normal form necessarily normalized relations relational model 
proc 
rd vldb oct 
naqvi logic negation database systems 
proc 
foundations deductive databases logic programming 
ozsoyoglu ozsoyoglu 
extension relational algebra summary tables 
proc nd intl lbl conf 
statistical database management sept 
ozsoyoglu ozsoyoglu matos 
extending relational algebra relational calculus set valued attributes aggregate functions 
tods dec 
peyton jones implementation functional programming languages prentice hall 
schek scholl 
algebra relational model relation valued attributes 
information systems 
trinder comprehensions query notation 
proc 
rd dbpl workshop greece august morgan kaufmann 
ullman principles database systems computer science press nd ed 

vardi decision problem database dependencies information processing letter 
van gelder topor 
safety correct translation relational calculus queries 
proc 
th pods 
van gelder negation failure tight derivations general logic programs 
foundations deductive databases logic programming minker ed morgan kaufmann wadler comprehending monads 
proc 
conf 
lisp functional programming 
zaniolo representation deductive retrieval complex objects 
proc th vldb stockholm 
