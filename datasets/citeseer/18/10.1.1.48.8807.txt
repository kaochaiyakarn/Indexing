essence compiling continuations cormac flanagan amr sabry bruce duba matthias felleisen department computer science rice university houston tx order simplify compilation process compilers higher order languages continuationpassing style cps transformation phase generate intermediate representation source program 
salient aspect intermediate form procedures take argument represents rest computation continuation 
na ive cps transformation considerably increases size programs cps compilers perform reductions produce compact intermediate representation 
implemented part cps transformation step conceptually second phase 
code generators typical cps compilers treat continuations specially order optimize interpretation continuation parameters 
thorough analysis machine cps terms shows actions code generator invert na ive cps translation step 
put differently combined effect phases equivalent source source transformation simulates compaction phase 
fully developed cps compilers need employ cps transformation achieve results simple source level transformation 
compiling continuations number prominent compilers applicative higherorder programming languages language continuation passing style cps terms intermediate representation programs 
strategy apparently offers major advantages 
plotkin showed value calculus supported part nsf ccr ccr texas atp 
appear conference programming language design implementation 
june albuquerque new mexico fi value rule operational semantics source language conventional full calculus semantics intermediate language importantly calculus proves equations cps terms calculus corresponding terms source language 
translated practice compiler perform transformations intermediate language source language 
second language cps terms basically stylized assembly language easy generate actual assembly programs different machines 
short cps transformation provides organizational principle simplifies construction compilers 
gain better understanding role cps transformation plays compilation process studied precise connection calculus source terms calculus cps terms 
result research extended calculus precisely corresponds calcu lus intermediate cps language semantically sound source language 
extended calculus includes set reductions called reductions simplify source terms manner realistic cps transformations simplify output na ive transformation 
effect reductions name intermediate results merge code blocks declarations conditionals 
direct compilers typically perform reductions ad hoc incomplete basis 
goal show true purpose cps terms intermediate representation achieved normal forms 
base argument formal development machine intermediate code cps compiler 
development shows machine identical machine normal forms 
back normal form compiler employ code generation techniques cps compiler uses 
short normalization provides personal communication boehm dybvig hieb april 
mn mn xn values constants variables primitive operations syntax core scheme cs tional principle construction compilers combines various stages fully developed cps compilers straightforward transformation 
section reviews syntax semantics typical higher order applicative language 
section analyses cps compilers language 
section introduces reductions describes normal form compilers 
section proves equivalence normal form compilers realistic cps compilers 
benefits normal form terms intermediate representation compilers topic section 
appendix includes linear normalization algorithm 
core scheme source language simple higher order applicative language 
purposes suffices consider language syntax trees produced lexical syntactic analysis module compiler see context free grammar language 
terms language values non values 
values include constants variables procedures 
non values include expressions blocks conditionals function applications primitive operations 
sets constants primitive procedures intentionally unspecified 
purposes irrelevant language statically typed ml dynamically typed scheme 
language core scheme contextsensitive properties assumed checked front compiler 
procedure xn parameters xn mutually distinct bound body similarly expression binds variable bound free set free variables term fv 
barendregt ch identify terms modulo bound variables assume free bound variables distinct terms language overly simple contains ingredients necessary generate result full ml scheme 
particular assignments control operators orthogonal analysis cps compilation strategy 
interfere definitions theorems 
semantics language partial function programs answers 
program term free variables answer member syntactic category constants 
conventional tradition specify operational semantics core scheme machine 
machine cek machine components control string environment includes bindings free variables continuation represents rest computation 
cek machine changes state transition function 
example state transition block starts evaluation current environment modifies continuation register encode rest computation hlt ki 
new continuation receives value extends environment value proceeds evaluation remaining clauses similarly intuitive explanations 
relation gamma 
reflexive transitive closure transition function 
function fl constructs machine values syntactic values environments 
notation refers algorithm looking value environment operation xn extends environment subsequent lookups return value object hcl xn ei closure record contains code values free variables xn 
partial function ffi abstracts semantics primitive operations 
cek machine provides model designing direct compilers 
compiler cek machine implements efficient representation environments displays continuations stack 
machine code produced compiler realizes operations specified cek machine manipulating concrete representations environments continuations 
machine characterizes compilers order languages fortran 
case creation deletion environment continuation components follows stack behavior 
machine reduces traditional stack machine 
semantics cs hm gamma 
ci data specifications stated cs theta theta theta valued machine states variables gamma ffi valued environments valued hcl xn ei machine values hap ffl ki hlt ki continuations hif ki hpr ffl ki transition rules hv ki gamma 
hk fl ki gamma 
hm hlt kii ki gamma 
hm hif kii mn ki gamma 
hm hap hffl kii mn ki gamma 
hm hpr hffl mn kii ki gamma 
hm ki ki gamma 
hm ki ki gamma 
hm ki ffl ki gamma 
hm hap ffl kii ffli ki gamma 
hm xn ki hcl xn ffl ki gamma 
hm hpr ffl kii hv ffli ki gamma 
hk ffi ffi defined converting syntactic values machine values fl fl fl xn hcl xn ei cek machine cps compilers compilers map source terms cps intermediate representation generating machine code 
function basis cps transformations various compilers 
uses special expressions continuations encode rest computation shifting burden maintaining control information machine code 
notation delta delta delta marks administrative expressions introduced cps transformation 
primitive operation cps language equivalent operation source language takes extra continuation argument receives result computed 
transformation introduces large number administrative expressions 
example maps code segment df cps term convention ignore context enclosing cps programs 
decrease number administrative abstractions realistic cps compilers include simplification phase compacting cps terms 
analysis simplification phase optimality combined refer reader danvy filinski sabry felleisen 
phase simplifies administrative phi delta delta delta mn delta delta delta mn tn tn delta delta delta mn delta delta delta mn tn tn phi phi phi delta delta delta xn kx delta delta delta xn cps transformation redexes form rule gamma 
fi term result capture free substitution free occurrences example xz 
applying reduction fi administrative redexes previous example produces fi normal form term cps reduction fi strongly normalizing language cps terms 
simplification phase cps compiler remove fi redexes output translation simplification phase longer need distinguish regular administrative expressions notation delta delta delta classes expression 
convention language fi normal forms cps cs return bind branch wn tail call wn call wn prim op wn prim op kx xn values language typical intermediate representation cps compilers 
cps translation conditional expression contains continuation variable fi normalization phase produce exponentially larger output 
modifying cps algorithm avoid duplicating removes potential exponential growth 
rest technical development adapted mutatis mutandis 
na ive cps compilers machine characterizes code generator na ive cps compiler cps machine 
terms cps cs contain encoding control flow information machine require continuation component record rest computation 
evaluation proceeds state transition function 
example state transition tail call wn computes closure hcl xn corresponding extends values wn starts interpretation realistic cps compilers cps machine describes na ive cps compiler typical compilers deviate model regards 
na ive machine cps code represents continuation ordinary closure 
realistic cps compilers mark continuation closure special closure 
example shivers partitions procedures continuations order improve data flow analysis cps programs sec 
orbit rabbit allocation strategy closure changes closure continuation 
similarly appel describes various techniques closure allocation treat continuation closure special way 
order reflect changes machine tag continuation closures special marker ar describes activation records 
second cps representation user defined procedure receives continuation argument 
steele modifies cps transformation continuation variable hack recognizes instances cps terms delta delta delta transforms delta delta delta 
optimization eliminates register shuffling evaluation term 
appel achieves effect modifying cps transformation letting variables share semantics cps cs hp hcl gamma 
data specifications sn cps cs theta envn machine states envn variables gamma ffi environments hcl kx xn ei hcl ei machine values transition rules ei gamma 
hp hcl ei gamma 
hp ei gamma 
hp ei hp ei wn ei gamma 
hp xn hcl xn wn ei gamma 
hp hcl ei xn hcl xn wn ei gamma 
hp ffi ffi defined hcl wn ei gamma 
hp ffi ffi defined converting syntactic values machine values kx xn hcl kx xn ei na ive cps machine cps machine 
register procedure call 
terms cps machine optimization corresponds modification operation xn xn share binding order sharing explicit split environment components component includes binding continuation component gamma includes rest bindings treat component independently 
optimization relies fact control string exactly free continuation variable implies corresponding value held special register 
performing modifications na ive machine produces realistic cps machine 
new cps ek machine extracts information regarding continuation cps terms manages continuation optimized way 
example state transition tail call wn evaluates closure fact holds presence control operators identifiable current continuation 
hcl kx xn gamma extends gamma values wn starts execution particular need extend gamma value value remains environment component normal form compilers close inspection cps ek machine reveals control strings contain redundant information considering way instructions executed 
return instruction transition gamma 
dispatches term informs machine return address denoted value variable machine ignores information return instruction automatically uses value register return address 
second call instructions transitions gamma 
gamma 
invoke closures expect arguments continuation machine ignores continuation parameter closures manipulate global register 
semantics cps cs eval hp har gamma 
data specifications sc state cps cs theta theta machine states gamma variables gamma ffi environments value hcl kx xn gamma machine values har gamma continuations transition rules gamma gamma 
hp gamma gamma har gamma gamma gamma 
hp gamma gamma gamma gamma 
hp gamma gamma hp gamma gamma wn gamma gamma 
hp gamma xn gamma hcl xn gamma gamma wn gamma gamma 
hp gamma xn har gamma ii gamma hcl xn gamma gamma wn gamma gamma 
hp gamma ffi ffi defined har gamma gamma wn gamma gamma 
hp gamma ffi ffi defined gamma realistic cps machine cps ek machine 
undoing cps crucial insight elimination redundant information cps ek machine corresponds inverse cps transformation intermediate code 
function realizes inverse 
inverse transformation formalizes intuition redundancies cps ek machine 
eliminates variable return instructions parameter procedures 
change implies continuations passed arguments function calls contexts surrounding calls 
example code segment cps section argument appears cps compilers perform sequence steps oe cps cs cps fi normalization un cps cs ffl ffl ffl ffl cs diagram naturally suggests direct translation combines effects phases 
identification translation requires theorem relating fi reductions cps terms reductions source language 
correspondence reductions subject previous 
resulting set source reductions reductions 
reductions strongly normalizing characterize translation function applies reductions source term reaches normal form theorem 
definition reductions refers concept evaluation contexts 
evaluation context term hole denoted place subterm 
location hole points danvy weise recognize compaction cps terms expressed source language explore topic systematically 
inverse cps transformation cps cs cs psi psi psi wn psi psi psi wn psi psi psi wn psi psi wn psi psi psi psi psi psi kx xn xn language cs return bind branch vn tail call vn call vn prim op vn prim op xn values inverse cps transformation output evaluation contexts delta delta delta delta delta delta reductions gamma 
fv gamma 
vn gamma 
vn fv evaluation contexts set reductions subexpression evaluated cek semantics 
example expression reducible expression occur definition evaluation contexts includes clause 
reductions transform programs natural intuitive manner 
reductions merge code segments declarations conditionals 
reduction lifts redexes evaluation contexts names intermediate results 
evaluation contexts reductions semantics cs eval hm har gamma 
hx data specifications sa cs theta theta machine states variables gamma ffi environments hcl xn ei machine values har ki continuations transition rules hv ki gamma 
hm fl har ki gamma 
hm fl ki ki gamma 
hm ki fl hm ki fl vn ki gamma 
hm xn ki fl hcl xn fl vn ki gamma 
hm xn har kii fl hcl xn fl vn ki gamma 
hm ffi ffi defined har fl vn ki gamma 
hm ffi ki ffi defined fl ek machine rewrite sample code segment section follows 
clarity surround reducible term box gamma 
gamma 
gamma 
appendix includes linear algorithm maps core scheme terms normal form respect reductions 
compilers order establish reductions generate actual intermediate code cps compilers design machine language normal forms ek machine prove machine equivalent cps machine 
ek machine cek machine specialized subset core scheme normal form 
machine see kinds continuations continuation continuations form har ki 
cek machine ek machine needs build continuation evaluation non tail function call 
example transition rule tail call vn evaluates closure hcl xn extends environment values vn continues execution continuation component remains register comparison cek machine build seperate continuation evaluation sub expression vn equivalence compilation strategies comparison figures suggests close relationship cps ek machine ek machine 
fact machines identical modulo syntax control strings corresponding state transitions machines perform operations 
currently transition rules machines defined pattern matching syntax terms 
reformulate rules predicates selectors syntax see correspondence clearly 
example transition rules gamma 
gamma 
term syntax higher order functional call var call body call 
call args call fn hc ki gamma 
delta delta delta call 
call var call body call fn vn call args arguments syntax functions manipulating terms syntax independent manner 
applying appropriate functions produces transition rule gamma 
ek machine rule gamma 
cps ek machine gamma 
call var call fn gamma 
cps call var cps call fn suitable definitions syntax functions language cs call var vn call body vn call fn vn definitions language cps cs follow similar pattern cps call var wn cps call body wn cps call fn wn manner pair transition rules gamma 
gamma 
higher order functional tn syntax functions appropriate normal forms cps terms respectively 
theorem characterizes relationship transition functions 
theorem machine equivalence gamma 
tn gamma 
tn 
theorem states transition functions ek cps ek machines identical modulo syntax 
order show evaluation normal form term cps counterpart respective machines produces exactly behavior need prove exists bijection machine states commutes transition rules 
definition 
state gamma 
state hp gamma hu gamma env gamma 
env gamma gamma value gamma 
value hcl kx xn gamma hcl xn gamma cont gamma 
cont har gamma har gamma intuitively function maps cps ek machine states ek machine states perform similar mapping environments machine values continuations respectively 
formalize previously stated requirement behave manner 
requirement value ffi ffi function commutes state transition functions 
theorem commutativity theorem state gamma 
gamma 

gamma 
gamma 
proof inverse cps transformations bijective 
structural induction functions bijective 
proof proceeds case analysis transition rules 
intuitively evaluation cps term cps ek machine proceeds fashion evaluation ek machine 
machine equivalence theorem implies machines perform sequence operations compilers machines produce identical code input 
normal form compiler achieves goal fewer passes 
normal forms intermediate language analysis suggests language normal forms intermediate representation compilers 
direct compilers transformations similar reductions ad hoc incomplete basis 
natural modify compilers perform complete normalization phase analyze effects 
conducted experiment non optimizing direct compiler caml light 
compiler translates ml programs bytecode calculus intermediate language interprets bytecode 
performing normalization intermediate language rewriting interpreter ek machine achieved speedups dozen small benchmarks 
naturally expect speedups smaller modifying optimizing compiler 
major advantage cps intermediate representation optimizations expressed sequences fi reductions 
example cps compilers transform non tail call kx wn tail recursive call wn reduction continuation 
identical transformation language normal forms reduction fi id vn gamma 
vn vn normal forms corresponding wn respectively 
optimization cps terms corresponds sequence fij reductions expressible normal form terms 
reductions expose optimization opportunities merging code segments block declarations conditionals 
particular partial evaluators rely reductions improve specialization phase 
example addition operation constant apparently unrelated term add normalization phase produces add specializes 
summary compilation normal forms characterizes critical aspects cps transformation relevant compilation 
formulates aspects way direct compilers easily 
result lead improvements traditional compilation strategies 
linear normalization linear normalization algorithm written scheme extended special form match performs pattern matching syntax program terms 
employs programming technique cps algorithms pioneered danvy filinski 
prevent possible exponential growth code size algorithm avoids duplicating evaluation context enclosing conditional expression 
assume frontend uniquely renames variables implies condition fv reduction holds 
acknowledgments olivier danvy preston briggs keith cooper comments early version 
aho sethi ullman compilers principles techniques tools 
addison wesley reading mass 
appel compiling continuations 
cambridge university press 
barendregt lambda calculus syntax semantics revised ed 
studies logic foundations mathematics 
northholland 
boehm demers implementing russel 
proceedings acm sigplan symposium compiler construction vol 
sigplan notices pp 

bondorf improving binding times explicit cps conversion 
proceedings acm conference lisp functional programming pp 

clinger scheme compiler exercise denotational semantics 
proceedings acm conference lisp functional programming pp 

danvy back direct style 
proceedings th european symposium programming rennes lecture notes computer science springer verlag pp 

danvy steps cps transformation 
tech 
rep cis kansas state university 
danvy filinski representing control study cps transformation 
mathematical structures computer science 
define normalize term lambda normalize lambda define normalize lambda match lambda params body lambda params normalize term body normalize lambda normalize normalize name lambda normalize term normalize term fn 
fn normalize name lambda fn normalize name fn lambda normalize name lambda define normalize name lambda normalize lambda value 
newvar define normalize name lambda null 
normalize name car lambda normalize name cdr lambda linear time normalization algorithm felleisen friedman control operators secd machine calculus 
formal description programming concepts iii amsterdam wirsing ed elsevier science publishers 
north holland pp 

clinger friedman haynes scheme version manual 
computer science technical report indiana university bloomington indiana feb 
fischer lambda calculus schemata 
proceedings acm conference proving assertions programs vol 
sigplan notices pp 

kelsey hudak realistic compilation program transformation 
conference record th annual acm symposium principles programming languages austin tx jan pp 

kranz kelsey rees hudak philbin adams orbit optimizing compiler scheme 
proceedings acm sigplan symposium compiler construction vol 
sigplan notices pp 

leroy zinc experiment economical implementation ml language 
tech 
rep inria 
plotkin call name call value calculus 
theoretical computer science 
sabry felleisen reasoning programs continuation passing style 
proceedings acm conference lisp functional programming pp 

technical report rice university 
shivers control flow analysis higherorder languages taming lambda 
phd thesis carnegie mellon university 
steele rabbit compiler scheme 
mit ai memo massachusetts institute technology cambridge mass may 
wand correctness procedure representations higher order assembly language 
proceedings conference mathematical foundations programing semantics brookes ed vol 
lecture notes computer science springer verlag pp 

weise advanced compiling techniques 
course notes stanford university 
