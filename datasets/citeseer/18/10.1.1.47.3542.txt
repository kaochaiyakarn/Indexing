user defined syntax annika aasa department computer sciences user defined syntax annika aasa department computer sciences chalmers university technology university goteborg dissertation ph degree computing science chalmers university technology department computer sciences goteborg sweden isbn goteborg thesis contained published papers ii annika aasa kent petersson dan concrete syntax data objects functional languages 
proceedings acm conference lisp functional programming snowbird utah july 
iv extended version annika aasa precedences specifications implementations programming languages 
proceedings third international symposium programming language implementation logic programming passau germany august lecture notes computer science springer verlag 
unpublished papers iii annika aasa conctypes extensions algorithms implementation annika aasa precedences context free grammars vi annika aasa recursive descent parser user defined distfix operators 
part licentiate thesis may department computer sciences chalmers university technology goteborg 
user defined syntax annika aasa department computer sciences chalmers university technology goteborg sweden mail annika cs chalmers se thesis describes examples user defined syntax 
thoroughly investigated new datatype construction conctype elements flexible syntax 
embedded language easily introduced programming language conctypes computations easily expressed concrete syntax special pattern matching form 
second example user defined distfix operators give user possibility extend syntax expressions programming language 
describe user view implementation examples 
cases context free grammars serve basis definition new syntax 
problem investigated disambiguate grammars precedences 
see done investigate language grammar precedence rules defines 
subclass context free grammars give predicate defines precedence correct syntax trees precedence rules 
give algorithm transforms grammar ordinary unambiguous contextfree grammar prove correctness algorithm 
algorithm implementation distfix operators 
general grammars isolate kind ambiguity suitable resolve precedence rules 
define generated language grammar attribute grammar 
approach resolving ambiguity implementation conctypes 
keywords phrases user defined syntax concrete syntax parsing grammars ambiguity precedence distfix operators inductive datatypes pattern matching earley algorithm recursive descent 
contents ii concrete syntax data objects functional languages concrete data types lexical analysis parsing type derivation user defined representation implementation related iii conctypes extensions algorithms implementation background special constructions sequence notation precedences parsing quotations type derivation type checker parsing quotations example parsing special constructions forgotten productions sequences parsing precedences implementation benchmarks conctype subset pascal conctypes example program interpreter iv precedences specifications implementations programming languages distfix grammars precedence definition precedence associativity correctness definition uniqueness precedence correct trees comparison operator precedence parsing transformation unambiguous grammar algorithm example correctness algorithm practical algorithm complete proofs lemmas complete proof algorithm proof proof lemmas precedences context free grammars notation ambiguity precedence grammars definition precedence informal description synthesized attributes inherited attributes formal definition inherited attributes synthesized attributes conditions example correctness parsers precedences precedences earley algorithm example correctness discussion precedences lr parsing application lemmas ii vi recursive descent parser user defined distfix operators introducing distfix operators parser user defined distfix operators example parser constructors translation syntax trees user defined infix operators user defined infix distfix operators complete distfix parser simplified version algorithm elimination left recursion parser summary bibliography iii iv advisor kent petersson 
appreciate patience silly questions encouragement believed researcher 
kent spent lot time discussions reading commenting different versions papers 
result valuable ideas comments 
author conctypes written time 
dan author conctypes 
implementation parsing algorithm conctypes 
unfortunately left department ideas comments theories things 
kent dan invited syntax group suggested implement user defined distfix operators 
chose parsing method recursive descent suggestion caused interesting problems 
worked conctype project originally idea 
privilege lennart augustsson corridor highly doing implementations lml 
answers questions interest comments conctypes 
mikael suggested improvements proof precedence removing algorithm am grateful careful reading valuable comments different versions papers contained thesis 
half year especially summer urban wonderful way helped reduce increasing feeling panic 
reading thesis comments 
bengt nordstrom encouragement believing finish thesis willingness help suggestion write program produces code parse trees magnus carlsson discussions type checking lena magnusson moral support clarifying things holmstrom year advisor thomas johnsson niklas thomas jan smith reading commenting papers 
wish members programming methodology group persons keep department computers going 
special due christer carlsson marie larsson 
am grateful family friends 
hope ph degree worth tears cost helped decrease number 
vi part user defined syntax annika aasa syntax programming language rules programs allowed written 
programming languages rules fixed 
thesis investigate different approaches letting programmer extend syntax programming language 
call user defined syntax 
reason wanting user defined syntax programming language simple fact syntax possibly include notation user may want 
desirable give user possibility extend syntax introduce new notation 
problem areas established notation programs 
example 
denote function updated value argument writing programs programming language facility introduce new notation possible 
function arguments example update user defined syntax save programmers 
frequent programming task write parsers 
parser takes string input string belongs certain set strings language parser outputs representation string 
exist tools automatically generate parser language description 
tools different reasons awkward parsers written hand especially relatively simple languages 
tools integrated programming language easier natural 
example restricted syntax elements user defined datatypes flexible necessary write parsers translate strings datatypes 
programming languages elements user defined datatypes restricted syntax 
user defined syntax enhance readability programs certainly desirable 
simple example feature enhances readability user defined infix operators 
expression repeated infix operators usually readable corresponding expression functions prefix notation 
programming languages allow user defined infix operators example algol sml lml haskell prolog objections allowing user extend syntax 
user may introduce new syntax way develop new dialect understands 
course possible forbid user introduce poor syntax purpose user defined syntax give user possibilities change language small extensions 
different kinds user defined syntax 
kind possibilities define embedded language programming language 
particularly useful writing programs manipulate languages example interpreters compilers 
parts thesis describe feature 
new datatype construction elements flexible syntax added functional programming language lazy ml lml aj aj 
new construction called concrete datatypes aps conctypes short 
kind user defined syntax give user possibilities extend syntax programming language 
example mentioned user defined infix operators programming languages allow 
generalization consider user defined distfix operators jon 
distfix operator operator distributed operands example construction 
programming languages allow user defined distfix operators 
done experimental implementation 
designer implementor user defined syntax decisions take problems solve 
kind objects user able define new syntax 
restrictions new syntax 
difficulty implementing user defined syntax features depends answers questions 
course possibilities user define new syntax 
preferable definition new syntax easy natural possible 
furthermore define new syntax require knowledge parsing formal language theory 
ordinary programmers knowledge able feature 
definition new syntax formal automatically analyzed 
definition contain information new syntax 
particular definition ambiguous 
user program analyzes definition may disagree meaning sentences 
language definition formalism natural readable understandable ordinary programmers automatically generate parser desirable 
problems finding language definitions investigated thesis 
conctypes parts thesis describe user defined syntax feature concrete datatypes conctypes aps 
elements datatypes programming languages usually written restricted form 
elements large soon unreadable user forced write parser transforms string element datatype 
strings seen concrete representation syntax datatype defines 
conctypes problem elements unreadable arise programmer defines concrete syntax 
compare datatype definitions ordinary conctype elements 
define small functional language 
examples written lml 
ordinary version type expr id string num int app expr expr mul expr expr div expr expr add expr expr sub expr expr eq expr expr expr expr expr string expr expr lam string expr element datatype fac lam eq id num num mul id app id fac sub id num app id fac add mul num num num conctype language defined conctype expr id number expr expr 
expr expr expr expr expr expr expr expr expr expr expr expr 
expr 
expr id expr 
expr id expr elements conctype readable fac fac fac assume id number defined conctypes 
conctypes supplied predefined conctypes 
enclosing elements brackets embedded language possible reserved words programming language elements 
symbols reserved words precedence information 
part thesis describes information resolve ambiguity 
precedence information needed ordinary datatype elements written prefix format 
easy define conctype 
notation close known bnf notation bac nau knu 
programmers problem understand notation 
conctype definition bigger definition corresponding ordinary datatype 
better syntax elements easily obtained 
extra writing compared parser needed ordinary datatype 
conctype corresponds context free grammar nonterminals correspond types 
types conctypes ordinary types 
possible polymorphic conctypes 
computations conctype elements easily defined 
functional languages computations preferably defined pattern matching 
special pattern matching form defining computations conctype elements 
antiquotation symbol lml variables patterns 
define function computes value expression conctype expr 
values elements ordinary datatype type value fn value 
value bool int function eval evaluates expression environment give values free identifiers expression 
represent environment function 
eval expr 
id value value rec eval id id eval toint eval fn eval eval eval eval eval eval eval eval eval eval eval eval eval sub eval eval eval eval eval case eval true eval false eval eval id rec update id eval eval eval id fn eval update id assume functions defined sub value theta value value toint number int update id value 
id value 
id value conctype nontrivial subset pascal interpreter bigger example conctype element appendix part iii thesis 
translation toint implicit necessary program 
grammars languages ambiguity precedences important question designing user defined syntax new syntax specified user 
mentioned desirable definition new syntax intuitive readable easy 
definition course contain information new syntax ambiguous 
context free grammars known formalism defining languages 
possible automatically generate parser context free grammar 
facts context free grammars useful language definitions user defined syntax 
examples user defined syntax conctypes distfix operators context free grammars basis definition new syntax 
problem context free grammars focus ambiguity problem 
grammar ambiguous generates sentence parse tree 
simple example int id sentence example different parse trees ambiguous grammars undesirable different representations different meanings usually want exact meaning sentence 
values interpreted usual parse trees differs example 
user defined syntax definitions context free grammars different solutions problem ambiguous sentences ffl definitions unambiguous context free grammars 
unfortunately unambiguous context free grammars natural ones 
unambiguous grammar generating language ambiguous int id written grammar binding power operators usual 
show part iv unambiguous grammars surprisingly complicated 
example language generated productions ambiguous grammar require productions unambiguous grammar see section part iv 
number required productions depend desired structure parse trees 
reasons unambiguous context free grammars unsuitable 
conctype unambiguous grammar computations elements complicated 
explained part iii 
definition distfix operators described part vi fact language distfix operator expressions defined grammar single nonterminal 
definition new distfix operator done simple way 
underlying grammar ambiguous hard see simple definition possible underlying grammar unambiguous 
ffl allow definition ambiguous require sentences unambiguous 
ambiguous sentence considered incorrect 
solution implies sentences hard read 
sentence generated ambiguous grammar page ambiguous allowed case 
fully parenthesized sentence 
grammars may exist corresponding unambiguous alternative 
example remove production parentheses example grammar 
ffl languages easily represented ambiguous grammars common solution ambiguous grammar augmented extra information telling structure ambiguous sentences 
ambiguous grammar page example extra information saying productions different precedences 
benefit solution grammar concise unambiguous 
drawback clear language grammar generates 
chosen solution resolve ambiguities user defined syntax conctypes distfix operators 
parts thesis investigate different aspects method 
decide kind ambiguities resolve disambiguation user fixed rules 
consider disambiguating rules user 
ambiguities consider kind really choice different possible representations natural 
questions disambiguating information important question language generated 
part iv solutions questions suggested 
suggestion part disambiguate conctypes 
obvious define language grammar disambiguating information generates 
common definition terms parsing method 
apart methodology objection language definition involve method recognize language dependency parsing method disadvantages 
disambiguation depends parsing method understanding disambiguation works clearly requires knowledge method 
knowledge understand language definition 
second hard implementor change parsing method preserve disambiguation properties 
thesis ways define language grammar disambiguating rules generates 
part iv consider subclass context free grammars 
generated language defined terms contextfree grammar predicate 
part general grammars considered 
attribute grammar formalism knu knu define language context free grammar disambiguating information generates 
definitions ideas common 
cases examples theorems motivate definitions reasonable 
having grammar disambiguation information definition language grammar generates problem construct parser language 
different ways solve problem ffl transform grammar ordinary unambiguous context free grammar ordinary parsing method 
solution usually chosen parsing method recursive descent dm 
transformation easy 
part iv algorithm transforms grammar infix prefix postfix operators different precedence unambiguous context free grammar 
part vi algorithm construct recursive descent parser 
ffl modify parsing method incorrect parse trees thrown away parsing 
common method ear sha wha 
usually parser constructed definition language parser said define language 
part show earley algorithm ear extended recognize language defined precedence grammar 
precedence grammars language generate defined part 
ffl transform grammar simple unambiguous grammar necessarily express correct structure sentences 
ordinary parser resulting parse tree transformed correct disambiguation information 
example method described lalonde des rivieres ldr 
ffl parsing method handle ambiguous grammars construct parser ambiguous grammar disambiguation information 
incorrect parse trees thrown away parsing 
related programming languages allow user defined infix operators example algol prolog ss sml mth lml aj haskell hea 
ada ge str possible overload predefined operators possible define new ones 
lml allow user defined prefix postfix operators 
languages provide user defined distfix operators 
examples obj hope bms 
implementations distfix operators seldom described literature jon description distfix operators parsed yacc joh 
infix operators constructors example sml mth object language defined 
language bit flexible syntax language defined prefix constructors syntax limited 
example hard constructors interfere constructions programming language 
constructor part object language parts constructor concrete syntax example application 
limitations remain distfix constructors 
parser tools developed years 
lalr parser generator yacc joh widely available 
file containing yacc specification language transformed program 
lex les lexical generator yacc 
implementations ml sml new jersey am caml inria paris ch wal parser generators style yacc implementations 
wand wan implemented system scheme yacc generate parser translates concrete syntax 
fpg functional parser generator 
written generates code lml 
jacobs gj implemented parser generator produces ll parser 
experimental programming language san combines syntax directed translation classes allow user choose syntax 
system voi system incremental grammar construction expression parsing allows flexible syntax 
caml system contains facility define parsers printers mau mdr 
special pattern matching stream datatype 
way writing parsers functional languages kind parser constructors explored burge bur petersson holmstrom pet fairbairn fai rea 
edinburgh lcf system gmw elements object language entered concrete syntax computations defined syntax 
furthermore lcf contains contains fixed object language 
konrad slind working generalizing ideas sli compiler support user defined parsers pretty printers soon available sml new jersey 
approach similar conctypes implemented dml system pf pf 
different parsing method dml system sophisticated lexical analyzer 
difference dml keywords denoted string literals ml objects 
leads readable syntax descriptions expressing large elements keyword denoted string literal awkward 
conctype elements antiquotation symbol indicate ml objects 
possible resolve ambiguities precedences dml system 
syntax definition formalism sdf possible priorities resolve ambiguities 
notation priorities concise notation precedences conctypes 
furthermore disambiguation correctly prefix postfix operators 
descriptions construct parser ambiguous grammar disambiguating rules ear ldr sha wha 
overview thesis divided parts parts numbered ii vi 
part ii concrete syntax data objects functional languages part introduces conctypes 
examples conctypes computations elements 
strong correspondence grammar conctype shown conctypes fit type system 
explained briefly conctype elements parsed 
part iii conctypes extensions algorithms implementation part describes parsing algorithm conctypes 
parser generalization earley algorithm integrated polymorphic type checker 
extensions conctypes implement described 
part iv precedences specifications implementations programming languages part contains aspects concerning precedences distfix grammars subclass context free grammars 
parser independent definition languages generated distfix grammars precedences 
argue definition reasonable number examples theorems 
second show transformation distfix grammar operators different precedence unambiguous context free grammar quite complicated 
algorithm transformation correctness proved 
part precedences context free grammars part considers precedences general grammars distfix grammars introduced part iv 
kind ambiguity suitable resolve precedences 
meaning grammar precedences terms language generated attribute grammar 
argue theorems definition reasonable 
part describes earley parsing algorithm extended handle precedence rules 
indicate rules lr parsing 
part vi recursive descent parser user defined distfix operators part application algorithm part iv 
parser user defined distfix operators described 
new distfix operator specified operator words example optionally precedence associativity 
declarations essentially distfix grammar precedences transformed unambiguous grammar build parser parser constructors construct recursive descent parser 
part ii concrete syntax data objects functional languages concrete syntax data objects functional languages annika aasa kent petersson dan functional languages construction define inductive data types hoa called general structured types jon structures lan datatypes mil free algebras 
inductive definition data type seen grammar language elements data type phrases language 
defining inductive data type seen introducing embedded language values programming language 
correspondence fully exploited existing functional languages 
elements presently written restricted form 
just parse trees elements written prefix form 
generalization consider allow elements written general form 
directly writing parse trees embedded language concrete syntactical form automatically generated parser translate concrete syntactical form corresponding parse tree 
think especially useful manipulate languages programs example implementing compilers interpreters program transformation systems programming logics 
convenient want concrete syntax kinds data program 
allowing distfix operators programming language jon possible achieve goals 
problem symbols comprising distfix operator interfere constructions programming language 
want represent programs language language problem acute 
example represent arithmetic expressions inside functional language difficult impossible situation expression evaluates integer value represents arithmetic expression 
solve problem different ways 
say distfix operator built identifiers programming language clear distinction programming language metalanguage represented language object language 
course relax situation case little allowing overloaded identifiers operators metalanguage hard imagine pure syntactical constructions metalanguage example reserved words overloaded 
published proceedings acm conference lisp functional programming concrete data types start introducing syntactical construction favorite functional language ml define concrete data type binary numbers conctype binnumber binnumber binnumber compare type definition context free grammar binary numbers binnumber 
binnumber binnumber confuse symbols defined language object language ol symbols programming language meta language ml enclose elements quotation brackets 
notice nonterminals grammar correspond types type definition 
intention introduce data type binary numbers elements written familiar way 
program write elements 
name quotation expression new form expression 
want able define computations elements need construction separates different forms binary number take selects components particular form 
modern way functional language pattern matching 
introduce pattern matching form elements type defined new constructor 
pattern sentential form language defined concrete datatype ordinary ml patterns type nonterminals patterns may contain ml patterns antiquotation symbol write ml variables patterns object language phrases 
variables written just antiquotation symbol complicated patterns enclosed parentheses 
blanks variable ignored 
examples patterns concrete datatype binary numbers 
name quotation pattern new form pattern 
construction possible write function takes binary number argument gives successor result fun succ succ succ succ succ notice antiquotation symbol quotation expressions right hand sides function definition 
example quotation expression intended construct phrase value bound ml variable symbol 
variable course bound value ignore binary numbers free data type 

concrete data types type binnumber value expected position 
secondly complicated expression succ ml expression succ evaluated value type binnumber number composed symbol produce binary number 
ml expressions inside quotation evaluate complete phrases language strings characters 
patterns function definition need directly correspond cases definition concrete datatype seen example fun div true div false pattern matching concrete syntax important approach representing object languages 
introduce somewhat arbitrary names operations decides form element operations selects components compound element 
compare quotation brackets antiquotation symbol corresponding constructions edinburgh lcf system gmw quine quasi quotation qui 
second example consider implementing denotational description simple imperative language 
define language conctype pgm program cmds 
cmds cmd cmd cmds cmd bexp 
cmds 
cmds 
fi bexp 
cmds 
var exp exp var integer exp exp exp exp exp bexp exp exp bexp bexp bexp bexp bexp assume defined concrete datatypes var integer function toint maps concrete integer corresponding ml value 
concrete datatype defined define interpreter natural way 
notice definition close gordon describes denotational semantics language gor 
assume implemented data type states operations update valof 
fun program cs cs cs cs cs cs cs cs fi cs cs cs fun cs cs update valof toint orelse andalso example raises problem decide different patterns means 
second cases definition just consist ml variables problem decide variable case second integer case 
information type inference mechanism choose possibilities 
pattern parsed typechecker typechecked right hand sides definition know case type var second type integer 
information possible distinguish case pattern supposed denote 
course possible try define function decide cases patterns supposed denote 
take example definition function counts number variables expression fun vars vars vars vars vars vars vars vars vars vars example impossible choose cases variable name indicate type denotational descriptions fortran 
solution allow user explicitly type variables 
cases definition written fun vars var vars integer 

lexical analysis consider error information parse quotation pattern unambiguously 
problem want define function fun true false type checker quotation parser give unique type variables type var integer exp pattern ambiguous erroneous 
unambiguous user provide type information 
notice type information distinguishes restrictive pattern var var exp exp 
problems ambiguities patterns discussed 
concrete data types fit nicely ordinary ml example define polymorphic concrete data types trees information nodes 
conctype tree tree tree elements string tree binnumber tree function swaps left right part tree fun seen string tree example possible ordinary ml types defining concrete types 
lexical analysis obvious treated lexical token embedded languages 
order flexible allow different concrete data types possible decided view character lexical token 
exceptions sequence blanks treated blank escape character gives character literal meaning 
result blanks handled nicely 
want blanks quotation expression blank character corresponding position grammar blank grammar blank quotation 
having sophisticated lexical analyzer give problem 
parts lexical token grammar 
example ml lexical analyzer system inr define binary numbers section sequence zeros ones treated integer ml 
best solution probably give user possibility define lexical analyzer 
parsing type derivation section describe new constructions translated compilation ordinary data types constructors 
compilation new constructions remains effect execution speed new syntactical constructions 
program concrete datatypes quotations anti quotations runs speed 
give overview translation process 
concrete datatype translated objects 
ffl datatype definition seen type parse trees language defined grammar concrete datatype 
ffl parser recognizes language described grammar translates phrase language parse tree 
ffl pretty 
printer prints elements concrete datatype concrete syntax 
type definition binary numbers conctype binnumber binnumber binnumber translated datatype definition 
datatype binnumber binnumber binnumber binnumber binnumber binnumber binnumber parser example translates binnumber binnumber binnumber parser compiler translate quotation patterns quotation expressions ordinary patterns expressions 
example function fun succ succ succ succ succ translated fun succ binnumber binnumber succ binnumber binnumber binnumber succ binnumber binnumber succ binnumber binnumber succ 
parsing type derivation usually syntax ml program checked distinct steps 
parsed context free parser typechecked type checker utilizing milner algorithm mil 
simple sequence longer possible concrete data types added ml parsing concrete element depends type 
concrete expression context element type expected parsed start symbol 
correspondingly type ml expression quotation dependent parsing quotation 
achieve integrate parsing concrete elements milner type derivation algorithm 
built parser generalized version earley algorithm ear 
generalized reasons ffl concrete data types seen grammars powerful context free grammars earley algorithm constructed 
stems fact polymorphic concrete data types 
simple example language defined polymorphic data type context free grammar trees introduced section 
ffl parser defined earley algorithm usually takes sequence lexical tokens input gives parse tree output 
parser want take sequence lexical tokens ml objects input give ml expression output 
algorithm developed differs earley type variables nonterminals instantiated parsing 
example conctype conctype list list conctype input instantiated support item earley algorithm contains apart dotted production item set pointer type substitution 
substitutions handled way parsing operations ffl predict operation earley algorithm item added predicted item 
version new item created initial substitution 
information substitution inherit predicting item chance share 
assure maximal sharing item start empty substitution 
dot left uninstantiated type variable conctypes known context predicted 
ffl completion item return item set pointed add updated versions items type right dot unified type just completed 
item property sure fresh variables type variables unification 
update moving dot step right compose substitution substitution illustrate example corresponding input conctype conctype list list get item sets delta 
list list 
delta list 
delta 

list list 
delta list delta 
list 
delta 
list 
list list 
delta list 
delta 

list list 
delta list 

list delta 
list 
list list 
delta 
list 
list list deltas 

list 
list list 
delta 
list 
list 
list 
list list 
delta list 
delta 

list composition substitutions written ss substitution obtained milner type derivation algorithm applied ml parts program 
notice unify left hand side production type right dot get substitute new variable 

user defined representation explain expressions input 
expression type viewed parsed part input accepted item item set dot left type unified illustrate grammar input int delta 
list list 
delta list 
delta 

list list 
delta 
list 
int list 
delta list 
delta 

list list 
delta list 

list delta 
int 
int list 
delta 
list 
list list delta 

int 
int list 
delta 
list 
int list 
int 
int list 
delta list 
delta 

list user defined representation previous section described elements concrete datatypes represented 
representation bit inconvenient want represent sequences ml lists forget productions grammar 
differences representation indicated constructions definition conctypes 
productions containing terminals purpose indicate structure sentence course unnecessary sentence represented tree 
take example parentheses arithmetic expressions 
denotational description section clauses exp bexp want parentheses elements concrete datatypes exp bexp 
productions remain representation cases interpreter 
eliminate introduce notation indicate production remain representation 
dots stands arbitrary terminal symbols 
denotational example written exp 
exp bexp 
bexp parentheses may occur quotation expressions 
eliminated parsing appear quotation patterns 
situation possible forget productions way course clause just contains nonterminal conctype just defined 
grammars special notation sequences 
cmds cmd conctypes described far recursion define sequences 
example denotational description section sequence commands defined conctype cmds cmd cmd cmds sequence commands represented term cmds cmds cmds having representation explicit recursion defining computations elements 
represent sequences ml lists possible predefined list handling functions 
representing sequences ml lists necessary exclude terminals separate elements 
somewhat different notation sequences ordinary grammar descriptions 
cmd nonterminal inside curly brackets defines elements sequence 
terminals nonterminal dots separators elements sequence 
denote repetition times 
possible denote zero times 
notation command sequence denotational description defined 
user defined representation conctype pgm program cmd conctype cmds longer necessary 
function cs interpreter 
define function fun program cs cs predefined list handling function 
conctype pgm translated datatype datatype pgm pgm cmd list list notation definition language conctypes comprehensible 
procedure head simple imperative language list notation defined conctype proc id proc id parlist parlist id typeid id typeid defined conctypes 
element type proc int ch char function counts number parameters fun proc id proc id ps sum map fn ids 
length ids ps sum map length predefined list handling functions 
list notation conctype definition defined conctype proc id proc id parlist parlist idlist typeid idlist typeid parlist idlist id id idlist function counts number parameters fun proc id proc id ps ps fun ids ids ids ps ids ps fun id id ids ids previously mentioned considered error quotation expression parsed uniquely 
desirable unambiguous conctypes 
consider arithmetic expressions 
unambiguous conctype contain lot nonterminals productions irrelevant representation 
function definitions quite complicated 
precedences associativity rules resolve ambiguities define language complicated conctype natural patterns 
desirable extension give user possibility giving precedence associativity rules productions conctypes 
completely different representation obtained defining datatype function maps concrete object new representation 
example want represent binary numbers integers define function maps concrete data type binnumber corresponding integer 
fun compare definition yacc 
zero zero implementation constructions described section implemented functional language lml aj aug examples section tested implementation 
constructions described section implemented 
lml input output user defined datatypes bothered generate pretty printers conctypes implementation 
related system explicit notion metalanguage object language edinburgh lcf system gmw 
contrast proposal lcf contains fixed object language 
furthermore object language represented type defines syntax language concrete syntax quotations seen just convenient way user enter elements type 
define computations uses object language constructors selectors 
syntax user remember concrete syntax object language 
system inria inr hue user easily define object language interface ml version yacc 
concrete syntax seen convenient form write syntax trees computations expressed terms constructors selectors syntax 
quotation patterns available 
wand wan implemented similar system scheme yacc generate parser translates concrete syntax 
limited way define object language infix operators constructors ml mil 
type declaration arithmetic expressions involving integers operators ml defined infix datatype expr num int op expr expr op expr expr function evaluates expression fun num way making elements datatype concrete number disadvantages 
ml allow overloading symbols constructors 
choose symbols example example 
constructor part new language want define parts constructor concrete syntax integer case example 
expression written num num num 
want write expressions familiar way write parser translates strings elements datatype 
implement constructions described section user defined representation 
define implement constructions expressing priorities associativity 
problems lexical analyzer investigated 
interesting question notion subtype fm resolve problems ambiguities patterns described 
members programming methodology group goteborg help encouragement 
particular lennart augustsson support help provided implementation holmstrom useful comments 
part iii conctypes extensions algorithms implementation conctypes extensions algorithms implementation annika aasa background new datatype construction conctype aps elements flexible syntax described part ii thesis 
brief part conctype definition corresponds grammar nonterminals correspond types 
types conctype definition need conctypes ordinary types 
may define polymorphic conctypes 
elements conctypes quotations enclosed brackets translated corresponding syntax compiler 
appendix give conctype subset pascal quotation interpreter language 
conctypes fits nicely ordinary type system parsing quotations integrated ordinary type checking parsing quotation determines type dependent types context 
part describe parsing type checking algorithm 
reconsider special constructs mentioned briefly described part ii describe implemented 
special constructions part ii described occasions automatically obtained representation bit inconvenient 
sequences preferably represented lists forget productions 
mentioned problem ambiguous conctypes 
part reconsider sequence notation describe possible patterns detail 
describe precedences resolve ambiguities 
implementation features described section 
sequence notation languages contain sequences different objects 
example pascal find sequences type procedure function definitions formal actual parameters statements 
defining sequences grammar explicit recursion special notation 
sequence statements example defined program statement statement program statement statement special notation sequences advantage decreasing number nonterminals grammars enhances readability 
sequences special notation eliminates nonterminals 
conctypes reason special notation sequences 
representation obtained explicit recursion explicit recursion defining computations elements 
better represent sequences lml lists list handling functions possible 
elements sequences separated terminals 
var integer sequence variables separated commas var integer ch char ready boolean sequence variable declarations separated semicolons representing sequences lml lists convenient exclude terminals separate elements 
somewhat different notation sequences ordinary grammar descriptions type inside curly brackets defines elements sequence 
terminals type dots separators elements sequence 
denote nonempty sequences possibly empty sequences 
pascal variable definition part sequence notation defined conctype var conctype 
type 

type 
conctype id id assume id type defined conctypes 
sequence notation definition comprehensible conctype var conctype id type elements sequence defined type 
possible terminals mixture nonterminals terminals 
reason restriction elements sequence type name 

special constructions conctype previous example necessary 
var id type illegal 
mentioned part ii conctype associated type quotations translated elements type compilation 
associated type conctype containing sequence notation constructors lml lists arguments just elements conctypes 
conctype exp contains sequence notation conctype exp num var exp def conctype def var exp associated types conctypes exp def type exp exp num exp var exp exp list def type def def var exp antiquotation type list occur position sequence notation type elements sequence 
consider pattern conctypes exp def ds parsing type checking variable assigned type exp ds type list def 
possible complicated position sequence notation long type correct example note semicolon lml list element separator 
complicated patterns possible 
remember occur positions nonterminals corresponding sentential form quotation 
right hand side exp def example derive sentential forms exp def exp def 
exp def 
def exp def 
def 
exp def 
def 
def 
possible patterns ds 
seen sentential forms example denote element list type def case rest list type list def 
denoting resolvable context explicit typing 
patterns corresponding complicated sentential forms example id id ds chosen terminals inside curly brackets separate elements sequence case sequences 
sequence notation course sequences separator elements 
sequence notation terminals conctype dots 
problems sequence notation sequences element ends having separators elements 
separator just repeated sequence notation 
fact sequence hard distinguish sequence elements separated terminals followed terminals 
example pascal type definition part conctype type typedef conctype typedef id type interpretation type definition ends semicolon 
sequence type definitions separated semicolons semicolon ends type definition part 
regardless interpretations notation 
note semicolon remains representation patterns written type precedences quotation parsed uniquely ambiguity resolvable context considered error 
ambiguity resolved context quotation parsed different ways parses type 
consider example conctype simple arithmetic expressions conctype exp int exp exp exp 
special constructions exp exp exp exp exp exp quotation ambiguous ambiguity resolved context corresponding context free grammar ambiguous 
quotations derived conctype exp ambiguous order conctype unambiguous way 
rewriting order unambiguous structure parse trees desired forces introduce lot new conctypes conctype exp exp term exp term term conctype term term fact term fact fact conctype fact int exp new types irrelevant representation function definitions quite complicated example interpreter rec unambiguous conctype complicated forces computations complicated 
way grammar conctype unambiguous 
precedence associativity rules disambiguating 
obvious kind ambiguity possible suitable resolve precedences 
decidable grammar ambiguous au flo 
think impossible resolve ambiguity precedence rules 
part thesis notion ambiguity defined 
kind ambiguity arises fact grammar generates ambiguous parse trees 
ambiguous parse tree contains subtree forms motivations ambiguities suitable resolve precedences definition means give precedences productions part precedences alternatives nonterminal left right recursive 
conctypes approach resolving ambiguity precedences 
sign indicates production higher precedence previous 
sign indicates production equal precedence previous 
production marked sign associativity 
done reserved words indicating production left associative right associative nonassociative 
production having precedence production associativity 
unambiguous conctype arithmetic expressions written 
conctype exp int exp exp exp exp exp exp exp exp exp grammar contains conctype left right recursive precedences different conctypes 
conctype exp bexp int bexp true false bexp bexp bexp bexp bexp bit unusual convention example higher precedence 

parsing quotations type derivation note production bexp precedence 
necessary derivations bexp bexp ff bexp ff bexp polymorphic conctypes precedences way 
parsing quotations type derivation parsing quotations integrated type checking parsing quotation determines type dependent types context 
type checking quotation means parsed type checked 
reasons ordinary parser context free grammars parse quotations 
ffl conctypes polymorphic powerful context free grammars 
variables conctypes conctype seen special case level grammar cu 
ffl input arbitrary sentential forms consisting solely terminal symbols quotation contain lml objects 
handle points chosen generalize earley context free parsing algorithm ear 
motives chosing earley algorithm general context free parsing algorithm restrictions context free grammar conctype 
algorithm handle ambiguous grammars 
algorithm quite simple expect hard generalize 
type checker damas milner algorithm dm mil augmented handle ambiguous quotations 
quotation parsed ambiguously compared overloaded symbol 
meaning overloaded symbol resolved type information context 
similarly type quotation determined context 
type checker polymorphic type checker usually car dm mil jon takes type environment expression type checked argument returns type substitution type expression expr 
subst theta type variant described rea substitution argument 
type environment contains assumptions type identifiers 
substitution map type variables types 
denote type variables substitutions 
important functions type checker involving substitutions unify type type subst combine subst subst subst explain functions briefly omit details 
function unify takes type expressions argument unifies 
result substitution applied type expressions equal 
example unify list theta list int types unifiable unify fails gives special bad substitution result 
function combine combines substitutions 
example combine list int bool list int int bool juxtaposition shorthand function combine 
important note combine may fail give special bad substitution result 
example combine int bool bad substitution variants functions 
hancock jon chapter describes example type checker function unify takes substitution argument 
type checker takes additional argument compared usual ones expected type expression 
known type expected type simply type variable 
main reason expected types explicit typing expressions improve execution speed type checker 
expressions different types type checker returns list possibilities type check expression 
possibility consists substitution list parsed translated quotations appear expression 
phase compilation parsed expressions substituted quotations 
expr expected type list list expr theta subst type checker patterns returns variable type association variables bound pattern types 
pattern expected type list list pattern theta theta subst illustrate type checker works examples 
examples conctypes conctype var conctype int var conctype bool var int bool predefined ordinary types integers booleans lml 

parsing quotations type derivation start expression suppose information type expression context type checker gets type variable expected type 
applications type check argument 
regardless expected type application know argument type checked fresh type variable expected type 
result type checking expected type substitution int 
information type checking type application expected type argument int know type abstraction int expected type abstraction 
leads type checked expected type type environment type int 
type checking means parsed type int possible way parse 
substitution result get type abstraction int note expected type abstraction possible types 
int 
var 
bool 
var expression gets type translated quotation result associated constructor production int parsing 
consider slightly different application argument case possible types var result type checking expected type follows type checking expected type possibility translated quotations substitution type var var var var var type expected type type checking abstraction 
solution type variable abstraction time type checked expected type quotation type checked expected type type environment type parsing ambiguous type checking expected type type environment type possibility translated quotations substitution type int var bool var possibilities remain abstraction type checking nx expected type possibility translated quotations substitution type int int var var bool bool var var application check substitutions possible combine 
case possible combine possibility type checking possibility type checking type checking nx expected type possibility translated quotations substitution type var var ambiguity hopefully resolved 
error message 
possibility give type information explicitly type expression course explicitly typed expression explicit type expected type expected type application case argument type checked type variable expected type course ambiguous way 
abstraction type checked expected type quotation expected type results type checking expected type type environment type possibility translated quotations substitution type int var type checking nx expected type possibility translated quotations substitution type var var int int 
parsing quotations type derivation combining substitutions application possibility left 
type checking nx expected type possibility translated quotations substitution type var complicated expression type check case expression 
case ce 
type checking case expression case possibility list consisting translated quotations substitution pattern type expression type 
clause type checked list updated impossible combinations thrown away 
case possibility list contains element types expected types type checking pattern expression substitution applied type environment 
initial case possibility list possibilities resulting type checking choice expression expected type case expression 
cases choice expression type checking possibility 
pattern type checked unambiguously expression type checked type environment variables pattern possible types 
pattern type checked ambiguously corresponding expression type checked type environment variables fresh type variables types 
information possible types type variables held substitutions possibilities type checking pattern 
consider abstraction 
case eval eval assume eval type int type environment expected type irrelevant parts substitutions omitted examples 
initial case possibility list element initial case possibility list case expression 
possibility translated quotations substitution pattern type expression type pattern ambiguous right hand side resolve ambiguity case possibility list clause contains possibilities case possibility list type checking clause 
possibility translated quotations substitution pattern type expression type int int var var bool bool var var possibility fresh type variables expected types type checking second clause 
second pattern ambiguous parsed different ways 
parsing possibilities 
right hand side resolves ambiguity obtained possibility resolve ambiguities case possibility list second clause contain element case possibility list type checking clause 
possibility translated quotations substitution pattern type expression type bool bool list contains element know type pattern expression 
clauses expected type type checking patterns bool type checking expressions 
substitution results type checking case expression deduce abstraction type bool 
parsing quotations parsing quotation expression aims determine type quotation translate element ordinary type 
parsing quotation pattern additional aim assign types variables pattern 
original algorithm earley takes grammar input string argument 
version takes type environment expected type argument 
type environment needed type check expected type restrict number conctypes checked possible types 
parsing quotation seen problem determine conctypes derive quotation 
conctypes seen possible start symbols 
expected type restricts number start symbols 
result parsing list possibilities parse quotation 
possibility consists translated expression type substitution 
possible type quotation obtained applying substitution possibility expected type 
grammar quotation expression expected type list expr theta subst generalized version works original algorithm processing set item sets input symbol 
item contains production currently trying recognize right hand side part input string 
dot production indicates right hand side recognized far 
item contains pointer back position input string began look production 
dotted production backward pointer items 
parsing quotations type derivation version contain substitution associated constructor production 
parsing patterns item contains variable type association 
item components hc es ffl fi ii associated constructor production left hand side conctype dotted production es sequence parsed substrings translated lml expressions fi sequence types terminals substitution backward pointer 
dot production recognized constructor applied expression sequence es new expression es built 
original algorithm processing starts item set item alternative start symbol dot 
generalized version items alternatives conctypes unified expected type initially added item set 
usual dot new right hand side 
substitution initial item obtained unification conctype expected type 
substitution applied types productions 
illustrate examples 
suppose conctypes conctype sym conctype tree tree tree example quotation parsed type variable expected type 
means known type quotation context 
items productions added initial item set initial item set expected type sym sym ffl sym sym sym ffl sym tree tree tree tree tree tree tree second example expected type tree conctype sym unifiable items productions conctype tree added initial item set initial item set expected type tree tree tree tree tree tree third example expected type 
conctype tree unifiable case add instantiated items initial item set expected type 
tree tree int int original algorithm parsing proceed operations predict scan complete item sets built 
operations changed bit handle substitutions items input string 
changes shortly predict usual operation predict applicable dot front type just adding items alternatives add new items conctypes unifiable scan operation scan usually applicable dot front terminal input symbol terminal 
version operation scan applicable dot front type input symbol antiquotation 
possible type antiquotation unified type dot involved substitutions combined new item added item set 
call variant operation scan 
complete item item set pointed predicted completion item 
possible unify type dot recognized type combine involved substitutions 
soon new substitution obtained applied types sequence dot 
reason information possible parsing rest item 
example consider item tree tree ffl tree tree suppose obtain substitution int performed 
information try recognize rest item 
item added item set tree tree ffl int int domain substitution item greater set type variables production due 
consider example expression type checking abstraction variable assigned type 
expected type abstraction function type immediately leads type error type type variable say antiquotation type checked type environment type result type checking antiquotation obtain substitution int 
substitution appear items parsing succeed 
type checked item set processed 
input symbol processing item set terminal symbol antiquotation associated list possibilities obtained type checker 
possibility consists list translated quotations substitution type antiquotation 
antiquotation type checked type variable expected type 

parsing quotations type derivation disadvantages type check antiquotation part operation type dot expected type 
applicable item case type checked 
efficient 
type checker case find type need type error program 
may exist items operation applicable possible expected types 
finished possible types quotation expression conctypes appear left hand side item set 
quotation ambiguous 
suppose items item set parsing item set es ffl es ffl constructors applied expression sequences result parsing obtain result parsing 
possibility translated quotations substitution type es es detailed information operations seen table 
operations predict complete scan operations handle list constructions conctypes 
described section 
operations items item set operation applied effect predict dot front type hc es ffl bfi ji 
production fl unified yielding substitution add item hc ffls fl ii item set constructor associated production 
introduce fresh type variables predicted items 
scan dot front terminal hc es ffl afi ji input symbol position add item hc es ffl fi ji item set 
dot front type hc es ffl bfi ji input symbol position antiquotation possible parsings es substitutions types unify yielding substitutions possible combinations add item hc es es ffl fi ji item set 
operations items item set operation applied effect complete dot hc ji 
consider items hc es ffl fl ki item set predicted item 
unify yielding substitution possible combinations add item hc es es ffl fl ki item set fresh type variables item unification 
es denotes expression expressions expression sequence es substituted quotation occurrences denotes result applying substitution type ff denotes result applying substitution types ff example suppose conctype conctype parse quotation expected type initially item set ffl ffl notice introduced fresh type variables item 
operation predict applicable second item dot front type variable add items conctypes item set cont ffl ffl note items added empty substitution 
ignore operation complete applicable third item lead 
operation applicable items dot front type variable input symbol antiquotation type int get item set item set ffl int int int ffl int int 
parsing quotations type derivation note obtained substitution int applied types dot item 
operation scan applicable items item set ffl int int int ffl int int terminal symbols just disappear 
dot front instantiated type result operation predict instance type added item set cont int ffl int ffl int int ignore operations complete 
item set operation fails move dot type int int unified int type antiquotation 
operation applicable item dot front type int item set int ffl int applying operations scan predict item set int ffl int int ffl int ffl int int operation complete applicable second item item set 
item set cont int ffl operation complete applicable 
item set cont ffl int int ffl int result applying operation complete item items item set added applicable 
applying operation scan item item set dot front symbol ready 
item set ffl int int result parsing result parsing expected type possibility translated quotations substitution type int int int parsing special constructions described section special constructs sequences precedences part ii described forgotten productions 
section describe constructs handled parser 
forgotten productions notation double square brackets example production defining conctype means production remain representation 
suppose normal parse tree sentence production sequences terminals marked forgotten parse tree want sentence translating parse trees quotation expressions means associated constructor forgotten production appear translated expressions 
suppose translated expression forgotten productions expression constructor associated forgotten production effect achieved parsing adding boolean component item earley algorithm 
new item constructed production grammar component set true production forgotten 
operation complete constructor applied list parsed expressions boolean component true 

parsing quotations type derivation sequences recall sequence notation conctypes define nonempty sequence separated sequence notation introduce nonterminal generates sequence handling sequences earley parser closely related correspondence 
example process item es ffl ff effect processing item replaced new items 
es ffl ff es ffl ende ff number denotes number times replacement occurred 
counter dot front new symbol ende es delta delta delta ffl ende ff sequence parsed parsed elements sequence delta delta delta dot 
effect processing item lml list containing elements delta delta delta constructed es delta delta delta nil ffl ff replacements sequence notations may applicable dot front sequence element 
recall notation compared conctype generates sequences type list 
operation may applicable item es ffl ff requirements input symbol antiquotation type unifiable list obtained substitution combinable result item added item set es ffl endl ff ss difference symbols ende endl endl regard element sequence parsed elements list element list 
result processing item es delta delta delta ffl endl ff replaced item es delta delta delta ffl ff notation possibly empty sequences corresponds ffl nonterminal defines possibly empty sequences separated semicolon 
note nonterminal defines nonempty sequences separated semicolon 
effect processing item es ffl ff replaced new items es nil ffl ff es ffl ff item corresponds epsilon production ffl second production 
parsing precedences handle precedence rules described section new components added items earley algorithm algorithm augmented components throw away undesirable parse trees 
done described part thesis 
implementation implementation conctypes described done functional language lml aj aj available lml distribution examples implementation 
benchmarks compilation execution lml program containing conctypes quotations slower corresponding program containing ordinary datatypes values 
corresponding program mean program conctype replaced ordinary type quotation replaced corresponding element 
difference greater longer quotations 
table give compilation times example programs 
example give time program conctypes corresponding program conctypes 
compilation done sun sparcstation times seconds 
available anonymous ftp ftp cs chalmers se 

benchmarks program conctype version normal version quicksort element interpreter interpreter quicksort element conctype expr interpreter fac element examples variants program appendix example conctype expr part thesis interpreter quotation containing fac function 
named functions explicitly typed 
compiling program explicit typing takes little bit longer time 
example unnecessary typing takes seconds compile 
comparing conctype version normal version bit unfair program contains big quotation 
example dare ordinary element corresponding quotation containing quicksort procedure 
example program automatically generated 
parser time compiling parser included 
parser quotations extension earley algorithm earley algorithm efficient parsing method 
parsing method compilation may efficient 
sophisticated lexical analyzer may improve compilation times 
appendix conctype subset pascal appendix define subset pascal wir conctype 
call subset pascal 
size subset pascal appendix dragon book asu allows nontrivial programs expressed 
example give quotation containing quicksort procedure 
give interpreter pattern matching concrete syntax 
program consists sequence variable declarations sequence procedure function declarations single compound statement 
standard types integer boolean type constructor array standard types allowable component types 
parameters function allowed standard type passed value 
parameters standard type procedure passed value parameters array type passed 
statements usual ones assignment procedure call conditional statements loops 
expressions build numbers identifiers operators array indexing function calls 
value expression standard type 
conctypes give conctypes defines 
conctype program 
assume conctype id elements read quicksort conctype number elements defined 
precedences disambiguate conctype expr 
escape character give character literal meaning 
conctype program program id id declaration 
appendix conctype subset pascal conctype declaration var dec conctype dec id type conctype type array number number 
conctype integer boolean conctype declaration conctype function id arguments 
procedure id arguments conctype arguments conctype var dec call dec call value conctype statement conctype statement id expr assignment id expr expr assignment array id procedure call arguments id expr procedure call expr 
statement 
statement expr 
statement expr 
statement repeat statement expr 
example program conctype expr number id expr id expr array indexing id expr function call expr expr 
expr expr 
mod expr expr 
div expr expr expr expr 
expr expr expr expr expr expr expr expr expr expr expr expr expr expr expr expr expr expr example program example element conctype program give program reads numbers stores array sorts array quicksort prints sorted numbers 
quicksort procedure taken sw 
program correct pascal program text inside brackets compiled pascal compiler 
program input output var array integer integer procedure swap var integer var tmp integer tmp tmp appendix conctype subset pascal procedure quicksort integer var integer swap repeat repeat repeat swap swap quicksort quicksort repeat read quicksort write 
interpreter section give interpreter 
interpreter implementation denotational description 
functions interpreter written pattern matching concrete syntax 
functions explicitly typed readability making compilation bit faster 
necessary typing type idl list id prog argument cases variables idl type checker deduce type 
third case typed deduced context pattern denotes element type dec 
assume operators declared infix function toint number int defined 

interpreter rec type value int bool type location int type memory location 
value type state memory list int list int location memory input output highest location type type parameter ref location call val value call value type simple location array int int location index location fun list parameter 
state 
value list parameter 
state 
value location function body proc list list parameter 
state 
state type environment id 
initstate fail defined state os os state os os upd state 
location 
value loc loc state 
location 
value 
state os upd os listof listof environment read proc listof ref os 
upd os write proc listof vs os 
ns map val vs ns os fail defined appendix conctype subset pascal 
list var ids type rept length ids ids type rept length ids arguments 
list args args dec 
list parameter environment state 
list parameter environment state dec variable declaration formal parameter declaration 
list parameters nil variable declarations 
returns environment state variable declared identifiers bound new locations storage reserved performed parameter declarations ids case array toint toint alloca id ref loc ps env ps upd env id array loc alloca id env os upd env id array os alloca ids st id val ps env os ps upd env id simple upd os id ref loc ps env ps upd env id simple loc id env os upd env id simple os ids 
list parameter environment state 
list parameter environment state var dec dec dec dec 
interpreter arguments 
list parameter 
environment 
state 
environment state updated environment state ps env env ps env env ps env env declaration 
environment 
state 
environment state updated environment state declared identifiers bound new locations storage reserved var decs env env decs env env env env statement 
environment 
state 
state resulting state execution statement environment state env loc case env simple loc loc loc loc loc env env array env env nv env fail index range assign nv env proc env procedure call appendix conctype subset pascal ps env procedure call proc pk env map pk ps id ref case env id simple loc loc array loc loc id ref array env id env fail index range val env cc env cc cc env env case env true env false env env case env true env false env rec case env true env false 
interpreter repeat cs env rec repeat env cs case env true false repeat repeat cc 
environment 
state 
state cc cs env env cs sd 
environment 
environment updated environment function procedure identifier bound meaning sd function fid args cc env rec ps os env upd env fid env args ps env os env env cc cc env upd env fid fun sd procedure cc env pk args rec ps env args ps env env env cc cc upd env pid proc pk upd env pid proc pk sub 

neg appendix conctype subset pascal expr 
environment 
state 
value value expr environment state env toint env case env simple loc loc loc fun env array env case env fail index range function call ps env vs map val env ps case env fun vs vs env env env env env mod env env env div env env env env env env env env env env env env env env sub env env neg env env env 
env env env env env env 
env env env env env env env env env env 
interpreter prog program 
list int 
list int prog program pid idl list id 
env initstate env sd sds env cc cc env result applying function prog element section lml list 
appendix conctype subset pascal part iv precedences specifications implementations programming languages precedences specifications implementations programming languages annika aasa precedences language descriptions resolve ambiguities 
reason resolving ambiguities precedences unambiguous grammar language description shorter readable 
unambiguous grammar reflects different precedences operators usually contains lot nonterminals single productions 
consider example ambiguous grammar simple arithmetic expressions unambiguous alternative 
int int language contains prefix postfix operators unambiguous grammar surprisingly large 
language user defined operators example ml mil prolog ss convenient precedences 
new operator introduced grammar augmented new production hard imagine user able indicate place production unambiguous grammar different nonterminals 
dealing precedences questions arise 
precedences situations adequate definition means production grammar higher precedence production 
precedences guide steps parser take ambiguity grammar ear sha wha 
easy ambiguous grammar set disambiguating precedence rules decide parse tree belongs extension published proceedings third international symposium programming language implementation logic programming lecture notes computer science volume language 
second question possible transform grammar precedence rules ordinary context free grammar 
surprisingly complicated grammars containing prefix postfix operators different precedences 
subclass context free grammars give parser independent definition precedences algorithm transforms grammar precedences unambiguous context free grammar 
distfix grammars precedence define kind grammars consider 
definition op stands arbitrary operator word analogy int id definition distfix grammar grammar form op delta delta delta op delta delta delta op infix distfix operators op delta delta delta op delta delta delta op prefix distfix operators op delta delta delta op delta delta delta op postfix distfix operators op delta delta delta op eop delta delta delta op closed distfix operators int id initial operator word subsequent operator word sequence operator words initial sequence operator words operator 
divide distfix operators kinds left associative infix distfix right associative infix distfix prefix distfix postfix distfix closed distfix 
ae shorthand atomic expressions integers identifiers 
example prefix distfix operator gamma gamma 
examples extra requirements imply consider productions allowed production grammar productions illegal olle erik concentrate special case infix prefix postfix operators ideas easily extended include distfix operators indicate done 
requirements operators consider infix prefix postfix operators mean operators distinct 
requirement distfix grammars nonterminal hard 
language descriptions precedences resolve ambiguity just part language part described grammar nonterminal 
ideas defining precedences extended general grammars shown part thesis 
allow unary binary minus language may assume lexical analyzer translates different operators 

definition precedence associativity definition precedence grammar distfix grammar precedence rules 
precedence rules mean precedence associativity rules 
denote precedence grammars follows 
left associative int precedences numbers productions 
simple grammars just say operators precedence 
precedence operator op denoted op 
operators different kinds allowed precedence 
example allow prefix operator precedence postfix operator 
variable range precedence grammars satisfy requirements 
convention production higher precedence binding power lower precedence 
usual arithmetic operators addition operator higher precedence multiplication operator 
convention example prolog ss obj 
convention unusual languages opposite convention chosen algorithm section proof clearer 
precedences structure consider parse trees syntax trees strings talk language precedence grammar defines 
syntax trees example picture derivation gamma gamma note sentence easily obtained syntax tree 
syntax tree operator syntax tree operator root 
definition precedence associativity obvious question ask language define precedence grammar 
language course subset language generated ambiguous grammar precedence rules 
precedence rules throw away parse trees 
call parse trees keep precedence correct 
unsatisfactory define precedence correct trees terms specific parsing method 
specification language involve method recognize language defined parsing method hard see parser uses method correct 
define predicate pch precedence grammar defines precedence correct trees 
pch holds syntax tree correct disambiguating rules grammar predicate defined way syntax trees built operator precedence parser asu flo precedence correct 
converse precedence correct tree recognized operator precedence parser proved section 
reflections 
syntax tree infix operator root form op lt rt precedence correct subtrees lt rt course precedence correct 
furthermore requirements involving precedence root operator 
languages infix operators look precedences roots subtrees 
precedence root 
language contains prefix postfix operators 
consider precedence grammar left associative int syntax trees precedence correct 
want consider left syntax tree precedence correct syntax tree right 
illustrates prefix operators higher precedence infix operator allowed occur right subtree 

definition precedence associativity furthermore consider syntax trees generated grammar want consider left syntax tree precedence correct syntax tree right 
illustrates precedence root operator subtree precedence tree syntax tree need precedence correct 
solve problem introduce different kinds precedence weights syntax tree left weight lw right weight rw 
prefix operators precedence right postfix operators left infix operators directions 
weights depend root operator weights subtrees define follows 
definition lw ae lw op max op lw lw op lw lt op rt max op lw lt rw ae rw op rw op max op rw rw lt op rt max op rw rt easy realize right weight syntax tree maximal precedence infix prefix operators chain right left weight syntax tree maximal precedence infix postfix operators chain left pictured 
tree atomic tree prefix operator tree atomic tree postfix operator op op op op op op give definition predicate pch defines precedence correct syntax trees 
definition precedence grammar rules define predicate pch left right pre post respectively denote set left associative infix operators right associative infix operators prefix operators postfix operators 
atomic expressions pch ae left associative infix operators op left pch lt pch rt rw lt op lw rt op pch lt op rt right associative infix operators op right pch lt pch rt rw lt op lw rt op pch lt op rt prefix operators op pre pch lw op pch op postfix operators op post pch rw op pch op rest precedence correct tree assumed precedence correct definition 
definition easily extended distfix operators 
just notice subtrees operator words operator allowed arbitrary precedence weights long precedence correct 
precedence weights subtrees outside leftmost rightmost operator word satisfy conditions infix prefix postfix operators 
op denote complete distfix operator op delta delta delta op denote operator words op example rule infix distfix written follows left associative infix distfix operators op left pch delta delta delta pch rw op lw op pch op delta delta delta gamma op 
definition precedence associativity requirement closed distfix operator subtrees precedence correct closed distfix operators op closed pch delta delta delta pch gamma pch op delta delta delta gamma op requirement operators distinct important 
assume operator prefix postfix infix operator 
consider sentence possible trees precedence correct regardless precedences give productions 
arise fact know occurrence operator prefix postfix infix operator 
annotate occurrence operator kind syntax tree sentence 
ambiguity problem arise operators different length character 
consider example grammar 
int sentence different syntax trees precedence correct regardless precedences give productions 
think restriction taken care lexical analyzer 
lexical analyzer usually finds longest possible token 
alternative way define precedence correct trees define operators allowed occur subtree 
say need new definition 
definition occurrence operator syntax tree covered occurs subtree operator higher precedence 
occurrence operator uncovered covered 
possible operator higher precedence occur subtree operator lower precedence covered 
example precedence correct syntax tree generated precedence grammar page left associative int gamma gamma prefix operator covers infix operator 
postfix operators left subtree infix operator node independently precedence right subtree 
analogously prefix operators right subtree infix operator node independently precedence left subtree 
syntax tree lt op rt op left associative precedence correct lt rt precedence correct infix prefix operators lt higher precedence op covered infix postfix operators rt higher equal precedence op covered 
correctness definition definition sensible motivated theorems 
states exactly precedence correct tree sentence generated distfix grammar 
desirable want precedences throw away syntax trees 
note imply precedence grammar unambiguous 
theorems motivate correct syntax tree precedence correct 
state operator precedence parser asu flo gives result exactly precedence correct trees 
uniqueness precedence correct trees prove exactly precedence correct tree sentence generated distfix grammar 
theorem 
prove theorem need definitions 
compared definition covering 
definition operator op postfix captured sentence postfix operator right op higher precedence 
delta delta delta op delta delta delta postop delta delta delta op postop 
definition precedence associativity definition operator op prefix captured sentence prefix operator left op higher precedence 
delta delta delta preop delta delta delta op delta delta delta op preop definition characterizes operator sentence root precedence correct syntax tree 
definition top operator sentence generated distfix grammar 
postfix operator postop operators right postop infix prefix operators postop higher precedence postop postfix captured 
prefix operator preop operators left preop infix postfix operators preop higher precedence preop prefix captured 
left associative infix operator inl infix prefix operators left inl higher precedence inl postfix captured 
infix postfix operators right inl higher equal precedence inl prefix captured 
right associative infix operator inr infix prefix operators left inr higher equal precedence inr postfix captured 
infix postfix operators right inr higher precedence inr prefix captured definition distfix operators regard operator words operator enclosed expressions 
example expression regard top operator operator outside operator 
proof lemma algorithm finds top operator sentence 
definition top operator lemmas prove theorem 
proofs lemmas appendix lemma sentence generated distfix grammar operator top operator 
lemma syntax tree precedence correct ffl operators 
ffl top operator root precedence correct subtrees 
lemma syntax tree root operator top operator precedence correct 
theorem exactly precedence correct tree sentence generated distfix grammar 
proof proof induction structure sentence base operators clearly exactly precedence correct syntax tree induction step assume belonging language exactly precedence correct syntax tree show exactly precedence correct syntax tree 
lemma gives contains top operator top 
assume top infix operator appear middle top belong language induction assumption gives exactly precedence correct syntax tree respectively 
call syntax trees lemma gives top top operator precedence correct syntax tree precedence correct top precedence correct tree follows lemma exactly precedence correct tree assume top prefix postfix operator get 
reasoning 
note extend precedence grammars include nonassociative infix operators theorem longer holds sentences precedence correct tree 
take example usually nonassociative operator 
precedence correct tree sentence 
weaker formulation theorem sentence precedence correct tree shown precedence grammars including nonassociative infix operators 

definition precedence associativity comparison operator precedence parsing easy translate precedence grammar operator precedence table operator precedence parsing 
algorithm dragon book aho sethi ullman asu chapter 
theorem parsing sentence generated precedence grammar operator precedence parser gives precedence correct tree result 
proof proof induction number reductions parsing process 
base reductions 
trivial 
induction step show done reductions trees built reductions precedence correct resulting tree reduction precedence correct 
case analysis possible handles operator precedence parser 
delta post delta show tree reduction precedence correct definition show rw post 
know rw maximal precedence chain prefix infix operators right 
assume op highest precedence 
possible op higher precedence post reached configuration delta delta delta op delta post delta delta delta delta time earlier parsing process 
configuration post chosen reduction reach configuration delta delta delta delta post delta delta delta delta delta pre delta analogous postfix case 
delta inl delta proof rw inl analogous postfix case 
proof lw inl analogous prefix case 
theorem operator precedence parser give precedence correct trees result 
proof take arbitrary precedence grammar arbitrary precedence correct syntax tree generated prove result operator precedence parse 
call sentence parsing operator precedence parser give raise syntax error correct sentence result parsing syntax tree shown theorem operator precedence parsers gives precedence correct trees result precedence correct 
theorem says different syntax tres sentence precedence correct 
means equal arbitrary operator precedence parser generate precedence correct trees 
transformation unambiguous grammar theoretical interest knowing precedence grammar transformed unambiguous context free grammar algorithm needed practice 
example want describe language precedence grammar parse language method handle precedence rules algorithm definitely needed 
commonly parsing method recursive descent dm dcg pw 
obvious precedence rules earley algorithm ear possible shown part thesis 
grammars infix operators known algorithm asu chapter transforms ordinary unambiguous context free grammars introducing nonterminal precedence level 
language contains prefix postfix operators method 
consider precedence grammar left associative left associative int grammar method introducing nonterminal precedence level 
method naively give grammar int grammar incorrect generate precedence correct syntax trees 
generate sentences original grammar example 
derivable 
exists unambiguous grammar generates sentences precedence grammar int grammar correct generates syntax trees precedence correct example gamma gamma 
transformation unambiguous grammar attempt construct grammar precisely precedence correct syntax trees derivable int tried incorporate idea postfix operator forms closed expression 
grammar incorrect ambiguous derives precedence correct syntax trees incorrect ones 
illustrates construct grammar way production possible derive syntax tree postfix operator higher precedence syntax trees postfix operators lower precedence course derivable reflections syntax trees derivable nonterminal production harder want syntax trees postfix operators higher precedence derivable 
consider syntax tree gamma gamma precedence correct left subtree gamma gamma ensure subtree derivable production shown production derive syntax trees postfix operators higher precedence show productions derive syntax trees postfix operators higher precedence consider syntax tree syntax tree subtree gamma gamma syntax tree precedence correct higher precedence 
case ensure syntax tree derivable gamma gamma note occurrence covered syntax tree gamma gamma 
syntax tree derivable precedence correct syntax tree sentence postfix operator allowed occur syntax tree derived nonterminal cover operators 
reasoning case prefix operators allowed occur analogous 
indicated nonterminal possible derive syntax tree specific infix operator root 
nonterminals information postfix prefix operators allowed occur left right subtree 
postfix prefix operator allowed cover operators allowed occur left right subtree 
number different nonterminals need infix operator depends postfix prefix operators higher precedence precedence grammar 
algorithm section transform observations algorithm generates contextfree grammar precedence rules precedence grammar incorporated 
simplicity algorithm handles exactly operator precedence level 
severe restriction 
easily extend algorithm allow operators level extend resulting grammar operators 
restriction handle distfix operators infix prefix postfix operators 
severe restriction 
easily extend algorithm allow distfix operators 

transformation unambiguous grammar algorithm generates grammar nonterminals form indices natural numbers show operators allowed occur syntax trees derived nonterminal 
giving algorithm introduce notation 
inl th left associative infix operator inr th right associative infix operator pre th prefix operator post th postfix operator pre precedence th prefix operator higher precedence post precedence th postfix operator higher precedence grammar left associative infix operators right associative infix operators prefix operators postfix operators numbered separately increasing precedence order 
define post pre examples section 
define operators occur syntax tree derived 

operator op op max pre post 

uncovered prefix operator op op pre 

uncovered postfix operator op op post 

uncovered infix operator op op mentioned earlier production operator number depends number prefix postfix operators higher precedence 
algorithm generates grammar rules introduce nonterminals productions 

rule left associative infix operators 
inl inl inl inl gamma inl gamma number left associative infix operators number prefix operators higher precedence inl number postfix operators higher precedence inl 
rule right associative infix operators 
inr inr gamma inr inr inr gamma number right associative infix operators number prefix operators higher precedence inr number postfix operators higher precedence inr 
rule prefix operators 
pre pre gamma number prefix operators number prefix operators higher precedence pre number postfix operators higher precedence pre 
rule postfix operators 
post post gamma number postfix operators number prefix operators higher precedence post number postfix operators higher precedence post 
rule 
ae pre pre gamma post gamma post number prefix operators number postfix operators start symbol resulting grammar nonterminal highest precedence 
example method construct unambiguous grammar language generated precedence grammar left associative left associative int grammar inl post 
post inl post 
post rule left associative infix operators yields productions postfix operator higher precedence prefix operators 
transformation unambiguous grammar rule left associative infix operators yields productions postfix operators higher precedence prefix operators rule postfix operators yields productions production arise 
prefix operators postfix operators higher precedence 
productions arise 
postfix operator higher precedence prefix operators 
rule yields productions postfix operators int int int resulting grammar contains useless nonterminals lot single productions 
easily eliminated algorithms example jacobs gj 
eliminate productions grammar 
augment grammar prefix operator having greater precedence operators unambiguous grammar consists productions eliminate useless single productions left 
correctness algorithm correctness algorithm shown proving precedence grammar generates language set syntax trees grammar obtain applying algorithm consider set strings grammars generate interested structure expressions 
consider parse trees nonterminals parse trees different names chains single productions parse trees grammars algorithm produces 
correctness formulated theorem 
theorem generated language syntax trees grammar ft pch precedence grammar language equal language 
nonterminal useless appear derivation sentence 
proof proof induction precedence grammar 
induction precedence grammar mean show statement grammar consisting zero operators assumption statement holds grammar consisting operators show holds extend grammar operator 
operators introduced increasing precedence order 
notation hm precedence grammar highest precedence operators hm equal hm gamma plus production new operator precedence important properties 
hm gamma hm 
hm gamma hm denote set productions grammar proof theorem divided parts 

part show syntax tree precedence correct generated precedence grammar generated grammar obtain applying precedence removing algorithm second part show syntax tree generated grammar obtained applying algorithm precedence grammar syntax tree precedence correct 
parts predicate qh informally holds syntax tree precedence correct operators natural numbers occur define precisely 
part show direction qh define way hm start symbol grammar hm hm follows prove shown hm hm theorem follows immediately 

transformation unambiguous grammar turn definition predicate definition qh holds 

operators occur syntax tree 
operator op op max pre post 
uncovered prefix operator op op pre 
uncovered postfix operator op op post 
uncovered infix operator op op recall occurrence operator syntax tree uncovered occur subtree operator higher precedence 
example illustrate operators allowed syntax tree hold picture infix prefix postfix post pre allowed allowed covered allowed clearly holds hm 
proof give overview proof 
proof appendix induction precedence grammar base operators trivial 
induction step assumption transformation correct precedence grammar gamma operators show correct extend grammar new operator 
prove case analysis new operator 

left associative infix operator trees form op old tree op old tree op old tree old tree arbitrary chain new infix operator induction length chain new operator 
base length zero tree old 
induction step assumption derive tree occurrences new infix operator show derive tree occurrences new infix operator 

right associative infix operator analogous left associative infix operator 

prefix operator trees form pin prefix infix operator 
transformation unambiguous grammar pin old tree pin old tree pin old tree old tree arbitrary chain prefix infix operators induction length chain infix prefix operators 
base length zero tree old 
induction step assumption derive tree chain occurrences infix prefix operators show derive tree chain occurrences infix prefix operators 
show cases tree infix operator root prefix operator root 

postfix operator analogous prefix operator 
proof sketch proof 
proof appendix prove qh induction length derivation 
induction assumption qh fl show fl qh show qh arbitrary assumption fl case analysis step derivation 
gamma 
gamma 
inop gamma 
preop preop gamma 
postop gamma postop 
gamma practical algorithm algorithm implement experimental language user defined distfix operators aas described part vi thesis 
distfix operator specified operator words optionally precedence associativity 
parser written ml mth uses parser constructors due burge bur fairbairn fai kent petersson holmstrom pet 
parser constructors easy write parser grammar constructors recognize terminal symbols sequences alternatives constructors introduce actions parsing 
parser constructors construct recursive descent parser grammar left recursive express precedences involved operators 
parser user defined distfix operators rules algorithm described 
changes order remove left recursion generate entire grammar different nonterminals 
see rules production schemas way similar hyper rules level grammars cu instantiate rules parsing 
hanson han describes technique parsing expressions recursive descent introducing additional nonterminals technique handle prefix postfix operators different precedence method 
appendix complete proofs lemmas complete proofs lemmas proof theorem 
lemmas proofs lemma 
ffl prefix infix operator pin appears syntax tree pin covered postfix operator precedence correct rw pin lemma ffl postfix infix operator appears syntax tree covered prefix operator precedence correct lw lemma lemma sentence generated distfix grammar operator top operator 
proof consider sentences operators show top operator sentence generated distfix grammar top operator sentence generated distfix grammar show statement induction number operators sentence 
base operator sentence 
operator top operator operators violate top operator conditions 
appendix complete proofs lemmas induction step assume top operator sentence operators operator show top operator sentence operators show take arbitrary sentence operators 
consider operator highest precedence 
operators equal highest precedence consider leftmost operator prefix right associative infix operator rightmost operator postfix left associative infix operator 
clearly operator case analysis kind operator highest precedence 
infix operator highest precedence operator violates conditions top operator 
note chosen leftmost occurrence right associative infix operator vice versa 

postfix operator postop postop rightmost operator postop top operator 
holds postop highest precedence operator violates condition 
postop rightmost prove top operator follows 
denote part left included postop part delta delta delta delta delta delta postop delta delta delta delta delta delta operators postop postop highest precedence operators sentence obtain replacing atomic expression top operator top operator 
ae clearly fewer operators induction assumption gives top operator 
prefix operator analogous postfix operator case 
concludes induction proved 
prove statement top operator sentence generated distfix grammar take arbitrary sentence assume top operator top prove top operator case analysis top 
postfix operator clearly postfix operator top operator rightmost 
prove contradiction prefix infix operator top operator assume prefix infix operator pin top operator cases pin top order pin top operator prefix operator preop preop top pin top 
chose prefix operator pin postop highest precedence 
delta delta delta pin delta delta delta delta delta delta preop delta delta delta delta delta delta top top top operator postfix operator postop postop preop preop top 
delta delta delta pin delta delta delta delta delta delta preop delta delta delta postop delta delta delta top postop violates condition pin top operator 
prefix operator higher precedence postop pin postop preop highest precedence prefix operators pin top 
contradiction pin top operator 
top top operator sentence 
pin top analogous 

prefix operator analogous postfix operator case 

infix operator reasoning impossibility operator top operator analogous case case 
lemma syntax tree precedence correct ffl operators 
ffl top operator root precedence correct subtrees 
proof syntax tree operators clearly precedence correct assume syntax tree top operator root precedence correct subtrees show syntax tree precedence correct 
appendix complete proofs lemmas case analysis syntax tree 
post rule postfix operators op post pch rw op pch op gives order show post precedence correct precedence correct show rw post right weight syntax tree defined rw ae rw op rw op max op rw rw lt op rt max op rw rt follows atomic tree tree postfix operator holds 
tree infix prefix operator rw maximum precedences infix prefix operators op op post op op op subtree op atomic tree tree postfix operator 
op prefix infix operator chain op op highest precedence 
rw op show contradiction op post start assuming opposite op post post top operator postfix operator post higher precedence op op post sentence 
post postfix operator highest precedence op post 
delta delta delta op delta delta delta post delta delta delta post post op post appear op op post covered prefix operator precondition lemma fulfilled get precedence correct lw post precedence correct subtrees immediately leads contradiction 
leads contradiction lw post op op precedence correct contradicts fact subtrees precedence correct 
appendix complete proofs lemmas post covered prefix operator contradicts fact post post operator 
contradiction follows prefix operator pre covers post higher precedence post pre post pre covers post op post post top operator postfix operator higher precedence pre pre post sentence 
impossible post chosen highest precedence postfix operators proved assumption leads contradiction holds proved lemma postfix operator case 

pre analogous post 

lt inl rt left associative infix operator rule left associative infix operators op left pch lt pch rt rw lt op lw rt op pch lt op rt gives order show lt inl rt precedence correct lt rt precedence correct show rw lt inl lw rt inl proof analogous postfix case proof analogous prefix case 

lt inr rt right associative infix operator analogous lt inl rt 
lemma syntax tree root operator top operator precedence correct 
proof take syntax tree top operator root operator 
operator root top operator appear subtree 
case analysis syntax tree 
post post top operator prefix infix operator pin left pin post pin pin appear covered postfix operator 
lemma get precedence correct rw pin holds course post precedence correct 
holds post precedence correct pin post rw post condition rule postfix operator fulfilled 

pre analogous post 

lt inl rt inl top operator cases 
infix prefix operator pin left inl pin inl pin case analogous case 
infix postfix operator right inl pin inl case analogous case 
lt inr rt analogous lt inl rt 
lemma prefix infix operator pin appears syntax tree pin covered postfix operator precedence correct rw pin proof proof induction number operators syntax tree satisfies preconditions 
base syntax tree operator 
operator pin pin appears appendix complete proofs lemmas rw pin proved base case 
induction step assume lemma holds syntax trees operators show syntax trees operators 
case analysis kind syntax trees 
st post prefix infix operator pin appears st st operators induction assumption gives st precedence correct rw st pin holds ready st post precedence correct 
conditions lemma pin covered postfix operator 
pin post holds combine get condition rule postfix trees fails 
precedence correct 

pre st pre pin easily prove lemma rw pre st max pre pin rw st pin pre pin pin appears st st operators induction assumption gives st precedence correct rw st pin holds ready pre st precedence correct 
holds prove lemma stating rw pre st max pre rw st pin pin 
infix operator lt rt pin rw lt rt max pin rw rt pin cases pin appears lt pin appears rt 
case analogous postfix operator case second case analogous prefix operator case 
lemma postfix infix operator appears syntax tree covered prefix operator precedence correct lw proof analogous proof lemma 
appendix complete proofs lemmas appendix complete proof algorithm theorem generated language syntax trees grammar ft pch precedence grammar language equal language 
proof proof theorem consists parts 

part show syntax tree precedence correct generated precedence grammar generated grammar obtain applying precedence removing algorithm second part show syntax tree generated grammar obtained applying algorithm precedence grammar syntax tree precedence correct 
proof show qh proof induction base operators syntax tree atomic tree 
clearly holds production ae induction step assume hm gamma gamma show hm appendix complete proof algorithm case analysis introduced operator 
op left case new nonterminal introduced new productions hm op gamma gamma lemma follows syntax trees hm form op old tree op old tree op old tree old tree arbitrary chain new infix operator proof induction length chain new operator 
denotes syntax tree chain length base length zero 
show hm take arbitrary triple 
assume hm show cases 
hm gamma new infix operator occur follows assumption property page gamma 
proof statement follows assumption hm gamma 
assumption case op occur gamma gamma fact gamma hm gamma follows gamma know production gamma hm get shown second case 
concludes base induction chain new infix operators 
induction step assume hm show hm suffices show statement hold 
know op op 
show assume show statement follows facts appendix complete proof algorithm ffl op chain op ffl production op gamma 
follows ffl chain op length derived 
ffl hm gamma derived gamma 
concludes induction step shown case introduced operator left associative infix operator 

op right analogous op left 
op pre case lot new nonterminals productions introduced 
lemma follows syntax trees form pin denote infix operator prefix operator 
left subtrees case infix operators 
prefix operators chain new operator old 
pin old tree pin old tree pin old tree old tree arbitrary chain prefix infix operators show induction length chain infix prefix operators 
base length zero tree post hm gamma 
atomic tree follows lemma tells atomic tree derived nonterminals 
consider case post show hm post post take arbitrary triple 

proof assume hm post show post lemma get number prefix postfix operators respectively post course occurs uncovered post follows assumption post post precedences precedences post 
post 
post 

post picture similar ones precedences decreasing precedence order left picture post post number postfix operators post 
compare example 
know postfix operators definition post postfix operators post get precedences post 
post 

precedences post 

post 
appendix complete proof algorithm rule post gamma post number prefix operators number postfix operators see exists production post gamma post 
remains show post gamma show start proving premisses 
know post hm gamma gamma postfix operators hm gamma higher precedence post 
rules rule postfix operators post post gamma number postfix operators number prefix operators higher precedence post number postfix operators higher precedence post follows post gamma hm gamma show desired instance holds gamma post gamma 
hm new prefix operator occur follows hm gamma 
know postfix operators postfix operators post 
post post gamma post 
proof seen picture precedences post 
post 

precedences post 

post 
furthermore max pre post post post gamma max post post post gamma post post gamma post pre post post know operators ffl uncovered postfix operator higher precedence post occur know occur post 
ffl uncovered prefix infix operator higher precedence post occur post precedence correct 
say operators occur operator op op post 
follows occur uncovered operator higher precedence post operator cover 
uncovered prefix operator op op post 
uncovered postfix operator op op post 
uncovered infix operator op op post 
concludes proof get 
statement post follows results post gamma post post gamma appendix complete proof algorithm triple arbitrary shown base induction length chain infix prefix operators 
induction step assume hm show hm denotes syntax tree chain infix prefix operators length take arbitrary triple 
assume hm show case analysis pre show pre lemma get number prefix postfix operators respectively pre course occurs uncovered pre follows assumption pre pre know prefix operators definition pre prefix operators pre get rule pre pre gamma number prefix operators number postfix operators 
proof get exists production pre pre gamma 
remains show pre gamma prove start proving premisses 
know gamma prefix operators higher precedence pre rule prefix operators pre pre gamma number prefix operators number prefix operators higher precedence pre number postfix operators higher precedence pre follows pre gamma hm show desired instance holds pre gamma 
hm hm 
know prefix operators definition pre prefix operators pre 
pre pre gamma pre max pre pre gamma post pre max pre pre gamma pre pre pre gamma pre post pre pre know operators ffl uncovered prefix operator higher precedence pre occur know assumption occur pre ffl uncovered postfix infix operator higher precedence pre occur know pre precedence correct 
say operators occur operator op op pre 
uncovered prefix operator op op pre 
uncovered postfix operator op op pre 
uncovered infix operator op op pre 
appendix complete proof algorithm concludes proof 
see follows fact chain prefix infix operators length statement pre follows results pre pre gamma pre gamma concludes case induction step shown case chain starts prefix operator 
ii 
inl show inl just give overview proof 
statement follows 
inl number prefix operators postfix operators inl inl inl inl inl inl inl gamma statement follows lemma follows rule left associative infix operators 
show show 
iii 
inr analogous inl 
op post analogous op pre proof show qh take arbitrary show qh 
proof proof induction length derivation 
base show qh syntax tree derive step atomic tree holds ae induction step assume qh fl show fl qh take arbitrary 
assume fl show qh case analysis step derivation 
gamma prefix operator precedence case assumption follows gamma fl gamma assumption follows qh gamma 
pch holds 
operators occur operator op op max pre gamma post gamma 
uncovered prefix operator op op pre gamma 
uncovered postfix operator op op post gamma 
uncovered infix operator op op gamma 
appendix complete proof algorithm statement follows immediately 
prefix operator precedence infix operator precedence 
say infix operator op op occur say infix operator op gamma occur pre gamma pre post gamma post 
gamma postfix operator precedence analogous previous case 

inop gamma inop left associative infix operator precedence lt inop rt 
lt fl gamma rt fl assumption gives qh lt lt pch lt holds operator op op max pre post post occur lt uncovered prefix operator op op pre inop occur lt 
uncovered postfix operator op op post occur lt 
uncovered infix operator op op inop occur lt 

proof lemma gives rw lt inop assumption gives qh rt gamma rt pch rt holds operator op op max pre gamma post gamma pre gamma pre occur rt 
uncovered prefix operator op op pre gamma pre occur rt 
uncovered postfix operator op op post gamma gamma occur rt 
uncovered infix operator op op gamma occur rt 
lemma gives lw rt gamma inop pc rule left associative infix operators op left pch lt pch rt rw lt inop lw rt inop pch lt inop rt follows pch lt inop rt holds follows operator op op max pre post occur lt inop rt 
appendix complete proof algorithm follows uncovered prefix operator op op pre occur lt inop rt 
follows uncovered postfix operator op op post occur lt inop rt 
follows uncovered infix operator op op occur lt inop rt 
proved arbitrary proved case step derivation inop gamma 

preop preop gamma preop 
rule pre pre gamma number prefix operators number postfix operators get preop gamma fl assumption gives qh preop gamma pch holds say operators note pre preop gamma pre 
proof seen picture pre pre preop gamma 
gamma preop 
say operators occur operator op op max pre preop gamma post preop pre occur 
uncovered prefix operator op op pre preop gamma pre occur 
uncovered postfix operator op op post preop preop occur 
uncovered infix operator op op preop occur 
lemma gives lw preop course prefix operator precedence preop left weight prefix node fact lw preop pc rule prefix operators op pre pch lw op pch op follows pch preop holds appendix complete proof algorithm statements operators occur preop important note 
follows operator op op max pre post occur preop 
follows uncovered prefix operator op op pre occur preop 
fact operator lower precedence preop covered preop follows uncovered postfix operator op op post occur preop 
fact operator lower precedence preop covered preop follows uncovered infix operator op op occur preop 
proved arbitrary proved case step derivation preop preop gamma 

postop gamma postop analogous 
gamma trivial 
concludes induction shown arbitrary shown particularly 

lemmas lemmas lemma precedence grammar inl left associative infix operator highest precedence operators syntax trees form inl old tree inl old tree inl old tree old tree chain possibly empty inl proof old tree tree inl occur course form empty chain inl consider case inl root operator 
lt inl rt syntax tree 
show possible build precedence correct syntax tree subtree tree inl root operator left subtree tree form 
left right weight inl inl highest precedence grammar 
case analysis ways building syntax tree subtree 

preop tree precedence correct lw inl 
preop 
postop tree precedence correct rw inl 
postop 
inop inop inl 
tree precedence correct rw inl inop 
inop inop inl 
tree precedence correct lw inl inop 
inl tree precedence correct lw inl 
inl 
inl tree precedence correct pch lw inl 
rw inl inl 
appendix complete proof algorithm lemma precedence grammar pre prefix operator highest precedence operators syntax trees form pin denote infix operator prefix operator 
left subtrees case infix operators 
prefix operators chain pre 
pin old tree pin old tree pin old tree old tree arbitrary chain prefix infix operators proof old tree course form empty chain infix prefix operators 
simplest case tree old pre root operator old tree subtree 
tree form chain prefix operator 
precedence correct old tree precedence correct right weight pre 
show tree form rw pre subtree tree pc form rw pre 
case analysis ways building syntax tree subtree 

preop preop pre preop pre tree form rw pre pre highest precedence rw preop max preop rw pre pre 
postop tree precedence correct rw pre 
postop 

inop rt tree precedence correct rw pre inop 

lemmas 
lt inop lt old tree tree form rw pre rw lt inop max inop rw pre pre lt old tree precedence correct 
lemma precedence grammar nonterminal grammar 
possible derive atomic tree 
proof show ae take arbitrary grammar show ae proof induction base show ae statement follows immediately rule 
induction step assume gamma gamma ae show ae take arbitrary show ae assume show ae appendix complete proof algorithm case analysis operator precedence 
infix operator rules infix operators follows production gamma assumption follows derivation gamma ae statement follows 
arbitrary shown 

prefix operator rule prefix operators follows production gamma rest analogous infix operator case 

postfix operator rule postfix operators follows production gamma rest analogous infix operator case 
concludes induction shown 
arbitrary shown 
lemma precedence grammar natural numbers derivation number prefix postfix operators proof show take arbitrary grammar show prove induction 
lemmas base show order satisfy condition 
follows immediately 
induction step assume induction assumption gamma gamma gamma show take arbitrary assume show number prefix postfix operators follows immediately consider case operator precedence level productions grammar gamma infix gamma prefix gamma postfix gamma get assumption gamma gamma gamma number prefix postfix operators gamma 
case number prefix postfix operators infix operator precedence prefix postfix operator 
second case number prefix postfix operators prefix operator precedence third case number prefix postfix operators postfix operator precedence statement follows arbitrary 
statement follows induction 
appendix complete proof algorithm lemma pc uncovered prefix infix operator op op rw proof syntax trees form pin denote infix operator prefix operator 
left subtrees case infix operators 
tree tree postfix operator atomic tree 
proof induction length chain 
assume uncovered prefix infix operator op op arbitrary 
base length zero 

ae lemma holds rw ae 
postop lemma holds rw postop induction step 
lt inop rt definition rw rw max inop rw rt inop course occur uncovered conditions lemma give inop rt shorter chain infix prefix operators lt inop rt get induction assumption rw rt get rw concluded induction step case 

preop analogous previous case rt 
conclude induction proved lemma 
lemma pc uncovered postfix infix operator op op lw proof analogous proof lemma 
part precedences context free grammars precedences context free grammars annika aasa syntax programming languages described context free grammars 
problem descriptions hard concise readable unambiguous 
unambiguous context free grammars contain lot nonterminals single productions quite hard read 
consider example ambiguous grammar expressions small functional language unambiguous alternative usual precedences constructions incorporated id int id ep ep ae ae ep id ae ae int id reason need different nonterminals generating parse trees root unambiguous alternative explained part iv thesis 
larger example syntax description parts hard read human grammar caml ch wal contains lot nonterminals aim grammar unambiguous 
way ambiguous grammar unambiguous rewriting completely precedence associativity rules disambiguating 
easy see rules disambiguate grammar 
old description sml mil stated productions decreasing precedence order explained obvious meant 
grammars precedences infix operators agrees parse trees regarded correct 
arbitrary context free grammars generally accepted rule rules dependent different parsing techniques 
descriptions precedence rules parsers aho ullman earley ear 
precedence associativity rules say precedence rules 
unsatisfactory define syntax language terms specific parsing method 
specification language involve method recognize language defined parsing method hard see parser uses method correct 
serious disadvantage understanding disambiguation works requires knowledge specific parser works 
precedence rules resolve ambiguity common parsers lr techniques asu knu 
lr parser generators example yacc joh precedences resolve shift reduce conflicts 
user parser generator understand parser generator works wants precedences 
productions precedences natural ones 
seemingly harmless change grammar forces precedence changes conflicts productions 
hard translate lr precedence rules parsing techniques 
precedences situations adequate definition means production grammar higher precedence 
parser independent definition say parse trees grammar generates sentences structure important 
ambiguous grammar set precedence rules possible decide parse tree belongs language 
note dealing precedences consider languages sets trees sets strings usual 
part iv thesis aas definition subclass context free grammars 
part consider general grammars 
notation assume reader familiar context free grammars ordinary notation conventions 
letters written typewriter font terminals capitals nt nonterminals 
greek letters sequences terminals nonterminals strings solely terminals 
grammars written sequences productions nonterminal left hand side production assumed start symbol 
notation derivation step derivation steps lm lm leftmost derivations 
picture parse trees follows ff picture shows parse tree nonterminal root 
top half tree corresponds sentential form ff nonterminal root sub parse tree sentence 
ambiguity ambiguity goal precedences resolve ambiguous sentences generated ambiguous grammars 
question possible resolve ambiguities precedences 
grammar ambiguous exist sentence parse tree 
unfortunately problem deciding arbitrary context free grammar unambiguous undecidable au flo inherently ambiguous context free languages au par 
problem resolving ambiguity precedences hard impossible solve general 
restrict goal resolve kind ambiguity 
resolve kinds ambiguity solution completely rewriting grammar 
possible isolate pattern parse trees think suitable resolve precedences 
ambiguity usual form ambiguity grammars programming languages includes programming language constructs normally precedences 
pattern occurs parse tree contains subtree forms precise definition 
call parse tree ambiguous parse tree kind ambiguity ambiguity goal resolve ambiguities precedences 
note ambiguous grammar arithmetic expressions generates ambiguous parse trees int stands recursive 
see 
case precedences specify ambiguous parse trees want consider correct ones 
usually want consider third tree correct second incorrect 
achieve give productions higher precedence productions bit unusual convention example higher precedence usual binding arithmetic operators 
complicated example subset grammar sml defined mil descriptions mth grammar slightly changed ae ae case ae int id 
int id grammar generates example ambiguous parse trees sentence case 
case ae 
ae ae case ae 
ae ae resolve ambiguity intuitive way give precedences productions ae case ambiguity resolved lr parser asu ear precedences productions 
ae int ae id 
ambiguity see necessary look collection lr item sets 
picture show 

ffl ffl ae ae ffl int ae ffl id ae ae ffl ae int ffl ae id ffl int id item set shift reduce conflict input int productions 
ae int input id shift reduce conflict productions 
ae id conflicts resolved giving precedences involved productions 
way resolving ambiguity precedences unnatural people really requires knowledge lr parser works 
reason people want give precedences productions ae case resolve ambiguity nonterminal left right recursive 
nonterminal left recursive right recursive aff ffa 
easy see grammar generates ambiguous parse tree useful nonterminal left right recursive grammar 
suppose grammar generates ambiguous sub parse tree nonterminal useful appears derivation sentence 
description algorithm removes useless nonterminals grammar book jacobs gj 
parse tree see derivations aw ua 
left right blr recursive 
definition blr grammar useful nonterminal right recursive 
blr grammars ambiguous 
proof straightforward 
blr grammar derivations lm wa lm afi 
sentential form leftmost derivations lm wa lm lm afi lm 
grammar ambiguous 
unfortunately blr grammar generate ambiguous parse trees common case 
example blr grammar ambiguous sentences ambiguous parse trees 
note nonterminal nonterminals left right recursive int strange grammar ambiguous ambiguous sentences parse trees 
sentence example ambiguous different parse trees ambiguous non ambiguous parse trees sentence 
example grammar int ffl example generates different parse trees sentence ambiguous 
ambiguity ffl ffl ffl ffl ffl ffl ffl ffl non ambiguous parse trees sentence 
case nonterminal left right recursive grammar generate ambiguous parse trees 
sentence generated blr grammar course ambiguous way left right recursiveness 
blr grammar generates sentence sentence ambiguous fact nonterminal left right recursive non ambiguous parse trees sentence reasons resolve ambiguity blr grammars precedences 
blr grammars generate ambiguous parse trees ambiguity close correspondence left right recursive nonterminals 
propose order resolve ambiguity precedences nonterminals left right recursive 
problem deciding nonterminal left right recursive decidable similar problem deciding nonterminal accessible bac 
practical cases quite easy see nonterminals left right recursive 
problems grammar writer augment grammar precedences 
formally define mean precedences define ambiguous parse trees considered correct ones 
need introduce definitions 
nonterminal accessible derivation 
definition left edge node parse tree sequence nodes 
left siblings father element left edge 
node belongs left edge left edge part left edge order nodes sequence father follows child 
right edge node defined analogously 
definition left edge node parse tree sequence nodes 
node element left edge 
node belongs left edge left edge leftmost child part left edge order nodes sequence child follows father 
right edge node defined analogously 
note node belongs left edge left edge 
example left edge left edge right edge nodes belong right edge right sibling 
hope distinction node nonterminal node clear context 
notation mean different nodes correspond nonterminal 

ambiguity definition production said left edge node parse tree left hand side nonterminal left edge node 
example production left edge formally define ambiguous parse tree 
definition parse tree ambiguous contains node node left right edge node right left edge left edge right edge right edge left edge note chosen node necessarily nonterminal left right edge node nodes node chosen node right left edge node choose significance deciding parse tree ambiguous matters definition 
definition ambiguity pair ambiguous parse trees sentence nodes chosen definition complete subtrees swapped shown picture example ambiguity pair sentence ambiguous parse tree exists parse trees parse tree ambiguity pair 
parse trees nonexistent possible grammar cyclic tree achieved nodes swapped 
notion ambiguity pair sections discuss precedences productions grammar order resolve ambiguity motivate precedence definition reasonable 
precedence grammars informally precedence grammar grammar precedence rules section define language trees precedence grammar generates 
precisely define precedence grammar 
mentioned quite easy recognize blr grammar certainly generates ambiguous parse trees 
grammar writer usually idea structure wants parse trees 
examples different parse trees ambiguous sentences hard translate ideas rules form production higher precedence production left associative 
informal rules mind precedence grammar generates desired language usually easily constructed 

precedence grammars definition precedence grammar productions left right recursive nonterminal way alternatives left right recursive come 
productions preceded sign sign 
recursive production preceded sign 
production preceded sign higher precedence previous production 
production preceded sign precedence previous production 
precedence group set productions having precedence 
left right recursive productions precedence group sign indicating associativity precedence group 
letter stands left associative right associative nonassociative 
example precedence grammar arithmetic expressions 
int id precedence groups precedence grammar precedence relation form total order 
augment order element 
total order precedence grammar example pictured follows int id left left right section define language precedence grammar defines operations total order 
operation take maximum precedence groups determine group 
description code total order natural numbers plus ordinary operations max 
picture annotated order numbers coding order 
appropriate annotate precedence grammars natural numbers code precedence orders 
total order nonterminal left right recursive 
example nonterminal note precedence grammars introduced part iv thesis minor changes special case precedence grammars considered 
definition precedence obvious question ask language define precedence grammar 
precedence rules parse trees illegal legal 
call legal parse trees precedence correct defined terms attribute grammar 
definition lot common definition precedences distfix operators part iv thesis aas 
complicated define precedence general grammars 
part iv considered grammars nonterminal 
attribute grammar knu knu context free grammar node parse trees augmented set attributes condition 
parse tree correct conditions true 
values attributes specified evaluation rules productions 
attribute grammars specify syntax directed translations 
conditions 
attribute grammars specify language conditions play central role 
informal description main idea precedence definition define precedence checks conditions attribute grammar attributes precedence information propagated parse tree 
synthesized attributes nodes parse trees weights left weights right weights 
values weights depend precedences productions left right edges node 
synthesized attributes weights 
left weight nonterminal nt node maximum precedences productions nt left edge node precedence production nt replaced zero 
reason include precedence production nt left recursively 

definition precedence example consider precedence grammar generates parse tree left weight nonterminal root node despite appearance production production left recursively 
inherited attributes inherited attributes precedence production flow node suitable define precedence check 
precedence production ff inherited divided left precedence right precedence 
left precedence propagated left edge right precedence propagated right edge father appearance value left precedence nonterminal node precedence production nonterminal left edge node 
nonterminal appear left edge node value left precedence nonterminal node 
value right precedence analogous 
example consider non ambiguous parse tree precedence production right precedence nodes right precedence node 
node inherited left precedence nonterminal left right recursive attributes functions nonterminals precedences 
value left precedence nonterminal node indicates heavy right weight leftmost subtree allowed nonterminal vice versa right precedence 
formal definition give formal description evaluation rules conditions attribute grammar 
description pattern matching different forms productions notation 
ff denote precedence production ff 


denote function updated value argument updated value argument mentioned section natural numbers plus represent precedence order define types 
precedence theta associativity precedence nat associativity set pattern typically form ffb 
productions having nonterminal rightmost symbol right hand side matches pattern example case productions grammar matched patterns 
notice production match pattern 
inherited attributes precedence checks indirectly left right recursive nonterminals precedences inherited downwards parse tree 
inherited attributes left precedences lps right precedences rps 
nonterminal indirectly left recursive aff step 

definition precedence lps nonterminal rps nonterminal evaluation rules attributes follows 
left precedences production attribute evaluation rules aff lps lps 
aff 
nt lps 
nt ff aff nt lps 
nt ff right precedences production attribute evaluation rules ffa rps rps 
ffa 
nt rps 
nt ff ffa nt rps 
nt ff synthesized attributes node weights nonterminals belongs left right edge 
left right weight nonterminal node maximum precedences productions left right recursively left right edge node 
left weights lws right weights rws synthesized attributes types 
lws nonterminal precedence rws nonterminal precedence attribute evaluation rules follows 
left weights production attribute evaluation rules aff lws 
aff lws lws 
max lw lw lws 
lw lws fst aff right weights production attribute evaluation rules ffa rws 
ffa rws rws 
max rw rw rws 
rw rws fst ffa conditions precedence checks defined conditions attribute grammar 
production condition true true ffb true rps 
ffb rp lw lw right ass lw lws fst rp ass snd rp bff true lps 
bff lp rw rw left ass rw rws fst lp ass snd lp notice production match patterns example case conditions true order condition true 
example grammar nonterminal left right recursive order resolve ambiguity give precedences productions left right recursive 
grammar define precedence relation case indicate grammar sign productions 
give higher precedence case production example want sentence case 
interpreted case 


definition precedence indicate production left associative 
int id case 
int id precedence definition see meaning precedence grammar grammar attribute grammar 
simplified attribute grammar bit knowledge productions precedences nonterminal derive int id lws 
rws 
condition true lps lps 
lps 
rps 
rps rps 
lws lws 
max lws rws rws 
max rws condition rws lws case lps 
lps 
rps 
rps rps 
lws 
rws rws 
max rws condition true 
lps 
rps rps 
rws rws 
condition fst rps lws int id lws 
rws 
condition true correctness reason add precedences grammar exclude parse trees generated language 
parse trees excluded definition precedence correct parse trees section 
definition said correct undesired parse trees excluded 
goal resolve ambiguity requirement ambiguous parse trees thrown away 
formulated theorem 
obvious requirement parse trees generated grammar precedences correct 
formulated theorem 
theorem says parse trees generated precedence grammar precedence correct 
states precedence grammar generate pairs 
theorem imply precedence grammar unambiguous 
mentioned restricted resolve ambiguity precedence grammar unambiguous may contain ambiguities ambiguities 
simple example precedence grammar sentence different parse trees non ambiguous parse trees sentence true sentence generated precedence grammar ambiguous parse tree 
ambiguous parse tree occur subtree different parse tree result ambiguity 
precedence grammar contains ambiguity resolved precedences kind ambiguity int 
correctness sentence different parse trees ambiguity really ambiguity parse trees ambiguous note precedences sentence different parse trees 
example shows true sentence generated precedence grammar ambiguous parse tree 
theorem precedence grammar generate bit weak 
precedence grammar example unambiguous follow theorem 
int sentence different parse trees generated grammar precedences precedence correct 
ambiguity pairs indicated arrows 
seen form picture trees form ambiguity pair 
theorem imply trees precedence correct 
theorem give indication definition reasonable 
lemmas proofs 
formulated proved appendix theorem precedence incorrect parse tree ambiguous 
proof suppose precedence incorrect parse tree 
show ambiguous 
precedence incorrect node precedence condition false 
precedence condition rules give node nonterminal leftmost rightmost child 
cases symmetric assume condition fails node leftmost nonterminal child precedence condition rule production bff 
show nonterminal left edge nonterminal right edge node ambiguous 

correctness ff nonterminal clearly appears left edge nonterminal inherited left precedences precedence condition true 
appears left edge follows lemma 
precedence condition false node lemma gives right weight node greater zero appears right edge node follows lemma 
theorem parse tree generated grammar precedences productions precedence correct 
proof follows immediately lemma says productions nonterminal precedences subtree accepted 
theorem precedence grammar generate ambiguity pairs 
proof theorem says parse tree ambiguity pair precedence correct 
take ambiguity pair parse trees ii assume precedence correct show precedence incorrect 
assume precedence correct get analogous proof 
precedence correct condition nodes true specially condition node left edge node true 
precedence condition node lemma gives precedence production left edge node 
call production prod 
rw right weight node 
lemma gives rw maximum precedences productions right edge node precedence production replaced zero 
show condition node right edge node ii parse tree false 
production prod parse tree left edge node ii 
lemma follows left weight lw node ii 
lw precedence condition node lemma gives precedence production right edge node ii 
call production prod 
productions right edge node ii parse tree subset productions right edge node parse tree follows maximum rw 
rw know prod left recursive left edge node prod right recursive right edge node ii 
follows equal associativity restriction 
ass ass condition node true true 
rw rw left ass show condition node false 
show lw lw right ass holds lw lw right ass follows rw combining gives rw lw lw split cases lw lw 

parsers precedences lw clearly true 
lw follows rw follows left ass follows ass follows right ass follows proved condition node false parse tree precedence incorrect 
concludes proof parse tree ambiguity pair precedence correct 
note possible parse trees ambiguity pair precedence incorrect 
parsers precedences definition precedence correct parse trees course important easy construct parsers recognize language defined precedence grammar 
possible find parser 
parser constructed ambiguous grammar precedences give parse trees sentence result 
course parsing technique handle ambiguous grammars 
precedence incorrect parse trees filtered 
filtering possible attribute values conditions computable 
furthermore evaluation order attribute grammars attributed asu chapter 
parse trees result parser 
parse trees just built implicitly representation sentences result 
filter precedence incorrect trees representation parse trees 
give parse trees result filtering translate parse trees desired representation 
process unnecessary inefficient section investigate precedence rules incorporated parsers 
precedence incorrect trees thrown away parsing 
precedences earley algorithm section show precedence rules incorporated earley algorithm ear 
earley algorithm general context free parsing algorithm 
takes context free grammar sentence input gives parse trees sentence output 
extended version earley algorithm takes precedence grammar sentence input gives precedence correct parse tree result 
precedence grammar contains kinds ambiguity ambiguity course algorithm give parse tree result give precedence incorrect trees result 
algorithm works scanning input string left right 
set items constructed input symbol 
item represents possible derivation far 
item sets constructed operations predict scan complete 
precedence checks done operation complete 
item operation complete applicable contains parse tree representation parsed substring 
items item set pointed pass precedence checks parse tree added result operation complete 
items pass precedence checks added incorrect parse trees built 
facilitate checks information dotted production backward pointer added items 
extra information corresponds attributes attribute grammar defines precedence correct trees left inherited precedences right inherited precedences left weights right weights 
component precedence production item 
item extended version denoted lps rps ts ffl ff lws rws lps inherited left precedences left hand side nonterminal rps inherited right precedences precedence production left hand side nonterminal ts sequence parse trees ff sequence terminals nonterminals lws left weights left hand side nonterminal rws right weights backward pointer 
values new components calculated way follows attribute evaluation rules attribute grammar defines precedence correct trees 
left right inherited precedences added item operation predict 
ordinary algorithm operation predict applicable dot left nonterminal 
nonterminal leftmost rightmost symbol left right precedences predicting item inherited new item added 
weight components item weights parse tree left hand side nonterminal root 
updated dot moved leftmost rightmost symbol respectively 
examples question mark indicate 
parsers precedences weights updated 
updating weights done operations scan complete 
result operation scan dot moved terminals easy update weights case 
example dot moved leftmost terminal left weights updated zero left hand side nonterminal 
updating weights result operation complete bit complicated dot moved nonterminal way done follows closely attribute evaluation rules weights 
mentioned conditions checked operation complete 
example algorithm parse sentence case 
precedence grammar int id case 
int id precedence orders grammar pictured natural numbers coding orders int id case 
int id left note precedence order nonterminal precedence relation productions productions precedence group indicate precedence productions left associative description subscript precedences nonterminals 
case nonterminal interesting 
items item sets indicate dots 
ordinary algorithm augment grammar new start symbol get items item set 
item set ffle ffle 
ii operation scan applicable item ii terminal case leftmost symbol update left weights moving item item set 
item set case ffl ii operation predict applicable 
nonterminal leftmost rightmost symbol precedences inherited 
item set 

sequence steps get ii item set 
dot moved symbols 
item set case ffl ii operation predict applicable item rightmost symbol right precedences inherited new item 
item set 

iii 
steps come item set 
item set 
ffl iii take closer look item iii represents 
predicted item set item case ffl stage item set represent parse 
parsers precedences case 
ffl unknown parse tree right dot inherited left precedences item set iii nonterminals means left edge node empty node left sibling case terminal 
inherited right precedence means production right edge precedence 
left weights item iii updated dot moved leftmost symbol zero nonterminal occur left edge dot moved rightmost symbol right weights updated indicated question mark item 
going back parsing process note operation predict applicable item iii items added item set 
item set 
iv ffle 
operation scan applicable item iv item moved item set dot moved terminal id item set iv result applying operation complete item iv items item set added 
item gets twice left edge case weight zero 
item set 

ffl iii ffl operation complete applicable item iii result add item item set 
item set 
case ffl ii 
dot item ii precedence checks done item item set 
precedence check time 
right weight nonterminal built parse tree parse tree accepted place leftmost production precedence 
item added item set precedence incorrect parse tree constructed case 
proceeding item set get item 
item set 
ffl operation complete applicable item go back item set see item iii pass precedence checks 
check left parse tree picture acceptable place right parse tree 
item iii inherited right precedence compared left weight item 
precedence check item added item set 
item set 

ffl iii result applying operation complete item iii item set item ii item set added 
item set case ffl ii 
parsers precedences precedence check causes problems precedences defined nonterminal item ii 
note right weight item ii updated maximum precedence production right weight item iii 
item new start symbol item set added item set result applying operation complete item ii 
item set 
ffl symbol scanned ready parser returns precedence correct tree case 
case 
correctness discussion section motivate version earley algorithm precedences correct 
state precedence correct trees result parser 
argue true showing close updating precedence components attribute evaluation rules 
precedence check operation complete corresponds exactly condition attribute grammar 
item earley algorithm represents sub parse tree 
precedence components attributes root parse tree 
item lps rps ff ffl lws rws represents parse tree ff lps lps rps rps lws lws rws rws show components lps rps lws rws updated way values equal values attributes corresponding annotated parse tree 
left right precedences components corresponding inherited attributes left right precedences updated operation predict 
updating corresponds exactly attribute evaluation rules left right precedences 
consider rule left precedences production attribute evaluation rule aff lps lps 
aff 
nt lps 
nt ff rule incorporated operation predict predict applied item item set lps rps pb ffla ff applying operation predict item left precedences lps inherited new items 
production fl precedence pa add item item set item set 
lps 
pb 
pa ffl fl right precedences updated corresponds rules right precedences 
assume ff nonempty 
dot left rightmost nonterminal updating right precedences corresponds exactly rule right precedences 
nonterminals middle right hand side left right precedences updated correspond rules 
left right weights weight components items correspond synthesized attributes left right weights 
components updated dot moved leftmost rightmost symbol right hand side 
consider rule left weights 
production attribute evaluation rule aff lws 
rule incorporated scan operation scan applied item item set lps rps ffl ff 
parsers precedences left weights updated new item added item set 
item set lps rps ffl ff second rule left weights bit complicated 
production attribute evaluation rule aff lws lws 
max lw lw lws 
lw lws fst aff rule incorporated operation complete dot moved nonterminal 
item operation complete applicable updatable left right weights dot item 
item set lps pa fl ffl lws rws assume item predicted item item set lps rps pb ffl ff lws result operation complete dot moved left weights updated follows item set lps rps pb ffl ff lws 
max lws fst pb lws result item set lps rps pb ffl ff lws 
updating right weights analogous 
precedence check precedence check corresponds exactly condition attribute grammar 
consider condition rule production condition bff true lps 
bff lp rw rw left ass rw rws fst lp ass snd lp condition ones incorporated operation complete item set lps pb fl ffl lws rws assume item predicted item item set lps rps pa ffl ff item added item set precedence check pass condition true 
condition rule lp lps 
pa fst lp ass snd lp rw rws lp condition true item added item set lp item added rw rw left ass 
incorrect parse trees built precedence correct parse trees result 
precedences lr parsing precedences widely lr parsing shown section way user precedences unnatural 
precedences productions cause conflicts parsing table built collections items sets 
pointed grammar precedences input lr parser generator equal precedence grammar generating language 
think precedence grammar intuitive natural indicate generate lr parsing table precedence grammar 
idea inherit precedences item sets conflicts occur 
done collection item sets constructed 
add extra component items dotted production 
extra component precedence component function nonterminals precedences 
contains precedence production possibly inherited precedences items 
denote production fl precedence production 
item denoted ff ffl fi ip ip precedence component 
construction collection item sets described dragon book asu chapter extend operation closure 
operation goto need changes 
closure operation precedence component inherit new items dot left nonterminal leftmost rightmost symbol 
set items grammar closure set items constructed rules 
initially item added closure 

ff ffl bfi ip ff fi ffl closure fl production add item 

ip closure fl production add item ip 

ff ffl ip closure fl production add item ip 

apply rules items added closure 

parsers precedences parsing table constructed collection items sets conflict precedence components 
conflict resolved favor item lowest precedence 
show done grammar section example 
give precedences nonterminal nonterminal left right recursive 
ae ae case ae int id 
int id big part collection item sets grammar 
simplicity precedences productions omitted 
fe 
pg denote function returns value argument 
item set item case ffl fe 
item dot left rightmost nonterminal 
precedence component inherited new item added operation closure 
item ffl 
fe 
added item set results operation goto item dot moved symbol time appear item sets item set item ffl ae fe 
dot left rightmost nonterminal precedence component inherited new items added operation closure 
ae ffl int fe 
ae ffl id fe 

case ffl fe 
ffl 
fe 

ffl 
fe 

ffl fe 
ffl ae fe 
ffl ae fe 
ffl case fe 


ffl fe 
ffl ae fe 
ae ffl int fe 
ae ffl id fe 
ae ae ffl fe 
ae ffl fe 
ae int ffl fe 
int id delta delta delta ae delta delta delta case delta delta delta constructing parsing table collection item sets item set generates conflicts 
input int id conflicts reduction 
shift 
conflicts resolved precedence components 
items involved conflicts precedences action parsing table item lowest precedence gives rise 
shift actions inputs int id action table state 
application state action int id case shift shift reduce application definition precedences earley parser parsing conctypes aps 
described part iii thesis 
suggested way resolve kind ambiguity ambiguity giving precedences alternatives left right recursive nonterminals 
kinds ambiguity resolved ambiguity common programming construct easily expressed ambiguous grammars 
having intuitive easy way resolve ambiguity improve readability programming language descriptions 
meaning grammar precedences precedence grammar terms attribute grammar 
showed quite easy incorporate precedence rules parsers 
appendix lemmas lemma precedence condition rule productions bff true right weight node zero 
proof consider precedence condition bff 
production condition bff true lps 
bff lp rw rw left ass rw rws fst lp ass snd lp suppose rw prove rw rw left ass condition true rw 
suppose 
rw left ass precedence zero associativity restriction 
lemma precedence condition rule productions ffb true left weight node zero 
proof analogous proof lemma 
lemma nonterminals left precedence node belong left edge node 
appendix lemmas nt nt nt lps nt 
lps nt 
lps nt proof attribute evaluation rule updates left precedences productions form ff 
production pictured ff left precedence nonterminal updated rule 
nonterminal clearly belongs left edge nonterminal left precedence hold lps apply argumentation 
lemma nonterminals right precedence node belong right edge node 
proof analogous proof lemma 
lemma right weight node nonterminal greater zero nonterminal appears twice right edge rws proof attribute evaluation rules right weights get right weight greater zero evaluation rule rws rws 
max rw rule applicable productions form ff rws 
means belongs right edge seen evaluation rules right weights 
appears twice right edge inside right edge lemma precedence condition productions bff precedence production left edge proof ignoring associativity lps 
bff nonterminals clearly precedence production left edge follows lemma belong left edge furthermore precedence occurrence follows attribute evaluation rules left precedences 
lemma precedence condition productions ffb precedence production right edge node containing proof analogous proof lemma 
lemma right weight nonterminal node maximum productions right edge node precedence production replaced zero 
ff ff ff gamma ff rps max ff delta delta delta ff gamma belong right edge proof follows rules right weights 
right weight node zero belong right edge terminal rightmost child follows immediately rule right weights 
sequence nodes nonterminals right edge terminal 
node right weight value synthesized follows second rule right weights rws 
right weight nodes right edge updated time occurs 
follows second rule time updated maximum precedence actual production right weight right weight node maximum productions right edge precedence ff replaced zero 
appendix lemmas lemma left weight nonterminal node maximum productions left edge node precedence production replaced zero 
proof analogous proof lemma 
lemma productions nonterminal precedences subtree root accepted 
proof precedences weights zero precedence conditions violated follows lemmas 
part vi recursive descent parser user defined distfix operators recursive descent parser user defined distfix operators annika aasa syntax programming language possibly include notation user may want 
desirable give possibility extend syntax 
way expressions offer user defined distfix operators 
distfix operator jon operator operator name distributed operands 
familiar example programming languages construction syntax expr expr expr distfix operators programs readable seen example 
left expression sml syntax right lisp syntax lt gt expression repeated infix operators type ff theta ff ff readable corresponding expression functions prefix notation 
example compare arithmetic expressions add add mul infix prefix postfix operators just special cases distfix operators 
distfix operators possible distinguish operands keywords just position case functions 
illustrated sum fn 
fn 
regard lisp syntax readable reading 
expressions supposed reflect mathematical formula gamma gamma note distinction operator function 
operator syntactical construction 
operator object way function 
operator example argument function operator 
disadvantage operators obvious apply operator arguments 
curried way functions 
haskell hea lml aj aj operator transformed function enclosed parentheses 
example denotes function fn 
denotes argument function fn 
fn 
programming languages give user possibility define infix operators 
languages provide user defined distfix operators 
examples obj hope bms 
implementations distfix operators seldom described literature 
jon description distfix operators parsed yacc joh 
introducing distfix operators usual way describing syntax programming language context free grammar 
parser language constructed grammar 
language user defined distfix operators user allowed extend syntax parser changed 
user course tell parser new distfix operators wants program 
see done consider expressions language generated grammar int id user wants add new distfix operator language give information corresponds production grammar 
nonterminal grammar suffices give terminals mark nonterminal placed 
experimental language information distfix declaration distfix user point view underscores mark positions operands placed 
parser point view underscores mark places nonterminal placed declaration seen production grammar terminals compose distfix operator 

introducing distfix operators 
distfix declaration parser able parse things language generated grammar int id user declared distfix operator distfix syntax expressions consider distfix grammars defined part iv thesis definition section 
distfix grammar contains nonterminal generates language consisting distfix operators 
call terminals compose distfix operator operator words 
note distfix operators divided different categories 
postfix distfix operand left leftmost operator word right rightmost 
example 
prefix distfix operand left leftmost operator word right rightmost 
example 
infix distfix operands left leftmost operator word right rightmost 
example 
closed distfix operands left leftmost operator word right rightmost 
example want parser transform expressions programs syntax trees 
said effect distfix declaration new production added distfix grammar 
causes problem 
resulting grammar ambiguous 
example parser know syntax tree want sentence 
distinct syntax trees sentence solution problem require user ambiguous expression solution parentheses expression hard read 
solution completely rewrite grammar unambiguous introduces new nonterminals grammar quite big unreadable hard see user indicate new distfix operator production placed grammar 
third solution suitable case precedence associativity rules throw away undesirable syntax trees 
definition syntax trees precedence grammar distfix grammar precedence rules generates part iv thesis aas 
generated syntax trees called precedence correct 
definition formal restrict informal description precedences eliminate ambiguity 
operator higher precedence binding power lower 
usual arithmetic operators addition operator higher precedence multiplication operator 
notion precedence example prolog ss obj 
recall ambiguous sentence possible syntax trees 
suppose know precedence predefined infix operator 
want sentence parsed syntax tree give distfix operator lower precedence want parsed second syntax tree give distfix operator higher precedence 
experimental language information precedence operator declared distfix precedence declaration gives right syntax tree page correct 
note need precedence resolve ambiguity operands enclosed operator words 
infix distfix give information parser want operator left associative right associative example want expression parsed left associative right associative 
experimental language infix distfix operator right associative word declaration necessary associativity rules prefix postfix distfix operators operator word side expression 
closed distfix operators useful precedence associativity rules operator words enclosing expression acting somewhat parentheses 
relies fact accept different operators operator words 
accept possible combinations precedences operators get ambiguities 
example allow user define prefix operator postfix operator equal precedence distfix distfix possible parsings sentence 
parser user defined distfix operators gamma gamma precedences disambiguate sentence 
similar example distfix define infix operators equal precedence different associativity 
information declaration disambiguate possible parsings sentence gamma gamma gamma gamma yacc joh declares operators associativity gives precedence 
operators example declared left associative sentence 
parsed syntax tree 
behaviour postfix operator higher precedence 
analogously declared right associative behaviour prefix operator higher precedence sentence parsed syntax tree 
third alternative yacc declare operators nonassociative 
syntax error string 
possible declare operators equal precedence unequal associativity yacc problem deciding parse string left associative right associative arise 
problem second example 
sml define new infix operators parsing second example syntax tree 
behaviour left associative infix operators lower precedence right associative ones 
experimental implementation allow operators different kinds precedence problems arise 
parser user defined distfix operators experimental parser user defined distfix operators implemented sml mth 
recursive descent dm parser uses parser constructors due burge bur fairbairn fai kent petersson holmstrom pet 
parser constructors easy write parser grammar 
possible generate parser directly precedence grammar 
precedence rules incorporated grammar 
shown part iv thesis aas quite complicated precedence grammar contains infix prefix postfix operators different precedence solely infix operators 
furthermore parser recursive descent parser grammar left recursive 
order able eliminate left recursion variant algorithm part iv thesis aas 
algorithm transforms precedence grammar ordinary context free grammar 
describe parser constructors write parsers languages containing infix distfix operators 
program examples written sml 
example parser constructors complete description parser constructors implementations pet rea chapter interested informal description constructors example hopefully 
parser constructors write parser language generated precedence grammar left associative left associative left associative left associative int id transform precedence grammar ordinary context free grammar precedences incorporated asu chapter 
eliminate left recursion asu chapter 
transformation obtain grammar el el addop el ffl el el mulop el ffl int id addop mulop parser constructors easily write parser language 
parsing function nonterminal grammar takes list terminal symbols argument initial part list correct form parsing function succeeds returns representation initial part rest list 
initial part list correct form grammar parsing function fails 
type parsing function ff fi ff type terminal symbols fi type representation part list parsed 
go details datatype ff fi 
parsing functions constructed parser constructors briefly explain 
construct parsing function recognizing terminal symbols 
takes terminal symbol argument gives parsing function recognizing terminal symbol result 
type ff 
ff ff 

parser user defined distfix operators sequencing 
takes parsing functions argument returns parsing function result 
type ff fi theta ff fl 
ff fi theta fl 
alternatives 
takes parsing functions argument returns parsing function result tries parsing function fails 
type ff fi theta ff fi 
ff fi 
alt alternatives 
takes list parsing functions type argument returns parsing function tries alternatives order succeeds 
type ff fi list 
ff fi 
type transformations parsing 
takes parsing function function argument returns parsing function recognizing thing argument parsing function returns representation parsed sentence 
necessary constructor get type correct program 
type ff fi 
fi fl 
ff fl 
suppose parsing function id recognizes identifier parsing function int recognizes integer constant functions define parsers languages generated nonterminals el el addop mulop 
parsing function epsilon succeeds input 
note strong correspondence parser grammar fun el el addop el epsilon el el mulop el epsilon int id addop mulop parser supposed recognize sentences language 
substantial problem program type correct 
type correct parser constructor 
changes type parsing function 
problem practice parser usually anyway translate sentence representation 
translation syntax trees normally parser recognize language translate sentences syntax trees rest compiler 
attribute grammars asu chapter knu knu formalism specifying translations programming constructs 
attribute grammar specifies translation construct terms attributes associated syntactic components 
attribute said synthesized value parse tree determined attributes values children node 
value inherited attribute node defined terms attributes parents siblings node 
values attributes specified evaluation rules productions 
turn example grammar attribute grammar specifying evaluation rules syntactical construction translated syntax tree val infix val val val infix val val val infix val val val infix val val int val num int val id val var id val eliminating left recursion transform evaluation rules resulting syntax tree 
algorithm dragon book asu chapter 
synthesized attributes attribute grammar inherited attributes 
result transformation attribute grammar el el val val el val el addop el el infix el addop val val el val el val el ffl el val el el el val val el val el mulop el el infix el mulop val val el val el val el ffl el val el int val num int val id val var id val addop addop val addop val mulop mulop val mulop val 
parser user defined distfix operators attribute inherited attribute val synthesized 
implementing translation specified attribute grammar sml inherited attributes arguments parsing functions synthesized attributes results parsing functions 
production example see result syntax tree parsing function argument parsing function el 
schema occurs evaluation rules introduce parser constructor works 
sequencing grammar result operand parsing function argument second operand 
type 
ff fi theta fi 
ff fl 
ff fl new parser constructor easily write parsing functions language gives syntax trees result 
convenience change parsing function epsilon bit 
succeeds inputs gives extra argument result 
type operator string datatype tree infix tree operator tree var string num int fun 
el el lt addop 
fn aop rt infix lt aop rt 
el epsilon lt 
el el lt mulop 
fn mop rt infix lt mop rt 
el epsilon lt int id addop mulop user defined infix operators functions functions el el identical 
parameterize parsing functions precedence just need function ens 
parsing function inop recognizes infix operators specific precedence 
fun ae 
el el lt inop 
fn op rt infix lt op rt 
el epsilon lt ae int id inop alt map snd filter difficult see user defined infix operators implemented 
just parse infix declarations build operator precedence list 
predefined operators course list 
give list argument parsing function parse functions el inop contained 
body parse call highest precedence fun parse fun 
el lt ae inop alt map snd filter function application juxtaposition 
causes problem seen invisible predefined infix operator 
decide precedence allow operators precedence 
functional languages function application lowest possible precedence 
necessary 
problem allowing user possibility defining operators lower precedence function application 
think convenient function application lowest precedence 
user defined infix distfix operators see introduce user defined infix distfix operators 
recall infix distfix operator operator consisting number operator words operands parser constructors course 

parser user defined distfix operators left leftmost operator word right rightmost operator word 
simplicity assume operators left associative 
changes method introduced section parsing infix operators 
important thing operands operator words seen belonging operator operands outside operator words 
change parsing function inop recognizes operator word infix operator parsing function recognizes number operator words expressions 
example distfix declaration distfix parsing function inop able recognize sequence expr expr parsing function inop uses auxiliary function takes parsing function recognizing expressions list operator words argument returns parsing function recognizing sequence operator words expressions 
example expr returns parsing function recognizes sequence expr expr fun inop alt map expr snd filter expr parsing function recognizing expressions highest precedence 
parsing function el changed bit handle value returned new variant inop 
means code transforming recognized expressions operators changed order structure correct 
complete distfix parser complete distfix parser simplified version algorithm part iv thesis aas transforms precedence grammar unambiguous context free grammar 
simplified algorithm give unambiguous grammar result recursive descent parser constructed grammar give precedence correct syntax trees 
note inl inr pre post closed distfix operators 
example post shorthand op op delta delta delta op op op operator words post highest precedence distfix operators 
simplified version algorithm 
give operators numbers way done original algorithm 

introduce nonterminals productions 
rule left associative infix operators 
inl inl inl inl gamma inl gamma number left associative infix operators number postfix operators higher precedence inl rule right associative infix operators 
inr inr gamma inr inr inr gamma number right associative infix operators number postfix operators higher precedence inr rule prefix operators 
pre pre gamma number prefix operators number postfix operators higher precedence pre rule postfix operators 
post post gamma number postfix operators number postfix operators higher precedence post rule 
ae post gamma post number postfix operators rule 
ae int id closed number closed operators pre pre number prefix operators 
start symbol grammar nonterminal highest precedence operators 
simplification compared original algorithm index nonterminals telling uncovered prefix operators allowed occur 

parser user defined distfix operators elimination left recursion try implement parser grammar constructed algorithm eliminate left recursion direct indirect asu chapter 
start eliminating direct left recursion rule left associative infix operators rule inl inl gamma el inl el inl inl inl gamma el inl ffl number left associative infix operators number postfix operators higher precedence inl rule right associative infix operators left recursive 
left factoring asu chapter transformation easier parser efficient rule inr inr gamma er inr er inr inr inr ffl number right associative infix operators number postfix operators higher precedence inr rules prefix postfix operators left recursive rule contains indirect left recursion 
realize consider derivation post gamma post delta delta delta post eliminate indirect left recursion start transforming production contains direct left recursion post gamma post transforming step replace nonterminal production right hand side production nonterminal 
step get production know postfix operator precedence post post gamma gamma post steps production get depends grammar 
reflections 
replace nonterminal result depends kind operator precedence possibilities ffl left associative infix operator 
nonterminal replaced gamma el 
ffl right associative infix operator 
nonterminal replaced gamma er 
ffl postfix operator 
nonterminal replaced gamma 
ffl prefix operator 
nonterminal replaced gamma 
replacement step index decremented 
replacements nonterminal production form delta delta delta post el er depending left associative right associative infix operator precedence lowest precedence infix operators highest precedence post infix operators 
eliminate direct left recursion achieve non left recursive rule 
ae aep aep delta delta delta post aep ffl number postfix operators parser explain complete distfix parser constructed 
parser returns syntax tree go details tree constructed 
main function parse lists distfix operators 
left associative infix distfix operators right associative infix distfix operators prefix distfix operators postfix distfix operators closed distfix operators 
function parse contains number local parsing functions auxiliary functions 
explain important 
usual recursive descent parsing parsing function corresponding nonterminal grammar 
el er ae aep 
nonterminal parsing function arguments corresponding indices function corresponds production rule 
ae aep parsing function fun ae 
aep function corresponds productions left hand side ffl inl inl gamma el inl ffl inr inr gamma er inr ffl pre pre gamma ffl post post gamma parsing function check kind operator precedence function returns kind operator having precedence 
parser user defined distfix operators case infixl 

el infixr 

er postfix 
prefix 
nonterminal el parsing function el arguments integer corresponding index syntax tree 
function inop parsing function recognizing infix distfix operators precedence including expressions operator words fun el lt inop 
fn iop ts rt 
infix iop lt ts rt 
el epsilon lt function el corresponds productions el inl inl inl gamma el inl ffl parsing function er fun er lt inop 
fn inop ts rt 
infix inop lt ts rt epsilon lt function corresponds productions er inr inr inr ffl nonterminal ae atomic expressions prefix expressions closed distfix expressions generated parsing function ae 
variables respectively lists prefix distfix operators closed distfix operators ae alt int id map fn words 
expr words 
closed map fn 
expr 
fn preop ts 
prefix preop ts function corresponds productions ae int id closed number closed operators pre pre number prefix operators productions nonterminal aep aep delta delta delta post aep ffl nonterminal parsing function aep arguments corresponds index syntax tree aep alt map fn ppost ppost 
fn pt postop ts 
postfix postop pt ts 
aep epsilon function takes syntax tree list precedences arguments returns parsing function recognizing sequence delta delta delta lowest precedence list infix distfix operator highest precedence list exists infix distfix operator 
function parsing function recognizing distfix postfix operators including expressions operator words ppost returns precedence th postfix operator 
body main function parse consists single call parsing function highest precedence operators 
summary shown expression part parser language user defined distfix operators implemented parsing method recursive descent 
achieve parser language course implement parts parser example part recognizes distfix declarations builds operator lists 
bibliography bibliography aas annika aasa 
recursive descent parsing user defined distfix operators 
licentiate thesis department computer sciences chalmers university technology goteborg sweden may 
aas annika aasa 
precedences specifications implementations programming languages 
wirsing editors proceedings third international symposium programming language implementation logic programming lecture notes computer science volume pages 
springer verlag august 
aj lennart augustsson thomas johnsson 
lazy ml user manual 
programming methodology group department computer sciences chalmers goteborg sweden 
distributed lml compiler 
aj lennart augustsson thomas johnsson 
chalmers lazy ml compiler 
computer journal 
aho johnson ullman 
deterministic parsing ambiguous grammars 
communications acm august 
am andrew appel david macqueen 
standard ml compiler 
proceeding acm lisp functional programming pages 
acm 
aps annika aasa kent petersson dan 
concrete syntax data objects functional languages 
proceedings acm conference lisp functional programming pages snowbird utah 
asu alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley publishing reading mass 
au alfred aho jeffrey ullman 
theory parsing translation compiling volume parsing prentice hall 
aug lennart augustsson 
compiler lazy ml 
proceedings acm symposium lisp functional programming pages austin 
bibliography bac backus 
syntax semantics proposed international algebraic language zurich acm conference 
proceedings international conference information processing june pages unesco paris 
bac roland backhouse 
syntax programming languages theory practice 
prentice hall 
bms burstall mcqueen sannella 
hope experimental applicative language 
conference record lisp conference pages stanford ca august 
bur burge 
recursive programming techniques 
addison wesley publishing reading mass 
david cantor 
ambiguity problem backus systems 
journal acm 
car luca cardelli 
basic polymorphic typechecking 
science computer programming 
ch cousineau huet 
caml primer 
technical report inria france 
cu cleaveland 
grammars programming languages 
elsevier north holland 
kahn lang el ese 
document structure modularity mentor 
proceedings acm sigsoft sigplan software engineering symposium practical software development environments pittsburgh 
software engineering notes vol 

dm davie morrison 
recursive descent compiling 
horwood limited 
dm luis damas robin milner 
principal type schemes functional programs 
proceedings th acm symposium principles programming languages pages albuquerque nm january 
ear jay earley 
efficient context free parsing algorithm 
communications acm february 
ear jay earley 
ambiguity precedence syntax description 
acta informatica 
fai jon fairbairn 
making form follow function exercise functional programming style 
software practice experience 
futatsugi goguen 
jouannaud meseguer 
principles obj 
proceedings th acm symposium principles programming languages pages new orleans january 
bibliography flo robert floyd 
ambiguity phrase structure languages 
communications acm 
flo robert floyd 
syntactic analysis operator precedence 
journal acm 
fm chin mishra 
type inference subtypes 
ganzinger editor proceedings esop 
lncs vol 
pages nancy france 
springer verlag 
ge goos hartmanis eds 
programming language ada manual volume lecture notes computer science 
springer verlag 
american national standards institute ansi mil std 
gj dick jacobs 
programmer friendly ll parser generator 
software practice experience 
gj dick jacobs 
parsing techniques practical guide 
ellis horwood limited 
gmw gordon milner wadsworth 
edinburgh lcf volume lecture notes computer science 
springer verlag 
gor gordon 
denotational description programming languages 
springer verlag 
thatcher wagner wright 
initial algebra semantics continuous algebras 
jacm january 
han david hanson 
compact recursive descent parsing expressions 
software practice experience 
hea paul hudak philip wadler report functional programming language haskell august 
version 
heering hendriks klint rekers 
syntax definition formalism sdf manual 
acm sigplan notices 
jan heering paul klint jan rekers 
incremental generation parsers 
acm sigplan notices 
hoa hoare 
recursive data structures 
international journal computer information sciences 
hue erard huet 
formal structures computation deduction 
lecture notes international summer school logic programming calculi discrete design marktoberdorf germany may 
inr inria 
ml handbook version 
project inria may 
bibliography joh johnson 
yacc compiler compiler 
technical report bell labs 
unix programmer manual volume 
jon simon peyton jones 
parsing distfix operators 
communications acm february 
jon simon peyton jones 
implementation functional programming languages 
prentice hall 
knu donald knuth 
backus normal form vs backus naur form 
communications acm 
knu donald knuth 
translation languages left right 
information control december 
knu donald knuth 
semantics context free languages 
math 
systems theory 
knu donald knuth 
semantics context free languages correction 
math 
systems theory 
lan landin 
mechanical evaluation expressions 
computer journal 
ldr wilf lalonde jim des rivieres 
handling operator precedence expressions tree transformations 
acm transactions programming languages systems january 
les lesk 
lex lexical analyzer generator 
cstr bell laboratories murray hill 
mau michel mauny 
parsers printers stream destructors embedded functional languages 
proceedings acm conference functional programming languages computer architecture pages london 
mdr michel mauny daniel de 
parsers ml 
proceedings acm conference lisp functional programming pages san francisco california 
mil robin milner 
theory type polymorphism programming 
journal computer systems sciences 
mil robin milner 
standard ml proposal 
polymorphism ml lcf hope newsletter january 
mth robin milner mads tofte robert harper 
definition standard ml 
mit press 
nau peter naur 
revised report algorithmic language algol 
communications acm 
bibliography par parikh 
context free languages 
journal acm 
pet kent petersson 
ml 
department computer sciences university goteborg chalmers university technology goteborg sweden 
pf mikael pettersson peter 
dml meta language system generation practical efficient compilers denotational specifications 
proceedings th ieee international conference computer languages iccl 
pf mikael pettersson peter fritzson 
general practical approach concrete syntax objects ml 
proceedings acm sigplan workshop ml applications pages san francisco california 
pw fernando pereira david warren 
parsing deduction 
proceedings st annual meeting association computational linguistics pages 
qui willard van quine 
mathematical logic 
university press 
rea chris 
elements functional programming 
addison wesley publishing reading mass 
san david sandberg 
language combining flexible syntax classes 
proceedings th acm symposium principles programming languages pages albuquerque nm january 
sha michael share 
resolving ambiguities parsing translation grammars 
acm sigplan notices 
sli konrad slind 
object language embedding standard ml new jersey 
proceedings sml workshop 
ss leon sterling ehud shapiro 
art prolog 
mit press 
str stroustrup 
programming language 
addison wesley publishing reading mass 
sw daniel neil 
data structures data types pascal 
brooks cole publishing pacific grove california 

functional parser generator 
licentiate thesis department computer sciences chalmers university technology goteborg sweden 
voi fr ed eric 
tool interactive grammar construction expression parsing 
science computer programming 
bibliography van wijngaarden revised report algorithmic language algol 
acta informatica 
wal weis mauny 
caml manual 
inria france 
technical report 
wan mitchell wand 
semantic prototyping system 
proceedings acm sigplan symposium compiler construction pages june 
wha wharton 
resolution ambiguity parsing 
acta informatica 
wir niklaus wirth 
programming language pascal 
acta informatica 
