deliverables categorical approach program development type theory james hugh mckinna doctor philosophy university edinburgh le ne que les pr es thesis considers problem program correctness rich theory dependent types extended calculus constructions ecc 
system contains powerful programming language higher order primitive recursion higher order intuitionistic logic 
supported pollack versatile lego implementation extensively develop mathematical constructions studied 
systematically investigate burstall notion deliverable program paired proof correctness 
approach separates concerns programming logic want simple program extraction mechanism 
sigma types calculus enable achieve 
similarities subset interpretation martin lof type theory 
show deliverables rich categorical structure correctness proofs may decomposed principled way 
categorical combinators define system package logical book keeping allowing concentrate essential structure algorithms 
demonstrate methodology number small examples culminating machine checked proof chinese remainder theorem showing utility deliverables idea 
drawbacks encountered 
consider semantic aspects deliverables examining definitions setting firmly category theory 
aim overcome language categorical combinators ii dependent type theories interpretation fibrations 
elaborate concrete instance category sets generalises arbitrary topos 
process uncover subsystem ecc speak deliverables defined topos 
presence extra structure interpretation extends ecc 
wheel turns full circle 
acknowledgments ffl firstly supervisor rod burstall sense humour encouragement sage advice enjoyed creative partnership studies edinburgh ffl members lego club especially randy pollack zhaohui luo ways supported conceivable randy lego implementation luo extended calculus constructions ffl eugenio moggi bart jacobs herman geuvers illuminating discussions fibrations type theory ffl roy dyckhoff fer jan de vries waiting folk sixth seminar sheaves logic hasty rehearsal chapter ffl wes phoa unwittingly responsible chinese remainder theorem convinced thought experiment chapter enjoyed fruitful discussions stages ffl science engineering research council funding research providing spur write promptly harold simmons iii acknowledgments iv meetings opportunities sponsored initiative aegis ffl readers various drafts stuart anderson gardner goguen stephen gilmore jane claire jones wes phoa alan thoughtful criticism attention deserve expected ffl claire jones typesetting expertise ffl secretaries computing support staff making research possible computer science department edinburgh ffl emotional support laughter tears parker lately salisbury centre men group ffl long suffering flat mates jennifer ruth jonathan ffl friends kept going neglected friendship ffl finishing ffl parents owe special kindness support years student ffl gill love companionship 
declaration declare thesis composed contained stated 
draft outlining ideas chapter appeared 
james hugh mckinna table contents ii acknowledgments iv declaration contents vi 
formal methods foundations type theory category theory overview thesis related prerequisites 
type theoretic preliminaries ecc lego review ecc term calculus derivable judgments ecc proof theoretic properties calculus equality conversion vi table contents vii review lego syntax theorem prover additional features lego system equality conversion bis 
sample derivation 
order second order deliverables definition properties order deliverables specifications order deliverables equality deliverables semi structure categories identities composition semi terminal object binary semi products binary semi coproducts semi exponentials semi pullbacks internalisation equality factorisation system del consequence rule pointwise construction inductively defined types table contents viii second order deliverables thought experiment basic definitions del semi ccc del indexed category del pullback functors del del indexed sums products second order deliverables natural numbers lists lists 
examples division mathematical specification correctness proof intended algorithm development terms deliverables finding minimum list mathematical specification correctness proof intended algorithm development terms deliverables insert sort mathematical specification correctness proof insert sort proof recast terms deliverables table contents ix completed development terms deliverables chinese remainder theorem mathematical specification development terms deliverables 
deliverables construction order deliverables hyperdoctrines programming language assertions topos theoretic model modelling dependent types hyland pitts categories fibrations interpreting types terms dependent products category fibrations propositions types cc model definition properties definition category fibration type substitution dependent products definition category fibrations prop table contents prop included type propositions yield types dependent products consistency model proof irrelevance extensionality model luo ecc sums type universes 
partial equivalence relations observational equivalence data abstraction parametricity second order calculus extraction realisability partial functions type theory pragmatics fibrations basic definitions naturality beck chevalley condition categories fibrations table contents xi lego code relevant thesis basics basic logic basic datatypes unit booleans naturals calculus relations polymorphic lists permutation sorting lemmas deliverables order deliverables order deliverables sums natural numbers polymorphic lists second order deliverables second order deliverables natural numbers lists examples simple example division minimum finding list insert sort chinese remainder theorem bibliography chapter thesis concerns number insights techniques obtained category theory applied study programs correctness proofs constructive type theory 
provides modest exploration interaction disciplines heart research theoretical computer science 
largely unpublished ideas rod burstall 
formal methods years researchers pursued grail verified programming 
longer may content regard programming craft strive preserve 
thesis represents experiment field context integrated environment development mathematical proofs contains powerful programming language 
environment furnished pollack lego implementation extended calculus constructions chapter 
represents experimental tool investigation new methods features computation logic combined system 
strengths formal reasoning machine relegate logically dull activity computing substitutions proof tool unification devices user having manage tedious book keeping 
set activity formal proof observed times various authors research workers carries huge burden information typically suppressed mathematicians regard acceptable proofs 
aims thesis develop languages sufficient expressiveness enable construct proven programs structured way mirroring construction programs 
contrasting approaches formal development correct programs 
classically typically write program produce separate proof correctness 
approach unsatisfactory proof separate program 
acceptable formalism floyd hoare assertions local correctness statements attached program phrases dijkstra predicate transformers may derive appropriate guards calculating weakest preconditions 
constructive type theoretic approach prove mathematical theorem constructive logic extract program 
method attractive sight considerable difficulty separating algorithmic part proof correctness part 
annotate proof way mark parts computationally relevant opposed serve demonstrate correctness extracted program 
look constructive proof statement form chapter 
emerges function individual proof produces pair consisting individual proof satisfies 
words get result providing proof 
try develop substantial program way need handle proofs time attempt calculate values proof computation inextricably mixed 
burstall idea consider pairs function individuals individuals proof thesis consider systematic development proven programs type theory idea deliverable 
approach clear separation computation proof gain construct separately 
examine possibility compositional development pairs 
face obstacle asymmetry definition 
approximation simply consider unary predicates relations examine pairs function proof burstall observed deliverables form category additional structure 
enables construct deliverables style categorical combinators calculus 
subsequent burstall author sketched extend framework allow speak relations input output preserving categorical character construction 
ideas elaborated section thesis 
chapter 
methodology propose regarded panacea problems verified programming 
eliminate essential difficulty furnishing proofs allow proofs structured ad hoc way 
sense localised difficulty insisting structure intended partially elaborated algorithm underlie correctness proof 
experience chinese remainder theorem chapter bear 
major drawback language categorical combinators 
significant advance develop type theoretic language deliverables 
system chapter derived semantic considerations deliverables regarded preliminary step direction 
foundations type theory category theory years seen revitalisation intuitionistic mathematics emergence various type theories focusing notion construction relationship proof theory calculus 
starting howard account propositions types constructive reading logical connectives semantics proofs revealed close connections intuitionistic mathematics functional programming 
ideas elaborated scott de bruijn workers automath project notably martin lof succession predicative systems bear name :10.1.1.135.7851
central systems idea dependent type family types 
parallel development girard considered impredicative systems related simple type theory 
coquand huet able unite dependent types impredicativity calculus constructions cc 
luo synthesised martin lof idea chapter 
predicative hierarchy type universes impredicative calculus constructions extended calculus constructions ecc :10.1.1.38.7596
context notion deliverable considered simple case function respecting unary predicates appear new 
proof normalisation theory martin lof gave interpretation due hancock judgments theory model closed terms types interpreted sets closed terms subject predicate satisfied interpretation grand simultaneous inductive definition derivable judgments theory 
particular clause function space embodies idea deliverables 
applies normalisation proof reducibility method 
reducibility predicate oe defined induction type function clause essentially oe oe oe fa martin lof interpretation years giving account subset types martin lof type theory shall say 
parallel development similar period emergence internal languages categories crude simply extensional type theories unary function symbols 
presence structure images cartesian products closedness yields strengthening type formation derivation rules internal logic 
effort expended seventies systematic exploration interaction logical properties categorical structure culminating elaboration internal logic toposes 
significant development regard lawvere tierney observation representability notion subobject called subobject classifier set theory possible 
significant authors development am grateful furio honsell pointing connection chapter 
internal language realisation just russell church noted different terms impredicative definitions higher order logic extensional intuitionistic setting obtainable small complete internal poset omega object objects subobject classifier ch 
subsequent research categorical logic considered richer type systems fibrations emerging central unifying concept 
shall return issues chapter 
type theoretically notion subset subset type clearly defined 
probably closely argued theoretically satisfying goteborg group :10.1.1.135.7851
troubling desirable 
features role subsets play suppressing propositional information programs 
topos subobjects give semantics judgments logic ensures propositions proof calculus propositions types possibly yielding potentially huge proliferation dependence functions proofs 
treatment deliverables follows path systematically developing proofs correctness computational information kept distinct propositional information 
presence sigma types allows 
overview thesis chapter sets type theoretic preliminaries require study approach program correctness 
luo extended calculus constructions ecc sketched basic framework types terms :10.1.1.38.7596
calculus intended provide unified account dependent type theory brings theory predicative datatypes impredicative higher order logic 
chapter 
separation datatypes propositions heart deliverables idea 
presence sigma types calculus allows maintain distinctions structured way 
discuss number features calculus including simple lemma equality repeatedly verifying basic properties deliverables 
number derivations illustrating expressive power calculus 
discuss small example concerning numbers context general view program specification 
discuss pollack lego implementation extended calculus constructions 
versatile system allows develop proofs constructions refinement 
system achieves great utility powerful mechanism extending basic calculus definitions 
describe number features system extensively research 
particular mathematical proofs thesis checked system exception concerning categorical constructions chapter 
proof term exhibiting mathematical construction text illustrated corresponding term lego system 
sample derivation number example give reader reasoning system 
elaborate examples discussed chapter 
system extended allow inductive definitions datatypes style martin lof type theory 
allows direct access powerful programming language higher order primitive recursion 
illustrate language examples natural numbers lists 
impose restriction programs simply typed allow polymorphism type level full power dependent types 
reasons 
pragmatic programming language resemble language standard ml dependent type constructors various points convenient prototype notation algorithms chapter 
represent lego 
practical terms course restriction helps keep things simple understand going 
amore ambitious task develop theory full language dependent types 
feel thesis represents substantial step direction 
second reason arises particular approach adopted developing structure various categories deliverables 
wished part allow methodology applied church representations datatypes impredicative level calculus 
hopefully permitted comparison reported paulin mohring collaborators program extraction coquand original calculus constructions 
unfortunately connections remain precise 
chapter introduces central definitions concepts thesis 
define simple notion specification consisting type predicate defined 
show define order deliverables program proof pairs respect notion specification type theory ecc 
demonstrate various constructions may gadgets provide practical examples methodology propose meta theory 
show order deliverables form closed category sense 
theorem 
may equip category order deliverables weak notion natural numbers object lists 
show correctness proof simple doubling function framework 
discuss refine basic notions able express statement function respects relation input output 
leads notions relativised specification secondorder deliverables principal objects study examples considered 
turns structure second order deliverables similar order deliverables 
stated precisely obtain chapter 
theorem theorem specification category second order deliverables structure semi ccc theorem theorem second order deliverables form indexed category category order deliverables fibres semi cccs semi cc structure strictly preserved reindexing order deliverables 
show rules recursive specifications natural numbers lists employ examples 
chapter discusses number examples development small programs deliverables methodology 
example discusses proof chinese remainder theorem illustrating secondorder deliverables separating roles parameters dependent variables proof economy deliverables style separate correctness proof underlying algorithm 
chapter return category theory 
explore idea deliverables may elaborated setting category intended model typed functional language system predicates indexed 
give detailed account particular instance construction topos 
categorical understanding semantics type theories allows describe model type theoretic terms 
uncover subsystem cc ecc describes deliverables 
cc introduced luo overcome non conservativity cc church simple theory types 
enables represent type individuals church system constant type level prop level 
set theory embodied topos sufficiently rich example case zermelo frankel set theory inaccessible cardinals may interpret ecc 
case arrive fragment lego system may logic chapter 
correct programs higher order logic topos 
believe may useful consequences pragmatics program development set existing formal design methodologies higher order logic 
thesis ends number avenues exploration ideas 
related basically approaches logical account formal program development 
relies annotating programs logical formulae expressing correctness program terms logical deductions 
origins floyd hoare sixties example 
idea deliverable clearly echoes idea brought functional setting 
avoids defect floyd hoare style having object language meta logical variables footing object variables chosen type theory 
proofs obtain encoded logic programs 
case hoare logic edinburgh logical framework proved quite difficult formulate satisfactory notion encoding 
second approach various intuitionistic type theories develop constructive proofs realisability techniques extract algorithmic information 
martin lof type theory calculus constructions style :10.1.1.135.7851
thesis uses ideas schools 
influential theory subsets martin lof type theory 
treatment chapter reader referred detailed discussion 
central problem constructive proofs programming discipline proofs contain redundant information 
dependent types allow express logical predicates chapter 
types permit representation recursive functions 
calculus constructions precise statement result berardi mohring theorem cc conservative 
consequently cc represent standard representation functions inductive types due variously church girard leivant functions 
proof syntactic mapping called berardi mohring projection 
mohring mapping extraction function coupled associated realisability predicate allows powerful flexible approach program development proofs 
interpretation arbitrary type interpreted type predicate realisability predicate defined 
approach taken separate computationally relevant proofs purely logical translation judgments basic formal system multiple judgments 
translation permits formation subset type fx ajb reasonable elimination rule may 
attempt equip basic theory type may precisely hide information precise nature proof predicate holds yields unsatisfactory results 
basic theory types terms martin lof type theory step extend theory notion proposition judgment true propositions 
straightforward propositions types 
proposition just type basic theory 
proposition true element inhabiting basic theory 
seemingly innocent proof irrelevance gives subset theory power 
subset theory interprets basic judgment set chapter 
martin lof type theory judgments underlying theory prescribing ffl set basic theory ffl family propositions prop basic theory :10.1.1.38.7596
corresponds definition specification section 
equality sets equality underlying sets uses logical equivalence families rejected choice favour decidable relation convertibility ecc :10.1.1.38.7596
membership judgment interpreted obvious way may derive derive true basic theory :10.1.1.38.7596
captures essential idea judgments set describe subsets terms underlying theory :10.1.1.38.7596
way proofs propositions systematically suppressed 
relatively straightforward see allows interpretation subset type constructor 
compare approach 
resulting expressions various type constructors similar compare example definition exponential second order deliverables pi type subset interpretation 
consider explicit proofs propositional parts specifications need know proof may derived subset theory 
limitations approach know certain derivations subset theory arise certain derivations 
sigma types contrast means represent derivations deliverables actual terms ecc definable combinators code explicit translation 
price pay clumsy language chapter 
terms opposed conceptual elegance reusing basic language types terms subset theory 
nuprl system developed constable workers early versions martin lof type theory 
particular underlying term calculus untyped system extensional equality types 
advantage suppressing irrelevant information proofs 
overcomes limitations explicit subset type constructor theory intensional equality exposed 
disadvantage basic judgments theory undecidable coupled proliferation formedness conditions application rules 
hayashi proposed system realisability abandons usual type constructors pi sigma date type theory favour set theoretic style union intersection singleton types 
system considers ingenious represent dependent products dependent sums 
time typing rules union intersection hide information 
allows simple translation extraction programming language polymorphic type discipline 
singleton types essential achieving harmony type system underlying untyped terms 
pavlovic thesis elaborates categorical terms theory constructions programs depend proofs logical propositions 
models constructions considered hyland pitts emphasis extensional systems intensional system 
proof theoretic properties regarded implementation answer 
chapter 
prerequisites assume reader familiar basic account category theory including definition adjunction cartesian closed category example mac lane lambek scott 
assume reader rudimentary understanding type theory 
excellent systems martin lof contained book nordstrom petersson smith 
chapter type theoretic preliminaries ecc lego review ecc luo extended calculus constructions ecc rich type theory containing coquand huet calculus constructions subsystem strong sigma types cumulative hierarchy predicative universes systems considered martin lof collaborators :10.1.1.38.7596
systems propositions types paradigm due curry howard ideas go back constructive reading logical connectives due heyting kolmogorov 
martin lof systems types may read propositions coquand huet original system propositions may read types 
ecc avoids blurring distinctions giving access full intuitionistic higher order logic propositional level predicative environment computation mathematics 
precisely ability distinguish propositional computational information single framework underlies approach program development 
chapter 
type theoretic preliminaries ecc lego ecc built calculus terms formal system deriving judgments define typed terms 
term calculus collection terms grammar piv tt sigmav pair ranges infinite collection variables ranges prop type called kinds ecc 
prop impredicative universe coquand huet original systems intended contain propositions type predicative universes set theoretic hierarchy similar versions martin lof theories 
substitution free occurrences variables defined usual way 
terms identified renaming bound variables 
basic conversion relation fi defined terms usual congruence closure familiar reductions fi oe pair 
extended cumulativity relation relation terms ffl pre order fact luo proves partial order respect conversion fi ffl kinds prop type type chapter 
type theoretic preliminaries ecc lego ffl respects formation pi types sigma types 
derivable judgments ecc context finite sequence declarations form term 
denote empty context ffi judgment relation form gamma gamma context terms 
gamma empty context simply write place ffi rules ecc table :10.1.1.38.7596
fv typically write pix case typed type prop context 
simply device mark distinction logical implication prop level function type constructor predicative levels type type hierarchy 
vein typically write place pi instances rule pi table emphasise distinction logical quantifier dependent type constructor 
sigma types fv write theta sigmax examples derivable judgments way illustration features ecc impredicative definition rule pi strong 
allows usual higher order definitions logical constants connectives intuitionistic logic example def prop precisely fi pix pix see detailed discussion point :10.1.1.38.7596:10.1.1.38.7596
chapter 
type theoretic preliminaries ecc lego axiom ffi prop type gamma gamma prop type fv gamma kind type gamma prop type gamma type type 
var gamma delta prop type gamma delta pi gamma prop gamma pix prop pi gamma type gamma type gamma pix type gamma gamma pix app gamma pix gamma gamma mn sigma gamma type gamma type gamma sigmax type 
pair gamma gamma gamma type gamma pair sigmax sigmax gamma sigmax gamma gamma sigmax gamma gamma gamma type gamma table rules ecc deriving judgments chapter 
type theoretic preliminaries ecc lego oe def prop oe interpretation consistent may show exists term ffi :10.1.1.38.7596
impredicativity allows generalised inductive definitions see example exposition 
simple example may derive context gamma nat nat type nat nat nat gamma nat nat phi nat prop phi nat phi phi sk phi prop represents informal proposition natural number 
define numbers satisfy predicates satisfied closed successor successor impredicativity course lies fact evenness just predicate 
representation gamma nat phi nat prop phi nat phi phi sk phi nat prop phi nat phi phi sk phi proof 
definitions arise way church representation datatypes second order calculus universes cumulativity simple examples universes may derive type type type type type type chapter 
type theoretic preliminaries ecc lego defining polymorphic identity function type universe type trivial cumulativity reflection propositions say terms type prop predicative levels rule 
allows form sigma types second component proposition 
gives strong constructive notion subset type species 
way may account impredicative instances set theoretic comprehension typical mathematics 
sigma types context gamma nat phi nat prop may sigma types form type representing functions preserve gamma nat nat prop sigmaf nat nat nat fn type type may seen specification preserving functions 
essential cumulativity indicated previous section 
case predicate defined representing evenness def nat phi nat prop phi nat phi phi sk phi may derive judgment 
term formally represents knowledge function 
preserves numbers 
may read judgment 
meets specification evens preserving map 
sigma types allows speak function proof correctness idea subsequent chapters thesis revolve 
examples illustrate expressions defining simplest proofs 
shall occasion describe proofs explicitly 
principle virtues lego system proofs may developed refinement proof term computed system 
finished scripts refinement proofs usually perspicuous expressions give rise 
appropriate chapter 
type theoretic preliminaries ecc lego gamma nat pair sigmaf nat nat nat fn proof sigmaf nat nat nat fn nat sn proof nat phi nat prop phi nat phi phi sk phi proof 
preserves numbers shall quote dialogues typechecker indicate particular construction existence claimed text 
proofs implemented lego rely laborious explanation informal mathematics 
proof theoretic properties calculus properties calculus central lego implementation thesis follows church rosser cr underlying conversion relation church rosser strong normalisation sn gamma type occurring gamma strongly normalising subject reduction sr gamma gamma chapter 
type theoretic preliminaries ecc lego strengthening gamma derivable fv gamma derivable cumulativity inductive definition terms decidable principal types gamma exists ordering gamma equality conversion impredicative quantification prop level expressed rule pi table allows define leibniz equality cf 
eq def pip prop px py gamma kind defines equivalence relation follows impredicativity see appendix formal proofs symmetry transitivity 
thesis ibid 
pp luo proved lemma establishes computational adequacy leibniz equality specifications lemma suppose ffi ffi eqa fi proof follows sn cr structure derivations ecc shows normal form proof refleq def prop eqa reflexivity relation eq :10.1.1.38.7596
proof rests crucially fact defined empty context 
fact true prescribe shape match term refleq 
easy induction derivation judgments theory inductive character proves chapter 
type theoretic preliminaries ecc lego show terms typable context gamma interconvertible necessary sufficient gamma refleq prop eq derivable type review lego lego pollack implementation typechecker refinement proof system ecc number related systems earlier ideas huet de bruijn 
syntax lego syntax terms official syntax ecc prop type fv tgt tt correspondence official syntax table 
system accept ill typed terms 
lego provides extensions syntax described due detailed operation system describe details may papers pollack 
particular presence cumulativity sigma types means term may general typed infinitely types 
usually principal type useful occasion need cast term specified legal type denoted device inherent official syntax chapter 
type theoretic preliminaries ecc lego fv tgt corresponds pix sigmav pair sigmax 
table comparison syntax lego ecc pairs pair sigmax subscript provides form casting term 
type casting part goal mechanism 
detailed discussion point see 
theorem prover system distinct levels called lego state proof state 
lego state user may build manipulate contexts type check terms initiate proofs 
type check expression user simply enters followed semicolon 
term typed current context may include local hypotheses definitions course proof system returns value type expression 
typically illustrating mathematical constructions include output indicating success construction seriously howard intention propositions types 
construction proof 
lego implements small command language developing proofs refinement 
fuller explanation account uses lego body thesis brief explanation commands chapter 
type theoretic preliminaries ecc lego goal command goal gamma current context gamma initiates refinement proof type system enters proof state exits subgoals remain 
intros command performs introductions rules pii pair table 
refine command refine term attempts unify current goal type term expanding definitions performing fi reduction needed 
successful produces subgoals types bindings wholly matched fails event match 
strength system lies evaluations performed unification especially presence ffi rules 
absence subgoals proof successful system prints qed 
returns lego state 
save command save term adds new definition context binding result successful refinement name term cast type goal 
commands provide context management essential proof theoretic properties strengthening 
additional features lego system pollack typechecker ecc lego implementation extends official syntax ecc significant ways typical ambiguity syntax extended anonymous universe freeing user having specify universe levels inferred system subject constraints example chapter 
type theoretic preliminaries ecc lego type defines polymorphic identity function levels definitions local global definitions available user 
denoted uniformly acts binder local definitions standing global definition 
universe levels recomputed instance expansion definition ibid allowing form universe polymorphism 
argument synthesis implicit binding operators fx ag allow suppression arguments application terms obtained translation unofficial implicit syntax explicit system algorithm synthesise implicit arguments 
example may define leibniz equality uniformly needing supply type explicitly eq type 
prop 
defined type eq legal expression type inferred passed argument eq 
example polymorphic identity define type self application legal expression 
arbitrary reductions syntax extended provide arbitrary extensions conversion relation fi new ffi reductions elimination constants type level accordance luo view logical types live prop level datatypes type level 
example natural numbers may defined system follows chapter 
type theoretic preliminaries ecc lego nat type zero nat succ nat nat nat type zero nat succ far small context assumptions extend axioms defining behaviour primitive recursor applied constructors zero succ 
axioms describe ffi reductions propositional level leibniz equality eq allow identify types dependent convertible terms 
underlying unification algorithm lego exploit proofs equality resolving goals 
add new reductions corresponding usual ffi rules nat type zero nat ih kc succ nat zero 
succ 
leaves burden context assumptions datatypes type constructors necessary axiomatisation gives utility computation structural recursion 
universe polymorphism type ensures expressive programming language martin lof systems 
motivates study program development ecc 
meta theory extension case iterated inductive definitions martin lof various theories active area research name 
consistency argued preservation strong proof theoretic properties understood 
shall course thesis features extensively simplify syntactic complexity constructions impact chapter 
type theoretic preliminaries ecc lego directly felt clearly relevance considering extension theory deliverables case structuring mathematical theories pp 

shall exploit arbitrary reductions feature describe disjoint sums types unit type natural numbers lists primitive recursion define deliverables 
hope give uniform account datatype definitions 
see 
equality conversion bis 
concerning leibniz equality section powerful practical tool lego 
lemma equality lemma establish terms lego require refinement successful goal eq refine refleq qed refleq type 
prop proof reflexivity leibniz equality 
considerably simplify routine verifying equality various categorical constructs subsequent chapters 
sample derivation give reader feel lego implementation derivation proof 
preserves numbers 
chapter 
type theoretic preliminaries ecc lego firstly context gamma nat assumptions lego 
type system responds decl type decl decl context define predicate evenness lego 
phi 
prop phi phi phi system responds defn phi prop phi phi phi phi prop initiate refinement derivation term relevant sigma type goal 

system responds goal term represents term waiting instantiated proof progresses 
henceforth record response system user sees directly commands lego 
prompt 
outermost constructor term pair sigma chapter 
type theoretic preliminaries ecc lego lego 
intros intros subgoals corresponding components pair 

goal functional type pi 
refine term twice idea construction wish 
lego 
intros refine refine intros refine refine close branch derivation tree local assumption discharge 
indicates discharge local hypothesis derivation tree just natural deduction 
lego 
refine refine discharge 
wenow subgoal instantiated solution 
pi expand definition predicate 
lego 
intros hyp expand intros hyp hyp chapter 
type theoretic preliminaries ecc lego expand phi prop phi phi phi phi see introductions time wildcard character underscore standard ml 
lego 
intros intros phi prop phi phi phi phi stage local context visible wemay prf command display local context current subgoals 
lego 
prf hyp phi prop phi phi phi phi fact stage proof choice open hypothesis phi phi unifies current subgoal 
lego 
refine refine phi choice hypothesis hyp chapter 
type theoretic preliminaries ecc lego lego 
refine hyp refine hyp phi phi phi wemay immed tactic resolve outstanding subgoals local context 
lego 
immed immediate discharge 
phi discharge 
hyp qed alternative point give explicit refinement terms lego 
refine refine refine phi phi refine discharge 
phi discharge 
hyp qed case derivation complete may save proof term 
lego 
save saved may examine term simply entering name 
see explicit type casting lego representation terms sigma type 
lego 
value hyp phi prop phi phi phi hyp phi chapter 
type theoretic preliminaries ecc lego type may construct explicit terms proof definition 
lego 
defn lego 
proof defn proof proof lastly may commands hnf vreg normal vreg display values head normal form respectively normal form lego 
value type lego 
hnf vreg lego 
normal vreg lego 
proof value type lego 
hnf vreg hyp phi prop phi phi phi hyp phi lego 
normal vreg likewise commands hnf normal display types form respectively normal form 
chapter 
type theoretic preliminaries ecc lego hyp phi prop phi phi phi phi phi prop phi phi phi hyp phi concludes example 
chapter order second order deliverables chapter consider basic syntactic definitions study approach program correctness 
indicated wish give account correct programs respect specification way clear distinction computational logical behaviour 
leads definition deliverable 
surely desirable feature design methodology compositional able describe development large programs terms suitably smaller sub programs better done syntax directed way 
putative programming language simple type theory primitive recursion inductive types deliverable constructors reflect structure 
point draw experience category theory semantics formal systems particular calculus higher order logic example 
formalise interpretation typed calculus inside ecc considered logical framework cf 
develop combinators appropriate categorical constructions 
involve technicalities notably idea semi cartesian closed category due hayashi 
able realise aim compositional system correct program development 
chapter 
order second order deliverables definition properties order deliverables relative formed context gamma ecc 
specifications informally consider approximation idea specification pair consisting ffl type ffl predicate defined type 
motivation types carry computational information predicates carry computationally irrelevant propositional information specification 
idea new lies heart called theory subsets martin lof type theory division type information informative non informative propositions underlies studies program extraction type theory 
course zero th approximation types specifications 
martin type theory programming language reading types 
reader mind account subset theory martin type theory chapter system multiple judgments opposed sigma types ecc conveys similar idea 
chapter 
order second order deliverables definition specification pair terms gamma type gamma sx prop typically write specifications understand respectively referring underlying type resp 
predicate 
formally type specifications spec def sigmas type prop may consider operations construct specifications entirely framework ecc cf 
account specifications refinements 
consider category objects specifications morphisms defined 
specifications defined logically equivalent predicates general define distinct objects 
order deliverables having choice objects appropriate choice morphism order define category 
intuition definition specification morphisms reflect concern separating computational propositional information 
indicated appropriate notion morphism consists pair function underlying types proof respects predicates 
formally definition burstall order deliverable specifications order deliverable term gamma sigmaf gamma 
sx fx reader hopefully somewhat unfortunate notation chosen consistent specifications 
chapter 
order second order deliverables motivation definition goes right back hoare original axiomatic semantics logic triples bears name expresses formal system informal notion program certificate specified input output behaviour 
course concerned functional language imperative confusion program variables logical variables 
framework proof program linked pair 
definition uses sigma types essential way capture idea 
may features ecc construct pairs intuitions computational vs propositional information insist trivial extraction process projection sigma type yields underlying algorithm accounts name deliverables software house deliver customers program plus proof box specification printed cover sigma type 
customer independently check proof run program need complicated extraction process may yield unusual algorithm 
propose method style developing programs place 
usually reasonable idea algorithm advance opposed proof termination correctness understanding reflects intuitions build deliverables smaller ones example refinement composition possibly machine assistance 
example hinted chapter construction simple example order deliverable case nat nat 
reader unfamiliar machine checked proofs may complicated formal machinery required establish simple result 
may take comfort fact complexity localised propositional reasoning 
algorithm remains recognisable resulting pair 
complex examples normalise projection deliverable recover chapter 
order second order deliverables algorithm 
categorical combinators develop give schematic description algorithm deliverable 
terms lego constructions define type order deliverables ecc lego 
del value type pred pred type type pred pred prop lego 
del value type pred pred del type type pred pred type exploited implicit syntax enable suppress argument types predicate del type del 
eye categorical aspects definition typically write del del gamma gamma 
gamma del may inferred typechecker general interested save know exists may abuse notation write del accordance lego implicit syntax coupled certain laxity proof terms accounts choice notation types may inferred relegate notationally lower case 
reader careful distinguish category arrow type constructor arrow gamma 
chapter 
order second order deliverables course stage need sigma types definitions 
mathematical pair sigma type allows represent operations produce function proof pairs calculus 
gives possibility developing structure gadgets 
equality deliverables mathematicians computer scientists typically think informally operations extensional 
type theory wemust general preserve proof theoretic properties implementations depend 
example martin lof switch extensional equality type theory leads undecidable type checking problem 
previous subsequent versions theory intensional equality type 
argued extensional systems example grounds utility take view 
problem adding conversion systems ecc active area research limited case conversion typed terms appears permissible 
adding sigma types type theory raises problem surjective pairing systems ecc known church rosser property reduction fails pp 

concern delicate questions definitions encourage identifications terms interest 
fact shall scarcely need technicalities number points verifying del category category certain structure 
definition equality specifications specifications say fi ffi fi ffi chapter 
order second order deliverables definition hardly impact development subsequent material included partly underline concern extensionality intensional systems ecc support definition equality morphisms define category 
definition order deliverable mentions predicate part specification application proposed structure del detect differences expansions definition underlying conversion relation fi ffi decidable able typechecker test equality 
natural definition equality logical equivalence general decidable 
spirit constructive mathematics non trivial logical equivalence specifications regarded having algorithmic content explicit 
example consider definitions means permutation word alphabet enumerative words am say ng ng ng impredicative higher order definition permutation congruence words express ecc follows def prop congr uv congr expresses relation equivalence relation congruence operations proof equivalence definitions involves construction hand specific permutations initial segments ng chapter 
order second order deliverables natural numbers essentially derivation trees proofs propositions appendix contains detailed treatment impredicative definition lego 
developed course investigating proofs sorting algorithms 
definition equality deliverables del say fx fi ffi gx fi ffi terms lego define polymorphic function call order deliverables order deliverables mapping fx lego 
value type pred pred ff del ff ff type type pred pred del del definition equality deliverables amounts convertibility minimal extension basic conversion relation ensures categorical properties 
position exploit lemma enable determine equality deliverables lego 
chapter 
order second order deliverables semi structure categories cartesian closed categories give models simply typed calculus familiar computer science example various equational presentations structure cartesian closed category 
basic type term constructors defined adjunctions 
analysis unit counit adjunction defining arrow type correspond loosely fi conversion respectively similarly product type constructor 
earlier account ideas thesis attempted give account cartesian closed structure del abandoned clumsy definitions required favour hopefully smoother treatment 
discussed absence conversion surjective pairing ecc forces extra technical difficulty 
models various typed calculi conversion surjective pairing rigorous semantic account terms semi adjunctions introduced hayashi essentially equations defining adjunction relaxed sufficiently suitable conditions notion counit corresponds appropriately fi conversion unit corresponding conversion 
follow hayashi treatment closely recall main definitions 
definition semi functor categories semi functor functor need preserve identities say assignment objects objects assignment called arrows arrows implies fa ff fb am grateful bart jacobs introducing concept 
chapter 
order second order deliverables fa ff fb fc semi adjunction replace usual natural bijection pair maps need mutual inverses 
require behave naturally 
definition semi adjunction categories oe semi adjunction families oe maps indexed objects diagram fc oe oe gd ff gg fc oe oe gd commutes 
say resp left resp 
right semi adjoint resp 
beauty definition lies lemma 
lemma hayashi suppose fact functors 
oe define families inverse isomorphisms giving adjunction chapter 
order second order deliverables concept subsumes ordinary understanding adjunctions constructions universal gadgets defined adjunctions particular category semi terminal object right semi adjoint functor semi products right semi adjoint theta diagonal functor delta theta semi exponentials right semi adjoint semi functor theta structure say semi cartesian closed category 
hayashi development leads main results generalising previous accounts models calculus fi conversion 
proposition semi cccs sound complete interpretations fi calculus 
proposition semi cccs algebraically 
category operations theta ev satisfying equations vi may structure semi ccc 
theta operations semi functorial sense theta hf hg theta ii theta theta contrast adjunctions structure defined semi adjunction general unique 
chapter 
order second order deliverables iii theta theta theta iv theta ev theta 
thetay ev thetay object vi theta ev theta theta ev rest section dedicated proof theorem theorem del semi cartesian closed 
note structure semi ccc instrumental deliverables means developing proven programs 
results reflect understanding may construct skeleton proof program phrase alongside development phrase 
categorical structure reflects syntactic constructions terms enforce correctness programs 
identities composition considering slight modification underlying conversion terms ecc remedy failure surjective pairing conversion chapter 
order second order deliverables calculus fixed notion equality arrows 
definition trivial establish specifications order deliverables morphisms form category denoted del identities simply sx del lego lego 
value type pred type type pred composition fx sx fx lego lego 
composedel value type pred pred pred ff del gg del ff ff gg gg del type type pred pred pred del del del obtain immediate appeal typechecker definitions yield structure category del proof need modified equality prove identity laws 
conversion relation sufficient establish associativity composition 
chapter 
order second order deliverables lego 
value type pred pred del refleq composedel type type pred pred del eq composedel lego 
value type pred pred del refleq composedel type type pred pred del eq composedel lego 
value type pred pred pred pred del del del refleq composedel composedel type type pred pred pred pred del del del eq composedel composedel composedel composedel 
xi example imagine simple order deliverables underlying algorithm 
respectively transform numbers odds odds evens 
composition gives representation normal form simple example 

semi terminal object unit def unit unit spec defines trivial specification unit type defined lego unique term type unit 
chapter 
order second order deliverables unit type void unit unit unit type void 
unit type void void 
pollack notation inductive types 
obtain spec deliverable def refleq del unit satisfies hayashi condition 
proof lego 
unit value unit eq void type pred unit lego 
value type pred void refleq void unit del unit type type pred unit lego 
hayashi value type pred pred del refleq type type pred pred kk del eq composedel kk 
xi chapter 
order second order deliverables binary semi products obtain semi products non dependent sigma type underlying type conjunction predicate level theta def theta theta lego lego 
productdel value type pred pred xy xy xy type type pred pred prop lego 
value type type type lego 
value type pred pred pred ff del gg del ff ff gg gg pair type type pred pred pred del del del productdel 
lego 
pi del value type pred pred yz yz productdel fst del productdel type type pred pred udel productdel lego 
pi del value type pred pred yz yz productdel snd del productdel type type pred pred udel productdel semi product structure follows hardly surprising curry howard correspondence 
chapter 
order second order deliverables lego 
hayashi value type pred pred pred pred gg del hh del kk del refleq composedel kk gg hh type type pred pred pred pred gg del hh del kk del eq composedel kk gg hh composedel kk gg composedel kk hh lego 
hayashi value type pred pred pred gg del hh del refleq composedel gg hh pi del type type pred pred pred gg del hh del eq composedel gg hh pi del gg lego 
hayashi ii value type pred pred pred gg del hh del refleq composedel gg hh pi del type type pred pred pred gg del hh del eq composedel gg hh pi del hh binary semi coproducts fact additional structure semi coproduct obvious algebraic definition give datatypes mechanism 
completeness record lego definitions 
omit proofs marginally greater difficulty semi product save recursion combinator proof case construct respects disjunction predicates 
logically construction def inl sx inr ty chapter 
order second order deliverables defined constructs embedded higher order logic assume existence sum types constructors inl inr tau type tau tau tau type type type ac bc bc type type ac bc 

case type type pred pred ex eq ex eq definition wrote tau type tau tau tau type sum type constructor 
device due goguen expansion ambiguous expression type type type allows define sum type type levels pollack typical ambiguity translation way gamma type gamma type gamma type datatype definitions follow verbatim martin type theory 
account see 
chapter 
order second order deliverables lego 
value type pred pred type pred ff del gg del ff ff gg gg case case 
type type pred pred type pred del del del semi exponentials notion order deliverable predicate del terms arrow type 
precisely predicate defines specification yields semi exponential object del abstraction evaluation follow operations underlying type theory 
lego 
value type pred pred pred ff del productdel ff ff pair del del type type pred pred pred del productdel del del lego 
value type pred pred hyp productdel del fst hyp snd hyp type type pred pred del productdel del lego 
hayashi value type pred pred pred pred ff del productdel gg del hh del chapter 
order second order deliverables refleq type type pred pred pred pred ff del productdel gg del hh del eq composedel composedel gg ff hh composedel gg hh ff lego 
hayashi value type pred pred pred pred ff del productdel gg del refleq composedel gg ff type type pred pred pred pred ff del productdel gg del eq composedel gg ff composedel composedel pi del gg pi del ff semi pullbacks internalisation equality tempting sight imagine del structure outlined evident nave set theoretic character foregoing particular existence finite semi limits semi colimits 
appears case 
equality arrows defined underlying conversion relation calculus slightly modified construction pullbacks require notion known possible representing convertibility relation proposition lead absurdity presence non empty context example containing assumption terms interconvertible 
possible define object ought define chapter 
order second order deliverables vertex pullback square del viz 
theta theta eq cone form projection maps essentially show mediating arrow pz qz conj zh refleq pz qz commuting square semi functorial 
pass arbitrary proof eq knowledge fi ffi 
say proposed limit cone cone 
similar remarks apply attempt characterise monomorphisms epimorphisms idempotents del suggests notions equality arrows smoother definition apart eq leibniz equality defined chapter 
conj term proofs propositions oe returns proof conjunction oe 
chapter 
order second order deliverables remarks extension idea deliverables considering types partial equivalence relations section pursued problem 
factorisation system del function say term arrow type gives rise deliverable manner assignment rule hoare logic dijkstra predicate transformer assignment 
gamma 
gamma 
prop obtain del def fx call deliverables trivial come vacuous proofs correctness 
algorithmic side may distinguish deliverables embody trivial algorithm identity 
correspond propositional reasoning 
suitable sense del lies extremes 
order deliverable trivial deliverable followed propositional reasoning 
proof obvious 
id id xi chapter 
order second order deliverables consequence rule logical implication induces pointwise ordering ae predicates consequence rule manner hoare logic ae ae general need view incorporates propositional reasoning general framework deliverables 
pointwise construction basic combinator theory deliverables constructs function proof pair function returns value proof pairs mendler thesis calls gadgets pointwise designs argument value pointwise existence value type satisfying property tv yields deliverable codomain 
detail pix sx ty def fx def sx fx inductively defined types provided accept weak definition inductive type relatively straightforward add inductive types categorical structure developed far 
just corresponds howard observation emphasised martin strong interpretation existential quantifier sigma type axiom choice constructively valid 
chapter 
order second order deliverables categorical accounts inductive types initial algebras impose extra equalities iterator due uniqueness clause definition initial algebra 
semi structures existence uniqueness relevant universal arrows 
basic idea simple add inductive types type level strong elimination rule yielding simply typed recursor type level usual induction principle prop level 
type paired identically true predicate 
elimination rule order deliverables easily derived packaging primitive recursion type level induction predicate level 
illustrate general idea considering case natural numbers lists 
natural numbers assume martin lof type theory existence type natural numbers constructors zero successor 
yields wellformed context nat type nat nat gamma 
nat typically abbreviate informal mathematical language 
extend context dependent elimination constant pic nat gamma 
type piz pis pik nat ck pin nat cn strong eliminate types merely propositions 
dependent 
chapter 
order second order deliverables reduction rules defining ffi redices context appropriate types ffl ffl precisely expressed lego follows nat type zero nat succ nat 
nat nat type zero nat ih kc succ nat nat type zero nat ih kc succ zero 
succ 

yields derived iterator primitive recursor natiter piff type ff gamma 
ff gamma 
ff gamma 
ff natrec piff type ff gamma 
nat gamma 
ff gamma 
ff gamma 
ff natiter def cf 
martin type theory odel earlier system functionals 
essentially language primitive recursion finite types programming language 
cf 
discussion chapter adding arbitrary reductions lego 
type ff course inferred typechecker 
chapter 
order second order deliverables natiter def natiter natrec def natrec def natrec induction principle pi phi nat gamma 
type piz phi pis pik nat phi phi pin nat methodology suggests examine derived induction principles iterator recursor interested programs case form natiter natrec proven propositions 
iterator obtain phi ff phi phi nat phi natiter ff ff gamma 
ff recursor phi nat ff phi phi nat phi natrec ff nat gamma 
ff gamma 
ff interested building new deliverables complex ones course dependent eliminator construct terms type del doing violate separation proofs programs distinguishes approach 
package recursion type level induction prop level pair 
introduce predicate nat def nat true natural numbers 
constructor type obtain corresponding deliverable zero def unit unit unit unit nat succ def nat nat nat nat nat chapter 
order second order deliverables iterator obtain unit natiter nat nat recursor unit nat natrec nat nat function component natiter respectively natrec natiter respectively natrec proof component obtained appropriate derived induction principle 
terms easily obtained refinement lego lego 
value type pred zz del unit ss del zz void zz ss ss natiter nat nat natiter 
type type pred del unit del del nat lego 
value type pred zz del unit ss del nat del zz void zz ss ss natrec nat nat natrec 
type type pred del unit del nat del del nat example example combinators correctness proof doubling function double def nat natiter nat suppose wish show double natural numbers posed terms deliverables seek term type del nat function component double 
chapter 
order second order deliverables rule natiter problem reduces finding base case unit nat 
take def unit proof chapter step case nat nat 
simply order deliverable constructed sample derivation chapter 
obtain non trivial recursive order deliverable lists way may define combinators deliverables type lists 
extend context type constructor case list type gamma 
type may express lego goguen trick section list tau type tau tau type constructors usual nil cons dependent eliminator derive iterator primitive recursor listrec induction combinator comes considering derived induction principles iterator recursor wenow freedom specify recursions lists elements satisfying predicate lists parameter type specification obtain derived specification list def list listof listof nil def true listof cons def ax listof example originally due burstall 
chapter 
order second order deliverables defines listof primitive recursion 
may proceed way obtaining constructors nil def unit nil unit unit unit listof cons listof listof function component list cons proof component list listof pair likewise package recursion appropriate derived induction principle obtain rules constructing deliverables iterator unit list listof recursor unit list listof listrec list listof lego lego 
value type pred pred nn del unit cc del del nn void nn cc cc chapter 
order second order deliverables list listof 
type type pred pred del unit del del del listof lego 
value type pred pred nn del unit cc del del listof del nn void nn cc cc listrec list listof listrec 
type type pred pred del unit del del listof del del listof chapter 
order second order deliverables second order deliverables system described amounts functional version known invariants proofs imperative programs 
unfortunately specification connection input output function 
say input satisfies property output satisfies property relation 
example specify sorting function takes lists ordered lists specify output permutation input 
function produce empty list sorted interesting 
matter fact classical invariant proofs weakness masked tacit assumption variable carried computation change value 
enforce constraint output bear relation input need develop compositional theory relations basic objects study notion arrow respects relations predicates 
thought experiment suppose pi specification wish find function gamma 
satisfies 
sense may refine specifications composition 
suppose wish instantiate composition functions intermediate type 
intuition case predicates anticipate intermediate specification solves chapter 
order second order deliverables solves logically equivalent left intended solution intermediate value introduced asymmetry roles remedy underlies definitions separate roles independent parameter dependent variables consider relations objects study fixed type allowing types vary 
provides appropriate notion morphism re establishes symmetry corresponding instantiations definition arrow consists data ffl function gamma 
gamma 
say function arguments recovers missing dependence observed ffl proof composition gadgets definable hx xw xw employ informal alphabetical convention type type type type chapter 
order second order deliverables established definition respects symmetry source target previous analysis decomposition pi specification 
doing generalised notion specification old specification corresponds new setting choosing def unit def true old def new 
complement discussion remarking incorporation value remains constant computation reminiscent ghost variables classical invariant proofs overcome limitation hoare logic providing connection initial final values program variables ghost variables recorded initial state remained unchanged program 
advantage programs allowed mention scope delimited universal quantifier proof basic definitions view discussion specifications order deliverables depend input type observing may uniformly impose condition input parameter affecting notion composition arrive burstall definition second order deliverable 
definition relativised specification suppose gamma type gamma gamma 
prop 
relativised specification respect pair terms guiding intuition burstall private communication 
chapter 
order second order deliverables ffl gamma type ffl gamma gamma 
gamma 
prop 
definition burstall second order deliverable suppose gamma type gamma gamma 
prop 
relativised specifications second order deliverable term gamma sigmaf gamma 
gamma 
fxy define del qr predicate gamma 
gamma 
sx fxy definition embodies idea sx holds fx fx order deliverable qx rx def 
may precise constructions 
proposition family construction suppose ffl gamma type ffl gamma gamma 
prop ffl relativised specifications respect 
ffl gamma gamma 
ffl gamma sx del qx rx sx defines second order deliverable 
chapter 
order second order deliverables proposition order deliverables second order deliverable arises way 
proof constructions lego obtain lego 
value type pred rel rel family fx del fx family family type type pred rel rel fx del fx del lego 
del value type pred rel rel ff del ff ff fx del fx type type pred rel rel del fx del fx 
xi suggest study second order deliverables amounts study order deliverables extended context 
particular expect obtain specification def category structure second order deliverables similar definition equality second order deliverables section details left reader 
define identities composition 
composition definition thought experiment 
call category del lemma identities composition del lego terms lego 
chapter 
order second order deliverables value type pred rel type type pred rel lego 
composedel value type pred rel rel rel ff del gg del ff ff gg gg del type type pred rel rel rel del del del proof immediate constructions 
proofs identity composition laws similarly trivial 
details see appendix xi second order deliverable typically write usual types may inferred typechecker 
notation intended indicate considering deliverables relative assumption defined specification 
notation deliberately intended echo style contexts martin lof type theory 
shall return idea greater detail chapter 
del semi ccc section relative context gamma 
seen second order deliverable context gamma may viewed arising order deliverable extended context gamma sx 
conditions definitions intended enforce hierarchy dependencies extended context 
type depend relation considered predicate context gamma depend chapter 
order second order deliverables function component may depend proof component may 
conditions may lift structure del observing various constructions section respect hierarchy dependencies 
predicates concerned need modified include explicit hypothesis sx 
arrive result 
theorem specification del structure semi ccc 
proof merely sketch constructions basis informal intuition 
full details left appendix semi terminal object relativised specification def unit unit true map 
relativised specification function component proof component sx xw semi products relativised specifications 
may form relativised specification theta def theta theta qx rx term corresponding true def oe prop oe type true def prop oe oe 
lego lego 
top value prop type fa chapter 
order second order deliverables defines semi product object del 
pairing map 
theta ffl def pair thetau xw xw ffl def sx xw pair projections similarly straightforward define theta function component yz theta yz proof component sx yz theta yz qx yz fst pair term corresponding pair def oe prop oe prop oe type prop oe oe 
lego lego 
pair value prop prop type fa terms arguments pair accordance lego implicit syntax 
fst term corresponding elimination fst def oe prop oe oe oe type prop oe oe 
lego lego 
fst chapter 
order second order deliverables omit proof algebraic define structure sense proposition 
semi exponentials just predicate del defined semi exponential object category del wemay define semi exponential object del relativised specification del gives rise 
precisely suppose relativised specifications 
obtain relativised specification def gamma 
gamma 
fy gamma gamma 
gamma 
gamma del qr gamma fx fx 
theta obtain currying obvious way def def def def sx xw qx xh pair may similarly define evaluation map details left imaginative reader develop construction value prop type fa arguments fst accordance lego implicit syntax 
chapter 
order second order deliverables refinement lego 
likewise proofs data meet hayashi conditions semi exponential best dealt refinement 
see appendix xi del indexed category del categorically minded reader asks relationships exist various categories sjs spec extent may elaborate structure collection 
particular may ask relationship del del order deliverable moment pause convince composition del induce operation second order deliverables order deliverables defined extended context 
words theorem theorem del indexed category del fibres semi cccs semi cc structure strictly preserved reindexing arrows del pullback functors theorem depends existence pullback functors translate data categories del obvious definition works trivially respects equality objects arrows pullback functors functors merely identities composition preserved 
straightforward tedious task verify operations compose strictly preserve structure fibre 
chapter 
order second order deliverables definition pullback order deliverable specifications anda order deliverable define operation pullback abuse notation standard way employing symbol operation objects arrows follows relativised specification def respect def kx relativised specification def second order deliverable define pair sx xh lemma relativised specification respect second order deliverable proof property requires checking readily seen case example appeal typechecker lego 
value type pred pred rel rel kk del kk kk ff del ff ff compose pre type type pred pred rel rel kk del kk del 
del xi lemma preserves identities composition 
chapter 
order second order deliverables proof equality lemma lego 
goal eq kk kk lego 
refine refleq qed case composition proved exactly way 
xi existence functors fibres del satisfactory notion reindexing requires show obey condition fact true 
lemma reindexing strict sense proof inspection definition composition order deliverables 
xi turn remainder theorem pullback functors preserve structure semi ccc fibre 
find structure preserved strictly 
examine case exponentials cases products terminal object exactly similar easier 
lemma notation theorem proof straightforward typechecking 
xi proposition suppose relativised specifications respect theta 
chapter 
order second order deliverables proof equality lemma 
difficulty lies having coerce terms type viz 
del theta straightforward 
xi categorical structure defined semi adjunctions general unique may ask structures semi ccc may put del hayashi define notion functor semi cccs preserves structure 
theorem fortunate requiring develop concept greater generality strict preservation observed 
turns choice product exponential object incorporate extra hypothesis form sx obtain semi ccc structure 
pullback functors preserve structure nose 
preserve structure lax sense laxity arising obvious ordering predicates relations 
exact sense laxity difficult precise 
extended consider refinement specifications example power categorical analysis data refinement expect appropriate lax notions important 
del del indexed sums products consequence theorem hope light give semantics martin lof type theory terms deliverables 
particular expect interpret dependent products sums specifications 
part development subset theory 
structure defined semi adjunctions adjunctions seely account extensional theory defer discussing idea corollary may language dependent types describe chapter 
order second order deliverables manipulate deliverables chapter 
particular avoid discussing technical difficulty definition structure dependent products arises absence surjective pairing 
give structure dependent pi define right semi adjoints weakening functors fibres 
order able restrict absence surjective pairing relations defined sigma types fi ffi second order deliverables natural numbers lists context second order deliverables situation regarding inductive types understood 
regard section giving definitive account examples chapter suggest usable set combinators reasoning recursive programs 
take guiding motivation derived induction principles section 
relativised case subtly altered presence induction variable 
means case natural numbers examine proofs statements form nat natrec type nat gamma 
gamma 
proof induction yields nat consider natrec natiter degenerate instance 
chapter 
order second order deliverables requisite hypotheses base step cases 
recognise second hypothesis logical component second order deliverable function component question arises view hypothesis regard part second order deliverable 
sense choice current version deliverables 
examine derived rule induction time rephrased nat nat natrec isolates currently view recursions second order level 
see function recursively applies arbitrary initial value function component second order deliverable proof component proof induction nat natrec observed hypothesis step case induction arises proof component second order deliverable nat written relation nat manner write relation nat obtain second order deliverable constructor nat recursions derived rule nat natrec nat chapter 
order second order deliverables natrec function component nat natrec principle reason making choice representation pragmatic partly experience behaviour unification typechecker 
mimic construction order deliverables induction expect rule hypothesis constructor datatype example nat nat natrec typically apply rule top proof subgoal form del top development may construct deliverables constructions described instantiation general possible allow subsequent development allow unification constrain application valid 
choice rule natrec achieve 
regard choice necessarily definitive merely represents view 
lists wemay extend analysis case lists case order deliverables find richer structure lists reflected richer collection predicates relations 
chapter 
order second order deliverables firstly fibre del list obtain exactly way derived rule pix cons list listrec nil list cons def list cons nil def list nil lego term obtain lego 
value type rel list family univpred list family family list listrec list true nr list listrec 
type type rel list univpred list 
del univpred list lego 
value type rel list list nil type type rel list rel list lego 
value type rel list list cons type types rel list rel list find list listrec function component suitable induction lists chapter 
order second order deliverables list listrec proof component 
rule find new outermost pi binding 
say rule premise dependent family second order deliverables 
phenomenon arises parameter type lists question 
rule susceptible criticisms rule natrec criticism accorded different status parameter type 
particular constrained predicate awe impose justification essentially pragmatic 
rule useful construction example minimum finding chapter 
say obtain forms rule input list constrained 
may example consider predicate listof predicate fact considering second order deliverables take account relations depend input variable result computation step may extend predicate dependent version call defined follows phi nil def true phi cons def phi phi phi relation values variable varying parameter type lists example predicate sorted take phi def relation element list discussed detail examples chapter 
introduces extra hypothesis induction scheme consider 
suppose wish prove list phi listrec chapter 
order second order deliverables gamma 
gamma 
proof induction generates hypotheses constructor 
base case true nil reduces logically nil rules natrec shall fold assumption rule initial relation second order deliverable eventually derive 
step case formally obtain list phi listrec phi listrec simplifications 
replace explicit mention listrec additional universally quantified parameter second observe phi cons phi combining obtain induction hypothesis step case list phi form see logical part second order deliverable emerge 
obtain derived rule yields second order deliverable function component listrec dependent family second order deliverables pix cons cons phi nil phi shall see examples chapter 
lego represented term lego 
value type phi rel list rel list adel phi list listrec list chapter 
order second order deliverables list phi nil list phi 
listrec list 
type type phi rel list rel list adel phi 
del phi chapter examples illustrate discussion previous chapter turn examples deliverables small scale program development 
deliverables may heavy handed counter productive smaller examples considered hope final example proof chinese remainder theorem methodology 
choice examples extent dictated literature way comparison approaches formal program development 
examples consider second order deliverables 
chapter contains worked example doubling function viewed recursive order deliverable natural numbers 
studied examples order deliverables significantly complicated 
natural examples arise specify relationship input output 
furthermore case deliverables programming methodology hinges strengths weaknesses second order deliverables 
chapter 
examples division thorough illustration propositions types paradigm authors give careful account division 
observe constructive content theorem give mathematical proof induction show gives rise algorithm requires certain amount rephrasing properly considered function emphasis choice algorithm determines correctness proof vice versa different development 
mathematical specification consider original specification started slightly weaker intended algorithm meets stronger specification isolating witness certainly implies original disjunction pair inequalities iff chapter 
examples second specification instantiated function returning pairs natural numbers composed projection obtain function meeting specification 
interesting note example artificially small attempt derive algorithm division weak specification deliverables led additional condition complete development give 
correctness proof intended algorithm consider prototype algorithm standard ml fun fst fun natiter natiter val div aux natiter fn 
val fun div fst div aux induction function div aux lego term natiter zero zero nat nat succ easily shown meet second specification base case immediate 
step case suppose induction show 
follows trivially 
chapter 
examples arithmetic lemmas inconsequential nature identified localised proof algorithm 
development terms deliverables example straightforward give dialogue lego 
introduce specification seek function satisfies 
div spec def theta seek unit true div div spec true gives subgoal div spec lego 
div spec nat nat nat eq plus succ defn div spec nat nat nat eq plus succ div spec nat nat nat prop lego 
goal del univpred nat nat unit div spec goal del univpred nat nat unit div spec decompose subgoal div spec chapter 
examples subgoal general match natural number recursor process matching subgoals completely instantiated 
left subgoals div spec div spec div spec lego 
refine composedel refine composedel type rel nat del univpred nat nat unit del univpred nat div spec lego 
refine refine del univpred nat nat unit div spec del nat div spec div spec concentrate base case 
pointwise construction instantiate base case value subgoals 
fact may exploit unification instantiation course working propositional reasoning subgoals 
obvious facts 
subgoal 
lego 
refine refine nat unit nat nat univpred nat nat unit 
div spec del nat div spec div spec lego 
intros intros nat chapter 
examples unit nat nat univpred nat nat unit 
div spec lego 
intros refine pair intros univpred nat pre nat unit div spec refine pair eq zero plus succ refine refleq plus zero zero zero zero zero succ zero refine zero succ zero refine discharge 
pre discharge 
branch tree closed 
return step case subgoal 
pointwise construction 
involved logical reasoning subgoals 
specified pointwise value solves subgoal case del nat div spec div spec lego 
refine refine chapter 
examples nat nat nat nat nat 
nat div spec div spec intros nat nat nat nat nat nat div spec div spec defn nat defn nat lego 
refine succ refine succ nat div spec div spec succ lego 
intros ih refine pair intros ih nat ih div spec div spec succ refine pair eq succ plus succ succ succ succ point easily proven lemma div lemma proves part induction hypothesis ih proves lego 
refine div lemma refine ih refine div lemma eq plus succ succ succ refine ih succ succ succ chapter 
examples recover induction hypothesis 
lego 
refine ih refine ih succ succ lastly close proof trivial lemma div lemma proves 
remaining part induction hypothesis prove need 
lego 
refine div lemma refine ih refine div lemma refine ih discharge 
ih discharge 
qed finished proof 
save result print 
complete term unwieldy readable discern certain amount structure pretty printed version 
lego 
save div del div del saved lego 
div del value composedel nat unit zero zero univpred nat nat unit pair refleq plus zero zero nat nat nat succ chapter 
examples nat ih div spec pair div lemma ih ih div lemma ih type del univpred nat nat unit div spec wemay extract algorithm div aux projection normalisation 
normalisation compute div aux 
lego 
nat div del void value nat div del void type nat nat nat lego 
normal vreg save nat nat nat nat zero zero nat nat nat succ lego 
div aux normal vreg value div aux type nat nat succ succ succ succ zero succ succ succ succ zero lego 
div aux normal vreg value div aux type nat nat succ succ succ zero succ succ succ succ zero finding minimum list wenow turn treated times literature minimum finding list 
non trivial semi cartesian closed structure fibres del chapter 
examples mathematical specification suppose decidable total order type purposes example contains maximal element avoids having consider exceptions case nil list 
distinguish boolean valued function relation tt denoted may specify minimum list follows lista nil abbreviate second conjunct may easily express solution specification follows fun min fun nil fn 
fn 
min fun nil explicitly curried function definition fun nil min type system ecc strict allow definition pattern matching 
definition recursion argument corresponding proof induction seek verify meets specification lista fa fa sannella fact treats maximum list 
chapter 
examples proof follows composition suitably relativised deliverable application 
correctness proof intended algorithm just consider verification 
indicated proof induction 
base case fa nil fa nil condition fa nil forces choose def reflexive second conjunct satisfied 
step case suppose fa fa def min obtain cases ffl true min hypothesis transitivity ffl false min fb hypothesis fb hypothesis fb fb done 
development terms deliverables give partial dialogue proof checker quote significant subgoals 
chapter 
examples arbitrary type equipped boolean valued linear ordering lego 
type lego 
bool lego 
eq tt lego 
refl lego 
trans lego 
eq lego 
aor minspec def lista gamma 
fa fa seek arrow lista unit true minspec lista true lego 
min lego 
inlist listrec false list prop eq lego 
minspec list aand inlist cons lelist cons lego 
goal del univpred list list unit minspec yielding del univpred list list unit minspec composition enable exploit recursion combinator second order deliverables lists section package proof induction 
chapter 
examples refine composedel refine yielding del univpred list list unit minspec adel univpred list minspec minspec subgoal base case induction 
resolve pointwise construction 
propositional reasoning relatively straightforward case unification strong resolve value goal 
fact assist unifier explicit refinement refine refleq 
sufficient allow completely close branch derivation 
lego 
refine list unit 
univpred list list unit 
minspec lego 
intros intros univpred list pre list unit inlist cons nil lelist cons nil lego 
refine pair gives conjuncts inlist cons nil lelist cons nil resolve chapter 
examples lego 
refine inl refine refleq lelist cons nil lego 
refine pair refine refine top discharge 
pre discharge 
adel univpred list minspec minspec step case 
extend context free variable type continue pointwise construction 
case give function explicitly 
left logical goal 
lego 
intros refine list 
univpred list 
minspec 
minspec lego 
intros refine min univpred list 
minspec 
minspec min mathematical proof split subgoal cases splitting hypothesis spec minspec obtain conjunct 
case name inlist lelist respectively 
lego 
intros spec refine spec lego 
intros inlist lelist lego 
refine eq tt 
inlist min cons cons lelist min cons cons eq ff 
inlist min cons cons lelist min cons cons chapter 
examples give code cases mirrors informal argument suppress intermediate output 
lego 
intros case lego 
refine case bb bool ga bb inlist ga cons cons lelist ga cons cons lego 
refine pair refine inl refine refleq lego 
refine pair refine lego 
equiv lelist cons lego 
refine refine immed immediate discharge 
case second case requires explicit lemma 
eq ff transfers boolean value ff proposition linearity ordering lego 
intros case lego 
refine case bb bool ga bb inlist ga cons cons lelist ga cons cons lego 
refine pair refine inr immed lego 
refine pair refine immed immediate discharge 
case discharge 
lelist inlist discharge 
spec discharge 
discharge 
qed save term 
curious reader may look appendix printed full 
extract algorithm projection normalise result 
chapter 
examples lego 
save lego 
list void normal vreg list list list bool insert sort chose insert sort expressible naturally primitive recursion opposed efficient algorithms hoare quicksort natural expression terms general recursion 
mathematical specification informally straightforward 
list type ff carries decidable linear ordering exists sorted list permutation formal treatment give explicit representations notions permutation 
impredicative definition permutation relation written mentioned section 
predicate sorted defined recursion sorted nil sorted sorted ff list ff nil ff ff list ff chapter 
examples observed section dependent list recursion sorted may seen instance constructor predicate list ff ff just instance listof 
obtain immediately induction number trivial useful lemmas 
passing proved useful example minimum finding able benefit reuse lemmas 
lemma ff list ff sorted sorted lemma ff list ff sorted lemma ff list ff induction enables extend results lemma ff list ff lemma ff list ff sorted sorted sorted lemma ff list ff definition permutation earlier obvious elimination rule prove derived elimination rule predicates 
lemma property lists ff 
sl sm corollary chapter 
examples lemma ff list ff obtain lemma ff list ff sorted sorted proof reflexivity lemma sorted 
lemma obtain definition xi corollary symmetry argument antisymmetry lemma sorted sorted correctness proof insert sort ml prototype sort wrote view proving correct fun listrec fold fn 
val fn 
fn 
val max min fun scons val listrec nil val sort listrec nil scons chapter 
examples translation lego code type list min cons max scons type list listrec nil cons sort listrec nil scons anticipate levels induction correctness proof function sort defined nested recursion 
recall derived induction principles recursive program phrases give account recursive deliverables oe list ff gamma 
fi gamma 
prop fi ff gamma 
list ff gamma 
fi gamma 
fi oe ff list ff fi 
oe nil oe list ff oe listrec consequence induction principle sorted lists oe list ff gamma 
fi gamma 
prop fi ff gamma 
list ff gamma 
fi gamma 
fi sorted oe ff list ff fi 
oe nil oe list ff sorted oe listrec sorted list induction property sorted relevant lemma 
induction principle exemplifies motivation second order deliverables relation oe lists holds condition sorted 
correctness proof proceeds application induction principle outermost recursion produces subgoals chapter 
examples sorted nil nil nil ff list ff sorted sorted scons scons 
immediate reduces ff list ff sorted sorted scons scons extends context assumption ff extended context define relativised specification list ff sorted may apply sorted list induction yield subgoals new context nil nil sorted nil ff list ff sorted mn 
trivial reduces ff list ff sorted sorted sorted min max min max goal rests apart trivial properties lemma suppose ff list ff ffl sorted ffl ffl chapter 
examples max proof consider cases order calculate max ii iii point take account hypothesis linear exhaust cases 
max lemma ii max definition 
iii sorted 
lemma lemma 
xi proof recast terms deliverables double recursion definition program translates nested list recursion level deliverables 
base case induction resolved simple pointwise construction 
inner step case verification function propositional reasoning lemmas 
point considerable course proof 
stage shift second order deliverable chapter 
examples identically true predicate lists defined outermost recursion inner recursion second order deliverables defined predicate sorted appears eliminate input parameter permutation relation moves condition sorted condition result condition input scons 
reduction case ff list ff sorted sorted scons scons ff list ff sorted sorted scons scons shift allows apply principle sorted list induction 
inconvenient ad hoc solutions exist resolve difficulty 
solution violates clean mathematical structure deliverables simply project function proof perform logical manipulations underlie shift sigma type 
ugly extremely hard understand attempting top derivation 
alternative considered rule difficult give intuitive justification 
accordingly simply state observe solves technical problem 
provisionally call rule exchange exchanges roles dependent variable parameter deliverable subject side condition specifications 
general statement possible give turns formulation sufficient serve purposes particular proof 
lemma exchange lemma suppose specifications relativised specification respect relativised specification respect 
suppose relation chapter 
examples omega omega relational composition 
rule derivable def def lifted level relativised specifications 
proof see appendix xi astute reader see interest applying rule case def sorted def list ff true def permutation shall see 
completed development terms deliverables relegate details appendix proof probably long intelligible 
outline significant refinement steps 
specification sorting perm sorted le previous example le associated propositional level ordering boolean valued order function le type le 

bool le eq tt le refl le trans le le le eq aor le le chapter 
examples predicate sorted relation lelist defined indicated listof constructors lelist type le rel listof le sorted type le rel lelist le abbreviations terminal predicate relation top level goal univpred list list unit outermost recursion uses listrec combinator apply splitting initial goal composition operator 
refine composedel refine base case recursion induction resolved pointwise construction 
unification solves value subgoal solve propositional subgoal perm nil 
prove permutation nil list equal nil obtain correct instantiation nil nil list trivially sorted 
step case little complicated 
introduce parameter listrec rule 
recall algorithm considered contains construct 
fun scons val listrec nil chapter 
examples composition deliverables explicates construct 
second component composition just second order deliverable analogue trivial construction subsection 
fold function relativised specification pursue inner recursion induction 
intros refine composedel refine list list cons list list cons perm cons sorted le position exploit exchange lemma 
side condition subrel perm solved observing sorted conjunct oe unchanged composition relation transitive closed composition 
fact closed cons type rel list list list cons cons 
type perm perm indicated position combinator 
preface application appeal composition 
refine composedel refine proof concludes considering pointwise construction base case induction account verification function 
lemma distinguish cases induction chapter 
examples possible boolean values expressions le le 
refined analysis recursion induction allow consider inductive step terms combinators deliverables 
pursued 
chinese remainder theorem turn mathematical example rich complex field number theory 
chinese remainder theorem state prove ring integers requires technical machinery formalise convenient way 
achievement applying deliverables methodology theorem considerable terms managing complexity formal proof 
mathematical specification theorem concerns solution simultaneous congruences pairwise coprime moduli 
theorem chinese remainder theorem gcd mod making remarks specification reification algorithm give 
firstly quantifier string range quantification implicitly defined integers variable length determined outermost quantifier 
formalising specification faced choices chapter 
examples ffl literal interpretation def natrec type unit type theta ffl computationally useful list outermost quantifier implicit length list 
considerably simplifies recursions involved type input remains constant recursion depending accordance choice simple types programming language 
price pay choice number extraneous subscript checks proof 
unavoidable take vector approach prefer information propositional level 
secondly require largely simplification presentation euclidean algorithm natural description terms general primitive recursion easy construction lemma euclidean algorithm am bn gcd gcd iff am bn 
assume proof form second order deliverable euclid theta am bn theta coprime notation indicate take list modulus remainder pairs basic input 
wish distinguish moduli remainders separate lists notation chapter 
examples coprime predicate gcd defined type pairs integers 
thirdly issue represent integers development 
touches area data abstraction certainly time include thesis 
possible topic research explore categorical techniques developed thesis context luo data refinement type theory hoare power category theory data refinement 
confine familiar representation iff terms deliverables consider underlying algorithm defined lists pair natural numbers 
proof respects equivalence relation computationally irrelevant far correctness concerned 
lastly question computational relevance lemma 
turns proof chinese remainder theorem taken relevant irrelevant applications lemma 
see system extraction mark different instances lemma way reflect uses 
turn proof theorem 
proof firstly fm pairwise coprime implies gcd def proof computationally irrelevant application euclidean algorithm 
combinatorial advantage reducing gamma conditions conditions cost calculating products exploit euclidean algorithm calculate 
chapter 
examples compute properties establish desired simultaneous solution 
words algorithm solving simultaneous congruences composition steps initialisation 
significant component takes list moduli applies function defined primitive recursion nil 
nil ms 
maplist theta ms pil def listrec theta simply multiplies elements list 
euclid ffl 
def euclid simply maplist euclid 
summation oe 
just listrec theta theta properly speaking theorem requires computed range step computationally trivial shall pursue 
xi clearly algorithm hardly optimal complexity purposes thesis concern 
chapter 
examples development terms deliverables deliberately obtuse presentation algorithm emphasising role vectors ghost variables 
course believe appropriate discuss logical properties stages terms second order deliverables 
persistence arguments computation parameters proof directly echoes discussion section 
accordingly wish extract steps ffl oe function components second order deliverables initialisation corresponding proof seek proposition list unit true matrix matrix representation relativised specification gcd mod wish show matrix euclid proof seek proposition list list true matrix matrix ffl ffl relativised specification matrix ffl representation ffi ij mod ffi ij kronecker ffi symbol ffi ij def chapter 
examples second order deliverable seek derive matrix ffl matrix ffl summation summation step matrix ffl oe sigma vector oe vector oe represents ffi ij mod establishes solution simultaneous congruence 
deliverable chinese remainder theorem obtained composition ffl oe sigma fact quite story 
relativised specifications matrix matrix ffl vector oe complex recursion list arguments 
allows dependent list recursion deliverable constructor noted enhance matrices explicit subscript checks effect output list length input list 
technical consideration forced lists represent quantifier string chinese remainder theorem 
complete development shown appendix really exploited power recursive deliverables initialisation step 
partly due time considerations partly practical grounds 
certainly achieved dramatic reduction size proof script case comparing recursive development pointwise construction 
largely invested representation matrices propositions 
chapter 
examples cases second third steps time consider pointwise constructions scripts long 
complex recursion definition matrices proved obstruction albeit temporary hope recursive development ffl oe sigma 
case appears complexity proof lies initialisation step 
reflected quadratic recursion definition compared linear algorithms ffl oe 
chapter deliverables categorical perspective construction order deliverables just particular instance modulo considerations semi structure indicated chapter grothendieck construction indexed category base base theory types functions fibres predicates 
discuss categorical formulation notion deliverable examine particular instance illustrates ideas 
abstracting away details syntax obtain perspective idea deliverables applicable wide spectrum semantic frameworks hyperdoctrines lawvere 
allows reinterpret calculations chapter added simplification extensional view functions proofs 
means correct notion equality deliverables non uniqueness structure defined semi adjunctions 
specialising analysis particularly simple understood hyperdoctrine subobjects topos structure emerges 
semantics dependent type theories developed years categorical logic show subsystem ecc may interpreted 
wheel turns full circle fragment basic type theory chapter 
deliverables speak structure composite objects call deliverables originally defined basic type theory 
construction order deliverables examine syntactic definitions chapter see structure exploited underlying semi cartesian closed structure types terms corresponding programming language system predicates assertions may programs defined internally prop valued functions 
type theoretic properties ecc allow define deliverables simple type structure programs logic quantifiers 
categorical structure sufficient describe constructions elaborated years ago lawvere 
hyperdoctrines definition lawvere hyperdoctrine hyperdoctrine indexed category cartesian closed base category cartesian closed fibres called attributes additional structure quantification pullback functor left right adjoints denoted coherence beck chevalley condition holds intuitively means substitution commutes quantifiers require preserves exponentiation fibres 
chapter 
deliverables may think representation functional programming language arrows correspond denotations program phrases 
attributes may thought notion predicates indexed objects morphisms fibres may regarded proofs entailments 
additional structure quantifiers coherence ensures logical language obeys usual rules substitution respect logical operations 
definition order deliverables indexed category grothendieck construction applied yields order deliverables grothendieck construction defines category functor fibration see appendix background material fibrations 
objects pairs oe object oe object 
morphisms pairs oe arrow ffl ffl oe 
theorem hyperdoctrine cartesian closed 
proof constructions section give syntactic description putative proof theorem 
cartesian closed structure components objects cartesian closed structure fibres quantifiers defining predicates second components objects 
exploit coherence chapter 
deliverables quantifiers exponentiation respect substitution definition hyperdoctrine reflect exactly logical constructions section 
uniqueness categorical structure defined bona fide adjunctions smooths technical encountered ecc 
theorem stands fact false 
called canonical isomorphisms definition indexed category obstruct proof 
cartesian closed structure defined isomorphisms 
model consider degeneracy allow construction proceed smoothly 
posets attributes 
xi precisely similar way wemay define second order deliverables 
definition second order deliverables hyperdoctrine object oe define category second order deliverables oe ffl objects pairs object attribute theta ffl arrows pairs theta oe theta 
just counterpart isomorphism theorem may state counterparts theorems secondorder deliverables setting 
leave formulation consequent canonical isomorphisms patient reader 
chapter 
deliverables programming language assertions scott essay suggests understanding calculus cartesian closed categories conservatively extended yoneda embedding considering calculus qua theory functions subtheory higher order logic topos sets op chapter extend idea observing precisely features subobject classifier representation predicates toposes models higher order logic allow give interpretation subsystem ecc 
interesting grounds gives new model construction cc enables cc language deliverables defined model higher order logic 
probably interesting application ideas thesis 
suggests able define complex deliverables usual apparatus pi clumsy categorical combinators previous chapters 
may directly apply technology theorem proving typed calculi development programs 
implementation idea remains subject research time investigate details approach 
chapter 
deliverables topos theoretic model turn particular instance foregoing analysis elaborate model basic ideas sketched burstall july 
related constructions discussed detail 
construction give valid arbitrary topos certainly view scott position demand exemplify concrete example category sets sets functions 
section concerns nave construction category sets gives rise model calculus constructions type constants cc 
cc viewed subsystem ecc 
introduced resolve conjecture luo concerning conservativity calculus constructions church simple theory types turns interpret type individuals church system term type prop cc calculus fails conservative 
require ability interpret type individuals constant type type 
cc minimal extension cc ability assume context type constants 
relationship topos theory exemplified category sets sets functions observing internal language topos essentially church system extensionality strong form proof irrelevance 
language parametrised exactly way intended cc constant symbols object type topos 
follow nijmegen notation referring system hol 
chapter 
deliverables consider model interesting semantics give type theory interprets types theory specifications sense chapter 
interpret type pair consisting set subset 
term functional type respects subsets firstorder deliverable 
model theoretic connection luo conservativity result 
luo projection berardi mohring essentially erases dependencies level types preserving level propositions show conservativity cc hol 
see similar phenomenon types hol carrier sets interpretation obtain mapping cc hol projection functor simply maps pairs carrier sets 
rules cc contexts ffi valid gamma type gamma valid type formation gamma valid gamma type constant 
rule really allowable signatures take hol signature produce cc signature semantic consideration particular model important stress object set hol syntactic counterparts type level 
nub luo original conjecture conservativity cc hol 
chapter 
deliverables pif gamma type gamma pix type prop gamma valid gamma prop type prf gamma oe prop gamma prf oe type basic typing var gamma delta valid gamma delta con gamma type gamma constant specified signature higher order logic 
pii gamma gamma pix pie gamma pix gamma gamma ma gamma oe prop gamma oe prop gamma prf oe gamma prf oe gamma prf oe gamma gamma prf oe chapter 
deliverables conversion gamma gamma type gamma take conversion relation fi conversion 
holds toposes consider explicit assumption extensionality 
substitution derivable presence fi conversion pi rules gamma type gamma gamma gamma modelling dependent types hyland pitts general framework modelling dependent type theories fibrations developed emphasis calculus constructions particular case 
refinement essentially presentations data model called categories fibrations shall employ 
interested reader appendix contains introductory material fibrations general essential development 
treatment closely follows 
categories fibrations case simply typed equational theories categorical logic provides simple semantic paradigm types correspond objects terms morphisms codomain corresponds type term domain context term typed 
substitution corresponds composition 
known example simply typed calculus cartesian closed categories example 
capturing type theoretic idea dependent type requires sophisticated machinery chapter 
deliverables obvious interaction contexts formedness types typedness terms 
definition pitts category fibrations category terminal object 
say category fibrations object collection fib ffl object fib object ffl arrow da ffl gamma 
called display map ffl gamma 
arrow fib fib arrow ffl ffl gamma 
ffl ffl ffl ffl da pullback require pullbacks 
interpreting types terms category fibrations base model contexts typed substitutions element fib gamma models types formed context gamma gamma type derivable 
rule valid contexts gamma type gamma valid chapter 
deliverables see operation ffl corresponds context extension 
model judgment gamma gamma type take sections da da id ffl id da extends simply typed case context extension ffl simply cartesian product theta objects display maps product projections 
situation term context morphism gives rise section display map simply pairing appropriate identity 
particular may give semantics rule var gamma delta valid gamma delta follows gamma fib gamma delta fib gamma ffl data hypothesis seek section gamma ffl ffl delta gamma ffl ffl delta ffl id da gamma ffl ffl delta object fib gamma ffl ffl delta corresponding gamma delta type essentially unique obtained mediating arrow pullback gamma ffl ffl delta delta delta delta delta delta gamma ffl ffl delta ffl gamma ffl id da da gamma ffl ffl delta delta da gamma chapter :10.1.1.38.7596
deliverables delta da delta gamma ffl ffl delta gamma :10.1.1.38.7596
gamma ffl just composite defined induction length delta 
semantics substitution straightforward generalisation 
existence pullback squares definition ensures may obtain new types substituting terms variables types behaved respect substitution language fibrations simply stipulating certain class cartesian arrows exist 
soundness rule gamma type gamma gamma gamma requires gamma type gamma gamma type obtained section determined gamma interpretation gamma unique section defined gamma delta delta delta delta delta delta delta delta delta delta gamma ffl ffl gamma ffl ffl id 
db gamma gamma ffl id da gamma ffl gamma gamma 
gamma ffl ffl gamma gamma ffl gamma ffl ffl follows fact section db db obtain mediating morphism pullback square 
chapter 
deliverables give model cc give type prop cod corresponding types propositions structure reflect relation terms type prop types form prf theory able form dependent product pi types propositions types propositions may objectified terms type prop closed pi 
dependent products category fibrations give structure dependent pi fibration give right adjoint substitution 
context category fibrations means fib fib ffl exists object fib soundness rule pif bijection ffl ffl db ae natural db say gamma 
fib fib ffl dotted arrows correspondence ffl ffl oe delta delta delta delta delta delta ff ae fi delta delta delta delta delta delta ffl delta delta delta delta delta delta fi ff delta delta delta delta delta delta delta ffl db ffl psi gamma gamma gamma gamma gamma gamma ffl da addition naturality define require construction pi respects substitution called beck chevalley condition 
relegate discussion technical issues appendix 
chapter 
deliverables propositions types cc cc levels corresponding types propositions may depend 
fibrations type prop corresponding judgments gamma prop gamma type fibration closed pi 
relate allow mixed quantifications including special case impredicative gamma prop oe prop gamma prop oe prop stipulate prop fully faithfully included type products type restrict products prop demand terms arrows sections type prop fibration type reflected back types objects fibres fibration prop accordingly object omega fib corresponding type prop 
term type section omega gives rise type prop pulling back generic proposition section 
generic proposition interpretation prop prf type object fib ffl omega gamma display map object prop proposition object prop display map corresponding arise way 
model turn details topos theoretic model 
base category data categories fibrations category sets ordinary sets functions illustrate construction 
clear structure sets finite limit structure cartesian closed structure fact notion subset construction chapter 
deliverables clearly rests representable 
words construction may applied topos yield model cc definition corresponds category order deliverables hyperdoctrine defined sets fibre object poset subobjects defined follows ffl objects pairs set subset sequel shall refer carrier distinguished subset predicate 
ffl arrows domain codomain functions gamma 
fy identity just identity composition arrows just composition functions gamma 
gamma 
satisfy fy gz ffi gz fy gamma 
unique restriction denote properties lemma finite limits proof straightforward show terminal object 
pullbacks inherited sets chapter 
deliverables pullback iff pullbacks sets iff pullback gamma gamma may readily checked 
xi may take theta theta theta theta projections theta gamma 
theta gamma 
distinguished choice product diagram lemma cartesian closed chapter 
deliverables proof object foe gamma 
oey evaluation map ev ev theta gamma 
inherited sets define exponential firstly observe ev yield arrow oe foe gamma 
oey ev oe oey secondly theta gamma 
expression gamma 
obviously yields unique mediating arrow id theta ev chasing predicates adjunction defining sets see arrow definition xi definition category fibration type proceeding lines indicated initial section define gamma object collection fib gamma operation ffl gamma fib gamma consists pairs set theta precisely instance notion relativised specification cf :10.1.1.38.7596
definition 
define context extension gamma ffl theta theta chapter :10.1.1.38.7596
deliverables display map da gamma ffl gamma 
gamma carriers readily seen arrow 
proposition burstall morphism ffl ffl db da form id second order deliverable proof condition db da readily implies 
id underlying morphisms da db just projections definition morphism satisfies exactly required :10.1.1.38.7596
xi substitution definition gamma 
fib theta fy theta id gamma definition fffl map theta id theta gamma :10.1.1.38.7596
theta carriers define arrow ffl ffl gamma :10.1.1.38.7596
ffl theta id ffl theta id theta theta id gamma fy theta theta ffl chapter :10.1.1.38.7596
deliverables ffl ffl ffl da pullback theta theta id theta pullback sets ffl gamma theta id gamma complete description type wemust close isomorphism class display maps fib gives rise :10.1.1.38.7596
essentially technical consideration 
formally objects fib triples :10.1.1.38.7596
psi gamma gamma gamma gamma gamma gamma product diagram definition requires choice pullbacks completely satisfactory :10.1.1.38.7596
dependent products define context gamma fib gamma fib gamma ffl oe thetab oea chapter :10.1.1.38.7596
deliverables natural isomorphism ffl ffl db ensures dependent product reasonably expected usual exponential adjunction carriers chasing predicates bijection oe ffl gamma 
ffl ffl oe db ffl oe theta id theta gamma :10.1.1.38.7596
theta theta theta gamma :10.1.1.38.7596

gamma 
theta fy fy fy fy verification beck chevalley condition consists long tedious chase may intuitively justified knowledge beck chevalley holds sets notions gamma exponential :10.1.1.38.7596
collection propositions type object omega omega omega gamma omega ftrue falseg considered element fib defines type propositions empty context shall see 
definition category fibrations prop obtain prop cod collections fib gamma operation gamma ffl gamma 
gamma take fib gamma collection subsets fib gamma define gamma ffl display map just identity 
chapter 
deliverables prop included type inclusion prf induced mapping 
theta defined collections fib gamma obvious extension gamma ffl :10.1.1.38.7596
theta theta theta gamma ffl defines mapping objects prop simply displays gamma objects type straightforward show extends functor prop type inclusion prop isomorphic category fibrations defined subcollections fib gamma component :10.1.1.38.7596
property preserved constructions considered obvious reasons 
able define products substitution prop restriction constructions type propositions yield types context gamma interpretation judgment gamma oe prop section gamma 
theta omega theta omega gamma prop ffl prop gamma 
arrow exactly id gamma omega arrow classifies subset fx element fib way terms type prop yield types 
particular denotation generic proposition prop prf type oe omega theta oe trueg oe omega theta oeg proposition pullback map classifying map sets subset representing proposition 
chapter 
deliverables dependent products straightforward somewhat tedious check calculation products propositions prop agrees type show gamma prop gamma prop prf pip prf prf fib gamma trivial sides reduce ja bg consistency model show model consistent exhibit type inhabiting closed term 
accordingly logical type theoretic intuition look denotation absurd proposition prop prop prf 
pix prop prf type earlier calculations ffi pix prop prf type fu oe omega oeg oe omega oe false proposition sets classifying empty subset set 
clearly object sections projection map sets factor empty set impossible 
prf 
inhabiting terms model logically consistent 
chapter 
deliverables proof irrelevance model proof irrelevant sense proofs proposition may judge equal understand interpretation equality judgments equality objects arrows model 
detail suppose gamma formed context gamma gamma oe prop 
prf oe subset gamma prf oe sections id gamma 

map identity carriers extent exists 

express axiom cc obvious way oe prop oe eq oe leibniz equality definable cc exactly way ecc 
interests completeness add axiom reflect logic sets true propositions essentially identified point set considered subobject collapse oe prop oe eq prop oe true extensionality higher order logic sets extensional sense sets functions gamma 
fx gx chapter 
deliverables pursuing complete axiomatisation model formulate rule axiom extensionality type gamma 
fx gx symbol type language represents judgment gamma type consider cc subsystem ecc unable quantify types assumption universes 
content regard extensionality schematic axiom absence structure topos define hierarchy type universes 
model luo ecc prepared certain assumptions underlying theory sets possible extend model give model luo ecc 
fact semantics sigma types assumptions 
sums hyland pitts specify sums giving left adjoint substitution defines akin existential quantifier orthogonality condition gives second projection sum 
terms categories fibrations context gamma fib gamma fib gamma ffl define object fib gamma underlying type theta predicate theta theta details defines sigma type left reader :10.1.1.38.7596
chapter 
deliverables type universes typical set theoretic assumptions modelling universes type theory exist strongly inaccessible cardinals 
intention nth inaccessible code nth universe 
intuitively straightforward restricting fibration type consist pairs sets may interpret type choice strong ensures constructions pi sigma take outside obtain hierarchy fibrations corresponding type levels fully faithful inclusions 
obtain type type details similar ibid 
pp 

chapter partial equivalence relations observational equivalence basic definitions chapter contain lot redundancy far proofs concerned 
having chosen notion equality sufficient give smooth theory categorical structure del distinguish different proofs program meets specification practical terms interested existence proof 
proof irrelevance topos models higher order logic possibility developing theory deliverables setting topos suggests modify basic definition deliverable 
fact extreme modification indicated prepared abandon decidable reducible type checking ecc property deliverable sense definition favour type inhabitation problem 
restrict distinguishing functions intensional character equivalent respect meeting certain input output specification 
chapter 
suggests advance fully fledged theory specifications observational equivalence functions consideration observations specifications 
led introduce partial equivalence relations pers 
consider definition context gamma 
definition specification specification pair gamma type gamma gamma 
gamma 
prop proofs gamma sxy gamma sxy 
say consider types partial equivalence relation defined 
issue terms part data simply require terms derivable 
proof terms chapter question book keeping 
specification sense gives rise sense definition passing diagonal 

specification la definition gives rise new sense leibniz equality eq 
sx eq sy 
easily shown eq equivalence relation failure reflexivity arises possible non totality predicate ground types course typically consider equivalence relations partiality forced pass higher types notion exponential familiar logical relations def gamma 
sxy fx gy framework correct notion deliverable function notion hom object considering collection functions modulo obtain appropriate notion cartesian closure 
possible develop chapter 
categorical structure chapter basis new definitions modulo principled account proof irrelevance 
general quite hard examining fully explicit system ecc ideas context studied proof irrelevant interpretation higher order logic toposes 
remains done exploring relationships explicit systems away details computationally irrelevant proofs non observable behaviour 
undertaken preliminary investigation lego pers specifications complete 
number outstanding technical details relating representation categorical perspective chapter 
data abstraction luo considers framework specification data types operations defined notion refinement exactly definition deliverable refinement maps taken going opposite direction 
introduces number operations specifications corresponding categorical structure chapter consider categorical framework example consider closed structure corresponding idea hypothetical specification 
analysis restricted simple types level refinement maps able define dependent families specifications straightforwardly account second order deliverables 
natural extension bring experience data abstraction deliverables obvious influence ideas programming large example programming small experience reported 
evident chapter 
ideas view deliverables outlined may clarify issues behavioural abstraction different implementations datatypes 
parametricity second order calculus calculus constructions ecc builds original girard higher order extensions curry howard correspondence applications proof normalisation higher order logic 
reynolds independently rediscovered girard second order calculus study programming languages polymorphism 
number subsequent papers reynolds attempted describe parametricity models calculus 
attempt describe aims merely observe number comparisons may ideas underlying thesis parametricity 
particular parametricity wadler approach proving properties programs second order calculus 
reynolds idea give interpretation types system relations style logical relations 
clearly links martin lof subset interpretation type theoretic description deliverables 
analysed predicative account computational types impredicative style programming second order calculus relationships need elaborated 
chapter 
extraction realisability authors notably paulin mohring collaborators project hayashi nuprl group constable studied proofs constructive mathematics view extracting programs realisability translations 
originally conceived kleene giving strong constructive reading logical connectives order validate certain intuitionistic principles 
contemporary treatments proof formal system calculus constructions annotated way mark proofs deemed computationally relevant syntactic map applied proof term yield term program related functional system 
general remove computationally irrelevant information necessarily yield familiar algorithms 
paulin programs obtained left parametricity discrepancy target programming languages account 
reasons considering simply typed programming language predicative type level ecc may replace primitive recursions counterparts considered subsystem impredicative level ecc 
opens way comparisons paulin extraction 
starting point may conjecture function component deliverable constructors natural number list recursions extracts proof component 
relationships remain precise believe definitive account recursion system proved satisfactory small examples considered 
chapter 
partial functions type theory strong normalisation theorem ecc implies wemay represent total recursive functions 
partiality arises naturally theory computation limitation addressed 
various authors considered partial objects logic type theory example immediately evident adapt methods framework deliverables 
category theory defines partial map monomorphism morphism adapt definition requires explicit criterion definability domain employ intuition domain represented logically predicate say partial map domain function sigmax sx 
function proof sx essential way 
purposes extending natural definition highly constructive flavour 
stronger constructive notion partial map defined logics existence predicate flexible obtains proofs term denotes 
pragmatically theoretically hope better reconciling partiality constructive type theory 
strong normalisation calculus extended inductive types fi ffi reduction open problem 
chapter 
pragmatics examples exhibited show far trivial formalise simple arguments pen verifications small pieces code 
clearly part due extra overhead fully formalised proofs equally clearly limitation 
regard experience chinese remainder theorem support approach proof fully formalised hand considered pointwise construction greatly reduced length complexity recursion induction principle second order deliverables lists 
formalise second third stages algorithm deliverables analysis regarded provisional 
certainly consider rules recursion case second order deliverables definitive account examples considered appear adequate 
considerations widen scope come consider nature large programs 
considered kinds modular development programs discussed example literature extended ml 
examples minimum finding insert sort parametrised underlying type boolean valued ordering relation gives certain modularity constructions 
remains open question satisfactorily answered light greater experience methodology propose appropriate verification pieces code kinds signature matching conditions encountered chapter 
modules system ml possibly augmented axioms large scale developments outstanding deficit proposal deliverables programming methodology lack type theoretic language describing 
chapter represents start direction details remain elaborated 
shown possible give principled account general notion functions respect specifications called deliverables 
syntactically semantically particular setting model higher order logic able lift structure functions deliverables 
theory quite supported small number examples considered 
various limitations observed approach 
expect development suitable type theories describing deliverables style chapter may extend utility methodology 
light luo idea deliverable guise theory morphism describe structuring proof development mathematical theories 
appendix fibrations appendix discuss general categorical framework underlying constructions chapter 
details fibrations interested reader referred papers 
basic definitions idea fibration captures notions heart theory dependent types types terms relative context substitution rules valid contexts regulate passage data relative different contexts 
data arises ways valid contexts typed substitutions types context typed terms context 
case simple types may organise category organise 
hope category judgments context related case functor gamma 
relationship 
ask takes judgment returns context derived 
reflect derivations judgments particular appendix fibrations derivations rule substitution 
intended model typed substitutions structure reflected definition cartesian arrow gamma 
functor 
arrow gamma 
cartesian pf terminal lift property gamma 
pc gamma 
pb pc pg pb pf pa commutes unique lift ph commutes 
definition fibration gamma 
fibration oe gamma 
pa cartesian lift consequence definition cartesian arrow property fibration equivalent requirement oe gamma 
pa lift arrow gamma 
factors hf ph id pc cartesian 
speak vertical arrow horizontal 
collection vertical arrows forms subcategory called fibre metaphorically cartesian arrows base translations fibres parallel fixed appendix fibrations uniquely choice object fibre codomain definition cartesian arrow formalisation metaphor 
cartesian arrows reflect structure base sense hinted section 
fibration collection local data fibres translations substitutions cartesian arrows essentially unique way 
central example types functor cod objects arrows gamma 
morphisms yield commutative squares cod codomain map cod lemma cod cartesian arrows precisely pullback squares 
lemma cod fibration precisely pullbacks 
study dependent types principally interested cod 
category fibrations fib ffl may form category objects display arrows morphisms euclid fifth postulate 
appendix fibrations commutative squares ffl ffl db da obvious inclusion theorem cod gamma 
fibration 
proof immediate data earlier discussion cod 
cartesian arrows precisely pairs ffla gamma 
fib xi naturality beck chevalley condition categories fibrations construction dependent product varies parameters ffl context morphism gamma 
ffl target type ffl type naturality pi construction concerns variation parameters expressed follows gamma 
fib fib ffla ff fflf gamma 
ffla ffla gamma 
ffla appendix fibrations parallel arrows equal ffl ffl oe delta delta delta delta ff delta delta delta delta delta ffl delta delta delta delta delta delta delta delta delta ff delta ff pi delta delta delta delta delta delta delta delta delta ffl pi ffl ffl oe ff ffl ff ffl db 
psi gamma gamma gamma gamma gamma gamma ffl da pi ae id ffl gamma 
ffl addition require construction pi respects substitution called beck chevalley condition variation third parameters variation abstraction type substitution may formulated follows gamma 
fib fib ffl induced map ffl pi ffl gamma 
ffl appendix fibrations isomorphism obtained chase round diagram ffl pi ffl ffl ffl pi ffl psi gamma gamma gamma ae id gamma gamma gamma ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ff ae id ffl ffl ffl pi ffl ffl ffl pi ffl ffl pi ffla ffl ffl pi ffla vertices pullbacks exists unique isomorphism ff ffl pi ffl ffl gamma 
ffl pi ffl ffl obtain arrow oe ff ae id ffl ffl ffl pi ffl ffl gamma 
ffl ffl indicated transpose bijection yields commuting square ffl pi ffl oe ffl appendix fibrations ffl ffl pullback obtain unique mediating arrow ffl pi ffl ffl required 
may rephrase beck chevalley condition requiring ffl pi ffl ff ae id ffl ffl ffl pullback theorem model chapter satisfies form beck chevalley condition 
proof straightforward 
condition holds carrier sets dependent products inherited sets 
predicates preserved follows elementary logic chase round diagram 
xi appendix lego code relevant thesis proof scripts constructions considered categorical model chapter 
suppressed number lemmas required course studying examples especially theorem 
hope date library theorems lemmas available anonymous ftp 
offer minimal commentary form comments code signified 
notation 
basics collect mathematical knowledge employed examples 
order suppress unnecessary information simply names terms lego context developed 
reader may certainly omit material reading examples 
basic logic definitions slight modification appear 
appendix lego code relevant thesis init prop type cut compose permute conjunction disjunction negation prop prop prop prop prop prop pair prop inl prop inr prop fst snd constants false propa prop false true propa top prop true quantification uniform pi prop tp prop existential quantifier ex prop prop prop prop witness prf wit prop gen gen witness prf ex tuples prop prop prop pair prop prop chi prop appendix lego code relevant thesis pair chi prop chi predicates relations prerequisites deliverables pred type prop rel type prop rel refl tr prop sym prop trans prop preorder refl trans sym trans equiv refl goal 
ex 
intros ande intros exe intros refine refine immed save discharge families relations preserves rel rel prop respect preserves prop equality eq pred rel refleq pred refl eq eq eq refleq sym eq trans eq eq eq pred compose application respects equality substitution property respect eq appendix lego code relevant thesis eq eq refleq pi want better pi discharge basic datatypes unit booleans naturals unit unit type void unit unit unit type void 
unit type void void 
goal void intros refine immed save type goal unit 

intros phi refine phi void save goal 
unit 
intros immed save discharge bool bool type tt bool ff bool bool type tt ff bool type tt ff tt 
ff 
appendix lego code relevant thesis phi bool prop phi tt phi ff phi type bool bool bool type bool andb bool ff orb bool tt tt ff bool tt ff tt bool ff tt goal eq tt eq ff refine bool eq tt eq ff refine inl refine refleq refine inr refine refleq save goal eq tt ff intros eq refine eq true false intros immed save peano bool new nat nat type zero nat succ nat 
nat nat type zero nat ih kc succ nat nat type zero nat ih kc succ zero 
succ 
natiter type nat nat natrec type nat nat phi nat prop appendix lego code relevant thesis phi zero nat ih phi succ phi succ zero succ succ succ succ succ succ succ plus nat nat natiter succ mult nat nat natiter zero plus exp nat nat natiter mult pred nat nat natrec zero nat minus nat nat natiter pred nat plus minus nat minus minus lenat nat ex nat eq plus succ rel nat nat nat ex nat eq plus rel nat nat goal nat eq succ succ 
eq intros refine nat pred immed save peano nat goal eq zero intros refine natiter true prop false intros immed save peano nat goal eq zero succ intros refine natiter true prop false intros immed save peano nat goal plus zero refine nat eq plus zero refine refleq intros refine succ immed save goal succ plus plus succ intros refine nat eq succ plus plus succ refine refleq intros refine succ immed save goal plus plus refine nat plus plus appendix lego code relevant thesis intros refine intros refine refine succ refine ih save calculus relations edited version extensive section systematic study representation calculus relations lego 
formed part general study iterated inductive definitions applications theory permutation 
relations prop type pred hyp xg pred hyp hyp refl pred hyp hyp trans subrel rel hyp yr rel hyp hyp refl subrel rel subrel subrel hyp hyp trans subrel pred pred pred pred pred xe pred pred pred op rel rel rel rel rel rel rel rel rel rel appendix lego code relevant thesis phi prop exy hyps rel rel rel yt rel rel rel hyps zt rel prop pred pred rel pred rel univpred true univpred false type pred top type pred univpred phi pred 
pred preserves phi phi rel 
rel preserves phi subrel subrel discharge polymorphic lists list type type nil typelist cons list list type list type nil list ih kc cons list ac type list list 
type nil list 
cons appendix lego code relevant thesis nil 
cons 
type phi list 
prop phi nil list ih phi cons list phi type type list list listrec type type list list type atom cons nil head list tail list listrec nil list append list cons list zero nat succ list 
eq cons 
eq cons 
eq 
eq cons 
eq cons 
eq 
eq append nil 
eq append append append append 
eq append nil 
eq nil eq nil 
eq eq zero eq nil 
nat eq eq succ ex eq cons tail 
eq plus append discharge false prop true pred list insert list append cons appendix lego code relevant thesis list peano list 
eq eq cons nil false 
eq eq insert nil false 
eq insert cons nil 
eq nil eq eq nil discharge concludes selection large number lemmas lists necessary prove course research 
permutation turn theory permutation lists impredicative definition gave chapter 
proved major investigation 
give definition trivial establish constructor properties relation intersection equivalence relations equivalence relation identify lists commutativity append function closed cons induction closed append 
new permutations resolution problem perm prop type swap rel list list list append append rel list list list cons cons rel list list subrel perm rel list list list rel list list refl sym trans appendix lego code relevant thesis swap 
refl perm 
sym perm 
trans perm swap perm 
swap perm perm crucial elimination rule inductive relation 
give proof analogue derivation primitive recursor iterator church representations datatypes 
goal list perm rel list list list ar list perm list perm perm list ar append append list perm cons cons intros refine perm andi andi intros andi refine refine andi intros ande andi refine refine immed intros ande ande andi refine refine immed refine refine intros refine perm andi appendix lego code relevant thesis intros andi refine refine intros ande andi refine refine immed intros immed intros immed save goal rel list list list eq list perm list perm perm list ar append append list perm cons cons subrel perm intros refine intros refine refine refleq immed save type goal rel list list append 
append list perm 
cons 
cons subrel perm intros refine kerr op op appendix lego code relevant thesis refine kerr intros andi intros refine immed intros refine immed intros ande andi intros refine immed intros refine immed intros ande ande andi intros refine refine immed intros refine refine immed intros andi refine refine intros ande andi intros refine immed intros refine immed refine immed refine refine save discharge wenow specialise elimination rule consider predicates 
application show permutation nil list nil permutation singletons occurs fact equal 
goal pred list list append 
append list perm iff cons 
cons list perm 
intros refine list iff immed intros andi intros refine immed intros refine immed intros ande andi immed intros ande ande andi appendix lego code relevant thesis intros refine refine immed intros refine refine immed intros andi refine refine intros ande andi refine immed refine refine andi immed intros refine immed save goal list perm eq nil 
eq nil intros refine eq nil immed intros refine refine immed intros refine list eq nil append refine list eq nil append nil refine refleq intros refine nil refine immed save goal list perm nil leq nil intros refine immed refine refleq save 
list perm eq atom 
ex eq eq atom goal perm atom atom 
eq intros refine refine refine refleq intros ande refine immed refine immed refine refleq save goal list perm refine list eq intros refine list eq 
refine refleq intros refine refine intros refine refine refine intros refine refine appendix lego code relevant thesis refine refine intros refine succ refine save turn tricky proof hereditary property 
stage proof insert sort require case iii proof lemma 
list phi prop list perm append eq insert phi rel list list goal list eq insert append intros refine immed refine save goal list append append intros refine intros refine immed intros refine intros refine refine list eq list 
append refine refine refine refine list perm append refine refine refine refine intros refine intros refine refine list eq list 
append refine refine refleq refine refine appendix lego code relevant thesis refine list perm append refine refine refine refine save goal list perm list list cons cons intros refine intros refine cons nil immed intros refine intros refine immed intros refine refine eq 
cons refine nil refine refleq refine refine refine list perm append refine list perm append refine list perm append refine intros refine intros refine append refine immed intros refine refine list eq 
cons refine refleq insert cons refine refine refine list perm append refine refine save goal list appendix lego code relevant thesis intros refine intros refine intros refine refine refine refine refine intros refine intros refine refine refine list perm append refine refine refine refine list perm append refine refine refine refine refine refine refine refine refine refine refine refine intros refine intros refine intros eqh refine refine refine eqh list perm append refine refine refine refine list perm append refine intros refine intros refine refine refine list perm append refine refine refine refine list perm append refine refine refine refine refine refine refine refine refine refine refine refine refine appendix lego code relevant thesis save goal list perm eq cons intros refine immed intros refine immed intros refine immed refine nil immed save goal list perm cons cons 
perm intros rel list list list list eq eq cons eq eq cons refine immed intros expand intros refine refine refine immed intros expand intros refine refine immed intros expand intros refine refine eq refine eq refine list list append append intros expand intros refine refine refine immed intros refine list append append intros eq eq eq refleq eq eq refleq eq refine refine refine intros eq eq eq refleq eq appendix lego code relevant thesis eq refleq eq eq insert eq refleq eq insert eq refleq refine refine refine refine perm insert 
refine perm 
insert refine refine refine refine refine refine intros eq eq refine eq refleq list perm refine eq refleq refine refine refleq refine refleq save discharge hereditary rel list list list goal hereditary perm refine list subrel perm perm intros immed intros intros refine ih refine immed save goal list perm insert insert insert insert intros refine refine refine cons cons refine refine refine refine appendix lego code relevant thesis refine refine refine save discharge sorting lemmas turn theory predicate sorted example insert sort considered 
modules specification sorting sorted prop type le rel refl le trans le le le 
eq specification lelist true prop le pred list sorted listrec true list prop lelist pred list goal type phi rel list 
list 

phi nil 
list sorted cons 
phi 
phi cons 
list sorted 
phi listrec intros refine list sorted 
phi listrec immed appendix lego code relevant thesis intros immed intros refine intros refine immed refine ih immed save wenow prove specification including lemmas chapter 
goal sorted nil intros immed save list goal lelist nil intros immed save goal sorted cons 
sorted intros refine intros immed save goal sorted cons 
lelist intros refine intros immed save goal lelist cons 
lelist intros refine intros immed save goal lelist append 
lelist refine list lelist append lelist intros immed intros refine ih refine immed save goal lelist append 
lelist refine list lelist append lelist intros refine intros refine intros refine pair immed refine ih immed appendix lego code relevant thesis save goal lelist 
lelist 
lelist append intros refine list lelist lelist append immed intros immed intros refine intros refine pair refine ih immed save goal sorted append 
sorted sorted refine list sorted append 
sorted sorted intros refine pair refine immed intros refine intros refine ih immed intros refine pair refine pair immed refine immed save goal le 
lelist 
lelist refine list le lelist lelist intros refine intros refine intros refine pair immed refine immed refine ih immed save goal perm 
lelist 
lelist refine lelist intros refine refine refine immed intros refine refine intros refine pair refine immed save appendix lego code relevant thesis goal sorted cons sorted cons 
perm cons cons 
le intros refine fst refine lelist equiv lelist cons refine immed refine pair refine refine immed save goal sorted cons sorted cons 
perm cons cons 
eq intros refine refine immed refine immed refine immed save discharge goal list sorted sorted perm refine list list sorted sorted perm intros refine immed intros refine refine immed refine refleq intros eq refine eq sorted refine intros refine refine refine ih 
list eq 
cons immed refine refine refine refine eq appendix lego code relevant thesis eq eq eq refine eq 
cons refine refleq save discharge concludes basic lemmas 
included substantial number trivial lemmas arithmetic employed proof chinese remainder theorem 
may safely left substantial exercise patient reader 
deliverables lego code constructions chapter 
contrast foregoing easier comment 
argue chapter merely verbose inaccurate account fully formal treatment 
order deliverables predicates order deliverables prop spec type 
prop local context type pred pred pred pred pred fundamental definitions del pred pred pre del pred pred del appendix lego code relevant thesis hack assist equality deliverables ff del ff ff pre pre del identities pred del law composition goal del del del intros ff gg ff ff gg gg refine intros refine refine immed save composedel ff del gg del hh del goal eq composedel ff ff refine refleq save goal eq composedel ff ff refine refleq save goal eq composedel ff composedel gg hh composedel composedel ff gg hh refine refleq save basic pointwise construction deliverables underlying term calculus goal 
del appendix lego code relevant thesis intros family refine family intros refine family immed save trivial construction function yields deliverable pred goal del intros refine intros immed save discharge logical inferences yield deliverables pred pred goal del intros subs immed intros refine subs immed save goal 
del del intros subs phi phi phi phi phi immed intros refine refine phi refine subs immed save discharge goal ff ff eq ff composedel refine refleq appendix lego code relevant thesis save discharge ff semi terminal object unit pred unit unit eq void goal pred unit intros refine void intros hyp refine refleq save semi cartesian binary products productdel pred pred xy xy xy associated pairing function ff del gg del ff ff gg gg pair del productdel associated projections goal pred pred udel productdel intros refine yz yz intros refine fst pre save pi del goal pred pred udel productdel intros refine yz yz intros refine snd pre save pi del appendix lego code relevant thesis semi exponentials del underlying predicate exponential object goal del productdel 
del del intros ff ff ff refine intros refine refine pair immed save goal del del 
del productdel intros gg gg gg refine intros refine pre intros refine immed save goal pred pred udel productdel del intros refine intros hyp refine fst hyp refine snd hyp save hayashi equational conditions algebraic semi ccc ff del productdel gg del hh del kk del goal eq composedel kk gg hh composedel kk gg composedel kk hh refine refleq save hayashi goal eq composedel gg hh pi del gg refine refleq doesn quite goal eq composedel gg hh pi del gg appendix lego code relevant thesis refine refleq save hayashi goal eq composedel gg hh pi del hh refine refleq save hayashi ii goal eq composedel composedel gg ff hh composedel gg hh ff refine refleq save hayashi goal eq composedel gg ff composedel composedel pi del gg pi del ff refine refleq save hayashi ii goal eq composedel kk refine refleq save hayashi goal eq composedel pi del del pi del del refine refleq save hayashi discharge appendix lego code relevant thesis order deliverables sums natural lists tau type tau tau tau type type type ac 
bc 
bc type type ac bc 

case type type pred pred pred pred pred ex eq ex eq goal del del del intros ff gg ff ff gg gg intros refine case intros refine case immed intros refine intros refine intros conj refine fst conj case appendix lego code relevant thesis refine refine snd conj intros refine intros abs refine fst abs prop false true intros immed intros refine intros refine intros abs refine fst abs prop true false intros immed intros refine intros conj refine fst conj case refine refine snd conj save discharge order deliverables natural numbers nat nat true nat nat nat spec type pred goal zz del unit ss del nat intros zz void zz ss ss refine intros refine natiter refine nat nat natiter intros refine refine intros refine refine ih intros immed appendix lego code relevant thesis save goal zz del unit ss del nat del del nat intros zz void zz ss ss refine intros refine natrec refine nat nat natrec intros refine refine intros refine refine ih intros immed save discharge order list deliverables prop type pred pred listof pred true prop pred list goal del unit 
del del 
del listof intros nn cc nn void nn cc cc intros refine refine list listof lt intros refine refine intros refine intros refine refine ih immed save goal del unit 
appendix lego code relevant thesis del del listof del 
del listof intros nn cc nn void nn cc cc intros refine listrec refine list listof lt listrec intros refine refine intros refine intros refine refine ih immed save discharge second order deliverables relations second order deliverables del prop type pred pred pred pred pred rel rel rel rel fundamental definitions del pred rel rel pre del pred rel rel del hack assist equality deliverables ff del ff ff pre pre del appendix lego code relevant thesis identities pred rel pre pre del law composition goal del 
del 
del intros ff gg ff ff gg gg refine intros refine refine immed save composedel ff del gg del hh del goal eq composedel ff ff refine refleq save goal eq composedel ff ff refine refleq save goal eq composedel ff composedel gg hh composedel composedel ff gg hh refine refleq save basic construction deliverables underlying term calculus goal pre bq del intros family refine family intros refine family immed save appendix lego code relevant thesis basic tool lifting structure del del goal fx fx 
del intros family refine family immed intros refine family immed save goal del 
fx fx intros ff ff ff refine immed save del goal del 
intros ff ff ff refine refine immed save del trivial construction function yields deliverable rel rel goal del intros refine intros immed save discharge logical inferences yield deliverables pred rel rel goal del intros immed intros refine immed save appendix lego code relevant thesis goal subrel subrel 
del 
del intros subs subp subq phi phi phi phi phi refine phi intros refine subq refine phi refine subs refine subp immed save discharge factorisation theorem goal ff ff eq ff composedel refine refleq save discharge ff structure inherited del productdel rel rel productdel rel goal del 
del 
del productdel intros ff gg ff ff gg gg refine intros refine pair refine refine immed save goal del productdel intros refine pi immed appendix lego code relevant thesis intros refine fst pre save proj del goal del productdel intros intros refine pi immed intros refine snd pre save proj del 
rel rel del rel goal del productdel 
del intros ff ff ff intros refine refine intros refine immed refine pair immed save goal del productdel intros refine intros refine fst pre refine snd pre save 
reindexing fibres del kk del rel kk rel goal kk del del 
appendix lego code relevant thesis del del kk del kk intros kk ff kk kk ff ff refine compose intros refine refine immed save preserves structure nose 
example 
kk del goal eq del kk del kk del kk refine refleq 
ff del productdel see type casting goal typed goal eq kk ff kk ff del productdel del kk del kk del kk refine refleq discharge appendix lego code relevant thesis second order deliverables natural numbers lists second order deliverables natural numbers prop type rel nat rel nat nat zero rel nat rel nat nat succ rel nat goal del nat 
del nat intros ss ss ss intros refine natrec immed intros zr refine nat natrec immed intros refine immed save discharge second order deliverables lists prop type rel list list nil rel list pred list list cons pred list rel list list cons rel list rel list goal univpred list 
del univpred list appendix lego code relevant thesis intros family family family intros refine listrec immed intros refine list listrec immed intros refine immed save phi rel list listrec true list phi prop phi phi pred list phi rel list goal phi 
del phi intros family family family intros refine listrec immed intros refine list phi lr listrec immed base case intros immed step case intros refine refine ih refine snd immed save discharge appendix lego code relevant thesis examples simple example recall introductory example chapter simple doubling function 
type phi 
prop phi phi phi phi goal 

intros intros refine refine refine intros hyp expand intros prf refine refine hyp immed undo refine refine save proof hnf vreg normal vreg proof hnf vreg normal vreg appendix lego code relevant thesis division discussion chapter simply include lego file 
prop just marker goal zero zero refine zero refine refleq save goal zero refine refine refleq save goal nat eq eq plus eq succ plus succ intros refine refine succ immed save div lemma goal nat leq succ succ intros refine leq intros refine refine refine succ immed save div lemma div spec nat nat nat eq plus succ goal del univpred nat nat unit div spec refine composedel refine zero case refine intros intros refine pair appendix lego code relevant thesis refine refleq plus zero zero refine refine successor case refine intros refine succ intros ih refine pair refine div lemma refine ih refine ih refine div lemma refine ih save div del div normal nat div del void div nat natiter zero zero nat nat succ div nat nat nat div normal vreg succ succ succ succ zero succ succ succ succ zero div normal vreg succ succ succ zero succ succ succ succ zero minimum finding list give lego script 
prop type inlist listrec false appendix lego code relevant thesis list phi prop eq phi bool eq tt refl trans eq aor goal eq ff intros ore intros rab refine peano bool refine refine immed intros rba immed save min minspec list aand inlist cons lelist cons goal del univpred list list unit minspec refine composedel refine base case refine intros intros refine pair refine inl refine refleq refine pair refine intros immed step case appendix lego code relevant thesis intros refine intros refine min intros spec refine spec intros inlist lelist refine intros case refine case bb bool ga bb inlist ga cons cons lelist ga cons cons refine pair refine inl refine refleq refine pair refine equiv lelist cons refine refine immed intros case refine case bb bool ga bb inlist ga cons cons lelist ga cons cons refine pair refine inr immed refine pair refine immed save normal list void list listrec list list discharge include transcript dialogue lego 
omit proof initial lemma 
appendix lego code relevant thesis goal del univpred list list unit minspec refine composedel type rel list del univpred list list unit del univpred list minspec refine del univpred list list unit minspec adel univpred list minspec minspec refine list unit 
univpred list 
list unit 
minspec adel univpred list minspec minspec intros list unit univpred list 
list unit 
minspec intros univpred list pre list unit inlist cons nil lelist cons nil refine pair inlist cons nil lelist cons nil refine inl eq lelist cons nil refine refleq lelist cons nil refine pair appendix lego code relevant thesis true refine true intros prop immediate discharge 
discharge 
pre discharge 
closes branch corresponding base case 
step case follows 
adel univpred list minspec minspec intros del univpred list minspec minspec refine list 
univpred list 
minspec minspec intros list univpred list 
minspec minspec refine min univpred list 
minspec minspec min intros spec univpred list spec minspec inlist min cons cons appendix lego code relevant thesis lelist min cons cons refine spec inlist cons 
lelist cons 
inlist min cons cons lelist min cons cons intros inlist lelist inlist inlist cons lelist lelist cons inlist min cons cons lelist min cons cons consider cases fb tt ff 
refine eq tt 
inlist min cons cons lelist min cons cons eq ff 
inlist min cons cons lelist min cons cons intros case case eq tt inlist min cons cons lelist min cons cons refine case bb bool ga bb inlist ga cons cons lelist ga cons cons inlist tt cons cons lelist tt cons cons refine pair inlist tt cons cons lelist tt cons cons refine inl eq tt lelist tt cons cons refine refleq lelist tt cons cons appendix lego code relevant thesis refine pair tt tt lelist tt refine tt lelist tt equiv lelist cons refine trans lelist cons refine lelist cons immediate discharge 
case list univpred list spec minspec inlist inlist cons lelist lelist cons eq ff 
inlist min cons cons lelist min cons cons intros case case eq ff inlist min cons cons lelist min cons cons refine case bb bool ga bb inlist ga cons cons lelist ga cons cons appendix lego code relevant thesis inlist ff cons cons lelist ff cons cons refine pair inlist ff cons cons lelist ff cons cons refine inr eq ff inlist ff lelist ff cons cons immediate lelist ff cons cons refine pair ff ff lelist ff refine eq ff ff ff lelist ff immediate discharge 
case discharge 
lelist inlist discharge 
spec discharge 
discharge 
qed saved final result lego 
value composedel list unit univpred list list unit pair inl refleq pair prop appendix lego code relevant thesis minspec list min spec minspec spec inlist min cons cons lelist min cons cons inlist inlist cons lelist lelist cons inlist min cons cons lelist min cons cons case eq tt case bb bool ga bb inlist ga cons cons lelist ga cons cons pair inl refleq tt pair tt case lelist case eq ff case bb bool ga bb inlist ga cons cons lelist ga cons cons pair inr inlist pair case lelist type del univpred list list unit minspec lego 
normal list void list list list bool appendix lego code relevant thesis insert sort script proof dialogue 
large examples cease intelligible directly quoted 
machine checked proof lemma 
prop exchange lemma generalisation type pred pred rel rel rel type pred rel goal subrel 
del 
del intros sub ff ff ff intros refine immed intros refine sub intros refine exy refine refine fst pre refine snd pre immed save discharge rel rel rel goal subrel ff del op del intros ff ff intros refine immed intros fst pre fst snd pre appendix lego code relevant thesis hyps snd snd pre refine intros refine exy refine immed save discharge proof begins type le 

bool le eq tt le refl le trans le le le eq aor le le goal eq ff le le intros ore intros refine peano bool refine refine immed intros immed save perm sorted le univpred list list unit goal del refine composedel refine refine base case intros intros refine pair refine refine le step case appendix lego code relevant thesis intros refine composedel refine list list cons list list cons perm cons sorted le refine immed consider side condition subrel perm intros hyp refine hyp intros fst snd refine pair refine refine immed return reasoning refine composedel refine base case refine intros intros refine pair refine refine pair refine top refine top step case intros refine intros refine le cons cons intros pre split hypotheses fst lelist le appendix lego code relevant thesis snd sorted le fst pre perm cons cons snd pre sorted le cons fst lelist le snd sorted le consider cases proof lemma 
case simple case lemma 
consider cases refine le intros refine pair refine refine nil nil refine immed refine pair refine pair immed refine le immed intros refine pair refine refine nil nil refine refine nil nil refine immed refine pair refine pair immed refine refine pair immed treat case iii lemma ii lemma 
concludes proof 
lelist le appendix lego code relevant thesis refine le intros refine refine refine refine le perm cons immed refine pair refine le immed intros refine refine refine refine pair refine immed save normal list void chinese remainder theorem technical preliminaries success failure constructive proofs type theory highly sensitive choice representation 
discuss main ideas employed structuring proof theorem 
appendix lego code relevant thesis matrix matrix ffl instances term generalised kronecker ffi matrix represent conjunction matrix propositions phi phi def oe propositions oe fact may functions oe allowing vary vectors def fa def fb yielding definition 
definition generalised kronecker ffi suppose types ff fi relations oe ff gamma 
fi gamma 
prop 
vectors def fa ff def fb fi define generalised kronecker ffi matrix propositions kronecker oe kronecker oe def oe consider instances general construction matrix take nat ffl oe def coprime ffl def mod matrix ffl take nat ffl oe def mod ffl def mod strength generalised kronecker ffi may define primitive recursion list pairs values vectors zip function definable primitive recursively 
appendix lego code relevant thesis order define total zip function partial functions available ecc pay price 
subscript checks arise 
zip function define returns list length minimum lengths zip defined recursion list argument producing function lists lists defined primitive recursion 
lego zip type list list list nil list list list listrec nil list list cons type list list list instances zip considered proof aj bj 
vectors may formulate induction principle zip 
lemma zip induction suppose types ff fi place relation phi ff gamma 
fi gamma 
ff theta fi gamma 
prop rule derivable phi nil ff nil fi nil ff nil fi ff fi list ff list fi jlj jmj phi zip phi zip list ff list fi jlj jmj phi zip kronecker matrix definable lego follows kronecker type phi psi rel list bs list ab ab ab list phi appendix lego code relevant thesis listof cd cd cd psi psi zip bs zip induction may derive fold unfold characterisation kronecker oe 
type phi psi rel list list 
kronecker phi psi cons zip 
phi kronecker phi psi zip listof psi listof op psi 
type phi psi rel phi 
list list 
listof psi listof psi 
kronecker phi psi zip 
kronecker phi psi cons zip established technical details proof initialisation step compact 
proof complete proof rests large number largely trivial arithmetic lemmas manipulations recursive propositions considered particular formalisation proof theorem 
include 
merely give main constructions deliverables ffl oe sigma 
include pointwise construction deliverable initial step contrast size proof required adopt powerful structuring available deliverables approach 
appendix lego code relevant thesis crt preliminaries prop specification initialisation step list zed kronecker coprime divides zip goal zed list zed listof coprime eq maplist intros refine list zed list zed zed listof coprime matrix kronecker coprime divides maplist immed intros immed intros refine eq matrix intros refine refine refine refine fst refine refine eq refine refine intros div refine immed refine intros div refine immed refine refine snd immed save initialisation function appendix lego code relevant thesis bar ns list zed listrec nil zed zed ns list zed product list zed cons ns maplist product ns goal ns list ns bar ns intros refine ns list zed eq ns bar ns immed refine refleq intros refine succ refine ih refine save statement initial step crt list zed zed unit true pcm list zed zed ms maplist pi zed zed ms ms list zed list zed ms list zed zed list zed ms maplist pi zed zed ms goal del pcm refine save goal del pcm refine composedel refine refine nil case refine appendix lego code relevant thesis intros refine nil zed intros refine pair intros immed refine refleq step case intros refine intros refine cons maplist intros hyp pre fst hyp listof coprime fst pre snd pre refine pair equal lengths twice refine succ refine refine refine refine refine refine refine refine refine refine refine immed save comparison pointwise construction proof theorem build bar algorithm statement theorem 
statement initial step crt list zed zed ms maplist pi zed zed ms bar ms ms appendix lego code relevant thesis proof goal intros ms maplist pi zed zed bar ms refine listrec list zed zed ms maplist pi zed zed ms bar ms ms immed intros immed intros intros ks maplist pi zed zed bar ks intros ih fst listof coprime ks snd ks refine list zed zed ks maplist pi zed zed ks bar ks ks cons ks cons ks cons ks maplist immed intros refine pair refine pair intros refine gen refine refine refine refleq intros immed intros immed 
zip ks appendix lego code relevant thesis refine ih immed back 
intros ns ns intros ls maplist pi zed zed bar ls intros ih fst fst coprime snd fst listof coprime ls fst snd listof coprime ls snd snd ls got refine coprime divides refine refine intros fst listof divides maplist snd listof zed divides ls ls refine refine refine refine refine refine succ refine refine refine appendix lego code relevant thesis refine refine pair refine refine refine zed divides ls zed divides cons ls intros refine immed refine refine refine refine refine refine refine refine refine refine refine refine intros refine immed refine zed divides ls zed divides cons ls intros refine immed refine equiv ls maplist maplist refine refine refine refine appendix lego code relevant thesis refine save 
return steps proof 
step case crt prop list zed zed xs list zed kronecker zed zed zed mod zed zed zed divides zip xs list zed zed xs list zed xs euclidean algorithm deliverable euclid del mn zed zed mn mn coprime zed zed unit mn zed zed ab zed zed mn mn ab ab euclid zed euclid void euclid zed euclid coprime euclid void top appendix lego code relevant thesis mrm zed zed zed mrm mrm mrm euclid remaining arithmetic list lemmas need zed coprime 
mod goal zed list zed zed list zed listof listof divides listof divides maplist zip intros refine list zed zed list zed list zed zed zed listof listof divides listof divides maplist immed intros immed intros immed intros fst listof snd listof listof divides refine pair refine refine immed refine immed save goal zed zed zed list zed zed listof listof op divides maplist pi zed zed listof zed zed divides intros refine list zed zed listof listof op divides maplist pi zed zed appendix lego code relevant thesis listof zed zed divides immed intros immed intros fst listof divides snd listof listof op divides maplist pi zed zed refine pair refine refine immed refine ih immed save resolve step case goal del univpred list zed zed refine intros ms maplist pi zed zed refine maplist zip intros fst ms snd ms refine pair refine list zed zed list zed list zed zed zed ms maplist pi zed zed matrix ms maplist immed intros appendix lego code relevant thesis refine matrix refine eq refine refine intros refine refine refine refine eq refine refine refine refine refine refine boring subscript checking refine refine refine save crt chinese remainder theorem january crt prop theorem list zed zed zed listof zed zed mod crt list zed zed ms maplist pi zed zed ms zed appendix lego code relevant thesis goal del univpred list zed zed refine intros xs refine xs intros fst snd refine list zed zed xs list zed list zed zed zed kronecker zed zed zed mod zed zed zed divides xs immed intros xs refine eq intros matrix refine pair equiv mod cons xs refine refine refine refine refine immed equiv listof zed zed mod cons xs refine matrix intros pq pq pq equiv mod cons xs appendix lego code relevant thesis refine refine refine refine save undischarged assumptions depends datatypes unit type void unit unit unit type void nat type zero nat succ nat nat nat type zero 
nat succ bool type tt bool ff bool bool type tt ff list type type nil type list cons type list list type list type nil 
list cons 
list ac ideal arithmetic zed coprime 
coprime coprime appendix lego code relevant thesis euclidean algorithm considered second order deliverable euclid del mn zed zed coprime mn mn zed zed unit mn ab zed zed mn ab mn ab zed coprime 
mod final composition stages proof 
steps pulled back trivial deliverable ensure correct matching types term 
goal del pcm univpred list zed zed refine refine save composedel composedel del pcm bibliography note lnm lncs refer series lecture notes mathematics respectively lecture notes computer science published springer verlag 
department computer science technical reports available lorraine edgar 
requests mail sent lme dcs ed ac uk 
lego available anonymous ftp 
ftp ftp dcs ed ac uk name anonymous password enter mail address cd export lego get readme read readme gives full details set system 
user manual ftp directory examples 
questions regarding lego directed randy pollack rap dcs ed ac uk 
aczel inductive definitions handbook mathematical logic ed 
barwise north holland amsterdam 
backhouse chisholm malcolm type theory notes international summer school constructive methods computer science marktoberdorf 
bibliography barendregt calculi types survey article handbook logic computer science eds 
abramsky gabbay maibaum oxford university press forthcoming 
bishop foundations constructive mathematics ergebnisse der mathematik und ihrer series springer verlag 
bell toposes local set theories oxford university press 
fibred categories foundations na category theory jsl 
berardi type dependence constructive mathematics ph thesis dipartimento di informatica torino italy 
bishop foundations constructive analysis mcgraw hill 
bohm berarducci automatic synthesis typed programs term algebras theoretical computer science vol 
northholland amsterdam 
joyal la logique des topos annals pure applied logic north holland 
de bruijn survey project automath 
burstall approach program specification development constructions talk workshop programming logic sweden may 
see discussion pp 

burstall mckinna deliverables approach program development constructions available university edinburgh technical report ecs lfcs 
bibliography church simple theory types journal symbolic logic vol 

constable implementing mathematics nuprl proof development system prentice hall new jersey 
constable fraser smith partial objects constructive type theory proceedings second lics symposium ieee 
coquand huet constructions higher order proof system mechanizing mathematics proceedings lncs springer verlag 
coquand huet theory constructions information computation vol 
nos 
academic press 
coquand metamathematical investigations calculus constructions 
coquand paulin mohring inductively defined types 
curien categorical combinators sequential algorithms functional programming pitman research notes theoretical computer science pitman london 
dijkstra guarded commands formal derivation programs communications acm vol 

dijkstra discipline programming prentice hall new jersey 
dijkstra selected writings computing springer verlag 
bibliography dijkstra scholten predicate calculus program semantics springer verlag 
categorical semantics constructions proceedings third lics symposium ieee 
feferman formal theories transfinite iterations generalised inductive definitions subsystems analysis intuitionism proof theory ed myhill north holland amsterdam 
fourman logic topoi handbook mathematical logic ed 
barwise north holland 
freyd scedrov categories allegories north holland amsterdam 
gardner representing logics type theory ph thesis university edinburgh 
geuvers church rosser property fij reduction typed calculi draft december 
girard interpretation fonctionelle elimination des coupures dans arithm etique de ordre sup erieure thesis university paris vii 
goguen luo inductive data types ordering types revisited manuscript submitted proceedings second workshop logical frameworks 
harper honsell plotkin framework defining logics journal acm appear 
bibliography harper milner tofte definition standard ml version technical report ecs lfcs lfcs dept computer science university edinburgh 
harper pollack type checking universes theoretical computer science vol 
north holland amsterdam 
hayashi adjunction categorical structures lambda calculus theoretical computer science vol 
north holland amsterdam 
hayashi att optimised curry howard isomorphism program extraction talk annual bra workshop logical frameworks antibes may 
hayashi singleton union intersection types program extraction proceedings tacs sendai japan springer lncs springer verlag 
hoare axiomatic basis computer programming communications acm vol 

hoare data refinement categorical setting draft oxford 
howard formulae types notion construction 
huet coquand paulin mohring calculus constructions version documentation user manual techniques projet inria rocquencourt paris august 
bibliography huet plotkin eds 
electronic proceedings annual bra workshop logical frameworks antibes may distributed electronically participating bra sites january 
hyland pitts theory constructions categorical semantics topos theoretic models proceedings ams conference categories computer science boulder colorado 
hyland robinson rosolini discrete objects effective topos proceedings london mathematical society vol 
pp jan 
ireland rosen classical modern number theory second edition springer graduate texts mathematics springer verlag 
jacobs categorical type theory university nijmegen 
johnstone topos theory academic press london 
johnstone pare eds indexed categories applications springer lnm springer verlag 
kock elementary toposes aarhus lecture notes aarhus denmark 
kreisel functions ordinals species logic philosophy methodology science iii eds 
van northholland amsterdam 
bibliography lambek scott higher order categorical logic cambridge studies advanced mathematics cambridge university press cambridge england 
lawvere adjointness foundations dialectica 
lawvere equality hyperdoctrines comprehension schema adjoint functor proceedings ams symposium applications category theory ams providence 
leivant reasoning functional programs complexity classes associated type disciplines proceedings th ieee symposium foundations computer science 
luo higher order calculus theory abstraction technical report ecs lfcs department computer science university edinburgh 
luo ecc extended calculus constructions proceedings fourth ieee conference logic computer science asilomar california 
luo extended calculus constructions ph thesis department computer science university edinburgh june 
luo problem adequacy conservativity calculus constructions higher order logic technical report ecs lfcs department computer science university edinburgh october 
luo program specification data refinement type theory technical report ecs lfcs department computer science university edinburgh january 
bibliography luo higher order calculus theory abstraction information computation vol 

luo unifying theory dependent types technical report department computer science university edinburgh 
luo pollack taylor lego preliminary user manual lfcs technical note lfcs tn october 
luo pollack lego proof development system user manual technical report ecs lfcs department computer science university edinburgh 
mckinna permutation manuscript edinburgh 
categories springer graduate texts mathematics springer verlag 
macqueen dependent types express modular structure proceedings popl 
martin lof intuitionistic theory types predicative part logic colloquium north holland amsterdam 
martin lof constructive mathematics computer programming proceedings conference logic philosophy methodology science vi north holland amsterdam 
martin lof intuitionistic type theory bibliopolis 
martin lof meaning logical constants justification logical laws technical report di logica matematica universita di siena 
bibliography mason hoare logic lf technical report ecs lfcs department computer science university edinburgh 
mendler logic design ph thesis university edinburgh forthcoming 
moggi partial calculus ph thesis university edinburgh available lfcs report ecs lfcs 
moggi category theoretic account program modules mathematical structures computer science vol cambridge university press 
barendregt barendsen dekkers geuvers jacobs lecture notes summer school calculus nijmegen 
dybjer nordstrom petersson smith editors proceedings workshop programming logic programming methodology group report university goteborg chalmers university technology may 
nordstrom petersson smith programming martin type theory oxford university press 
ore ecc extended inductive types draft edinburgh 
paulin mohring extracting programs proofs calculus constructions proceedings popl acm 
paulin mohring werner extracting executing programs developed inductive constructions system progress report 
bibliography pavlovic predicates fibrations university utrecht 
pitts categorical semantics dependent types talk sri international menlo park california june logic colloquium berlin 
pollack theory lego manuscript edinburgh 
pollack implicit syntax 
pollack implicit syntax draft summer school proof theory leeds uk july 
power algebraic formulation data refinement proceedings mfps tulane university louisiana springer lncs springer verlag 
prawitz natural deduction proof theoretic study almqvist wiksell stockholm 
reynolds types abstraction parametric polymorphism information processing ed 
mason north holland 
reynolds qing ming ma parametric polymorphism revisited lms symposium category theory computer science durham 
smith strength subset type type theory proceedings third lics symposium ieee 
bibliography information discharging retrieval martin type theory ph thesis institute informatics university oslo 
church rosser property lf fij reduction talk annual bra workshop logical frameworks antibes may 
church rosser property pure type systems fij reduction manuscript november 
sannella formal specification ml programs lfcs technical report ecs lfcs dept computer science university edinburgh 
sannella tarlecki formal development ml programs foundations methodology lfcs technical report ecs lfcs dept computer science university edinburgh 
scott constructive validity proceedings symposium automatic demonstration rennes springer lnm springer verlag 
scott identity existence intuitionistic logic proceedings lms symposium applications sheaves durham springer lnm springer verlag 
scott relating theories calculus 
seely hyperdoctrines natural deduction beck condition zeitschrift ur mathematische logik und grundlagen vol 

bibliography seely locally cartesian closed categories type theory mathematical proceedings cambridge philosophical society vol 

seldin hindley eds curry essays combinatory logic calculus formalism academic press 
combinators calculus proof theory reidel dordrecht 
streicher correctness completeness categorical semantics constructions thesis passau 
taylor diagrams tex available pt doc ic ac uk 
troelstra van dalen constructivism mathematics ii north holland amsterdam 
wadler theorems free proceedings fourth international conference functional programming languages computer architecture london acm 
