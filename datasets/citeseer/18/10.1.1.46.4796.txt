vldb journal deadlock detection distributed database systems new algorithm comparative performance analysis kemper ehud universit passau lehrstuhl informatik passau germany mail lastname db fmi uni passau de ben gurion university department math 
comp 
science beer israel mail ehud indigo bgu ac il edited mohan 
received december accepted february 
attempts comprehensive study deadlock detection distributed database systems 
predominant deadlock models systems different distributed deadlock detection approaches discussed 
new deadlock detection algorithm 
algorithm dynamically creating deadlock detection agents ddas responsible detecting deadlocks connected component global wait graph wfg 
dda scheme system initial warm phase dedicated ddas formed centers locality parts system conflicts occur 
dynamic shift locality distributed system responded automatically creating new ddas obsolete ones terminate 
compare competitive representative class algorithms suitable distributed database systems simulation model point relative strengths weaknesses 
extensive experiments carried indicate newly proposed deadlock detection algorithm outperforms algorithms vast majority configurations workloads contrast algorithms robust respect differing load access profiles 
key words distributed database systems deadlock detection comparative performance analysis simulation study decade computing systems undergone rapid development great impact distributed database systems 
commercial systems gradually maturing new challenges imposed world wide interconnection computer systems 
creates growing need large scale enterprise wide distributed solutions 
mariposa sal prototype system addressing demand 
distributed database systems support hundreds thousands sites millions clients face tremendous vldb journal springer verlag scalability challenges regard performance availability administration 
deadlocks arise database system permits concurrent execution transactions pessimistic synchronization schemes locking protocols case todays distributed database systems 
centralized database systems deadlock detection resolution thoroughly investigated acm 
deadlocks studied areas operating systems 
surveys earlier distributed deadlock detection distributed database systems elm sin 
surveys described different algorithms quantitative analysis terms benchmarking carried 
describe predominant deadlock models underlying locking database transaction synchronization 
different distributed deadlock detection approaches briefly surveyed timeout path pushing probing global state detection schemes representatives classes described 
reflect new developments new deadlock detection algorithm designed distributed object systems 
comprehensive simulation study different deadlock detection algorithms 
computational model transactions carried control transaction manager synchronization achieved phase locking scheme example semantic locking 
locking scheme entirely control object managers 
execution commit processing transactions controlled transaction managers 
proposed algorithm detects deadlocks dynamically creating deadlock detection agents ddas 
dda maintains part wait graph wfg searches cycles 
resource model underlying deadlock model database transactions cycle constitutes deadlock 
transactions start executing dda 
conflict transaction occurs transaction associated dda dda conflicting transactions associated dda exists newly created 
distributed deadlock detection transactions associated different ddas encounter conflict ddas merged single 
scheme guarantees real deadlocks detected main problems distributed deadlock detection algorithms face 
large scale distributed database system expect centers locality formed 
centers locality comprise transactions access compete objects 
dda scheme automatically establishes different ddas different centers locality decentralizing deadlock detection 
dda scheme self tuning system 
initial warm phase dedicated ddas established center locality 
shift system load encountered shift activity different time zones course day enterprise wide distributed system dda scheme adapts automatically 
new ddas created newly forming centers locality obsolete ddas eventually terminate 
order evaluate performance different schemes built simulation system chose implement representatives different classes algorithms efficient ones suitable distributed database systems 
implemented algorithms dda approach representative global state detection algorithms edge chasing algorithm described rb generates fewest messages cited path pushing algorithm system different timeout approaches :10.1.1.15.5632
rest organized follows 
sect 
outline underlying model computation 
section gives overview deadlock problem deadlock models mainly apply distributed database systems 
classification distributed algorithms models representatives different classes described sect 

sect 
new deadlock detection scheme 
performance comparison different algorithms reported sect 

section concludes 
model computation investigation distributed deadlock detection algorithms general distributed database model consisting collection sites transactions objects residing 
execution commit processing transactions controlled transaction managers tms objects controlled object managers oms 
om receives requests operation executions objects controls sent tms communicates objects answers back tms 
order simplify presentation loss generality assume tm om controls single transaction object respectively 
synonymously term transaction tm object om 
model object transaction unique identifier 
deadlock detection algorithms require total ordering transactions deadlock resolution assume transactions identifiers purpose determine youngest transaction 
transaction aborted restarted new identifier information regarding aborted restarted execution transaction distinguished possibly leading inconsistencies 
changing identifier alter ordering transactions old transaction youngest 
avoid system transaction associated timestamp additionally identifier indicating time entered system modified abort transaction ordering 
simplicity reasons rest identifiers ordering transactions assume contain timestamp 
transactions objects communicate asynchronous message passing 
transactions send tms requests objects oms turn send results back tms 
assume error free communication meaning message sent arrives finite time transmitted correctly 
assumption needed deadlock detection algorithms gather information messages 
messages get lost deadlocks detected 
systems guaranteed parts system connected unreliable network transactions set timeout abort expires 
similar done systems network communication www ftp 
timeout handle communication errors confused timeout approach detect transaction deadlocks 
communication timeout supposed handle rare cases message delivered set larger value timeout handling deadlocks 
phase locking protocol assumed 
phase tms request operation executions possibly different objects acquired locks maintained oms behalf holding transaction 
second phase tms initiate commit processing locks released 
transaction ti consists sequence opi opi 
operation invocations objects oj denotes additional parameters invocation 
corresponding tm requests execution operations strictly sequential order sends message object requesting invocation operation opi 
request object requesting execution opi sent tm receives requested invocation opi 
successfully executed 
transactions single threaded 
object manager receives requests operation invocations object schedules order fifo 
object manager maintains lock table compatibility matrix commutativity operation invocations maintained 
information om decides locks needed requested operation granted 
operation invocation delayed particular transaction execution blocked required distributed deadlock detection locks available 
locks granted om associates lock mode corresponding transaction invokes requested operation 
adopt semantic lock model ss kor flexible exclusive read write lock model 
exclusive lock model object accessed transaction time 
read write lock model contrast allows multiple readers hold locks object time writers need exclusive locks 
semantic lock model exploits semantics operations commutativity increase possible concurrency multiple transactions updating data item concurrently hold locks 
consider object bank consisting set accounts 
semantic locking transaction deposit acct transaction deposit money account releases corresponding lock 
possible deposit operations commute order execution irrelevant 
general deadlock problem vast majority modern database systems concurrency control locking mechanisms 
systems employ strict pl protocol gr 
locking protocols lead deadlocks 
deadlock permanent circular wait condition 
set transactions deadlocked iff transactions waits locks held transactions set bhg 
transactions set waiting state blocked unblocked interference outside 
different locking models concurrency control algorithms 
exclusive read write lock models transaction waiting lock granted wait transactions currently holding locks object 
semantic locking employed transaction may wait subset holders object 
different transactions blocked object may wait different subsets holders object 
handling deadlocks involves problems deadlock detection deadlock resolution 
dbms deadlock resolution means participating transactions victim chosen aborted resolving deadlock 
deadlock detection algorithm correct satisfies conditions deadlock eventually detected basic progress property detected deadlock really exists genuine deadlocks detected safety property 
condition intuitive second needs explained 
deadlock stable property due stale information possible deadlock detected resolved twice 
detected deadlocks really exist anymore called phantom deadlocks see ks 
argue algorithm detecting phantom deadlocks considered correct unnecessary transaction aborts expensive tolerable 
deadlock detection algorithm may detect phantom deadlocks spontaneous aborts permitted 
algorithm decides abort transaction order resolve deadlock time transaction involved deadlock aborts spontaneously resolving deadlock algorithm breaking phantom deadlock 
assume spontaneous aborts occur system 
wait graph blocking conditions transactions represented transaction wfg 
wfg directed graph nodes correspond transactions directed edge ti tj expresses ti waits resource currently held tj 
deadlock detected examining structure wfg 
graph structures indicate deadlock depends deadlock model applies described section 
different deadlock models depending computational model mainly types requests transactions different deadlock models apply 
distributed dbmss single resource model prevailing discussed 
descriptions models model general model common bo mc ks 
simplest widely model dbmss single resource model 
model transaction outstanding request time requests lock object waits granted requests lock object 
transaction outgoing request time may wait transaction 
erroneously concludes single resource model transaction wait transaction implying node wfg outgoing edge 
true exclusive locking model 
deadlock single resource model corresponds cycle wfg 
algorithms model declare deadlock cycle waiting transactions determined 
cycle resolved involved transactions aborted releasing locks 
numerous algorithms proposed model rbc bad sh mm ks 
algorithms described sect 

computational model transaction send request time wait granted deadlocks described resource model 
model applies instance systems supporting nested transactions transaction request locks objects simultaneously 
deadlock model indicated cycle wfg 
far see algorithms designed single resource model easily extended deadlock detection model transaction issue multiple requests time 
models distributed deadlock detection similar authors claim algorithms model computational model describe single resource rbc restrictions model basically reducing single resource model :10.1.1.15.5632
algorithm deadlock detection model lk clear deadlocks resolved algorithm 
algorithms especially designed dbmss supporting nested transactions 
distributed deadlock detection algorithms numerous deadlock detection algorithms developed distributed dbmss surveys elm sin 
focuses distributed algorithms single resource model 
classify distributed algorithms technique similar classification proposed explain different techniques describe representative class detail 
chose algorithms appear best class induce fewest number messages correct detect fewest phantom deadlocks class 
sect 
take look deadlock resolution strategies 
deadlock resolution deadlock resolution strategies determine transaction aborted order resolve deadlock 
resolution strategies proposed centralized systems 
compared acm simulation study centralized system 
results simulation conditions resolution strategy guarantee determined guaranteed transaction system finish guaranteed forward progress transaction aborted restarted indefinite number times indefinite restarts 
condition related basic progress property stated sect 

property guarantees deadlock exist forever ensure transaction finish 
ensured conditions guaranteeing transaction processing progress 
deadlock detection resolution algorithm achieve intuitively expected transaction enters system eventually finish deadlock detection correct fulfills conditions sect 
resolution strategy guarantees conditions 
obviously conditions hold distributed dbmss 
timeout approach algorithm transaction sets timeout time operation request 
receive operation executed successfully timeout expires assumes involved deadlock aborts 
algorithm simple easy implement 
cause network traffic due deadlock detection 
main disadvantage algorithm aborts transactions 
algorithm aborts transactions may deadlocked causing unnecessary roll backs restarts transactions 
disadvantage timeout interval tuned 
short transactions unnecessarily aborted long deadlocks persist system long time delaying transactions deadlock waiting locks held 
timeout interval chosen carefully difficult applications widely differing profiles running system 
usually set longer average execution time transaction bn hof 
bn said may desirable abort transactions transaction waits longer time timeout interval deadlocked indicates locking load high 
may true deadlock detection algorithm responsible scheduling 
drawback algorithm resolution strategy 
timeout scheme guarantee transaction finish transaction aborted indefinite number times 
particular load high long transactions chance get 
algorithm performs surprisingly distributed dbmss carefully tuned systems implemented simplicity bn 
alleviate drawbacks timeout approach systems oracle introduce deadlock detector site responsible detecting local deadlocks 
deadlocks involving local transactions resolved timeout 
classification distributed algorithms different distributed deadlock detection algorithms distributed dbmss published 
divided categories cf 
probe global state detection algorithms 
describe different classes algorithms summarize assumptions 
explained previous sections recall 
assumptions regard behavior transactions 
follow pl protocol spontaneously abort 
error free communication assumed meaning message reaches destination finite time received message correct 
course algorithms assume total ordering transactions choose victim resolve deadlock 
algorithms additional assumptions pointed algorithm description 
centralized dbmss performs poorly shown acm 
system transaction identifier purpose 
distributed deadlock detection path pushing algorithms path pushing algorithms explicitly maintain wfg 
site periodically collects local wait dependencies builds local wfg searches cycles resolves cycles detects 
parts rest wfg sent neighboring sites 
incorporate received wait dependencies local wfg search cycles 
site passes parts wfg sites 
interesting observe published path pushing algorithms turned incorrect 
detect phantom deadlocks algorithms fail detect real ones 
example counterexample algorithm mm gs 
obermarck algorithm algorithm obermarck implemented system wdh optimizes path pushing strategy sending part possible cycle path site case transaction path higher priority :10.1.1.15.5632:10.1.1.15.5632
reduces number messages half 
despite optimization algorithm imposes significant overhead performs deadlock detection 
done periodically wfg searched cycles 
additionally paths sent sites identified 
incorporating newly arrived paths site implies previous information received site exchanged wfg new information 
elm stated algorithm detects phantom deadlocks parts wfg sent sites belong asynchronously taken snapshots inconsistent 
snapshots taken synchronously algorithm detect false deadlocks inconsistencies arise due breaking cycles algorithm 
probe algorithms probe algorithms explicitly maintain wfg send special kind messages probes edges wfg 
kinds probe algorithms edge chasing diffusing computation 
edge chasing algorithms transaction ti requests operation execution object blocked wait locks held transactions probe sent transactions ti initiates probe computation 
blocked transaction receives probe forward deadlock detection done continuously checked new edge created cycle 
transactions holding locks waits 
probe initiated ti returns ti probe traversed cycle constitutes deadlock 
transaction requested operation execution know blocked operation currently processed 
blocked know transactions waits 
objects information fact send initiation probe behalf blocked transaction 
reasons transaction forwards probes object waits object sends probes appropriate transactions 
numerous edge chasing algorithms developed cm rbc sn sh ks lk turned incorrect see rbc ks 
describe algorithm rbc rb rb improvement cm sn 
algorithm induce amount messages detects fewer phantom deadlocks algorithms class 
handle semantic locking algorithms sn handle exclusive locking 
algorithm order reduce message traffic algorithm objects forward probes transactions identifier lower initiator probe 
probes sent transactions lower identifier called antagonistic probes 
strategy sending antagonistic probes reduces number messages additionally assures cycle detected 
probe initiated transaction highest identifier forwarded cycle 
reduce number probe transactions objects store probes receive order forward dependency occurs time 
necessary order avoid periodical re initiation deadlock detection drastically increase number messages 
stored probes incur performance penalty 
removed deadlock detected order bring wfg back consistent state 
object detecting antagonistic edge ceased exist send antagonistic probe arrived edge corresponding disappearing dependency 
mimics behavior probe follows paths cleans wfg 
sending reduces eliminate likelihood detecting phantom deadlocks rb 
probe may pass edge ceased exist deletes detecting phantom deadlock 
algorithm designed single resource model 
additional assumption messages arrive order sent 
identifiers denote priority transaction 
distributed deadlock detection diffusing computation algorithms class transaction starts diffusing computation ds cha wait lock 
deadlock indicated computation terminates 
node directed graph starts diffusing computation sending messages successors 
receiving message node send messages successors 
order determine diffusing computation terminates nodes receive signals successors send signals predecessor ds cha 
signals receives initiator decide deadlocked 
diffusing computation overkill detection single resource model deadlocks 
models deadlock indicated probe returns initiator induces overhead diffusing computation 
algorithms diffusing computation ks ks mc usually designed complex deadlock models edge chasing algorithms 
global state detection main problem distributed deadlock detection algorithms encounter information may stale inconsistent leading detection phantom deadlocks 
avoid global state detection algorithms try obtain consistent snapshot wfg search deadlocks 
cl algorithm online obtains consistent snapshot system 
algorithm detection generalized deadlocks snapshots bt 
algorithm generalized model cdas 
approach appears inefficient blocked transaction initiates deadlock detection process 
algorithm model esl 
algorithm tm tmi full control transactions connected component wfg ti additionally manage objects transactions accessed 
tmi maintain corresponding part wfg search cycles 
component splits components tmi pass control component part tm new component 
note split wfg means wfg split sets objects accessed transactions different components disjunctive 
algorithm assumes synchronous communication transaction wants request object wait object ready receive 
despite unrealistic simplification algorithm incurs severe overhead 
requests operation executions object transaction holds lock forwarded local request go distant site 
tm take charge tm conflict access object 
sect 
new global state detection algorithm 
algorithm creates agents objects oms report wait dependencies transactions agents perform deadlock detection 
different agents responsible different parts wfg different connected components wfg consistent snapshot 
algorithm easy integrate system deals asynchronous message passing depend correct message ordering 
deadlock detection agents ddas main idea algorithm distribute information global wfg different agents called ddas way cycle graph dda having complete information 
cycle belongs connected component global wfg connected component eventually dda responsible detecting cycles 
achieved allowing transactions associated dda 
dda detects deadlocks transaction involved deadlock detected twice inherent problem algorithms distributed deadlock detection encounter 
guaranteeing node wfg dda having outgoing edges node part graph algorithm avoids detecting phantom deadlocks 
explained detail sect 

dda information connected component responsible reduce number transactions aborted deliberately choosing victim 
emergence new connected component leads creation new dda 
case connected components wfg join component corresponding ddas merged part global wfg dda responsible disappears dda terminates 
algorithm single resource model 
show extend model 
dda scheme require particular lock model assumes component reporting dependency dda 
large scale distributed database system different types transactions access different groups objects creating centers locality 
dependencies arise transactions belonging center building connected components wfg 
initial warm phase dedicated ddas centers locality formed 
due commits aborts transactions connected component split different connected components 
case corresponding dda responsible cycle detection components 
connected components belong center locality soon merge connected component 
connected components split access profile system shifted new centers locality emerge new dda automatically emerge previous dda eventually terminate 
dda scheme combines advantages distributed deadlock detection algorithms load distribution local distributed deadlock detection ization deadlock detection vicinity involved transactions global view parts wfg centralized scheme getting best worlds 
avoids detecting phantom deadlocks despite distribution 
dynamically adjust system load particular automatically adjusts shifts system hot spots forming new ddas vicinity 
algorithm additional assumptions described sect 
pl error free message transmission spontaneous aborts transactions 
deadlock resolution total ordering transactions needed 
dda creation proposed algorithm dynamically creates ddas needed 
deadlock occur exists conflicting lock object 
long conflicting lock requests dependencies accessing transactions dda needed 
lock management underlying model done objects object managers responsible creation ddas 
transaction requests operation object transaction holds lock conflicts required requested operation dda needed 
object knowledge dda involved transactions associated new dda created 
object creates passes dependencies 
involved transactions associated dda 
associated dda means transaction sent identifier dda operation requests transaction contain identifier dda 
object created dda records association transaction dda 
example shown fig 

holding non conflicting locks transactions associated dda 
associated dda requires lock conflicting locks held denoted dashed arrows 
dependencies arise 
creates dda passes dependencies 
object records association transactions 
created sends message new transactions associated 
receiving message send identifier operation requests 
transaction request conflicts set locks granted requesting transaction transactions holding locks dda object knows dda created 
dda dependencies reported transactions associated dda 
case transactions different ddas merged described section 
dda unique identifier total ordering identifiers needed 
kind identifiers transactions employed 
dda op request fig 

creation dda dda merger dda create dda set dda set dda set dda conflicting lock request create dependencies lead join connected components wfg component 
case ddas responsible components merged 
initiation merge explained 
merging ddas described merging ddas done analogously 
ddas merged dda higher identifier younger refer dy merged older lower identifier 
denote older dda 
receiving request merge dy sends information 
includes dependencies dy received far list ddas previously merged administrative information 
dy records identifier passive 
means dy forward information relevant deadlock detection receives 
way messages sent dy processed 
receives merging message sent dy adds received dependencies part wfg checking cycles 
adds information got information 
sends message transactions responsible merger associated 
additionally message sent dda previously merged dy informing forward dy 
note done efficiency reasons prevent building forward chains ddas 
impact correctness algorithm dy forwards information gets anyway 
example fig 

example responsible associated 
obvious merged dependencies know belong connected component wfg 
receives request merge step sends information 
second step informs dda changed third step requests change forwards 
note transactions informed merging ddas 
implies know current dda get know finite time objects may refer dda merged distributed deadlock detection fig 

merging ddas new 
due forwarding messages result loss information 
initiation merge merge ddas initiated object transaction 
possible different transactions involved conflict object different ddas 
means conflict caused join connected components wfg corresponding ddas merged 
object chooses dda report dependencies initiates merging ddas involved chosen 
merge initiated sending list ddas merged dependencies 
chosen dda sends merge request message ddas 
object chooses dda lowest identifier oldest 
oldest chosen order avoid infinite number merges 
case requesting transaction dda different oldest dependencies sent indirectly dda requesting transaction 
message contains merge request information dda merge older dda 
transaction wait object sending dependencies dda requesting transaction algorithm guarantees point time dda outgoing edges node wfg corresponding transaction 
shown sect 
sufficient order avoid detection phantom deadlocks 
merging ddas initiated transaction 
example shown fig 

transaction associated accessed object associated dda object information 
conflict involving arises object decide send dependencies information associated dda 
dependencies sent 
receiving dependencies send message informing associated 
receives message notice dependencies involved 
initiate merging 
message flow induced example shown fig 

fig 

transaction initiates merging fig 

messages sent merge initiation transaction transaction associated new dda immediately initiated merging previous dda new 
happens new dda confirms merge sending set merge dda message transaction 
transaction stays associated old dda 
transaction immediately changed dda happen new dda receives information transaction waits transactions previous dda merged 
result active ddas having outgoing edges transaction node possibly lead detection phantom deadlocks 
deadlock resolution dda starts deadlock detection time receives new dependencies performs continuous detection 
dependencies object sends dda consist transaction waiting set transactions 
waiting transaction member cycles currently ex distributed deadlock detection part wfg dda responsible 
deadlock detection involves depth search starting waiting transaction 
cycle dda resolves 
currently done choosing youngest transaction cycle aborted cycle 
cycle arisen new dependencies transaction wait dependencies newly arrived aborted cycles get resolved 
dda complete information cycles part graph deadlock resolution strategy easily integrated algorithm 
note clear advantage deadlock detection algorithms 
apart objects dda learn new dependencies dda merging 
currently algorithm runs depth search starting new node treating new node outgoing edges new dependencies 
easily replaced better strategy 
explained sect 
efficiency reasons dda records transactions aborted knows committed 
dda termination simplest possibility dda terminates received message long period time timeout 
current system implemented version ddas needed cause overhead 
alternative dda terminates transactions part wfg terminated 
possibility dda collects additional information part graph transactions belong part graph dda know 
needed information provided transactions part message transaction sends dda termination 
information processed active ddas request obsolete ddas dissolve 
data structures pseudo code deadlock detection deadlock detection object structure augmented list transactions accessing ddas transactions associated 
course transaction needs know dda 
explained previous section transaction initiates merge current dda new waits confirmation merge associated new dda 
stores 
messages ddas transaction arrive different order sent 
transaction receive message merged learnt responsible 
order avoid unnecessary forwards messages transaction stores set merge dda messages dda merges information contain 
describe structure dda shown fig 

ta list tk wfg fig 

dda structure forw addr dda list term tas dj dda object having special attributes ta list wfg forw addr dda list term tas 
ta list list transactions dda currently responsible 
wfg information maintained wfg structure 
passive dda forw addr contains address dda dda merged 
dda maintains ddas merged dda list 
ddas forward messages 
dependencies involving transaction may received terminated 
avoid adding transaction wfg dda keeps track transactions terminated aborted knows committed term tas 
information needed efficiency reasons avoid unnecessary set dda set merge dda messages keep smaller 
note done algorithms explicitly maintaining wfg 
code objects change objects code case lock needed operation execution requested transaction granted 
case object determine dda send dependencies 
operation request transaction tj received receive operation request lock granted lock conflict locks held tn determine dda create new dda send dependencies ddas merged dda determined dda update ta dda association list fi determining dda done follows 
tj associated dda chosen 
object chooses dda lowest identifier set ddas transactions tn associated tj associated dda 
possible transactions tn tj associated different ddas 
causes merge ddas lowest identifier 
note dependencies list ddas merged sent dda tj extension algorithm model aborted transactions recorded term tas order prevent detection phantom deadlocks 
transactions tn may conflict perform read object different ddas 
distributed deadlock detection 
dda merged dda message contains merge request 
object relies information transactions associated ddas determines dda 
information stale lead additional overhead creating dda needed lead incorrectness loss information transactions recognize unnecessary creation request merging ddas 
object finished execution operation sends requesting transaction 
described earlier message contains dda transaction transaction sent request transaction dda cause dependencies object sent dependencies 
object initiated merge ddas transaction learn dda object 
code transactions messages may arrive order sent set merge dda set dda messages sent different ddas transaction may arrive wrong order 
transaction deals storing information received set merge dda messages dda merges 
transaction tj requests operation object oi operation request send operation request oi dda tj receive operation ack dda new case operation request contained dda return operation ack contain dda return default proceed receive set dda update dda operation request contained dda object sends dependencies transaction wait dda returns identifier transaction 
information new transaction transaction may information dda merged dda 
ignores 
case transaction dda requesting operation checks initiate merge receive set dda 
case associated different dda waiting operation ack 
order guarantee dda outgoing edges tj part wfg transaction associated dda got object initiated merging dda 
transaction stays associated dda receives message merge accomplished 
tj may information dda merges receiving operation ack 
transaction tj receives set dda dda new receive set dda dda new case dda associated dda dda dda new dda new dda dda new knew return dda new initiate merging needed update dda identifier stored dda transaction associated associated waits message previous dda merged 
transaction wait order guarantee dda outgoing edges node tj 
reduce unnecessary forwards transaction uses dda merge 
case transaction tj checks dda merges dda new merged dda dn 
tj initiates merging dn dda new dn exist 
course merging needed dn dda new case dn equals 
transaction tj receives set merge dda dda new dda merged receive set merge dda dda new dda merged insert received information dda merges dda associated dda dda dda new dda new return fi dda new dda new fi update dda considering dda merges dda merged dda merged dda new 
represents oldest dda tj knows associated case dda new older updated 
dda updated dda new dda dda new merged 
code ddas dda merged dda passive forwards messages receives forward change forward 
consider active ddas 
dda dj receives message object containing list dependencies list ddas merged possibly merge request receive dependencies dependencies list ddas merge request filter dependencies involving transactions contained term tas add dependencies wfg update ta list send set dda self new transactions message contain merge request send merge request self new ddas distributed deadlock detection received list check cycles wfg message contains merge request dda merge send merge request dda merge new ddas received list merge dda merge fi dependencies sent dda blocked transaction 
object knows dda lower identifier transaction involved initiates merge adding merge request message 
list ddas merged sent dependencies 
dj requests ddas list merge dda merge 
course message needs sent ddas merged dj 
dda receives merge request dda new receive merge request dda new id dda new merge dda new id dda new send merge request dda new fi fi case identifier dda receiving message smaller identifier dda new arise due forwarding messages 
happens receiving dda sends merge request message dda new 
dda receives merge message receive merge wfg ta list dda list term tas update ta list wfg received term tas filter received information involving transactions contained term tas send set merge dda transactions received ta list update ta list send change forward ddas received dda list append list sender dda list add received wfg wfg append received term tas term tas check cycles wfg correctness issues deadlock detection algorithm correct deadlocks occur system detected finite time detected deadlocks really exist time detection see sect 

section argue dda algorithm correct assumptions 
assume message passing error free messages sent arrive finite time correct 
assumption existing dependency ti tj ceases exist transaction tj commits aborts 
assumptions proof wuu bernstein wb applicable saying cycle global wfg indicates deadlock system 
implies deadlock permanent deadlock resolved interference outside 
case true deadlock detection algorithm may detect phantom deadlocks may detect cycle spontaneously resolved 
course aborts behalf deadlock detection algorithm considered spontaneous aborts 
deadlocks detected observation 
outgoing edges node maintained dda 
observation follows construction algorithm 
outgoing edges transaction arise iff transaction waits locks object 
reported dda waiting transaction learns dda lock requests 
implies transaction waits time object knows dda responsible sends dda identifier lock request 
objects transaction waits point time send dependencies represent outgoing edges corresponding wfg node dda 
younger dda dy transaction associated merges older dda transaction associated previous dda dy inactive 
point time ddas contains outgoing edges corresponding node wfg 
merging previous dda dy forwards dependencies receives information lost 
observation 
ti node involved cycle tj ti global wfg 
point time incoming edge ti involved cycle part wfg dda having outgoing edges ti part graph 
observation follows outgoing edges ti dda say dc 
ti information associated dc dda merged dc 
involved cycle edge tj ti global wfg part cycle 
dependency represented edge recognized object sent dda 
sent dc proved 
sent dda dda inform ti dda 
ti recognize ddas initiate merging eventually single dda edge tj ti outgoing edges ti part wfg 
observation 
deadlocks system detected resolved finite time 
tn constitute cycle global wfg 
observation follows point time dda having outgoing edges edge tn part wfg 
particularly true edge dda contain outgoing edges observation particular edge 
continuing lead point time edges involved distributed deadlock detection 


fig 

cycle overlaps cycle part wfg dda 
note ddas merge direction dda lower identifier eventually process terminate 
dda starts deadlock detection time receives new dependencies cycle detected resolved edge completing cycle reaches dda 
deadlock represented cycle graph deadlock detected resolved 
phantom deadlock detection showing phantom deadlocks detected analyze lead detection 
assumptions deadlock resolved spontaneously cycle global wfg indicates deadlock system 
possibilities phantom deadlock detected deadlock detected different ddas resolving deadlock deadlock gets resolved appropriate dda noticing 
cycle detected dda dependency reported dda dda knowledge long dda active 
dda merges dda sends dependencies dda dda 
edge chasing algorithms true cycle detected 
problem arises cycles common node shown fig 

transaction largest identifier right hand left hand cycle happen 
probe sent behalf passes chosen victim resolve left hand cycle 
resolving left hand cycle aborted break right hand cycle exist due aborting 
inherent problem edge chasing algorithms reported rb 
problem happen dda scheme 
dda aborts transaction resolve cycle removes edges corresponding node involved 
particular removes outgoing edges node 
dda outgoing edges node observation transaction involved cycle cycles removed graph wrong deadlock detection possible 
order reduce number aborts due deadlocks dda scheme employs heuristics 
transaction closing cycle involved deadlock transaction chosen victim 
heuristics employed edge chasing approach 
reasons edge chasing algorithms expected induce aborts 
inherently detect phantom deadlocks 
secondly deliberately choose transactions involved cycles 
observation backed simulation results section 
extension model dda approach easily extended detect deadlocks model transaction issue multiple requests parallel 
reason algorithm sufficient model multiple requests transaction lead dda responsible 
consider transaction having dda time requests 
objects dependencies arise objects send different ddas create ddas 
lead detection phantom deadlocks ddas search cycles involved 
note problem occur dda request ddas properly merge start looking cycles 
avoid problem model algorithm extended follows 
transaction gets dummy dda assigned starts execution 
objects treat dummy dda way normal difference dummy dda instantiated receives message dependency involving transaction arises 
transaction dda sends identifier request phantom deadlocks detected 
comparative performance evaluation distributed deadlock detection algorithms proposed quantitative comparisons schemes database systems exist 
acm concentrated simulation study various deadlock handling deadlock avoidance algorithms centralized database system 
cho compares algorithm algorithm combines path pushing approach 
buk presents comparison centralized distributed approach 
algorithms timeout approach compared 
section results comprehensive simulation study compares distributed deadlock detection algorithms different classes 
algorithms analyzed dda scheme representative global state detection path pushing algorithm obermarck edge chasing algorithm rb various timeout approaches :10.1.1.15.5632:10.1.1.15.5632
algorithms cover different classes distributed deadlock detection algorithms diffusing computation category 
described sect 
diffusing algorithms competitive restricted computational models underlying database transactions 
deadlocks occurring single resource model detected effectively inherently expensive algorithms edge chasing algorithms 
simulation model simulation model distributed database system consists arbitrary simulation run fixed number sites 
site time shared cpu server point time autonomously operating entity object transaction deadlock detector active site 
site responsible properly scheduling entities located 
scheduled come basis 
system models network latency messages sent entity take different time depending distance locations 
messages sent lan take time messages sent distant sites 
simplicity omitted modeling servers 
believe impact performance deadlock detection algorithms equally influence throughput response time achieved different algorithms 
account delays thinking time incorporated duration operation execution 
having transactions enter system arbitrary points time started number transactions simulation run system preserved number active transactions multiprogramming level mpl simulation 
measuring cold start system run warm phase started record transaction processing 
completing warm phase recorded commits analyzed results 
warm phase intended bring system stable operational condition 
turned different algorithms reach stable condition vastly different intervals 
real detection algorithms reach quite soon timeout approaches sensitive prolonged high load runs 
report experiments demonstrate effect 
transaction initiated processor sends operation request object wants access 
lock needed operation granted object acknowledges operation sending message transaction 
receiving message transaction send operation request 
case lock granted object manager takes actions depending deadlock detection strategy 
edge chasing algorithm object manager generates probe dda approach employed dependencies sent dda dda created 
case path pushing algorithm timeout schemes object manager sends dependencies local deadlock detector 
transaction executed operation requests chosen victim deadlock detection starts commit abort sending appropriate messages objects accessed 
aborted transaction restarted restart delay 
delay varies different experiments depending transaction mix fix experiment 
committed transaction new started random site order maintain constant mpl number active transactions 
transaction started chosen transaction mix specified experiment 
implementation algorithms implementations edge chasing dda approaches straightforward described previous sections adaptation computational model needed 
timeout approach transactions changed transaction sets timeout time requests operation execution object 
operation execution acknowledged timeout expires transaction aborts restarted restart delay 
refer algorithm pure timeout algorithm 
timeout approach augmented local deadlock detector site called timeout detection algorithm 
pure timeout approach transaction sets timeout requests operation execution aborts arrive timeout expires 
additionally object sends dependencies local deadlock detector dependencies occur 
detectors search cycles local wfg resolve deadlocks detect victim releases locks faster 
path pushing algorithm adapted computational model 
algorithm transaction starts execution site 
wants access data located site transaction creates agent site exist performs request 
agents transaction correlated unique transaction identifier 
algorithm assumes transaction agent created site local deadlock detector automatically knows 
assumes detector knows site agent sent request site moved activity 
implementation really move transaction informed detectors transaction current locus control 
transaction moves activity site inform remote deadlock detector sending message 
transaction send message current local detector 
investigated cost adaptation charging corresponding messages counting letting arrive immediately 
means request cost costs algorithms quite fair algorithm needs additional information obtained costs 
modest increase number messages minimal impact results 
algorithm overhead dominated handling wfg costs sending messages informing deadlock detectors current locus control turned negligible 
system transactions access objects sites parts distributed deadlock detection wfg sent grow tremendously takes long time construct messages sent receiver unpack 
edge sent times part different paths relatively small graphs overhead considerable 
important difference algorithm ones explicitly maintaining wfg scheme periodically exchanges parts wfg algorithms continuously update 
performance experiments ran number experiments order study performance algorithms different loads 
scenario generated load fairly short transactions relatively homogeneous system representing lan 
environment analyzed impact timeout value performance timeout algorithms 
behavior different algorithms load change behavior time studied 
performance algorithms analyzed scenarios 
second scenario environment typical load introduced mix short small number long transactions 
third scenario represents wan consisting lans 
performance measures obtained experiments number messages restart ratio throughput response time 
restart ratio defined number aborts relative number transactions executed 
throughput measured number committed transactions millisecond response time time transactions stay system time moment transaction started commit 
simulation parameters experiments fig 

number objects simulation runs relatively small larger object bases lead conflicts fewer deadlocks behavior algorithms investigated 
pointed acm important analyze behavior algorithms workloads high conflict probabilities order evaluate performance hot spots exist database 
synchronization semantic locking 
objects type having operations compatibility matrix shown fig 

mpl experiments varies depending load 
ranges experiments short transactions run experiments small percentage long transactions added system varies 
transaction size number accesses transaction performs introduce different types transactions study realistic load profiles 
size ranges average size accesses relatively short size representing long transactions 
likelihood access local varies different transaction types 
actual size 
sites 
objects mpl operation execution milliseconds undo operation milliseconds commit operation milliseconds message delay local milliseconds message delay lan milliseconds message delay remote wan milliseconds receiving sending message milliseconds cycle detection dda timeout detection milliseconds merging ddas fig 

simulation parameter setting milliseconds op op op op op op op op fig 

compatibility matrix transactions probability request local specified experiment separately 
system parameters message delays cycle detection measurements local area network 
parameters parameter settings simulation studies buk cho estimate average realistic values 
path pushing algorithm costs handling wfg experimentally derived 
schemes explicitly maintaining wfg dda timeout detection continuously update wfg search cycles 
insert new edges check edges lead cycle wfg acyclic update 
path pushing algorithm periodically updates wfg periodically searches cycles 
time site sends paths interest site search wfg potential cycles sent 
receiving site exchange old newly arrived information 
time consumption operations strongly depends size graph give estimate calculate actual costs anew time 
costs performing deadlock detection algorithm include building wfg incorporating local received dependencies analyzing 
analyzing wfg means finding cycles identifying paths sent deadlock detectors 
simulation system costs total ms edge paths detector received 
cost measure derived performance experiments conducted sun sparcstation processor 
path pushing algorithm sensitive variation length interval starts periodic deadlock detection 
tuned length interval running simulations different values 
done different scenarios 
generally results report constitute averages simulation runs 
number simulation runs experiment depends variation results 
stan distributed deadlock detection average transaction size range transaction size timeout values interval path pushing restart delay transaction type likelihood lock requested local share type transaction type likelihood lock requested local share type fig 

additional simulation parameters scenario throughput tas ms pure timeout pure timeout pure timeout timeout detection timeout detection timeout detection multiprogramming level fig 

throughput different timeout intervals dard deviations recorded results shown graphs 
scenario short transactions lan scenario compare different algorithms system load consists short transactions done simulation studies cho buk acm 
realistic scenario highly distributed system represents part typical load helps understanding algorithms 
parameters simulation fig 

operation execution requests transactions local introduced types transactions making local requests making local requests randomly chosen objects system 
adjusting timeout interval varied values timeout interval order determine optimal value 
described acm optimal timeout interval depends workload mpl 
short long timeout durations lead performance degradation 
small value leads restarts large timeout interval degrades performance deadlocks stay system long 
throughput tas ms warm phase mpl window size dda obermarck pure timeout timeout detection commits fig 

behavior time mpl fig 
demonstrates variations throughput induced different intervals 
optimal value timeout detection algorithm decreasing value significantly reduces performance 
small mpls system load low deadlocks rare algorithm performs short timeout interval higher load causes restarts 
timeout interval long set leads congestion system 
pure timeout algorithm performs significantly worse timeout detection algorithm scenario timeout intervals 
low mpls optimal timeout interval high mpls throughput drops achieved interval mpls obtain results short interval 
interval length best value low mpls optimal 
timeout interval performs poorly mpl due congestion system imposes 
warm phase commits experiment shows timeout approaches achieve best throughput 
prolonged system operation high load simulation experiment investigates changes algorithms performance time relatively high load 
figs 
show behavior algorithms time mpls respectively starting cold system 
point graph represents throughput achieved commits 
mpls real detection algorithms stable fast timeout approaches reach stable state 
problem pure timeout approach encounters resolution strategy aborts transactions creating problems 
timeout detection algorithm partly alleviates problem truly resolving local deadlocks 
number transactions try execute operations need conflicting locks high standard deviation path pushing algorithm explained distributed deadlock detection throughput tas ms warm phase mpl window size fig 

behavior time mpl throughput tas ms commits dda obermarck pure timeout timeout detection dda obermarck pure timeout timeout detection multiprogramming level fig 

throughput warm phase resolution strategy guarantees finish reducing congestion 
timeout approaches accumulate problematic situations time progress possible 
pure timeout algorithm degrades fast 
timeout detection algorithm maintains surprisingly high throughput level long time mpl throughput tas ms dda obermarck pure timeout timeout detection multiprogramming level fig 

throughput warm phase degenerates low throughput 
note relatively high locality transactions favorable algorithm 
throughput real deadlock detection algorithms decrease time systematically resolve occurring problems allowing stay system forever 
costs problem solving reason timeout algorithms perform better price high throughput low throughput 
variation mpl throughput results algorithms short warmup phase commits long warm phase commits summarized figs 
respectively 
measured results fig 
mpls correspond left vertical lines figs 
results shown fig 
correspond right vertical lines 
timeout approaches previously measured optimal timeout values considered 
expected figs 
real deadlock detection schemes achieve approximately throughput long short warm phase 
timeout approaches lower throughput longer warm phase reasons explained 
circled value fig 
shows result timeout detection algorithm far obtain 
simulation runs ran hours fastest machines sun making progress 
mpls obtain results 
long warm phase dda performs better algorithms demonstrated fig 

results algorithms achieved warm phase discussed additional results measured long warm phase omitted convey new information 
low mpls conflicts rare algorithms perform alike pure timeout approach unnecessarily aborts transactions performs poorly 
load ideal timeout detection algorithm 
deadlocks local detected local deadlock detector algorithm resolves deadlocks faster distributed algorithms 
high mpls tuned timeout value short warm phase timeout detection algorithm performs better algorithms 
dda outperforms algorithms short warm phase edge chasing path pushing pure timeout approach 
reason poor performance pure timeout approach explained previously results achieved edge chasing path pushing algorithms discussed 
pointed previous rb performance distributed deadlock detection algorithms strongly depends number messages induce 
increase system load number messages edge chasing algorithm generates grows drastically see fig 
leading decrease throughput 
distributed deadlock detection messages dda obermarck pure timeout timeout detection multiprogramming level fig 

number messages warm phase response time ms ta dda obermarck pure timeout timeout detection multiprogramming level fig 

response time warm phase obermarck path pushing algorithm appears robust edge chasing algorithm lower mpls completely deteriorates higher mpls 
simulation runs mpl exceeded computing facilities chance getting done finish required transactions 
turned path pushing algorithm sensitive degeneration wfg meaning wfg large lots cycles 
unfortunately situation occurred randomly number simulation runs 
reason high standard deviation simulation results algorithm 
number messages induced dda approach significantly increase growing mpl 
reason high mpls dependency sent object dda 
course merges mpl higher centers locality built 
merging induce high message traffic 
apart throughput number messages sent simulation measured response time transactions 
huge number messages edge chasing algorithm induces time algorithm spends constructing wfg searching cycles increases response time transac restart ratio dda obermarck pure timeout timeout detection multiprogramming level fig 

restart ratio warm phase tions see fig 

response time achieved dda algorithm shorter path pushing edge chasing algorithms longer timeout approaches 
note response times committed transactions considered 
favors timeout schemes transactions staying system long time finished problematic transactions aborted included measurements 
restart ratio different algorithms expect see fig 

dda detect phantom deadlocks aborts transactions algorithms differences experiment significant 
scenario mix transactions lan scenario examine behavior algorithms environment realistic transaction mix 
additional simulation parameters fig 

load experiment consists types transactions relatively short transactions accessing local objects transactions twice length accessing local objects probability remote ones long transactions accessing randomly chosen objects 
throughput mix transactions induces heavier load system case scenario maximum throughput lower obtained lower mpl 
reason longer transactions hold locks long period time transactions waiting locks stay longer system short conflicts deadlocks occur 
due higher load system stabilizes faster 
fig 
demonstrates mpl 
leads small standard deviation measurements cases visible graphs 
obermarck distributed deadlock detection timeout value interval path pushing restart delay transaction type average transaction size range transaction size likelihood lock requested local share type transaction type average transaction size range transaction size likelihood lock requested local share type transaction type transaction size access pattern random share type fig 

additional simulation parameters scenario throughput tas ms warm phase mpl window size fig 

behavior time mpl commits dda pure timeout timeout detection path pushing algorithm obtain results mpl algorithm induced enormous overhead exceeding computing facilities 
scenario dda scheme outperforms algorithms see fig 

lower mpls edge chasing algorithm performs dda scheme number probes sent large 
increasing mpl number messages sent algorithm drastically grows compared dda scheme throughput degrades 
mpl dda achieves throughput higher edge chasing algorithm cf 
figs 

mpl dda achieves mpl higher throughput edge chasing algorithm 
timeout approaches perform poorly accumulate problems scenario faster 
mpl dda performs better timeout detection algorithm cf 
fig 

mpl leads higher throughput dda compared timeout detection algorithm cf 
fig 

considering results warm phase commits experiment 
throughput tas ms dda obermarck pure timeout timeout detection multiprogramming level fig 

throughput warm phase messages fig 

number messages dda obermarck pure timeout timeout detection multiprogramming level scenario locality transactions high previous deadlocks involve objects sites leading equal performance pure timeout timeout detection algorithms 
path pushing algorithm obermarck achieves low throughput low mpls 
explained algorithm sensitive large mpls obtain results 
reason poor performance edge chasing algorithm induces high overhead sending large number probes see fig 

timeout approaches send messages due enormous number aborted transactions explained 
timeout detection algorithm sends messages pure timeout algorithm additional deadlock detection messages sent 
timeout approaches favor short transactions long ones seen figs 

fig 
shows average response time operation transaction types 
response time milliseconds operation wide range transactions lengths 
dda achieves best response time 
edge chasing algorithm poor response time large number probes induces 
response times timeout approaches long distributed deadlock detection response time ms operation dda obermarck pure timeout timeout detection fig 

response time transactions response time ms ta multiprogramming level dda obermarck pure timeout timeout detection multiprogramming level fig 

response time short transactions vantage long transactions 
evident response times transactions different types examined separately 
transactions type relatively short transactions timeout algorithms achieve better response times edge chasing algorithm dda scheme 
fig 
shows response times transactions type 
type long transactions timeout algorithms achieve poor response time see fig 
transactions aborted 
true dda edge chasing algorithm favor old short transactions order guarantee forward progress transaction types 
note committed transactions considered transactions system long time committed included results favors timeout approaches 
restart ratio algorithms shown fig 

timeout approaches abort transaction average times mpl 
aborting transaction times implies messages sent explaining fig 

response time ms ta dda obermarck pure timeout timeout detection multiprogramming level fig 

response time long transactions restart ratio dda obermarck pure timeout timeout detection fig 

restart ratio multiprogramming level scenario mix transactions wan experiment analyze algorithms wan environment consisting lans 
utilized transaction types scenario added new type accesses local objects objects lan started 
additional simulation parameters fig 

order simulate irregularities message delivery wan introduced network disturbances 
connection randomly chosen lans disturbed random time duration direction 
means sending messages connection delayed meaning arrival messages postponed length disturbance 
throughput throughput algorithms measured experiment fig 

shows superiority real deadlock detection algorithms timeout approaches tuned experiment 
non local accesses transactions constitute accesses 
distributed deadlock detection number lans number sites lan timeout value restart delay network disturbances transaction type load random lans share type transaction type load share type transaction type load share type transaction type average transaction size range transaction size likelihood lock requested local likelihood lock requested lan share type fig 

additional simulation parameters scenario throughput tas ms dda obermarck pure timeout timeout detection fig 

throughput multiprogramming level low mpls algorithms perform alike mpl increases throughput timeout approaches significantly drops 
mpl dda algorithm achieve throughput higher timeout approaches 
path pushing algorithm obermarck performs poorly higher mpls large constructs obtain values mpls 
experiment edge chasing algorithm dda perform alike 
surprising dda scheme outperformed previous experiments 
reason long message delays rare cases postpone detection deadlocks dda 
environment dda may take longer detect local deadlocks case ddas mainly responsible deadlock detection different centers locality merge 
reason merge disappears centers locality split takes time new dedicated ddas form 
number messages restart ratio response time measured graphs reveal new information 
summary experiments section reported thorough simulation study behavior deadlock detection algorithms distributed dbmss different environments 
ran quite number simulation experiments different database configurations fraction 
showed relative trends observed experiments discussed 
study showed importance difficulty determining timeout interval timeout approaches varies depending load mpl 
behavior algorithms time analyzed showing stability dda scheme lacking robustness timeout approaches prolonged heavy system loads relatively short transactions involved 
loads including mainly short long transactions introduced second scenario algorithms stabilized rapidly different throughput levels 
dda outperformed algorithms scenario achieving significantly higher throughput 
timeout algorithms performed worse edge chasing algorithm performed low mpls deteriorated higher mpls 
path pushing algorithm performed better edge chasing algorithm lower mpls scenario showed poor performance scenarios 
simulation results obtained algorithm 
experiment simulating wan environment timeout approaches performed poorly higher mpls 
dda edge chasing algorithm achieved higher throughput 
simulations show dda outperforms true deadlock detection algorithms 
performs better algorithms different scenarios 
additionally dda algorithm analyzed ones showed robustness different loads 
algorithms experiment obtain results mpls throughput degraded zero 
robustness algorithm great importance especially distributed system global load control feasible 
reason dda outperforms algorithms robust high loads explode load increases 
establishes ddas centers locality resolve deadlocks centers 
dependency sent object dda number messages increase significantly deadlocks detected quickly information short travel time 
deadlocks distributed dbmss analyzed 
identified deadlock models rep distributed deadlock detection resented dbmss gave detailed survey existing algorithms models 
devised new distributed deadlock detection algorithm dynamically created deadlock detection agents ddas 
dda responsible connected component wfg 
new component emerges new dda created 
case previously unconnected components interconnect corresponding ddas merge 
component dissolves dda terminates time 
dda scheme adapts shifting hot spots varying loads 
reports thorough simulation study deadlock detection algorithms shows dda scheme outperforms algorithms robust different loads 
implemented ddas persistent distributed system autonomously operating objects called auto 
computational model auto basically corresponds described sect 

objects extended autonomous behavior modeled asynchronous message passing 
object managers integrated objects objects autonomously manage resources locks 
transactions transaction managers realized autonomous objects 
auto operates different sites connected internet 
fully implemented java run wide variety platforms 
system robust reliable respect different workloads access profiles 
results simulation study chose dda best deadlock detection algorithm purpose 
porting dda code simulation system java able quickly implement deadlock detection method proven robust real system just simulation results indicated 

stefan pr ls great help implementation algorithms 
anonymous referees helpful suggestions 
acm agrawal carey mj mcvoy lw performance alternative strategies dealing deadlocks database management systems 
ieee trans software eng bad dz distributed deadlock detection algorithm 
acm trans comput syst bhg bernstein pa hadzilacos goodman concurrency control recovery database systems 
addison wesley reading mass raynal singhal deadlock models general algorithm distributed deadlock detection 
parallel distrib comput bn bernstein pa newcomer principles transaction processing 
morgan kaufmann san mateo calif bo beeri obermarck resource class independent deadlock detection algorithm 
proceedings th international conference large data bases vldb september cannes france 
ieee computer society press pp bt bracha toueg distributed deadlock detection 
distrib comput buk performance comparison distributed deadlock detection algorithms 
ed proceedings eighth international conference data engineering february tempe 
ieee computer society isbn pp cdas chen deng attie sun optimal deadlock detection distributed systems locally constructed wait graphs 
proceedings th international conference distributed computing system may 
hong kong ieee computer society pp cha chang echo algorithms depth parallel operations general graphs 
ieee trans software eng cho choudhary cost distributed deadlock detection performance study 
proceedings sixth international conference data engineering february los angeles calif usa 
ieee computer society isbn pp choudhary kohler wh stankovic ja towsley modified priority probe algorithm distributed deadlock detection resolution 
ieee trans software eng cl chandy km lamport distributed snapshots determining global states distributed systems 
acm trans comput syst cm chandy km misra distributed algorithm detecting resource deadlocks distributed systems 
acm sigact sigops symposium principles distributed computing august ottawa canada 
acm isbn pp chandy km misra haas lm distributed deadlock detection 
acm trans comput syst ds dijkstra ew scholten cs termination detection diffusing computations 
inf process lett elm elmagarmid ak survey distributed deadlock detection algorithms 
acm sigmod rec esl elmagarmid ak liu mt distributed deadlock detection resolution algorithm correctness proof 
ieee trans software eng gr gray reuter transaction processing concepts techniques 
morgan kaufmann san mateo calif gs gligor vd sh deadlock detection distributed systems 
ieee trans software eng hof timeout global deadlock detection decentralized database systems 
process lett er pr ls kemper auto distributed system autonomous objects 
www db fmi de projects auto auto html knapp deadlock detection distributed databases 
acm comput surv kor korth hf locking primitives database system 
jacm ks ad singhal invariant verification distributed deadlock detection algorithm 
ieee trans software eng ks ad singhal efficient detection resolution generalized distributed deadlocks 
ieee trans software eng ks ad singhal characterization correctness distributed deadlock detection 
parallel distrib comput ks ad singhal distributed detection generalized deadlocks 
proceedings th international conference distributed computing system baltimore maryland usa 
ieee computer society press pp lk lee kim jl efficient distributed deadlock detection algorithm 
proceedings th international conference distributed computing system may june distributed deadlock detection vancouver british columbia canada 
ieee computer society press isbn pp oracle server concepts manual 
oracle redwood calif mc misra chandy km termination detection diffusing computations communicating sequential processes 
acm trans program lang syst mm da muntz rr locking deadlock detection distributed data bases 
ieee trans software eng obermarck distributed deadlock detection algorithm :10.1.1.15.5632
acm trans database syst rb burkhard wa deadlock resolution semantic lock models object oriented distributed systems 
boral larson eds proceedings acm sigmod international conference management data chicago ill june 
sigmod record september pp rb burkhard wa resolution deadlocks object oriented distributed systems 
ieee trans comput rbc burkhard wa cooper kb efficient deadlock resolution lock concurrency control schemes 
proceedings th international conference distributed computing systems san jose california june 
ieee cs press isbn pp ff detection arcs deadlock management nested transactions performance 
small douglas johnson rg king martin gn eds advances databases proceedings th british national conference databases london uk july 
lecture notes computer science 
springer berlin heidelberg new york isbn pp hierarchical deadlock detection nested transactions 
distrib comput sal stonebraker aoki litwin pfeffer sah staelin yu mariposa wide area distributed database system 
vldb sh sanders ba pa distributed deadlock detection resolution probes 
raynal eds proceedings rd international workshop distributed algorithms nice france september 
lecture notes computer science lncs springer berlin heidelberg new york isbn pp sin singhal deadlock detection distributed systems 
ieee comput sn sinha mk natarajan priority distributed deadlock detection algorithm 
ieee trans software eng ss schwarz pm spector az synchronizing shared types 
acm trans comput syst wb wuu gt bernstein aj false deadlock detection distributed systems 
ieee trans software eng wdh williams daniels haas lapis lindsay ng obermarck selinger walker yost overview architecture 
rj 
ibm research san jose calif reprinted stonebraker ed 
readings database systems morgan kaufmann san mateo calif pp yeung hung lam performance evaluation new distributed deadlock detection algorithm 
acm sigmod rec 
