generating finite state abstractions reactive systems decision procedures michael col tom uribe computer science department stanford university stanford ca colon uribe cs stanford edu 
algorithm uses decision procedures generate finite state abstractions possibly infinite state systems 
algorithm compositionally abstracts transitions system relative fixed set assertions 
number validity checks proportional size system description size state space 
generated abstractions weakly preserving ctl temporal properties 
describe applications algorithm implemented decision procedures stanford temporal prover step 
th international conference computer aided verification vol 
lecture notes computer science pp 
springer verlag june july 
attractive method proving temporal property reactive system find simpler system satisfies satisfies 
particular finite state validity established automatically model checker may possible due infinite overly large state space 
obstacles approach 
construction manual proved correct stage 
process errorprone proof formal tedious 
second abstractions may fine may satisfy 
address problem automatically constructing guaranteed correct abstraction limited user input 
address second constructing abstractions quickly abstractions coarse refined little effort tested 
finding right abstraction iterative process user tests number candidate abstractions possibly guided feedback model checker 
procedure basic building block process 
procedure graf saidi gs validity checking generate finite state abstraction set formulas fb research supported part national science foundation ccr defense advanced research projects agency nasa nag aro daah aro muri daah army contract dabt darpa :10.1.1.39.1920
performing exhaustive search reachable states constructing algorithm transforms directly leaving exploration state space model checker 
number validity checks performed algorithm proportional number formulas size representation size state space 
furthermore procedure applicable systems state space large enumerate explicitly handled symbolic model checker mcm 
price paid approach compared gs coarser abstraction may obtained :10.1.1.39.1920
offset richer state space complete boolean algebra expressions fb monomials set 
procedure seen form interpretation cc algebra domain 
related abstraction procedure related gs sum :10.1.1.39.1920
procedure gs closest discussed :10.1.1.39.1920
deductive model checking sum system state space generated interactively theorem proving refinement initial maximally system 
refinement proceeds property question proved disproved 
procedure top opposed bottom property independent approaches gs propose :10.1.1.39.1920
contrast gs sum perform validity checking compile time model check time :10.1.1.39.1920
abstraction frameworks theoretical foundations property preserving abstraction dam lgs cgl 
necessary results abstraction section 
deductive rules proving simulation abstraction kmp 
contrast approach transform concrete system property preserving system automatically obviating need prove property preservation abstraction priori approaches interpretation cc cgl dam dgg 
specialized case finitestate systems 
include simple fairness considerations special case verification rules kmp appear interpretation 
uses abstractions explicitly user 
instance df applies abstraction error trace analysis infinite state systems 
abstraction generated automatically data abstraction maps concrete variables operators ones 
bbm uses interpretation generate invariants intermediate assertions fair transition systems 
procedure compositional automatic procedures top flavor including set atoms temporal formula verified 
suitable domain 
emphasis finding abstraction domains reachable state space approximated produce useful invariants 
motivated need prove general temporal properties system 
abstractions generate invariants 
invariants turn generate precise abstractions 
approximations pardo ph automatic bdd method symbolic model checking size bdd reduced approximations subformulas depending polarity 
polarity analogous way 
approximated bdd symbolic model checking procedure interpretation framework dam 
procedures change state space system approximate transition relation produce smaller bdds 
dill wong toi dw won interpretation verify timed safety automata approximating sets states state relations 
approximates set operations model checking statically approximating transitions methods specialized real time systems 
algorithm propose approximating transitions similar settings 
preliminaries fair clocked transition systems fair transition systems mp convenient formalism specifying infinite state reactive systems assertion language firstorder logic 
fair transition system fts sigma theta set system states sigma initial condition theta set transitions state sigma valuation finite set typed system variables sigma finite said finite state 
definition assertion 
order formula free variables subset assertion state formula represents set states satisfy 
assertion say sigma state iff holds values initial condition theta assertion characterizes set initial states 
transition associate transition relation ae order formula system variables primed set indicating values state 
transition enabled taken state 
define enabled def ae 
define post assertion ae characterizes states reachable states transition usual define result replacing free variable set expressions def 
run infinite sequence states theta ae case say taken transitions labeled just 
just weakly fair transition continuously enabled taken strongly fair transition enabled infinitely taken finitely times 
computation run satisfies fairness requirements 
ensure run prefixes extended infinite sequence assume idling transition transition relation clocked transition systems mp extension fair transition systems intended model reactive systems real time constraints 
clocked transition system cts fair transition system sigma theta system variables partitioned set discrete variables set real valued clock variables idling transition includes tick transition transition advance time 
progress time restricted time progress condition pi assertion transition relation tick ae tick delta delta delta pi delta stands delta delta pi stands pi fd impose fairness conditions transitions clocked transition system 
upper bounds time pass enabled transition taken specified time progress condition 
computations cts runs time grows bound 
temporal logic linear time temporal logic ltl express properties reactive systems 
temporal formulas built assertions boolean operators temporal operators usual 
see mp details 
ltl properties part universal fragment ctl subset ctl eme 
procedure applies verification ctl properties ltl 
example presents fragment fischer real time mutual exclusion algorithm described mp simple programming language mp 
algorithm assumes uniform positive bounds time process wait executing statement enabled transition wait taken 
algorithm guarantees processes critical sections simultaneously 
clocked transition systems contain master clock changed tick transition theta imply 
need example 
local await skip await critical jj await skip await critical fig 

fischer mutual exclusion algorithm 
model program clocked transition system introduce control variables ranging fm respectively clock variables theta take assertion 
introduce transition statement statement yields transition relation ae take time progress condition pi add transition tick 
mutual exclusion expressed ltl formula 
abstraction abstraction reduces verification temporal property concrete system checking related property simpler system simplicity write indicate corresponding property holds system 
notation dam possible 
set temporal properties systems say weakly preserving abstraction iff 
said strongly preserving abstraction converse true weakly preserving abstractions 
ideas interpretation cc system constructed set states sigma partial order precise state abstractions terms galois connections posets connected sigma sigma sigma concrete state space 
see lgs dam 
concretization function fl sigma 
sigma maps state set concrete states represents abstraction function ff sigma 
sigma maps set concrete states precise state represents 
pair ff fl galois connection iff sigma sigma ff fl 
extend fl sets states sigma fl def fl relations ae sigma theta sigma fl ae def phi hs fl fl ha ae psi domain implicitly deductive verification definition assertion abstraction 
domain sigma choose complete boolean algebra ba finite set assertions iff implies fl fs sigma fg ff phi ba fl psi call assertion domain basis galois insertion sigma sigma ff fl ba 
notation note operations domain usual connectives general assertion language 
continue characterize sets concrete states assertions need points state space 
formula ba write fl characterize set states represents simply highlight fact state fl assertion representing set concrete states 
formally fl obtained replacing boolean variables elements appear corresponding subformulas fl 
way extension fl sets characterized fl fl 
assertions write valid 
correctness abstractions lemma 
lemma weak preservation ctl sufficient condition 
finite set assertions sigma theta sigma theta 
initial condition theta fl theta theta approximated theta 
transition transition ae fl ae approximated 
fairness just resp 
just resp 
fl enabled resp 
enabled post fl enabled fl post enabled system weakly preserving abstraction ctl 
third requirement limits fairness constraints imposed transitions note fairness constraints ctl properties satisfy 
hold safety properties preserved 
note guaranteed ae fl ae 
lemma holds inclusions valid reachable states invariants establish 
general conditions simulation refinement fair transition systems kmp deductive verification rules 
generating finite state abstractions fb fixed assertion basis 
assume disposal procedure decide validity assertions returns true valid 
validity checker assumed sound required complete 
workhorse abstraction algorithm procedure approximates assertions assertions procedure descends boolean structure formula building assertion serve context keeping track polarity subexpressions reaches atoms 
procedure approximates atom element ba 
abstracting atoms atoms abstracted testing context set points ba ff atom fp fl approximation ff atom gamma fp fl approximation intuitively context indicates concerned results lie approximating context consider smaller set 
yields smaller result precise approximation 
similarly approximating context approximate 
give larger result better approximation 
abstracting assertions extend ff atom function ff abstracts assertions follows ff ff atom atom ff ff gamma gamma def gamma gamma gamma def ff ff ff fl ff ff ff fl ff gamma ff gamma ff gamma fl ff gamma ff gamma ff gamma fl assertion abstracted jp delta jf validity checks 
main claim justifies correctness algorithm proposition 
assertions 
fl ff gamma 
fl ff valid 
notice algorithm applies domain boolean algebra provided operations fl available 
similarly applies assertion language validity checker available 
abstracting systems properties concrete transition system sigma theta abstraction theta theta result approximating theta result approximating transition relation initial context contain known invariants abstracting atoms initial condition assertions temporal property see test set unprimed points pu def bg transition relations test set mixed points pm def pu fp pu algorithm abstracts transition relation ae jae validity checks jbj 
assertion primed variables validity checks needed 
enlarging point sets increase quality abstraction discussed section relatively small sets sufficed verify examples section 
system bit finite state system 
theta fl theta ae fl ae conditions lemma satisfied 
satisfy condition propagating fairness establish validity fl enabled enabled 
case enabling conditions equivalent 
basis includes atoms guard guaranteed case 
assertion contains atoms abstraction equivalent modulo invariants 
worst case fairness carries safety properties proved 
temporal property abstracted approximating assertions contains approximating negative polarity 
method guarantees model property corresponds model concrete 
computations system satisfy computations concrete system satisfy 
basis includes assertions appearing property property approximation exact 
optimizations preserving concrete variables allow finite domain variables propagated leaving model checker represent explicitly encode bits 
implement having ff identity finite domain subexpressions free variables appear basis 
note algorithm finite state systems smaller ones 
general known invariants establish conditions lemma differ unreachable states 
reducing test point set implementation includes simple strategies eliminating trivial redundant test points 
example atom implies unnecessary test point modify free variables eliminate points fp pu enlarging test point set occasions additional points tested obtain sufficiently precise abstraction 
example ae may imply imply unwilling incur potentially exponential cost naive enumeration points 
allow user specify additional points test specifying basis 
alternatively user may enlarge basis general increase time space model check time 
conjunctions literals subexpression consists solely conjunctions literals eliminate redundant validity checks testing point entire subexpression 
terminate recursion early testing points atom improve quality abstraction 
example basis fischer algorithm starting context consisted assumptions invariants 
initial condition abstracted write 
transition abstracted ae transitions similarly abstracted 
tick transition contains quantifiers treated single literal abstracted 
implementation see section system generated seconds mutual exclusion automatically model checked second 
experimental results implemented abstraction procedure deductive algorithmic support stanford temporal prover step bbc 
step includes system transitions basis size abstraction time model check time bakery fischer alternating bit bounded retransmission table 
abstraction model check times 
decision procedures datatypes partial orders linear arithmetic congruence closure bit vectors 
integrated general validity checker complete ground formulas relative power decision procedures applied order formulas 
step includes explicit state symbolic ltl model checking fair transition systems 
tested implementation examples including mutual exclusion algorithms data communication protocols 
examples infinite state contain variables range unbounded integers lists real valued clocks 
example table gives size basis time generate system time model check properties interest generated abstraction step explicit state model checker 
concrete systems properties bases systems available web rodin stanford edu abstraction 
bakery algorithm process mutual exclusion algorithm see mp 
property verify mutual exclusion proves particularly easy establish sufficient take basis set assertions guard transitions 
alternating bit protocol sender receiver communicate lossy channels 
property verify receiver list prefix list sender transmitting 
basis example trace refinement starting guards transitions added assertions basis response counter examples model checker 
necessary add test point validity checker derive necessary inductive properties lists 
bounded retransmission protocol hs gs extension alternating bit protocol limit placed number transmissions particular item 
alternating bit protocol verify prefix property receiver list 
addition verify sender receiver report status consistently report ok report ok sender reports dont know receiver reports ok ok generate basis started basis alternating bit protocol added guards transitions 
recognize abstraction times highly dependent speed validity checker give feel quickly abstractions generated practice 
verifying consistency status reports step model checker discovered counter example uncovered oversight original implementation 
list transmitted empty sender finishes immediately reporting ok receiver having received frame bit set assumes sender aborted transmission reports ok correct problem require list non empty bounded retransmission protocol designed transmit empty lists 
procedure abstracting transition systems compositional manner finite state abstraction domain 
explore state space transition relations describe system 
state space explored explicitly symbolically model checker 
procedure provides alternative method combining deductive algorithmic verification 
deductive tools procedure applicable infinite state systems 
efficiency abstraction procedure finite state model checking level gives procedure level automation comparable finite state algorithmic methods 
deductive methods availability new decision procedures particular theories increases power algorithm 
choice abstraction basis user understanding system analogous intermediate assertions deductive verification 
procedure completely automatic basis chosen efficiency allows various alternatives quickly tested 
techniques generation manual automatic abstraction basis remain tested explored 
bj rner zohar manna saidi sipma feedback comments 
ah alur henzinger editors 
proc 
th intl 
conference computer aided verification vol 
lncs 
springer verlag july 
bbc bj rner browne chang col kapur manna sipma uribe 
step deductive algorithmic verification reactive real time systems 
alur henzinger ah pages 
bbm bj rner browne manna 
automatic generation invariants intermediate assertions 
theoretical computer science february 
preliminary version appeared st intl 
conf 
principles practice constraint programming vol 
lncs pp 
springer verlag 
bj rner stickel uribe 
practical integration firstorder reasoning decision procedures 
th intl 
conf 
automated deduction vol 
lncs pages 
springer verlag july 
cc cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
th acm symp 
princ 
prog 
lang pages 
acm press 
cgl clarke grumberg long 
model checking abstraction 
acm trans 
prog 
lang 
systems september 
dam dams 
interpretation partition refinement model checking 
phd thesis eindhoven university technology july 
df 
model checking infinite state systems data abstraction assumption commitment style reasoning theorem proving 
wolper wol pages 
dgg dams gerth grumberg 
interpretation reactive systems 
acm transactions prog 
lang 
systems 
argenio katoen tretmans 
bounded retransmission protocol time 
rd tacas workshop vol 
lncs pages 
springer verlag 
dw dill wong toi 
verification real time systems successive approximation 
wolper wol pages 
eme emerson 
temporal modal logic 
van leeuwen editor handbook theoretical computer science vol 
pages 
elsevier science publishers north holland 
gru grumberg editor 
proc 
th intl 
conference computer aided verification vol 
lncs 
springer verlag june 
gs graf saidi :10.1.1.39.1920
construction state graphs pvs 
grumberg gru pages 
hs havelund shankar 
experiments theorem proving model checking protocol verification 
formal methods europe pages march 
dams gerth 
practical symbolic model checking full calculus compositional abstractions 
technical report eindhoven university technology netherlands october 
kmp kesten manna pnueli 
temporal verification simulation refinement 
decade concurrency vol 
lncs pages 
springer verlag 
lgs graf sifakis bouajjani bensalem 
property preserving abstractions verification concurrent systems 
formal methods system design 
mcm mcmillan 
symbolic model checking 
kluwer academic pub 
mp manna pnueli 
temporal verification reactive systems safety 
springer verlag new york 
mp manna pnueli 
clocked transition systems 
tech 
report stan cstr computer science department stanford university april 
ph pardo 
automatic abstraction techniques propositional calculus model checking 
grumberg gru pages 
sum sipma uribe manna 
deductive model checking 
alur henzinger ah pages 
wol wolper editor 
proc 
th intl 
conference computer aided verification vol 
lncs 
springer verlag july 
won wong toi 
symbolic approximations verifying real time systems 
phd thesis computer science department stanford university march 
tech 
report cs tr 
