expressive capabilities description languages query rewriting algorithms vassalos yannis papakonstantinou information integration systems cope wide variety different information sources support query interfaces varied capabilities 
deal problem integration systems need descriptions query capabilities source set queries supported source 
integration systems need algorithms deciding query answered capabilities sources 
need translate query format source understands 
languages suitable descriptions query capabilities sources compare expressive power 
languages automatically derive capabilities description integration system terms capabilities sources integrates 
describe algorithms deciding query matches description show application problem translating user queries source specific queries commands 
propose new improved algorithms problem answering queries descriptions 
identify interesting class source capability descriptions algorithms efficient 
users applications today require integrated access multiple heterogeneous information systems conventional sql database management systems 
examples systems web sources forms interfaces object repositories bibliographic databases systems provide powerful query capabilities provide limited query interfaces 
systems integrate information multiple sources cope different limited capabilities sources 
particular integrating systems allow users query data single powerful query language having know diverse capabilities source 
illustrates typical high level architecture integration system 
mediator decomposes incoming client queries expressed common query language new common language queries sent wrappers 
wrappers translate incoming queries queries commands expressed native language source supported 
queries received wrappers supported sources sense directly correspond supported source queries 
counterproductive build wrappers accept queries directly supported corresponding source 
apparently wrappers mediators require descriptions research partially supported nsf iri aro daah air force contract lilian foundation 
computer science dept stanford university stanford ca 
email vassalos db stanford edu computer science engineering dept ucsd san diego ca 
email yannis cs ucsd edu information source information information information source source source wrapper mediator user application mediator wrapper wrapper wrapper user application common architecture integration mediator capabilities rewriter query engine query cost optimizer candidate plans plan cost estimate resource locator plan queries annotated query mediator architecture query capabilities participating sources order correctly reduce client query queries supported wrappers translate supported native query 
particular special module mediator called capabilities rewriter cbr uses description adapt query capabilities sources 
example illustrate query processing steps followed mediator modules see 
consider source exports lookup catalog lookup employee manager specialty employees 
description indicates source supports selection queries 
assume client query simply query requests managers employee specialized java employee specialized databases 
notice query answered self join lookup table manager 
module mediator called resource locator knows metadata views source data descriptions data needed answering query reside lookup 
consequently formulates annotated query relation annotated origin 
notice finding needed data problem orthogonal obtained 
problem treated 
cbr takes input descriptions annotated query infers plans retrieving required data 
running example plan executed mediator engine retrieve set managers java employees set managers database employees intersect sets 
alternatively cbr may form sideways information passing plan retrieves set managers java employees manager issues query check database employer 
cbr typically produces candidate plans query 
assume cost optimizer provide cost estimates 
notice approach loose coupling cbr optimizer 
systems algorithms cbr module optimizer tightly coupled described 
rate concerned estimating cost plans 
relevant acps dks 
wrappers need descriptions source capabilities order translate supported common language queries queries commands understood source interface 
particular description associated actions perform translation style yacc asu 
approach tsimmis project stanford wrapped number real life bibliographic sources 
clear languages describing set supported queries needed 
new languages describing query capabilities brings questions studied languages expressive 
ii description wrappers capabilities answer client query queries answerable supported wrappers 
refer problem capabilities rewriting cbr problem corresponding algorithm run cbr module clearly related answering queries views problem lmss lru see section 
focus sources support conjunctive queries capabilities subset cq ahv 
extends results vp 
particular topics novel contributions follows ffl introduce description language datalog formally define set queries described datalog programs complete efficient procedures decide query described datalog description 
algorithm run wrapper note finds translating actions executed 
ii decide query answered combining supported queries cbr problem 
algorithm run mediator 
algorithm runs time non deterministic exponential size query description substantial improvement algorithm described lru non deterministic doubly exponential 
ffl study expressive power datalog 
reach important result datalog describe query capabilities certain powerful sources 
particular show datalog program describe conjunctive queries schema 
program describes boolean conjunctive queries schema 
presents expressiveness results reported vp provides formal proofs 
ffl describe extend rqdl provably powerful language datalog keeps salient features datalog 
ffl provide reduction rqdl descriptions datalog augmented function symbols 
reduction important practical theoretical value 
practical point view reduces cbr problem rqdl cbr problem datalog giving complete algorithm applicable rqdl descriptions theoretical point view clarifies difference expressive power rqdl datalog 
current presents reduction algorithms complete rqdl language 
presenting complete cbr algorithms expressiveness results proofs current contributions vp ffl identify important class descriptions covering sources document retrieval systems lookup catalogs object repositories show complexity cbr problem specific class significantly lower complexity general case 
ffl provide algorithm takes input descriptions queries supported wrappers outputs description queries supported mediator accesses wrappers 
algorithm important mediators accessing mediators requiring knowledge query capabilities accessed mediators 
ffl investigate expressive power relationship proposed description languages datalog queries annotated binding patterns 
furthermore provide completeness proofs complexity arguments datalog cbr algorithm produces plans sideways information passing 
section introduces datalog description language 
section describes algorithm run wrappers 
section describes cbr algorithm run mediators 
section studies useful large class descriptions cbr problem lower computational complexity 
section discusses expressive power issues 
section introduces rqdl 
section discusses rqdl description mediator capabilities 
section describes reduction rqdl datalog function symbols section describes wrapper mediator algorithms rqdl 
section discusses related 
section gives 
datalog source description language known popular real life query languages spj queries ahv web query forms equivalent conjunctive queries 
datalog program natural encoding sets conjunctive queries set described expansions datalog program 
describe informally datalog source description language illustrate examples 
formal definition follows subsection 
simple case deal weak information source source described set parameterized queries 
parameters called tokens specify constant expected fixed position query lru 
loss generality assume existence designated predicate ans head parametrized queries description 
example consider bibliographic information source provides information books 
source exports predicate books isbn author title publisher year pages 
source exports indexes author index author name isbn publisher index publisher isbn algorithm works rqdl descriptions important union 
title index title word isbn 
conceptually tuple author index string resembles actual name author isbn book author 
similarly title index word actual title isbn book word title 
parameterized queries describe wrapper answers queries specifying author title publisher 
ans id aut itl ub pg books id aut itl ub pg author index id ans id aut itl ub pg books id aut itl ub pg title index id ans id aut itl ub pg books id aut itl ub pg publisher index id denotes token 
query ans id aut itl ub pg books id aut itl ub pg author index smith id answered source derived parameterized query replacing constant smith 
previous example source described parameterized conjunctive queries 
note instance source accepts queries values combination indexes specified write parameterized conjunctive queries 
example uses idb predicates predicates defined source predicates idb predicates describe abilities source succinctly 
example uses recursive rules describe source accepts infinite set query patterns 
example consider bibliographical source previous example 
assume source answer queries specify combination indexes 
datalog program describes source ans id aut itl ub pg books id aut itl ub pg ind id ind id ind id ind id title index id ind id ffl ind id author index id ind id ffl ind id publisher index id ind id ffl ffl denotes empty body ffl rule empty expansion 
notice ffl rules unsafe ull 
general datalog rules unsafe problem semantics 
note number rules polynomial number available indexes number possible expansions exponential 
query ans id aut itl ub pg books id aut itl ub pg author index smith id answered source derived expanding rule rules replacing constant smith 
easily modify description require index 
general datalog program describes queries expansions ans rule program 
particular datalog rules ans predicate head expanded possibly infinite set conjunctive queries 
expansions generated refer source predicates call expansions terminal expansions 
datalog program unsafe terminal expansions 
say datalog program describes set conjunctive queries safe terminal expansions 
see formal definitions subsection 
example consider bibliographical source example 
assume index index word id indexes books words contained abstracts 
consider source accepts queries books words abstracts 
datalog program describe source 
ans id aut itl ub pg books id aut itl ub pg ind id ind id index id ind id ind id index id example recursive source description think transportation information source capable answering queries flights 
assume source answer exists flight cities stops 
model source datalog program 
formal description datalog 
assume familiarity datalog ull ahv 
constant variable sorts third disjoint set symbols set tokens 
definition datalog program syntax parametrized datalog rule datalog rule expression form relation names tuples constants variables tokens appropriate arities 
datalog program finite set datalog rules 
tokens variables instantiated form query 
formalize semantics datalog source description language 
definition set queries described expressible datalog program datalog program particular idb predicate ans 
set expansions smallest set rules ffl rule ans head predicate ffl assume variables tokens renamed don variables tokens common substitution general unifier resolvent gamma set terminal expansions subset expansions containing edb predicates body 
set queries described set rules ae ae assigns arbitrary constants tokens set queries expressible set queries equivalent query described stated source predicates edb predicates descriptions 
unification extends tokens straightforward manner token unified token yielding token 
unified variable yields token 
unified constant yields constant 
definitions easily extended accommodate designated predicates ans 
context description semantics terms datalog program description interchangeably 
informally observe expansions generated grammar fashion datalog rules productions head predicates treating idb predicates nonterminals asu 
resolution generalization non terminal expansion rules context free grammars simply thought datalog rules arguments 
rectification deciding expressibility solving cbr problem rectified form datalog rules simplifies algorithms 
assume conditions satisfied ffl variable appears twice subgoals query body 
multiple occurrences variable handled distinct variables making equalities explicit equality predicate equal 
ffl variable appears twice head query 
equalities explicit predicate equal 
ffl constants tokens appear ordinary subgoals 
constant token replaced unique variable equality subgoal equal equal added equate variable constant 
ffl variables appear equal subgoal query 
example consider query ans contains join second columns selection column variable columns ans 
rectified equivalent ans equal equal equal notice treat equal subgoal built predicate source predicate 
call rules obey conditions rectified rules process transforms rule rectified rule rectification 
call inverse procedure give rule rule de rectification 
sections provide algorithms deciding query expressible description solving cbr problem 
refer edb idb relations facts ordinary distinguish facts equal relation 
deciding query expressibility datalog descriptions section algorithm query expressibility datalog descriptions 
doing develop techniques allow section give elegant improved solution problem answering queries infinite set views described datalog program :10.1.1.38.7636
algorithm query expressibility decision algorithm extension classic algorithm deciding query containment datalog program appears see ull 
algorithm tries identify expansion datalog program equivalent query 
illustrate workings algorithm example 
example revisit bibliographic source previous examples 
assume source contains table books isbn author publisher word index titles title index title word isbn author index au index au name isbn 
assume query capabilities source described datalog program ans books id ind id ind id equal id id equal id id ind id title index id equal ind id ffl ind id au index id equal ind id ffl consider query ans books id title index zen id au index smith id produce rectified equivalent ans books id title index id au index id equal zen equal smith equal id id equal id id apparently query expressible description 
intuitively algorithm discovers expressibility matching datalog program rules subgoals 
particular matching done follows create db containing frozen fact subgoal query 
frozen facts derived turning variables unique constants denoted bar 
want capture information carried equal subgoals db 
example subgoals equal equal exist query generate frozen facts implicit equalities equal equal interests space clarity write equal mean previously mentioned facts db 
db running example books id title index id au index id equal id id id equal zen equal smith evaluate datalog program db deriving facts idb 
addition keep track set frozen facts called supporting set deriving fact 
set facts supporting sets derived particular evaluation datalog program 
ind id fg 
ind id fg 

ans id equal id id 
ind id index id equal zen 
ind id index id equal smith 

ans id title index id equal zen au index id equal smith equal id id id ans fact identical frozen head client query corresponds query contains client query 
furthermore derive containing query fact supporting set 
pair translating frozen facts back subgoals 
running example containing queries correspond 
supporting set identical db started modulo redundant equality subgoals corresponding query equivalent client query 
corresponding query ans books id title index id zen au index id smith equivalent identical query 
algorithm qed starts mapping subgoals query frozen facts variable maps unique constant creating canonical database ull query evaluates datalog program trying produce frozen head query 
keeps track different ways produce fact achieved annotating produced fact supporting facts facts canonical db derivation formalize notion canonical database 
formal definition supporting facts follows 
definition canonical db query em rectified conjunctive query ordinary subgoals em equality subgoals 
select mapping assigns variable unique frozen constant identity mapping constants predicate names 
way construct frozen ordinary facts 
construct frozen facts edb predicate equal 
facts constitute instance equal relation 
create additional equal facts get smallest set equal facts includes instance equivalence relation 
constructed facts constitute canonical db query notice db contains kinds constants regular constants frozen constants 
example consider rectified query ans equal equal equal equal canonical db produced query equal equal equal equal equal equal equal equal equal equal equal equal equal algorithm qed uses pruning eliminate output 
shorthand notation proceed formalize shorthand notation introduced example 
obvious equal facts form equivalence relation constants frozen constants appearing equal facts divided equivalence classes 
look canonical db query variables appearing canonical db belong equivalence class replace equal facts involving equal 
example equal stands equal 
canonical db produced query example written equal equal easy see equal subset equal xm iff fx definition supporting set fact ordinary fact produced application datalog rule em datalog description database db consists canonical database cdb facts mapping rule database db 
set supporting facts supporting set respect smallest set ffl cdb ffl cdb set supporting facts ffl set smallest set equality facts includes equivalence relation included notice set leaves proof tree ull annotate produced fact id rule production generating proof tree fact 
example apply rule ans author publisher equal equal canonical db author author publisher publisher equal equal equal prenticehall produce fact ans 
supporting set publisher equal equal prenticehall define notions extended facts extended canonical db definition extended facts extended canonical db extended fact pair form fact supporting set respect description rectified conjunctive query 
extended canonical db database extended facts ffg belongs canonical db referring example extended fact associated production ans ans publisher equal equal prenticehall introduce notion corresponding query fact intuition supporting set explicit 
definition corresponding query extended fact db 
fact define mapping ae identity constants predicate names maps frozen constant variable came 
easy see mapping formed 
maps query body fact query head 
query ae ae ae called corresponding query extended fact 
intuitively corresponding query instantiated expansion rules description prove uses source equality predicates 
algorithm qed produces set candidate queries corresponding queries produced extended facts 
candidate queries described datalog description interesting expansions equivalent query 
show candidate query important property projection empty list attributes contains projection empty list attributes query said body candidate query contains body query 
means exists candidate query head identical head obviously containing query respect expressible iff candidate queries set equivalent algorithm detail 
notice algorithm generates maximal supporting sets produced fact 
produced candidate queries sense minimal 
formalize notion section 
proceed give results correctness running time algorithm 
just demonstrate example rectification necessary 
example illustrate rectification necessary identifying candidate queries consider query ans datalog description ans 
evaluating description canonical db fp rectification produce extended fact ans fp 
corresponding query ans correct candidate query expressible definition description 
hand rectification get canonical db fp equal evaluating description get candidate query ans containing query query equivalent 
obviously description source simple query interface algorithm input minimized ull non rectified conjunctive query form head subgoal form ans xn 
non rectified datalog description output set candidate queries 
method rectify construct extended canonical db apply rules facts db generate possible extended facts bottom evaluation ull modified ways items guarantee generation extended facts maximal supporting sets 
populate idb relations extended facts fact produced rule compute enter database iff ffl database ffl db 

new fact added db delete db facts form ae 
rule unsafe distinguished variables appear rule body simply leave variables produced fact 

extended fact ans fact contains variables delete extended fact 

de rectify resulting extended facts query 
create corresponding queries extended facts 
treatment unsafe rules generalized magic sets ull 
algorithm qed ready state formal results algorithm qed 
ultimately formally state prove correctness criterion solving expressibility problem state prove computational complexity 
lemma algorithm qed produces extended facts maximal supporting sets 
maximal mean extended facts fact lemma directly follows algorithm theorem soundness completeness set candidate queries query datalog description fq set candidate queries result algorithm qed true 

identity mapping map body body 
query described fq ffl contain ffl exists heads identical identity mapping containment mapping 
query described fq exists proof sketch derived directly algorithm direct consequence existence mapping 
algorithm qed exhaustive generates relevant sense candidate queries exception pruned due lemma 
relevant candidate set 
extended fact maximal supporting set 
means exists extended fact 
clear definition corresponding query corresponding query contained mapping identity 
direct consequence 
theorem says described query candidate set equivalent exists smaller query candidate set contains sense candidate set contains minimal queries 
says queries candidate set interesting query candidate set equivalent algorithm qed produces output allows correctly decide query expressibility 
effect prove lemma expressibility criterion expressible iff set supporting facts extended fact frozen head identical canonical db proof sketch obvious way corresponding query defined db corresponding query equivalent output algorithm qed contains candidate queries theorem holds expansion tighter fit query queries output 
exists fact canonical db set corresponding query equivalent reason minimized minimization unique isomorphism subgoals facts canonical db necessary 
number extended facts generated real fact equal number different supporting sets fact exponential size canonical db 
number facts exponential size description theorem algorithm qed produces answer time exponential size description size query 
notice problem query containment datalog reducible problem query expressibility described 
query containment datalog exptime complete 
theorem query expressibility exptime complete 
algorithm meets theoretical lower bound 
head body frozen 
de rectification 
expressibility translation consider case wrapper receives query 
easy see extend algorithm annotates fact supporting set proof tree 
wrapper parse tree perform actual translation user query source specific queries commands applying translating actions associated rule description 
answering queries datalog descriptions mediators faced tougher problem wrappers descriptions wrappers mediator answer user query sending wrappers queries expressible wrapper descriptions consequently combine answers produce answer query 
capabilities rewriting cbr problem 
notice mediator combine queries selections projections joins 
formally considers rewritings user query conjunctive rules described 
definition rewriting query conjunctive query set queries fq form ans body rewriting fq rule form ans ans ans optional equalities said previous sections source description defines possibly infinite set conjunctive queries answerable source 
cbr problem equivalent problem answering user query infinite set views described datalog program lru 
algorithm proceeds steps 
step finds finite set expansions 
second step uses algorithm answering queries views lmss qia combine expansions answer query 
step uses algorithm generate finite set expansions see 
prove answer query combination expressible queries answer combination expansions finite set 
lru solution problem complexity non deterministic doubly exponential size query description 
solution signatures expansions description divide queries expressible description equivalence classes 
show solution non deterministic exponential size query description 
proof solution intuitive simpler 
user query wrapper description datalog algorithm qed produces candidate queries respect show exponential number lemma output algorithm contains worst exponential number queries length linear size user query 
prove queries expressible relevant answering modulo variable renaming corresponding queries output algorithm described theorem cbr assume query datalog description tokens fq result applying algorithm exists rewriting fq jq expressible pg exists rewriting fq proof sketch direction trivial 
lmss 
expressible candidate query 
fq contains interesting candidate queries respect theorem 
means fq exists corresponding containment mapping identity mapping 
jm rewritten query 
replace corresponding identified equivalent proof ffl exists containment mapping particular identity mapping containment mapping ffl exists containment mapping containment mapping theorem cm equivalent 
completes proof theorem 
sure need solve rewriting problem compute candidate queries algorithm need algorithm combine candidate queries rewriting query 
problem finding equivalent rewriting query finite number views known np complete size query view set lmss known algorithms solving absence tokens lmss qia 
total computational complexity cbr scheme worst case ffl stage qed exponential size query description 
ffl second stage answering queries views np size input 
size input cardinality candidate set times size largest candidate 
qed algorithm output exponential size second stage dominates total complexity algorithm worst case nondeterministic exponential 
particular cardinality candidate set exponential arity head candidate queries importantly size canonical database 
see subsection cbr binding requirements discussion previous section ignores presence tokens 
handle tokens datalog description need modify steps cbr scheme 
discuss changes necessary 
correctly solve cbr problem presence binding requirements need modify qed algorithm 
consider example show algorithm qed unchanged inadequate solution cbr problem binding patterns 
example target query ans description rectified query ans equal equal rectified datalog description source ans equal algorithm qed produces candidate query de rectification ans rewriting equivalent way answer datalog description 
see rewrite query view binding patterns explicit ans fb fb rewrite follows ans fb fb fb rewriting respects binding requirements views processed passing bindings equivalent target query 
need modify algorithm qed 
necessary change qed consists basically pre processing step replace tokens datalog description variables maintain extra annotation information variables need bound 
particular information attached extended fact extra annotation 
modified algorithm qed detail 
applying modification previous example ans needs bound 
algorithm qed input produces candidate queries ans needs bound ans needs bound 
qed uses binding information turn candidate queries queries binding patterns 
turn ans fb ans fb algorithm input minimized ull non rectified conjunctive query form head subgoal form ans xn 
non rectified datalog description output set candidate queries binding patterns 
method rectify construct extended canonical db replace tokens variables 
annotate rules binding information 
apply rules facts db generate possible extended facts bottom evaluation ull modified ways 
populate idb relations extended facts fact produced rule compute enter database iff ffl database ffl db 

new fact added db delete db facts form ae 
rule unsafe distinguished variables appear rule body simply leave variables produced fact 

update bound variables annotation extended fact variable gets annotation binds annotated variable 

extended fact ans fact contains variables delete extended fact 

de rectify resulting extended facts query 
create corresponding queries extended facts 
binding information construct binding patterns 
treatment unsafe rules generalized magic sets ull 
algorithm qed input second stage cbr scheme section algorithm answering queries views 
algorithms lmss qia proposed previous section deal properly tokens 
mentioned section tokens describe binding requirements 
need take account binding requirements candidate queries 
studies problem answering queries views binding requirements 
authors binding patterns describe binding requirements 
show problem np complete describe algorithm 
algorithm takes input finite set conjunctive views binding patterns target query binding pattern rewrites query views way respects view binding patterns 
example example query rewriting views binding patterns 
algorithm henceforth referred algorithm second part cbr scheme find rewriting user query candidate queries 
input obtain correct efficient rewriting shown example 
theorem cbr tokens assume query datalog description tokens fq result applying algorithm exists rewriting fq jq expressible pg exists rewriting fq proof sketch issue qed missing candidate queries ignoring tokens 
easy see candidate query missing identical queries candidate set qed modulo equality subgoals 
rewriting query candidate binding pattern rewriting query binding pattern 
theorem follows 
solution cbr problem binding requirements non deterministic exponential 
interesting efficient class datalog descriptions identify interesting class datalog descriptions simple syntactic characterization cbr algorithm section efficient 
particular class descriptions output qed algorithm exponential arity candidate query head depend size canonical database 
second stage cbr scheme efficient receives smaller input 
cbr scheme class non deterministic exponential arity head predicate 
definition datalog description belongs loop ffl contains idb predicate ffl idb predicate pred pred km rule appears descriptions loop consist simple loops exit rules 
example repeat description source example 
source accepts queries books words abstracts assuming exists index index word id datalog program describe source 
ans id aut itl ub pg books id aut itl ub pg ind id ind id index id ind id ind id index id description clearly belongs loop lattices help explain output qed descriptions loop depend size canonical database solely depends arity ans facts 
subsection short reminder lattices 
description happens monadic ahv 
descriptions general don 
supporting sets length supporting sets length supporting set lattice fact database size lattice framework consider subset relation sets 
denote lattice set elements supporting sets section subset relation hl elements lattice hl ae means ancestors descendants element lattice hl defined follows ancestor fb bg descendant fb ag note element lattice descendant ancestor 
immediate proper ancestors element lattice belong set shall call 
formally fb ae ae ae bg common represent lattice lattice diagram graph lattice elements nodes edge 
lattice elements lattice diagram path downward shows lattice diagram possible supporting sets fact database size 
subsection discusses size output qed algorithm loop class datalog descriptions 
qed loop cardinality candidate set produced qed general exponential size canonical database 
gives graphical explanation potential supporting sets fixed size fact number candidate queries exponential size canonical database 
descriptions loop crucial observation supporting sets fact produced algorithm qed description loop common ancestor 
produced qed qed keeps extended facts maximal supporting sets extended fact kept replace extended facts 
easy see extended fact fact generated just candidate query 
output qed algorithm loop supporting sets length supporting sets length supporting sets common ancestor complexity second stage cbr scheme exponential arity head candidate queries size canonical database 
importance class lies fact observed expressive describe large number common sources document retrieval systems web sources 
expressive power datalog illustrated datalog programs source description language 
section explore limits description capabilities 
noted focus description conjunctive queries similar results hold negation disjunction introduced 
clearly sets conjunctive queries described datalog description 
lemma exist recursive sets conjunctive queries expressible description 
proof seen previous section decision procedure description semantics datalog exponential 
recursive set conjunctive queries membership function super exponential expressible datalog description 
practical question recursive sets conjunctive queries correspond real sources expressed datalog programs 
show common sources intuitively powerful ones exhibit behavior 
prove result demonstrate expressive abilities limitations datalog 
start observation datalog description program arity result exactly arity ans predicate 
restriction somewhat artificial define descriptions answer predicate 
case program bound arities answers 
furthermore serious bound number variables occur rules program 
see bound imposing severe restrictions queries expressed 
bound number variables show theorem integer 
edb predicates database 
exists datalog program describes conjunctive queries variables database 
proof sketch show construction case predicates arity 
program describe conjunctive queries ans temp ans ans ans ans ans ans temp temp temp temp temp temp temp temp temp ffl distinct variables 
easy see similar construction provide program describes conjunctive queries larger arities 
mentioned fixed datalog program bounds arity results bound cause limitation 
focus arity results queries answer provide data datalog limited 
limitation related number variables 
fo set sentences order logic ahv variables 
note variable reused wanted quantification 
relates queries described datalog program formulas expressible order logic bounded number variables 
states query may arbitrary number variables appropriate reuse bounded number variables suffice 
lemma datalog program maximum number variables occurring rule expressible equivalent query fo 
proof sketch variables appearing rules description ans descr show equivalent order sentence variables 
proof induction number resolution steps construct rule 
rule claim true 
doing step resolution literal unified rule head 
variables reused existentially quantified extra variables rule 
limitation number variables program prohibits description set conjunctive queries schema set supported common powerful sources 
disregard repeated variables head conjunctive queries assume result predicate arity theorem database schema relation arity 
datalog description exists boolean query expressible 
particular datalog description describe source answer conjunctive queries fix arity answer 
order prove need prove lemma lemma database consist binary relation contains self loops 
question clique expressed conjunctive query variables fo gamma proof sketch question clearly expressed query ans gamma gamma query expressed ahv fo gamma formula shown playing ehrenfeucht fraiss game see ahv structures clique self loop clique self loop 
ready prove theorem 
proof loss generality contain binary predicate suppose description exists 
maximum number variables rule conjunctive query expressible fo lemma 
clique self loop theorem points serious limitation datalog descriptions 
rqdl description language limitations datalog description powerful information sources proposing powerful query description language 
rqdl relational query description language datalog rule language description query capabilities 
proposed describing query capabilities information sources 
shows advantages datalog descriptions schema specific description refer specific relations arities schema specific source 
way descriptions concise gracefully handle schema evolution 
formal specification extended rqdl provably allows describe large sets queries 
example prove extended rqdl default refer extended rqdl rqdl datalog describe set conjunctive queries 
furthermore reduce rqdl descriptions terminating datalog programs function symbols 
consequently decision conjunctive query expressed rqdl description reduced deciding expressibility query resulting datalog program 
note reduction rqdl datalog function symbols important ffl reduces comparison expressive power datalog rqdl comparison datalog datalog function symbols 
ffl reduces decision procedure expressibility algorithm 
allows give complete solution cbr problem rqdl 
subsections demonstrate rqdl description source capabilities define syntax semantics rqdl 
section describes reduction rqdl descriptions datalog programs function symbols section proceeds give algorithms query expressibility rqdl description cbr problem rqdl descriptions 
rqdl query description support schema independent descriptions rqdl allows predicate tokens place relation names 
furthermore allow tables arbitrary arity column names rqdl provides special variables called vector variables simply vectors match sets relation attributes appear query 
vectors stand arbitrarily large sets attributes 
property eventually allows description large interesting sets conjunctive queries set conjunctive queries 
example illustrates rqdl ability describe source capabilities referring specific schema 
example demonstrates rqdl program describes conjunctive queries schema 
subsection describes formal syntax semantics rqdl 
go ahead examples introduce notation 
named attributes conjunctive queries notational convenience slightly modify query syntax refer components tuples attribute names column numbers 
example consider relation book schema book title isbn 
write book subgoals explicitly mentioning attribute names writing ans book equal write ans book title isbn equal named attributes rest 
predicate set named attributes list attributes 
connection scheme sql syntax evident 
example consider source accepts queries refer exactly relation pose exactly selection condition source schema 
ans item equal rqdl description describes query ans books title isbn equal intuitively map relation books set attribute variable pairs isbn zg item declares variable maps variables set attribute variable pairs mapped maps variables subgoal token maps attribute name variable map attribute names map predicate tokens belong sort tokens 
notice rqdl descriptions queries rectified 
rqdl descriptions completely schema independent 
example assume put selection condition title attribute relation 
modify rqdl description follows ans item name equal replacement name forces selection condition refer name attribute 
rqdl description describes conjunctive queries schema 
example ans cond ii cond cond iii cond item equal cond iv cond item item equal cond cond rectified conjunctive query arithmetic description describes 
rule deals particular capability rule describes arbitrary projection capabilities condition 
third rule describes selection attribute condition 
fourth rule describes join variable 
second rule augments conditions necessary new literals create conditions conjunctions predicates arbitrary length 
union carries attribute list augmented condition 
formal syntax semantics rqdl full syntax rqdl appears appendix fig 

rqdl description finite set rqdl rules 
description semantics rqdl generalization description semantics datalog account existence vectors 
start defining expansion rqdl description 
definition rqdl description particular idb predicate ans 
set expansions smallest set rules ffl rule ans head predicate ffl substitution general unifier resolvent gamma unification unification extends vectors way 
vector unify vector yielding vector 
vector unify set consisting attribute variable pairs yielding set example unify attr attr yielding attr attr argument list specific type define union mean vector vectors sets attribute variable pairs 
define item mean item mean means variable belongs set attribute variable pairs maps attribute name 
constant 
token 
variable 
vector set attribute variable pairs 
define subset mean vectors sets attribute variable pairs appear head rule addition subset subgoal 
intuition subset allows arbitrary projections 
call contain vectors ground 
safety observe binding pattern constraints 
particular vectors appear safe defined ffl vector appears edb idb subgoal safe 
ffl vector appears subgoal union safe safe 
ffl vector appears subgoal subset safe safe 
definition description semantics section define description semantics rqdl 
definition set queries described rqdl program set terminal expansions subset expansions containing edb predicates predicate tokens body 
valid terminal expansion terminal expansion ground evaluate true set instantiated terminal expansions ip rqdl description set rectified conjunctive queries belongs set terminal expansions mapping rqdl rule conjunctive query 
maps token constant 
note consider relation names constant type 

maps vector set attribute variable pairs replace predicate subgoal variable appears predicate subgoals subgoal form union subgoal form item includes pair subgoal form item includes pair subgoal form subset maps subset 

drops subgoals 
set described queries rqdl description designated predicate ans ans understood set safe instantiated terminal expansions example refer rqdl description example 
rqdl rule ans union item item equal subset terminal expansion rqdl description 
particular rule derived rqdl description rules iv ii order 
conjunctive query ans equal instantiated terminal expansion rqdl description instantiation rule particular ffl map predicate names respectively 
ffl map attribute names respectively 
ffl maps maps maps necessarily union 
ffl map respectively 
ffl maps 
subgoals dropped 
conjunctive query head predicate ans rqdl description say expressible exists described referring example query ans equal expressible description equivalent note rqdl easily extended allowing tokens variables place predicate names describe capabilities information sources understand process higher order logics example sources understand hilog logic kl 
pursue issue 
section explains rqdl describe capabilities networks mediators 
rqdl mediator capabilities revisit mediation architecture 
dynamic environment internet intranet big organisation integrating information able leverage existing integration machinery wie 
specifically mediator exists offers integrated view information want access able accessing sources integrates 
networks mediators possible necessary 
mediator source mediator means course able describe mediator capabilities 
explained assume mediators query processing capabilities allow handle conjunctive query data integrate 
expressiveness results section datalog describe capabilities mediator 
rqdl powerful task 
consider mediator integrates sources descriptions sources assume wrapper understands answer predicate ans ans rqdl program dm describes capabilities mediator ans cond cond choose cond cond item equal cond cond item item equal cond cond choose choose ans 
choose ans 
similarity description example evident 
dm describes conjunctive queries mediator answer conjunctive query combines results queries accepted sources mediator integrates concatenation dm description dm obviously automatically generated 
discuss efficient algorithm deciding query expressible rqdl description 
algorithm reduction query description simple standard schema facilitates reasoning relations attribute names 
reducing rqdl datalog function symbols deciding query expressible rqdl description requires matching rqdl description query 
challenging problem vectors match non atomic entities sets variables making matching harder 
problem identified brute force approach effect tries generate instantiated terminal expansions bottom vectors match sets derivation 
unfortunately approach soon leads complicated problems forced restrict applicability matching algorithms subset rqdl descriptions 
particularly tough problem existence unsafe rules vectors head 
brute force approach may derive extended facts vector half specified know attr variable pairs contain 
note applicable rqdl descriptions may exhibit behavior 
section algorithm avoids problems reducing problem query expressibility rqdl descriptions problem query expressibility datalog function symbols reduce rqdl description corresponding description datalog function symbols 
reduction idea database db reduced equivalent database db attribute names relation names db appear data schema db call db standard schema database 
rewrite query refers schema db standard schema rewrite description datalog description function symbols refers standard schema 
subsection presents conceptual reduction database standard schema database 
presents rewriting queries subsection presents rewriting rqdl descriptions 
subsections starts examples continues formal definition reduction skipped reading 
reduction database standard schema database order reason relation names attribute names queries conceptually reduce original database standard schema database relation names attribute names appear data manipulated need higher order syntax 
reduction example formally define reduction database standard schema counterpart 
example consider database db schema au isbn subj isbn 
au isbn smith jones subj isbn logic corresponding standard schema database db consists relations tuple table name tuple id attr tuple id attr name value common standard schema databases 
running example db tuple table name tuple id au smith isbn au jones isbn subj logic isbn subj isbn attr tuple id attr name value au smith isbn au smith au smith isbn isbn au jones isbn au jones au jones isbn isbn subj logic isbn subj logic subj logic isbn isbn subj isbn subj subj isbn isbn notice invented tuple id tuple original database 
definition database db say standard schema database corresponding db smallest database db 
schema tuple table name tuple id attr tuple id attr name value 
tuple db tuple tuple db attribute tuple attr db reduction queries standard schema queries rqdl expressibility algorithm reduces conjunctive query database db corresponding query standard schema database db reduction correct sense result asking query db equivalent modulo tuple id naming reduction standard schema result db 
illustrate query reduction consider couple examples 
consider boolean query schema example 
ans au isbn subj isbn equal equal query reduced query tuple ans ans tuple tuple attr isbn attr isbn equal attr subj equal notice ordinary subgoal introduce tuple subgoal invent tuple id attribute introduce attr subgoal 
tuple id result relation ans simply ans result relation attributes 
query head attributes single conjunctive query reduced non recursive datalog program 
example consider query returns authors books subject 
ans au isbn au isbn subj isbn equal equal query reduced program rule defines tuple part standard schema answer rules describe attr part 
tuple ans ans au isbn tuple tuple attr isbn attr isbn equal attr au attr subj equal attr ans au isbn au tuple tuple attr isbn attr isbn equal attr au attr subj equal attr ans au isbn isbn tuple tuple attr isbn attr isbn equal attr au attr subj equal general reduction accomplished procedure procedure reduction head ans generate program rules 
rule head tuple ans ans 
attribute rule head attr ans 
rules body constructed steps subgoal form am xm invent associate unique variable variables bind tuple id standard schema database call tuple id variables include standard schema query body subgoal tuple attribute include standard schema query subgoal attr 
add body equality subgoals original query 
variable token constant 
easy see obvious constraints exists inverse reduction 
show reduce rqdl descriptions datalog descriptions standard schema databases 
reduction rqdl programs datalog programs operating standard schema previous sections showed schema information relation attribute names data standard schema databases 
idea reduce rqdl descriptions datalog descriptions higher order features vectors 
particular reduce vectors tuple identifiers 
intuitively vector matches arguments subgoal tuple identifier associated subgoal finding attr variable pairs vector match 
vector result union vectors associate new constructed tuple id function tuple id correspond see reduction carefully produces program terminates despite function 
example consider simple interesting rule description ans item name rqdl rule describes conjunctive queries refer schema relation constraint schema relation contains attribute name 
description reduces datalog description tuple ans ans tuple attr name equal attr ans tuple ans ans attr equal vector variable reduced variable matches tuple id item name reduced predicate attr name 
example description example describes boolean conjunctive queries 
reduces datalog description function symbols tuple ans ans cond cond tuple cond valid cond attr equal cond equal cond attr attr equal cond equal equal cond ffl subset lag 
reduction rule independent reduction rules 
second rule notice reduced produced predicate valid valid predicate defined rules fig 
see appendix included reduced datalog descriptions 
valid constructs new tuple id restricted form associated attributes associated role valid simulate union replaces allowing generation arbitrary terms follow order mentioned 
intuition valid terms tuple id variables bind tuple ids constructed tuple ids terms built tuple ids 
assuming total order tuple ids standard schema database valid creates term tuple ids appear sorted order repeated 
example valid bind 
description include default rules fig 
sure attributes tuple ids attributes tuples id constructed formally rqdl description reduced datalog description steps 
include rules figures 
reduce rule description datalog functions follows reduce predicates involve vectors described subsection 
analogy union includes attr var pairs 
notice simplicity need include rules example 
subgoal form include reduced rule subgoal tuple 
reduction 
subgoal form item token constant include reduced rule subgoal attr reduction 
subgoal form union replace reduced rule instances include subgoal valid reductions 
subgoal form subset reduction reduction replace rule subset appears set subset flag variable rule see drop subset subgoal 
head form ans reduce tuple ans 
head form ans attr var set follow procedure generate datalog rules reduces 
intuition subset flag rule variable follows assume existence subgoal subset rule said earlier appear rule head head appear ordinary subgoal say 
subset subgoal means rqdl rule describes conjunctive queries head attribute set projection attribute set relation reduction replace reduction reduction saying effectively attribute set attribute set set flag rule variable subset flag sure consider described conjunctive queries include projections theorem rqdl description reduction datalog functions 
db canonical standard schema database query applied db terminates 
crux suffices see generation terms fall infinite loop tuple id database appear twice constructed tuple id remaining sections denote datalog functions datalog section explains semantics datalog functions shows solve cbr problem rqdl algorithms developed datalog sections 
way handle subset defining ordering constructed tuple ids defining means atomic values 
subset just reduced correspondingly reductions attr attr valid attr attr valid default rules generation attr tuples qed cbr rqdl descriptions reduction previous section allows formulate solution expressibility problem rqdl descriptions 
particular show qed small changes datalog prove modified qed sound complete fragment generated rqdl reduction 
proceed discuss cbr scheme rqdl uses rqdl reduction reduce cbr problem rqdl cbr problem datalog illustrate qed rqdl example 
notice designated predicates predicates tuple attr 
example consider query ans books au description ans au ans au reduction query tuple ans ans tuple attr au attr equal equal attr ans tuple attr au attr equal equal canonical db tuple books attr au attr equal reduction description rectification tuple ans ans tuple attr au attr equal equal attr ans tuple attr au attr equal equal tuple ans ans tuple attr au attr equal equal attr ans tuple attr au attr equal equal notice didn include rules figures valid rules reduced description original description didn contain 
run algorithm canonical db extended facts produced tuple ans ans books attr au attr equal 
attr ans books attr au attr equal 
tuple ans ans books attr au attr equal 
attr ans books attr au attr equal output algorithm includes extended facts tuple id group extended facts tuple id notice group consisting extended facts corresponds exact conjunctive queries reduction say expressible description 
presenting theorem states condition rqdl expressibility important observations ffl lemmata theorem hold datalog ffl conjunctive query fq ng set standard schema queries reduces 
heads queries 
pointed section body 
form tuple ans term denotes tuple id form attr call query id previous example query id ans 
theorem query expressible rqdl description subset exists maximal set fq ng queries described reduced description id maximal means fq includes described queries query id referring example maximal set fq set corresponding queries extended facts 
observe exact value tuple ids important identify components attributes relation 
say reduced query datalog expressible reduced datalog description exists equivalent tuple id naming described proof sketch theorem easy see case rqdl description contains vectors 
rqdl description contains vectors intuition follows conjunctive query projection fq ng set standard schema queries reduces 
rqdl description red reduced datalog description 
direction reduction directly maps rqdl rules rules producing tuple subgoals ensures expressible expressible red default rules fq expressible 
direction straightforward absence subset subgoal 
presence subset crux fq maximal set described queries query id result follows theorem 
theorems algorithm qed see section answer expressibility question rqdl 
qed generates possible extended facts tuple attr 
check necessary frozen tuple attr facts produced id ii corresponding queries equivalent 
algorithm properly change needs definition supporting set fact due reduction introduced sections implicit connection fact tuple const facts attr const tuple fact attribute facts created reduction 
connection explicit modifying definition supporting set follows definition supporting set modified ordinary fact produced application datalog rule em reduced datalog description database db consists canonical database cdb facts mapping rule db db 
set supporting facts supporting set respect smallest set subset exists fq mg projection taken care subset directly maps subset lag 
effect correspondingly changing rqdl datalog reduction procedure 
ffl cdb ffl cdb set supporting facts ffl tuple attr canonical db attr ffl set smallest set equality facts includes equivalence relation included modifications presence subset subgoals explained subset subgoal reduced statement setting subset lag attached rule variable reduces 
execution qed algorithm tuple fact generated rule set subset lag annotation tuple id annotation execution complete theorem determine expressibility 
consider example 
example rqdl description ans item au example query ans au au subj expressible description 
reduction description tuple ans tuple attr au equal attr attr valid equal attr attr valid equal plus rules defining valid predicate see appendix reduction query set fq tuple ans ans au tuple attr au attr subj attr ans au au tuple attr au attr subj canonical db tuple attr au attr subj equal extended facts produced algorithm account modification definition supporting sets introduced tuple ans attr au attr subj equal 
valid attr au attr subj equal 
attr au attr au attr subj equal 
attr subj attr au attr subj equal look detail extended fact produced 
application rule datalog program generates tuple ans attr au equal 
frozen regular constants 
reduction example simplified valid rule fires generates valid attr au equal 
second rule program consequently fires gives attr au attr au equal attr subj attr subj equal modified definition supporting set need augment supporting set tuple ans include attr subj getting extended fact 
performing augmentation step take exponential amount time 
valid rule fires generate second rule program fires generate 
standard schema queries reduction expressible reduced description original query pointed expressible rqdl description 
maximal set described queries produced consisting corresponding queries larger set reduced queries 
hand description ans item au subset described modified description 
reduction description exactly set subset lag rule 
modification described previously theorem algorithm decide correctly described modified description 
consider complicated example 
example source accept queries perform join relation relation set attributes 
description source simplification description example 
ans cond cond union cond cond item item equal cond cond reduction description rectification tuple ans cond cond tuple cond valid equal equal cond attr attr equal cond equal equal cond tuple attr attr valid equal attr attr valid equal plus rules fig 
see appendix 
user query submitted source ans au ln subj au subj ln ln stands name produces extended canonical db tuple attr au attr subj tuple attr ln equal equal equal standard schema reduction user query tuple ans ans au ln subj tuple tuple attr au attr subj attr ln equal equal equal attr ans au ln subj au tuple tuple attr au attr subj attr ln equal equal equal attr ans au ln subj ln tuple tuple attr au attr subj attr ln equal equal equal attr ans au ln subj subj tuple tuple attr au attr subj attr ln equal equal equal running algorithm canonical db produces extended facts valid attr au attr subj tuple attr ln equal equal 
cond attr ln equal 
cond attr au attr subj tuple attr ln equal equal 
cond attr au attr subj tuple attr ln equal equal equal 
tuple ans attr au attr subj tuple attr ln equal equal equal 
valid attr au attr subj tuple attr ln equal equal equal 
attr au attr au attr subj tuple attr ln equal equal equal 
attr ln attr au attr subj tuple attr ln equal equal equal 
attr subj attr au attr subj tuple attr ln equal equal equal maximal set described queries query id corresponding equal set standard schema queries reduction user query 
user query expressible rqdl description theorem 
cbr problem rqdl solve cbr problem query reduced rqdl description steps showing extended facts produced sake brevity 
ffl generate set relevant described queries output algorithm glueing tuple attr subgoals supporting set 
words create corresponding standard schema queries extended facts inverse reduction sets id body queries original schema 
relevant queries description respect query 
ffl query schema number relevant queries views schema apply answering queries views algorithm qia lmss problem 
notice presence subset subgoals rqdl description qed algorithm produces candidate queries set subset lag annotation 
principle annotations ignored solution cbr problem assume mediator capability projections locally projections handled final rewriting mediator 
complexity procedure non deterministic exponential input size 
obvious discussion subsection binding requirements holds rqdl 
example consider source expects selection condition attribute au attribute subj 
rqdl description source ans item au ans item subj description reduces tuple ans tuple attr au equal tuple ans tuple attr subj equal attr attr valid equal attr attr valid equal plus rules fig 
see appendix 
user query ans subj au isbn books subj au isbn equal logic equal smith obvious answered combination queries expressible description send selection condition au subj intersect results 
reduces tuple ans ans subj au isbn tuple books attr au attr subj attr isbn equal logic equal smith attr ans subj au isbn subj tuple books attr au attr subj attr isbn equal logic equal smith attr ans subj au isbn au tuple books attr au attr subj attr isbn equal logic equal smith attr ans subj au isbn isbn tuple books attr au attr subj attr isbn equal logic equal smith canonical db tuple books attr subj attr au attr isbn equal logic equal smith extended facts generated algorithm qed tuple ans books attr subj attr au attr isbn equal logic 
tuple ans books attr subj attr au attr isbn equal smith 
attr subj books attr subj attr au attr isbn equal logic 
attr au books attr subj attr au attr isbn equal logic 
attr isbn books attr subj attr au attr isbn equal logic 
attr subj books attr subj attr au attr isbn equal smith 
attr au books attr subj attr au attr isbn equal smith 
attr isbn books attr subj attr au attr isbn equal smith result inverse reduction candidate conjunctive queries binding information ans bff subj au isbn books subj au isbn ans subj au isbn books subj au isbn input algorithm get expected answer 
related projects dealt data integration structured sources lmr hm 
projects ignored problem different limited query capabilities information sources important integration systems deal heterogeneous sources 
follows discuss approaches taken newer generation projects discuss theoretical area 
hermes capabilities sources literals explicitly specify parameterized calls sent sources 
unfortunately reduces interface integration system sources limited set explicitly listed parameterized calls 
suggested grammar approach describing query capabilities lru datalog tokens purpose 
works focused showing compute query capabilities description algorithm applies specific classes descriptions 
mentioned improved result lru problem answering query infinite number views 
studies rqdl powerful datalog gives expressiveness results 
rqdl proposed allow capabilities descriptions schema specific 
furthermore proposed mediator architecture includes cbr 
show rqdl expressive datalog 
furthermore cbr algorithms include arbitrary union subset provide proofs complexity results 
brevity doing full rectification 
showing extended facts interest 
information manifold focuses capabilities description sources web consider recursion :10.1.1.38.7636
expressive power capabilities describing mechanism strictly datalog 
disco system describes capabilities sources context free grammars appropriately augmented actions 
disco enumerates plans initially ignoring limited wrapper capabilities 
checks queries appear plans wrapper grammars rejects plans containing unsupported queries 
disco strategy expensive doing capabilities rewriting ensures queries emitted wrappers answerable source 
garlic system combines capabilities rewriting cost optimization 
assumption variables mentioned query available wrapper 
compromises expressiveness description language greatly simplifies proposed algorithm 
interesting capabilities descriptions terms plans supported wrappers 
additional assumptions point regarding class plans described 
rqdl handling constructed tuple ids skolem functions close ideas mai kl 
subsection discusses tokens description binding requirements compares approach binding patterns ull 
describing binding requirements datalog noticed sources answer queries specific binding requirements 
mentioned section tokens specify constant expected fixed position query implicitly define binding requirements described queries 
contrast uses explicit enumeration accepted binding patterns ull described query achieve goal 
example consider datalog rule ans rule describes join query requires bindings third argument relation third argument relation notation ull write rule follows ans rule describes binding requirements rule 
explicitly specifying accepted binding patterns rule presents number problems 
particular obscures distinction variable constant rule 
complicates answering query expressibility question 
importantly explicit specification binding patterns generalize presence recursion 
query capabilities described datalog program possible enumerate binding patterns description encodes possibly infinite number described queries different bound variables 
hand tokens allowed naturally extend description binding requirements case datalog programs 
difference clearer example 
example revisit example describes particular bibliographic source 
datalog description source ans pg books pg ind ind index ind ind index source describes infinite family conjunctive queries ans pg books pg ans pg books pg index ans pg books pg index index queries family increasing number bound variables binding patterns look tokens allows describe binding requirements succinctly 
discussed problems describing query capabilities sources ii descriptions source wrapping mediation 
considered datalog variant called describing set queries accepted wrapper 
provide algorithms solving expressibility ii cbr problems 
algorithm decides query equivalent queries described datalog program 
algorithm wrapper 
second algorithm run mediators finds query computed queries expressible datalog program 
study expressive power datalog 
show powerful binding patterns reach important negative result datalog describe query capabilities certain powerful sources 
particular show datalog program describe conjunctive queries schema 
program describes boolean conjunctive queries schema 
direct consequence result datalog model fully fledged relational dbms 
subsequently describe extend rqdl provably expressive language datalog 
extra power mainly result vector variables match sets attributes arbitrary length 
consequence extra power ability automatically derive description capabilities mediator descriptions wrapper capabilities 
existence vector variables hard brute force implementation mediator wrapper algorithms rqdl 
get problem providing reduction rqdl descriptions datalog augmented function symbols 
reduction discuss complete algorithms solving expressibility cbr problem 
focused exclusively conjunctive queries 
plan extend queries queries involving aggregates negation 
variable names changed authors wish serge abiteboul help formalizing presentation datalog proof theorem jeff ullman fruitful discussions 
ahmed pegasus heterogeneous multidatabase system 
ieee computer 
acps candan papakonstantinou subrahmanian 
query caching optimization distributed mediator systems 
proc 
sigmod pages 
ahv abiteboul hull vianu 
foundations databases 
addison wesley 
asu aho sethi ullman 
compilers principles techniques tools 
addisonwesley 
chen kifer warren 
hilog foundation higher order logic programming 
journal logic programming february 
cm chandra merlin 
optimal implementation conjunctive queries relational databases 
proceedings ninth annual acm symposium theory computing pages 
dks du krishnamurthy 
shan 
query optimization heterogeneous dbms 
proc 
vldb pages vancouver canada august 
hammer extracting semistructured information web 
workshop management semistructured data acm sigmod conf 
laura haas donald edward wimmers jun yang 
optimizer heterogeneous systems non standard data search capabilities 
special issue query processing non standard data ieee data engineering bulletin december 
haas wimmers yang 
optimizing queries diverse data sources 
proc 
vldb 
hm hammer mcleod 
approach resolving semantic heterogeneity federation autonomous heterogeneous database systems 
intl journal intelligent cooperative information systems 
hammer breunig garcia molina nestorov vassalos 
wrappers tsimmis system 
proc 
acm sigmod pages 
kim resolving schematic heterogeneity multidatabase systems 
distributed parallel databases 
kl kifer lausen 
logic higher order language reasoning objects inheritance scheme 
proc 
acm sigmod conf pages portland june 
lmr litwin mark roussopoulos 
interoperability multiple autonomous databases 
acm computing surveys 
lmss levy mendelzon sagiv srivastava 
answering queries views 
proc 
pods conf pages 
levy rajaraman ordille :10.1.1.38.7636
querying heterogeneous information sources source descriptions 
proc 
vldb pages 
lru levy rajaraman ullman 
answering queries limited external processors 
proc 
pods pages 
mai maier 
logic objects 
minker editor preprints workshop foundations deductive database logic programming washington dc usa august 
papakonstantinou gupta garcia molina ullman 
query translation scheme rapid implementation wrappers 
proc 
dood conf pages 
papakonstantinou gupta haas 
capabilities query rewriting mediator systems 
appear 
papakonstantinou gupta haas 
capabilities query rewriting mediator systems 
proc 
pdis 
qia qian 
query folding 
proc 
icde pages 
rajaraman sagiv ullman 
answering queries templates binding patterns 
proc 
pods conf pages 
ramakrishnan sagiv ullman vardi 
proof tree transformations applications 
proc 
pods conf pages 
subrahmanian hermes heterogeneous reasoning mediator system 
www cs umd edu projects hermes overview 
thomas heterogeneous distributed database systems production 
acm computing surveys 
tomasic raschid valduriez 
scaling heterogeneous databases design disco 
technical report inria 
ull ullman 
principles database knowledge base systems vol 
ii new technologies 
computer science press new york ny 
vp vassalos papakonstantinou 
describing query capabilities heterogeneous sources 
proc 
vldb conf pages 
wie wiederhold 
mediators architecture information systems 
ieee computer 
rqdl grammar table contains complete syntax rqdl 
definition valid predicate contains rules define predicate valid see subsection 
hans query hans query ans namei subgoal list may predicate namei token predicate namei namei namei rqdl syntax valid tuple tuple valid tuple tuple valid tuple valid tuple tuple valid valid tuple tuple valid tuple valid valid tuple tuple valid tuple tuple valid valid tuple valid valid tuple tuple valid valid tuple tuple valid valid tuple valid default rules generation valid gamma terms 
