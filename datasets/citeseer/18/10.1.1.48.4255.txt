continuations semantics andrew wilson february semantic compositionality meaning phrase depends meaning subphrases desirable property language possess admits proofs structural induction terms language 
regular expressions propositional logic compositional languages sense 
programming languages said compositional semantics strictly compositional semantics defined 
instance consider tennent principle abstraction syntax domain language may definition invocation mechanisms abstracts soon allow naming language attach meanings symbols inherent syntactic structure 
suppose pascal program fragment mystery say means merely structure meaning mystery mystery 
need parameterize semantics compiler writers call symbol table partial function names precompiled meanings 
longer strict compositionality meaning phrase may depend meanings defined 
introduced little context sensitivity language 
allow recursive definitions overcome difficulties 
structural induction treated names macros expanded 
alternatively add special definition expansion cases induction steps proofs expand names fly 
involve parameterizing induction principle symbol table adding special induction cases add definitions table 
named expression invoked mentioning name 
see chapter turns recursion trick despite fact non founded recursive abstracts 
kind parameterized induction principle kind parameterized compositionality mccarthy calls principle recursion induction 
rule called recursion induction making arguments usual formulations recursive function theory mathematical induction 
rule may regarded theorems recursive function theory giving status rule inference 
recursion induction may described follows suppose recursion equation defining function xn ff xng right hand side conditional expression non trivial cases suppose calculation xn rule converges certain set tuples ii functions xn xn satisfy equation substituted may conclude xn xn tuples xn set mccarthy mention symbol tables clear assumes 
know refers right hand side equation 
mention structural induction definition 
assumed 
need check satisfy equation 
rewrite definition things clearer understand role set need compute mathematical device talk termination function extension termination concept termination mathematically tangible 
redefine recursion induction follows 
language proposition wish prove programs written symbol table 
show prove arbitrary constructor assuming holds subphrases holds program 
take axiomatic definition modifies scope prove proven take axiomatic prove body proven name naming preserve kind compositionality associated induction principle 
language feature 
interesting question scope essay 
language feature interested commands goto label control program may jump different part program labelled label clearly semantics language compositional meaning phrase may depend solely meanings textual subphrases 
treat jumps recursive macros expanded fly jumps return 
kind compositionality labelled jumps 
despite big difference labelled jumps procedures things common invoked name rely code foreign program phrase occur 
involve non local transfer control van wijngaarden insight treat control transfers procedure invocations crucial property procedures return program 
identify control transfers rest program 
modern terminology procedures known continuations 
compositionality labelled jumps induction principle recursion induction 
pay price rewrite programs continuations called continuation passing style programming 
gives semantics labelled jumps practical style program 
reason cited morris procedures longer named subprograms treat goto special return gotos tagged 
clearly write lot procedures ordinarily 
leads unnatural unreadable programming style 
effect induction principle 
continuations partitioned programs past 
past determines computer state evaluated continuation determines done past 
compositionality property sequentialized meaning phrase depends past 
recursion induction reduced induction dynamic evaluation sequence program 
viewpoint longer mathematician manipulating algebraic structure computer sequence instructions 
build continuations 
phrase know 
phrase contain inherently past program 
computer takes entire program breaks evaluation strategy 
start entire program easy determine program fragment 
instance program continuation clearly modulo packaging things nicely 
compositionality turned upside building program meanings bottom building meanings top 
consider pure calculus consisting variables abstractions applications 
transform direct style program program transform see cx mnc clauses take values variables abstractions 
captures idea values intermediate tokens computation manipulated represented third clause bit harder understand 
continuation mnc continuation expects result evaluating mnc continuation expects result evaluating phrase mnc tells apply continuation clearly simulates right call value evaluation application 
simulate call name evaluation replacing third clauses implement call name call value 
said operates lower level result confirmed 
reynolds advocated definitional interpreters evaluation order defined language depend defining language 
definitional interpreters possess property 
plotkin proved proved results theorem plotkin simulation psi eval eval phi eval eval indifference eval eval psi psi phi phi ffl call value ffl call name indifference result shows intended evaluation strategy program encoded relevant form 
evaluation program indifferent evaluation strategy interpreter 
look closely transform see flow control values flow left right continuation term 
consider example cx cy mnc underlined abstractions introduced transform 
programs hard understand reason 
practical code generation purposes special algorithms required minimize number 
sabry felleisen note optimizations tend reduce terms fij normal forms 
plotkin calls new redexes administrative redexes administer flow control allow write programs temporal way 
provide mechanics may code 
illustrate sequentialization effect exhibit correspondence term machine code cx push cy push mn apply wand shows may understanding precise exhibiting transformation terms combinatory logic looks similar machine code 
start basic set combinators halt fetch ae ae ae xg apply ae fac return ae cv ae ae pae combinator corresponds sequential composition programs denotes number values flow stack 
right associative rotate tree expressions linear form 
combinators form basis language give language semantics amounts compilation 
give compilation call value calculus return halt fetch return apply example compiled fetch return fetch apply return halt rotated fetch return fetch apply return halt rewrite initialize environment fetch apply return halt looks identical form intuitively derived 
justified original claim lower level 
results see expressive 
implement program 
prove result precisely pure functional language reynolds 
consider call name calculus 
give denotational semantics styles see 
wish show domain included domain exhibit retraction pair phi allow express terms plays role require able represent value mathematically assuming retraction pair hff fii fi ffi ff 
english means ff codes elements fi decodes loss information 
notice ff continuation 
define retraction pair phi 
may seen phi little transform described earlier fij normal forms 
rest devoted general problem construction relations recursively defined domains 
pure functional languages know includes include 
danvy presents transformer calculus extended constants declarations conditionals 
pure calculus 
ct mnc mn stands trivial expressions terminate setting denote values variables abstractions serious expressions don necessarily terminate 
terminology due reynolds 
transform concise wished 
perfect inverse transform 
example cx cy mnc mn fi transforms inverses fi reduction 
galois correspondence 
categorical terms transforms form adjunction 
case equi expressive 
transforms case continuations treated class objects 
restriction means danvy notes continuation variables linear term 
body continuation abstraction 
linearity gives sequential flow control 
means need variable represent continuations 
property exploited transform distinguish functions form represent continuation abstractions represent ordinary abstractions 
restriction restrictive 
purely applicative languages reynolds notes continuations required give semantics 
high level languages designed treated algebraic structures seen implemented purely linear flow control 
originally introduced continuations handle goto constructions function var ae ae ae ind xg ae case ae isd ae isp var ae ae ae 
xg ae ae oe case oe 
ae isp domain outputs domain explicit values 
direct semantics continuation semantics semantics call name calculus phi phi case isd 
phi ffi ffi psi isp inp phi phi psi psi case fi ff 
ind ffi ffi phi isp inp psi psi definition retraction direct continuation semantics jump current linear flow control 
content restriction require ability treat continuations class objects 
having ability enables write programs calculus control evaluation 
seen programs clumsy hard understand 
control flowing linearly need continuations 
nice assume continuation mechanism explicit mention wanted jump 
typically involve programming programming thinking continuations certain special operators added language 
calculus languages operators landin operator label values scheme catch throw mechanism call cc operator 
follow felleisen form call cc operator denote call cc short call current continuation function take current continuation supply argument function called 
argument call cc function shall abbreviate cx mnemonic reminds bound current continuation term 
called labelling catching continuations 
reminds label values imperative languages 
call cc differ major respect necessarily return point call 
apply current continuation result call 
define call cc call cc def cc fc give semantics operator cf cv definition hard understand 
current continuation 
evaluate called function put value apply argument cv pass result continuation 
continuation effect returning call 
call terminate program 
argument looks bit strange denotes continuation function values bound value passed entire expression argument continuation time argument invoked 
control operator provide useful programming constructs 
simplest example abort operator evaluate argument immediately program returning argument result 
abort def cc fv define coroutining mechanism 
collection coroutines initiated parallel caveat may executed time 
implementing parallel processes interleaving code sequential processor stay coroutine program explicitly tells leave resume execution 
action resume suspend current coroutine 
resume def cc cq continuation resumed coroutine continuation current coroutine cq continuation parameter packages resumption current coroutine function implement exception mechanism 
exception error condition raised try divide zero causing execution program halt error raised scope suitable error handler 
represent information passed handler error handle def cc raise def elliot pfenning show exceptions implement backtracking mechanisms logic languages 
require data structure called trail keep track variable bindings 
raise exception say failed jump back choice point removing variables trail bound faulty choice 
friedman show implement intelligent backtracking 
know expressive pure expressive get power adding control operators 
danvy lawall show answer negative providing transformer 
requires inductively defined relation decides jump just part normal linear flow control 
seeing occurs free subexpression declares new continuation identifier 
jump 
transformation essentially modify clause ae cc know class continuations provide power operator second class continuations provide linear flow control 
filinski uses just observations models programming linear categories 
categories model linear logic key feature assumptions exactly proof 
people advocated linearity functional programming main benefits filinski notes naturally express single threadedness transparent destructive updates reduce eliminate need garbage collection 
linearity functional programming means bound variable body function 
continuations gives sequentialization property noticed earlier embedding 
linear modalities course 

give ability copy values internal structure known 
restriction means directly copy functions continuations copy implementations copyable primitives 
price pay lose extensionality may way implement function 
may define functor maps functions specific implementations 
achieve power operator modalities implementer functor 
categorical terms copyable values form subcategory means subcategory copyable values capable representing implementing value linear category 
noted consequence semantic meanings pure terms built bottom meanings terms built top 
suggests kind duality styles 
filinski takes feeling showing duality values continuations 
think continuations lack request values 
see duality way values view past computations continuations view computations 
filinski notes duality call value call name call byvalue values drive control flow onwards call name value requests continuations pull control flow forward 
filinski uses duality define typed symmetric lambda calculus slc functions seen value abstractions continuation abstractions 
models bicartesian closed category 
know nontrivial support fixpoints see filinski assures slc typed need special operator write recursive definitions 
doing lose strong normalization property 
presents surprisingly new problems nontermination viewed special case escaping 
basic properties category hold precisely axioms weak inconsistency results apply look types slc see continuations values dual sense 
type continuation requests value type 
type function values values type function continuations continuations 
know continuations functions values 
overlap argument result continuation 
fact continuation function merely takes value function argument continuation 
ffi page contravariance continuation function value function 
arrow reversal types functions reminds arrow reversal opposite categories 
turn attention categorical products coproducts 
product projection function follows theta dually coproduct injection function product projection continuations theta pair continuations requesting value value 
pair continuations represents pair futures 
pair continuations represent alternative branches computation take projection represents selection particular alternative 
terms values means value value satisfy request whichever value choose 
projection corresponds making choice satisfying request injecting coproduct 
type continuation 
exploration attest values continuations dual 
means cont operator contravariance seen importantly involution id griffin suggest type accepting continuation 
arrived considering type control operator 
consider phrase cc 
occurs program context xi 
suppose type program xi cc surrounding context xi thought function type value type note type expression cc 
function cram context xi current continuation variable type accepts argument encapsulates xi evaluating mean evaluating xi point 
term know result evaluating continuation result argument 
sequentialization effect 
xi type result evaluating xi hidden continuation type 
assumed current continuation invoked evaluating 
terminates top level 
behaves abort operator away surrounding context 
means result result entire program 
declared result program type type 
means type noted type cc type control operator argument self type depends type expression part 
stuff paradoxes case simply means assign type expression cc 
startling fact illustrated follows 
consider complete program type cd type consistent 
curry howard view propositions see sense false empty type 
important consequences 
type entire program 
second type accepting continuation variously denoted 
means type control operator gives involution property desired cont operator 
viewing propositions types proof looks rule double negation classical logic 
confirms duality values continuations 
categorically value global element morphism terminal object type 
continuation morphism type initial object 
diagrammatically past diagram shows categorical view matches temporal intuitions 
looking perspective 
tells began computation point past 
forgotten initial inputs know message 
know computations done past see result produced 
similarly know computations know demand input door just way past window past 
remains difficulty type entire program 
continuation accepts value returns type 
surely type 
mean terminating programs 
re examine example led absurd typing 
current continuation complete program 
intuitively program terminated continuation 
cd meaningful 
solution restrict occurence operators ad hoc suggest wrong theory 
alternatively metaphysical say continuation 
program result report programmer continuation transmitted eyes read monitor continuation decoded brain occipital lobes enter eternity programmer consciousness continuation 
seriously say types result imperative operation writing value screen 
sense expect imperative operation return value 
side effect par 
think denoting unknown 
really give types values known 
difficulty typing value type depends argument 
type argument depends type value pass argument continuation accepts value determined 
know represents law double negation elimination 
meyer wand show term transform type transform ffl 
identify types types result program 
seen need operator reverse translation arbitrary pun intended 
terms type corresponds rule double negation 
typing rule means infer type term necessarily having compute 
sort classical program evaluation logic classical type system 
classical logic convenient intuitionistic logic precisely take shorts cuts proofs 
price convenience loss precision 
girard notes classical logic denotational semantics identifying proofs proposition 
classical logic provability proofs 
derive type intuitionistically inherent self 
discovery pseudo classical typing programs people attempting derive programs classical proofs 
murthy shown transform double negation embedding classical logic intuitionistic logic 
uses friedman translation replace instances fresh proposition embedding intuitionistic logic minimal logic 
extract programs classical proofs way extract programs intuitionistic proofs translating double negation eliminations instances pseudo classical logic satisfy property subject reduction 
type system able intermediate states proof 
murthy shows classical logic admit subject reduction modified logic due translation 
gives example consider sentence fairly simple classical proof omit yields program cc ch axiom chm function code guess required check 
test succeeds halt 
jump back chose choose murthy admits program provide evidence truth wait counterexample change guess accordingly 
reminds refutation completeness prolog certainly backtracking happening 
appel jim 
continuation passing closure passing style 
acm symposium principles programming languages popl 
clinger revised revised report scheme 
technical report indiana university mit laboratory computer science 
danvy 
back direct style 
proceedings fourth european symposium programming pages 
springer verlag 
lecture notes computer science 
danvy lawall 
back direct style ii class continuations 
acm symposium lisp functional programming pages 
elliot pfenning 
semi functional implementation higher order logic programming language 
preprint 
felleisen friedman duba 
reasoning continuations 
symposium logic computer science 
felleisen friedman duba 
syntactic theory sequential control 
theoretical computer science 
preliminary version 
filinski 
declarative continuations investigation duality programming language semantics 
pitt rydeheard dybjer pitts poign editors category theory computer science pages 
springer verlag 
lecture notes computer science 
filinski 
linear continuations 
acm symposium principles programming languages popl 
fischer 
lambda calculus schemata 
proc acm conference proving assertions programs pages 
sigplan notices sigact news jan 
friedman haynes kohlbecker 
programming continuations 
pepper editor program transformations programming environments 
springerverlag 
friedman 
classically intuitionistically provably recursive functions 
scott muller editors higher set theory pages 
springer verlag 
lecture notes mathematics 

girard 
geometry interactions 
griffin 
formulae types notion control 
proceedings seventeenth annual acm symposium principles programming languages popl page 
holmstrom 
linear functional language 
proceedings workshop implementation lazy functional languages pages 
hopcroft ullman 
automata theory languages computation 
addison wesley 
isbn 
poign 
note inconsistencies caused fixpoints cartesian closed category 
theoretical computer science 

orbit optimizing compiler scheme 
proceedings sigplan symposium compiler construction pages 
sigplan notices 
lafont 
linear machine 
theoretical computer science 
landin 
mechanical evaluation expressions 
computer journal 
landin 
correspondence algol church lambda notation parts ii 
communications acm 
mazurkiewicz 
proving algorithms tail functions 
information control 
mccarthy 
mathematical science computation 
proceedings ifip congress pages 
meyer wand 
continuation semantics typed lambda calculi summary 
parikh editor logics programs pages 
springer verlag 
lecture notes computer science 
moggi 
notions computations monads 
information control july 
morris jr bonus van wijngaarden device 
communications acm 
murthy 
evaluation semantics classical proofs 
symposium logic computer science 
murthy 
classical logic programming language typing nonlocal control 
preprint 
plotkin 
call name call value calculus 
theoretical computer science 
reynolds 
simple language principle completeness concept 
communications acm 
reynolds 
definitional interpreters higher order programming languages 
proceedings th acm national conference pages 
reynolds 
relation direct continuation semantics 
editor proceedings second colloquium automata languages programming pages 
lecture notes computer science 
sabry felleisen 
reasoning programs continuation passing style 
acm symposium lisp functional programming pages 
schmidt 
denotational semantics methodology language development 
wm 
brown publishers 
isbn 
shivers 
control flow analysis higherorder languages taming lambda 
phd thesis carnegie mellon university 
sussman steele 
scheme interpreter extended lambda calculus 
technical report ai lab memo mit 
van wijngaarden 
recursive definition syntax semantics 
steel jr editor formal language description languages computer programming 
north holland 
wand 
continuation program transformation strategies 
journal association computing machinery january 
wand 
deriving target code representation continuation semantics 
acm transactions programming languages systems july 
