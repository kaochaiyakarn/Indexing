implementation message logging elnozahy willy zwaenepoel school computer science department computer science carnegie mellon university rice university pittsburgh pa houston tx message logging long advocated offering better failure free performance coordinated checkpointing 
contrary number experiments showing compute intensive applications executing parallel clusters workstations message logging higher failure free overhead coordinated checkpointing 
message logging protocols result shorter output latency coordinated checkpointing 
message logging applications involving substantial interactions outside world coordinated checkpointing 
unorthodox message logging design uses coordinated checkpointing message logging departing conventional approaches independent checkpointing 
combination message logging coordinated checkpointing offers advantages including improved failure free performance bounded recovery time simplified garbage collection reduced complexity 
new protocols retain advantages conventional message logging protocols respect output commit 
discuss lessons learned implementation various message logging protocols 
output commit dependency information messages log needs written stable storage 
necessary write message data stable storage leading faster output commit 
second copy write implementation message logging substantially reduces logging overhead communication intensive programs 
provide quantitative evidence supporting previous qualitative claims superiority sender message logging receiver logging 
supported part nfs cda ccr texas advanced technology program atp atp 
author supported part ibm graduate fellowship advanced research projects agency contract number dabt 
views contained document authors interpreted representing official policies sponsors 
methods proposed rollback recovery message logging 
failure free operation processes participating distributed computation take independent checkpoints log messages exchange 
failure occurs recovery algorithm uses message logs checkpoints available stable storage compute consistent state processes roll back 
message logging allows processes distributed computation take independent checkpoints avoiding possibility domino effect recovery 
argued design results better failure free performance coordinated checkpointing avoids overhead synchronizing checkpoints form consistent state 
premise true environments communication expensive incremental cost logging small message exchanges necessary synchronize checkpoints add substantial overhead example see 
workstation clusters cost network communication small rapidly decreasing 
cost accessing stable remains high mechanical nature disks media choice implementing stable storage cost capacity advantage techniques 
experiments indicated difference performance coordinated independent checkpointing marginal workstation clusters 
re examines design premises message logging protocols light developments 
implemented message logging protocols compared performance implementation coordinated checkpointing hardware software platform 
protocols receiver optimistic message logging ii sender optimistic message logging iii manetho rollback recovery system :10.1.1.134.8089
protocols asynchronous message logging 
results show message logging protocols perform worse coordinated checkpointing 
costs writing message logs managing recovery information stable stor age outweigh cost coordinating checkpoints failure free operation overhead contention stable storage server global checkpoint 
result imply coordinated checkpointing method choice 
message logging reduces output latency interactions outside world 
rollback recovery system process allowed send output outside world output commit algorithm guarantee state application producing output rolled back failure 
output latency time necessary execute output commit algorithm 
measurements show message logging protocols commit output faster coordinated checkpointing 
observations new message logging protocol uses coordinated independent checkpointing 
unorthodox combination retains fast output commit property conventional message logging independent checkpointing offers advantages conventional designs 
message logs need written stable storage resulting reduction stable storage access enhanced performance 
second explicit garbage collection algorithm needed 
events occurred consistent checkpoint rolled back recovery information related events discarded soon consistent checkpoint completed 
third coordinated checkpointing guarantees processes roll back latest checkpoint 
new design offers better bound recovery time requires permanent checkpoint process maintained stable storage 
implemented new approach measurements implementation indicate achieves better performance message logging protocols independent checkpointing 
highlight issues interest implementors message logging systems 
previous message logging designs write part message log stable storage output including message data log dependency information 
show dependency tracking information needs saved stable storage resulting reduced output latency 
second copy write implementing message log reduce overhead logging 
copy write extends message log application address space reducing probability overflowing volatile log resulting potential blocking application 
results show sender logging failure free performance superior receiver logging 
qualitative arguments sender logging aware quantitative performance comparisons support arguments :10.1.1.134.8089
experiments focus performance various protocols study 
consider performance failures recoveries occur 
results apply processes nondeterminism tracked efficiently underlying assumption message logging protocols 
outline follows 
section reviews background information 
section describes environment experiments 
section presents results experiments comparing conventional message logging protocols coordinated checkpointing 
section presents new message logging protocols coordinated checkpointing 
section compares related research section concludes 
background section summarizes rollback recovery techniques discussed 
include coordinated checkpointing optimistic message logging receiver sender logging manetho system 
full description methods refer reader relevant publications 
coordinated checkpointing coordinated checkpointing processes cooperate checkpoints form consistent state 
new global consistent state recorded checkpoints belonging previous may discarded 
result garbage collection old checkpoints required 
recovery application rolls back consistent checkpoint bounding amount lost 
drawbacks coordinated checkpointing include overhead required coordination protocol high load stable storage service checkpointing 
study algorithm described previous study checkpointing workstation clusters 
receiver message logging receiver message logging processes participating distributed computation log stable storage messages receive failure free operation 
asynchronous logging failure free overhead synchronous logging expensive hardware support 
recovery failure process restarts previous checkpoint replays messages log restore execution state occurred failure 
message logging protocols process execution deterministic order message replay restore process state failure 
techniques exist recovery computing maximum recoverable state checkpoints message logs available stable storage 
techniques failure process may cause processes roll back processes survive failure 
processes called orphans 
furthermore garbage collection protocol required reclaim old checkpoints messages process may maintain checkpoints stable storage 
study technique suggested johnson zwaenepoel 
technique sender adds dependency information message sends 
information recovery compute maximum recoverable state 
sender message logging process fails volatile message log lost 
sender message logging messages logged sender volatile storage :10.1.1.134.8089
process fails messages needed execution replay available senders logs 
technique tolerates single failure system 
strom enhanced technique separating logging message data receipt order 
data message logged sender receipt order logged receiver 
resulting protocol tolerates arbitrary number failures 
requires maintenance checkpoints process stable storage garbage collection protocol reclaim old checkpoints messages 
implementation sender adds dependency information message sends suggested johnson 
recovery protocol uses dependency information computing maximum recoverable state 
manetho system manetho uses combination independent checkpointing sender message logging dependency tracking means graph 
graph provides process system complete history nondeterministic events causal effects state 
adding graph sender message logging results advantages optimistic logging protocols 
process commits output locally having run protocol 
second process orphan result failure process 
third process rolls back checkpoint process needs maintain permanent checkpoint stable storage 
graph allows message logging protocol combine advantages pessimistic optimistic logging disadvantages 
price paid cost maintaining graph failure free operation complex garbage collection algorithm reclaim obsolete information graph 
implementation techniques reduce cost 
experimental setup implemented techniques described section software hardware platform 
section describe experimental setup application programs study 
experimental environment implementations carried dedicated mbit sec ethernet connecting diskless sun workstations 
workstation equipped mhz motorola mc processor megabytes memory kilobytes consumed operating system kilobytes consumed message logs applicable 
machines run version system distributed operating system 
stable storage provided sun network file servers mhz mc processor fujitsu eagle disk 
applications performance measurements longrunning compute intensive applications 
applications typical exploit parallel processing capacity workstation cluster 
measurements carried applications executing machines 
network workstations idle 
table summarizes running times memory requirements communication rates applications 
description follows ffl gauss performs gaussian elimination partial pivoting theta matrix 
iteration process communicates process currently holding current pivot element 
ffl grid performs iterative computation grid theta points 
iteration value point computed function value iteration values neighbors 
grid subdivided processes participating computation 
iteration process exchanges values borders subgrid processes contain bordering 
application occurs kernel fluid flow modeling algorithms 
ffl sparse solves sparse system linear equations unknowns variation iterative gauss seidel method 
system sparse row matrix nonzero 
process responsible computing portion solution vector 
iteration process sends computed subvector processes 
readers familiar previous may recall applications evaluation performance coordinated checkpointing 
applications included fft matmult prime communication loads similar tsp lead similar 
smaller problem size sparse space taken message logs reduced amount memory available application 
running process memory total communication rate program time kbytes memory second name minutes code data total mbytes messages kbyte gauss grid sparse tsp table application running times memory requirements communication rates 
ffl tsp uses distributed branch bound algorithm solve traveling salesman problem dense map cities 
program master slave structure 
master maintains current best solution task queue containing subsets search space 
communication occurs slaves master 
performance traditional message logging failure free performance compared failure free overhead coordinated checkpointing message logging protocols described section 
table shows results experiments 
overhead expressed percent increase running time due provision fault tolerance protocols 
completeness show overhead protocol uses independent checkpointing message logging 
measurements shown checkpointing intervals minutes application 
garbage collection performed message logging protocols measurements underestimate actual overhead 
measurements show coordinated checkpointing outperforms message logging protocols tsp little communication 
illustrate point table shows components overhead protocols 
table shows added overhead cost independent checkpointing 
coordinated checkpointing overhead coordination 
overhead add total value overheads various execution 
gauss coordinated checkpointing shown negative additional cost compared independent checkpointing 
short checkpointing intervals coordinated checkpointing performs better independent checkpointing gauss tight synchronization pattern application interaction coordination 
overhead logging messages 
cost dependency tracking protocols negligible 
manetho overhead split overhead message logging dependency tracking 
tsp overhead due coordinating checkpoints combined overhead logging messages tracking dependencies 
conjecture results hold modern hardware platforms 
processor speed network bandwidth increasing resulting higher communication rates 
stable storage bandwidth improving rate increasing relative cost message logging 
stable storage bandwidth improved distributing load multiple servers 
expect coordinated checkpointing benefit stable storage organization overhead coordinated checkpointing results machines accessing stable storage approximately time record checkpoints 
contention observed saving message logs 
output interactions table shows average latency releasing output outside world output commit algorithms rollback recovery protocols study section 
measurements shown case processors participating output commit algorithm 
latency expressed function size global checkpoint megabytes coordinated checkpointing protocol 
overhead expressed function number processors involved size data logged 
manetho output commit require protocol systems output commit constant overhead 
table shows message logging protocols better latencies coordinated checkpointing protocol 
manetho system lowest latency dependency tracking allows process commit output locally single stable storage message logging protocols require protocol commit output entails exchanging messages performing stable storage operations 
increase running time program checkpointing independent coordinated manetho name interval checkpointing checkpointing gauss min 
min 
min 
grid min 
min min 
sparse min 
min min 
tsp min 
min min 
table failure free overhead independent coordinated checkpointing message logging protocols 
increase running time program coordination manetho name interval overhead logging logging logging dependence gauss min 
min 
min 
grid min 
min min 
sparse min 
min min 
tsp min 
min min 
table added overhead due particular aspects protocol 
output commit latency seconds coordinated manetho checkpointing mb mb mb table output latency coordinated checkpointing protocols message logging 
lessons learned dependency logging output commit conventional message logging requires message data flushed stable storage committing output 
inspecting algorithms purpose committing output suffices write receipt order messages message data 
consider instance traditional 
information required replay non orphan message recovery consists data receipt order 
message receipt order retrieved log inferred 
message data hand retrieved log regenerated recovery message orphan 
result suggests flushing message data committing output necessary efficient shown measurements 
just flushing dependency tracking information consists receipt orders lower latency committing output obtained 
latency milliseconds number processes participate output commit algorithm 
copy write message logging asynchronous logging process execution may blocked volatile log full logging message 
blocking avoided copy write protection message data application address space 
volatile log fills memory management unit mmu information modified write protect pages containing message data application address space application continues execute 
volatile log written stable storage new space available volatile log message data copied log write protection removed corresponding pages 
blocking application necessary tries write protected pages 
application wait space message available log 
scheme extends message log address space application reduces probability overflowing volatile log 
sparse message logging overhead implementation employ technique increases 
increase processor speeds reasonable expect applications produce messages optimization gain importance 
versus comparing columns labeled logging logging table see sender message logging efficient receiver logging especially communication intensive programs sparse 
reasons phenomenon 
message logged transmitted network logging message sender critical path interprocess communication 
second logging sender reduces amount messages logged applications gauss sparse 
applications processor typically broadcasts result single iteration rest 
data logged receiver single copy logged sender 
follows amount logged data smaller 
results quantitatively confirm previous qualitative claims issue 
message logging coordinated checkpointing results described section led consider new message logging design 
message logging offers lowest output latency coordinated checkpointing offers best failure free performance addition limited recovery time simplified garbage collection propose design combines message logging coordinated independent checkpointing 
design maintains low output latency message logging addition allows important optimization improves failure free performance traditional design uses independent checkpointing 
specifically show manetho message log need written stable storage reducing logging overhead implementation complexity 
sections discuss new protocol advantages 
section compare performance original design 
focus manetho 
coordinated checkpointing combined message logs need written stable storage reducing performance advantage volatile log receiver fails 
addition shown superior 
new protocols new versions manetho take coordinated checkpoints independent checkpoints 
protocols algorithm coordinating checkpoints 
implementation reuse coordinated checkpointing protocol study coordinated checkpointing 
recovery algorithm protocol remains unchanged 
corresponding correctness proofs simply carry new design assume arbitrary sets process checkpoints consistent set special case 
new versions perform dependency tracking original designs output commit algorithms identical 
advantages coordinated checkpointing avoid having write message log stable storage 
manetho particular process writes volatile sender log stable storage takes independent checkpoint 
necessary guarantee process rolls back latest checkpoint 
message sent checkpoint logged sender recipient message failed necessary roll back sender earlier checkpoint order recreate message 
log saved checkpoint saved periodically stable storage guarantee maximum recoverable state advances 
saved stable storage volatile log overflows 
strom describe way compressing log coordinating checkpoint scheme requires large amount communication processes determine messages may removed 
wang fuchs describe algorithms eliminate messages needed recovery require coordination determine obsolete messages 
coordinated checkpointing saving log time checkpoint longer necessary 
process roll back state checkpoint messages required replay transit time checkpoint messages sent sender checkpoint received receiver checkpoint 
coordination protocols consider message part checkpoint receiver special handling required 
protocols require messages identified treated messages outside world logged stable storage receiver may send message 
handle situations message tagged number latest checkpoint taken sender 
receiver determine message message comparing checkpoint number message local checkpoint number 
experiments indicate cross checkpoint messages occur infrequently practice 
overflow volatile log may require log written secondary storage important distinction need written stable storage 
stable storage typically replicated high availability provided network 
secondary storage local disk 
addition reduced stable log access new protocols benefit simplified garbage collection 
consistent checkpoint establishes recovery line event prior checkpoint replayed recovery 
dependency tracking information relating events occurred prior checkpoint removed explicit garbage collection protocol original version protocol 
results simpler implementation explicit code handle garbage collection necessary better performance lower storage overhead 
original design protocol requires process maintain checkpoints stable storage 
new version process need maintain permanent checkpoint stable storage 
checkpoint establishes bound time recovery protocol 
performance implemented new versions protocol compared performance original implementations 
table shows comparison overhead versions protocol 
garbage collection performed old versions protocols results underestimate performance advantage new versions 
results show applications study combination message logging coordinated checkpointing performance edge traditional designs 
applications considerable communication load performance benefits reduction stable storage access 
sparse benefits new method diminish increasing checkpointing intervals 
short intervals overflow occurs volatile message log checkpoints log written secondary storage 
performance differences reflect reduced stable storage access 
longer intervals volatile logs overflow written secondary storage device 
workstations unfortunately diskless secondary storage provided network file server 
result cost secondary storage access log overflow different cost stable storage access checkpoint performance differences methods small 
log written local disk performance differences remain longer checkpointing intervals 
discussion new versions message logging protocols 
new design departs traditional ones combination message logging coordinated checkpointing 
new design offers output commit latency conventional message logging improves failure free execution time avoiding maintenance message log stable storage simplifies garbage collection limits rollback checkpoint improves utilization space stable storage device 
light results viewed enhancement message logging protocols 
alternatively viewed addition existing coordinated original design manetho provides bounded recovery time dependency tracking 
increase running time program checkpointing manetho name interval coord 
indep 
coord 
indep 
gauss min 
min 
min 
grid min 
min min 
sparse min 
min min 
tsp min 
min min 
table comparison failure free performance overhead versions manetho 
checkpointing protocols message logging added provide efficient interactions outside world applications tracking nondeterminism done efficiently 
related message logging protocols proposed literature 
best knowledge advocate coordinated checkpointing method choice saving processes states message logging protocols 
aware compares message logging protocols coordinated checkpointing methods software hardware platforms 
comparative analysis revealed message logging systems benefit coordinated checkpointing 
shown implementing message logging systems sender logging method choice 
researchers advocated sender logging qualitative grounds believe results provide quantitative evidence supporting argument :10.1.1.134.8089
schemes coordinated checkpointing appeared literature 
best knowledge systems handle interactions outside world consistent checkpoint 
systems benefit addition message logging provide better performance interacting outside world 
experimental study showing traditional designs message logging independent checkpointing performance advantage systems solely coordinated checkpointing 
real purpose message logging longer fix inconsistencies checkpoints reduce output latency rollback recovery method 
results proposed new protocols combine message logging coordinated checkpointing deviating traditional systems independent checkpointing 
proposed combination coordinated checkpointing message logging leads better failure free performance reduced implementation complexity efficient space stable storage smaller recovery time compared traditional protocols 
new schemes maintain small output commit latency message logging 
choice message logging coordinated checkpointing depend application interacts outside world efficiency tracking nondeterminism 
study highlighted issues interest implementors message logging protocols 
showed memory management techniques copy write necessary avoid overflowing volatile log ensuing performance penalty 
second showed committing output suffices write dependency information stable storage writing message data 
third confirmed superiority sender message logging receiver logging 
examine performance methods failures recoveries involved 
examine results different hardware platforms 
conjecture results continue hold current trends stable storage networking technologies 
acknowledgments referees valuable comments 
ahamad lin 
checkpoints localize effects faults distributed systems 
proceedings th symposium reliable distributed systems pages october 
bacon 
file system measurements applications design efficient operation logging algorithm 
proceedings th symposium reliable distributed systems pages october 
bartlett 
non kernel 
proceedings th acm symposium operating systems principles pages december 
bhargava 

leu 
experimental evaluation concurrent checkpointing rollback recovery algorithms 
proceedings international conference data engineering pages march 
borg 
message system supporting fault tolerance 
proceedings th acm symposium operating systems principles pages october 
borg blau herrmann oberle 
fault tolerance unix 
acm transactions computer systems february 

distributed domino effect free recovery algorithm 
proceedings th symposium reliable distributed systems pages october 
chandy lamport 
distributed snapshots determining global states distributed systems 
acm transactions computer systems february 
cheriton 
distributed system 
communications acm march 
elnozahy 
manetho fault tolerance distributed systems rollback recovery process replication 
phd thesis rice university october 
available technical report tr 
elnozahy johnson zwaenepoel 
performance consistent checkpointing 
proceedings th symposium reliable distributed systems pages october 
elnozahy zwaenepoel 
manetho transparent rollback recovery low overhead limited rollback fast output commit 
ieee transactions computers special issue fault tolerant computing may 
goldberg gopal li strom bacon 
transparent recovery mach applications 
proceedings usenix mach workshop pages october 
israel morris 
non intrusive checkpointing protocol 
phoenix conference communications computers pages 

fault tolerant processes 
distributed computing 
johnson 
distributed system fault tolerance message logging checkpointing 
phd thesis rice university december 
johnson 
efficient transparent optimistic rollback recovery distributed 
proceedings th symposium reliable distributed systems october 
johnson zwaenepoel :10.1.1.134.8089
sender message logging 
proceedings th international symposium fault tolerant computing pages june 
johnson zwaenepoel 
recovery distributed systems optimistic message logging checkpointing 
proceedings th annual acm symposium principles distributed computing pages august 
juang venkatesan 
crash recovery little overhead 
proceedings th international conference distributed computing systems pages may 
kaashoek bal tanenbaum 
transparent fault tolerance parallel orca programs 
symposium experiences distributed multiprocessor systems iii pages march 
kim 
scheme coordinated execution independently designed recoverable distributed processes 
proceedings th international symposium fault tolerant computing pages 
koo toueg 
checkpointing rollback recovery distributed systems 
ieee transactions software engineering se january 
lai yang 
distributed snapshots 
information processing letters may 
malek 
space time overhead analysis experiments techniques fault tolerance 
third ifip international working conference dependable computing critical applications pages september 
leu bhargava 
concurrent robust checkpointing recovery distributed systems 
proceedings international conference data engineering february 
li naughton plank 
checkpointing multicomputer applications 
proceedings th symposium reliable distributed systems pages october 
lowry russell goldberg 
optimistic failure recovery large networks 
proceedings th symposium reliable distributed systems pages october 
peterson schlichting 
preserving context information interprocess communication 
acm transactions computer systems august 
powell presotto 
publishing reliable broadcast communication mechanism 
proceedings th acm symposium operating systems principles pages october 
randell 
system structure software fault tolerance 
ieee transactions software engineering se june 
silva silva 
global checkpointing distributed programs 
proceedings th symposium reliable distributed systems pages october 
sistla welch 
efficient distributed recovery message logging 
proceedings th annual acm symposium principles distributed computing pages august 
kearns 
efficient distributed snapshots 
proceedings th international conference distributed computing systems pages may 
strom bacon yemini 
volatile logging fault tolerant distributed systems 
proceedings th international symposium fault tolerant computing pages june 
strom yemini 
optimistic recovery distributed systems 
acm transactions computer systems august 

error recovery multicomputers global checkpoints 
international conference parallel processing pages august 
tong tsai 
lower overhead checkpointing rollback recovery scheme distributed systems 
proceedings th symposium reliable distributed systems pages october 
venkatesh radhakrishnan li 
optimal checkpointing local recording domino free rollback recovery 
information processing letters july 

wang fuchs 
optimistic message logging independent checkpointing message passing systems 
proceedings th symposium reliable distributed systems pages october 

wang fuchs 
scheduling message processing reducing rollback propagation 
proceedings nd international symposium fault tolerant computing pages july 
