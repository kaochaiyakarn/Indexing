new formulation tabled resolution delay swift computer science department suny stony brook stony brook ny usa email cs sunysb edu 
tabling important logic programming part opens new application areas model checking logic programming techniques 
development new extensions tabled logic programming restricted formalisms underly 
formalisms tabled evaluations slg generally developed view specific set allowable operations performed evaluation :10.1.1.38.8814
case slg tabling operations variance relation atoms 
set slg tabling operations proven useful number applications types operations subsumption relation atoms practical uses 
slg reformulated ways parameterized different sets operations forest trees paradigm 
equivalence slg new formulation extended slg shown new formalism parameterized variant operations 
addition parameterized subsumption operations shown correct queries founded model 
usefulness forest trees paradigm motivating tabling optimizations shown formalizing concept relevance tabled evaluation 
keywords logic programming non monotonic reasoning ability compute queries founded semantics wfs extensions proven useful number applications including model checking diagnosis 
logic programming community evaluation wfs commonly done tabled evaluation methods 
slg resolution linear resolution selection function general logic programs interest non ground programs formed foundation extended implementation efforts xsb system :10.1.1.38.8814
extensions slg address constructive negation property called delay minimality 
understood proper context ideas differentiate slg tabling methods relatively simple 
slg breaks tabled evaluation set primitive operations equivalently transformations 
handle possible loops negation slg provides delaying operation dynamically adjust computation rule simplification operation resolve away delayed literals truth value known 
slg ensures polynomial data complexity controlling manner delayed literals propagated marking completed subgoals benefit resolution 
slg originally notation sets objects called elements associated ordinals transfinite induction performed :10.1.1.38.8814
despite power formulation somewhat difficult learn particularly exploring operational aspects slg 
stated goal derive calculus computing founded semantics simpler understand slg 
addition definitions original formulation slg assume variance relation terms determine new subcomputation arise answer resolution selected literal delayed literal simplified 
derive new computation strategies founded semantics extensions founded semantics new operations needed variant operations 
defines reformulation slg called extended slg reformulates slg ways 
trees may naturally formulated sets see slg may modeled forests trees explicit sets elements 
believe resulting framework clearer original formulation slg lose power slg formalize transfinite computations 
informal forest trees model slg derive scheduling properties tabled evaluations motivate design machine slg 
second definitions geared underlying tabling operations parameterizable 
result prove full equivalence slg parameterized variant style operations called slg variance 
second main result parameterize subsumption tabling operations form method called slg subsumption prove soundness completeness slg subsumption wellfounded semantics 
subsumption new tabled evaluations definite programs cf 
formulation fully subsumption tabling method founded semantics novel knowledge 
practical usefulness demonstrated optimization called relevance 
slg defined computation terminates answers derived initial query subgoals arise solving useful ignore subcomputation determined subcomputation produce answers initial query 
section formalizes notions 
proceeding informally introduce concepts parameterized variant style operations example 
example 
consider possible slg variance evaluation query program 




slg variance evaluation evaluation consists sequence forests slg trees form answer template delay list fail 
form answer template represent bindings tabled subgoal course resolution computation path delay set contains set literals selected fixed order literal selection strategy evaluation delayed goal list sequence unresolved literals 
requires fixed literal selection strategy 
assume loss generality literal selection strategy left right goal list 
evaluation query begins tree root node 
root node answer template reflects bindings subgoal delay set empty goal list identical original subgoal 
children root nodes produced program clause resolution operation children depicted 
numbers associated nodes depict order creation children node answer node defined leaf node goal list empty 
selected literals children jp produce new tabled subgoals slg variance operation new subgoal note slg variance new tree created subsumed 
children non root nodes selected literals positive node produced positive return operation children nodes negative selected literals node may produced negative return operation 
answer contained node forest failure node node produced child 
failure node subject slg variance operations indicates computation path leading failed 
possible new subgoal program clause resolution positive return negative return operations performed 
despite truth value determined tree depends node literal selected 
slg overcomes problem self dependency negation delaying operation case creates new node node moved goal list delay set 
delaying operations produce nodes addition node 
delaying negative literal allows literals selected failure may break self dependency negation 







complete 

fail 


complete 




complete 

fail 


fig 

intermediate forest selected node 
includes relevant portions final forest reached restarting subcomputations enabled delaying negative literals 
node example literal selected negative return causes computation path leading node fail 
delaying creates node termed conditional answer non empty delay set 
node produced computation paths stemming failed 
result literal fact succeed conditional answer unconditional removed delay set 
slg variance uses simplification operation produce unconditional answer node shows state slg variance evaluation possible slg variance operations applied 
note tree marked token complete denoting completely evaluated produce answers 
turn formalizing concepts example 
framework parameterizing tabling operations terminology assumptions assume standard terminology logic programming see 
assume program defined countable language predicates function symbols 
literal 

fail 




fail 



fail 
complete 






fail 

complete fig 

final slg forest vars denotes set variables herbrand base hp program set ground atoms formed valued interpretation program mean set literals defined hp hp true false interpretation atom refers fl ground instantiation ag sections terms goal subgoal atom interchangeably 
variant terms considered identical 
evaluations allow arbitrary fixed literal selection strategies 
simplicity assume literals selected left right order 
provide definitions concepts introduced example 
definition trees forest 
slg forest consists forest slg trees 
nodes slg trees forms answer template delay list fail form answer template atom delay set set delayed literals see definition goal list sequence literals 
second form called failure node 
root node slg tree may marked token complete 
call node answer leaf node goal list empty 
delay set answer empty termed unconditional answer conditional answer 
definition specifies exact formulation delay literals 
definitions ensure root node slg tree form js subgoal 
slg tree forest root node js possibly marked complete terminology 
root node tree definition delay literals 
negative delay literal delay set node form ground atom 
positive delay literals form call answer atom truth value depends truth value answer answer subgoal call 
substitution call answer call answer positive delay literals contain information may simplified particular answer particular call unconditionally true false 
useful define answer resolution takes account form delay literals 
definition answer resolution 
node ln 
ans answer variables standardized apart slg resolvable ans unifiable mgu 
slg resolvent ans form gamma ln empty gamma ln negative 
set subgoals completely evaluated produce answers 
formally definition completely evaluated 
set subgoals forest completely evaluated conditions holds 
tree contains answer 
node tree selected literal ls completed applicable new subgoal program clause resolution positive return delaying negative return operations definition set subgoals determined completely evaluated completion operation marks root node trees subgoal definition 
definition conditional answer resolved selected literal goal list node information delayed literals answer need propagated 
shown propagation delay elements specified definition necessary ensure polynomial data complexity :10.1.1.38.8814
certain cases propagation delayed answers lead set unsupported answers shown example 
example 
consider program query founded model false true 
forest possible slg variance slg subsumption evaluation shown nodes numbered order creation 
consider sub forest induced nodes numbered 
nodes literals delayed creating conditional answers nodes 
conditional answer node returned node creating second conditional answer node 
subsequently node unconditional answer causing successful definition simplification operation performed creates failure node node 
completely evaluated determined false conditional answer depends positively unsupported see definition 
unsupported answers handled answer completion operation 
definition supported answer 
slg forest subgoal answer atom occurs head answer template supported 
completely evaluated 
exists answer node answer delay positive delay literal call ans ans supported call 
aside note unsupported answers appear uncommon practical evaluations minimize delay 
evaluation consists possibly transfinite sequence slg forests 
order define behavior evaluation limit ordinal define notion upper bound set slg trees 
global ordering literals assumed elements delay set node 
fail 







fig 

derivation containing unsupported answer uniformly ordered ordering node tree taken term usual definitions variance subsumption apply see full version www cs sunysb edu details 
particular nodes slg trees treated identical variant 
rooted tree viewed partially ordered set node represented fn pg tuple representing path root tree 
represented manner easily seen rooted trees iff subtree furthermore root union defined set union taken sets 
definition tabled evaluation 
program atomic query set tabling operations definition definition tabled evaluation sequence slg forests 
fi forest containing single tree successor ordinal fi fn obtained fn application tabling operation 
limit ordinal ff fi ff defined set trees ffl root js root tree forest ff ffl ft jt ff root operation applicable ff ff called final forest fi contains leaf node non ground selected negative literal floundered 
slg forests related interpretations manner 
definition 
forest 
interpretation induced properties 
ground atom iff ground instantiation unconditional answer ans ground atom iff ground instantiation completely evaluated subgoal ground instantiation answer atom successful tree unconditional answer failed completely evaluated tree contains answers 
atom successful failed ground instantiation negative delay literal successful failed forest forest failed successful similarly positive delay literal call ans successful failed call unconditional answer ans slg variance variant tabling delay slg variance uses variant relation terms determine add new slg tree slg forest new subgoal operation determine answer program clause may resolution program clause resolution positive return operations removing delay literal failing conditional answer simplification instruction 
operations follows 
definition slg variance operations 
forest fn slg variance evaluation program query non limit ordinal fn may produced operations 

new subgoal fn contain non root node ans goal list selected literal assume fn contain tree root subgoal add tree js fn 
program clause resolution fn contain root node js program clause head body head unifies mgu 
assume fn child child 
add child child 
positive return fn contain non root node selected literal positive 
ans answer node fn child slg resolvent ans assume fn child child add child child 
negative return fn contain leaf node ans goal list selected literal ground 
negation success failed create child form ans list negation failure succeeds create child form fail 

delaying fn contain leaf node ans goal list ground fn successful failed fn create child form ans list 

simplification fn contain leaf node ans failed create child fail 
successful create child ans delay set delay set gamma 
completion completely evaluated set subgoals definition mark trees subgoals completed 

answer completion set unsupported answers ua create failure node child answer ans ua 
interpretation induced forest definition counterpart slg definition :10.1.1.38.8814
concepts relate slg slg variance evaluations 
theorem 
finite program atomic query 
exists slg evaluation exists slg variance evaluation proof 
proof theorems provided full version available www cs sunysb edu 
subsumption tabling delay variance relation atoms implicitly slg variance operations replacing uses subsumption relation atoms slg subsumption obtained 
specifically slg subsumption new subgoal operation applicable forest new subgoal subsumed subgoal forest 
slg variance evaluation may perform new subgoal operations necessary slg subsumption similarly slg subsumption program clause resolution positive return operations produce child node child subsumed child operations affected 
simplification operation may applicable delay literal conditions delay literals specified definition subgoal may completely evaluated subsumed subgoal completely evaluated 
condition reflected slg subsumption completion instruction formulating new definition completely evaluated 
definition slg subsumption operations 
state fn evaluation program query non limit ordinal fn may produced operations 

new subgoal fn contain non root node ans goal list selected literal assume fn contain tree root subgoal subsumes add tree js fn form positive delay literals need annotations described definition maintained sake uniform representation 

program clause resolution fn contain root node js program clause head body head unifies mgu 
assume fn child subsumes child 
add child child 
positive return fn contain non root node selected literal positive 
ans answer node fn child slg resolvent ans assume fn child subsumes child add child child 
negative return fn contain leaf node ans goal list selected literal ground 
negation success create child form ans list negation failure create child form fail 

delaying fn contain leaf node ans goal list ground fn successful failed fn create child form ans list 

simplification fn contain leaf node ans delay set 
failed fn create child fail 
successful fn create child ans delay set delay set gamma 
answer completion set unsupported answers ua create failed child answer ans ua 

completion set subgoals fn completely evaluated subsumed subgoal tree exists fn marked complete 
mark complete tree theorem 
program query 
exists slg variance evaluation final state exists slg subsumption evaluation final state slg variance slg subsumption considered extreme types tabled evaluation 
implementational perspective may useful mix operations different evaluation methods 
instance replacing slg variance new subgoal operation slg subsumption evaluation may said call subsumption 
replacing slg variance positive return operation slg subsumption evaluation may said answer subsumption 
special cases call answer subsumption discussed tabling literature definite programs see 
relevant subgoals example slg optimization previous theorems hold slg variance slg subsumption evaluations ordering applicable operations 
order apply method practical programs useful restrict evaluations certain properties 
instance notion incremental completion applying completion operation soon possible space completed trees reclaimed described 
describe optimization notion relevance 
slg tree relevant initial query need operations performed principle disposed reclaiming space 
restating definition subgoal dependency graph sdg provides useful abstraction slg forest 
definition subgoal dependency graph 
forest evaluation 
say tabled subgoal directly depends tabled subgoal iff tree marked complete selected literal node tree subgoal dependency graph sdg directed graph set root goals trees iff directly depends example 
represents sdg forest 
fig 

sdg forest dependency relation non symmetric sdg directed graph partitioned strongly connected components sccs 
particular independent scc depends scc 
example 
consider program rel 





tree slg variance evaluation query shown 
note answer subgoal obtained answers irrelevant evaluation case subgoal answers fact relevant solving goal shares variables 






fig 

tree evaluation rel definition captures notion query relevant 
definition 
slg forest ans delay list node root subgoal selected literal goal list relevant 
vars vars 
vars non selected literal goal list 
edge sdg 
relevant sdg selected literal leaf node selected literal non leaf node relevant relevant path node node exists sdg path relevant edges path exists say relevant relevant evaluation defined constraining operations act trees relevant original query 
definition relevance 
evaluation query program relevant new subgoal program clause resolution positive return delaying negative return simplification operation creating fn fn gamma applied node root subgoal relevant sdg fn gamma 
note relevance defined property forests defined forest possibly transfinite evaluation 
theorem 
relevant evaluation query program represent founded model evaluation programs queries easily constructed relevant evaluations terminate finitely non relevant evaluations 
relevance tabled captures aspects prolog cut existential query optimization deductive databases 
aspects relevance explored allow tabled logic programs implement partial order model checking 
relevance differs cut irrelevant trees necessarily removed forests operations trees postponed 
strategy keeping uncompleted irrelevant trees adopted shown relevant slg evaluations maintain polynomial data complexity properties general slg 
implement relevant evaluations open question particularly determination relevance done dynamically part engine informed analysis 
discussion originally formulated slg learned relatively large amount intellectual commitment forest trees model underlies may reduce 
addition formulation easier formulate alternate sets operations demonstrated creation slg subsumption extensions presently formulated implemented new sets operations abduction founded semantics generalized annotated programs formalize algorithms distributed tabling 
tabling serious implementation powerful non monotonic logics program optimizations increasingly important necessity prove optimizations correct 
hoped reformulation described efforts easier date 
author david warren freire useful discussions forest trees model slg david warren suggesting topic relevance 

alferes pereira swift 
founded abduction tabling dual programs 
technical report suny stony brook 

bol 
tabulated resolution founded semantics 
journal logic programming february 

chen warren 
tabled evaluation delaying general logic programs 
jacm january 

dam asio 
paraconsistent extended logic programming constraints 
phd thesis univ nova de lisboa 

dam asio nejdl pereira schroeder 
model diagnosis preferences strategies representation logic meta programming 
logic programming pages 

devlin 
fundamentals contemporary set theory 
springer verlag berlin germany 

freire rao sagonas swift warren 
xsb system efficiently computing founded semantics 
lpnmr pages 
mit press 

freire swift warren 
depth improving tabled logic programs alternative scheduling strategies 
journal functional logic programming 

hu 
distributed tabled evaluation 
phd thesis suny stony brook 

liu adams chen 
constructive negation founded semantics 
technical report smu 

lloyd 
foundations logic programming 
springer verlag berlin germany 

ramakrishna ramakrishnan ramakrishnan smolka swift warren 
efficient model checking tabled resolution 
proceedings conference automated verification pages 

ramakrishnan beeri krishnamurthi 
optimizing existential datalog queries 
proc 
acm symposium principles database systems pages 
acm 

sagonas swift 
machine tabled execution fixed order stratified logic programs 
acm toplas may 

sagonas swift warren 
machine computing founded semantics 
extended version article joint international conference symposium logic programming pp 
mit press 

sagonas swift warren 
limits fixed order computation 
theoretical computer science 

preliminary version international workshop logic databases lncs 

swift 
tabling non monotonic programming 
annals mathematics artificial intelligence 
appear 

tamaki sato 
oldt resolution tabulation 
iclp pages 
springer verlag 

van gelder ross schlipf 
unfounded sets founded semantics general logic programs 
jacm 

brass freitag 
improving alternating fixpoint transformation approach 
lpnmr pages 
springer verlag 
