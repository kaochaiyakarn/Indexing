linear type inference functional language processes 
investigate interesting combination functional concurrent programming 
concurrent part contains processes rst class objects allows pass channels values 
insist channels directed connect processes 
property ensured type inference system linear types 
show channels sense universal implementing linear datatypes 

designs new programming language days forget include concurrency features 
concurrent programming integrates object oriented functional programming 
case serve additional purpose communication synchronization processes clean way handle side pure languages 
explain functional languages standard ml haskell clean introduce concurrent extensions implement real life applications window systems 
combine purely functional programming language calculus communicating processes 
candidates ccs calculus plain chocs facile 
processes communicate channels synchronous message passing 
facile integrates calculus opinion sensible way side form communications kept functional expressions 
obtain better concept impose additional restrictions 
processes rst class values plain chocs facile 

channels may passed processes calculus 

channels directed connect processes 
disallow hidden synchronizations 
item requires channel port may accessible process time 
channels may copied 
restricts applicability rst item processes free port names may copied 
short spreading channels controlled carefully 
main problem address 
type inference system resembling fragment linear logic 
system nice property general principle types exist computed 
includes primitive form data aeow analysis detect unused arguments 
feature necessary handle polymorphic values 
demonstrate power approach show translate algebraic speci cations de ning datatypes language 
approach compared construction 
implement ordinary types processes 
emphasis lies linear types key words phrases 
type systems linear logic 
implemented sets channels interface 
channels objects linear type powerful implement linear type 
linear type systems increase eoeciency functional languages handle side 
try integrate linearity constraints better conventional type inference relies uni cation 
similar type systems exist calculus inference linearity pict 
type inference system designed overcome limitations conventional type system 
continue name calculus considered 
language contain algebraic datatypes proposed type system powerful deal recursion directly 
fact xpoint operators type 
stronger type system provides programmer equalities veri cation think additional regularity worth price 
recursive functions processes recursive data structures coincide de ned usual counterintuitive restrictions 
anyway implementation algebraic speci cations relies 
organized follows 
section introduces syntax semantics 
type system follows section 
leads type inference algorithm section 
section prove academic way algebraic datatypes pattern matching handled type system show language powerful simulate 
section draws 

syntax semantics language stripped minimum 
particular functional part consists calculus 
comment extensions section 
shows syntax 
syntactic categories expressions actions patterns identi ers 
skip pn 
syntax program expression evaluates process 
process 
operators denote respectively nondeterministic choice parallel execution 
operator called pre xing rst operand action executed second process run 
turn actions immediately 
skip eoeect 
operator creates new channel introduces distinct identi ers ends ports 
rst receive output second provide input 
creation operator calculus binds names 
relates restriction operator plain chocs way 
evaluates second expression outputs sends result rst expression evaluate output port 
denotes input receiving value rst expression evaluate input port 
depending value second expression evaluate process 
remaining linear type inference functional language processes operators known ordinary calculus 
surely need explain recursive bindings abstraction function application constants tuples reader 
mention distinguish tuple expression expression 
lines increasing precedence 
particular precedence increases abstraction application binds tightest 
structure pattern matches tuple 
identi ers appearing distinct 
distinguish tuple pattern pattern 
rationale design follows 
included bindings substitutions needed anyway 
goal show functional programming simulated powerful calculus calculus 
help abstraction syntax input actions shortened creating asymmetry 
tuples type system interesting 
replication calculus derived operator simulated recursion 
recursion turn expressed xpoint operators get type system 
bindings essential introduce polymorphic values 
nondeterministic choice presents problems type system 
practical programming language operands form gives labelled transition system 
range identi ers patterns expressions respectively 
silent action dioeerent 
arbitary action may substituted substitution expression pattern de ned inductively xn xn xn denotes simultaneous substitution expressions patterns xn say form de nition sense 
assume bound names renamed free names caught 
names bound names pattern bound see pre transparent action forces pre xes move upward proper context established communication 
semantics early binding 
semantic de nition unrealistic allows transfer unevaluated expressions channels 
hand forces call value function applications 
matters evaluation strategy impact type system simply chose convenient form 

sequent calculus purpose calculus derive sequents form xn meaning iif patterns xn respective types expression type tj 
lefthand side sequent regarded set special rule perform permutations 
patterns lefthand side contain common name 
assertions called type assignments 
sources inspiration system intuitionistic linear logic regular trees 
review 

linear hindley milner logic 
typing rules section resemble fragment linear logic notation dioeerent 
version comes closer original shown appendix reader refer names rules 
possible calculus directly known proofs types interpretation 
reason cut elimination procedure see example reduce expression normal form order obtain type 
type assignment undecidable 
types strong case typable expressions normalizing 
hindley milner logic cut rule left rule replaced new rule 
set rules shown gure 
assume write dm names pair disjoint 
say type contain principal position identities lexical variants 
commutative associative operators neutral element 

ff conversion 
creations channels move outwards fx fx appears free appears free 
construct unfolded name appears free normal form form labelled transitions gamma 
gamma 
gamma 
gamma 
skip gamma 
gamma 
gamma 
gamma gamma 
gamma gamma gamma 
gamma 
gamma 
gamma 
gamma 
gamma 
gamma gamma 
gamma gamma 
gamma 
gamma 
gamma 
gamma 
gamma 
gamma 
gamma 
expression normal form form pattern gamma 
gamma 

semantics labelled transition system linear type inference functional language processes contain contain principal position 
interpret lefthand side sequent box box box theta delta delta delta theta box xn xn theta delta delta delta theta name price pay convenient 
abbreviation fx dg 
name containing principal position xn xn theta delta delta delta theta dn dn theta delta delta delta theta name free 
rules linear hindley milner logic reader familiar linear logic probably intersection 
please refer explanation intersection types 
type systems constructor elegant undecidable 
type system universal quanti cation general form girard reynolds logic powerful 
changed rules 
weakening rule restrictive 
requires entities linear type discarded 
compatible semantics earlier 
expensive implement type checker 
version classical weakening rule better seen correspondence right rule contraction 
constant appropriate type expression value needed computation 
want sure expression typable value ignored 
second change added premise right rule 
rule construct 
current framework suited handle polymorphism 
approximation sequel looks theta unnecessarily xes hand rule appropriate allow applications left right rules see appendix derivations course possess common type 
separate consideration derivations suitable necessary applications contraction rule 
best approximation probably theta vn vn type nally comment technical detail 
rules concat lefthand sides sequents 
possible patterns type assignments distinct 
may necessary rewrite proofs premises dioeerent patterns 
contraction rule reestablish sharing 
course better solutions practice 
example show type constructors 
example 
give dioeerent typings term fst snd fst snd rst assigns nonlinear types appear times body function 
theta theta theta theta theta theta theta abbreviate theta theta ae continue 
fst snd ae theta ae fst snd ae theta ae fst snd ae theta ae body 
fst theta fst theta fst fst theta theta fst fst analogous derivation proves snd ae snd gives fst snd ae fst snd theta fst snd ae fst snd theta fst snd ae fst snd theta rst part fst snd fst snd theta type expression theta theta second typing shows linear types body function 
theta theta 
theta theta theta 
theta 
theta linear type inference functional language processes abbreviate theta 
theta ae continue 
fst snd ae theta ae fst snd ae theta ae fst snd ae theta ae type economic 
body handled follows 
fst theta 
fst theta 
fst fst theta 
theta fst fst analogous derivation proves snd ae snd gives fst snd ae fst snd theta rst part fst snd fst snd theta type expression theta theta expected 

regular trees 
allows direct recursion types 
means terms types extended nite trees regular ones 
regular trees written help xpoint operator 
solution smallest tree occurrence isomorphic 
recursive types studied example 
fortunately presence type constants ensures expression type example 
recursive types introduced rule denotes structural equivalence types isomorphism regular trees 
essential rules structural equivalence shown gure 

rules equality regular trees equivalence congruence relation respect type constructors 
constructor involutive types behave way respect rules preceding subsection 
comment rst rules appendix example demonstrate power recursive types 
example 
derive typing xpoint operator desired assignment clear guess correct type abbreviate observe xx xx leads xx nally combining sequent obtain type expression 

rules 
shows rules speci complete typing rules 
expressions evaluate executable processes get type 
channels homogenous carry values type 
input port type output port type skip 
speci rules rules introduce type 
name main skip 

properties type system 
list properties ensure type system adequate 
lemma 
derivable derivation chosen contain sequent contains type assignments form free name derivation uses left left theta weakening 
proof 
induction length derivation sequent axiom identity right assertion clear 
look rule derivation 
rule instance left left theta weakening assertion follows immediately induction hypothesis 
rule remaining rules apply induction hypothesis premises reassemble proof 
case right rule intermediate sequent divided part form linear type inference functional language processes derivation steps starting intermediate sequent permuted leave unchanged long possible 
gives derivation cases left rule contraction respective rules applied individual names building pattern cases rules observe dioeerent premises 
proof reveals contain type assignments free names derivation right rule 
follows case expression possesses nonlinear type free names possess nonlinear types 
important proposition needs lemmas interesting right 
rst sort cut elimination theorem linear logic 
second shows process able communicate channel contain free name 
reason roughly obtained preceding communication 
main idea proofs expressions certain form created certain rules 
creation expression righthand side sequent lefthand side may change 
contraction rule candidate 
changes expression inessential way 
take liberty ignore 
lemma cut elimination 
derivable normal form form derivable 
proof 
proof induction lengths derivations rules righthand side irrelevant part rst sequent lefthand side second sequent induction hypothesis apply rules 
rules identity axiom left left theta weakening left contraction fall rst category 
left left theta left weakening fall second 
rule obviously harmless type equivalence transitive 
rules second sequent require name right right theta right contraction right 
identity axiom left cases 
remaining combinations handled follows inclusion type equivalence left reader reduces premise xn xn theta delta delta delta theta theta delta delta delta theta reduces xn applications induction hypothesis equivalent assertion 
rst sequent result weakening name free substitution eoeect assertion obtained applications weakening rule 
possibility allows 
reduces applying induction hypothesis premises 
rules change expressions ones introduce nonlinear types 
remains consider contraction rule side 
dioecult case rst lemma chosen contains free names form applications induction hypothesis premises contracting names get equivalent assertion 
lemma original recovered modi ed contraction rule second sequent causes problem chosen names appear lemma communication 
derivable gamma gamma 
gamma gamma gamma 
derivable suitable derives applications left theta rule 
proof 
proof induction length derivation 
rule left left theta left contraction weakening change expression apply induction hypothesis 
rule transition caused assertion follows induction hypothesis 
remaining cases transition possible respectively reduced name lemma derivation contain sequent derivation contain sequent 
names introduced identity axiom 
appears respectively 
applying left weakening rules rst obtain required 
proposition subject reduction 
lexical variation gamma 
gamma gamma 
suitable derives applications left theta rule contraction 
gamma gamma gamma 

formally start disjoint copies linear type inference functional language processes proof 
show rst lexical variation preserves types 
identities gure possible types 
identity needs presence type shown simple example assignment possible unfolding value suddenly accessed times 
derivation contain rule 
derivation theta derivation contain right theta rule 
derivable theta derives theta applications left theta contraction 
name appears free need contain name lemma conclude derivable 
general apply lemma derivation obtain construct derives applications left theta contraction 
theta derivable suitable type 
largest part form contraction rule allowed contain name nonlinear type corresponding subterm nonlinear type 
follows derivable 
replace instance identity axiom derivation derivation apply contraction rule necessary 
yields derivation name linear type appear appear derivable derivation derivation replaced derivation 
put assignment appear put free names obtain derivations replace instances identity axiom derivation derivation completes construction 
rule derivation consider relations prove assertion induction length derivation axiom identity right instance right rule gamma 
impossible 
look rule derivation apply induction hypothesis premises 
concerning contraction note choice names impact execution sequences 
interesting cases nature transition depends form expression ffl dn dn theta delta delta delta theta gamma 
induction hypothesis applies ffl theta gamma 
derivation theta contain right theta rule 
derivations suitable theta derives theta applications left theta rule contraction 
induction hypothesis derivation assertion obvious 
ffl gamma 

rst case induction hypothesis applies second case derivation contain right rule 
derivation assumption normal form form gives derivation lemma 
ffl gamma 

induction hypothesis applies ffl skip skip leads directly premise 
ffl gamma 
gamma gamma gamma 
gamma gamma gamma 
rst case induction hypothesis applies second case derivation contain rule 
derivations suitable derives applications left theta rule contraction 
lemma contains type assignment type assignment induction hypothesis applies giving derivations suitable derives applications left theta rule contraction 
clearly derivation induction hypothesis applies gives derivation derivable 
rule derivable 
sequent derives applications left theta rule contraction 
rule derivable 
ffl gamma 
gamma gamma 
rst case induction hypothesis applies second case directly leads premises 
ffl gamma 
gamma gamma gamma 
rst case induction hypothesis applies second case assertion follows linear type inference functional language processes proof right rule 
consequence situation prevented computation expression form confused expression form delta delta delta dioeerent contain free name statement main problem solved 

type inference type inference constructs possible types derived rules preceding section course build known algorithm handling fragment modality 
terms types enhanced introducing free type variables represent type 
type general type obtained substituting types variables reasonable speak general principal type expression depending set type assignments type exists computed solving set equations involving type variables 
review idea generating equations 
subexpression name type variable 
set equations variables computed structure example form unique rule yielding type type variables belonging respectively get equation setting 
example type variable name lefthand side equal type variable expression righthand side instance identity axiom sets equations solved rst order uni cation type terms 
order uni cation extended regular trees see example section yields algorithm recursive types 
task extend algorithm include modality respecting equation 
appendix shows involutive function handled general 
unary second order variables introduced seen boolean values 
say type form av representing 
need complicated structure constructor changes type changing expression 

attributes 
idea annotate names expressions additional variables called attributes 
attributes encode applications rules 
attribute belonging name means left rule applied introduced equivalently iis type instance identity axiom replaced derivation rules 
form similarly expression right rule 
identity axiom right rule arbitrary number type assignments lefthand side 
application rule introduces implication 
delta delta delta attributes names attribute implication written equation delta delta delta new unique attribute belonging 
note time corresponds unary second order function belonging 
expressions attributes delta delta delta conjunction delta delta delta attribute rst position plays special role 
note obtain single attribute 
expressions delta delta delta am delta delta delta considered equal identical fa amg fb de ne substitutions oe mapping attributes expressions way general uni ers exist renaming 
usual carrier oe set attributes oe nite 
set equations 
attribute rst position exactly expression image oe 
delta delta delta expression image oe oe oe delta delta delta oe 
partial order properties ffl delta delta delta am ffl delta delta delta am delta delta delta fb fa am gives general uni ers oe delta delta delta oe oe delta delta delta am oe delta delta delta oe oe delta delta delta am delta delta delta oe delta delta delta oe oe delta delta delta oe second case note uni er ae satisfy ae ae delta delta delta am ae ae delta delta delta anyway ensure uniqueness oe general extension renaming 

algorithm consider derivations right rule moment 
consider sub expression unique type variable attribute assume set equations created far 
case continue considering structure add equations pass subexpressions type variable attribute belong subexpression unique attribute belonging write set attributes belonging free names set easy compute values attributes type term pattern de ned inductively name av av pair attribute type variable belonging xn theta delta delta delta theta 

linear type inference functional language processes ffl add equations ffl add equations ffl add equations equations 
ffl skip add equations ffl add equations create new type variables attributes equations fa new type variable attribute ffl add equations equations 
ffl add equations new type variable attribute add ffl create new type variables vn attributes names type term including attributes corresponding pattern add 
equations universal closure oe oe solution point 
place solve proceed 
attribute type variable oe occur outside oe polymorphic 
add equations equations 
ffl create new type variables vn attributes names type term including attributes corresponding pattern add equations fa ffl add equations av equations 
ffl add equations type variable attribute belong ffl add equations theta delta delta delta theta vn delta delta delta en 

equations actions straightforward 
problem equations solved 
ordinary types done uni cation type terms 
attributes treated previous subsection 
unify components separately 
property ensures algorithm correct 
theorem 
assume xn derivable algorithm computes set equations ft general uni er oe 
av unique attribute type variable belonging principal type oe av property set types xn equals set types obtained substituting types attribute expressions variables hindley milner algorithm attributes type variables replaced fresh copy uni cation 
proof 
rst part statement follows induction length derivation xn consider rule derivation construct oe 
lemma know xn contains free names name containing principal position assertion obvious oe oe rst rule simply recurs induction hypothesis 
second rule assertion obvious 
xn xn theta delta delta delta theta dn dn theta delta delta delta theta rst rule simply recurs induction hypothesis 
second rule assertion follows induction hypothesis general uni ers oe premises disjoint sets type variables attributes 
obtain delta delta delta en theta delta delta delta theta 
theta vn type equation solution clearly substitution instance 
derivation theta contain right theta rule 
derivations suitable theta derives theta applications left theta rule contraction 
follows contains type assignment name occurs created contraction rule 
cases assertion follows induction hypothesis 
rst rule observe general uni ers oe oe premises disjoint sets type variables attributes 
equation solution second rule oe cases assertion follows induction hypothesis 
rst rule attribute name set violating equations 
occurs expressions delta delta delta second rule observe attribute form occur 
elements appear attribute set violating equations 
third rule attributes names equal pairwise equal 
name free linear type inference functional language processes rules simply recur induction hypothesis 
rst rule assertion obvious 
cases assertion follows induction hypothesis 
second rule general uni ers oe oe combined exists 
third rule observe general uni ers oe oe premises disjoint sets type variables attributes 
skip rst rule simply recurs induction hypothesis 
second rule assertion follows induction hypothesis 
value cases assertion follows induction hypothesis 
rst rule general uni ers oe oe oe combined exists 
oe oe disjoint sets type variables attributes 
equation solution second rule general uni ers oe oe combined exists 
value converse consider structure cases rule yielding expression form 
recur induction hypothesis subexpressions appear premises rule ll remaining type variables attributes 
remains allow common names dioeerent premises multi premise rules rule set attribute handled contraction rule algorithm right thing 
distinguish cases 
attribute value leads situations shown applications left rule necessary 
implies expression righthand side 
lefthand side contains additional names free apply lemma rst 
case instance right rule follows 
necessary lefthand side recovered applications weakening rule left rule left theta rule 

algorithm ii 
allow right rule 
implies entitled say subtype written 
reason implies extend relation composite types follows ffl theta delta delta delta theta theta delta delta delta theta ffl ffl 
suitable rules types form turn types channels determined exactly 
course type inference algorithm infer specialized type 
type case function type argument general possible 
ensure necessary generality prescribing principal positions resulting type equal 
prescribed positions reader expect principal positions principal positions principal positions theta delta delta delta theta principal positions principal appear inferred type uni cation fails anyway 
pass prescribed positions appropriate subexpressions 
list changes respect algorithm preceding subsection 
general rule prescribed 
check starting empty set equations 
solve resulting set equations provided possible 
discard 
equations added remaining changes ffl equations name appear ffl type inferred rst 
solve proceed 
gives prescribed positions passed turns principal types exist 
theorem 
assume xn derivable algorithm computes set equations started occurrences principal positions ft general uni er oe 
av unique attribute type variable belonging principal type oe av property sets equal ffl set types xn occurrences principal positions ffl set supertypes obtained substituting types attribute expressions variables proof 
reconsider rules 
name containing principal position assertion obvious prescribed positions 
rules simply recur induction hypothesis 
rst rule prescribed positions substitution instance subtype substitution instance supertype ensures exists 
hand substitution instance subtype substitution instance subtype suitable substitution instance induction hypothesis derivable 
derivable 
second rule solvable equations concerning names appear hand names introduced weakening rule arbitrary types 
obviously prescribed rule recurs induction hypothesis solve set equations solvable replacing set equations solvable 
obvious corollary derivability sequent decidable 
note obtain principal type prescribe occurrences principal positions 
positions principal positions exactly position 
convention principal position 
linear type inference functional language processes 
notes implementation 
natural top left right strategy imposed preceding subsection welcome 
error smallest possible subexpression 
function argument application disagree type error argument function 
natural type prescribe program 
set equations solved 
concretely unify types top attributes bottom 
means rst equation followed type equations subexpressions program 
attributes collected identi ers reached 
attributes built expressions set necessary equation reached 
identi ers type variables attributes introduced way time expression encountered 
dioecult maintain premise right rule 
fresh set equations mean identi ers environment available original types 
hand easy determine identi er expression 
analysis pointless 
check equation type variable attribute pair identi er set equations expression inspected 
identi er expression appears subexpressions type means type identi ers appear lefthand side sequent 
nal observation things easier 
need store recursive substitutions attributes oe delta delta delta information obtained occurrences keep oe unde ned 
attribute expression containing contains need bother set uni cation oe delta delta delta am oe delta delta delta done introducing fresh attribute oe oe fb fb amg fa am fa 
datatypes process nets able implement algebraic speci cations 
identify important parts 
datatype constructors 
notation equals de nition algebraic datatypes functional programming languages 

rules modi ers selectors 
usually take form equations rewriting rules 

usage objects type 
involves evaluating variable calling operation compute new object pattern matching constructors obtain parameters 
running examples serve illustrate concepts 
example 
boolean expressions consist constructors false true modi ers 
boolean false true case false true true false case false false true case false true true control structures implemented pattern matching 
example 
queues elements arbitrary type consist constructors empty join modi er rest return queue rst element selector retrieve rst element 
queue empty join queue rest case join case empty join join rest case join case empty join test queue empty implemented pattern matching 
queues example simulate asynchronous communication 
operations look depends linear normal type implemented 
case expression translated process net 
sake readability abbreviate expressions form remainder section 

normal types 
normal types implemented functions evaluates process 
interface contains output ports communicate instances output port constructor 
retrieve arguments pattern matching 
operation type modify crucial property contain free variables nonlinear type 
rst implement datatype de nition delta delta delta mnm constructors type jk datatypes 
basic idea de ne constructors note parameter types nonlinear type nonlinear 
result object type ready identify sending parameters appropriate port 
turns form general picture 
operations objects type modify body function building process net 
easier receive parameters input ports send result output port 
extend solution follows delta delta delta 
parameters read input ports result written output port turn item list implementing remaining operations datatype 
consider equation operation parameters body translate delta delta delta translation values send result port linear type inference functional language processes expression evaluated send result port consider evaluation variable rst 
simply translated complicated call operation parameters 
translated delta delta delta en en translations available values send result port problem translate case discrimination case delta delta delta assume translation sends result port assume constructors type takes parameters construction looks follows delta delta delta delta delta delta vn vn translations vn straightforward translation available values including send result port means concrete examples shown 
example 
boolean expressions translated shown gure 
note false true 
false true false 
false true true true false false true 
implementation boolean expressions case discrimination variable done little simpler general described 
example 
queues translated shown gure 
note need assumptions element type empty join 
empty join empty 
empty join join rest rest join 

implementation queues 
linear types 
linear types implemented tuples output ports forming interface 
output port constructor 
chance get copy tuple 
implement datatype de nition 
constructors look follows delta delta delta delta delta delta result process send interface port interface link process 
constructs translated case discriminations simpler 
notations construction looks follows delta delta delta vn vn translations vn 
apply translations examples 
example 
boolean expressions translated shown gure 
example 
hard time implementing previous speci cation queues intrinsically nonlinear 
start slightly dioeerent speci cation rest case join case empty empty join join rest join case join case empty join join queues translated shown gure 
extended rudimentary functional language concurrency features 
conventional program turned single threaded process 
change visible inside process presence channels 
linear type inference functional language processes false true false false true true false true false false false true true false true true true false false true 
implementation linear boolean expressions empty join empty empty join join empty join empty empty empty join join empty join join rest empty join rest join join join 

implementation linear queues channels unique objects duplicated represent outside world process 
representation understood terms datatypes seen section 
uniqueness channels ensured linear type system 
presentation type inference algorithm shows close connection derivation rules sequent calculus 
proof correctness easy 
allows compute linearity attributes usual types 
extensions algebraic data types pose problems language form able simulate 
remains shown linear type systems compatible advanced concepts type classes see real obstacle 
monads suggested manage side functional languages 
noted ports serve purpose passed exactly way 
opinion channels basic mechanism state monads encapsulate channels underlying runtime system 
monads provide convenient syntax state manipulations state manipulations 
hide dioeerence name containing principal position normal form form xn xn theta delta delta delta theta dn dn theta delta delta delta theta delta delta delta delta delta delta name free 
rules intuitionistic linear logic applicative imperative programming style 
force appearance immutability environment appropriate 
think process calculi bring dynamics back functional languages 
prototypical implementation type inference system haskell currently available ftp ftp informatik uni mainz de pub sources tar gz 

author georg helpful discussions comments earlier versions report 
appendix rules intuitionistic linear logic vary notation look familiar 
tensor product cumulative conjunction omega types written theta cartesian product 
direct product alternative conjunction written intersection 
linear implication ordinary function generator 
exponential 
fact modality turning linear types ordinary ones written 
adopt constants known arbitrary type 
shows rules intuitionistic linear logic notation 
iv free dj means assignment appears free notations introduced main text 
rules bear names rst lines contain identity axiom cut rule line contains weakening contraction called structural rules left right axioms rules type constructors theta lie 
right rule deviates original 
normally dedicated constant possess type 
values linear type inference functional language processes needed computation 
unpleasant side eoeect type identity axiom restricted 
rules express basic idea linear types occurrence name consumes access right identity axiom 
multiple access rights obtained contraction rule 
requires pattern question nonlinear type 
pattern bound expression actual parameter needs nonlinear type 
expression get nonlinear type right rule depends solely nonlinear components 
appendix completeness rules type equivalence want show rst rules gure complete equivalence recursive types 
correctness rules quite obvious 
start observation types involving xpoint operator established short proof account proof gives proof instance axiom replaced proof follows equality compatible substitutions xpoint operators involved axiom system better suited carrying proofs 
extend equations sequents meaning equations left valid equation right 
replace rules question axiom rule note allow usual weakening contraction 
new set rules known complete 
remains shown derive new rules derive old rules 
prove induction structure proof tree 
application second rule done 
rule shortens lefthand side lefthand sides empty recover original rules 
consider application rule application rule front 
moment forget symmetry equality add symmetric version rule 
trick ensures premise subterm decomposing proof tree premise write paths axioms leaves 
paths 
distinguish possibilities 
path leads axiom identity type constants equation proof works lefthand side 

path leads axiom introduce new variable corresponding occurrence regard term 
replace occurrence path get proof works assumption combining cases proof vn suitable follows application original rule short proof need apply rule 
easy exercise show old rules follow new rules 
appendix unification involutive function look uni cation regular trees unary functions involutive fft term call function remind equivalent second order identity surprising solution involves certain unary second order variables 
set equations 
introduce unary secondorder variable variable may take possible values identity id 
kinds equations normal equality equality modulo means algorithm compute general uni er oe 
note allow sides equation 
procedure carries list equations needed handle recursive equations 
ffl normal equations gt gt extend oe 
gt gt extend oe id 
extend oe 

start extend oe 
linear type inference functional language processes ffl equations modulo eventually lead normal equation 
equivalently assume chains eliminated 
choose gt gt extend oe xx 
start procedure obviously terminates 
correctness proven usual step uni er obtained oe 
barendregt lambda calculi types 
chapter handbook logic computer science volume background computational structures clarendon barendsen smetsers conventional uniqueness typing graph rewrite systems 
lncs barendsen smetsers derivation system uniqueness typing entcs graph grammar semantics higher order programming language distributed systems 
lncs coppo type inference recursive types syntax semantics 
information computation courcelle fundamental properties nite trees 
tcs 

girard linear logic 
tcs guzm hudak single threaded polymorphic lambda calculus proc 
th annual symposium logic computer science ieee computer science press kobayashi pierce turner linearity pi calculus 
conference record popl rd acm sigplan sigact symposium principles programming languages lincoln mitchell scedrov shankar decision problems propositional linear logic 
annals pure applied logic martini masini modal view linear logic 
journal symbolic logic milner parrow walker calculus mobile processes ii 
information control milner theory type polymorphism programming 
journal computer system sciences milner calculus communicating systems 
lncs milner calculi synchrony asynchrony 
theoretical computer science milner functions processes 
lncs milner polyadic calculus tutorial 
logic algebra speci cation springer pierce programming pi calculus 
experiment concurrent language design 
tutorial notes pict version 
november prasad mishra operational algebraic semantics facile symmetric integration concurrent functional programming 
icalp lncs linear types higher order processes class directed channels entcs thomsen plain chocs second generation calculus higher order processes 
acta informatica thomsen theory higher order communicating systems 
information computation van bakel complete restrictions intersection type discipline 
tcs ph 
wadler theorems free 
th international symposium functional programming languages computer architecture ph 
wadler linear types change world 
broy jones editors programming concepts methods north holland ph 
wadler linear logic 
sigplan notices ph 
wadler comprehending monads 
mathematical structures computer science wirsing algebraic speci cation 
chapter handbook theoretical computer science volume formal models semantics elsevier johannes gutenberg universit mainz institut informatik postfach mainz germany mail address informatik uni mainz de 
