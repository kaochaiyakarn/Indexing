department computer science series publications report discovery frequent patterns large data collections hannu toivonen university helsinki finland department computer science series publications report discovery frequent patterns large data collections hannu toivonen permission faculty science university helsinki public criticism iii december th clock noon 
university helsinki finland contact information postal address department computer science box fin university helsinki finland email address cs helsinki fi internet url www cs helsinki fi telephone telefax copyright fl hannu toivonen issn isbn computing reviews classification helsinki helsinki university printing house discovery frequent patterns large data collections hannu toivonen department computer science box fin university helsinki finland hannu toivonen cs helsinki fi www cs helsinki fi phd thesis series publications report helsinki november pages issn isbn data mining knowledge discovery databases aims finding useful regularities large data sets 
interest field motivated growth computerized data collections high potential value patterns discovered collections 
instance bar code readers supermarkets produce extensive amounts data purchases 
analysis data reveal useful information shopping behavior customers 
association rules instance class patterns tell products tend purchased 
general data mining task consider class patterns possibly occurrences data collection determine patterns occur frequently probably useful ones 
characteristic data mining applications deal high volumes data patterns 
address algorithmic problems determining efficiently patterns frequent data 
contributions new algorithms analyses problems pattern classes data mining 
extensive experimental results 
start giving efficient method discovery frequent association rules known data mining problem 
introduce problem discovering frequent patterns general show association rule algorithm extended cover problem 
analyze problem complexity derive lower bound number queries simple realistic model 
show sampling discovery exact association rules give algorithms efficient especially terms amount database processing 
show association rules negation disjunction approximated efficiently 
define episodes class patterns event sequences alarm logs 
episode combination event types occur close 
give methods discovery frequent episodes event sequence 
algorithm discovery association rules commercial data mining products episode algorithms telecommunication operators discovered episodes alarm handling systems 
computing reviews categories subject descriptors information storage retrieval content analysis indexing artificial intelligence learning analysis algorithms problem complexity algorithms problems general terms algorithms theory experimentation additional key words phrases data mining knowledge discovery association rules episodes ii am grateful advisor prof heikki mannila guiding doctoral studies 
deep involvement continued support invaluable preparation dissertation 
large parts research reported results joint efforts dr verkamo 
hand benefitted insightful comments prof prof tarhio 
carried department computer science university helsinki 
am grateful head department prof prof ukkonen personnel department inspiring pleasant working environment 
particular team mates data mining group collaboration research friends coffee room refreshing breaks research 
financial support academy finland th anniversary fund university helsinki helsinki graduate school computer science gratefully acknowledged 
parents toivonen support years 
iii iv contents discovery association rules association rules rule generation finding frequent sets candidate generation database pass experiments extensions related discovery frequent patterns discovery task generic algorithm examples exact database rules inclusion dependencies functional dependencies discovery database states complexity finding frequent patterns border complexity generic algorithm problem complexity complexity computing selection criteria computing border related sampling large databases frequent sets sampling discovery frequent sets analysis sampling experiments discovery boolean rules frequent sets boolean formulas rules computation frequencies experiments discovery episodes sequences event sequences episodes definitions generation candidate episodes recognizing episodes sequences general partial orders experiments extensions related discussion vi chapter information currency era value 
information knowledge surely wisdom 
john lippman data mining aims discovery regularities large data collections 
rapidly growing interest field stimulated large amounts computerized data available business science 
instance supermarkets store electronic copies millions receipts banks credit card companies maintain extensive collections transaction histories 
goal data mining called knowledge discovery databases kdd short analyze data sets find regularities provide new insight business process generates data 
overview research data mining 
current interest data mining understandable companies large collections data describing daily operations 
instance countries retailers required law store copies receipts sales 
stores copies customer 
cash registers immediately save information electronic format 
telecommunication operators store events networks trouble shooting purposes 
companies realizing new methods emerging analysis databases accumulated side product methods possibly gain competitive advantage 
discovery association rules ais identified important data mining problem 
original motivation searching association rules came need analyze called supermarket basket data examine customer behavior terms purchased products 
asso ciation rules describe items purchased instance association rule beer chips states customers bought beer purchased chips 
rules useful decisions concerning product pricing promotions store layout 
discovery association rules serves starting point thesis 
chapter give efficient method finding association rules apply user specified number rows database confidence exceeds threshold user 
experiment university course enrollment database search combinations courses taken students 
association rules simple form frequent patterns 
see mean frequent note interesting find association rule logically holds analyzed database 
assume instance supermarket sold hammer analyzed time period hammer happened bought customer purchased vase 
inference hammer sold vase useful business decisions association statistically significant 
interested patterns occur times database 
times pattern occur considered frequent depends course application domain 
typical require instance small fraction rows database matches pattern 
chapter consider general data mining task discovering frequent patterns class generic algorithm solves task 
discovery criterion need frequency show called exact database rules inclusion dependencies functional dependencies discovered generic algorithm 
criticized aspect knowledge discovery analyzing just state database give reliable information regularity exist analyzed database chance 
chapter describe method knowledge discovery similar databases states database 
business data sales information analyzed searched interesting knowledge 
new current state technology allows efficient verification high number hypothesis large collections data 
point data mining best contrasted close scientific neighbors statistics machine learning 
compared data mining statistics geared analyzing fitting relatively complicated models data 
statistics great deal effort put specifying exact questions asked data data mining methods typically evaluate automatically large number relatively simple questions 
aspects carefully dealt statistics significance variation explicit bias largely ignored data mining 
statistical perspective data mining ep 
researchers machine learning community think field machine learning covers data mining 
case typical machine learning typical data mining contrasted 
research machine learning devoted discovery regularity input output attributes 
data mining differs tasks aspects focus regularities unexpected attributes discovered regularities simpler 
example consider analysis supermarket basket data 
cat food target product machine learning method induction decision trees probably find complex expression identifying quite reliably shopping baskets contain cat food 
data mining typical specify target product search simple patterns association rules strong respect product 
words data mining tends trade complexity patterns complexity selecting components patterns 
analyze chapter complexity problem discovering frequent patterns 
derive lower bound number queries form frequency pattern needed find frequent patterns show algorithm discovery association rules optimal simplifying assumptions 
developed concepts derive bounds known problem finding functional dependencies 
bounds functional dependencies new simplicity derivation demonstrates power general formulation 
contrast machine learning data mining seen amount analyzed data 
data mining assumed data collections large millions billions rows 
large data sets considered necessary reliable results unfortunately execution time mining algorithms depends heavily database 
time complexity discovering association rules linear number rows database existing algorithms require multiple passes database 
subsequently size database influential factor execution time large databases 
chapter develop method essentially reduces database activity pass 
discuss sampling discovery association rules analyze accuracy results obtained random sample 
main contributions new methods discovery exact association rules 
methods sample initialize discovery database pass compute results 
terms database activity method outperforms known methods attractive especially large databases 
give experimental results showing methods practice 
far mainly interested efficiency issues discovery 
time note class association rules simple positive connections sets items expressed 
chapter consider powerful rule formalism class boolean rules 
basically boolean rules association rules negation disjunction rules diet soda chips expressed 
demonstrate task discovering boolean rules hold database useful feasible 
show boolean rules derived information derive normal association rules 
necessary information available frequent boolean rules 
show experimentally approximations frequencies confidences computed available information 
application areas data sequential nature 
consider instance monitoring system telecommunication network world wide web server computer application user 
lot information activities recorded 
example switches critical equipment telecommunication networks produce large amounts notifications trouble shooting purposes 
sequence events produced network contains detailed fragmented information network behaves relationships components 
discovery regularities sequences useful prediction faults 
chapter episodes class frequent patterns sequences events 
episode combination events occurring frequently frequent episodes known possible generate rules describe occurrences events prediction 
methods discovery episodes sequences give experimental results telecommunication event databases 
chapter conclude short discussion 
described thesis consists hand theoretical algorithms concepts discovery frequent pat terns hand practical experiments support theory 
results published joint articles prof heikki mannila dr verkamo algorithm finding association rules ams mtv generalized problem algorithm analysis mt methods finding association rules sampling toi idea approximate discovery boolean rules mt problem discovering frequent episodes sequences mtv mtv 
material thesis represents original definition association rules basic rule generation method chapter 
half described thesis construction discovery system called implements methods 
development methods taken place collaboration data mining activities analyze real databases 
development methods analyzing sequences particular benefitted working real data real problems 
projects gained algorithms regularities discovered telecommunication databases incorporated event handling software telecommunication operators hkm 
tasa discovery system tools browsing discovered rules described hkm hkm 
chapter discovery association rules predicting easy 
getting right hard part 
howard frank start studying discovery association rules simple important case frequent patterns 
specify problem formally section 
section review association rules generated frequent sets items input 
section starts contributions thesis 
section give efficient method discovery frequent sets 
experiments method described section 
review extensions related section 
parts described chapter published ams mtv 
association rules collection sets items association rules describe various combinations items occur sets 
typical application association rules analysis called supermarket basket data goal find regularities customer behavior terms combinations products purchased 
simple data model consider 
definition set binary database collection multiset subsets elements called items elements called rows number rows denoted jrj size denoted jtj 
discovery association rules row id row fa gg fa fg fb kg fa hg fe jg example binary database set fa kg 
example domain supermarket basket analysis items represent products stock 
items beer chips milk bread 
row basket database corresponds contents shopping basket product type basket corresponding item row 
customer purchased milk corresponding row database 
quantity price items considered model binary information product purchased 
note number different items order thousands typical purchases contain dozens items 
sparse databases jtj closely corresponds physical database size practical storage structures 
letters alphabet denote items 
set items denoted sets items denoted letters alphabet calligraphic symbols denote collections sets 
databases denoted lowercase letters rows letters interesting property set items rows contain 
brings formal definition term frequent 
definition set binary database set items 
item set matches row set rows matched denoted ft tg frequency denoted fr jm jrj write simply fr database unambiguous context 
frequency threshold min fr set frequent fr min fr literature terms large covering frequent term support frequency 
association rules row id example binary database relational form valued attributes fa kg 
example consider binary database set fa kg 
instance fa bg ft fr fa bg 
database viewed relational database schema fa kg valued attributes name binary database 
presents database form 
set frequent matches fraction min fr rows database frequency threshold min fr parameter user depends application 
notational convenience introduce notations collections frequent sets 
definition set binary database min fr frequency threshold 
collection frequent sets respect min fr denoted min fr min fr fx fr min frg simply frequency threshold clear context 
collection frequent sets size denoted fx jx lg example assume frequency threshold 
collection frequent sets database ffag fbg feg fgg fa non empty set occurs row 
empty set trivially frequent binary database ignore empty set non interesting case 
move define association rules 
association rule states set items tends occur row set items 
associated rule factors confidence frequency 
discovery association rules definition set binary database sets items 
expression association rule confidence denoted conf jm jm frequency fr fr write simply conf fr database unambiguous context 
frequency threshold min fr confidence threshold min conf holds fr min fr conf min conf words confidence conf conditional probability randomly chosen row matches matches frequency rule amount positive evidence rule 
rule considered interesting strong common 
association rule discovery task ais min fr min conf find association rules hold respect min fr min conf disjoint non empty 
example consider database 
suppose frequency threshold min fr confidence threshold min conf 
association rule disjoint non empty left right hand sides holds database fag fbg 
frequency rule min fr confidence min conf 
rule fbg fag hold database confidence min conf 
note association rules monotonicity properties respect expansion contraction left hand side 
holds fag necessarily hold fag necessarily sufficient frequency confidence 
fag holds necessarily hold sufficient confidence 
association rules monotone respect expansion right hand side holds fag necessarily hold sufficient frequency confidence 
association rules monotone respect contraction right hand side fag holds holds 
rule generation association rules hold binary database discovered phases ais 
find frequent item sets frequencies 
test separately ae rule finding frequent sets holds sufficient confidence 
algorithm ais uses approach generate association rules hold input database 
harder part problem task finding frequent sets considered subsection 
note indentation algorithms specify extent loops conditional statements 
algorithm input set binary database frequency threshold min fr confidence threshold min conf 
output association rules hold respect min fr min conf frequencies confidences 
method 
find frequent sets algorithm 
compute min fr fx fr min frg 
generate rules 
min fr 
ae 
fr fr min conf 
output rule fr fr fr theorem algorithm works correctly 
proof note conf jm jm fr fr clearly association rules output algorithm hold input database fr min fr fr min fr line conf min conf line 
association rules hold input database output algorithm 
fr min fr fr min fr min fr line 
possible rule checked lines 
conf min conf rule output line 
finding frequent sets exhaustive search frequent sets obviously infeasible smallest sets search space potential frequent sets consists jrj subsets efficient method discovery frequent sets iterative approach 
determine collection candidate episodes size obtain collection frequent sets computing frequencies candidates database 
large data collections computation frequencies database expensive 
useful minimize number discovery association rules cost generation phase 
generate small sufficient collection candidates observe properties item sets 
obviously subset items frequent superset frequency monotone increasing respect contraction set 
means sets items fr fr frequent frequent 
proposition takes advantage observation gives useful information candidate generation set subsets frequent safely discarded candidate collection jx proposition states suffices know subsets smaller frequent 
proposition set 
proper subsets ae frequent frequent non frequent subset ae size jx gamma 
proof claim follows directly observation frequent subsets ae frequent 
argument applies claim ae exists ae jzj jx gamma 
frequent frequent 
example know ffa bg fa cg fa fa fg fb cg fb fc ggg conclude fa cg fa possible members sets size subsets size included 
know empty 
proposition define candidate collection sets size consist sets possibly frequent frequent sets size definition collection frequent sets size candidate collection generated denoted collection sets size possibly frequent fx jx jy lg give algorithm finds frequent sets 
subtasks algorithm specifications described detail subsections 
finding frequent sets algorithm input set binary database frequency threshold min fr 
output collection min fr frequent sets frequencies 
method 
ffag rg 


database pass algorithm 
compute fx fr min frg 

candidate generation algorithm 
compute gamma 
output fr theorem algorithm works correctly 
proof show induction computed correctly collection contains sets size line collection contains correctly exactly frequent line 
assume gamma correctly computed 
gamma proposition line 
collection correctly computed contain frequent sets line 
note algorithm computes jxj frequent set frequent frequent sets subsets sizes jx condition true jx proposition follows definition gives sufficiently large candidate collection 
theorem shows definition gives smallest possible candidate collection general 
theorem collection fx jx lg sets size exists binary database frequency threshold min fr 
proof simple trick set min fr jrj sets frequent 
sets size complete proof show contradiction assume ae definition subsets size candidate generation information just subsets frequent way number candidates reduced 
exact frequency set inferred 
discovery association rules example assume sets fa bg fa cg fa dg fb cg fb dg frequent 
definition gives fa cg fa dg candidates theorem shows binary database exists fa cg fa dg frequent 
know fr fa cg fr fa bg infer fr fa dg min fr 
intuitively item partitions database fa bg occurs min fr occurs fr fc dg min fr fa dg frequent 
frequency fa cg computed necessary compute frequency fa dg database 
slightly different situation fr fa bg fr fag 
fag fbg fa cg fa cg fr fa cg fr fa cg 
frequency fr fa cg needs computed database 
algorithm principle take advantage situations similar examples 
situations occur frequently effort saved effort put finding cases 
furthermore algorithm combines computations frequencies candidate sets size pass number database passes seldom reduced 
candidate generation trivial method compute candidate collection check possible set size definition holds subsets size frequent 
efficient way compute potential candidates unions size frequent sets size check rest subsets size algorithm presents method 
efficiency reasons assumed item sets collections item sets stored arrays sorted lexicographical order 
write denote precedes lexicographical order 
algorithm input lexicographically sorted array frequent sets size output lexicographical order 
method 

share gamma lexicographically items 
ae jzj 
continue line 
output finding frequent sets theorem algorithm works correctly 
proof show collection potential candidates considered algorithm superset 
set consider subsets size denote second subset lexicographical order respectively 
share gamma lexicographically items valid candidate 
algorithm iterates sets phase note set lexicographical ordering share gamma lexicographically items 
iteration find superset collection candidates 
potential candidate correctly output subsets size frequent line 
time complexity algorithm polynomial size collection frequent sets independent database size 
theorem algorithm implemented run time jf log jf 
proof outer loop line inner loop line iterated jf times 
conditions line tested time 
line remaining gamma subsets need checked 
binary search set size located time log jf 
output line takes time potential candidate 
total time complexity jf gamma log jf jf log jf upper bound met pairs frequent sets size created 
number iterations inner loop line typically fraction jf computing successive families computed checked single database pass 
trades reduction number database passes increase number candidates database processing main memory processing 
candidates size computed assuming candidates size fact frequent values determined efficiently extra bookkeeping information stored time candidates generated 
closely related method idea section 
discovery association rules 
candidate families computed calls algorithm 
generating candidate families useful overhead generating testing extra candidates nc effort database pass 
unfortunately estimating volume extra candidates general difficult 
obviously useful situations jc small 
example assume ffa bg fa cg fa dg fa fb cg fb dg fb gg fc dg ff ggg ffa cg fa dg fa dg fb dgg ffa dgg practical evaluate frequency candidates single pass 
database pass turn database pass algorithm 
algorithm presents method computing frequencies candidates database 
algorithm input set binary database candidate collection min fr frequency threshold min fr 
output collection min fr frequent sets frequencies 
method 
initialization 
contained 

contained contained fxg 
freq count 
database access 

item count 

contained 
item count item count 
item count freq count freq count 
output 

freq count jrj min fr output freq count jrj finding frequent sets item maintain list contained candidates contain candidate maintain counters 
variable freq count count number rows matches variable item count records current row number items theorem algorithm works correctly 
proof need show frequency candidate computed correctly obviously correct sets output line 
frequency counters initialized zero line 
claim remains frequency counter increased line row consider initialization phase 
lines contained fx xg 
consider lines row lines compute set size intersection variable item count value item count reaches size lines case frequency counter increased 
time complexity algorithm linear size database product number rows number size candidates 
theorem time complexity algorithm jrj jc jrj 
proof time complexity initialization jrj jc jc lines 
time complexity reading database line 
initialization candidates rows takes time jrj jc line 
row candidate updated times worst case time complexity computing frequencies jrj jc 
output takes time jc 
time complexity database pass jrj jc jc jrj jc jrj jc jc jrj jc jrj practical improvements algorithm 
instance determine set frequent read fraction gamma min fr rows database 
relatively large frequency threshold min fr practical check discard candidate rows left needed candidate frequent 
best case candidates discarded fraction min fr database rows left 
best possible saving fraction min fr original time 
discovery association rules size frequency threshold table number frequent sets size different frequency thresholds 
experiments experimental results course enrollment database department computer science university helsinki 
database consists registration information students row student items courses offered department 
shopping basket student contains courses student enrolled stay university 
number courses row contains average courses 
experiments chapters run pc mhz pentium processor mb main memory linux operating system 
data collections resided flat text files 
table gives overview amount frequent sets different sizes frequency thresholds 
table shows number size frequent sets increases quickly decreasing frequency threshold 
frequency threshold corresponds set students students threshold rules hold students 
overview various characteristics experiments table 
top table shows number candidates time took generate 
number frequent sets maximum size time compute frequencies database experiments frequency threshold candidate sets count generation time frequent sets count maximum size database pass time match rules min conf count generation time rules min conf count generation time rules min conf count generation time table characteristics experiments different frequency thresholds 
shown 
row match shows large fraction candidate sets frequent 
lower parts table show number rules generated frequent sets different confidence thresholds time took 
table shows time takes generate candidates smaller magnitude time database pass database small 
large databases candidate generation time practice ignored 
noted number frequent sets grows quickly threshold lowered 
number candidate sets grows identically number rules explodes frequency threshold confidence threshold rules 
table shows candidate generation method works number candidates quite close number frequent sets especially lower frequency thresholds 
table shows detail experiment min fr 
couple iterations combinatorial information available subsequently non frequent candidates 
candidate generation method works effectively match 
times database passes experiments roughly linear discovery association rules candidates frequent sets size count time count time match total table details candidates frequent sets size min fr 
total number items candidate collection 
consistent result jrj jc jrj theorem 
case fairly small constant database small jrj significant 
tested scale properties algorithms producing fold copies data set 
presents relative running times frequency thresholds including candidate generation database passes 
expected execution time linear respect number rows database 
note constant term candidate generation time essentially show figures 
extensions related ais association rules researched lot 
section discuss related regards extensions basic framework association rules 
remotely related research discussed chapter 
candidate generation definition algorithm candidate generation independently mtv 
touch subject chapter detail algorithm deal addition sets multisets ordered sets 
extensions related relative time relative size database theta theta theta theta theta theta results scale tests 
frequent set discovery method ais works generate test fashion candidate generation quite different 
essential difference ais candidate generation evaluation performed database pass 
importantly method fails take advantage proposition generates candidates frequent 
experimental comparisons method ais shown perform worse algorithms section ams mtv 
association rule generation confidence association rules monotone decreasing respect moving items left hand side rule right hand side 
property reduce number potential rules tested rule generation algorithm 
idea set rule tested rules ae high confidence 
candidate generation algorithm construct candidates rule right hand sides 
database pass large databases important minimize database activity improve algorithm 
matching candidate discovery association rules row database straightforward way results repeating done previously 
subsets matched row previous passes 
starting scratch information matches subsets utilized 
particular candidate set matches exactly rows matched subsets size jx gamma 
create new temporary binary database item candidate fill database database pass 
candidate pass items representing subsets previous pass needed determine match old database needed 
trade matching faster reusing results size jm temporary database may larger original database 
reuse usually pay iterations candidates high frequencies 
alternative strategy database pass inverted structures son 
idea organize storage items original database rows 
information item represented set fag identifiers rows contain inverted structures database pass consists computing intersections sets set rows containing intersection sets fag jc candidates items inverted structures results somewhat smaller asymptotic worst case time complexity jrj jc bound jrj jc jrj inverted structures 
main difference inverted structures non frequent items need read 
mentioned idea reusing results previous database passes implemented efficiently storing intersections representing frequent sets 
size temporary database consisting inverted structures jm efficient method discovery frequent sets takes advantage fact small databases database needs read disk remain main memory 
partition method son database large fit main memory partitioned partition analyzed separately main memory 
database pass consists identifying part collection locally frequent sets 
second pass union collections locally frequent sets candidate set 
pass guaranteed locate superset collection frequent item sets second pass needed merely compute frequencies sets 
hashing tasks discovery fre extensions related quent sets 
hashing database pass efficiently determine collection candidates match row 
method turn uses hashing identify prune non frequent candidates database pass 
modification original algorithm ais uses sql discovery frequent sets hs 
item hierarchies association rule algorithms generalized items arranged hierarchies taxonomies hf sa 
concept hierarchies exist items instance supermarket environment know samuel adams beer brand beer beverage 
idea search rules levels hierarchy beer chips samuel adams chips 
rule gives useful information general may interesting confidence differs significantly 
non binary data basic setting association rules sets items 
useful able search associations values attributes general 
association rules discrete values different attributes straightforward way considering attribute value pairs items 
number items sum sizes domains attributes 
candidate generation method modified generate internally inconsistent candidate sets contain items derived attribute 
association rules numeric attributes considered sa 
addition associations single values authors develop methods automatic selection useful value intervals sets rules 
rule selection thousands millions association rules may hold database thresholds confidence frequency clearly point useful rules 
problem rule ranking far trivial 
interactive method browsing rules templates kmr regular expressions specify rules selected explicitly excluded 
automatic methods pruning redundant rules clustering rules considered 
chapters discusses aspect strongly related frequent sets 
chapter generalization algorithm discovery association rules discovery different types frequent patterns 
problem discovering frequent patterns including discovery frequent sets analyzed chapter 
methods sampling reduce amount database processing chapter 
chapter inferring association rules negation disjunction frequent sets discussed 
chapter presents problem discovering frequent episodes event sequences 
chapter discovery frequent patterns need solution couldn just enjoy problem 
anonymous phd student chapter consider generalization problem discovering frequent sets set patterns database find patterns frequent database 
give algorithm task section algorithm direct generalization algorithm 
section give examples setting various knowledge discovery tasks show frequency criteria selecting rules 
section extend setting algorithm discovery database states 
review related postponed follow analysis approach chapter 
parts material chapter published mt 
discovery task significant fraction discussion chapter formalized framework relational data model start defining basic concepts 
definition relation schema set fa am attributes 
attribute domain denoted dom 
row schema sequence ha am dom row ith value denoted 
relation set rows relational database set relations set relation schemas collectively called database schema 
discovery frequent patterns define knowledge discovery setting consider chapter 
set patterns class expressions databases predicate evaluate database satisfies pattern task determine patterns satisfied database 
definition assume set predicate theta fr ftrue falseg elements called patterns selection criterion pattern database say selected true 
selection criterion frequency pattern term frequent synonym selected 
database theory respect trueg example problem finding frequent item sets described task discovering frequent patterns straightforward way 
set binary database frequency threshold min fr set patterns consists item sets fx rg selection criterion true fr min fr 
note specify satisfaction relation patterns task taken care selection criterion applications true mean occurs true true defines way interesting property subgroup obviously task determining theory tractable arbitrary sets predicates instance infinite true infinitely patterns explicit representation computed 
discovery tasks considered aim find patterns selected relatively simple criterion exceeding frequency threshold order efficiently identify space potentially interesting patterns criteria pruning processing patterns 
consider example discovery association rules frequent sets discovered rules sufficient frequency generated confidence threshold prune rules 
task discovering frequent sets noteworthy properties 
frequent sets needed generation association rules 
sufficient know just largest frequent sets determine collection frequent sets 
second important property selection criterion frequency monotone decreasing respect expansion set 
consider situation predicate monotone respect partial order patterns 
generic algorithm definition finite set patterns selection criterion partial order patterns databases patterns imply strength hierarchy respect said stronger weaker 
write oe 
example set inclusion relation strength hierarchy frequent sets 
item sets set weaker implies stronger set frequent weaker set frequent 
practical purposes strength hierarchy computable patterns possible determine 
typically strength hierarchy restriction converse semantic implication relation implies 
predicate defined terms statistical significance semantic implication relation strength hierarchy respect pattern statistically significant weaker pattern 
recall predicate meant way identifying interesting patterns threshold statistical significance prune patterns generic algorithm section algorithm task discovering frequent patterns special case exists computable strength hierarchy patterns 
notation relative strength patterns 
definition strength hierarchy patterns level pattern denoted level oe 
level maximum level patterns oe 
collection frequent patterns level denoted level lg algorithm analogical algorithm finds frequent patterns 
works breadth manner starting set weakest patterns generating evaluating stronger stronger candidate patterns 
algorithm prunes patterns frequent frequent patterns obtained earlier iterations 
discovery frequent patterns algorithm input database schema database finite set patterns computable selection criterion computable strength hierarchy output set frequent patterns 
method 
compute level 


database pass 
compute 

candidate generation 
compute level level oe 
output algorithm generic details depending specific types patterns data left open instances algorithm specify 
algorithm aims minimizing number evaluations line 
frequent set discovery algorithm computation determine candidate collection involve database 
theorem algorithm works correctly 
proof show induction computed correctly collection contains patterns level line collection correctly computed line 
assume collections computed correctly note consider pattern level patterns oe level computed oe correctly level put line 
collection computed correctly line 
note iteration variable value level 
definition level weaker patterns oe level level strength hierarchy frequent condition true level 
input specification algorithm states set finite 
need finite algorithm works correctly long number candidate patterns finite 
desirable properties strength hierarchy 
efficient method accessing weaker stronger patterns neighboring levels useful finding collection valid candidates may expensive 
examples examples look applicability algorithm known knowledge discovery tasks 
formulate problems tasks discovering patterns selected predicate discovery exact database rules inference inclusion dependencies inference functional dependencies 
purpose show algorithm fits different discovery tasks demonstrate selection criterion properties patterns frequency 
exact database rules exact database rules ps rule formalism somewhat general association rules numerical categorical attributes considered 
hand confidence exact rules small variation gives strong rules confidence 
introducing exact database rules formally define notion taxonomy attribute 
definition attribute taxonomy set dom partial order 
assume reflexive special member taxonomy 
example consider attribute department domain dom department dept dept 
taxonomy department consist dom department dept production dept sales names departments types 
partial order classify department type defining dept management dept dept management dept dept production dept dept sales dept additionally dept department dept dept dept definition relation relation schema assume taxonomies non numerical attributes simple condition row form numerical attribute dom form non numerical taxonomy 
exact database rule expression form simple conditions 
rule holds true row true 
discovery frequent patterns relation taxonomies non numerical attributes collection exact database rules hold theory set patterns consists possible exact rules predicate true holds show strength hierarchy exact rules 
theorem relation strength hierarchy respect set possible exact database rules partial order simple conditions defined follows proof denote set rows condition true 
definition relation simple conditions property true row true strength hierarchy simple conditions 
assume exact database rule holds 
consider weaker rule 
properties follows 
rule holds 
proof shows strength hierarchy restriction converse semantic implication patterns implies 
intuitively strength hierarchy means exact database rule holds know modified rule left hand side matches subset rows hold right hand side matches superset rows modified rule hold 
algorithm start rules hold loosen conditions left hand sides tightening conditions right hand sides 
example assume relation represents employees 
consider attributes department previous example age assume domain age 
examples weakest patterns considered algorithm age department department dept age number obvious rules hold 
meaningful rules dealt strength hierarchy prunes rules consideration way 
instance rule department dept age hold rules department dept age department management dept age hold 
note task discovering exact database rules split phases discovery association rules frequent sets rule components discovered 
case exact rules minimum threshold frequency rules 
strong correct rules searched correctness needs carefully defined partial order strength hierarchy 
example demonstrates 
example consider discovery strong rules confidence threshold min conf defined association rules means determining rule strong 
rule department dept age confidence close threshold min conf rule department age strong employees departments dept years old 
discovery frequent patterns algorithm considers database pass collection candidate rules rules level 
kid algorithm ps discovering exact database rules turn considers iteration rules attribute left hand side 
kid directly evaluate rules stores summary information rules hold extracted 
approaches drawbacks 
space requirement summaries kid worst case linear database size 
algorithm turn take advantage fact rules close strength hierarchy similar evaluated efficiently 
lots redundant exact strong rules hold 
exact rules instance giving specific rules hold sufficient rest rules implied 
recall purpose find rules hold methods select useful ones specificity certainly criterion ps 
inclusion dependencies consider discovery inclusion dependencies cfp hold database 
essence inclusion dependency means values attributes relation values attributes relation practical databases inclusion dependencies data interconnected 
discovery inclusion dependencies useful database reverse engineering ka 
definition database schema inclusion dependency expression relation schemas ha hb equal length sequences attributes respectively contain duplicates 
database relations corresponding respectively inclusion dependency holds row exists row inclusion dependency trivial problem database database schema discover collection non trivial inclusion dependencies hold collection theory set consists non trivial inclusion dependencies true examples inclusion dependency holds show suitable strength hierarchy 
theorem relation strength hierarchy respect consisting non trivial inclusion dependencies ha hb fi kg ha hb proof definition row exists row kg 
claim holds trivially subset kg particularly subset fi dependency holds 
strength hierarchy restriction converse semantic implication 
specifications algorithm starts search inclusion dependencies hai hbi trivial ones 
expands attribute lists dependencies dependencies hold 
example consider relation schemas fa dg fe gg dependencies tested hai hbi hf hci dependency ha di hg ei tested dependencies hold ha bi hg ha di hg ei hb di hf ei frequent sets pattern accepted candidate suffices selection criterion true weaker patterns level level gamma 
criterion true follows criterion true weaker patterns requirement algorithm 
number evaluations smaller algorithm best known previous algorithms problem 
algorithms take partial advantage strength hierarchy candidate patterns require weaker patterns level selected weaker patterns selected 
way exact database rules generalized strong rules define correct inclusion dependencies allowing small inconsistencies database 
done defining discovery frequent patterns true fraction rows exists row desired properties relations corresponding note partial order strength hierarchy criterion 
functional dependencies consider discovery functional dependencies cod attributes database example database reverse engineering discovery integrity constraints 
definition relation schema functional dependency expression dependency true relation pairs rows 
functional dependency trivial theorem relation strength hierarchy respect set consisting non trivial functional dependencies proof consider relation set pairs denote set pairs denote corresponding set 

holds pair pair hold 
algorithm starts dependencies iteration size left hand sides decreases 
number database passes jr smallest set true note large relation schema iterations answer representable succinctly set dependencies minimal left hand sides 
example problem iterations partially avoided shifting focus minimal left hand sides true functional dependencies maximal left hand sides false functional dependencies 
predicate strength hierarchy defined true true discovery database states search false functional dependencies starts empty set left hand side dependencies 
iteration dependencies tested true 
left hand sides grow iteration long dependencies hold 
instance dependency fa cg considered candidate dependencies fa bg fa cg fb cg false 
case happen iterations necessary large set attributes derive target attribute 
useful output algorithm approach set candidate patterns selected predicate tested functional dependencies true 
minimal left hand sides true functional dependencies 
strength hierarchy efficient known algorithms discovering functional dependencies 
algorithms depth manner jumping strength hierarchy 
take advantage fact attribute sequence ha attribute predicate evaluated efficiently time functional dependencies fa discovery database states criticized aspect knowledge discovery analyzing just database state give reliable information impossible know regularity exists analyzed database chance true database states 
describe algorithm adopted discover patterns selected criterion database states 
define global selection criterion pattern depend number database states selected 
definition selection criterion set patterns frequency threshold min fr global selection criterion predicate theta fr set ftrue falseg set fr databases true jfi gj min fr delta theory called true theory respect min fr 
discovery frequent patterns note partial order strength hierarchy respect strength hierarchy respect theorem 
theorem definition strength hierarchy respect strength hierarchy respect global selection criterion proof definition relation strength hierarchy respect sets databases imply 
see case consider pattern holds 
holds hold weaker patterns hold 
strength hierarchy respect global selection criterion algorithm applied directly knowledge discovery database states just global selection criterion evaluation consists evaluating individual database states turns strength hierarchy locally globally 
consider algorithm running set fr database states global selection criterion inputs 
candidate patterns algorithm weaker patterns globally selected 
patterns evaluated database state order find selected sufficiently database states 
possible database state patterns weaker selected correspondingly selected key efficient evaluation global selection criterion generate candidates locally database state evaluate patterns candidates globally locally 
specific level global candidate collection contains patterns potentially selected local candidate collections denoted contain database state patterns potentially selected evaluation database state evaluate predicate intersection global local candidates 
information local candidates eliminate evaluations global candidate collection may contain patterns candidates sufficiently collections situation pattern weaker patterns oe selected disjoint database states 
useless evaluation candidates avoided simple check pattern needs discovery database states evaluated jfi gj min fr delta similar check applied failed evaluation order prune candidate soon turns globally selected 
summary information global selection criterion patterns level investigate patterns database state looking database state locally enable investigate patterns combining local global information see investigate patterns method analyze database time order see regularities hold database states analyze similar databases instance find association rules hold stores supermarket chain 
discovery frequent patterns chapter complexity finding frequent patterns solution fit problem 
frustrated phd student analyze complexity finding frequent patterns derive results complexity discovering frequent sets 
section introduce concept border frequent non frequent patterns 
notion turns useful analysis generic algorithm section analysis problem finding frequent patterns section 
section contains notes complexity evaluating selection criteria 
section return concept border show strong connections transversals hypergraphs 
related task discovering frequent patterns generic algorithm analysis reviewed section 
results chapter appeared mt 
border consider theory set patterns 
theory specified giving maximally strong patterns pattern weaker selected rest 
collection maximally strong patterns correspondingly collection minimally strong patterns useful analysis generic algorithm problem 
purpose introduce notion border 
complexity finding frequent patterns definition set patterns subset partial order closed downwards relation fl fl border bd consists patterns weaker patterns pattern stronger bd fl fl oe fl oe sg patterns bd called positive border bd bd oe sg patterns bd negative border bd gamma bd gamma fl fl oe fl sg words positive border consists strongest patterns negative border consists weakest patterns outside border union sets 
note set closed downwards described giving just positive negative border 
consider negative border 
pattern negative border patterns note theory closed downwards respect strength hierarchy concept border applied set frequent patterns 
example consider discovery frequent sets items fa fg 
assume collection frequent sets ffag fbg fcg ffg fa bg fa cg fa fg fc fg fa fgg negative border collection contains sets frequent subsets frequent minimal non frequent sets 
negative border bd gamma feg fb cg fb fgg positive border turn contains maximal frequent sets bd ffa bg fa fgg complexity generic algorithm complexity generic algorithm consider complexity discovering frequent patterns terms number evaluations selection criterion trivial method finding test patterns jp evaluations algorithm evaluates patterns result frequent patterns patterns negative border collection frequent patterns 
theorem algorithm 
algorithm evaluates predicate exactly patterns bd gamma 
proof note pattern evaluated pattern unique level collection recall line algorithm specification candidate collection 
compute level level oe show bd gamma 
note pattern bd gamma 
selected 
selected bd gamma patterns weaker 
note pattern bd gamma level level weaker patterns evaluated earlier iterations levels level 
weaker patterns oe level 
level pattern level shown proof theorem level constructed bd gamma 
candidate generation step algorithm basically compute negative border frequent patterns far 
line equals specification 
compute bd gamma iteration candidate collection generated exactly negative border patterns selected far minus patterns selected 
concept negative border restate complexity frequent set discovery algorithm compact form 
corollary set binary database frequency threshold min fr algorithm evaluates frequency sets min fr bd gamma min fr 
complexity finding frequent patterns proof claim follows directly fact algorithm instance algorithm theorem 
problem complexity analyze complexity problem discovering frequent patterns 
consider verification problem assume somebody gives set claims 
evaluations necessary verifying claim 
theorem shows border bd inspected 
theorem sets patterns database selection criterion strength hierarchy 
database accessed predicate determining requires worst case evaluations done exactly evaluations proof show sufficient worst case necessary evaluate border bd 
claims follow 
assume patterns border evaluated 
pattern bd pattern bd gamma selected definition border 
agree border clearly 
assume evaluations consistent claim pattern border bd evaluated 
way knowing 
evaluations patterns give information consistent border weaker patterns oe selected definition border stronger patterns selected rest irrelevant respect 
words set negative border swapped positive border vice versa changing truth set 
corollary set patterns database selection criterion strength hierarchy 
algorithm computes accesses data predicate evaluate patterns bd 
proof claim follows directly proof theorem 
problem complexity result gives corollaries complexity discovery tasks 
consider discovery frequent sets 
recall algorithm evaluates frequency candidates frequent sets bd gamma min fr 
corollary shows limited reasonable model computation evaluation non frequent candidates inevitable 
corollary set binary database frequency threshold min fr finding collection min fr queries form frequent requires sets negative border bd gamma min fr evaluated 
proof claim follows directly corollary 
algorithm evaluates theory min fr border 
discovery association rules general necessary exact frequencies needed rule generation phase 
algorithm optimal simplifying restriction way controlling algorithm information set frequent 
corollary gives result finding functional dependencies specific setting easy find 
simplicity result case finding keys relation 
define keys 
definition relation relation schema subset key functional dependency holds rows agree key minimal subset ae key 
set keys denoted keys 
recall theorem converse set inclusion suitable strength hierarchy left hand sides functional dependencies keys case superset key key collection keys consists supersets minimal keys 
set minimal keys positive border bd keys 
corollary relation relation schema finding minimal keys requires jmax evaluations predicate key max set maximal subsets contain key 
proof note keys power set predicate key 
set minimal keys complexity finding frequent patterns positive border bd keys 
recall positive border specifies theory keys 
corollary algorithm computing theory keys predicate key evaluate border bd keys 
note max subset border negative border bd gamma keys 
max evaluated 
example relation fa dg suppose somebody tells fa bg fa cg minimal keys keys fx fa bg fa cg xg verify check border bd keys 
positive border consists minimal keys bd keys ffa bg fa cgg negative border consists weakest patterns frequent 
means bd gamma keys proper supersets keys key 
bd gamma keys ffa dg fb dgg inspect sets bd keys ffa bg fa cg fa dg fb dgg determine fa bg fa cg supersets really keys advantage corollary border bd small large drawback difficult determine border 
return issue section show connection problem finding border hypergraph transversal problem 
complexity computing selection criteria analyzed complexity discovery task terms number evaluations selection criterion consider shortly complexity evaluating case frequent sets linear pass database sufficient finding set frequent 
linear pass suffices determining exact database rule holds 
integrity constraints considered inclusion dependencies functional dependencies situation different 
verify inclusion dependency holds usually sorts relations corresponding relation schemas complexity worst case order log relations size sorting relation hashing required comparison model computation verifying functional dependency holds 
computing border essential difference finding frequent sets finding integrity constraints difference linear log time complexities 
searching frequent sets unrelated candidate sets evaluated simultaneously pass database 
verify truth set inclusion functional dependencies requires general passes database dependencies 
hand related dependencies evaluated efficiently time 
instance algorithms discovering functional dependencies evaluate full paths weakest strongest patterns 
record place path crosses border database passes crossings uniquely define border 
note path related functional dependencies contain pattern positive negative border 
number passes 
computing border return verification problem set verify 
corollary border bd inspected 
compute bd looking data simply find strongest patterns negative border bd gamma defined determined looking data finding weakest patterns difficult 
show minimal transversals hypergraphs determine negative border 
definition set 
collection subsets simple hypergraph element empty imply elements called edges hypergraph elements vertices hypergraph 
definition simple hypergraph set transversal subset intersecting edges transversal minimal transversal transversal ae transversal 
denote collection minimal transversals tr 
purposes hypergraphs transversals apply directly pattern class frequent sets 
items vertices complements sets positive border edges simple hypergraph set positive border set complexity finding frequent patterns edge consider set edge frequent 
hand edge intersection empty frequent 
frequent transversal minimal transversals minimal non frequent sets negative border 
general hypergraphs transversals determine negative border need represent patterns sets 
frequent sets representation give requirements general case 
definition set patterns strength hierarchy set 
function fx rg set representation bijective inverse computable 
notational convenience collection sets write ff sg example consider functional dependencies fixed right hand side recall theorem suitable strength hierarchy converse set inclusion true true supersets 
functional dependencies fixed right hand side set representation complement representation bijective representation inverse computable 
described frequent sets minimal transversals suitably constructed hypergraph constitute negative border 
definition sets patterns set representation denote simple hypergraph contains edges complements sets bd fr bd hypergraph corresponding set representation tr set representation negative border 
inverse function gamma maps set representations negative border patterns negative border 
set gamma tr negative border 
show formally 
computing border theorem sets patterns set representation gamma tr bd gamma proof prove claim steps 
show transversal gamma transversal bd bd gamma bd gamma show tr bd gamma theorem immediately follows 
tr fx minimal transversal fx minimal set gamma sg fx gamma gamma ae xg ff oe bd gamma example recall example 
example deals keys relation set bd keys ffa bg fa cgg minimal keys task verify really positive border 
need determine negative border bd gamma keys compute hypergraph formulation 
functional dependencies set representation key complement edges hypergraph keys complements complements minimal keys keys fr bd keys bd keys minimal sets fag fb cg intersect minimal keys fa bg fa cg tr keys ffag fb cgg minimal transversals set representation negative border gamma tr keys ffb dg fa dgg bd gamma keys complexity finding frequent patterns showed section simplifying restrictions negative border evaluated discovering frequent patterns 
section showed patterns representable sets notion negative border corresponds minimal transversals suitably defined hypergraph 
advantage wealth material transversals see ber design algorithms complexity analysis specific knowledge discovery problems 
complexity computing minimal transversals hypergraph long open known transversals computed time logn sum sizes edges hypergraph minimal transversals fk 
related concepts ideas previous chapter known different contexts 
contributions chapters providing unified viewpoint knowledge discovery tasks generic algorithm tasks analysis problems 
instance algorithm breadth search strategy uses strength hierarchy safely pruning branches search tree known search methods 
idea checking weaker patterns generating candidates missed original algorithm discovering frequent sets ais inference inclusion dependencies 
area machine learning version spaces mitchell mit systematic strength hierarchies concepts similar border 
mitchell learning task different conceptually mitchell set specific consistent patterns positive border 
generic viewpoint knowledge discovery algorithms similar expressed sie 
knowledge discovery settings seen discovery frequent patterns 
briefly contrast important systems claudien 
klo system discovering patterns describing outstanding subgroups database 
employs strength hierarchies organizes patterns hierarchies lets user specify strength hierarchies respect domain user interests 
algorithm repeatedly evaluates patterns paths weakest strongest patterns border located 
strength hierarchies prune evaluation patterns truth selection criterion known 
related claudien db discovers minimally complete order clausal theories databases terms minimally complete theory roughly corresponds positive border 
claudien discovers positive border finding patterns frequent strategy described example functional dependencies 
due large number patterns particular number patterns individual levels implementation claudien uses depth search order save space 
claudien take full advantage strength hierarchy may generate test candidate clauses hold weaker patterns 
general depth search strategy may useful collections frequent patterns level large computing selection criterion database cheap 
pratt system discovery patterns protein sequences example application 
total size analyzed sequences large pratt store data main memory index structures significantly larger original data 
evaluating selection criterion fast possibly faster evaluating potential candidate valid candidate 
problem complexity settings received attention 
lower bounds problem finding frequent sets ams mtv 
thorough analysis problem discovering functional dependencies 
various algorithms finding functional dependencies see bel pk 
relevance transversals computing theory model known context finding functional dependencies specific problems 
complexity finding frequent patterns chapter sampling large databases frequent sets data collected may proven statistical methods 
william holland law size data collection essential role data mining 
large data sets necessary reliable results unfortunately efficiency mining algorithms depends significantly database 
time complexity frequent set discovery algorithm linear respect number rows database 
algorithm requires multiple passes database subsequently database size influential factor execution time large databases 
chapter algorithms passes database 
idea pick random sample input database determine sets possibly frequent database verify results rest database 
algorithms produce correct set association rules full pass database 
rare cases sampling method produce frequent sets missing sets second pass 
concept negative border turns useful task 
describe sampling approach discovering association rules section 
section analyze goodness sampling method relation sample size accuracy results 
section give variations algorithms experimental results 
results show methods reduce disk activity considerably making approach attractive especially large databases 
chapter toi 
sampling large databases frequent sets sampling discovery frequent sets obvious way reducing database activity knowledge discovery random sample database find approximate regularities 
words trade accuracy efficiency 
useful samples small handled totally main memory give reasonably accurate results 
approximate results sample set focus complete discovery phase 
important know frequencies confidences association rules exactly 
business applications example large volumes supermarket sales data small differences significant 
relying results sampling takes risk losing valid association rules altogether frequency sample threshold 
random sample get approximate results fairly straightforward 
give bounds sample sizes desired accuracy results 
show exact frequencies efficiently analyzing random sample database follows 
random sample locate superset collection frequent sets 
superset determined efficiently applying algorithm sample main memory lowered frequency threshold 
collection candidates compute exact frequencies sets rest database 
approach successful requires full pass database passes worst case 
algorithm presents principle search frequent sets sample lower frequency threshold frequent sets missed 
algorithm input binary database set frequency threshold min fr sample size size lowered frequency threshold low fr min fr 
output collection min fr frequent sets frequencies subset failure report 
method 
compute random sample size size 
find frequent sets sample 
compute low fr main memory algorithm 
database pass 
compute fx bd gamma fr min frg algorithm 
output 
output fr 
bd gamma report possibly failure sampling discovery frequent sets concept negative border useful 
noted previous chapter border inspected discovering frequent sets 
sufficient locate superset min fr sample evaluate collection min fr bd gamma min fr needs checked 
obviously bd gamma superset collection superset min fr check union 
happens find necessary sets evaluated 
definition failure sampling frequent sets pass frequent set min fr bd gamma 
frequent set min fr bd gamma 
misses sampling successful 
misses problem evaluated database missed algorithm 
misses indicate potential failure 
superset frequent bd gamma 
simple way recognize potential failure check misses 
theorem algorithm works correctly 
proof clearly lines collection frequent sets computed output 
need show failure report frequent sets frequent sets failure report turn 
failure report bd gamma disjoint bd gamma bd gamma 
negative border bd gamma evaluated frequent sets 
frequent sets frequent set bd gamma exists set bd gamma frequent 
set bd gamma failure reported 
example assume binary database rows items want find frequent sets threshold 
algorithm randomly picks small fraction say rows keeps sample main memory 
algorithm database activity discover efficiently sets frequent sample 
probably collection frequent sets sample includes sets really frequent frequency threshold sampling large databases frequent sets lowered say 
algorithm determines collection sampled rows 
maximal sets positive border bd fa dg fb dg fa cg fa fg threshold lowered superset collection frequent sets 
pass rest database frequency sets bd gamma evaluated 
addition sets frequent sample evaluate candidates frequent negative border feg fb fg fc dg fd fg fa dg goal discover collection 
sets fa bg fa fg subsets frequent sets 
frequent sets evaluated exact frequencies known full database pass 
know frequent sets sets fdg feg fb cg fb fg sets negative border evaluated non frequent 
assume slightly different situation set fb fg turns frequent fb fg set fa fg frequent subsets 
case algorithm reports possibly failure 
problem formulation database frequency threshold min fr random sample determine collection sets contains high probability collection frequent sets min fr 
efficiency reasons secondary goal contain unnecessarily sets 
fraction cases possible failure reported frequent sets making second pass database 
algorithm extend algorithm second pass case 
algorithm simply computes collection sets possibly frequent 
parameter collection frequent sets algorithm gamma collection non frequent candidates algorithm 
collection bd gamma located similar way candidates generated 
analysis sampling algorithm input binary database set frequency threshold min fr subset min fr subset gamma bd gamma min fr 
output collection min fr frequent sets frequencies 
method 
repeat compute bd gamma gamma grow 
compute fx fr min frg 
output fr theorem algorithm works correctly 
proof sets computed output lines clearly frequent 
see frequent sets output consider frequent set assume contrary line 
smallest subset subsets negative border bd gamma 
possible reason excluded gamma contradiction frequent 
frequent sets output 
number candidates second pass principle large fit main memory handled database pass 
happen sample bad gives inaccurate results 
analysis sampling analyze relation sample size accuracy results 
consider accurate frequencies computed random sample 
noted samples reasonable size provide approximations frequencies sets ams mtv 
related sample approximately verifying truth arbitrary sentences relational tuple calculus considered km 
definition item set random sample binary database error difference frequencies gamma fr fr frequency database drawn 
analyze error consider sampling replacement 
reason want avoid making assumptions database size large 
sampling replacement size database sampling large databases frequent sets effect analysis results apply principle infinitely large databases 
note large databases practically difference sampling replacement 
analyze random variable jm number rows sample contain random variable binomial distribution jsj fr probability jm denoted pr jm jsj fr gamma fr jsj gammac consider necessary size sample requirements size error 
theorem gives lower bound size sample error bound maximum probability ffi error exceeds bound 
theorem item set random sample size jsj ln ffi probability ffi 
proof chernoff bounds give result pr jx gamma gamma random variable binomial distribution 
probability hand pr pr gamma fr delta jsj jsj gamma jsj jsj ffi table gives values sufficient sample size jsj ffi 
tolerable error samples reasonable size suffice 
instance chance error acceptable sample size sufficient 
applications parameter values perfectly reasonable 
cases approximate rules produced sample constant time independent size tighter error requirements sample sizes quite large 
result set corollary gives result stringent case collection sets probability gamma delta set error 
analysis sampling ffi sample size table sufficient sample sizes ffi corollary collection sets random sample size jsj ln jsj delta probability set delta 
proof theorem probability set delta jsj jsj sets probability question delta 
chernoff bound tight practice exact probability binomial distribution normal approximation useful 
consider proposed approach finding frequent sets exactly 
idea locate superset collection frequent sets discovering frequent sets sample lower threshold 
consider simple setting take sample small possible contain frequent sets 
sample size 
theorem set fr min fr random sample size jsj min fr ln ffi probability occur ffi proof apply inequality real number probability frequent set occur row gamma min fr 
probability occur row gamma min fr jsj bounded inequality min fr ffi sampling large databases frequent sets sample size theorem small unfortunately approach useful sample include lot garbage sets frequent border 
instance single row containing items subsets checked database 
obviously useful sample larger 
best results achieved sample large conveniently handled main memory 
move problem 
assume sample collection low fr sets 
say probability failure 
simple approximation 
assuming sets bd gamma independent upper bound probability failure probability set bd gamma turns frequent approximation tends give large probabilities 
set bd gamma frequent necessarily indicate failure 
general failure addition add sets negative border bd gamma additions needed new candidates 
note assumption sets bd gamma independent unrealistic 
interesting aspect approximation computed fly processing sample 
approximated probability failure needs set advance frequency threshold low fr adjusted run time fit desired probability variation theorem gives result set lowered frequency threshold misses avoided high probability 
theorem frequent set random sample probability parameter ffi probability ffi low fr min fr gamma jsj ln ffi proof chernoff bounds time sided error pr fr low fr gamma jsj ln ffi jsj jsj ffi consider number sets checked second pass algorithm case potential failure 
collection principle grow lot 
independent worst case generate experiments data set name jrj jrj size mb table synthetic data set characteristics row size average size sets positive border average 
new candidates frequent sets 
note probability set ffi probability independent misses ffi experiments describe experiments conducted assess practical feasibility sampling method finding frequent sets 
section variants method give experimental results 
test organization synthetic data sets tests 
databases model supermarket basket data benchmarks association rule algorithms ams son 
central properties data sets 
jrj items average number items row 
number jrj rows approximately 
average size maximal frequent sets sets positive border 
table summarizes parameters data sets see details data generation 
assume real data collections association rules discovered larger test data sets 
experiments fair sampling replacement 
means real data collections arbitrary large data sets data sets represent distributional properties 
considered sample sizes 
samples sizes large give approximations small handled main memory 
approach probabilistic repeated experiment times parameter combination 
altogether trials run 
sampling large databases frequent sets frequency sample size threshold table lowered frequency thresholds ffi 
number misses database activity experimented algorithm mentioned sample sizes 
selected lowered threshold probability missing frequent set ffi set fr min fr pr fr low fr lowered threshold depends frequency threshold sample size 
lowered threshold values table computations lowered thresholds exact probabilities obtained binomial distribution chernoff bounds 
shows number database passes different types algorithms algorithm partition sampling algorithm 
partition algorithm son discussed shortly chapter 
idea partitioning database parts small handled main memory 
algorithm passes database pass uses variant algorithm find frequent sets partition second pass checks database sets frequent partition 
data points results shown algorithm average value trials 
explaining results easy 
algorithm passes database size largest frequent set 
partition algorithm passes database frequent sets 
algorithm fraction trials misses expected larger ffi depending frequent sets frequency relatively close threshold misses sample 
algorithm succeeded finding frequent sets pass cases 
number database passes partition algorithm practically twice algorithm number passes experiments number passes frequency threshold algorithm partition algorithm number passes frequency threshold 
frequency threshold number database passes frequent set algorithms 
algorithm times algorithm 
table shows number trials misses data set sample size frequency threshold 
set trials zero trials misses 
fraction trials misses 
repeated experiment ffi probability missing frequent set 
experiment gave misses fraction trials 
cases fraction trials misses larger ffi magnitude 
actual amount reduction database activity depends database storage structures 
instance database rows disk block contains average rows sample size sampling phase read database 
alternative sampling large databases frequent sets frequency sample size threshold frequency sample size threshold frequency sample size threshold table number trials misses 
randomly drawing row separation course draw blocks rows sample 
depending randomly rows assigned blocks method give bad results 
design analysis sampling methods see 
related problem sampling query estimation considered hs 
reduction database activity achieved cost considering item sets algorithm generate check 
table shows average number sets considered data set different sample sizes number candidate sets algorithm 
largest absolute overhead occurs low thresholds number item sets considered grown worst case 
growth significant total execution time item sets handled entirely main memory 
relative experiments frequency sample size threshold algorithm table number item sets considered data set 
head larger higher thresholds absolute overheads small effect negligible 
table indicates larger samples cause overhead equally results sample sizes difference overhead significant 
obtain better picture relation ffi experimental number trials misses conducted test 
took samples frequency threshold sample size determined lowered frequency threshold misses trials 
presents results points lines showing lowered thresholds ffi thresholds corresponding probabilities frequent set 
frequency thresholds give misses fraction cases approximate surprisingly closely thresholds ffi 
experiments larger scale sample sizes give comparable results 
explanations similarity values 
reason necessarily potential misses frequent sets frequency relatively close threshold 
reason contributes similarity sets independent 
case possible failure algorithm generates iteratively new candidates pass database 
experiments number frequent sets missed missed ffi ffi 
number candidates checked second pass small compared total number item sets checked 
approximate gamma delta success probability setting lowered threshold algorithm trivial select probability failure low unnecessarily sets check 
automatic way setting parameter desirable 
consider sampling large databases frequent sets frequency threshold sample size theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta frequency thresholds giving misses cases points lowered thresholds ffi lines 
instance interactive mining tool 
useful know advance long operation approximately take case mining association rules database passes 
algorithms find frequent sets approximately fraction gamma delta cases delta user 
assumption sets negative border independent algorithms guaranteed find correct sets fraction gamma delta cases 
algorithm uses simple greedy principle find optimal lowered threshold independence assumption 
algorithm optimal central phase identical algorithm easy incorporate existing implementations 
experimental results algorithm 
greedy algorithm starts empty set decreases probability failure adding probable misses approximated probability potential failure delta 
experiments algorithm input binary database frequency threshold min fr sample size size probability delta 
output collection min fr frequent sets frequencies fraction gamma delta cases assuming frequencies sets independent subset min fr failure report rest cases 
method 
compute random sample size size 

find frequent sets sample 
estimated probability larger delta 
select bd gamma highest probability 
fxg 
database pass 
compute fx bd gamma fr min frg 
output fr 
bd gamma report possibly failure theorem algorithm works correctly 
proof see proof theorem correctness output failure reports 
assumption independence sets follows particular sets bd gamma independent 
probabilities easily computed lines algorithm fails fraction delta cases 
note single indicate failure probability upper bound probability failure 
assumption independence sets algorithm unrealistic 
reason delta practice approximates upper bound fraction failures 
algorithm simple variation algorithm 
utilizes failure probability approximation described section monitors approximated probability keeps probability small lowering frequency threshold low fr necessary rest algorithm 
algorithm discovery frequent sets sample dynamic adjustment lowered threshold modification concerns phase candidates added collection frequent sets thrown away 
time candidate frequent sample compute probability frequent 
total probability increases see lower frequency threshold low fr frequency sample rest algorithm 
eventually considered frequent sample candidate sets increase probability sampling large databases frequent sets algorithm input binary database set sample size size frequency threshold min fr probability delta fl 
output collection min fr frequent sets frequencies fraction gamma delta cases assuming frequencies sets independent subset min fr failure report rest cases 
method 
compute random sample size size 

low fr min fr 
find frequent sets sample 
ffag rg 




fr low fr 
frequent 
delta gamma fl low fr fr 
gamma gamma gamma 
fr low fr fxg 

compute gamma 
database pass 
compute fx fr min frg 
output fr 
report possibly failure heuristic decide possibility increases 
parameter fl frequency threshold lowered probability larger fraction fl remaining error reserve delta gamma complex heuristics changing frequency threshold developed account number candidates level number frequent sets level growing shrinking 
observations hint lowered threshold set start roughly correspond desired probability delta lowered threshold set ffi 
theorem algorithm works correctly 
proof see proof theorem correctness output failure reports 
consider invariant variable probability sets negative border assumption sets negative border independent delta 
invariant holds trivially initialized zero sets considered 
show invariant experiments frequency sample size threshold frequency sample size threshold frequency sample size threshold table number trials misses delta 
continues hold algorithm 
line updated set negative border sample potential correctly correspond total probability non negative real numbers delta gamma delta gamma fl delta gamma new value gamma gamma gamma gamma gamma gamma delta gamma delta gamma delta bounded delta invariant 
invariant continues hold probability program exits delta 
remember single necessarily indicate failure upper bound probability failure 
sets negative border necessarily independent upper bound approximation 
tested algorithm maximum probability delta dynamic adjustment parameter fl frequency thresholds data set 
number trials misses shown table 
number successfully remained delta set experiments 
table shows number cases misses half 
reason small fl algorithm tends conservative keeps lot space probability reserve 
sampling large databases frequent sets useful candidates 
negligible tradeoff algorithm may consider unnecessarily sets frequent sample 
summarize shortly experiments show proposed approach works practice frequent sets pass database 
efficiency mining association rules large databases reduction disk significant 
chapter discovery boolean rules frequent sets people write pen 
rest pen 
class association rules simple positive connections sets items expressed 
chapter consider powerful rule formalism class boolean rules 
informally boolean rules association rules negation disjunction define formally section 
note task discovering boolean rules hold database useful feasible 
list useful types boolean rules section show confidences computed frequencies sets 
show principle inclusion exclusion compute frequency boolean formula frequencies sets 
turns approximations frequencies confidences boolean rules computed frequent sets 
experimental results accuracy estimated frequencies section 
parts chapter published mt 
boolean formulas rules generalize notions set association rule boolean formula boolean rule follows 
definition set binary database literal expression literal said positive discovery boolean rules frequent sets literal negative 
define recursively boolean formulas truth 
literal boolean formula 
positive literal true row negative literal true row literal true row 
literal set rows true denoted ft true tg boolean formulas 
ffl boolean formula true rows set notational convention conjunction written set ffl boolean formula true rows set ffl boolean formula true rows set notational convenience consider empty set boolean formula empty conjunction 
true rows definition binary database set boolean rule expression form boolean formulas 
frequency boolean formula fr jm jrj frequency boolean rule denoted fr fr 
confidence boolean rule conf jm jm item sets considered definitions writing conventions conjunctions positive literals 
interpretation consistent earlier definitions concerning item sets 
set notation chapter emphasize item sets subclass boolean formulas association rules subclass boolean rules 
boolean formulas rules consider complexity discovering boolean rules hold binary database 
simplicity look association rules negation 
rules principle discovered association rule algorithms simple trick 
binary database set boolean rules consisting literals conjunctive connective association rule discovery algorithms follows 
introduce jrj new complement items item discover standard association rules extended set items extended binary database 
complement items introduced way size search space frequent sets grows jrj jrj addition growth search space direct application definition candidate collection gives candidates form fi impossible candidates formed size 
candidate generation easily modified exclude pairs consideration 
discovery rules negation straightforward 
efficient sense frequent formulas formulas negative border evaluated 
problem number frequent formulas size output explodes 
rough analysis demonstrates growth size output negation allowed association rules 
example assume positive literals frequency consider boolean formula negative literals 
frequency gamma kb formula frequent gamma min fr instance jrj items maximum item frequency frequency threshold min fr meaning conjunctions negative literals size frequent 
frequent formulas 
example consider class boolean formulas form turns reasonable assumptions formulas class frequent 
assume frequency threshold min fr fr empty set 
consider subclass boolean formulas form fr frequent 
jrj gamma frequent formulas 
task discovering arbitrary boolean rules useful number frequent boolean rules enormous 
arbitrary rule forms valuable applications 
useful approach user queries system specific rules classes rules 
discovery boolean rules frequent sets computation frequencies frequencies sets compute frequency boolean formula confidence boolean rule 
particular frequencies computed principle inclusion exclusion disjunctive normal forms formulas 
show possible 
definition boolean formula disjunctive normal form form turn form positive negative literal 
proposition boolean formula formula disjunctive normal form true true 
proof denote fa jrj set positive literals 
trivial disjunctive normal form boolean formula obtained terms disjunction conjunctions jrj true frequency formula disjunctive normal form computed principle inclusion exclusion 
definition set rows true union sets inclusion exclusion standard principle computing size union sizes different intersections 
proposition frequency boolean formula disjunctive normal form fr gamma kg gamma jsj fr sum frequencies conjunctions literals 
remember empty boolean formula true rows fr 
proof proposition straightforward application principle inclusion exclusion see ptw 
example consider formula disjunctive normal form 
principle inclusion exclusion compute frequency formula follows fr fr fa bg fr fcg fr fdg fa cg gamma fr fa dg gamma fr fc dg fr fa dg terms sum proposition frequencies conjunctions positive negative literals 
principle inclusion exclusion computation frequencies applied express frequency sum frequencies conjunctions positive literals frequencies item sets 
proposition frequency conjunction fa literals fr fa kg gamma jsj fr fa fb sg proof apply principle inclusion exclusion 
note conjunction fa logically equivalent 
frequency negated disjunction minus frequency disjunction computed proposition 
additionally restrict disjunction fa true 
example consider term sum example frequency fa dg 
proposition fr fa dg fr fa cg fa cg gamma fr fa dg fr fa dg apply proposition terms example remove terms sum zero fr gamma fr fdg fr fa dg fr fc dg fa dg gamma fr fa dg fr fa dg problems approach computing frequency boolean formula frequencies sets 
size disjunctive normal form exponential respect size original formula 
practical purposes number terms problem interesting cases terms needed shown examples 
second difficult problem computing frequencies way frequencies practice known frequency threshold min fr 
return problem briefly 
give examples useful subclasses boolean rules 
spirit definition truth boolean formulas defined terms truth positive literals show confidences computed frequencies item sets 
discovery boolean rules frequent sets example association rule form confidence defined fr fr example rule disjunctive right hand side form expresses row contains contains confidence rule fr fr gamma fr fr example similarly rules disjunctive left hand sides 
rule form meaning row contains contains confidence rule fr fr gamma fr fr fr gamma fr example rules negation left hand side 
rule means row contains contain contains confidence rule fr gamma fr fr gamma fr example rules negation right hand side form mean row contains contains contain confidence rule fr gamma fr fr frequency boolean formula approximated way express frequency formula sum frequencies sets computation frequencies principle inclusion exclusion simply ignore frequencies lower frequency threshold min fr 
consider error results ignoring terms sum 
define shorthand notation sum obtained principle inclusion exclusion 
definition inclusion exclusion frequency set items gamma gamma jy fr gamma jy fr frequencies interesting cases boolean formulas computed directly inclusion exclusion frequencies 
note particular basic cases hold sets fa items 
principle inclusion exclusion gives directly fr fr fr gamma 
additionally frequency fr directly compute fr fr gamma fr 
consider approximating inclusion exclusion frequency 
frequent sets know terms sum 
know terms greater equal frequency threshold 
definition set items collection frequent sets frequencies truncated inclusion exclusion frequency gamma jy fr absolute error err truncation err jie gamma open problem look bounds err 
idea negative border bd gamma evaluated computation 
subsets negative border specify sets ignored frequencies border sets set constraints ignored frequencies 
open problem collection bd gamma sets negative border frequencies sets item set denote bds bd gamma fr discovery boolean rules frequent sets smallest positive constant err subsets err delta bds 
believe bound computed sum frequencies ignored sets negative border 
find value open problem combinatorial aspects ignored sets determine value case individually 
obvious constant value correct simple cases ignored sets size jy jx gamma 
counter example larger sets shows correct general 
hand easy see bd gamma gj sufficient 
approximation inclusion exclusion sum considered kls ln shown knowing terms gamma jy fr inclusion exclusion formula jy jx sufficient getting approximations sum 
results directly applicable problem frequent sets necessarily provide required subset terms inclusion exclusion formula 
interestingly approximation formed simply computing truncated sum uses linear combination terms truncated sum 
experiments experimented course enrollment data described section 
discovering frequent sets negative border frequency threshold instance results frequency disjunction items 
ffl set structures database systems ig terms inclusion exclusion frequency known fr data structures database systems err 
ffl set unix related courses terms greater threshold negative border 
frequency estimated frequency error err 
sum ignored frequencies border bds 
ffl set different intermediate courses theory computation artificial intelligence computer graphics terms truncated inclusion exclusion frequency experiments size average error maximum error relative error sets err delta bds err delta bds err delta bds table errors different sizes random sets frequency threshold 
negative border 
err bds 
ffl set consisting programming projects err bds 
case terms exceed threshold negative border 
frequency threshold high compared instance supermarket domain reasonable frequency thresholds assumed fractions cent 
lowering threshold get exact inclusion exclusion frequency set computation artificial intelligence computer accurate estimate set unix related courses 
evaluate accuracy truncated inclusion exclusion sum open problem generated random sets observed error particular relation computed estimation 
frequency thresholds see strong effect frequency threshold error 
computed frequent sets negative border test cases 
generated random sets item frequent 
decision motivated assumption interesting boolean formulas consist items frequent fact non frequent items contribute terms truncated inclusion exclusion frequency 
test case sizes generated random sets 
computed errors sums bds results errors frequency threshold table 
see error average discovery boolean rules frequent sets size average error maximum error relative error sets err delta bds err delta bds err delta bds table errors different sizes random sets frequency threshold 
sizes 
sums bds reasonably close err sizes 
maximum errors truncated sums range bds reasonable sizes 
rows right see relative error ratio error estimated inclusion exclusion frequency average sizes 
comparison results min fr table shows frequency threshold smaller errors smaller especially small sets 
difference best visible average relative errors experiments 
summary frequencies small boolean formulas computed accurately frequent sets 
experiments average error order magnitude frequency threshold relative error notably better lower threshold 
chapter discovery episodes sequences times tell repeat 
desperate phd advisor application domains collect sequences events describing behavior users systems 
chapter consider problem recognizing frequent episodes sequences events 
episode defined partially ordered collection events occur time interval length 
frequent episodes known produce rules describing predicting behavior sequence 
describe episodes informally section give exact definitions section outline algorithm discovery frequent episodes 
sections give algorithms candidate generation database pass respectively important types episodes 
section shortly discuss types episodes 
experimental results section 
suggest extensions review related section 
chapter mtv formulations results discovery episodes mtv 
event sequences episodes data mining machine learning techniques adapted analysis unordered collections data 
important application areas data analyzed inherent sequential structure 
instance telecommunication network monitoring empirical user interface studies easy log lot information discovery episodes sequences time edf bad efc sequence events 
behavior actions user system 
abstractly log viewed sequence events event associated time occurrence 
example event sequence represented 
event types different types alarms telecommunication network different types user actions marked time line 
basic problem analyzing sequence find frequent episodes collections events occurring frequently 
example sequence episode followed occurs times sequence viewed narrow window 
episodes general partially ordered sets events 
sequence instance observation occur order occurs soon 
episodes described directed acyclic graphs obvious way 
consider instance episodes ff fi fl 
episode ff serial episode occurs sequence events types occur order sequence 
sequence events occurring 
episode fi parallel episode constraints relative order 
thesis consider discovery serial parallel episodes 
definitions give apply general 
episode fl example non serial non parallel episode occurs sequence occurrences precede occurrence constraints relative order 
discovering episodes telecommunication network alarm log goal find unknown relationships alarms 
relationships line analysis incoming alarm stream better explain problems cause alarms suppress redundant alarms predict severe faults 
alarm sequence merged sources useful episodes insensitive intervening events 
analysis sequences interested finding frequent episodes class episodes 
class serial episodes parallel episodes episodes partial order matches part network topology consider class partial definitions ff fi fl episodes 
orders 
considered interesting events episode occur close time 
user defines close close giving width time window episode occur 
user specifies windows episode occur considered frequent 
frequent episodes known obtain rules prediction 
example know episode fi occurs windows fl occurs windows estimate seeing window chance follows window 
compute rules confidences frequencies episodes 
summary consider problem 
class episodes input sequence events window width frequency threshold find episodes frequent event sequence 
algorithm give solving task instance generic algorithm discovering frequent patterns 
candidate generation similar generating candidates frequent sets 
database pass recognize episodes efficiently sliding window input sequence 
adjacent windows lot overlap similar 
take advantage similarity recognizing episodes window incremental updates data structures determine episodes occur window 
definitions return basic concepts define formally 
start giving definitions event sequences windows 
definition set event types event pair event type integer occurrence time event 
discovery episodes sequences edf bad efc example event sequence windows width 
event sequence triple integers called starting time closing time ordered sequence events gamma 
example presents graphically event sequence observations event sequence time just time 
event occurred time interval event type time occurrence recorded 
think looking event sequence narrow window giving view events relatively small time period 
define window slice event sequence seen time 
discuss case considers event sequence sequence partially overlapping windows 
definition window event sequence event sequence tw consists pairs tw time span gamma tw called width window denoted width 
event sequence integer win denote win set windows width win 
definition windows sequence extend outside sequence window contains time point sequence window contains time point 
definition event close sequence observed equally windows event middle sequence 
event sequence window width win number windows win gamma win gamma 
definitions ff episode 
example shows windows width sequence previous example 
window starting time shown solid line immediately window starting time depicted dashed line 
window starting time note event occurred closing time window 
window starting similar difference event missing new event 
set partially overlapping windows width constitutes window hi 
event occurs windows width event 
windows totally sequence considered event occur window 
move define episodes formally 
define episode relation strength hierarchy episodes 
definition episode ff triple set nodes partial order mapping associating node event type 
interpretation episode events occur order described size ff denoted jffj jv episode ff parallel partial order trivial 
episode ff serial relation total order 
episode ff injective mapping injection event type occurs twice episode 
example consider episode ff 
set contains nodes call mapping labels nodes discovery episodes sequences fi fl episode 
event types seen event type supposed occur event type precedes episode ff injective contain duplicate event types window ff occurs may multiple events types definition episode fi ff denoted fi ff exists injective mapping 
episode ff fi fi ff 
write fi oe ff fi ff ff fi 
example presents episodes fi fl 
see fi fl fi subgraph fl 
terms definition mapping connects nodes labeled nodes labeled nodes fi disjoint corresponding nodes fl 
nodes episode fi ordered corresponding nodes fl need ordered 
consider means episode occurs sequence 
nodes episode need corresponding events sequence event types partial order episode respected 
formalize 
define frequency episode fraction windows episode occurs 
definition episode ff occurs event sequence exists injective mapping ng nodes events definitions example window contains events order 
episodes fi fl occur window 
definition event sequence window width win frequency episode ff fr ff win win ff occurs jw win fraction windows ff occurs 
frequency threshold min fr ff frequent fr ff win min fr 
collection episodes frequent respect win min fr denoted win min fr 
collection frequent episodes size denoted win min fr 
give exact formulation discovery task hand event sequence set episodes window width win frequency threshold min fr find win min fr algorithm instantiation generic algorithm computing collection win min fr frequent episodes 
algorithm familiar structure alternation candidate generation database pass phases implementations steps discussed detail sections 
algorithm input set event types event sequence set episodes window width win frequency threshold min fr 
output collection win min fr frequent episodes 
method 
compute fff jffj 


database pass algorithms 
compute win min fr fff fr ff win min frg 

candidate generation algorithm 
compute fff jffj fi jfij win min fr fi fi oe ffg 
output win min fr level pattern definition algorithm uses sizes episodes assign episodes iterations 
classes serial parallel episodes size episode level episode class 
theorem implies algorithm works correctly provided underlying subroutines correctly 
discovery episodes sequences problem discovering frequent injective parallel episodes identical searching frequent sets 
injective parallel episodes essentially subsets collection windows sequence considered binary database set generation candidate episodes detail candidate generation method generalization candidate generation frequent sets 
method adapted deal parallel episodes multisets items serial episodes ordered multisets injective parallel serial episodes sets ordered sets 
algorithm method computation candidates parallel episodes 
algorithm episode ff represented lexicographically sorted array event types 
array denoted name episode items array referred square bracket notation 
example parallel episode ff events types represented array ff ff ff ff ff collections episodes represented lexicographically sorted arrays ith episode collection denoted 
algorithm input sorted array frequent parallel episodes size output sorted array candidate parallel episodes size 
method 


jf block start 
jf 
current block start 
block start block start 
gamma event types common 
build potential candidate ff combination 
ff 
ff 
build test subepisodes fi contain ff 
gamma 
gamma fi ff 
fi ff 
fi continue line 
subepisodes store ff candidate 

ff 
block start current block start 
output generation candidate episodes episodes episode collections sorted episodes share event types consecutive episode collection 
particular episodes size share gamma events shares events 
maximal sequence consecutive episodes size share gamma events called block 
potential candidates identified creating combinations episodes block 
efficient identification blocks store block start episode episode block 
theorem algorithm works correctly 
proof crucial claim algorithm pairs episodes generate candidates 
moment assume episode value block start episode block 
show assumption holds 
identify episode index collection 
outer loop line variable iterates episodes inner loop line variable iterates episodes block consider block episodes variables obviously iterate unordered pairs episodes block including case block gamma event types 
conceptually construct new potential candidate ff union episodes multisets build ff common gamma events lth event episode done line event number episode line 
events potential candidate lexicographically sorted 
iteration episodes proceeds lexicographical order sorted collection collection candidates constructed lexicographical order 
show collection potential candidates ff contains valid candidates fl size 
subepisodes fl frequent particular subepisodes ffi ffi size contain second events fl respectively 
ffi ffi gamma items common block 
time algorithm ffi ffi fl considered potential candidate algorithm 
need show false candidates output 
episode size subepisodes fi size sure obtain subepisodes leaving events ff time line 
note subepisodes discovery episodes sequences constructing ff need checked 
subepisodes size gamma ff correctly output candidate 
show correct value block start episode block 
structure built line episodes size common events block block start block property episodes block generated episode 
due simple fact events copied directly line 
save index candidate generated line saved value set block start correctly candidates block line 
algorithm easily modified generate candidate serial episodes 
events array representing episode order imposed total order instance serial episode fi events types order represented array fi fi fi fi fi change algorithm replace line 
theorem line 
block start block start block start algorithm works correctly serial episodes 
proof proof similar proof theorem iterate ordered pairs episodes block 
potential candidates ordered sequences event types sorted arrays candidate collection constructed lexicographical order 
arguments correctness candidate collection structure block start hold 
options algorithm 
desired episode class consists parallel serial injective episodes episode contain event type simply add line 
theorem line 
continue line recognizing episodes sequences inserted line algorithm works correctly injective parallel episodes injective serial episodes change theorem 
proof clearly effect inserted line candidates generated 
consider excluded candidate episodes 
note candidates ff contain event type twice excluded 
candidate excluded explicitly generated subepisodes ff excluded explicitly contains event type ff ff twice 
hand tested fi collection fl fi excluded explicitly 
ff contains twice event type fl jflj 
note episode ff occurrences event type generated 
event type occurs twice ff 
episode fl size fl fl fl ff ff candidate fl frequent 
fl excluded explicitly inserted line earlier iteration ff candidate 
time complexity algorithm polynomial size collection frequent episodes independent length event sequence 
theorem algorithm variations time complexity jf log jf 
proof initialization line takes time jf 
outer loop line iterated jf times inner loop line jf times 
loops potential candidate lines gamma lines built time gamma 
importantly gamma subsets need searched collection line 
sorted located binary search time log jf 
total time complexity jf jf jf gamma log jf jf log jf 
practical situations time complexity close jf log jf blocks typically small 
recognizing episodes sequences consider implementation database pass 
give algorithms recognize episodes sequences incremental fashion 
discovery episodes sequences adjacent windows win win sequences events similar 
take advantage similarity recognizing episodes incremental updates data structures achieve shift window obtain algorithms start considering empty window just input sequence considering empty window just sequence 
way incremental methods need special actions 
frequency episodes windows correctly input sequence course considered 
parallel episodes algorithm recognizes candidate parallel episodes event sequence 
algorithm input collection parallel episodes event sequence window width win frequency threshold min fr 
output episodes frequent respect win min fr 
method 
initialization 
ff 
ff 
count 
jffj contains 
ff 
ff 
number events type ff 
contains contains fffg 
ff event count 
ff freq count 
recognition 
start gamma win 
bring new events window 
events start win gamma 
count count 
ff contains count 
ff event count ff event count count 
ff event count jffj ff start 
drop old events window 
events start gamma 
ff contains count 
ff event count jffj 
ff freq count ff freq count gamma ff start 
ff event count ff event count gamma count 
count count gamma 
output 
episodes ff 
ff freq count gamma win gamma min fr output ff recognizing episodes sequences principles algorithm 
candidate parallel episode ff maintain counter ff event count indicates events ff window 
ff event count equal jffj indicating ff entirely included window save starting time window ff ff event count decreases indicating ff longer entirely window increase field ff freq count number windows ff remained entirely window 
ff freq count contains total number windows ff occurs 
access candidates efficiently indexed number events type contain episodes contain exactly events type list contains 
window shifted contents window change episodes affected updated 
instance event type window second comes episodes list contains updated information events type expecting 
theorem algorithm works correctly 
proof consider invariants 
event type occurs episode variable count correctly contains number events type current window 
episode ff counter ff event count equals jffj exactly ff current window 
invariant holds trivially empty window starting gamma win counters count initialized zero line 
assume counters correct window starting start gamma consider computation window starting start iteration loop starting line 
lines counters updated new event window similarly lines counters updated events longer window 
second invariant note set contains consists episodes contain exactly events type lists initialized empty line filled correctly event type episode line note set union operation 
consider counter ff event count episode ff 
counter initialized zero line 
event type denote number events type ff 
effect lines ff event count increased exactly time events type window 
ff event count jffj exactly events type ff window 
note ff freq count correct 
counter ini discovery episodes sequences zero line 
number consecutive windows containing ff invariant index window stored ff line 
window window containing ff counter ff freq count increased number consecutive windows containing ff line 
window considered empty window immediately sequence occurrences windows sequence correctly computed 
lines frequent episodes output 
serial episodes serial candidate episodes recognized event sequence state automata accept candidate episodes ignore input 
idea automaton serial episode ff instances automaton time active states reflect disjoint prefixes ff occurring window 
algorithm implements idea 
initialize new instance automaton serial episode ff time event ff comes window automaton removed event leaves window 
automaton ff reaches accepting state indicating ff entirely included window automata ff accepting state save starting time window ff automaton accepting state removed automata ff accepting state increase field ff freq count number windows ff remained entirely window 
useless multiple automata state transitions produce information 
suffices maintain reached common state removed 
jffj automata episode ff 
automaton need know removed 
represent automata ff array size jffj value ff initialized latest initialization time automaton reached ith state 
recall ff represented array containing events array label state transitions 
access traverse automata efficiently organized way 
event type automata accept linked list waits 
list contains entries form ff meaning episode ff waiting xth event 
event enters window shift list waits traversed 
automaton reaches common state automaton earlier entry array ff initialized simply overwritten 
recognizing episodes sequences algorithm input collection serial episodes event sequence window width win frequency threshold min fr 
output episodes frequent respect win min fr 
method 
initialization 
ff 
jffj 
ff initialized 
waits ff 
ff 
waits ff waits ff ff 
ff freq count 
gamma win gamma 
recognition 
start gamma win 
bring new events window 
start win gamma 
transitions 
events start win gamma 
ff waits 
jffj ff initialized ff start 

transitions transitions ff start win gamma 

transitions transitions ff ff initialized gamma 
ff initialized gamma ff initialized gamma ff gamma 
ff initialized gamma 
waits waits ff 
ff transitions 
ff initialized 
ff 
jffj waits ff waits ff ff 
drop old events window 
ff start gamma 
jffj ff freq count ff freq count gamma ff start 
waits ff waits ff ff 
ff initialized 
output 
episodes ff 
ff freq count gamma win gamma min fr output ff transitions shift window stored list transitions represented form ff meaning episode ff got xth event latest initialization time prefix length updates regarding old states automata done immediately updates new states done transitions identified order overwrite useful information 
easy removal automata go window automata initialized time stored list 
discovery episodes sequences theorem algorithm works correctly 
proof ff serial episode integer jffj event type consider window input sequence 
denote mpt ff maximal time window prefix length ff occurs subsequence starting time window ends 
consider invariants 

ff initialized prefix occur window jffj mpt ff mpt ff 
ff initialized mpt ff 

time window ff ff initialized 
list waits consists entries ff ff ff initialized gamma 
invariant holds trivially empty window data structures initialized zeros line 
assume data structures correct window starting start gamma consider computation window starting start show induction computations correct consider case 
new event comes window latest prefix length episodes start event type 
value ff initialized correctly set start win gamma episodes ff lines 
assume ff comes window ff initialized correct mpt ff clearly equals old value mpt ff gamma correct updates done lines ff initialized line ff initialized gamma 
note value ff initialized gamma set non zero mpt ff gamma mpt ff 
note prefix length window anymore ff initialized correctly set zero line 
second invariant holds trivially line 
assuming data structures correct window starting start gamma correct additions done line correct removals line 
removing lists start necessary 
third invariant holds algorithm waits lists set correctly line altered algorithm 
larger prefixes correct additions waits lists lines correct removals ff initialized gamma zero lines 
recognizing episodes sequences invariants index window correctly stored ff consecutive windows containing ff line ff freq count correctly increased consecutive windows containing ff line 
frequent episodes correctly output lines algorithm 
analysis time complexity simplicity suppose class event types fixed assume exactly event takes place time unit 
assume candidate episodes size length sequence 
theorem time complexity algorithm jcj proof initialization takes time jcj 
consider number operations innermost loops accesses ff event count lines 
recognition phase shifts window 
shift new event comes window old event leaves window 
episode ff ff event count accessed twice shift 
cost recognition phase jcj 
practice size episodes small respect size sequence time required initialization safely neglected 
injective episodes tighter result 
theorem time complexity recognizing injective parallel episodes algorithm excluding initialization win jcj proof consider win successive shifts time unit 
sequence shifts jcj candidate episodes ff undergo changes event type ff count increased decreased 
due fact event type come window count win time units 
reading input takes time compare trivial non incremental method sequence pre processed windows frequent sets searched 
time requirement recognizing jcj candidate sets windows plus time required read windows size win jcj delta win larger factor win 
theorem time complexity algorithm jcj discovery episodes sequences fl ffi ffi recursive composition complex episode 
proof initialization takes time jcj win 
recognition phase shifts shift event comes window event leaves window 
shift effort episode ff depends number automata accessed maximum automata episode 
worst case time complexity jcj win jcj jcj note win 
input sequence consists worst case events event type candidate serial episodes consist events particular type 
shift window results update automaton 
worst case complexity close complexity trivial non incremental method jcj delta win 
practical situations time requirement considerably smaller approach savings obtained case injective parallel episodes 
theorem time complexity recognizing injective serial episodes algorithm excluding initialization jcj proof shifts affect automata episode event comes window state transition automaton automaton removed initializing event goes window 
general partial orders far discussed serial parallel episodes 
discuss briefly partial orders episodes 
recognition arbitrary episode reduced recognition hierarchical combination serial parallel episodes 
example episode fl serial combination episodes ffi parallel episode consisting general partial orders recursive composition complex episode 
ffi episode consisting 
occurrence episode window tested hierarchical structure see episode fl occurs window checks method serial episodes ffi ffi occur order check occurrence ffi uses method parallel episodes verify occur 
complications take account 
necessary duplicate event node obtain decomposition serial parallel episodes 
consider instance episode left 
hierarchical composition consisting serial parallel episodes 
composite episode right node labeled duplicated 
duplication works injective episodes non injective episodes need complex methods 
important aspect composite events duration elementary events practical alternative handle episodes basically parallel episodes check correct partial ordering events window 
parallel episodes located efficiently checking correct partial ordering relatively fast 
interesting approach recognition episodes inverse structures 
frequent episode store identifiers windows episode occurs 
recognition phase candidate episode ff compute set windows ff occurs intersection sets windows subepisodes ff 
holds serial episodes additional information needed 
mt related algorithm database pass 
algorithm storing minimal occurrences episodes minimal occurrences subepisodes determine minimal occurrences candidate 
discovery episodes sequences injective window serial episodes parallel episodes width count time count time table results experiments fixed frequency threshold varying window width 
experiments experimental results obtained telecommunication network fault management databases 
database sequence alarms covering time period weeks 
time granularity second 
different types alarms diverse frequencies distributions 
average alarm minute 
alarms tend occur bursts extreme cases alarms second 
results experiments serial episodes injective parallel episodes opposite extreme cases complexity recognition phase 
performance overview tables give overview discovery frequent episodes 
table serial episodes injective parallel episodes discovered fixed frequency threshold varying window width table episodes discovered fixed window width seconds varying frequency threshold 
ranges parameter values experts alarm handling domain 
experiments show approach efficient 
running times seconds minutes time hundreds frequent episodes 
methods robust sense change parameter adds removes frequent episodes replace 
experiments injective frequency serial episodes parallel episodes threshold count time count time table results experiments fixed window width varying frequency threshold 
episode number number number size episodes candidate frequent match episodes episodes delta delta delta delta delta delta delta table number candidate frequent serial episodes frequency threshold averaged window widths quality candidate generation table shows number candidate frequent serial episodes iteration frequency threshold averaged test runs window widths seconds 
iteration size event types checked 
larger episodes combinatorial information exists take advantage 
size half candidates turned frequent 
seen table possible practical improvement discovery episodes sequences time relative size database scale results serial episodes dotted line injective parallel episodes solid line window width frequency threshold 
combine iterations generating candidate episodes iterations avoid reading input sequence times 
pays iterations candidates recognize match 
scale performed scale tests fold multiples sequence sequences approximately events 
results show time requirement linear respect length input sequence expected analysis 
incremental recognition tested efficiency database pass particular effect incremental recognition 
presents ratio times needed trivial vs incremental recognition candidate episodes 
time required generate windows trivial method excluded results 
shows incremental methods faster factor roughly linearly respect window width seconds 
consistent analysis algorithm injective parallel episodes worst case experiments efficiency ratio window width ratio times needed trivial vs incremental recognition methods serial episodes dotted line injective parallel episodes solid line functions window width 
analysis gave difference factor win 
results indicate incremental recognition method useful practice non injective serial episodes 
analyze effect incremental recognition detail conducted controlled tests 
alarm database different network sequence contains events covering time period days 
ignored actual times events assumed alarm arrived time unit 
event types number occurrences ranges 
tests considered injective parallel episodes 
table presents results test runs different window widths frequency thresholds 
results efficiency respect number frequent episodes candidates similar ones obtained sequence frequency thresholds experiments higher data dense event time unit 
central outcome analysis windowing methods effect window width win time complexity 
examined tests factors particular candidate collection fixed 
discovery episodes sequences window frequency candidate frequent width threshold episodes episodes time table results experiments sequence collection candidates consists episodes sizes 
presents total times recognizing candidates input sequence window widths time units total time trivial method doubles seconds 
incremental method time turn cut seconds 
running time trivial method approximately win incremental method win 
results match time complexity analysis earlier 
particular time complexity trivial method greater factor window width win approximating functions give factor win 
efficiency ratio experiments better experiments described earlier ratio ranges 
extensions related ideas instance candidate generation method stem discovery frequent sets association rules 
various extensions association rules apply directly minor modifications episodes 
instance methods extended event taxonomy direct application similar extensions association rules hf sa 
see section extensions related association rules 
technical problems related recognition episodes researched fields 
advantage slowly changing contents group events studied artificial intelligence similar problem spirit pattern object pattern match problem production system interpreters 
active databases extensions related time window width trivial method incremental method time database pass function window width 
related problem efficient detection trigger events see gjs 
comparable strategies sliding window study locality virtual memory den 
setting differs window queue special property know advance event leave window knowledge recognition serial episodes 
methods matching sets episodes sequence similarities algorithms string matching gl 
particular recognizing serial episodes sequence seen locating occurrences subsequences matches patterns variable length don care symbols length occurrences limited window width 
learning set sequences received considerable interest field bioinformatics interesting problem discovery patterns common set related protein amino acid sequences 
classes patterns differ substrings fixed length don care symbols 
closer patterns considered wcm 
described algorithm finds patterns similar serial episodes patterns minimum length occurrences edit distance 
problem discovering called sequential patterns closely related 
sequential patterns similar serial episodes discovery episodes sequences roughly described association rules discovered ordered sets 
lately pattern class extended windowing extra time constraints event taxonomy sa 
survey patterns sequential data see lai 
class patterns discovered easily modified directions 
methods analyze sequences 
sequences short windowing meaningful simpler database passes sufficient 
windowing variety choices definition frequency episode set sequences 
second windowing strategies considering windows starting win time units win windows starting event serial episode event types order windows starting event type taken account 
extension similar idea mt 
framework express episodes time bounds occur seconds follow minutes 
third patterns searched substrings fixed length don care symbols 
frequent episodes frequencies known generate episodes rules similar association rules 
episode rule state instance events types window event type window parallel episode rule events window order event type serial episode rule 
serial episode rules point forward backward time illustrated example left hand side places filled corresponding events right hand side 
episode rules generated frequent episodes way association rules generated frequent sets 
extending association rule methods deal multisets ordered sets fairly straightforward 
final note mentioned described methods analyze alarm databases telecommunication operators 
applications methods described hkm hkm 
goal discovering new useful knowledge achieved episode rules discovered alarm sequences taken alarm handling software operators 
chapter discussion gets harder know 
find 
frank discussed discovery frequent patterns large data collections 
efficient method discovery frequent sets association rules chapter 
generalized problem setting algorithm chapter discovery frequent patterns general 
showed exact database rules inclusion dependencies functional dependencies discovered algorithm 
analyzed problem discovering frequent patterns chapter showed algorithm discovery frequent sets optimal constraints 
knowledge discovery setting chapters originally mt far attempt provide unified view data mining 
chapter considered sampling discovery association rules gave methods efficient terms database activity 
idea determine random sample probable superset collection frequent sets verify result database pass 
approach shown effectively frequent sets 
combination sampling verification general situations random samples give results selection criterion patterns fraction rows match pattern 
chapter looked discovery boolean rules association rules negation disjunction 
demonstrated approximations boolean rules computed frequent sets 
discussion number boolean rules hold database usually huge useful approach user queries system specific rules classes rules 
collection frequent sets condensed representation mt database queries answered approximately looking database 
approach strong connection line analytical processing olap ad hoc queries summaries large data collections answered efficiently 
chapter introduced episodes novel class regularities event sequences 
episode defined collection events tend occur close 
frequent episodes rules derived describe connections groups events sequence 
rules explain predict events 
gave methods discovery frequent episodes methods successfully applied analysis fault management data telecommunication operators 
combining results chapters sampling boolean rules episodes part straightforward 
sampling sequences useful sample size small order outperform incremental methods database pass 
larger picture knowledge discovery finding frequent patterns just part important 
essential ingredient discovery process identification interesting useful regularities 
thousands association episodes rules hold data collection confidence frequency point useful rules 
interactive methodology data mining close olap spirit suggested discover large collection rules frequent sets provide tools user efficiently query rule set 
approach advantage methodologies knowledge discovery machine learning changing viewpoint result new time consuming phase discovering patterns 
research leading thesis started data mining knowledge discovery concepts known people including author 
problem discovering association rules introduced year ais 
data mining knowledge discovery database community 
years research articles related association rules published including describe research 
commercial interest hype catching quickly 
companies announced data mining products things discover association rules rules similar episode rules 
interesting research problems remain open 
widely applicable generic algorithm discovering frequent sentences 
classes patterns searched reliably sampling 
useful condensed representations different pattern types 
locate truly interesting patterns patterns hold data collection 
discussion ais agrawal imielinski swami 
mining association rules sets items large databases 
buneman jajodia editors proceedings acm sigmod international conference management data sigmod pages washington 
acm 
ams agrawal mannila srikant toivonen verkamo 
fast discovery association rules 
fayyad piatetsky shapiro smyth uthurusamy editors advances knowledge discovery data mining pages 
aaai press menlo park ca 
alon spencer 
probabilistic method 
john wiley new york ny 
agrawal srikant 
fast algorithms mining association rules large databases 
jarke zaniolo editors proceedings twentieth international conference large data bases vldb pages santiago chile 
morgan kaufmann 
agrawal srikant 
mining sequential patterns 
yu chen editors proceedings eleventh international conference data engineering icde pages taipei taiwan 
ieee computer society press 
bel bell 
discovery maintenance functional dependencies independencies 
fayyad uthurusamy editors proceedings international conference knowledge discovery data mining kdd pages montr eal canada 
aaai press 
ber berge 
hypergraphs 
combinatorics finite sets 
northholland publishing amsterdam netherlands rd edition 
cfp casanova fagin papadimitriou 
inclusion dependencies interaction functional dependencies 
journal computer system sciences 
cod codd 
relational model large shared data banks 
communications acm 
db de raedt bruynooghe 
theory clausal discovery 
proceedings thirteenth international joint conference artificial intelligence ijcai pages chamb ery france 
morgan kaufmann 
den denning 
working set model program behavior 
communications acm 
eiter gottlob 
identifying minimal transversals hypergraph related problems 
siam journal computing 
ep elder iv pregibon 
statistical perspective knowledge discovery databases 
fayyad piatetsky shapiro smyth uthurusamy editors advances knowledge discovery data mining pages 
aaai press menlo park ca 
fk fredman khachiyan 
complexity dualization monotone disjunctive normal forms 
technical report lcsr tr department computer science rutgers university newark nj 
fukuda morimoto morishita 
mining optimized association rules numeric attributes 
proceedings fifteenth acm sigact sigmod sigart symposium principles database systems pods pages canada 
acm 
forgy 
rete fast algorithm pattern object pattern match problem 
artificial intelligence 
fayyad piatetsky shapiro smyth uthurusamy editors 
advances knowledge discovery data mining 
aaai press menlo park ca 
gjs gehani jagadish shmueli 
event specification active object oriented database 
stonebraker editor proceedings acm sigmod international conference management data sigmod pages san diego ca 
acm 
gl grossi 
simple efficient string matching mismatches 
information processing letters 
hf han fu 
discovery multiple level association rules large databases 
dayal gray nishio editors proceedings st international conference large data bases vldb pages zurich 
morgan kaufmann 
hkm klemettinen mannila ronkainen toivonen 
knowledge discovery telecommunication network alarm databases 
su editor proceedings twelth international conference data engineering icde pages new orleans la 
ieee computer society press 
hkm klemettinen mannila ronkainen toivonen 
tasa telecommunication alarm sequence analyzer enjoy faults network 
ieee network operations management symposium pages kyoto japan 
ieee 
kersten mannila toivonen 
perspective databases data mining 
fayyad uthurusamy editors proceedings international conference knowledge discovery data mining kdd pages montr eal canada 
aaai press 
hs haas swami 
sequential sampling procedures query size estimation 
stonebraker editor proceedings acm sigmod international conference management data sigmod pages san diego ca 
acm 
hs swami 
set oriented mining association rules 
research report rj ibm almaden research center san jose ca 
collins higgins 
finding flexible patterns unaligned protein sequences 
protein science 
ka 
discovering foreign key relations relational databases 
yves kodratoff taylor editors workshop notes ecml workshop statistics machine learning knowledge discovery databases pages heraklion greece 

khardon 
translating horn representations characteristic models 
journal artificial intelligence research 
klo 
efficient discovery interesting statements databases 
journal intelligent information systems 
kls kahn linial 
inclusion exclusion exact approximate 
manuscript 
km kivinen mannila 
power sampling knowledge discovery 
proceedings thirteenth acm sigact sigmod sigart symposium principles database systems pods pages minneapolis mn may 
acm 
kmr klemettinen mannila ronkainen toivonen verkamo 
finding interesting rules large sets discovered association rules 
adam bhargava yesha editors proceedings third international conference information knowledge management cikm pages gaithersburg md 
acm 
mannila 

discovering functional inclusion dependencies relational databases 
international journal intelligent systems 
klemettinen mannila toivonen 
interactive exploration discovered knowledge methodology interaction usability studies 
technical report department computer science university helsinki finland 
lai laird 
identifying patterns sequential data 
jantke kobayashi tomita yokomori editors algorithmic learning theory th international workshop pages berlin germany 
springer verlag 
ln linial nisan 
approximate inclusion exclusion 
proceedings second annual acm symposium theory computing stoc pages baltimore md 
acm 
mit mitchell 
generalization search 
artificial intelligence 
mannila 

design relational databases 
addison wesley publishing wokingham united kingdom 
mannila 

complexity inferring functional dependencies 
discrete applied mathematics 
mannila 

algorithms inferring functional dependencies 
data knowledge engineering 
mt mannila toivonen 
discovering generalized episodes minimal occurrences 
simoudis han fayyad editors proceedings second international conference knowledge discovery data mining kdd pages portland 
aaai press 
mt mannila toivonen 
multiple uses frequent sets condensed representations 
simoudis han fayyad editors proceedings second international conference knowledge discovery data mining kdd pages portland 
aaai press 
mt mannila toivonen 
algorithm finding interesting sentences 
trappl editor cybernetics systems volume ii thirteenth european meeting cybernetics systems research pages vienna austria 
austrian society cybernetic studies 
mtv mannila toivonen verkamo 
efficient algorithms discovering association rules 
fayyad uthurusamy editors knowledge discovery databases papers aaai workshop kdd pages seattle wa 
aaai press 
mtv mannila toivonen verkamo 
finding association rules efficiently sequential data 
technical report department computer science university helsinki finland 
mtv mannila toivonen verkamo 
discovering frequent episodes sequences 
fayyad uthurusamy editors proceedings international conference knowledge discovery data mining kdd pages montr eal canada 
aaai press 
olken rotem 
random sampling trees 
apers wiederhold editors proceedings fifteenth international conference large data bases vldb pages amsterdam netherlands 
morgan kaufmann 
park 
chen yu 
effective algorithm mining association rules 
carey schneider editors proceedings acm sigmod international conference management data sigmod pages san jose ca 
acm 
pk pfahringer kramer 
compression evaluation partial determinations 
fayyad uthurusamy editors proceedings international conference knowledge discovery data mining kdd pages montr eal canada 
aaai press 
ps piatetsky shapiro 
discovery analysis presentation strong rules 
piatetsky shapiro frawley editors knowledge discovery databases pages 
aaai press menlo park ca 
ptw tarjan woods 
notes introductory combinatorics 
birkhauser boston ma 
sa srikant agrawal 
mining generalized association rules 
dayal gray nishio editors proceedings st international conference large data bases vldb pages zurich 
morgan kaufmann 
sa srikant agrawal 
mining quantitative association rules large relational tables 
jagadish mumick editors proceedings acm sigmod international conference management data sigmod pages montr eal canada 
acm 
sa srikant agrawal 
mining sequential patterns generalizations performance improvements 
apers bouzeghoub editors advances database technology th international conference extending database technology edbt pages avignon france 
springer verlag 
sie siebes 
data surveying foundations inductive query language 
fayyad uthurusamy editors proceedings international conference knowledge discovery data mining kdd pages montr eal canada 
aaai press 
son savasere omiecinski navathe 
efficient algorithm mining association rules large databases 
dayal gray nishio editors proceedings st international conference large data bases vldb pages zurich 
morgan kaufmann 
toivonen klemettinen ronkainen mannila 
pruning grouping discovered association rules 
yves kodratoff taylor editors workshop notes ecml workshop statistics machine learning knowledge discovery databases pages heraklion greece 

toi toivonen 
sampling large databases association rules 
buchmann mohan editors proceedings nd international conference large data bases vldb pages india 
morgan kaufmann 
wcm 
wang 
chirn marr shapiro shasha zhang 
combinatorial pattern discovery scientific data preliminary results 
snodgrass winslett editors proceedings acm sigmod international conference management data sigmod pages minneapolis mi 
acm 
issn isbn helsinki helsinki university printing house 
