numerical representations higher order nested datatypes december ralf hinze institut fur informatik iii universitat bonn bonn germany mail ralf informatik uni bonn de number systems serve templates container types container object size modelled representation number operations container objects modelled number theoretic counterparts 
binomial queues probably data structure designed analogy mind 
show express called numerical representations higher order nested datatypes 
nested datatype allows capture structural invariants numerical representation violation invariant detected compile time 
develop programming method allows adapt algorithms new representation straightforward manner 
framework employed implement different container types binary random access lists binomial queues finger search trees 
data structure treated depth seen main innovation data structural point view 
appears finger search trees best known purely functional implementation ordered sequences 
detail finger search trees support operations findmin deletemin theta amortized time member insert delete theta log minfd gamma dg amortized time distance smallest element 
addition concatenation supported theta log minfn splitting theta log minfd gamma dg merge theta log ns amortized time ns size shorter size longer sequence 
bounds remain valid data structure persistent setting 
wish life short thought 
languages take time things wants know lost road consider definition trees taken introductory textbook data structures algorithms aho hopcroft ullman 
tree tree properties 

interior node children 

path root leaf length 
hinze implementing trees favourite programming language faced problem enforce properties linguistic concepts language 
programming language offers sum types formulation property straightforward 
suitable definition look functional programming language haskell peterson hammond 
data tree empty node tree tree node tree tree tree second condition appears problematic 
note constraint reflected definition node empty node empty empty element tree int legal tree 
probably unclear express condition today programming languages 
usually programmer responsible check condition preserved program 
reason second property referred datatype invariant 
goes saying preferable programmer delegate proof obligation compiler type checker 
question naturally arises possible devise practical type system allows formulate structural constraints 
unsurprisingly answer 
surprisingly need haskell type system sufficient purpose 
order express structural constraints combine advanced features nested datatypes bird meertens higher order polymorphism jones 
nested datatypes known non uniform datatypes non regular datatypes paterson 
nested datatype recursive parameterised datatype definition involves recursive call arguments left hand side 
simplest example nested datatype 
data perfect zero succ perfect note recursive call right hand side perfect substitution instance left hand side 
history nested datatypes quite revealing 
hindley milner type system milner permitted nested datatypes 
largely ignored practice type system rejects definition recursive functions types 
definition illustrates reason refusal 
height perfect int height zero height succ height strictly speaking higher order polymorphism necessary expressing structural invariants 
simplifies programming nested datatypes 
numerical representations higher order nested datatypes function height unusual recursive call type perfect int substitution instance declared type 
hindley milner system requires types equal 
restriction noticed mycroft proposed suitable extension type system 
unfortunately shown typability system undecidable henglein 
designers haskell peterson hammond took pragmatic approach problem undecidability polymorphic recursion allowed programmer explicitly provides type signature 
definition height perfectly acceptable haskell 
see nested datatypes relevant goal enforcing structural constraints consider sample elements perfect int zero succ zero succ succ zero succ succ succ zero interpret pairs nodes see elements type perfect correspond perfect binary leaf trees 
recall perfect leaf tree path root leaf length 
definition height furthermore shows prefix succ zero constructors encodes height leaf tree 
binary leaf trees belong class leaf oriented trees elements stored leaves 
trees typically node oriented elements stored inner nodes 
adjust definition perfect leaf trees node oriented trees 
possible solution supply additional type parameter type search keys 
data tree zero succ tree node data node node node tree represent trees base type potential disadvantage representation type definitions explicate parameter container type second parameter 
type parameters node instance completely unrelated 
alternative representation models situation faithfully called higher order nested datatypes 
nested datatype termed higher order type parameter instantiated recursive call ranges type constructors types 
higher order variant datatype perfect data perfect bush zero bush succ perfect fork bush data fork bush fork bush bush higher order variant explicit argument zero container type base type advantage higher order approach definition easily adapted types trees 
trees simply hinze replace fork node data tree tree zero tree succ tree node tree data node tree node tree tree node tree tree tree discuss relationship order higher order nests exhaustively sec 

moment merely higher order nests preferable particular technical reason 
complete definition trees define polymorphic datatype initial parameter tree data empty empty type tree empty desired representation trees base type consider examples 
empty tree denoted zero empty term succ zero node empty empty denotes tree consists single node labelled 
tree depicted fig 
represented succ succ succ zero node node node empty empty empty node empty empty empty node node empty empty node empty empty node empty empty empty note tree empty encodes structural invariants trees 
unbalanced tree node empty node empty empty instance element tree empty int type system enforces subtrees height 
question remains adapt usual functions search insertion deletion representation trees 
sight complete redesign usual algorithmic solutions necessary 
main contributions develop method renders programming higherorder nested datatypes surprisingly simple 
cases straightforward mechanical transformation suffices adapt functions regular datatypes non regular colleagues 
framework implement different container types binary random access lists binomial queues finger search trees 
common characteristic datatypes numerical representations sense okasaki 
container type qualifies numerical representation modelled representation natural numbers 
haskell predefined lists instance seen modelled unary representation natural numbers 
data structures listed modelled binary number system 
binary random access list example sequence perfect binary leaf trees increasing height 
length random access list say dictates structure contains leaf tree height th bit binary representation 
best known example numerical representation numerical representations higher order nested datatypes sample tree left spine view double spine view 
fig 

different views trees 
probably binomial queues binomial queue sequence heap ordered binomial trees increasing height 
numerical representations typically contain regular data structures components higher order nested datatypes ideally suited translation programming language 
see trees fit setting consider tree shown fig 

offsprings nodes left spine form sequence trees successive heights 
fig 
depicts tree called left spine view 
representations isomorphic exhibit different access characteristics 
accessing leftmost smallest element takes theta log steps search trees constant time left spine view 
insertion tree requires theta log time insertion tree left spine view independent tree size costs theta log steps distance smallest element 
design obtain call double spine view trees see fig 

essence double strand trees increasing height allows access front rear simultaneously 
consequently insertion requires theta log minfd gamma dg steps 
trees left spine double spine view means new data structure 
correspond finger search trees guibas static finger front rear sequence 
finger search tree data structure represents ordered sequence way searches fast vicinity finger finger points arbitrary position sequence 
imperative setting finger search trees usually implemented level linked trees 
level linked tree node links neighboring nodes level 
addition upward links children parents 
functional setting level linked trees prohibitive update necessarily takes theta steps 
see case note level linked tree strongly connected interpreted graph 
absence side effects renders necessary copy complete tree single node hinze changed 
words level linked trees adapted persistent setting implementation support updates queries previous version data structure 
order retain properties finger search trees confine oneself static finger front rear sequence 
functional programmers finger search trees interest constitute best known purely functional data structure ordered sequences 
ordered sequences generalize priority queues adding functions searching deleting elements concatenation splitting 
implementation double spine view trees amortized time bounds member insert delete take theta log minfd gamma dg steps findmin take theta steps deletemin take theta steps concatenation takes theta log minfn steps partition takes theta log minfd gamma dg steps merge takes theta log steps distance smallest element size shorter size longer sequence 
bounds remain valid data structure persistent setting 
see importance container abstraction note dijkstra algorithm single source shortest paths dijkstra prim algorithm minimum weight spanning trees prim require operation easily defined terms insert delete furthermore note purely functional implementations priority queues king paulson okasaki okasaki okasaki support efficiently 
imperative setting delete require maintenance additional pointers data structure technique reproduced functional language 
exception statement priority queue implementations search tree schemes instance splay heaps okasaki sec 

search trees reach time bounds fingers search trees 
rest organized follows 
sec 
motivates higherorder nested datatypes expressing structural constraints 
sec 
reviews binary numerical representations sec 
reviews tree structures typically binary numerical representations 
sec 
develops framework binary random access lists running example 
sec 
applies framework binomial heaps 
trees left spine double spine view discussed length sec 

sec 
reviews related sec 
concludes 
assume big notation log log maxf xg 
numerical representations higher order nested datatypes higher order nested datatypes purpose section show higher order nested datatypes naturally arise tries encode structural constraints datatype 
simple seemingly uninteresting example 
aim devise list type property th element list type equal course haskell predefined numeric types unsuited purpose 
take unary representation natural numbers known peano numerals starting point 
data nat zero succ nat type nat contains natural numbers 
gain better control decompose nat base recursion case 
tradition haskell name types values alike 
stick tradition possible 
data zero zero data succ nat succ nat type constructor succ takes recursive component type parameter 
type succ zero contains single element succ zero representation prerequisites definition envisaged list type straightforward 
data nats nat nil cons nat nats succ nat recursive call nats succ nat substitution instance left hand side nats example nested datatype 
list type nats nat contains sequence elements type nat succ nat succ nat forth 
type definition reminiscent function nats nats nats generates infinite list successive integers correspondence shows sense computing types defining nested datatype 
relevance introductory example apparent switch numbers container types 
design list type constrains th element stack containing exactly elements 
note stacks correspond closely peano numerals see okasaki 
data nat zero succ nat data stack empty push stack type definitions essentially structure 
difference stack contains elements natural number 
view correspondence idea suggests follow road led definition datatype nats 
decomposition stack yields hinze type definitions 
data empty empty data push stack push stack stack type constructor type type parameter stack consequently ranges type constructors 
formally succ kind push kind 
recall kind system haskell specifies type type constructor see jones 
kind represents nullary constructors bool int nat kind represents type constructors map type constructors kind kind kinds decomposed types easy determine 
assume original type kind decomposed types kind corresponding constructor recursive component kind 
turning back example push empty type polymorphic stacks size type nats easy adapt 
data stacks stack nil cons stack stacks push stack type parameter instantiated recursive call ranges type constructors 
stacks example higher order nested datatype 
list type stacks stack contains elements types stack push stack push stack forth 
binary numerical representations section briefly reviews basics numerical representations 
indepth treatment topic refer interested reader textbook okasaki 
number systems serve templates container types container object size modelled representation number operations container objects modelled number theoretic counterparts inserting element corresponds incrementing number deleting element corresponds decrementing number merging container objects corresponds adding numbers halving container object corresponds dividing number 
data structures exception binary number system 
recall value binary number gamma gamma note write significant digit 
binary representation essentially sequence digits th digit contains data structures size digits usually drawn set 
means compelling 
alternative choices include 
digit zero admissible called representation 
way represent numbers called redundant number system 
system system redundant 
numerical representations higher order nested datatypes choice appropriate number system course dictated set operations particular container abstraction support 
examine properties different systems closely 
system binary increment decrement defined follows ffl denotes empty sequence 
ffl dec ffl dec dec dec operations take theta steps worst case number digits 
known averaging sequence increment operations yields amortized time bound theta cormen ch 

amortized bound holds binary decrement 
interesting contrast standard binary system system 
ffl dec ffl dec dec dec digit takes role takes role 
system may preferable reasons 
digit abandoned favour digit natural number unique representation 
particular need disallow leading zeros 
furthermore representation dense improves running time access functions head potential disadvantage systems non redundant number systems general support increment decrement efficiently 
alternating increment decrement operations oscillate worst case arises operation 
redundant number system avoids situation follows 
assume digits 
worst case increment sequence worst case decrement sequence ones dec 
subsequent decrement increment operation takes constant time dec 
see works consider definitions increment decrement 
ffl dec ffl dec dec dec dec operation identify expensive cheap digits 
digit expensive increment expensive decrement 
trick operation processes expensive digit leaves cheap digit 
increment decrement run theta amortized time 
unfortunately amortized time bounds break persistent setting 
illustrate assume delta gamma consider independent threads increment worst case arises increment costs counterbalanced preceding cheap operations 
okasaki shown series papers lazy evaluation mediate conflict hinze amortization persistence 
regime lazy evaluation dec constant time operations calls essentially delayed 
operation inspects number potentially costly evaluate delayed calls dec 
call evaluated value memoized subsequent operations need redo 
reconsider example 
incrementing constant time operation 
furthermore lazy evaluation guarantees evaluated 
evaluated threads done shared threads 
called debit argument prove dec operations inspect significant digit run theta amortized time 
principle idea delayed call assigned number debits paid value 
debit represents constant amount delayed 
lazy number system show operations preserve debit invariant expensive digits allowed zero debits cheap digits allowed debit 
assume number begins sequence followed 
incrementing changes 
step newly created digit assigned debit 
step digit changed 
debits discharged restore invariant 
unshared cost theta operation takes theta amortized time 
proof dec completely analogous 
operation inspects significant digit runs theta amortized time debit discharged 
data structures introduced subsequent sections variations lazy binary number system 
haskell non strict language implementation lazy number systems comes free 
regular tree structures essentially types trees binary numerical representations perfect binary leaf trees pennants binomial trees okasaki 
consider turn 
leaf tree full binary tree elements stored leaves 
formally element datatype 
data bush leaf fork bush bush interested perfect leaf trees decompose bush base recursion case 
data leaf leaf data fork bush fork bush bush remainder decomposed types 
original type definitions easily reconstructed case 
perfect binary leaf tree rank element fork leaf pennant perfect binary search tree additional node top 
numerical representations higher order nested datatypes leaf tree pennant binomial tree 
fig 

regular tree structures rank 
necessary type definitions 
data empty empty data bin tree bin tree tree data pennant tree pennant tree pennant rank element type pennant bin empty binomial tree multiway branching tree defined follows binomial tree rank consists single node tree rank gamma descendants binomial trees ranks upto gamma 
structure captured definitions 
data lin lin data snoc subtrees snoc subtrees node subtrees data node subtrees node subtrees subtrees organized called snoc lists build left right 
binomial tree rank element node snoc lin fig 
depicts types trees 
leaf trees pennants binomial trees rank contain elements probably comes surprise structures isomorphic 
correspondence leaf trees pennants best explained viewing leaf tree initial configuration tournament corresponding pennant corresponding final configuration 
inner node leaf tree note lin snoc nil cons spelled backward 
hinze represents match leaf stands participant 
top node corresponding pennant contains winner tournament inner nodes decorated loser matches 
relation pennants binomial trees direct 
note decomposed types essentially tuple types empty lin nullary tuples bin triple pennant snoc node pairs 
looking carefully see snoc nested pair form trivially isomorphic triple alias bin snoc type binomial forests really binarized variant bin type perfect binary search trees 
types empty lin types pennant node push sec 
identical 
eliminate unnecessary diversity henceforth empty nullary nodes types synonyms datatype 
data front tree tree straightforward induction rank show fork leaf pennant bin empty node snoc empty 
isomorphisms remain valid drop size constraints 
second isomorphism instance called natural correspondence binary trees forests knuth 
leaf trees pennants isomorphic important note exhibit different access characteristics 
accessing leftmost element leaf tree rank requires steps 
pennant done constant time leftmost element leaf tree appears top element corresponding pennant 
catenable sequences okasaki instance fact 
differences pennants binomial trees really minor pennants space economical linking unlinking slightly faster binomial trees hinze 
random access lists necessary prerequisites hand tackle implementation binary numerical representations basis higher order nested datatypes 
example translate binary random access lists framework 
random access lists implement sided indexable sequences 
container abstraction combines typical list operations operations accessing updating list elements position 
random access lists sided support operations front efficiently 
fig 
displays suitable signature indexable sequences 
note usual list operations null head tail combined single function called front type ha bi occurs type signature termed optional pair element type null pair form ha bi 
call front consequently possible outcomes sequence empty front returns null yields ha head tail 
random access lists originally leftist left complete leaf trees 
observation data structure recast numerical representation due okasaki 
binary numerical representations higher order nested datatypes data ha bi null ha bi empty cons front ha ai snoc rear ai access int update int fromlist tolist fig 

signature indexable sequences 
random access list sequence perfect binary leaf trees increasing rank 
structure captured data type definition 
data bush nil zero fork bush bush fork bush type leaf representation sequence uniquely determined binary decomposition size 
sequence size instance represented term zero nil type fork leaf random access lists system discussed length okasaki sec 
implement representation system 
lessons going learn prove useful tackle implementation finger search trees sec 

recall binary numeric representations idea digit corresponds container object comprising trees equal rank 
system offers interesting alternative weight represented tree rank single tree rank 
representation superior practice eliminates redundancy standard design 
type random access lists consequently takes form 
data bush nil bush fork bush fork bush fork bush follows abbreviate type constructor names letter 
level type structure ral calls recursively defined ral set characteristic higher order nested datatypes 
functions higher order nests typically follow type structure 
function cons extends sequence front may serve example 
hinze element converted singleton tree 
cons cons incr leaf helper function incr adds bush list bushes recursion pattern binary increment see sec 

incr bush ral bush ral bush incr nil nil incr ds fork ds incr ds incr ds note incr doubly polymorphic works arbitrary element types arbitrary base type constructors 
furthermore note incr uses higher order polymorphic recursion 
recursive call third equation type ral ral substitution instance declared type 
transform ordinary list random access list simple iterate cons starting empty sequence nil fromlist fromlist foldr cons nil expression fromlist example evaluates nil classical algorithm shrinking sequence front modelled binary decrement dec ffl dec dec dec 
striving elegance slightly different approach 
note cases simplified temporarily allow leading zero dec 
eliminate zero repeatedly applying rules ffl ffl 
zero ral fork bush ral bush zero nil nil zero ds zero ds zero fork ds ds building zero implementation front straightforward 
front ha ai front nil null front leaf ds ha zero dsi front fork leaf ts ha tsi traversing random access list things interesting write functions need inspect leaf trees random access list 
function tolist transforms random access list ordinary list serves motivating example 
numerical representations higher order nested datatypes function flatten ordinary leaf tree type bush flatten bush flatten leaf flatten fork flatten flatten note implementation efficient takes quadratic linear time worst case 
easily corrected standard techniques hughes 
function follow type 
obtain perfect leaf trees simply decompose flatten base recursion case 
leaf leaf bush 
fork bush flatten fork flatten flatten function takes recursive call parameter imitating transformations type level 
polymorphic function consequently flattens perfect leaf tree type fork leaf function listify flattens random access list naturally follows recursion scheme ral 
listify bush 
ral bush listify flatten nil listify flatten ds flatten listify flatten ds listify flatten ds flatten listify flatten ds recursing list listify builds appropriate flatten type fork bush 
recursion starts flatten set tolist tolist listify note tolist takes theta log time worst case 
construction tolist entirely straightforward higher order approach unwieldy single function involved say group mutually recursive functions 
fortunately simple alternative hand 
passing explicitly employ haskell type classes pass implicitly 
necessary definitions 
class flatten bush flatten bush instance flatten leaf flatten leaf instance flatten bush flatten fork bush flatten fork flatten flatten re original definition flatten change 
hinze supply necessary class instance definitions 
worth noting switch higher order functions type classes incur run time penalty 
compiler essentially generate code cases 
type classes advantage constructed automatically 
consider revised definition listify listify flatten bush ral bush listify nil listify ds flatten listify ds listify ds flatten listify ds note right hand sides equations identical 
course due fact flatten overloaded 
second equation flatten type bush occurrence third equation type fork bush 
uniform treatment cases reasons system representing digit single tree 
function tolist boils type specialized variant listify tolist tolist listify 
beautiful thing nested datatypes open new perspectives formulating algorithms 
known basically methods building tree bird recursive top iterative bottom 
methods corresponding inverse method takes tree list 
recursive method implemented listify works flattening subtrees appending results 
iterative method repeatedly splits trees subtrees singleton trees remain converted list elements 
second method equally straightforward implement due rigid structure datatype ral 
function listify returns list trees 
listify ral bush bush listify nil listify ds listify ds listify ds listify ds note recursive calls yields list trees type splits components 
fork bush bush fork ts ts rest easy 
tolist tolist leaf listify numerical representations higher order nested datatypes noted variant tolist takes linear time node processed constant number steps 
implementation access accesses th element sequence update updates th element sequence left exercise reader 
basically approaches 
works searching correct tree searching correct element okasaki 
second elegant employs structure random access lists okasaki 
variations different variations random access lists conceivable different number system employ different tree type design support sided indexable sequences 
consider dimension design space turn 
pros cons different number systems choice right system explained great detail okasaki ch 
sec 

content cursory remarks 
note number system preferable system supports head theta access update theta log opposed theta log system 
number system choice system supports increment decrement run theta amortized time 
type easily adapted adding fourth data constructor digit 
seen sec 
perfect binary leaf trees pennants binomial trees isomorphic 
question naturally arises gain say pennants perfect binary leaf trees 
turns pennants preferable wants implement ordered sequences support efficient membership test 
search element take theta log time distance query element front ordered sequence 
type random access lists easily adopted new situation 
data tree nil pennant tree bin tree pennant bin tree bin tree unfortunately insertion deletion expensive structure pennants rigid 
prove lower bound omega gamma insertion deletion data structure uniquely determined number elements contains snyder 
sec 
explains solve problem replacing perfect binary search trees trees redundant representation 
original article contains description random access deques grow shrink ends 
support symmetric set operations essentially design random access lists 
speaking terms tree transformations switch left spine view double spine view 
fig 
displays binary leaf tree hinze sample leaf tree double spine view 
fig 

different views leaf trees 
tree double spine view 
succession trees fig 
corresponds number ffl ffl marks root tree 
clear representation longer unique confine digits 
redundancy intended deque operations operate largely independent ends 
front rear part totally independent order avoid unbalanced situations instance ffl 
case element queue element right spine takes theta log time access 
reason require parts equal length 
allows represent ffl ternary nullary constructor 
data bush nil simple bush composite digit bush fork bush digit bush data digit bush bush fork bush type leaf singleton deques require special treatment smallest digit 
explains datatype rad comprises third constructor accommodates single tree 
important note rad bottom representation leaf tree digit contains leftmost tree left spine contains rightmost tree right spine 
leaf tree depicted fig 
instance numerical representations higher order nested datatypes represented nil code extending sequence front similar random access lists left exercise reader 
implement function extending sequence rear defined symmetrically 
snoc snoc leaf rad bush bush rad bush nil simple simple composite nil composite composite fork composite composite order versus higher order nested datatypes random access lists sequence types usually implemented order nested datatypes okasaki okasaki 
section shed light relationship order higher order nests discuss advantages disadvantages representations 
ease order variant ral okasaki adapted naming conventions previous sections 
data fork bush fork bush bush data bush nil bush fork bush fork bush fork bush theoretical point view approaches fact equivalent 
order variant easily defined terms higher order cousin ral fo ral ho leaf way round equally easy ral ho bush ral fo bush 
similar relation holds order higher order definition trees introduced sec 

const constant functor data const const tree fo tree ho const tree ho tree tree fo tree approach superior consequently question practical matters 
advantage order variant obvious type 
turn simplifies definition operations nests 
exemplify hinze consider order variant cons cons bush ral bush ral bush cons nil nil cons ds fork ds cons ds cons ds time space behaviour affected provided define types leaf const newtype declarations data declarations 
negative side class programming technique introduced sec 
adapted order nests 
consider definition ral note type parameter bush ranges tree types bush equals fork th level recursion initial call ral said surprising ral represents viable sequence type 
definition works identify singleton leaf tree label 
adapt class programming technique 
consider second definition tolist employs type class flatten 
require multi parameter type classes peyton jones 
class flatten tree flatten tree instance flatten bush flatten fork bush flatten fork flatten flatten auxiliary function listify signature 
listify flatten bush ral bush unfortunately listify nearly useful type context flatten bush ideally instance declaration lines expresses intent identifying singleton trees elements 
instance flatten flatten causes ambiguity problems definition non trivially overlaps instance declaration 
consider instance expression tolist type ral fork 
tolist deliver list type fork list type 
summarize order nests right choice implementing sequence types sequence container abstraction abstractions parametric respect element type 
container abstractions require inspect elements container higher order nests appear preferable 
numerical representations higher order nested datatypes data ha bi null ha bi empty ord ordsequence ord ordsequence ha ordsequence ai ord ordsequence ai member ord ordsequence bool insert ord ordsequence ordsequence delete ord ordsequence ordsequence ord ordsequence ordsequence ordsequence partition ord ordsequence 
ordsequence ordsequence merge ord ordsequence ordsequence ordsequence fromlist ord ordsequence tolist ord ordsequence fig 

signature ordered sequences 
binomial queues binomial queues vuillemin probably data structure developed close analogy binary number system 
binomial queues implemented times haskell king okasaki hinze 
shall see entirely straightforward adapt standard implementation new setting 
fact included application exemplifies problems arise adapting algorithms non regular types 
hand application shows beauty elegance non regular types 
binomial queues implement sided ordered sequences 
fig 
displays suitable signature ordered sequences 
container abstraction generalizes priority queues adding functions searching deleting elements concatenation splitting 
binomial queues support operations efficiently 
operations included view implementations finger search trees 
note usual operations priority queues isempty deletemin combined single function called concatenation ordered sequences defined max min operation partition splits ordered sequences max min binomial queue list heap ordered binomial trees increasing rank 
recall tree heap ordered elements root frontier path non decreasing order 
binomial queues standard binary number system 
point redundant representation 
data subtrees nil zero snoc subtrees node subtrees snoc subtrees type ordsequence empty hinze linking binomial trees careful preserve heap property 
link ord node ts node ts node snoc ts link ts snoc ts snoc type link states trees rank combined form tree rank 
type link general link full generality sense type general 
inserting element binomial queue corresponds incrementing binary number insert ord ordsequence ordsequence insert incr empty incr ord node ts bq ts bq ts incr nil nil incr zero ds ds incr ds zero incr link ds merging queues analogous adding binary numbers 
merge ord bq ts bq ts bq ts merge nil ds ds merge ds nil ds merge zero ds zero ds zero merge ds ds merge zero ds ds merge ds ds merge ds zero ds merge ds ds merge ds ds zero incr link merge ds ds incr merge polymorphic recursion 
explains type merge general needed 
restricted type ord os os os definition longer typecheck 
worth noting running time merge theta log amortized cost incr operations proportional number binomial trees okasaki 
extracting minimum element operation extracts minimum element essentially proceeds steps 
binomial heap minimum root determined replaced zero 
subtrees tree merged remaining trees queue 
lists maintained opposite order reverse list 
consider realize step 
moment reflection reveals facing problem express type function 
mathematical notation type bq ts hn bq ts ai rank extracted tree 
proceed 
answer surprisingly simple 
pull list reversal forward 
reversing binomial forest yields list type bq os numerical representations higher order nested datatypes operation receives type bq ts ha os bq ts ai 
reverse binomial forest folklore implementation employs auxiliary function bs reverse bs bird class subtrees subtrees bq subtrees ordsequence instance empty empty instance subtrees snoc subtrees snoc ts ts function called recursing list binomial trees 
data ha ci null ha ci extract ord ts bq ts ha os bq ts ai extract nil null extract zero ds case extract ds null null hm ds hm zero ds extract ts ds case extract ds null ha ts nil nili hm ds ha ts nil zero dsi hm ds note extract relies essential way lazy evaluation called min candidate 
strict environment determine minimum selectively extract minimum heap 
rest easy 
function calls extract merges binomial queues 
ord ordsequence ha ordsequence ai case extract null null hm hm merge halving binomial queue numerical representations support operations efficiently interpreted arithmetic functions 
section describe algorithm splitting binomial queue size queues size dn bn 
operation corresponds roughly division arithmetic shift left assuming significant bit comes 
splitting single binomial tree require link inverse 
unlink node snoc ts 
node ts node ts unlink snoc ts ts worth noting unlink total function 
type states tree rank hinze split trees rank regular types unlink necessarily partial function 
split binomial queue halves essentially apply unlink binomial trees 
purpose useful lift function application realm pairs 
pi 

pi halve bq snoc ts 
bq ts bq ts halve nil nil nil halve zero ds zero zero pi halve ds halve ds pi unlink pi halve ds type halve reflects fact halve binomial queues size 
size odd insert remaining tree rank half 
halve ord bq ts 
bq ts bq ts halve nil nil nil halve zero ds halve ds halve ds incr id pi halve ds trees left spine view finger search trees major application higher order nested datatypes 
section studies trees left spine view 
trees double spine view dealt section 
shall see implementations intensive class programming technique introduced sec 

trees left spine view best known purely functional implementation sided ordered sequences 
operations exhibit amortized time bounds member insert delete take theta log steps takes theta steps distance smallest element 
recall tree left spine view essentially list trees increasing rank 
tree rank element node empty node data node tree node tree tree node tree tree tree contrast structures sec 
size tree determined rank tree rank contains gamma gamma elements 
results snyder show redundant representation necessary able implement insert delete efficiently 
function termed cross bird 
numerical representations higher order nested datatypes ds ds ds ds ds ds fig 

graphical interpretation digits 
design decision concerns choice underlying number system 
left spine view trees suggests base finger search trees lazy number system 
encoding trick sec 
arrive definition fact minor modification type introduced sec 

data tree nil pennant tree node tree pennant node tree node tree type ordsequence empty recall weight represented pennants rank single pennant rank 
wait 
node tuple type argument slip 
pennant rank corresponds weight weight words data structure lazy number system 
fortunately exactly 
finger search trees redundant number system order achieve desired amortized time bounds theta theta log insert summarize finger search tree ordinary tree node left spine points parent left child 
nodes left spine nodes remaining nodes nodes 
fig 
shows representation digits haskell expressions graphical interpretation 
encoding trick proves useful implementing operations member insert delete aggravates readability operations modelled arithmetic functions 
restore readability called pattern abstractions fahndrich boyland allow name complex patterns 
pattern abstractions suggest 
pat ds ds pat ds ds pat ds ds minimize notation right hand side equations 
hinze cons ordsequence ordsequence cons incr incr fst fst incr nil nil incr ds ds incr ds ds incr ds incr ds zero fst node fst zero nil nil zero ds zero ds zero ds ds zero ds ds ordsequence ha ordsequence ai nil null ds ha zero dsi ds ha dsi ds ha dsi fig 

implementation cons incr zero 
prerequisites algorithms adding removing elements front easy code see fig 

finger search tree represents ordered sequence algorithms furthermore similar random access lists 
difference lazy number system system 
note cons adds new minimum front required implementation insert proof cons run theta amortized time identical sec 

searching study algorithm searching element lies heart functions inserting deleting elements 
algorithm works phases searches list trees appropriate tree searches tree query element 
note procedure tantamount exponential search followed binary search mehlhorn 
type classes coding second phase relatively straightforward 
class mem tree mem ord tree bool instance mem empty mem false instance mem tree mem node tree mem mem true mem numerical representations higher order nested datatypes mem mem true mem true mem search spine list take account split keys reside inconvenient places 
consider example tree ds 
order determine searched look digit ahead right candidate searched left 
encode information result search function datatype loc 
data loc lt eq 

loc loc lt lt eq eq operator required sequel corresponds map function data type loc 
search pattern described captured operator 
loc lt eq reduce number parenthesis agree function composition delta takes precedence 
turn takes precedence 
function member implements search assigned result type loc bool call member consequently outcomes lt signals searched left eq means searched indicating search successful 
member ord mem fst loc bool member nil lt member ds lt eq true eq mem member ds member ds lt eq true eq mem member ds curious situation right hand sides note loc isomorphic predefined type 
self defined type reasons readability extensibility see sec 

hinze equations identical 
direct representation digits say ds ds ds definition member twice long 
shows chosen encoding far superior avoids unnecessary duplication code 
important note non strict argument 
lazy evaluation vital guarantee theta log running time member function member simply calls member mapping lt false eq member ord ordsequence bool member false member see member runs theta log amortized time recall digit left spine assigned debit 
member processes log digits discharge log debits 
furthermore unshared cost searching tree theta log obtain total amortized running time theta log 
insertion things interesting 
algorithms studied far passive sense alter trees contained finger search tree 
element inserted tree tree possibly grow 
precisely inserting element tree rank results tree rank tree rank 
case root node node motivates definition 
data grown tree unchanged tree grown tree tree class ins tree ins ord tree grown tree different representations node node rank node rank 
alternatively may view node rank brown tarjan interpretation fits nicely framework numerical representations 
implementation ins relatively straightforward employs called smart constructors adams 
instance ins empty ins instance ins tree ins node tree ins node ins node ins ins node ins node ins node ins numerical representations higher order nested datatypes fig 

rebalancing operations insertion nodes heavily shaded 
code quite similar program unbalanced trees 
difference constructors node node replaced functions node node implementing rebalancing operations 
index indicates subtree altered 
essentially rebalancing operations visualized fig 

subtree node grows node expanded node 
node node smart constructor node defined accordingly 
subtree node grows node split nodes 
case height resulting tree increases 
node node remaining functions node node defined accordingly 
algorithm inserting element finger search tree essentially follows recursion pattern member function insert result type loc fst lt signals element inserted left eq ds means element inserted resulting finger search tree ds insert ord ins fst loc fst insert nil lt insert ds lt eq ins ds insert ds insert ds lt eq ins ds insert ds functions smart constructors continue balancing hinze spine list 
incr remains implement insert adds element ordered sequence 
insert ord ordsequence ordsequence insert cons insert conclude section simple application 
finger search trees implement adaptive sorting algorithm optimal respect number inversions 
sorting algorithm called adaptive nearly ordered sequences processed faster ordered sequences 
quantify amount presortedness measures proposed see instance mannila castro wood moffat petersson 
input sequence gamma number inversions inv jf gj measure inv indicates exchanges adjacent elements needed sort input 
announced algorithm insertion sort paradigm works repeatedly inserting elements empty initial tree 
sorted list obtained inorder traversal final tree 
fromlist ord ordsequence fromlist foldr insert nil converse fromlist tolist easily programmed 
essentially adapt functions sec 
pennants 
putting things obtain inv optimal sorting algorithm 
ord tolist delta fromlist see adapts input assume example input list sorted 
case insert repeatedly calls cons amortized running time theta 
consequently takes time linear size input sequence 
general amortized cost th insertion sequence gamma theta log number elements smaller jf gj 
inv log log inv fact inv optimal mehlhorn mannila 
numerical representations higher order nested datatypes external finger search trees decomposition trees base case recursion case trivial change base case 
flexibility instance improve space consumption finger search trees 
known internal search trees waste memory space empty nodes nodes tree 
estimate space usage constructed value gamma cells space occupied empty nodes ranges binary trees tertiary trees 
waste space avoided replace empty nodes leaves 
data leaf leaf leaf constructor leaf corresponds unary tuple leaf binary tuple 
operation ins extended leaf nodes 
instance ins leaf ins ins insert polymorphic respect base type constructor re new type 
attempt adapt insert new design slight problem shows 
recall insert reduces cons incr new minimal element 
second argument auxiliary function incr type leaf implies incr add elements front 
moment reflection reveals deficiency data structure represent singleton 
smallest trees nil nil nil hard remedy defect 
help defining suitable wrapper datatype 
data ordsequence id leaf add leaf convention smallest element add function insert easily adapted 
insert ord ordsequence ordsequence insert id ds add ds id insert ds insert add ds id incr ds id incr ds add insert ds hinze deletion deletion usually intricate insertion 
general observation proves true finger search trees 
broad picture clear decompose standard algorithm deletion works trees rank level type structure define functions delete delete works arbitrary base type constructors specialized type os deletion opposite insertion delete element tree rank obtain tree rank tree rank gamma 
unfortunately type system expressive formulate rank decreases 
correspond removing application type constructor clearly possible 
forced reformulate statement slightly delete element tree rank obtain tree rank tree rank give possibility deleting element rank tree 
empty base type constructor perfect sense point deleting element empty tree 
leaf base type accept little redundancy 
different techniques deleting element tree 
adapt standard algorithm binary search trees works replacing element inorder successor 
reason choosing algorithm simply need auxiliary function splices minimal element anyway 
necessary definitions 
data shrunk tree unchanged node tree shrunk tree class del tree splice node tree 
shrunk tree del ord node tree shrunk tree node may interpreted node single child brown tarjan 
function splice splices leftmost minimal element argument 
note splice returns pair optional pair ordinary pairs type splice guarantees tree contains element 
instance declarations fig 
supply code deleting element rank rank tree 
note intensive smart constructors 
fig 
visualizes rebalancing operations 
subtree node shrinks combined subtrees left right sibling 
node node node node node node numerical representations higher order nested datatypes instance del empty splice splice del del instance del tree del node tree splice node splice splice node splice del node del uncurry node splice node del del node del uncurry node splice node del uncurry node splice node del fig 

implementation splice del fig 

rebalancing operations deletion 
functions node node node defined accordingly 
fundamental difference balancing operations insertion deletion case context subtree taken account 
unfortunate consequence complicating definition delete consider instance finger tree ds assume deleting element causes tree shrink 
stuck necessary left context longer available 
furthermore counterbalance loss height looking right ds may empty 
help wrapping hinze result delete ds pair constructors signal height subtree decreased 
data tree unchanged node tree shrunk tree node node tree function delete returns element type loc fst 
delete ord del fst node loc fst delete nil lt delete ds lt eq uncurry splice ds eq del ds delta delete ds delete ds lt eq uncurry splice ds eq del ds delete ds smart constructors perform necessary rebalancing operations 
subtree node shrinks auxiliary constructor comes play 
eliminated enclosing function 
ds ds ds zero ds ds ds ds ds ds ds note delete expects finger tree type fst node tree spine list rank 
forced treat digit numerical representations higher order nested datatypes separately 
delete ord ordsequence ordsequence delete nil nil delete ds ds zero ds ds delete ds delete ds ds uncurry splice ds del ds delete ds duplication code sense price pay type system check structural constraints 
conclude section simple application 
dijkstra algorithm single source shortest paths prim algorithm minimum weight spanning trees require operation replaces element sequence smaller 
building insert delete definition straightforward 
decrease ord os os decrease member insert delete ordinary trees shown ordinary trees expressed nested datatype 
briefly consider operations search insertion deletion realized data structure 
recall structure trees captured datatype definition 
data tree tree zero tree succ tree node tree building constructor class mem implementation member entirely straightforward 
member ord mem tree bool member zero mem member succ member insertion deletion equally straightforward implement 
change height merely encoded prefix succ zero constructors 
easily accomplished smart constructors 
insert ord ins tree tree insert zero zero ins insert succ succ insert hinze zero grown tree zero zero zero succ zero deletion look constructor ahead able counterbalance possible loss height 
delete ord del tree tree delete zero zero delete succ zero succ del delete succ succ succ delete succ succ shrunk tree succ zero succ succ zero trees double spine view trees left spine view biased front extracting minimum cheap simple implement extracting maximum expensive non trivial implement 
design obtain data structure treats ends equal basis 
trees double spine view best known purely functional implementation ordered sequences member insert delete take theta log minfd gamma dg steps take theta steps takes theta log minfn steps partition takes theta log minfd gamma dg steps merge takes theta log steps distance smallest element size shorter size longer sequence 
type trees double spine view slight modification random access deques introduced sec 

data tree simple simple tree composite digit front tree node tree digit rear tree data digit pennant tree pennant tree pennant node tree data front tree tree data rear tree tree data ordsequence nil id empty numerical representations higher order nested datatypes points worth mentioning 
fst capable representing empty sequence 
reason wrapper datatype os introduced 
second different types pennants digits left right spine 
types chosen order elements expression type os reflects order elements sequence represented 
smallest finger search trees nil id id id 
ordered sequence size represented id id preceding section employ pattern abstractions improve readability code 
pat pat pat pattern abstraction rear digits defined accordingly 
deque operations operations cons incr zero colleagues snoc easily adapted new design 
show modified versions cons incr 
cons ordsequence ordsequence cons nil id cons id id incr incr fst fst incr incr incr incr incr incr instructive relate equations rebalancing operations trees 
equation incr corresponds expansion node node second equation realizes split node nodes 
ordered sequence built repeatedly calling cons obtain quite regularly shaped tree trees complete binary trees right spine digit appears 
operations cons snoc operate largely independent ends 
independence simplifies proof deque operations run theta amortized time see okasaki sec 

essence hinze debit front digit rear digit simply added 
define debit allowance digit 
delayed call allowed debits 
routine proof shows operations fact preserve debit invariant 
bag operations reasons space consider re implementation member modification insert delete left instructive exercise reader 
adapt member auxiliary datatype loc 
data loc lt eq gt loc lt eq gt function generalizes operator sec 

depending value second argument search continued left right 
function member implements quasi parallel search spines 
distance smallest element member runs theta log minfd gamma dg amortized time 
member ord mem fst loc bool member lt eq true gt member lt eq true eq mem eq true gt member min lt max gt eq mem member mem note assume digit front digit rear instances mem auxiliary function min determines leftmost smallest element contained digit max accordingly yields rightmost largest element 
min min max max numerical representations higher order nested datatypes fig 

concatenation fromlist fromlist 
function member calls member mapping lt gt false eq member ord ordsequence bool member nil false member id false member false adaptive sorting algorithm described sec 
irritating property worst case list descending order arguably sorted 
sense due measure inv yields largest value lists descending order 
represent ordered sequences trees view obtain sorting algorithm optimal respect inv inv inv reverse new worst case interleaving ascending descending list gamma gamma gamma gamma argue sequence sorted 
sec 
introduce sorting algorithm finger search trees sorts sequence linear time 
concatenation known trees support operations concatenation splitting theta log time 
possible adapt algorithms double spine view loss efficiency 
answer affirmative 
turns runtime complexity slightly better algorithms profit bottom representation 
concatenation ordered sequences depicted fig 

note defined element smaller element hinze operation works traversing spines trees root smaller tree reached 
walk pennants right spine argument joined pennants left spine second argument 
remaining pennants form spine lists concatenated sequence 
function join explained implements single step 
join node join join join join function join takes arguments rear digit sequence join previous step front digit second sequence 
join may produce tree higher rank second argument result type grown grown node respectively 
inspecting left hand sides equations see elements subtrees strictly alternating elements subtrees succession 
renders join implementation trivial second argument form digits converted nodes corresponding sizes digit node 
larger digit say converted node exception rule equation join 
said clear care taken ensure join receive digit corresponding node 
easily achieved applying transformation prior call join see 
function app iterates join arguments simple 
terminating cases correspond simple double triple increments 
app fst fst fst app incr app incr incr app incr incr app incr incr incr symmetric cases defined accordingly 
arguments composite app recurses 
app app join norm helper function norm implements mentioned normalization step numerical representations higher order nested datatypes fig 

concatenated sequence fig 
partitioned 
defined follows defined symmetrically 
norm incr norm checks empty arguments calls app second argument set 
ordsequence ordsequence ordsequence nil nil id id id app app recurses height smaller tree runs theta amortized time height contrast top concatenation trees takes theta time 
splitting operation partition splits ordered sequences max min simplicity allow contain elements equal strict variant partition yields sequences max min defined time bounds 
definition awkward large number cases considered 
fig 
displays result partition applied concatenated sequence fig 

splitting sequence proceeds steps 
tree min max determined conducting quasi parallel exponential search spines 
way back tree successively split halves combined pennants spines form ordered sequences 
function part implements stages dual function app sec 
hinze takes element type fst returns triple type fst fst 
part ord fst loc fst fst part lt gt part lt gt eq part min lt max gt eq cut part cut split recursion terminates root tree reached tree min max 
case auxiliary functions called performs initial cut 
code defined symmetrically 
zero zero zero zero zero zero way back helper function split called realizes single partitioning step 
takes arguments split key front digit result previous step rear digit 
split zero split zero partition calls part takes care various special cases 
partition ord os 
os os partition nil nil nil partition id nil id wrap part id nil wrap id id numerical representations higher order nested datatypes running time partition similar member insert takes theta log minfd gamma dg amortized time 
contrast top variant runs theta log time 
merging building partition define merge ordered sequences 
merge ord os os os merge case null ha cons merge partition algorithm reminiscent usual merge lists 
efficient uses exponential binary search linear search partition input sequences minimum number segments reordered obtain output sequence 
shown merge asymptotically optimal takes theta log amortized time size shorter size longer sequence moffat provided strict variant partition definition 
worst case merge sequences interleaved obtain ordered output sequence merge 
case merge profit exponential binary search 
asymptotically optimal merge exhibits adaptive behaviour 
consider instance sequences max min special case merge degenerates running time consequently amounts theta 
note number measures proposed order characterize simple problem instances merge 
interested reader referred carlsson depth treatment subject 
idea suggests implementation merge basis adaptive merge sort algorithm 
resulting algorithm termed inventors moffat petersson wormald 
ord tolist delta merge nil delta map single single ordsequence single id employs standard divide conquer strategy 
recursion pattern implemented higher order function colleague foldr foldl name chosen indicate builds balanced expression tree am am dn 
algorithm remarkable optimally adaptive range measures presortedness inv rem sms algorithm hinze fig 

worst case 
behaviour known author 
measure rem counts minimum number elements removed leave sorted sequence 
rem gamma ascending subsequence size algorithm rem optimal sorts theta rem log rem time 
measure sms defined minimum number monotone subsequences decomposed 
sms minf composed monotone sequences algorithm sms optimal sorts theta log sms time 
note sms superior measure runs counts number ascending runs input sms optimal algorithm runs optimal 
putting things running time theta minfn rem log rem log inv log sms see moffat 
worst case arises merge operation interleave arguments 
fig 
illustrates worst case sequence size 
sequence systematically constructed repeatedly ascending sequence 
step reverses merge operation sequence split 
instance understood simply turning fig 
upside 
turns sequence obtained corresponds called bit reversal permutation cormen problem original sequence 
bit reversal permutation operates sequences size natural number swaps elements indices binary representations reverse 
variations finger search trees augmented size fields additionally support order statistic operations 
selecting th smallest element instance implemented theta log gamma ig time 
briefly sketch necessary changes data structure 
suffices add size fields nodes numerical representations higher order nested datatypes maintain global size field 
data node tree node int tree tree node int tree tree tree data ordsequence nil id int empty size tree determined simply inspecting size field 
usual define suitable type class purpose 
class size tree size tree int instance size empty size instance size node tree size size order maintain size fields useful define smart constructors necessary calculations scenes 
size node size size size node size size size code previous sections easily adapted systematically replacing constructors smart counterparts 
implementation select os int determines th smallest element left instructive exercise reader 
note size field id necessary able conduct quasi parallel search spines 
related numerical representations idea numerical representations traces back programming problem solving seminar conducted clancy knuth 
loc 
cit 
describe attempt find data structure operations search insertion deletion take log worstcase time 
solution sketched amounts balanced search tree left spine view 
major insight rebalancing operations spine modelled segmented redundant binary number system digits drawn set 
digit may interpreted carry progress 
numbers satisfy invariant pair separated 
representation binary increment implemented constant time 

find leftmost change 

increment leftmost digit 
hinze interestingly nearly system re invented eighteen years kaplan tarjan call underlying design principle recursive slowdown 
able support increment decrement constant time digits drawn set 
simpler system digits gamma clancy knuth 
contrast lazy number systems segmented redundant binary numbers guarantee worst case amortized time bounds 
implementation costly consecutive grouped blocks able execute step constant time 
archetypical example binary numerical representations probably binomial queues vuillemin 
mehlhorn employs number systems static data structures support insertion deletion efficiently 
exemplify consider ordered table built time log searched time log 
order support modifications efficiently uses sequence tables non decreasing size size table corresponds weight digit 
data structure modelled binary number system searching slows log insertion deletion supported time log 
comprehensive treatment number systems textbook okasaki develops algorithmic design principle fine art 
particular lazy number systems simple alternative segmented redundant number systems 
underlying design principle called implicit recursive slowdown 
finger search trees finger search trees invented guibas mccreight roberts employ level linked trees order 
order achieve desired time bound log impose called regularity constraints search paths closely related segmented redundant number systems 
brown tarjan proposed simplify design level linked trees 
choice bases data structure number system resulting time bounds amortized worst case 
furthermore data structure handle arbitrary sequences insertions deletions efficiently 
deficiency overcome redundant number system 
change fact advocated mehlhorn base data structure level linked weak trees simplest weak trees trees 
level linked trees allow maintain arbitrary set dynamic fingers 
confines oneself static finger front rear simpler data structures may 
mehlhorn describes data structure similar introduced sec 

trees uses sequences avl trees 
details insertion quite complicated order achieve worst case bounds 
essence representation segmented number system digits drawn set 
avl trees offer slightly greater degree freedom trees successive heights may linked may added 
kaplan tarjan informally describe purely functional implementations finger search trees 
solutions numerical representations higher order nested datatypes double spine view superficially similar data structure sec 

implementation modelled recursive slowdown number system uses leaf oriented trees contain additional split keys conduct search 
due segmentation spines managed unit 
contrast data structure sec 
treats spines largely independent cons touches left spine 
second implementation separates spine lists uses digits 
unclear unbalanced situations spine list empty avoided 
implementation sketched uses level structural bootstrapping obtain double logarithmic concatenation time 
principle idea represent spine lists structures 
purely functional implementations random access lists originally leftist left complete leaf trees 
representation borges sec 
gives implementation haskell 
okasaki data structure binary numerical representation specifies regular sec 
non regular datatype sec 

binomial queues implemented times haskell king okasaki hinze 
formulation higherorder nested datatype original 
functional implementation trees due hoffmann donnell 
equational rewrite rules specify insertion rebalancing 
extended approach cover deletions 
interesting compare implementation nested datatypes 
uses extra constructors called put taken signal height subtree changed 
constructors elements datatype tree undermines type system turn complicates proof correctness sketched loc 
cit 
contrast separate types purpose 
furthermore nested datatypes structural invariants manifest 
establishes properties hand called subtype sets 
independent paterson defined trees order nested datatype 
insertion implemented higher order functions definition listify sec 

noted functional implementations priority queues support operations delete efficiently 
deficiency noted researchers 
king proposes combine priority queue set data structure bag records valid elements queue 
deletion works deleting element set 
unfortunately running times determined set operations preferable set data structure 
alternative approach suggested okasaki priority queues containing positive occurrences element containing negative occurrences 
deletion implemented insertion negative queue 
deletion remove element running times influenced complete history data structure 
hinze nested datatypes connelly morris generalized concept trie permit indexing elements arbitrary monomorphic datatype 
implementation generalized tries requires nested datatypes polymorphic recursion 
author extended approach arbitrary order polymorphic datatypes 
implementing tries places greater demands type system requires rank type signatures higherorder nested datatypes 
textbook functional data structures okasaki contains wealth examples order nested datatypes serve implementations sequence abstractions indexable sequences queues deques catenable deques 
unusual application nested datatypes bird paterson express de bruijn notation nested datatype 
companion furthermore show define fold operators called generalized folds order nested datatypes 
main contributions follows 
shown numerical representations nicely captured nested declarations 
contrast regular datatype nest express structural constraints data structure violations constraints detected compile time 
developing haskell code higher order polymorphism constructor classes proven value 
higher order nested datatypes cases preferable order nests allow connection container types element types explicit 
constructor classes turn simplify programming higher order nests building passing access functions mem ins del automatically implicitly 
part done scenes resulting code concise probably clearer 
main innovation data structural point view certainly purely functional implementation finger search trees appears best known functional data structure ordered sequences 
maintaining static finger front rear finger search trees support efficient access minimum maximum sequence 
furthermore insertions deletions cheap vicinity finger 
detail operations supported theta amortized time member insert delete theta log minfd gamma dg amortized time distance smallest element 
concatenation supported theta log minfn splitting theta log minfd gamma dg merge theta log amortized time size shorter size longer sequence 
finger search trees lazy number system bounds remain valid data structure persistent setting 
shown various adaptive sorting algorithms notably implemented functional setting sacrificing known time bounds 
conclude remarks expressibility nested declarations 
numerical representations higher order nested datatypes seen nested datatypes instance capture structure trees 
trees belong class balanced trees instances class brother trees ottmann wood trees red black trees guibas sedgewick equally easily encoded nested datatype 
balanced trees known avl trees adel son vel landis slightly elaborate scheme required 
idea maintain type parameters correspond avl trees successive heights 
data bin tree tree tree tree balanced tree tree tree tree data avl tree tree zero tree succ avl tree bin tree tree type ordsequence avl empty leaf note definition avl follows recursion pattern function generates infinite list fibonacci numbers called 
tree schemes shown expressible nested declarations include braun trees left complete trees paterson 
numerical representations fit particularly framework nested datatypes 
examples studied variations lazy binary number system 
binary system means compelling 
alternative choices definable nests include ternary quaternary number systems okasaki sec 
fibonacci number system knuth ex 

negative side nested datatypes expressive capture sparse segmented representations 
skew binary random access lists okasaki instance sparse representation 
briefly sparse representation digit represented explicitly weights successive digits may differ arbitrary amount renders implementation nested datatype impossible 
adams stephen 

functional pearls efficient sets balancing act 
journal functional programming 
adel son vel landis 

algorithm organization information 
doklady nauk sssr 
english translation soviet math 
dokl 
pp 

aho alfred hopcroft john ullman jeffrey 

data structures algorithms 
addison wesley publishing 
general binary tree called balanced node heights left right subtree differ hinze bird richard meertens lambert 

nested datatypes 
pages jeuring 
ed fourth international conference mathematics program construction mpc sweden 
lecture notes computer science vol 

springer verlag 
bird richard paterson ross 

de bruijn notation nested datatype 
journal functional programming 
appear 
bird richard paterson ross 

generalised folds nested datatypes 
submitted publication 
bird richard 

functional pearls building trees minimum height 
journal functional programming 
gerth st okasaki chris 

optimal purely functional priority queues 
journal functional programming 
brown mark tarjan robert 

design analysis data structure representing sorted lists 
siam journal computing 
carlsson levcopoulos christos petersson ola 

sublinear merging natural mergesort 
algorithmica 
clancy michael knuth donald april 
programming problemsolving seminar 
technical report cs tr 
stanford university department computer science 
connelly richard lockwood morris 

generalization trie data structure 
mathematical structures computer science 
victor anne 

simple efficient flexible implementation flexible arrays 
pages third international conference mathematics program construction mpc 
lecture notes computer science vol 

springer verlag 
dijkstra 

note problems connexion graphs 
numerische mathematik 
castro vladimir wood 

survey adaptive sorting algorithms 
acm computing surveys 
fahndrich manuel boyland john 
june 
statically checkable pattern abstractions 
pages proceedings acm sigplan international conference functional programming 
guibas leo sedgewick robert 

framework balanced trees 
pages proceedings th annual symposium foundations computer science 
ieee computer society 
guibas leo mccreight edward michael roberts janet may 
new representation linear lists 
pages conference record ninth annual acm symposium theory computing 
henglein fritz 

type inference polymorphic recursion 
acm transactions programming languages systems 
hinze ralf 

functional pearls explaining binomial heaps 
journal functional programming 
appear 
hinze ralf 
november 
generalizing generalized tries 
tech 
rept 
iai tr 
institut fur informatik iii universitat bonn 
hoffmann christoph donnell michael 

programming equations 
acm transactions programming languages systems 
scott mehlhorn kurt 

new data structure representing sorted lists 
acta informatica 
hughes john muir 

novel representation lists application function reverse 
information processing letters 
numerical representations higher order nested datatypes jones mark 

system constructor classes overloading implicit higherorder polymorphism 
journal functional programming 
jones mark 

functional programming overloading higher order polymorphism 
pages international spring school advanced functional programming techniques 
lecture notes computer science vol 

springer verlag 
kaplan haim tarjan robert may 
persistent lists catenation recursive slow 
pages proceedings seventh annual acm symposium theory computing 
kaplan haim tarjan robert may 
purely functional representations catenable sorted lists 
pages proceedings eighth annual acm symposium theory computing 
king 

functional binomial queues 
hammond turner sansom 
eds glasgow functional programming workshop 
ayr scotland springer verlag 
knuth donald 

art computer programming volume fundamental algorithms 
rd edn 
addison wesley publishing 
hughes john launchbury john 

implementing strictness analysis 
kehler holst carsten wadler philip eds functional programming glasgow proceedings workshop isle 
workshops computing 
london springer verlag 
mannila heikki 

measures presortedness optimal sorting algorithms 
ieee transactions computers 
mehlhorn 

algorithmen 
stuttgart germany teubner 
mehlhorn kurt 

sorting files 
pages proceedings th gi conference theoretical computer science 
lecture notes computer science 
springer verlag 
mehlhorn kurt 

data structures algorithms multi dimensional searching computational geometry 
berlin springer verlag 
milner robin 

theory type polymorphism programming 
journal computer system sciences 
moffat petersson 

overview adaptive sorting 
australian computer journal 
moffat petersson wormald 

sorting merging finger trees 
pages isaac rd international symposium algorithms computation vol 

mycroft alan 

polymorphic type schemes recursive definitions 
paul robinet 
eds international symposium programming th colloquium toulouse 
lncs 
okasaki chris 

amortization lazy evaluation persistence lists catenation lazy linking 
pages th annual symposium foundations computer science focs 
los alamitos ieee computer society press 
okasaki chris 

purely functional random access lists 
pages proceedings seventh international conference functional programming languages computer architecture fpca 
la jolla california acm press acm sigplan sigarch ifip wg 
okasaki chris 

simple efficient purely functional queues deques 
journal functional programming 
okasaki chris 

functional data structures 
pages second international summer school advanced functional programming techniques 
lecture notes computer science vol 

hinze okasaki chris 
may 
role lazy evaluation amortized data structures 
pages acm sigplan international conference functional programming 
okasaki chris 
june 
catenable double ended queues 
pages proceedings acm sigplan international conference functional programming 
acm sigplan notices august 
okasaki chris 

purely functional data structures 
cambridge university press 
ottmann wood 

brother trees avl trees revisited 
computer journal 
paterson ross 
april 
control structures types 
ftp santos doc ic ac uk pub papers paterson folds dvi gz 
paterson ross 
october 
private communication 
paulson 

ml working programmer 
nd edn 
cambridge university press 
peterson hammond march 
report programming language haskell non strict purely functional language 
research report yaleu dcs rr 
yale university department computer science 
peyton jones simon jones mark meijer erik 

type classes exploration design space 
haskell workshop 
prim 

shortest connection networks generalizations 
bell systems technical journal november 


balanced trees removals exercise rewriting proof 
science computer programming 
snyder lawrence 

uniquely represented data structures extended 
pages th annual symposium foundations computer science providence 
long beach ca usa ieee computer society press 
vuillemin jean 

data structure manipulating priority queues 
communications acm 
