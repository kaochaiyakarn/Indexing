tail recursive secd machine john mitre january method producing verified implementations programming languages formally derive machines 
tail recursive machines provide cient support iterative processes ordinary procedure call mechanism 
document argues tail recursive machines incurs small increase theorem proving burden compared required ordinary machines 
position supported comparing correctness proofs performed theorem prover 
product ort syntactic criterion tail contexts identifying procedure calls implemented tail calls 
concept tail contexts latest scheme report language specification known author defines requirement implementations tail recursive 
keywords tail recursion tail call secd machine cek machine verified implementation boyer moore theorem prover 
kluwer academic publishers 
definitive version appears journal automated reasoning july 
author address mitre burlington road bedford ma 
email mitre org 
document reflects views author statement views mitre 
tail recursive secd machine programming languages provide special syntax specification iterative processes 
space consumed execution iterative construct easily understood 
space bounded independent number iterations executed 
programming languages rely procedure calls express iterative processes 
languages space call chains built carefully selected procedure calls bounded independent number calls chain 
implementation programming language provides kind space bound called tail recursive 
tail recursive implementation programming language di ers implementation performs tail call optimizations 
tail recursive implementation programmer rely fact procedure calls occur certain syntactic contexts implemented tail calls 
implementing calls tail calls optional optimization correctness requirement implementations 
new programming styles available programmers tail recursive implementations 
example continuation passing style cps nearly procedure completes calling procedure required implemented tail call 
running programs written continuationpassing style implementations fail meet requirement quickly run space 
programming languages require implementations tail recursive scheme programming language prime example 
written requirement scheme expressed solely paragraph page ieee scheme standard implementations scheme required properly tail recursive 
allows execution iterative computation constant space iterative computation described syntactically recursive procedure 
tail recursive implementation iteration expressed ordinary procedure call mechanics special iteration constructs useful abbreviations 
notice requirement describes properties tail recursive implementations defines notion 
scheme implementors tail recursive secd machine able identify tail recursive implementation see experienced scheme programmers able identify procedure calls construct iterative processes tail recursive implementation 
time document revised scheme community added text fifth revision scheme report 
pages clearly define requirement implementations tail recursive 
formal definition requirement 
document argues tail recursive machines incurs small increase theorem proving burden compared required ordinary machines 
position supported comparing correctness proofs performed boyer moore theorem prover 
product ort syntactic criterion tail contexts identifying procedure calls implemented tail calls 
concept tail contexts latest scheme report 
syntactic criterion identifying tail calls follows naturally study tail recursive machines 
machines lambda value calculus objects studied 
years ago gordon plotkin published famous examines relation lambda calculus iswim programming language lambda calculus 
iswim operational semantics secd machine 
includes proof semantics defined secd machine equivalent recursively defined function implements applicative order evaluation lambda terms 
order bodies lambda terms evaluated arguments combinations evaluated substituted 
plotkin variation lambda calculus produces theory naturally defines computations secd machine 
calculus enriched constants delta rule models actions primitives iswim 
terms may substituted restricted terms combinations 
restriction substitution matches requirement arguments combinations evaluated substituted 
result called lambda value calculus plotkin called terms combinations values 
secd machine tail recursive 
application function argument causes push information dump secd machine equivalent control stack 
secd machine implements tail recursive secd machine caller saves convention means callee free sec stack environment code part secd machine state 
document presents tail recursive secd machine tr secd 
ways defining tr secd machine 
tr secd machine implements callee saves convention means callee ensure return caller results restoration sec part tr secd machine 
version tr secd machine motivated scheme byte code 
orts aimed formally deriving cient implementations programming languages produce implementations tail recursive 
start secd machine start categorical machine 
motivation show tail recursive machines results implementations ciently handle iterative processes modest increase theorem proving burden 
support thesis provided presenting fully automated correctness proofs 
proof shows recursively defined evaluation function lambda value calculus equal evaluation function defined secd machine 
second proof shows recursively defined evaluation function equal evaluation function defined tr secd machine variation secd machine tail recursive 
study proofs shows correctness proof tr secd machine slightly complex secd machine 
correctness proof performed boyer moore theorem prover nqthm 
logic boyer moore theorem prover order system provides extensive support recursively defined total functions inductive proofs 
tr secd machine transition rules combinations called tail combination rule iterative computations 
requirements imposed proofs boyer moore logic lead correctness proof tr secd machine shows grammar naturally identifies tail combinations 
point explained body document 
document gives high level description correctness proofs secd machines 
describes encoding descriptions logic boyer moore theorem prover compares relative tail recursive secd machine di proofs 
implications proof grammar identify tail combinations 
grammar shown identify tail combinations related tail recursive machine called cek machine 
application ideas identifying tail calls scheme discussed 
lambda value calculus notation document follows plotkin 
inductive definitions sets replaced context free grammars 
set defined grammar language generates 
metavariable decorated bar stands syntactic category grammar set defined 
notation terms due de bruijn 
proofs notation preferable standard element set terms standard notation di er change bound variables corresponds single term de bruijn notation 
set terms determined set variables disjoint set constants improper symbols 
de bruijn notation variable positive integer 
set syntactic category constants variables respectively 
set terms defined term form abstraction form mm combination 
set values set answers lambda value calculus reduction rules 
rule corresponds function application rule defines actions primitives 
actions partial function maps pair constants closed term 
rule mv subst result substituting value variable subst 
definition substitution de notation figures 
definition came directly mechanical proof church rosser theorem boyer moore theorem prover described section 
tail recursive secd machine subst terms values variables terms subst subst subst bump subst subst subst subst mm subst subst de bruijn substitution subst section shankar book contains careful explanation de bruijn notation 
bump terms naturals terms bump bump bump bump bump bump mm bump bump de bruijn substitution bump secd machines theorem plotkin states function eval defines semantics iswim programs identical defined secd machine 
section presents definitions needed theorem 
definitions di er plotkin reasons correctness proof factored stage verifies correctness environments substitution stage verifies correctness control structures 
tail recursive secd machine eval terms answers eval eval eval mm eval subst eval eval eval mm eval eval evaluation function addition terms objects manipulated secd machine grammar closures nil stacks nil environments ret call code halt dumps term represented closure function real uses auxiliary function butt 
easily shown function real produces answer applied closure 
real terms environments terms real nil real real subst butt real butt terms environments terms butt nil butt bump butt secd machine presents function step transition function secd machine 
tail recursive secd machine step dumps dumps step ret step lookup step nil step step call nil ret step call nil step mm call secd machine function step uses function lookup find closure associated variable 
lookup variables environments closures lookup lookup lookup run secd machine produces answer accepting state detected 
function run undefined reaches error state fails reach accepting state reason 
run dumps answers run ret halt real run run step correctness proof correctness secd machine expressed follows theorem correctness closed term eval run nil nil ret halt 
important lemmas prove theorem follow 
control complexity proofs correctness proof factored stage verifies correctness environments substitution tail recursive secd machine stage verifies correctness control structures 
shows evaluation function substitution replaced environment extension 
reduce terms environments closures reduce nil reduce reduce lookup reduce mm reduce reduce reduce reduce mm nil reduce reduce reduction function lemma gives key property associated replacement substitution environment extension 
lemma substitution real subst real real 
terms naturals booleans true mm bound predicate analog answer called answer closure 
defined terms answer environments 
definition answer environment answer environment defined inductively 

nil answer environment tail recursive secd machine 
answer environment length answer environments 
term said closed environment answer environment length 
closure said answer closure closed lemma ends stage proofs verifies correctness environments substitution 
lemma reduction assume answer environment term closed eval real undefined reduce undefined 
eval real real reduce 
reduce answer closure 
stage verifies correctness control structures consists main lemmas 
lemma adequacy value environment term closed reduce defined run run reduce 
lemma faithfulness value environment term closed reduce defined run defined 
proof theorem cases 
closed term reduce nil defined run nil nil ret halt run reduce nil nil nil ret halt lemma real reduce nil function run eval real nil lemma eval function real closed term reduce nil defined lemma lemma apply 
tail recursive secd machine tr secd machine objects manipulated tr secd machine di er fact code sequences di er 
tr secd machine code may follow call symbol 
ret call code function step transition function tr secd machine 
notice clauses identical ones define secd transition function 
step dumps dumps step ret step lookup step nil step step call ret step call nil ret step mm ret call step mm nil call ret tail recursive secd machine code combination clauses may apply 
clause pushes dump name push dump combination rule name penultimate clause tail combination rule 
tr secd machine iterative processes produced computations tail combination rule 
statement correctness theorem supporting lemmas remains unchanged exception adequacy lemma 
lemma tr secd adequacy value environment term closed reduce defined run run reduce ret function defined 
tail recursive secd machine terms environments booleans environments mm true true reduce reduce mm true reduce reduce mm false run environment function boyer moore theorem prover logic boyer moore theorem prover nqthm quantifier free order logic recursive functions 
lack quantifiers handled replacing existentially quantified variable function produces witness 
functions proofs total functions preceding sections partial 
partial functions extended total functions adding clauses produce error value distinct ordinary values 
zero default value nqthm usually selected error value encoding descriptions nqthm 
example function lookup total returning zero function positive integer variable 
special status zero nqthm part reason variables encoded positive integers natural numbers expect 
extension function eval total 
function ev 
function eval defined ev answer natural number furthermore eval ev ev answer 
statement correctness theorems includes implicit quantification functions certain properties 
boyer moore theorem prover constrain event suited task 
lack support partial functions boyer moore theorem prover think theorem prover better tail recursive secd machine ev terms naturals answers ev ev ev ev mm ev subst ev ev ev mm ev ev total evaluation function job 
boyer moore theorem prover ability find inductive proofs exploited proofs lambda calculus taken verbatim proof church rosser theorem comes theorem prover 
proof correspondence lambda calculus standard notation de bruijn notation part church rosser proof 
boyer moore proofs proofs divided topics 
section defines terms de bruijn notation substitution evaluation 
second section defines total function reduce procedure create ev eval concludes proof substitution lemma reduction lemma 
sections proof identical 
third section defines secd machine 
tr secd machine defined transition function step original secd machine defined transition function step 
encoding function run maps dump natural number dump 
natural number called step count 
run dumps naturals dumps run run run step fourth section defines timed version total function reduce 
function yields closure step count required tail recursive secd machine compute closure 
major lemma section timed reduction lemma establishes closure produced timed reduction function produced reduce 
tr secd machine version timed reduction slightly complex original secd machine version step count di ers depending rule combination 
combination rules clauses transition function step 
fifth section contains proof tr secd secd adequacy lemma 
sixth final section contains proof faithfulness lemma 
comparison proofs di erences correctness proofs machines put categories 

function definitions di er account tr secd machine 
function defining transition function function defining timed reduction examples 

hints tell theorem prover perform complex inductions di er ones tr secd machine require additional cases tail calls 
understanding machines definition hints straightforward 

occasionally functions counterpart required correctness proof 
function example 
required definition functions obvious 
di erences inputs theorem prover large di erence number cases examined theorem prover large 
fact reflected cpu time performing proofs 
correctness proof tr secd machine requires roughly cpu time proof secd machine 
theorem prover easily handles extra cases cases take substantial amount additional time 
authors nqthm suggest proofs di cult theorems decomposed proofs small lemmas order control theorem tail recursive secd machine cpu time minutes lemma tr secd secd reduction adequacy timed reduction entire proof table proof times prover 
authors state theorem prover kept short leash chapter 
particular time theorem prover allowed spend long time proving lemma 
secd tr secd proofs organized setting proof time consuming lemmas 
proofs reduction adequacy timed reduction lemmas minute cpu time mhz 
pentium pro pc running linux 
table gives cpu time required prove selected lemmas 
readers experience boyer moore theorem prover invited read file events tr secd secd correctness proofs 
section adequacy lemma succinctly provides support thesis 
proofs tail recursion proofs adequacy lemmas reveals intuition calling tr secd machine tail recursive 
machines ret rule way reduce depth dump 
secd machine dump pushed call abstraction rule 
specifying details secd adequacy lemma finds call abstraction rule matched ret rule 
tr secd machine call abstraction rule push dumps 
combination rules pushes dumps 
expect proof tr secd adequacy lemma reveals push dump combination rule matched ret rule 
recall timed reduce function produces pair consisting closure step count 
step count assigned combination timed reduce function tr secd machine depends combination rule tail recursive secd machine 
function uses additional parameter encode information 
avoid extraneous details associated computing step counts timed reduce function returns just closure presentation 
key clause displayed 
reduce terms environments booleans closures 
reduce mm reduce true reduce false reduce false boolean parameter compute step count closure computed timed reduce function depend parameter 
change adequacy lemma simple 
lemma timed tr secd adequacy value environment term closed reduce ret defined run run reduce ret ret 
proof lemma clear reduce applied combination tail combination rule boolean parameter true push dump combination rule 
form definition function reduce allows stronger statement selection combination rules 
combination rule combination term determined simple analysis term 
grammar partitions combinations categories 
tail combinations marked angle brackets push dump combinations retain original syntax combinations 
tail combinations values push dump combinations values values marked terms added structure reduction function reduce marked terms environments booleans closures 
reduce uu true reduce true reduce false reduce false reduce uu false reduce true reduce false reduce false tail recursive secd machine expected reduce applied tail combination boolean parameter true reduce applied push dump combination boolean parameter false 
terms marked boolean parameter timed reduce function redundant step count values depend boolean parameter 
tail combinations identified grammar play distinguished roles works 
example presents cps transform treats tail combinations specially 
contexts provide alternative grammar identifying tail combinations 
combination context term hole replaced combination 
set combination contexts defined term results substituting combination mm hole context mm 
proper subset combination contexts set set tail contexts term tail combination tail context push dump combination 
tail contexts motivate form proposed text identifying tail calls scheme section 
cek machine adequacy proof tr secd machine shows simple syntactic analysis needed identify combination rules applicable combination 
focus section tail recursive machine distinguish types combinations careful analysis machine shows distinction important 
cek machine similar secd machine closer denotation semantics iswim 
states machine triples composed term environment continuation code represents tail recursive secd machine remainder computation 
defines cek machine assuming terms unmarked 
halt fun arg continuation code cek state cek state cek state mm fun fun arg arg arg nil lookup cek states answers halt real cek machine results prove cek correctness theorem 
theorem cek correctness closed unmarked term eval nil halt 
tail recursion hint cek machine distinguishes types combinations comes studying relation tr secd machine 
tr secd machine runs produce value prescribed initial state length stack greater 
result tr secd machine pushes dumps forms nil call nil call forms correspond continuing evaluating function continuing applying function value argument value ways continuing cek machine 
tr secd machine rule tail recursive secd machine push dump combinations means increasing depth dump 
transitions involving push dump combinations way cek machine increases measure depth continuation code 
trick showing cek machine distinguishes types combinations marked terms marked continuation codes 
mark continuation behaves identity continuation added 
halt mark marking codes fun arg combination codes continuation codes notice continuation mark code combination code continuation combination code marking code 
result mark code separates pair combination codes 
depth continuation code number mark continuations contains 
marked cek state marked cek state uu fun uu fun mark fun arg arg arg nil lookup mark marked cek machine transition function cek machine uses marked terms marked continuation codes 
state marked cek machine tail combination marking continuation state push dump combination combination continuation 
tr secd machine depth continuation code increased push dump combination rule 
marked cek machine iterative processes produced computations tail combination rule 
erasing marks marked cek machine produces original cek machine 
implication cek machine treats kinds tail recursive secd machine combinations di erently rule kinds combinations 
particular push dump combinations lead unbounded growth depth continuation code 
boyer moore proof attempts cek tr secd machines tail recursive cek machine advantages 
transition function fewer rules manipulates fewer classes objects 
features lead reduction number cases required automated proofs 
tr secd machine similar machines project project produced verified implementation scheme programming language sense algorithms implementation formally verified 
author contributed ort tr secd machine natural starting point 
furthermore tr secd machine natural starting point ort refine implementation verified algorithm level verified code level 
lucky tr secd machine chosen 
attempts produce nqthm correctness proof cek machine form produced secd machines failed 
adequacy lemma equation 
inductive proof involves case combinations function part reduces lambda term 
case induction hypotheses evaluation argument evaluation function application lambda term argument value 
hypotheses order 
proof tr secd adequacy lemma nqthm options hypotheses correct order 
existence ret rule impossible reverse order 
attempts author prove cek adequacy lemma failed nqthm chose induction hypotheses reverse order 
elegance cek machine increases opportunities wrong step large step nature proof hard construct required constraint theorem prover 
tail recursive secd machine scheme tail recursion section relates previous 
programming language scheme subject relevant section 
follows simplification scheme syntax scheme related results 
syntax core scheme set 

lambda 
syntactic category scheme constants syntactic category identifiers 
grammar partitions scheme procedure calls categories specified production rules 
start symbol set 

set 

lambda 
syntax defined original syntax procedure calls generated delimited angle brackets 
marked procedure calls tail calls 
mitchell wand grammar form produce syntax directed compiler tail recursive omitting push stack frame compiling tail calls 
syntactic approach identifying tail calls 
presents set source source reduction rules transform core scheme called normal form intermediate representation compilers 
procedure calls naturally partitioned classes transformed normal form 
appears set procedure calls transformed form tail calls set procedure calls marked formal proof attempted observation provides support proposition 
core scheme expression may translated normal form sequence reductions 
evaluation context identify expression reduction applies 
scheme expressions marked grammar easy see reductions apply non value expressions generated syntactic category furthermore reductions transform procedure calls generated normal form calls tail calls 
tail recursive secd machine di erent orts identified set procedure calls expression tail calls 
orts include correctness proofs tail recursive machines tail recursive cps transformations tail recursive syntax directed compilers transformation normal form 
time programming language definitions require implementations identifying tail calls specifying constraints may implemented 
tail calls identified grammar tail contexts section suggest better method 
tail contexts naturally suggest surrounding procedure call occurs determines tail call 
scheme program goal identify subexpressions surround tail calls 
name subexpressions tail contexts 
inductive definition gives subexpressions tail contexts scheme program expression tail context expression form lambda 
occurs expression tail context expression form tail context ones 
expression form 
tail context tail call 
served motivation author request new revision scheme report include text clearly defines requirement implementations tail recursive 
time document revised scheme community added text uses tail contexts identify procedures implemented tail calls 
furthermore william clinger gave formal definition requirement 
tail recursive machines provide cient support iterative processes ordinary procedure call mechanism 
document showed tail recursive machines incurs small increase tail recursive secd machine theorem proving burden compared required ordinary machines 
position supported comparing correctness proofs performed boyer moore theorem prover 
careful study correctness proof tail recursive machines resulted method identifying tail calls tail contexts 
method intuitive easily understood 
document substantially improved result correspondence profs 
matthias felleisen william clinger robert boyer 
joshua guttman provided valued detailed comments improved document 
barendregt 
lambda calculus syntax semantics 
north holland amsterdam revised edition 
robert boyer strother moore 
computational logic handbook 
academic press 
william clinger 
scheme compiler exercise denotational semantics 
acm symposium lisp functional programming pages new york august 
association computing machinery william clinger 
proper tail recursion space ciency 
acm sigplan notices may 
proc 
sigplan conference programming language design implementation 
olivier danvy andrzej filinski 
representing control study cps transformation 
mathematical structures computer science december 
felleisen friedman 
control operators secd machine lambda calculus 
wirsing editor formal description programming concepts iii pages 
elsevier science publishers 
north holland amsterdam 
tail recursive secd machine cormac flanagan amr sabry bruce duba matthias felleisen 
essence compiling continuations 
acm sigplan notices june 
proc 
sigplan conference programming language design implementation 
brian graham 
secd machine verification case study 
secs 
kluwer publishers dordrecht 
joshua guttman mitchell wand eds 
verified implementation scheme 
kluwer academic publishers dordrecht 
contents identical lisp symbolic computation vol 
nos 
special double issue devoted results 
john hannan 
making machines 
hughes editor lecture notes computer science volume pages 
springer verlag 
proc 
th acm conference function programming languages computer architecture 
ieee std 
ieee standard scheme programming language 
institute electrical electronic engineers new york ny 
richard kelsey william clinger jonathan rees editors 
revised report algorithmic language scheme 
higher order symbolic computation 
gordon plotkin 
call name call value calculus 
theoretical computer science 
john 
secd events 
nqthm event file september 
ftp ftp cs utexas edu pub boyer nqthm secd events 
john 
tr secd events 
nqthm event file september 
ftp ftp cs utexas edu pub boyer nqthm events 
shankar 
metamathematics machines proof 
cambridge university press revised edition 
mitchel wand 
correctness procedure representations higher order assembly language 
brookes main melton mislove schmidt editors lecture notes computer science volume pages 
springer verlag 
mathematical foundations programming semantics 
