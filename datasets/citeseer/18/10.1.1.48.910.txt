version control system talk 
thomas ball jung min kim adam porter harvey bell laboratories dept computer sciences bell laboratories lucent technologies university maryland lucent technologies research bell labs com cs umd edu research bell labs com version control systems store reconstruct past versions program source code 
product capture great deal contextual information change 
illustrate ways information better understand program development history 
software metrics may assess state software system 
example mccabe halstead software complexity metrics measure aspects structure static snapshot source code estimate complexity 
measuring metrics change time hope identify decaying components software system restructured may reduce development effort needed maintain extend system 
analyses depend ability recreate snapshots software different points time 
version control system vcs tracks change developer system result recreate consistent snapshot point time 
examples include rcs sccs 
basic functionality essential version control measuring evolution metrics time data vcs ignored simply extract snapshots source code 
examine rich structure version control data show analysis version control data illuminate software development process new ways 
vcs tags change substantial amount additional contextual information 
knowing code changed changed change yield valuable insights went course code development better requirements software process implementation technology developers version control history version control history captures interactions various aspects software development 
developers memories 
vcs data amenable completely automated analysis just snapshot source code amenable metric analysis 
software development organizations employ form vcs 
methods outline wide applicability software projects 
framework data vcs referred version control history addition source code explore relationships various aspects software development 
example requirements software implementation technology development process followed organization developers effect software evolved 
illustrates idea 
characteristics particular view software development constraints impact 
thesis interactions views impact efficient production software version history data captured vcs provides starting point exploring relationships 
particular example examine interesting relationships requirements optimizing compiler implementation technology desire developers parallel 
examine relationships visualizations automatically generated vcs data 
version control data simplified description basic data collected vcs 
operate set files containing text lines source code 
atomic change program text captured recording lines deleted added order change 
information usually computed file differencing algorithm unix diff compares previous version file current version 
change associated file changed time change recorded vcs name login id programmer minimum 
order change software system developer may modify program entities files 
ability track group related changes modification record captures fact changes specific purpose semantically related 
may english associated developer provides describing purpose change 
may data opening time closing time status information approved rejected 
set atomic changes atomic change associated 
line text source code snapshot associated time change developer name login related data 
analyzing source code identify functions classes program entities associate vcs data entities source lines 
project study brief overview project study 
details may ladd 
ess tm lucent technologies local toll switching system containing estimated lines code product support tools 
heart ess software distributed relational database information hardware connections software configuration customers 
switch function properly data conform certain integrity constraints 
logical constraints example call waiting call forwarding busy active line 
constraints exist document data design choices redundancy functional dependencies distribution rules support efficient ess operation call processing 
prl declarative sql language created specify data integrity constraints 
prl specifications translated automatically data audits transaction guards compiled multiple platforms 
due constantly changing integrity constraints provided different communication service providers worldwide compilation speed crucial 
generated code optimized disk accesses possible 
compiler prl called cc prl compiler developed 
compiler follows traditional compiler structure includes lexing parsing semantic type checking optimization code generation phases 
lexing parsing phases produce syntax tree ast phases operate 
compiler project chosen study views ffl requirements 
build optimizing compiler declarative sql language ffl developers 
team developers coordinate ffl implementation technology 
language ffl software process 
components built parallel 
insights compiler development cc compiler written approximately classes 
multiple inheritance class inheritance relationship tree structured 
approximately classes small stub classes generated macros 
partitioned classes basic groups excluding miscellaneous support classes ffl top top level classes 
classes directly related language entity primarily base classes ffl symtab symbol table classes representing prl language construct type ffl ast syntax tree ast classes ffl optim classes apply optimization transformations syntax tree ffl quads code generation classes modification cc compiler recorded vcs known extended change management system 
analysis 
class computed modified 
shows inheritance hierarchy cc classes 
area node proportional log number modified corresponding class 
node shown touching quad indirect class inheritance hierarchy cc compiler size node proportional log number touch class 
shape node represents class group follow top diamonds symtab unfilled square ast filled circle optim unfilled circle quads filled squares 
reason number quads classes small classes generated macros modified hand 
clear change activity related ast 
keep mind ast code simply maintain tree data structure 
member functions ast classes responsible compilation phases type checking code generation imperative language encapsulate type checking module takes ast input traverses perform type checking 
object oriented language function type checking naturally expressed method ast classes 
cc compiler member functions ast classes divided files functionality 
example member functions type checking particular set files member functions code generation file set 
left panel clear seesoft code visualization 
rectangle represents file compiler 
files containing code ast classes shown 
class level gray gray scale spectrum left line file colored show class belongs 
clear picture file contains code classes 
note example files containing gray scale spectrum 
files group members functions different classes ast constitute particular phase compiler type checking code generation 
reason divide classes files functionality 
centralizing functionality set classes impede concurrent development 
splitting member functions class different files different programmers different aspects compiler 
right panel shows programmers worked files 
data derived owned exactly programmer code traced individual 
clear certain programmers ownership particular aspects compiler ast classes files accumulated modifications programmers 
partitioning illustrates complex relationships views examining 
example compiler literature suggests prototyping new programming language useful implement compiler phases member functions ast class 
add new language constructs simply adds new classes set ast classes 
hand mature language useful implement compiler phases modules transform operate data type representing ast 
easier add new optimizing passes compiler 
prl changing compiler development oo approach appear sense inheritance hierarchy acts built switch statement virtual functions help avoid writing identical functions classes inheritance hierarchy 
developers assignments mimic second approach 
developer implemented specific compiler phase ast classes 
compiler phases incorporated member functions ast classes development member functions similar functionality grouped separate files 
goal research better understand effect development decisions evolution software systems 
section discuss preliminary approaches analyzing relationship development approaches system change history 
date subject inspect class values lines files subject subject subject subject subject subject date subject subject inspect class values lines files seesoft views files comprising syntax tree classes cc compiler 
view left class maps level gray gray scale spectrum left line file colored class belongs 
view right shows set files line file colored programmer programmers 
quad cluster analysis classes relationships 
node representing class colored group class color shape 
nodes closer joined links higher probability 
clustering analysis defined class groups 
cluster analysis classes modification way help understand effects development decision system evolution examine system change history 
example describe initial explorations class structure system encapsulated changes 
class cmr number touch class unique classes number touch classes defines relationship classes translates link graph nodes classes 
probability measure associated link classes modified link probability cmr dmr case 
rarely modified comparison total number modifications link probability low 
generated data current version cc compiler ran graph clustering algorithm places nodes connected links higher weight closer 
probability measure described link weighting 
details algorithm see 
shows resulting graph 
node rep resents class 
shape node denotes group class belongs 
note clustering algorithm identified clusters semantically related classes 
fact identified basic partitions described earlier 
cluster round filled nodes lower left ast classes cluster white square nodes right symtab classes 
cluster upper left optim group 
group filled square nodes symbol table cluster represents quads group 
example links classes different groups probabilities group higher probability 
shows changes ast classes involved changes optim symtab groups 
expected links optim symtab groups 
initial analysis currently examining types changes classes hierarchy 
mainly changes involving member function different classes argues class partitioning effective 
addition examining similar views file partitioning 
summary thesis research version control systems contain significant amounts data exploited study system evolution 
illustrated ways information 
particular derived vcs related metrics connection strength probability classes modified 
metric assess effect implementation decisions evolution resulting software 
clearly initial stages 
currently exploring extensions 
ffl time series analysis 
metric single snapshot system 
little explored metrics capture structure changes long periods time 
ffl improved analysis models 
implicitly treats aspects change history dependent variables aspects development history independent variables 
initial looked variables 
example looked number changes class dependent variable 
ongoing refine variable looking type changes change effort change approved 
examine complex changes involve multiple developers multiple classes multiple functions 
ffl examining development processes 
examine issues related development process 
example defects discovered inspection different nature discovered testing 
look effect development decisions criteria development interval 
ffl improved visualization techniques 
visualizations show obviously static 
inherently interested system behavior time expect visualizations improve capture 
possibilities include trellis displays animation 
ffl static program analysis 
change history provides information different parts system related 
information may useful automatic restructuring 
ball eick 
software visualization large 
ieee computer april 
william cleveland 
visualizing data 
hobart press 
stephen eick graham wills 
navigating large networks hierarchies 
visualization conference proceedings pages san jose california oct 
maurice halstead 
elements software science 
elsevier north holland 
david ladd christopher 
software research switch software 
international conference communications technology beijing china 
david ladd christopher 
application languages software production 
usenix symposium high level languages oct 
thomas mccabe 
complexity measure 
ieee trans 
software engineering dec 
martin odersky philip wadler 
pizza java translating theory practice 
conference record acm symposium principles programming languages pages paris france jan 
marc 
source code control system 
ieee trans 
software engineering se december 
walter tichy 
design implementation evaluation revision control system 
proceedings th international conference software engineering pages tokyo japan sept 
