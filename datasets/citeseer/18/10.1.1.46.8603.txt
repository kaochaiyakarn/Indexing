patterns generate architectures kent beck class software ralph johnson university illinois urbana champaign need ways describe designs communicate reasons design decisions just results 
design patterns proposed ways communicating design information 
shows patterns derive architecture problem statement 
resulting description easier understand purpose various architectural features 
design hard 
way avoid act design reuse existing designs 
reusing designs requires learning parts communicating complex designs hard 
reason existing design notations focus communicating designs completely ignore 
design crucial customizing particular problem 
need ways describing designs communicate reasons design decisions just results 
approach improving design currently receiving interest primarily outside object community idea architecture garlan 
architecture way parts 
way architectures notated applied discovered topics active research 
closely related idea inside object community framework deutsch johnson 
framework reusable design system part system expressed set classes way instances subclasses classes collaborate 
frameworks particular way representing architectures architectures expressed frameworks 
ideas overlap 
attempts reuse design examples examples 
approach design object community patterns 
oopsla workshops architecture handbook anderson ones patterns coad overlap groups shows link architectures patterns 
patterns focuses authors addresses kent beck class software box boulder creek ca mail com ralph johnson department computer science springfield ave urbana il mail johnson cs uiuc edu ecoop patterns relationships objects building blocks larger architectures coad gamma 
original interest patterns sparked architect christopher alexander patterns encode knowledge design construction communities buildings alexander alexander 
word pattern takes meaning usual dictionary definition 
alexander patterns description recurring pattern architectural elements rule create pattern 
recurring decisions experts written skilled 
describe design simple description set relationships objects 
call patterns alexander describe pattern applied generative patterns 
generative patterns share advantages non generative patterns provide language designers easier plan talk document designs 
added advantage easier non experts providing rationale design fact 
focuses advantage 
shows patterns derive architectures mathematical theorem proved set axioms 
patterns way illuminate motivate architectures 
deriving architecture patterns records design decisions way 
easier modify architecture circumstances change 
patterns kinds patterns needed derive hotdraw object oriented design patterns graphics patterns 
probably typical architectures patterns generic specific application domain 
pattern follows format preconditions patterns satisfied valid 
sequence patterns considered important skills possessed experts 
problem summary problem addressed pattern 
problem statement reader decide pattern applicable 
constraints constraints describe conflicting mutually exclusive forces acting solution problem 
typical examples tradeoffs execution time execution space development time program complexity 
clearly stating priorities constraints patterns easy debate 
solution sentence summary solution problem 
solution accompanied diagram illustrating activity required transform system doesn satisfy pattern 
graphics patterns model view controller collect damage update user speed 
patterns editor design pattern catalog gamma 
versions patterns differ versions catalog ways 
obvious difference versions shorter necessity preference 
fully expressed pattern contains pages discussion constraints illustration example showing works 
difference versions generative versions catalog 
words emphasize conditions pattern applies transformation causes design comes existence 
patterns catalog entirely ignore applicable intent similar problem patterns 
list possible causes general focus solution variants solution 
rewritten patterns catalog generative reason believe couldn 
example generative pattern object oriented software objects states says transform object changes behavior depending state objects invariant parts original object family objects refer state original object 
hotdraw architecture derived hotdraw framework structured graphics editors 
previous set patterns hotdraw johnson 
contrast describes patterns create hotdraw 
patterns levels derived level considered basic pattern level 
hotdraw provides reusable architecture direct manipulation graphics editor applications implemented smalltalk 
versions implemented environments pattern depends environment chooses user interface framework lot commonality userinterface frameworks versions similar 
supports kinds figures drawing programmable palette tools different handles different figures smooth animation typical graphics editor palette figures handles figures 
describes hotdraw top proof theorem 
gives reasons design decisions hotdraw parnas says original reasons design decisions parnas 
derivation hotdraw hotdraw partly related history design 
purpose derivation show people hotdraw developed understand 
people usually start framework modifying examples recombining components different ways experts need deeper understanding framework 
believe derivation reflects understanding expert 
deriving hot draw describing architecture patterns process cell division specialization drives growth biological organisms 
design starts fuzzy cloud representing system realized 
patterns applied cloud parts come focus 
patterns applicable design finished 
step discussion briefly describe problem needs solved pattern solve effect pattern design 
user interface problem solve getting drawing screen displayed manipulated 
pattern tells need divide responsibilities objects 
model view controller krasner preconditions system going graphical user interface 
problem graphical user interfaces hard build 
users demand programs easy easy learn powerful user interface necessary achieve goals 
responsibilities implementing user interface divided objects 
constraints modern graphical user interfaces small number recurring visual elements 
user interfaces need consistent depend interaction techniques menus buttons scroll bars lists 
effort puts learning program part program apply programs parts program 
implementing user interface strike balance design uses objects difficult learn uses objects sacrifices flexibility 
important axis flexibility information displayed 
second axis flexibility independent display interpreting user gestures mapping state changes 
third degree freedom ability put multiple user interfaces information 
solution divide system objects model view controller 
model responsible maintaining state surfacing behavior necessary support user interface 
view responsible displaying date version model 
controller responsible mapping user gestures changes state model 
applying model view controller system derive objects drawing hold drawing display parse user gestures changes drawing 
elements drawing notice drawings need contain figures 
leads composite pattern 
composite preconditions composite object object components folder consists set documents book consists set chapters consists set departments 
problem naive modeling composite objects leads similar classes specialized primarily types components 
constraints consider text editing system chapter section subsection paragraph word item large number classes really just collection components 
titles start new page general quite similar 
hand composite object obviously different components 
hand easier reuse understand design minimizes number classes making classes polymorphic composable combination 
don want text element list components atomic 
scheme lets avoid having duplicate code design lot classes 
solution class represents composite components 
classes composite components concrete subclasses 
subclasses implement operations defined superclass 
operations implemented composite pattern iterate components leaf classes complicated implementation true composite classes 
operations application specific 
component leaf composite classes composite applying composite drawing creates new classes generic thing drawing figures contain sub parts 
drawing takes role branching part composite 
notice composite implies nest drawings drawings 
interpreting input tool selected palette changes input parsed 
applying objects states solves problem 
objects states preconditions object behavior depends state 
problem common object behavior depends state explicitly check value variables case statements 
technique states produces programs hard understand extend 
introduces multiple update problem maintenance cases updated parallel preserve correct behavior 
constraints hand encoding dependence state statements design compact fewer objects understand fewer procedures track 
hand hard tell states important hard tell state transition occurs object states determined set values variables take state transition assignment statement 
adding new state require changing object methods 
object states need new state probably better encode state dependency directly methods 
states represented objects 
solution implement object behavior depends state couple states set possible states change representing states objects having object act multiplexor delegating messages current state 
design uses encode state object transformed uses represent states objects steps enumerate possible states object 
class state 
give object instance variable contains current state 
method object depends state move state classes replace method simply delegates operation current state 
add object argument message delegates state classes access instance variables 
move method state classes copying class changing instance variable access original object passed argument message deleting parts method states 
result transformation new class state original object code class original object moved classes states 
add new state adding new class code object spread classes 
factor superclass described reduce size code applying objects states 
state object tool 
new attribute hold current tool 
create object help tools created 
responsibility manage tool current delegate input parsing 
different kinds drawings need different sets tools 
editor preconditions collection dissimilar objects probably applying composite 
problem object collection specialized operation want invoke objects collection support operation 
superclass supports operations specialized operations produce errors subclasses 
provide way clients determine object particular operation 
example consider collection vehicles 
support turn left turn right operations helicopters go go operations 
superclass vehicle support operations go go produce errors subclasses 
provide way clients determine vehicle submarine supports go 
constraints systems hard understand classes specialized interface 
design minimize number different interfaces learn 
hand problem working requires different objects support different operations forced different interfaces 
try design general interface force fit classes try hide interfaces reducing apparent complexity actual complexity just live complicated system 
class client uses specialized interface editor pattern give interface 
solution hide specialized interfaces making object editor represents client object making object responsible producing editor 
specialized interface directly ask object editor invoke editor 
editor object knows private interface specialized object 
name editor comes pattern hypermedia system link object invoke editor object 
important standard interface editor 
editor user interface object standard user interface object interface 
example set vehicles go go right left give vehicle controls operation returns set controls steering wheels knobs dials 
user operations turn right push operate controls turn control direction vehicle 
controls vehicle car turning left right controlling velocity submarine controls going 
object manipulates object drawing objects standard protocol tools 
half editor pattern 
finish pattern giving drawing responsibility returning standard set tools 
update display changes appearance sure changes drawing reflected screen 
observer preconditions objects synchronized 
changes object reflected 
problem changing object requires changing constraint 
don want client know constraint 
aren sure objects need changed object changed 
different instances class different numbers dependents dependents change time 
constraints objects reusable possible want hard code constraints 
objects responsible state state objects 
hand constraint states objects constraint recorded 
way changes object translated changes second 
solution object involved constraint keep list dependents 
time changes notifies dependents 
object notified depends changed takes appropriate action 
general object dependents change object require dependents change 
dependent able determine change object significant ignore 
observer add enclosing drawing dependent dependent top drawing 
notice relationship drawing toone calling drawing parent instance 
having done wanted keep object synchronized duplicate code update parent object 
redisplay changed part drawing parts drawing change simultaneously user perspective parts drawing update unit 
collect damage preconditions program internal representation picture 
periodically changes part picture update display correspond internal representation 
problem efficient program display little picture possible 
display just part picture changed 
constraints time change part picture display part changed 
simplest solution 
large constant overhead potentially entire representation picture traversed 
efficiency redisplay parts picture changed 
issue user expects single action example changing color certain kind result single redisplay 
updating little time gives impression system slow 
solution graphics system keep track part image changed 
associate damaged region image 
time part image changes add area damaged region 
adding deleting changing color part image add area damaged region 
moving part image add old new areas damaged region 
usually done automatically graphics system assuming graphical elements image considered part graphics system application program 
note haven said redisplay initiated just take place damaged region 
applying collect damage adds attribute applying causes broadcast message appearance changes 
language smalltalk anonymous functions embed damaging idiom method 
initiate redisplay collecting damaged regions need way sure get 
update user speed preconditions writing program animating visual display real time probably response user input 
collecting damage 
problem update display 
constraints update display application spend time performing low level graphics operations may able keep animation 
don update display animation jerky 
possible solution problem spawn independent thread control update display 
varying rate cycles tradeoff amount system resources required keep display consistent smoothness updates 
solution requires introducing maintaining monitor top drawing avoid inconsistent state 
solution update drawing speed user gestures 
implies redisplay drawing user event implies loop program reads event handles event updates drawing repairing damage 
events come faster program handle redisplay 
add responsibility tell redisplay damaged region routing event current tool 
pattern different convention editors drag outlines pattern called intermediate changes outlines 
gives immediate feel application 
create handles problem solve create handles 
different figures require different handles enclosing drawing insulated differences 
editor pattern solves problem 
applying editor creates handle object 
responsible returning set handles modify 
drawing handle simply implemented making subclass 
manage handles handles need manage 
need managed selecting different causes previous handles discarded 
exist limbo drawing 
manage drawing drawings nest know level store 
hand busy collecting damage displaying drawing 
need new put handles 
wrapper preconditions set classes composed different ways application 
probably composite observer kinds systems fairly static set parts 
problem want add responsibility object don want lot classes complicated 
constraints adding responsibility subclass ensure old class complicated 
want reuse responsibility object 
multiple inheritance statically assign object multiple inheritance lead explosion classes languages support 
multiple inheritance support dynamically reassigning responsibility object 
solution way add responsibility object wrapper 
wrapper wraps instance supports protocol forwarding operations handling directly operations relate responsibility designed fulfill 
applying wrapper drawing creates new object 
protocol hide show sets handles 
messages passes drawing 
implemented simply making subclass drawing figures 
drawing contain handles 
second drawing wrapped 
hotdraw architecture magic logical result set design patterns 
past explained architecture drawing tool handle 
pattern derivation puts classes perspective 
explains exactly created problem solves 
way hotdraw easier re implement modify circumstances warrant 
completely different approach describing design framework formal approaches contracts helm formal results explain design pattern derivation explains 
didn choose patterns chance 
talking patterns long time usually tried defend action terms pattern knew 
time tried explain existing design terms sequence design decisions led 
hard come general sequence took pattern descriptions clear short completely succeed 
attempted derive hotdraw patterns described design pattern catalog immediately realized catalog graphics patterns hotdraw need 
turned editor pattern derivation hotdraw showed needed describe new object oriented design pattern 
similar proof process mathematics presentation proof hides history advances mathematics caused break downs proofs 
catalogs design patterns mature people try explain designs terms patterns find patterns missing catalogs 
pattern derivation architecture presentation mathematical theorem 
problem solve known independent steps incrementally refine problem solution 
result understand final system understand reasoning led 
easier programmers extend systems documented pattern derivations 
bibliography alexander christopher alexander sara ishikawa murray silverstein max jacobson ingrid king shlomo angel 
pattern language 
oxford university press new york 
alexander christopher alexander 
timeless way building 
oxford university press new york 
anderson bruce anderson 
workshop report architecture handbook 
oopsla addendum proceedings printed oopsla messenger april coad peter coad object oriented patterns communications acm 
coad peter coad mark mayfield 
workshop report patterns 
oopsla addendum proceedings printed oopsla messenger april deutsch peter deutsch design reuse frameworks smalltalk programming system pp software reusability vol ii ed 
ted biggerstaff alan perlis acm press 
gamma erich gamma richard helm ralph johnson john vlissides design patterns abstraction reuse object oriented design 
european conference object oriented programming german july 
published lecture notes computer science pp 
springer verlag 
gamma erich gamma richard helm ralph johnson john vlissides 
design patterns elements object oriented software architecture addison wesley 
garlan david garlan mary shaw software architecture advances software engineering knowledge engineering volume world scientific publishing 
johnson ralph johnson brian foote designing reusable classes journal object oriented programming 
johnson ralph johnson documenting frameworks patterns oopsla proceedings sigplan notices vancouver bc october 
norman john hogg lynn stein harry porter summary discussions oopsla methodology oop workshop oopsla addendum proceedings printed sigplan notices pp 

krasner glenn krasner stephen pope cookbook controller user interface paradigm smalltalk journal object oriented programming 
helm richard helm ian holland contracts specifying behavioral compositions object oriented systems oopsla proceedings sigplan notices pp vancouver bc october 
parnas david parnas clements rational design process fake ieee transactions software engineering se february 
