university southampton modular grammars programming language prototyping stephen robert adams thesis submitted degree doctor philosophy faculty engineering department electronics computer science march contents language oriented programming language prototypes language prototypes usually built language fragments alternative structure contribution overview related overview survey programs data txl concrete syntax data objects caml elder parsing yacc parse tree annotations grammar inheritance sdf attribute grammars linguist chameleon reversible attribute grammars higher order attribute grammars attribute coupled grammars non specific tools summary language fragments syntax subject languages combinations ccs subset parameters functional formulation extending interpreters types recursion dynamic semantics evaluation rewriting interpreter ccs object oriented object oriented program representation object oriented language extension algebraic approach performance partial evaluation discussion modular syntax grammars terminology classes grammars top parsing bottom parsing choosing parsing method limitations backtracking top parsers modular grammars basic grammar notation grammar modules parametric grammars metaprogramming power system partial parses patterns constructors metaprogramming lisp metaprogramming lingua comparison cameron criteria discussion metaprogramming facilities lexical analysis algebra lexical analysers standard lexer parsing top framework generating parser functions basic translation scheme removing local backtracking left recursion parsing escapes parsing language shifts time behaviour reducing parse tree space requirements integrating alternative languages host lisp system bootstrapping modular parsing techniques lazy ll parsing modular lr parsing lr issues summary modular attribute grammars classical attribute grammars terminal attributes connection lazy functional languages formulation general attribute grammar processor modular decomposition syntactic modularity semantic modularity modular programming generalized modules generalization production patterns generalization abstraction pervasive inheritance bucket brigade harvest sow generalization quantification unit production copy rule list abstractions higher order operations puzzle implementation generalizations semantic patterns debugging module sources inefficiency removing inefficiency syntax attribute sets tagging feasibility designing modular attribute grammars coverage issues refinement revision comparison dueck cormack model derivation module coupling dependence syntax abstraction terminals copy rules rule precedence generics extensions local attribute names renaming declaration imports exports summary extended examples description translating set expressions implementation experiments attribute grammars translation expressions statements definitions expressions function call types translation sets functional subset top level example implementation summary summary major results engineering language fragments implications language design new avenues achieved ccs inference rules inference rules conversion scf syntax modules summary expr list bibliography university southampton faculty engineering electronics computer science doctor philosophy modular grammars programming language prototyping stephen robert adams programming languages formal notations central computer science 
significant part computer science research conducted constructing programming language prototypes studying properties 
argue conventional modular structure language processors sequence phases ill suited language implementation propose alternative phase oriented modularity structure language processor facets implemented language 
language viewed collection language fragments fragment defining independent reusable modular component 
structure new languages built cheaply different combinations language fragments reusing existing fragments 
cheap language implementation feasible perform language oriented programming application oriented languages constructed abstractions problem domains enabling concise solutions rapidly constructed particular problems 
report describes build language processors language fragments 
language oriented modular structure investigated arenas interpreters parsers attribute grammars 
case language fragment embodied interpreter 
structure interpreters changed allow combined 
modular parsing system developed 
interpreters modular parsers suffer structure clashes problems difficult express 
overcome modular attribute grammars 
modular attribute evaluator developed lazy functional programming language vehicle experimentation 
resulting system interesting properties allows language fragments semantic structure language syntactic structure includes support programming explicit refinement 
argue implementation languages collections component fragments may alter perception programming languages 
people helped possible 
particular supervisor peter henderson applying appropriate combination stick carrot 
times student patience times 
colleague friend david de roure things 
ph candidate year ahead demonstrated light tunnel constant source support wisdom 
david support moral interesting discussions proof read entire draft thesis 
chris johnson andy appreciation prepared discuss concepts bothering discussion ranged far areas specialty 
olivier danvy colleagues diku hospitality visit march 
read final draft 
final benefitted greatly comments 
particular mark andy king ian heath acknowledged 
david barron peter henderson joan lake effort put sorting science engineering research council 
case simple 
language oriented programming thesis describes new method structuring programming language implementations 
implementation structured collection language fragments describe largely independently different concepts language 
importance appropriate structure language implementation follows importance languages computing particular style computing call language oriented programming promises reduce software engineering costs 
language oriented programming 
formal notations fundamental software engineering 
programming languages obvious example 
obvious examples languages describe data formats user interface appearance configuration complex systems turn languages describe 
trend powerful languages languages user achieve training 
consider database package personal computer 
package comes language manipulating database gl 
relatively novice user create quite sophisticated application afternoon 
take expert programmer days reproduce application say compiler 
power application oriented language gl tool gives large increase productivity 
new application cost worthwhile developing application oriented language creating application 
style development application oriented language created tool assist engineering application called language oriented programming 
language oriented programming clear benefits 
application oriented language powerful general purpose language expect application concise 
application manageable investment application specific code 
language designed expressing problems particular problem domain problem description mirrors problem 
result closeness changes problem require corresponding obvious changes description 
similar applications built cheaply reuse application oriented language 
design application oriented language serves clarify issues general issues incidental individual application 
currently cost building tools high language oriented programming common software engineering practice 
cost shared applications practice commonplace witnessed gl example cited 
tool building cost reduced level language oriented programming cost effective single small numbers applications see change way software engineering done 
build application oriented language implementation economically need mature language oriented programming technology 
language tools ex build way implementations structured 
thesis different implementation structure substantially reduce language implementation cost 
turn lead language oriented programming common engineering methodology 
significant part computer science research performed constructing programming language prototypes studying properties 
organization language implementation determines easy hard change support new construct reuse part new language processor 
report argue traditional modular decomposition language processor guided implementation issues result conducive software engineering practices reuse 
alternative organization decompose implementation language implemented syntactic semantic properties language 
poses question write language processor modular structure reflects structure language set component features 
answer question requires re examination goes module modules defined tools support language definition activities 
focus rapid prototyping programming languages dialects module reuse pays biggest dividends 
assumed reader knowledge programming language implementation level provided introductory course sufficient 
assumed reader knowledge functional programming 
languages common lisp miranda prior knowledge help essential 
language prototypes researcher build language prototype number reasons 
experimentation new language features 
new language constructs new meanings existing language constructs investigated adding altering existing implementation 
true small scale experiments adding new control flow construct imperative language larger experiments example current adding object oriented programming language 
prototype implementation express run test programs demonstrate new feature 
programs assess new feature offers advantage sufficiently expressive having expected performance 
confidence 
implementor may want try part language check proposed method implementation correct feasible 
traditional role prototyping 
similar reason prototyping provide executable version theoretical 
example try particular semantics mathematical properties semantics really subject study 
working prototype gives confidence theory 
miranda trademark research software measurement 
implementor may want quantitative measurements aspect language implementation programs written language 
prototype execute programs instrumentation example monitoring amount distribution storage allocated 
implementation technique 
novel feature may implementation technique algorithm language processor interpreter translator product translation 
example new symbol table management strategy 
example second new stack frame allocation mechanism heap stack support multiple threads continuations 
goal implementation prototyping generate effective language processor 
rapid generation application oriented languages 
computers applications need invent suitable languages describe problems application area 
application may configurable tool help prototyping software engineering activity abelson sussman call metalinguistic abstraction abelson sussman 
prototype application oriented language check proposed language suitable describing problems implementation feasible 
reasons prototyping summarized linguistic algorithmic implementation driven 
main interest items list linguistic prototyping conventional structure language processors provide adequate support kind prototyping 
language prototypes usually built language processor prototype ordinary language processor minimum effort spent implementing features interest prototype builder 
prototype constructed existing implementation order reuse parts implementation 
suitable implementation exists entire prototype constructed 
traditional structure language processor sequence phases lexical analysis parsing type checking intermediate code generation optimization target code generation 
phase oriented decomposition language processor 
addition activities restricted single phase symbol table management error handling 
usually implemented service modules phases 
size phase module related size language 
language large syntax large parser language features large semantic analysis phase 
large language leads modules large understood 
prototyping activities served implementation oriented structure phases 
activities typically concerned aspect implementation 
example interested code generation plug code generator 
goes module language processor 
measurement new runtime system intermediate code generator count required information 
prototype new algorithm source program lexical analysis parsing type checking intermediate code generation optimization target code generation target program table management error handling traditional organization part module accommodated changing replacing module 
cases possible effective prototyping existing traditionally structured processor replacing single module 
occasionally interfaces modules need slight adjustment bulk effort restricted module 
changes served traditional structure 
addition new language feature affects modules 
new form new syntax possibly uses new symbols keywords requires changes lexical analyser parser 
type checker probably altered best check types components new feature worst new feature introduces new types require substantial changes algorithms 
similar comments apply intermediate code generation 
short modular structure traditional language processor inadequate prototyping new dialects 
common practice target translation high level language 
kernighan ritchie common choice benefit doing compiler performs code generation tasks cost slower system code generated parsed typechecked compiler 
reusing large parts compiler module interface source language 
benefit portability compilers run platforms 
lisp target language similar way chapter 
language fragments alternative structure seen traditional language processor structure suited prototyping new languages dialects 

koskimies suggests reason probably fact programming languages regarded complex indivisible objects 
software engineering point view language implemented black box implementor tends think terms services needed translation process try divide language logical pieces represented separate modules 
single indivisible entity propose language viewed collection language fragments 
language fragment cohesive set language features form natural unit 
language definition resemble structure language traditional phase structure 
include semantic structure data types variable scopes obvious syntactic structure 
language definition resemble body manual appendix containing collected syntax 
examples potential language fragments expressions imperative statements record types 
expressions especially language fragment languages substantial expression sub language nearly language 
re implementing fragment language unnecessary burden especially prototype builder experimenting aspect language care details expression requiring expressions look behave casual reader expect 
record types fragment different example obviously affects concerns storage allocation type checking 
concerned aspects unique aggregate structures component selection storage requirements new aggregate type rules general issues say expressions selected components variable storage allocation type rules language 
whilst convincing argument language fragments need understand languages modularized decompositions language appropriate reuse 
clear conventional modular programming poorly considered assignment functions responsibilities modules harm 
learned construct effective modular decompositions conventional programs example parnas advocates data types parnas 
similarly need learn constitutes language fragment poor 
examples 
kyoto common lisp translates lisp uses compiler produce object code file linked running lisp program 
original implementation preprocessor produced equivalent program 
source parser parse tree semantic analyser object code result syntax module syntax module syntax module semantic module semantic module syntactic semantic modules tools required help construct manage language fragments 
consider smalltalk user interface prototyping tool 
object oriented programming particular smalltalk revolutionized think graphics programming user interfaces 
effect clear modern generation computers interact users windows mice command line instructions 
appropriate tools system language fragments promise revolutionize programming language implementation similar fashion 
attempts impose language oriented structure language implementations distinction syntactic semantic modularity illustrated new language processor organization 
distinction great importance allows semantic modules decoupled concrete syntax apply languages 
syntax module specifies part appearance language 
semantic modules attribute grammars knuth unconventional allow definitions summarize behaviour module uninteresting syntax 
chapter demonstrate need module summarize behaviour syntactic objects irrelevant behaviour 
contribution main contributions ffl shown write language processors naturally structured language features having traditional implementation oriented structure 
structure considers language sum language fragments single indivisible entity 
ffl demonstrated programming explicit refinement attribute grammar language processor method similar deriving subclasses object oriented language 
method allows new processors specified differ previous processor 
lesser contributions ffl metalinguistic constructs 
shown parse programs containing quoted fragments programs top parsing scheme discussed ideas transfer bottom parsing 
ffl correspondence attribute grammars functional programming martin johnsson manipulated factor attribute style dependencies allowing standard novel structuring functional equivalent attribute grammar 
ffl concrete grammar grammar attribute grammar modules strongly coupled 
disadvantage 
overview related chapter surveys related 
related ways modularity mechanism notation 
concerned modularity description language processor expressing modularity inherent language described 
sdf syntax definition formalism heering provides alternative term syntax algebraic specifications 
algebraic term representing say statement written statement term form condition 
algebraic specification built modules definitions define concrete syntax syntax internal term structure definition syntax completely modular 
concrete syntax represent fragments program processed nice notation expressing processor 
possible algebraic specifications blur distinction program data term reduced set rewrite rules 
importance introduces complete syntactic modularity 
dueck cormack developed modular attribute grammar system response difficulties writing large attribute grammar specifications 
system similarities mine compare detail section 
koskimies contributed modular structure language processors 
concentrated writing processor collection modules conventional modular language modula oberon 
koskimies nonterminal context free grammar assigned module 
module imports modules symbols appear right side grammar productions 
organization addition deletion alteration production affect module 
koskimies new technique developed allows recursive descent parsing performed nonterminal module regime 
importance allows single pass recursive descent parsers traditionally implemented monolithic module implemented quite large number manageable modules 
functional programming language implement attribute grammar fundamental development modular system 
built works martin johnsson 
works common describe translate monolithic attribute grammar functional program computes value specified attribute grammar 
frost concerned building program smaller units calculus interpreters frost 
result better model constructing reasoning programs 
interest precedent functional language frost uses miranda implement prototype calculus essence language processor 
important difference approach works 
martin interested constructing formal models understanding attribute grammars 
frost johnsson interested programming paradigms attribute computation 
different direction 
functional programming enhance attribute grammars 
attribute grammars thing fixed works thing changes 
overview structure reusability programming language processors components improved modular syntax modular semantics 
modular aspects need tightly coupled 
aspect offers benefits benefits greater 
benefits language oriented decomposition accented language prototyping conventional implementation oriented modular decomposition phases tends shallower useful 
chapter survey related 
rest report describes investigations modularity language implementations 
mainly computational approach working executable definitions interpreters languages 
second syntactic introducing describing implementation system modular syntax variety applications 
third investigation concerned modular decomposition attribute grammars 
investigate language fragments may supported conventional programming paradigms chapter 
particular functional object oriented algebraic specification paradigms stretched provide fragment oriented modular description simple programming language 
chapter concerned syntactic modularity 
context free grammar describing syntax language composed sub grammars 
allows syntax language constructed set grammar modules 
chapter discusses efficient parsing grammar modular structure program fragments parsed represented meta programming environment 
describes parser box 
chapter attribute grammars described related functional programming 
relationship functional programming exploited derive system modular attribute grammars weakly coupled concrete grammar 
mechanism describing semantic fragments individual semantic aspects language 
programming methodology described chapter implements semantic analysis box 
modular attribute grammars support new method programming explicit refinement 
module may redefine specified module improving correcting behaviour module overriding module define alternative semantics 
chapter exciting 
chapter extended example concepts introduced previous chapters 
contains complete example prototype languages examples comprehensive description implementation 
chapter concludes summarizing achievements discusses language oriented modularity affect development programming languages 
survey chapter surveys current trends techniques tools description programming languages 
major categories items placed ffl description language objects program objects entities manipulated programming systems 
ffl parsing problem converting input text structured form defined grammar 
ffl attribute grammars developments expressiveness formalism 
discuss existing language system features subverted language prototyping 
programs data grammar metaprogramming scheme cameron ito method deriving data type adt describe program language grammar 
grammar basis deriving data type operations represent manipulate program 
direct correspondence data type original grammar facilitates metaprogramming writing applications manipulate programs 
adt provides type recognition syntactic type component selection construction context determination editing 
useful uniform methodology conventional programming language metaprogramming 
useful lists operations required metaprogramming 
txl txl cordy rapid prototyping system extending existing programming language 
system consists ffl base language extensions built 
ffl dialect description language specifying syntax semantics extension 
ffl processor reduces program written extended language program base language 
transformer context sensitive powerful traditional context free preprocessors extensible languages 
dialect described parts 
syntactic forms described bnf notation 
dialect forms integrated base language grammar replacing existing base language nonterminals new nonterminals 
nonterminals name redefined new names simply added grammar 
semantics dialect described set rules transform new syntactic forms base language structures 
txl capable arbitrary general pattern matching recursive transformations arbitrary code motion generation unique identifiers auxiliary support routines 
dialects easier describe base language turing holt restrictions order declarations statements say base language pascal 
range dialects described restricted power base language 
difficult add features support underlying model example data parallelism 
unit reuse base definition dialect built dialect built base 
concrete syntax data objects inductive data types seen grammar language values data type sentences language 
modern functional programming languages define inductive data types observed aasa correspondence taken providing linguistic input output support data types syntactic objects aasa 
aasa extend ml concrete data types 
concrete data types defined new type definition conctype 
elements language enclosed quotation brackets 
simple example type definition binary numbers conctype binnumber binnumber binnumber new form expression called quotation expression write concrete data type values 
quotation patterns allowed pattern matching 
antiquotation symbol put ordinary ml expression pattern quotation expression pattern 
ideas illustrated successor function fun succ succ succ succ succ set concrete types compiled set inductive types describe parse tree 
necessary specify type antiquotation variable pattern 
take example concrete type expression variable integer things specified conctype exp var integer assume var integer defined 
pattern possible decide type var integer 
solution specify type pattern integer 
concrete types integrate neatly ml type system example conctype may polymorphic 
unfortunately parsing program multiple concrete data types complicated type issues 
expected type type determine correct parse quotation expression integer 
parsing quotation pattern determine type 
expressions patterns determine assignment polymorphic type variables 
parsing quotations integrated type inference system 
solution adopted earley algorithm earley 
algorithm generalized operate type variable substitutions substitutions appropriate 
extensions basic system include special concrete types lists 
effect replaces automatically generated constructors normal list constructors 
benefit standard list processing functions map traverse list parts syntax tree 
caml caml cousineau huet functional language ml family 
statically typed language polymorphic typing 
implementation categorical machine cousineau name caml derived categorical machine language 
caml interest language tool integrated notations parsing printing object languages mauny 
bears similarities concrete types aasa approach quite different 
parsers modeled stream pattern matching functions yield computed value typically syntax tree 
printers hand functions data type stream formatting commands arrangement boxes text 
special notation specifying parsers printers 
typing system integrated typing system underlying ml dialect extension typing system extension type inference mechanism 
caml differs concrete types extension notation inductive types caml supports parsing method may produce values type desired programmer 
type parse tree declared program addition specifying parser 
parser kind function definition type declaration 
antiquotation escape feature concrete types added caml grammar explicitly calling system parser parse ml part escape 
illustrated shows example grammar arithmetic expressions 
note grammar builds parse tree constructors constant syntax constructor parenthesized expression 
syntax 
write values patterns parsed produce syntax 
example showing features function evaluate expression calc function constant 

calc calc 
calc calc type constant num addition multiplication grammar programs precedences left left rule entry exp parse num 
constant exp exp 
addition exp exp 
multiplication exp 

caml example arithmetic expressions antiquotation facility programmed needed 
having leaves syntax escape hands programmer 
usually syntax fewer nonterminals concrete syntax nonterminals syntax escape programmed 
parser stream pattern language pattern forms specifying iteration stream repeated patterns pattern lists lists 
result returned patterns caml lists repeated items making easy parse textual lists list data structure 
complete grammar converted yacc specification yacc described section 
imposes limitations form grammar 
possible reduce higher order parsers order parser grammar generated parser lalr 
interesting features parsers stream destructors mauny higher order parsers write multi level grammars 
multi level grammar uses grammar derive grammar parsing input 
unfortunately yacc parser generator ensuing limitations mean possible higher order parsers general fashion possible build modular grammars 
possible explicit calls parsers mix languages example system parser parsing escapes 
trick mix languages 
elder elder system experimenting languages 
weaknesses system motivated leading modular grammars thesis 
elder lisp 
language processors built interpreters collections macros 
programs languages represented lisp expressions 
program interpreted transformed lisp macros 
important component system rules macro allows functions macros written rewrite rules standard lisp defining forms 
rewrite rules little pattern matching miranda ml 
elder build implementations csp petri nets unity generic declarations systems dynamics models 
elder weaknesses 
library lisp macros functions 
implemented languages lisp expression syntax functions macros manipulate program expect 
possible bolt parser front lisp part language processor elder contains parsing language support reasoning program restricted lisp syntax 
example language set comprehension operator allows expressions expression lisp syntax setof range parts implementation handle set comprehensions form 
interesting observation system languages worked 
worked implemented macros largely independent 
making language fragments ad hoc 
language fragments generic declarations sufficiently general fragments unfortunately true fragments 
observation lead development modular attribute grammars better compositional model better 
parsing yacc yacc johnson known standard parser generator 
generates lalr parse table employ operator precedence associativity information resolve shift reduce conflicts 
production grammar recognized reduction occurs action associated production executed 
action update global variables values associated subparts production construct new value production 
yacc provides facilities constructing values nonterminal values subparts allows synthesized attributes attributed 
attribution useful constructing parse tree constraining sophisticated computations 
help creating modular descriptions 
include yacc related parser generators bison compiler writing community standard 
parse tree annotations callahan extension yacc see associates expressions string language grammar rules 
yacc program compiled parser calls custom lexical analyser 
yacc string valued language perform attribute calculations compiled powerful compiler generating systems allows definition multiple synthesized attributes limited set squares numbers 
useful inherited attributes 
original yacc really suited synthesis single attribute 
intended glue tool easy extract information program minor modifications program add extra instrumentation code track certain events 
support multiple synthesized attributes extends top level 
user program elect compute top level attributes run time 
consequence grammar definition tends reused related set programs single source maintained contains copy grammar programs calculate useful things program 
grammar inheritance aksit implemented parser generator system grammar inheritance aksit 
idea grammar inheritance analogous inheritance object oriented languages grammar may inherit rules grammar productions actions super grammar just object class inherits methods super class 
organization allows grammar reused extended deriving new grammars inherit bulk existing just add bits 
management system ensures grammar changed grammars inherit grammar updated reflect fact 
grammar inheritance independent class inheritance may implemented system authors feel best combined class inheritance 
aksit mention multiple grammar inheritance thought interesting extension 
multiple inheritance possible define new grammar inheriting grammars doing combine languages 
appears grammar system forms complete language unresolved undefined parts language fragment 
sdf syntax definition formalism sdf heering developed overcome restrictions term oriented syntax algebraic specification language asf bergstra 
sdf restricted asf literature contain sdf formalism 
central integration sdf asf correspondence syntax algebraic signatures 
signature consists declarations sorts types constants functions sorts 
sdf uses definition define syntax concrete syntax 
lexical context free syntax handled uniform way 
translation parse trees syntax implicit 
syntax represented signature derived concrete syntax production 
arbitrary context free grammars allowed 
ambiguity may resolved priority associativity rules 
eliminate need structuring nonterminals 
means concrete grammar quite close syntax making automatically derived syntax easy uncluttered irrelevant structuring information 
addition normal sorts integer statement expression derived sorts convenient describing lists items module layout exports lexical syntax 
layout 
layout module identifiers imports layout exports sorts id lexical syntax 
id module expressions imports identifiers exports sorts exp context free syntax id 
exp exp exp 
exp left exp exp 
exp left exp 
exp bracket priorities exp exp 
exp exp exp 
exp simple sdf example sort lists items sort sort lists items sort fs tg sort lists items sort items separated symbol fs tg analogous fs tg lexical syntax different section context free syntax works similar way 
syntax defines concrete form underlying signature 
shows small example sdf description arithmetic expressions variables 
demonstrates lexical context free syntax 
layout module defines lexical syntax things ignored whitespace comments line 
identifiers module imports layout module defines identifiers 
features sdf illustrated expressions module imports identifiers layout defines expressions 
imported module build new syntax 
operators defined left associative relative priorities expressions unambiguous 
parenthesized expressions declared bracket attribute means syntax semantic significance corresponding syntax algebra term concrete syntax 
parser sdf accept context free grammar 
variant tomita parser tomita 
algorithm works shift reduce parsing table lr lalr 
parser configuration shift reduce reduce reduce conflict parser stack spawned conflicting actions 
spawned parsers lock step accepting symbol time 
accurate parser table generating algorithm produce conflicts result faster parsing 
result parsing collection parse trees 
sdf chooses parse trees ambiguity resolving criteria priority 
context free grammar converted signature 
roughly rule grammar converted function constructor 
bracket rules lists handled specially 
attribute grammars attribute grammars ag declarative formalism describing syntax semantics programming language knuth 
attribute grammar context free grammar describes syntax language 
production context free grammar augmented rules specify value attributes associated production 
typically attributes translation program language ags advantage simple formal model known techniques converting efficient compilers 
lazy functional language executed directly 
chapter 
problem attribute grammar description grows large manageable 
apart context free grammar help writer organize definition way break large definition modules informal smaller units 
linguist linguist commercially developed translator writing system attribute grammars 
attribute grammar transformed attribute evaluator 
attributed parse tree apt kept secondary storage 
alternate passes traverse apt left right right left 
evaluator writes values attributes scan needed subsequent scan temporary attributes discarded 
importance linguist evaluators efficient run microcomputers demonstrating attribute grammars realistic tool 
optimization static subsumption eliminates copy rules generated evaluator 
generated compilers process input speeds compare favourably commercial compilers 
measurements show evaluators bound 
chameleon chameleon comprehensive data translation system characteristics derived formal model translation task supports building translation tools supports translation tools accessible targeted users 
software architecture achieve translation capability fully implemented 
translators generated architecture 
generation translators directed defining standard form 
item particular variant form may translated standard form standard form objects may translated variant form 
generation translators translations assisted system 
variant forms standard form possible translate text variant form variant form translating standard form back variant 
definitions variant forms gives translators 
chameleon applied translating documents mark languages 
reversible attribute grammars reversible attribute grammars yellin attribute grammars possible automatically derive inverse mapping 
attribute grammar defining translation language language shown automatically synthesize inverse attribute grammar specifying inverse translation gamma necessary restrict attribute grammar restricted inverse form attribute grammar 
yellin give algorithm inversion 
extensions grammars methods converting non grammars grammars considered 
unit reuse grammar defines translations 
chameleon section 
specifications written attribute grammars tend large complex 
inevitable ag formalism provide modularity abstraction 
dueck cormack review problems propose modular attribute grammars solution engineering problems dueck cormack 
system called processor combines create equivalent monolithic attribute grammar 
mag defines output attributes zero input attributes 
complete ag collective effect 
mag handle declarations environment concerned allocation storage essential feature modular attribute grammars specify attribute calculations sets productions individual productions 
means behaviour attributes specified detail important parts syntax module general fashion productions grammar 
higher order attribute grammars higher order attribute grammars vogt attribute grammar processing powerful allowing parts derivation tree defined attribute expressions 
parts tree parsed empty strings calculated ordinary attributes 
attributes synthesized new piece tree available ordinary attributes 
feature main uses ffl allows easy implementation macro features language 
ffl supports phase oriented modularity follows 
phase synthesizes translation attribute 
value grafted derivation tree 
new tree synthesizes translation attribute second phase 
technique powerful examples suggest 
number higher order expansions run time property translator depending program translated 
richer fixed number phases 
attribute coupled grammars attribute coupled grammars solution modularity problem attribute grammars 
consider attribute grammar ff defines translation language language 
translation mapping derivation trees language derivation trees language 
sort attribute grammar called attribute coupling ganzinger giegerich denoted ff 
attribute coupling description program text meaning translation term algebra derivation trees term algebra denoted key point domain range translation programs represented term algebras translations may composed 
ff fi composition ffi tfi complete compiler may expressed composition phases 
attribute couplings composed descriptional level 
attribute couplings ff fi exists attribute coupling fl ffi tfi tfl 
fl constructed ff fi operation called descriptional composition written ff 
descriptional composition operation descriptions result single attribute grammar describes composite translation 
descriptional composition offers solution problem inefficiency large number intermediate forms 
example phase description intermediate forms may implemented translations computed intermediate form 
ffi ffi ffi ffi ff flff flff ffi ff flff giegerich giegerich investigates properties attribute grammars descriptional composition 
example translation may chosen translations efficient classes attribute grammar 
summary attribute coupled grammars describe phase oriented decompositions 
descriptional decomposition allows implementation modularized independently description 
non specific tools languages language systems features prototyping new languages designed purpose 
example system widely language pre processor 
preprocessor macro language usually conditional compilation inter module communication data types constants textually including header files contain shared definitions 
simple example feature subversion linguistic experimentation set macros 
define defines name identifier text substituted name appears complete identifier program text 
define define define define endif macros input text endif expanded legal text problems approach ffl certain forms may redefined 
preprocessor allows text form identifier identifier expression expression expanded 
syntactic constructs handled 
ffl macro language limited macro expansion process example impossible devise macros automatically define new variable closest enclosing scope macros define replacement text 
ffl mechanism insecure 
prevent programmer native syntax new macros places 
comments apply operator definitions allowed ada smalltalk methods 
example programmer may overload operators language 
interestingly includes function call operator ff fi array indexing operator ff fi 
operators may overloaded handle new types versatility limited impossible operator support say miranda list comprehension expr pattern expr 
book stroustrup gives advice operators overloaded algebraically conservative ways 
example overloaded operations relative properties multiplication addition 
summary chapter surveyed programs systems designed assist aspects language implementation treating programs data objects parsing textual form notations attribute grammars describe syntax directed computation 
cases little attempt control complexity description allowing composed modules 
systems provide assistance usually weakness language considered single entity 
module concerned entire language example chameleon variant forms attribute coupled grammar phase 
evident modularity properties language descriptions improved 
language fragments purpose chapter investigate happens language definition broken pieces view re assembling pieces putting ways create new languages share part heritage flavour original language 
chapter describes experiments investigate combining forms programming language fragments 
combining form mean thing takes language fragments yields single new fragment sum parts 
objective experiments develop style notation express individual language fragments combine language fragments new fragments complete languages 
experimentation proceeded writing language fragments fragment combining mechanisms variety approaches computational styles 
fragments written style allow comparison strengths weaknesses approaches 
common task set express languages say combine language fragment say produce new languages phi phi success approach judged considering questions phi expressed expression concise 
understandable 
allow addition fragments means uniformly extensible 
components interact evident structure specification 
approaches compared ffl functional 
language represented evaluation function 
combination fragments involves composition higher order functions 
ffl object oriented 
syntax represented objects 
program evaluated sending message object represents program 
ffl algebraic 
language definition consists type description syntax collection rules reducing syntax result 
combining languages extends syntax description combines rule sets adding rules complete set 
rest chapter comprises description languages chosen correspond followed description approach building combining forms 
performance measurements 
followed discussion merits issues raised approaches 
describe mean syntax internal representation program 
syntax rest chapter discuss various programs manipulate subject programs 
subject programs need represented data structure amenable manipulation 
section describes program may represented syntax tree tree unambiguous linear form written term language 
syntax identifies essence piece program type sort piece components 
program fragment member set sorts 
sort represents class program constructs expressions statements definitions 
sort usually variants 
variant unique operation symbol 
operation symbol arity describes sort symbol belongs sorts components 
example assignment statement variant statement variable expression components give operation symbol assign 
say assign arity variable statement prefer write syntax generative style saying statement assignment statement syntax assignment statement written operation symbol front components listed parentheses statement assign variable expression small complete example syntax language expressions adding multiplying integers comb add comb comb comb mul comb comb comb num integer sorts definition 
integer sort built 
sort comb defined operation symbols 
comb may thought discriminated union product types operation symbol tags different member union 
program may written tree linear form selecting appropriate operation symbol fragment program replacing sort names symbol tree linear form corresponding subparts program fragment 
concrete syntax rules describing program looks infix operators parenthesized expressions associativity precedence rules associating correct operands operators 
syntax details removed potential ambiguities concrete syntax resolved syntax ambiguous restricted form 
linear tree forms syntax sentence shown 
subject languages subject languages chosen experiment find combining forms combinations ccs parameters 
combinations expression language similar arithmetic expressions available programming languages 
ccs subset milner calculus communicating systems milner 
parameters language fragment introduces named items syntax 
combinations ccs chosen require different evaluation mechanisms explained 
choice sets challenge inventing language combination method quite general 
rest section describes languages 
syntax comb add comb comb comb mul comb comb comb num integer sentence linear form add mul num num mul num num syntax tree integer integer integer integer num comb num comb num comb num comb mul comb mul comb add comb syntax combinations combination language simple expression language 
terms language values combinations values combined operator example addition 
syntax combinations numbers comb add comb comb comb mul comb comb comb num integer intended capture flavour expressions theta syntax mul add num num num expression language evaluated applicative order evaluation evaluate comb expression subexpressions evaluated produce values converted new values application operation 
type evaluator eval comb value 
evaluator comb language simple function case analysis input 
case selects appropriate action input form 
function called recursively evaluate subparts 
consider type set values 
types integers usually treated primitive 
types constructed simpler types union 
type comprises values theta cartesian product 
pairs values type second type map 
function values type yielding values type name algebraic type constructed list type lists items type algebraic type list name entity name type eval comb form case form add eval comb eval comb mul eval comb theta eval comb num case statement matches form pieces syntax order written returns value specified sharp matching arrow 
ccs subset calculus communicating systems mathematical notation invented robin milner describing behaviour concurrent systems 
give brief overview ccs purpose investigate ccs concurrency subset ccs example language requires different concept running combinations language 
interested readers refer milner milner 
system described agent 
agent system behaviour consists discrete actions 
agent may atomic decomposed sub agents acting concurrently interacting 
actions taken set labels labels names complimentary names names 
names written name name foo foo 
additionally silent action action accomplishes transition system state state 
transition state state action written gamma 
ccs language combinators 
agents combinators denote defined transitional semantics collection inference rules inferring possible transitions compound agent 
classic examples ccs csp hoare vending machine 
consider chocolate vending machine 
machine slots coins selector buttons select small large chocolate collection tray chosen chocolate delivered 
small chocolate selected inserting pressing small button chocolate tray 
vending machine vm value matches pattern operation symbols places 
names pattern bound subparts form corresponding positions form mul num num second pattern match bound num num 
error case matches happen form wrong type comb operation symbol 
pattern consists just name match 
pattern contain operation symbol 
example evaluator optimized adding new pattern avoid addition zero pattern add num eval comb functions case form body convenient write pattern matching function definition eval comb add eval comb eval comb eval comb mul eval comb theta eval comb eval comb num defined agent interacts environment ports small large collect way described 
vm def large collect vm small collect vm vending machine accepts 
commits allowing buttons pressed issues chocolate 
agent defined model user 
user slim takes small chocolate bar slim def small collect nil user vending machine interact composing system vm slim actions system rewriting system transitional semantics 
rule example rule agents composition may interact showing silent action observer 
vm slim large collect vm small collect vm small collect nil gamma 
small collect vm small collect nil gamma 
collect vm collect nil gamma 
vm nil vm see slim left vending machine continue usual 
interaction may reduced vm slim gamma 
vm mathematical concrete syntax milner inconvenient computer 
corresponding syntax discourse ccs program executed symbolically reducing simpler program 
expansion law shows agent may rewritten standard concurrent form 
program executed reducing standard concurrent form expansion law choosing prefixes 
process repeated 
execution reduction execution evaluation intermediate results execution valid expressions language 
type reduction step reduce agent agent type choice step choose agent theta choice agent composed step type step agent theta choice agent differs type evaluator combinations result type part domain evaluator function allowing reduction step re applied 
parameters previous languages meanings right 
complete definitions language 
parameters language complete sense 
extends language providing constructs naming reusing items language 
parameters language fragment introduces constructs language 
constructs name expression name syntax milner notation agent nil nil prefix label agent label agent sum agent agent agent agent compose agent agent agent agent restrict agent labels relabel agent function agent function expression agent agent expression agent agent label tau ccs syntax concrete syntax expression name expression expression expression param name meaning associate construct expression form param name equivalent expression functional formulation functional approach describing languages writing interpreter language largely functional style 
language embodied interpreter 
approach widely operational semantics lisp interpreter mccarthy denotational semantics scheme language semantics rees clinger 
approach closely resembles data structures may represent semantic domains 
compared completion semantics henson turner 
writing interpreter definition language develop language level operations phi introduced earlier 
languages embodied functions language fragment interpreters done means available functions composition abstraction application 
consequently functional approach mainly concerned writing language embodiments interpreters style allows apparatus functional programming provide desired operations language fragment combination 
language represented interpreter function language fragment built fragments higher order function 
language 
function duality extends higher order functions ways misses boat 
don operator phi creates new language phi create operator phic applied language postfix form phic 
extracted phi 
difficult don information phi map override operator may defined phi fx 
dom dom dom needs domains argument functions visible construct phi working intensional functions infinite domains finite extensional functions precludes possibility 
language fragment 
function interpreter fragment operation 
higher order function fragment extends fragment 
abstraction higher order function parameterized interpreter function subject language develop ideas take small language fragment called prim allows primitive function arguments called values subexpressions 
syntax comb prim primitive comb comb primitive divide primitive primitives fragment intended extension base language defines types expressions combinations language 
extending interpreters prim fragment written function 
logically extension mechanism prim mapping subject language new language subject language augmented new operations provides 
languages embodied interpreters function prim higher order function 
augmented language interpreter interprets forms knows passes job original interpreter 
original interpreter function takes piece syntax returns value denoted syntax 
inspects argument provided decides calculate result 
evaluation requires value denoted subpart program function calls recursively 
interpreter int comb language typical example 
looks int form case form add int int mul int theta int num function takes program returns value 
type program value 
attempt write function extends interpreter prim construct 
function called add prim extends base language higher order function 
takes function returns function type type program value 
program value 
try add prim base new new prim fun apply prim fun new new new form base form apply prim divide new int add prim int function new int interpreter extended language 
formed calling add prim interpreter case int parameter 
add prim returns interpreter extended language function new 
new works similar manner int performs pattern matching case analysis input possible outcomes 
input form new language feature evaluated applying primitive function values operands form recognised 
case original function base case int called evaluate form 
solution works case new piece syntax inside old piece 
case prim function calls base calls handle 
really want base function call new augmented function possible modifying base function 
satisfactory alter base function int call new int int written known extended prim case doing preclude int extension 
base function subject extension fragments prim single replacement recursive call site inadequate 
problem matter binding times function recursive call bound decided early decision gets way fragment 
general solution postpone decision communicate decision parameter call self reminds reader call recursive 
interpreter fragment takes additional parameter call interpreter including self passes additional parameter 
effect delay binding latest possible moment call 
rewriting int local function new add prim self mechanism gives definitions int self form case form add self self self self mul self self theta self self num add prim base new new self prim fun apply prim fun self self self self new self form base self form interpreter language created instantiating self tying knot sequence calls calls recursive 
interpreter base language constructed calling int self set int interpreter behaves original interpreter original interpreter called explicitly open version calls self interp program int int program augmented language int constructed add prim int interp program program types recursion types functions permitted type systems 
trouble type function int recursive 
parameter self type function 
ff type int ff ff theta program value called non shallow type problem known problem hindley milner type system basis type systems miranda ml field harrison 
situation improved slightly combinator 
combinator defined mechanism introducing recursion pure lambda calculus 
recursive function written recursive call parameter int curried int self dispatch dispatch form case form add self self mul self theta self num interp int difference recursive call explicitly pass recursive function 
done recursive definition type problems easily solved source non shallow types specially built language type checker 
definition add prim cumbersome curried deal curried version int add prim base new new self dispatch dispatch prim fun apply prim fun self self dispatch form base self form base self base self add prim int interp curried function function parameters rewritten function parameters returns function rest parameters 
example int function arguments self form curried turning function self returns function form 
dynamic semantics far combining forms extended syntax language 
individual fragments mainly concerned organising sharing case analysis correctly modules 
recourse recursive operator precludes language construct fragment altering interpretation meaning parts construct 
explicit handling recursive function self allows contextual interpretation 
achieved passing function self recursive call self 
parameters language fragment difficult write mechanism 
recall parameters fragment expression name expression expression expression param name meaning construct expression form param name equivalent expression interpretation param item depends surrounding lets words determines behaviour param contains 
correct effect achieved evaluating body function checks see evaluating new param name 
case defining value name evaluated 
cases form new name normal interpreter called 
self self expr metaphor evaluating expr expr metaphor evaluating expr extended contextually parameterized interpreter 
extended interpreter contextually parameterized access parts definition 
note replacing call self self changes semantics letrec interpreted context defined 
add param base new new self param error param inside new self self param self self self self param self self self new self base self summary interpreter dynamically changed implement dynamic semantics language fragment 
evaluation rewriting interpreter ccs add param function developed previous section suitable combinations language language evaluates program form residual context 
initial program may forms alter interpretation program fragment contains computed result context sensitive structure 
hand executing language ccs evaluated rewriting program produce program produce result context sensitive structure 
ccs system specification executed rewriting standard concurrent form scf choosing actions standard concurrent form 
system scf form summation prefixes 
vending machine example system scf 
form delta delta delta prefix agent scf sum agent 
evaluator ccs represents program scf set label agent pairs representing prefix term 
ccs agent reduced set prefix terms user chooses terms 
chosen term prefix silent action form represents internal action system term labeled prefix term represents interaction system ccs agent modelling user 
consider vending machine customer slim slim def small collect nil represented syntax prefix rest rest syntax agent small collect nil prefix small prefix collect nil 
prefix agent gives scf set written skeleton interpreter scf self agent case agent prefix label label consider agent part language ccs nil agent supposed equivalent agent nil syntax agent prefix param prefix param naively run interpreter agent get wrong answer param pushing context dynamically created interpreter caused surrounding context invisible 
want get result prefix param param equivalent 
solution pass function correctly reconstruct term 
function called ctx short context modified hand hand self maintain invariant self ctx self form interp ctx interp ctx self interp top level interpreter ctx empty context identity function 
trans ctx self agent case agent nil trans nil prefix label agent trans prefix label ctx agent sum agent agent trans sum self ctx self agent self ctx self agent compose agent agent trans compose self ctx self agent self ctx self agent restrict agent labels trans restrict self ctx self agent labels relabel agent function trans relabel self ctx self agent function cond agent agent eval cond self ctx self agent self ctx self agent ccs interpreter dispatch add param base eval eval ctx self exp case exp name val body body ctx self param val name ctx self self ctx self form ctx name val form base ctx self exp ctx form form ccs add param scf ccs interp agent ccs ctx ccs agent add param higher order function object oriented characteristics object oriented oo programming definition operation object associated definition type object 
operation example printing defined different types object operation defined type definition type 
operation usually different effect type object example character string presumably printed copying characters output printing integer requires digits calculated integer numeric value 
second characteristic oo programming types arranged hierarchy definition operation may inherited types higher hierarchy 
allows economy expression behaviour shared types may defined types inherit 
types sense usually called classes oo paradigm operations called methods 
object certain class said instance class components object record fields stored instance variables 
classes class class hierarchy class may inherit methods called superclasses 
act invoking operation object called sending message name parameters operation object 
terminology appropriate object knows appropriate behaviour virtue instance particular class system determine definition operation 
contrast operation oriented programming operation defined selects appropriate variation operation depending type parameters 
new type added operation oriented system system modified operations apply new object 
oo system new class simply added system piecemeal contains definitions operations apply type operations may inherited superclass es 
object oriented program representation oo approach investigated locality definition 
programming language definition terms means programming language construct represented object instance class representing particular kind construct semantics construct defined syntax 
hope factored semantics avoid compositional complexities encountered functional approach 
syntax grammars oo system structuring strongly related syntax grammar oo syntactic category sort nonterminal independent class operation symbol arity production subclass term string tree objects object oriented interpreter written manner ffl declare class sort syntax 
ffl declare subclass variant sort 
subclass instance variable component variant type instance variable class corresponding sort component 
ffl declare method called eval subclass 
combinations language defined applying rules obtain object oriented program 
comb num integer comb comb op comb comb op add op mul class comb class comb number subclass comb instance variables value integer method eval return value class comb comb subclass comb instance variables op operation comb method eval return op operate eval eval class operation class add subclass operation method operate integer return class mul subclass operation method operate integer return object oriented version combinations language note evaluation method operation class called operate 
called eval result evaluating operation function integers thought better method perform appropriate operation data synthesize new object function 
sending eval message comb comb object causes object send eval message subexpressions send operate message results combination operation 
object oriented language extension mentioned earlier object oriented program extended handle items different type simply adding definition new class 
extend interpreter described previous section parameters language 
assume symbol table class called environment available 
understands methods 
details implementation unimportant 
class environment method extend name identifier value object add binding method retract pop binding method lookup name identifier object find corresponding value generic add param base env environment class subclass base instance variables name identifier defn base body base method eval env extend name defn note result body eval env retract return result class param subclass base instance variables name identifier method eval env lookup name eval note add param add param comb combined language object oriented version parameters language combinations language extended parameters language adding new subclasses class subclass comb class param subclass comb nice able reuse parameters language fragment language dependence comb class needs abstracted 
simple way doing parameters language generic respect comb 
parameters language instantiated language extended 
generic facility compile time feature just dressed form macro 
simple pre processor language pre processor implement feature language possess facility 
generic form add param 
new forms param maintaining environment referenced global variable env 
extends environment new binding evaluation body 
binding removed environment 
effect env dynamic variable 
param form simply looks name environment evaluates form bound 
implementation gives param language dynamic procedural binding caller environment evaluate code stored environment time 
changing lines marked note env extend name defn eval env lookup name respectively change implementation values evaluated defining environment definition time 
way doing closures described shortly 
class closure subclass base instance variables body base closed env environment method eval saved env env env closed env result body eval env saved env return result method base freeze return new closure self env additions add param re write evaluation 
entire contents appear inside generic add param 
case functional approach version parameters language fragment unsuitable evaluator works rewriting source certain bits information moved program source evaluator state 
fixed adding method capture evaluator state explicit object 
new class called closure introduced represent program fragment context 
entire contents appear inside generic add param 
base class method called freeze defined capturing context 
requires original language fragment defines freeze method method undefined original language 
note freeze defined inherited subclasses 
freeze method corresponds roughly extra ctx parameter functional formulation 
algebraic approach previous approaches writing combinable modules concentrated existing control flow mechanisms bring various parts language 
approaches yielded quite complex results issues 
section take granted syntactic case analysis resolved merely stating modules act 
relieves burden complexities functional approach giving benefits distributed dispatch object oriented approach 
algebraic specification established formalism combining modules way 
algebraic module comprises sorts types operation symbols form terms sorts rewrite rules define combinations terms equivalent 
sorts operation symbols form signature algebra 
sorts operation symbols defined syntax section form signature 
previous sections production notation describe syntax 
algebraic specifications usually define operation symbols differently algebra combinations import integers sorts comb op operations comb comb op comb comb comb num integer op add op mul ev comb integer equations ev comb add ev ev ev comb mul ev theta ev ev num combinations combinations language algebraic module syntax comb add comb comb add comb comb comb algebraic specification add comb theta comb comb notations distinguish sorts variables operation symbols reserving names initial upper case letters operations 
ensures operation symbol constant ambiguous 
having equivalent notations useful syntax style definitions operation symbols part syntax algebraic style operations 
algebraic specification distinguish functions data useful maintain distinction 
signature defines type module 
signature declares sorts operation 
captures essence place function 
signature mapping sorts domain range operations value domain range modules conform signature 
combinations module defines language combinations language introduced earlier 
language slightly different operations addition multiplication sort 
combinations module conforms mapping signature substitution comb domain integer result ev value 
imports module integers provides sort integer operations addition multiplication 
new modules signatures defined substitution 
example signature evaluator looks just mapping expressions results signature evaluator mapping expr domain result range eval value modules may parameterized 
parameter typed signature 
parameterized module may instantiated module conforms signature 
module corresponding parameters language fragment sketched algebra add params lang evaluator import identifiers provides sort name operations expr name expr expr expr param name equations add params meaning new constructs described additional equations ev function 
form name creates new scope name visible bound name abbreviation param name appears associated value name substituted 
implementor fragment decisions determine kind fragment implements 
choices ffl evaluation time evaluated associated name substituted 
ffl visibility inside definition name visible definition yield recursive letrec kind definition 
ffl visibility inside forms nested name different name affect visibility name 
actual choice arbitrary key point decisions confined language fragment 
shall see issues confined fragment depend context 
approximation language semantics re write rules param param error name undefined body body shadowing body body circular 
approach inadequate accounts 
ffl difficult specify meaning nested lets different names writing circular equation 
algebra add params lang evaluator import environments name domain expr range provides sort env identifiers provides sort name operations expr name expr expr expr param name expr closure expr env equations eval closure eval closure extend closure eval closure param eval lookup eval closure closure eval closure eval param error undefined parameter eval eval closure extend empty env add params parameters language algebraic module 
ffl possible say happens body unknown language construct comb 
solution problem collect effects successive lets closure 
closure representation piece program bindings free variables parts piece program mapping free variables things bound called environment 
closure thought lazy substitution substituting names immediately substitutions kept separate place needed names evaluated 
closure introduced piece new syntax carries environment may normal piece syntax may 
part language se new syntax construct called pseudo syntax 
pseudo syntax allows represent derived pieces syntax internal evaluation mechanism visible transformations may performed derived grammar 
second problem tackled automatically generating rules cases specified fragment 
rules specified parameterized fragment parameter syntax unknown 
formal parameter tells module add param sorts mapping called ev 
combined language parameterization combinations rule comb op comb op generated automatically 
case sub expressions inherit context 
informally sub expressions contain param form referring name 
module parameters language 
equations determine new language features behave context closure 
adds new binding environment 
note value bound variable closed signature identifiers sig sorts name signature environments sig sorts domain range env operations empty env env lookup domain theta env range extend env theta domain theta range env signatures identifiers environments modules 
environments module provides extensible mapping identifiers module provides names 
defining environment 
param form reduced extracting bound value environment 
closure closure value inner closure closure definition complete contains variables defined inner closure environment 
equations state param outside error outermost starts empty environment 
additional rules automatically generated 
consider instantiating parameters module combinations module 
inspection reveals patterns closure operation symbol incomplete 
extra equations needed determine happens cases closure comb op env 
closure num env 
simplest options ignore discard context raise error 
option adequate 
assumption substructures term inherit context 
appropriate sorts syntax 
sorts inherit context looking containment relation syntax relation sorts syntax 
sorts oe oe related containment relation written oe oe syntax contains operator op oe op oe 
transitive closure containment relation written oe oe tells components operation symbol inherit context 
completing equations context sort oe subterm sort oe inherits context oe oe combinations language comb 
comb comb 
op comb 
integer trivially 
comb sort inherit context 
gives equations eval closure comb op env eval comb op closure env closure env eval closure num env eval num performance partial evaluation tool written completed rules lisp representation algebraic specifications 
performance code poor time spent reconstructing intermediate terms 
consider derived equation eval closure num env eval num constructs term num pull apart case analysis implied pattern matching selection eval 
time equation selected eval num needless avoided transforming program efficient partial evaluation 
eval function specialized know argument 
specialized version function generated symbolically evaluating function argument case num replacing calls eval calls respective specialized versions 
num case yields eval closure num env eval num eval num may unfolded produce eval closure num env interesting example shows transformation technique action variable splitting 
function specialized respect value partially known unknown parts value unknown part passed separate value 
symbolic evaluation done known part value 
automatically generated equation eval closure comb op env eval comb op closure env closure env generates specialized equations 
specialized equation called places generated 
saves time required transform program size 
specialized equations comb case eval closure comb op env eval comb op env eval comb add env eval closure env eval closure env eval comb mul env eval closure env theta eval closure env eval closure comb env cases closure 
including eval closure comb op env eval comb op env note program looks remarkably interpreter written pass environment 
improvements done hand lisp version function eval strictly applying methodology described mogensen mogensen 
possibility generate specialized functions time pattern matching completions 
combinations language generates eleven specialized functions simple eval num 
speed increase factor 
discussion chapter voyage different ways writing programming language fragments fragments combined produce larger fragments complete languages 
interpreters developed restricted phase compositional view program result program fragment defined terms parts contextual information 
contextual information passed structure means dynamically chosen functions dynamically scoped variables result passed back 
clear suitable scheme forms program 
efficiency methods discussed leaves desired 
partial evaluation improve efficiency panacea 
partial evaluation difficult apply programs dynamic control case functional object oriented approaches 
experimentation succeeded doing revealing issues involved working language fragments 
important observations ffl fragment needs way controlling parts language specific knowledge 
shown ways doing inheritance creation default equations major point needs understood better 
ffl introducing new semantic domains environment store major source difficulty especially fragments written kind extension mind 
ffl examples chapter flow information roughly parallel flow control 
allowed example dynamic variable store environment object oriented problem 
flow information parallel flow control interpreter techniques 
advantage insights notably modular grammars chapters developed 
modular syntax chapter develop modular grammar system writing programs define manipulate programs words modular metaprogramming system 
system called 
rest chapter discuss context free grammars cfgs grammatical basis system choice cfg parser 
introduce modularity metaprogramming 
discuss implementation issues 
grammars context free grammars concrete representation bnf backus naur form established formalism describing syntax programming languages 
language set strings alphabet set symbols 
usually infinite 
cfgs describe class languages called context free languages 
useful classes cfgs possible construct efficient recognizer determines input belongs language described grammar 
grammars concise declarative description syntax notation 
prototyping programming languages notations establish framework parts prototype 
terminology context free grammar set rules describe language 
example rule say expressions expression expression 
formal definition pins components statement 
context free grammar tuple consisting components set nonterminal symbols set terminal symbols start symbol axiom set rules productions ffl terminal symbols terminals basic constituents input 
input sequence string terminals 
typical terminals keywords identifiers names func numbers operator symbols punctuation 
classes terminals distinguished depending carry information addition implied presence input 
constant terminals carry extra information 
specifying grammar usually write string comprises terminal quotes 
variable terminals terminals variant forms infinite number variants 
number terminal 
inputs numbers denote different integers 
variable terminal value constructed textual form terminal 
example value identifier terminal func string characters name func derived string lisp symbol func 
specifying grammar write name terminal stands variants 
terminals called tokens 
ffl nonterminals denote sets strings 
nonterminal usually stands class language constructs expression definition 
vocabulary set symbols terminals nonterminals 
talking grammars greek letters ff fi denote arbitrary strings notation means set strings constructed symbols including empty string ffl 
means excluding ffl 
ffl nonterminal distinguished start symbol axiom 
nonterminal just nonterminal set strings denoted symbol language defined grammar 
ffl rules define terminals nonterminals may combined form string 
rule nonterminal followed arrow 
followed sequence terminals nonterminals 
rule means set strings denoted left side nonterminal includes set strings denoted right side sequence 
introduce useful standard terminology discussing cfg describes language 
terms introduced derivation sentence sentential form 
string ff fi production fl said directly derivable replaced fl 
fact may written say string ffi derivable ffi sequence strings ffi ffi ffi delta delta delta ffi ffi ffi derivable write ffi subset derive start symbol called set sentential forms 
restrictions placed derivation example ll parsing leftmost nonterminal may expanded restricts set sentential forms 
sentential form contains terminal symbols sentence language 
sentential forms half built sentences 
sequence ffi ffi ffi called derivation ffi 
grammar ambiguous sentence language derivation 
classes grammars recognition problem problem grammar string answering question string language described grammar 
answer usually want know detail string satisfies grammar 
parsing problem 
general case parsing arbitrary cfg quite difficult 
performance parsing algorithm usually measured time complexity function length input algorithms solving general problem poor worst case performance 
various classes cfg algorithms invented better characteristics 
main categories parsing algorithm top bottom 
top parsing top parsing algorithms axiom grammar 
derivation tree starts axiom grammar grows parsing 
nonterminal usually leftmost derivation tree parsed deciding production nonterminal matches input 
derivation tree extended production 
decision top algorithms differ 
full backtracking search tries production turn decision turns incorrect input parsed effect choice undone choice tried 
worst case algorithm exponential takes exponential time input error 
algorithm clearly unsuited realistic application 
ll parsing works deciding productions reversing decision linear time 
choice inspecting input tokens 
common case ll single token look ahead 
ll parsing grammar property productions single nonterminal possibly expand strings start token parser pick single production certainty 
intermediary class top parsing languages 
parse backtracking search backtracking limited current nonterminal set productions 
nonterminal re parsed see input match production higher level different way 
greatly cuts parsing time 
bottom parsing bottom parsing works input 
part input matches production part replaced production 
process repeated input reduced axiom grammar 
bottom algorithms differ decision string partially reduced input matches production replace choosing parsing method programming languages conveniently specified lalr grammar 
different grammars may describe language derive set strings 
grammar may amenable particular parsing algorithm 
example lr languages form hierarchy describe set languages 
lalr languages lalr languages particular grammar lalr language parsed lalr grammar 
illustrated simple grammar program options 
idea program may set options command line configuration file 
option form name value name word value possibly empty sequence words numbers 
options listed 
program print files uses command line options invoked parameters print file lisp printer lp heading theorem prover wish describe syntax options grammar 
suitable grammar options option options options option option word words words words word words number symbols word number value terminals provided basic input routine 
grammar lalr 
parser grammar looking ahead word token tell word start new option part current list words 
parser needs look input symbols see word respectively 
language belongs simpler class languages regular languages recursive structure iterative nature 
rewriting grammar regular grammar lalr grammar meaningful structure grammar options options word options options options number options options word options options options number options options options options word options difficult reason source program grammar structure rules destroyed 
clear words grammar denote names options ones part values word production 
case possible rewrite grammar lalr grammar way maintains information result entirely satisfactory rewritten grammar regular productions nonterminal rightmost symbol 
regular languages expressed form grammars form describe regular languages aho 
options options word words words words word words words word words words number words problems grammar option name appears places start subsequent options buried productions words example shows sufficiently powerful parser construction technique chosen artificial difficult rewriting grammars required 
chose tdpl shift reduce parser reasons easier understand combined languages operate allow modular implementation 
reasoning combined languages easier reasoning terms production ordering productions may shadow productions 
reasoning lr parsers involves understanding shift reduce reduce reduce conflicts lr automaton global property grammar 
tdpl allows modular decomposition implementation implemented set largely independent parsing procedures nonterminal 
fundamental unit language maps fundamental unit implementation 
eases implementation modular parser burdened complex mapping grammar parser 
limitations backtracking top parsers backtracking parser nature may re examine parts input 
easy construct grammars demonstrate stmt lvalue expr assignment stmt ident procedure call 
lvalue ident array index ident expr ident consider input foo parser parses foo lvalue 
followed backtracks re parses input procedure call 
limited backtracking lead exponential behaviour 
say expr ff stmt fi best lalr rewrite add discussion options options word words words options words word words words number words happen 
input foo bar reading top level inner form bar scanned twice 
backtracking costs occurs higher level grammar 
fortunately languages lists things higher levels pathological case happen 
importantly languages ll lr nearly ll 
happens constructs introduced keyword 
parse quite ll lr languages 
grammar lr reduce reduce conflict reductions expr ident index ident 
shared part stmt productions revealed substituting productions lvalue stmt production 
transformation disadvantage source level grammar transformations alters shape parse tree 
compromise declarative nature grammars 
ordering productions significant 
consider productions ffi ffi fi production chosen input parser accept ffi production rectify problem productions transposed 
share ll parsing methods weakness parse grammars left recursive rules expr expr term simple extension allows direct left recursion recognized treated specially 
useful allows programmer specify left right recursive structures 
modular grammars main types metaprogramming application grammar fragments ffl extension existing definition new features ffl creation new language built components fragments section describe modular grammars may applications 
basic grammar notation grammars described bnf language called grammar 
example grammar arithmetic expressions shown 
choice operator mulop 
entirely equivalent productions order choices addop 
systems built language notations grammar notation describe 
description called meta grammar shown additional example notation 
nearly ll mean small number productions prevent grammar language ll 
productions removed grammar new symbols added productions language ll 
grammar expressions terminal ident number expr 
expr addop term term term 
term mulop factor factor factor 
expr number ident addop 
addop 
mulop 
grammar expressions grammar consists header names grammar followed declarations followed list productions 
grammar notation productions similar bnf notation discuss grammars 
keyboard form production arrow 
right side terminated period productions may alternates separated vertical bars 
terminal directive specifies names denote value terminals 
axiom specifies nonterminal start symbol defaults symbol production 
expressions grammar specified defaults expr 
comments handled separate lexical analyser main text 
comments directive specifies comment style 
directives described 
terminal comments directives tie ins lexical analysis 
named value terminals provided lexical analyser 
grammar modules grammar definition module 
module importation 
simplest level modules divide grammar parts 
grammar import parts 
example extending language additional bits syntax 
original language forms module 
new module import base module define extensions syntax 
modules useful structuring tool parameterized modules powerful 
parametric grammars section describes parametric grammars 
parameterized grammars list symbols name 
formal parameters 
grammar parameters level operator 
grammar represents single level precedence hierarchy expressions constructed left associative binary operators 
actual symbols provided grammar imports parametric grammar 
substituted syntax chosen reasons similar discussed section period grammar parsed single look ahead nonlocal backtracking 
grammar grammar terminal ident string comments grammar 
header directives rules header 
ident ident parameters ident grammar parameters 
parameters 
directives 
directive directives directives 
directive 
import ident grammar directive 
export export names directive 
terminal value terminals directive 
external ident string special nonterminal directive 
axiom ident grammar axiom directive 
comments ident comment lexer directive 
lexer ident name non default lexer 
ident 
rules 
rule rules rules 
rule rule 
ident choice choice 
sequence choice choice 
sequence sequence 
collection sequence sequence 
collection 
ident nonterminal value terminal collection 
string constant terminal meta grammar 
lexical analyser removes comments starting hash symbol continuing line comments 
grammar requires lexical analyser provides types value terminal ident string 
effect grammar imports lexical analyser 
grammar level operator level 
level operator level 
grammar module precedence level grammar import expr term addop import term factor mulop import factor primary terminal ident number primary 
ident primary 
number primary 
expr addop 
addop 
mulop 
mulop 


precedence level module 
body parametric grammar resulting rules merged rules importing module 
parameterized grammars imported times instance parameterized different symbols 
grammar imports times 
pattern sharing symbols yields level precedence hierarchy having lowest precedence highest expr expr addop term expr term term term mulop factor term factor factor factor primary factor primary arbitrarily complicated parameterized grammars specified 
main flavours apparent ffl small scale constructs common patterns precedence hierarchy lists 
ffl large scale constructs grammars entire language fragments expressions statements parameterization 
metaprogramming seen supports definition modular grammars 
see grammars basis writing programs manipulate programs metaprograms 
key metaprogramming sufficiently rich set operations apply program data type 
power system cameron ito identify kinds operation supported metaprogramming system cameron ito 

type recognition 
statement including cameron calls syntagmatic types membership higher level construct number recognised expression 

component selection 
pick predicate conditional 

construction 
assignment statement variable expression 
context determination 
find nearest enclosing subprogram definition node 
editing 
delete third statement block 
delete insert replace splice 

lexeme coercion 
return value represented numeric lexeme cameron identified operations imperative metaprogramming language mind 
functional paradigm editing operations rewritten combinations selection construction 
partial parses patterns constructors essential operations metaprogramming system differentiation different syntactic objects construction new syntactic objects 
approach aspects textual program fragments 
program fragments little pieces program possibly containing escapes 
example expression 
statement 
pascal statement escapes 
linguistically program fragment sentential form language nonterminal grammar 
escapes unexpanded nonterminals sentential form 
escape may annotated name 
useful escapes fragment share nonterminal 
list expressions written expression expression 
program fragment different meaning different contexts 
pattern predicate constructor 
pattern predicate program fragment determines syntactic object derived sentential form pattern represents 
equivalent matching parse tree syntactic object data structure pattern partial parse tree sentential 
true parse tree direct record derivation 
escapes program fragment variables pattern 
appropriate scope pattern variable bound subtree syntactic object derivation nonterminal sentential form 
pattern variable named nonterminal nonterminal annotated case named annotation 
pattern variable repeated subtrees denoted variable equal syntactically identical example expression expression 
match list identical expressions binding expression variable expression expression expression 
match list expression binding second 
constructor program fragment specifies complete parse tree 
escape fragment identifies subtree structure subtree rooted escape determined value variable current scope 
variable named nonterminal escape annotated fragment case variable name annotation 
constructor expression expression 
builds parse tree list identical fact shared expressions determined value variable expression 
expression expression 
builds parse tree list expressions determined value variables may may equal 
metaprogramming lisp metaprogramming operations provided lisp reasons ffl operations necessary bootstrapping system 
ffl programmers wish write application lisp 
basic operations match syntax build syntax 
operations parse trees implemented macros expand lisp code perform matching construction 
match syntax case form compares argument parse tree specifications 
syntax match syntax correctly identical derivations match syntax expr grammar entry parse tree action action parse tree action 
parse tree action parse tree string constant containing partial parse sentential form language nonterminal entry grammar grammar expr evaluated 
resulting tree matched parse tree turn 
option matching tree selected 
subtrees expr correspond escapes pattern bound variables appropriate names 
action action evaluated order value value match syntax construct 
parse tree may constant matches expr serves default case 
note expr form evaluated grammar entry patterns evaluated 
patterns expanded lisp matching code macro expansion time 
final lisp program contains sequence instructions inspect value expr strings parse tree parse tree structures represent compiled efficient form 
arbitrary tree tested membership nonterminal language pattern escaped entry 
lisp expression tests expr match syntax expr grammar 
nil build syntax simple syntax 
form build syntax grammar entry text returns parse tree language nonterminal entry grammar grammar parse tree specified text string constant containing partial parse 
escape parse tree takes value variable appropriate name 
third metaprogramming macro macro scheme 
purpose concisely specify set syntax translations 
macro scheme expr grammar entry tree actions tree actions 
tree actions 
entry tree actions tree actions 
tree actions expr evaluated 
macro scheme returns tree syntactic type expr entry chosen depending syntactic type expr entry lingua level base hierarchy languages expr returned unaltered 
tree patterns chosen entry matched expr turn 
matches leads evaluation corresponding actions just match syntax 
tree matches expr returned unaltered 
actions may include special action replacement text equivalent build syntax grammar entry text grammar entry immediately enclosing grammar entry items macro scheme 
ensures returned value correct syntactic type 
macro scheme replaces expressions form theta 
subexpressions syntactically identical assured variable name subexpressions macro scheme expression expressions expr term 
term 
replacement term metaprogramming lingua lingua third language hierarchy languages written experiment defining new dialects language 
hierarchy shown 
language hierarchy superset previous language 
base language provides function definition expressions arithmetic operators function calls 
level language adds list constructors pattern matching including pattern matching function definition level 
lingua adds syntax constructors patterns 
base base provides simple applicative functional programming language 
allows function definition conventional arithmetic infix expressions comparisons function calls conditional assignment global variables 
level level extends base constructor syntax lists pattern matching 
forms pattern matching pattern matched function definition explicit pattern match 
syntax foo pattern 
expr pattern 
expr 

defines function foo 
function chooses set patterns match returns value corresponding expr patterns match error signalled 
variables introduced pattern bound corresponding parts arguments evaluation expr case number patterns function fixed number arguments 
explicit pattern match similar syntax match expr pattern 
expr pattern 
expr 
match form expression may appear place expression function definition appear place definition 
expression evaluated matched pattern turn pattern matched function 
level construct 
basic expression var expr body match metaphor variable pattern match bind expression 
match expr var 
body list patterns constructors notation 
lists items written square brackets 
double colon infix cons function 
empty list list integers head tail infix list constructor list integers lingua lingua adds syntax constructors patterns level 
syntax constructors patterns syntax 
forms 
grammar entry text entry text text double square brackets syntax brackets 
notation similar syntax brackets programming language semantics literature 
grammar identifier naming grammar defines syntax text 
entry identifier names nonterminal text belongs 
grammar omitted default grammar 
note identifiers grammar entry variables directly name grammar 
variables possible compile program fragment pattern constructor expression 
syntax ffi expr statement ffl keyboard syntax pascal statement expr 
statement 
caml similar system uses symbols look french quotation symbols comparison cameron criteria type recognition 
system supports type recognition pattern matching 
kinds type recognition supported ffl subclassing 
pattern expr term tests subject tree expression term 
ffl general class membership 
pattern expr expr tests subject tree type expr 
possible tests require induction grammar 
example tree number fail tests 
syntactic sorts disjoint unit productions imply subsorting 
component selection 
components selected pattern matching 
example predicate statement selected pred expr expr 
expr 
expr 
construction 
construction supported program fragment expressions 
context determination 
context determination example find enclosing block done tracking required information program tree traversed 
done tree shared programs program fragments arbitrary number parents 
structure parent stmts result transformation pascal repeat statement statement 
stmt repeat stmts 
expr 
stmt stmts expr 
stmts 
editing 
program fragment edited constructing new program fragment required changes 
declarative cameron editing operations cause side effects 
incorporated pass entire program quite efficient 
lexeme coercion 
value lexeme obtained matching lexeme pattern 
discussion metaprogramming facilities provides facilities defining grammars plain parameterized grammar modules 
allows user quickly construct grammar existing 
system constructing programming language prototypes example see chapter findings discussed 
main problem grammars constructed modular style support writing programs modular grammars 
ffl possible write program applies module correctly language uses module extensions 
ffl facility write programs abstractions provided parameterized modules 
example write single function operates level precedence hierarchy levels function works lists provided instantiating module 
chapter modular attribute grammars shows shortcomings 
lexical analysis lexical analysis conversion stream characters stream terminals higher level representation input 
performing lexical analysis separate phase parsing benefits 
ambiguities resolved level example identifiers keywords 

size input reduced tokens built characters 
layout comments completely removed input 
reduction size reduces time space requirements subsequent processing 

grammar simplified layout comments removed input longer appear grammar variant forms symbol may reduced single form 
algebra lexical analysers lexical analysers frequently metaprogramming environment sense establish operations allowed 
describe lexical analyser type define useful operations type 
lexical analyser lexer function performs lexical analysis stream characters returns stream tokens 
chose single step formulation tokens yielded time 
type lexer formulation lexer char token theta char lexer takes list characters returns pair ffl token indicated non null prefix list ffl rest list removing prefix constitutes token 
special tokens fail eof 
token fail returned lexer return valid token 
eof returned input stream 
lexer return eof empty input list 
sequencing sequence lexers behaves lexer lexer return fail token 
behaves second lexer 
stream token stream stream token fail stream token stream example lexer test identifiers numbers strings order lexer numbers strings hiding lexer hide tokens lexer 
lexer recognises token part input discarded lexer called 
provides comment facility discards part input 
hiding stream token stream stream token stream hiding stream implementation input stream modeled lazy list characters 
laziness allows input interactive 
lazy list built technique lazy value represented place function closure called suspension henderson 
suspension initially contains function computes value thunk flag set indicate function called 
time suspension activated inspects flag calls thunk stores value 
flag set indicate function called 
subsequent calls suspension knows flag function called simply returns stored value 
flag type list tail 
fine lisp lisp dynamically typed 
type tail function thunk called yield tail list 
function list nil cons cell character car position 
input list stored variable dynamic scope lexer function written side effecting zero argument function returning token 
interface facilitates production hand written lexers 
descriptions build lexical analysers assume imperative style programming input read character time token returned input stream change state 
combining forms described implemented higher order functions 
input stream global single threaded combining forms remember state input stream restore failure 
combining forms lexers convenient compromise 
approach taken pragmatic aim generate simple framework combining lexical analysers meaningful useful ways variable function parameter single threaded program old value new value assigned function call 
single threaded parameter functional program may replaced global variable altering meaning program 
stream single threaded lexer combining forms stream calling parameter lexer generating complete theory 
scope extending algebra lexers include standard combining operations regular expressions 
higher order functions hopelessly inefficient fine grained level example combining lexer token 
efficiency lexers combining forms reduced form re scan input 
conventional techniques lex lesk incremental approach heering lexer generation efficient 
standard lexer system provides standard lexer adequate experimental languages 
standard lexer recognizes classes terminal numbers including signed unsigned integer decimal scientific exponent representations 
terminal name number grammars refer numbers 
strings restricted style strings delimited double quotation characters 
terminal name string refer string tokens 
identifiers consisting letter followed alphanumeric underscore characters 
terminal name ident refer identifiers 
keywords subset identifiers behave reserved words 
terminals written double quotes grammar specification 
symbols sequences non alphanumeric characters written double quotes 
numbers strings identifiers value terminals keywords symbols constant terminals 
layout characters ignored may separate terminals 
standard lexer implemented higher order function parameterized respect keywords symbols 
called set keywords set symbols returns specialized lexer 
lexer specified grammar standard lexer default automatically parameterized keywords symbols grammar 
acceptable lexer speed achieved dispatching input character function handling particular class terminal 
constructing specialized lexer done initializing structures lexer 
returned lexer closure containing initialised structures 
say standard lexer table driven 
structures ffl fast dispatch table ffl hash table keywords checked identifier detected ffl set trie structures symbol dispatch character recognizing symbols dispatch character 
typically tries small node replaced fast dispatch table 
performance inadequate standard techniques convert lexer specification deterministic finite state automaton aho lazily heering 
language describes partial parse trees requires lexical notation escape indicate omitted part parse tree 
provides standard syntax metalevel escapes 
summarise notation allows forms escape unnamed named ffl opening angle bracket followed directly name nonterminal value terminal grammar followed directly closing angle bracket example factor 
ffl opening angle bracket followed directly name nonterminal value terminal grammar followed whitespace identifier closing example factor 
input causes return fail token 
higher order function parameterized names nonterminals value terminals grammar 
returns lexer specialized recognising escapes grammar 
returned lexer combined natural lexer grammar sequence lexer combining form 
implementation similar standard lexer comments apply implementation standard lexer apply 
level shift terminal returned recognises escape 
level shift terminal value terminal components value ffl grammar parsed ffl nonterminal value terminal escaped ffl identifier escape 
defaults name nonterminal value terminal 
level shift value terminal information available parse tree 
parsing top framework section top parser developed 
parser uses grammar specification top parsing language tdpl aho ullman similar manner implementation meta lisp 
limited backtracking ability 
special approach direct left recursive rules provides powerful parser usually efficient 
tdpl gives operational reading grammar 
nonterminal grammar defines parsing function 
parsing function attempts match prefix input stream 
match succeeds prefix removed input stream parse tree representing recognised input returned 
parsing function takes sequence tokens returns failure pair recognised parse tree remainder input 
parser token 
token parsing function nonterminal advantage special parsing functions defined handling exceptional circumstances example changes language lexical conventions 
generating parser functions section describes lisp parsing function generated set rules 
rules left side nonterminal 
input stream implemented lazy list tokens 
tail list lazy 
list lazy metalevel parsing require alternative lexical analyser 
alternative lexical analyser interpret input different sequence tokens 
lisp function returns nil indicate failure pair represented cons cell containing parse tree car remainder stream cdr 
parser function viewed function replaces prefix stream parse tree returns nil 
lisp regards value nil indicate true value lisp parser function viewed predicate indicates truth match prefix input stream 
single symbols parsed differently depending type symbol 
nonterminals parsed calling parser function nonterminal 
constant terminals parsed testing token input stream 
variable terminals parsed testing tag token input stream 
bnf provides basic constructions alternatives sequences 
alternatives 
essence parsing rules ff 
ff try match ff input turn returning match 
sequences 
essence parsing sequence symbols parse symbols turn matching input consumed previous symbol 
basic translation scheme consider compile list rules parser function 
take set rules nonterminal terminals nonterminals 
operation parse function follows 
attempts parse input 
succeeds attempts parse remaining input 
succeed parse tree constructed production containing subtrees recognised parse tree remaining input matched returned 
fails alternative fails 
parsing function backtracks tries parse alternatives fail parsing function fails returns nil 
backtracking limited local parsing function 
parsing function returned value retried example prolog parser 
possible control parse time removes need trail 
set rules compiled lisp tree 
name ij sj denotes parse tree stream pair returned parsing function sj input stream component pair defun cdr cdr ik sk ik sk sk cdr ik sk cons create parse tree node sk sk 

structure part partly obscured operations maintain correct position input stream 
ignoring issues considering predicates structure parser function 
special case empty rule handled uniformly reduces identity element conjunction true nonterminal just null production compiles function testing 
described far form parser function inadequate metaprogramming system ffl inefficient adjacent productions start symbol alternative fails function called 
ffl loops endlessly left recursive grammar 
ffl parse language shifts 
sections show problems overcome 
removing local backtracking efficiency basic translation scheme improved adjacent rules prefix 
basic parsing function transformed shared prefixes parsed 
variation technique converting grammars ll grammars called left factoring 
consider rules tree rules rewritten factoring shared prefixes issue rules may shadow rules 
set productions productions production prefix longest rule tested match 
easily detected corrected factoring shared prefixes 
factored tree term simply rewritten 
left recursion inability top parsing techniques handle kind left recursion major impediment 
direct left recursion handled special case 
technique handle general left recursion direct left recursion essential constructing correctly structured parse trees expressions containing left associative operators 
directly left recursive rules ff 
ff fi 
fi compiled parser function recognising base case building parse tree recursive productions loop 
ff tried order 
fail parse parse function fails 
ff succeeds taken base case recursion recognised 
attempt extend parse seeing fi follows recognised fi recognised recursive cases recognised corresponding extended parse tree built fi removed input 
process repeated prefix remaining input match fi tree version loop ff ff fail fi fi final parse factoring shared prefixes done ff fi parsing escapes describe tdpl parse sentential forms containing escapes 
point parser see escapes 
parsing ordinary program special case parsing program fragment containing escapes 
escape mechanism enabled parsing disabled parsing standard lexer 
escapes parsed simple modification parsing function 
input contains escapes value terminals nonterminal grammar augmented production escape escape escape terminal nonterminal parsing function extended check escape terminal correct nonterminal productions augmented additional production 
left recursion case handled correctly new terminal ff inputs expr parse single expr intended 
parsing language shifts lingua language allows program fragments appear expressions patterns 
section describes special actions required parser lingua metalinguistic support grammar lingua import level external lambda lingua shift nil nil external lambda lingua shift nil external lambda lingua shift primary 
pat 


ident 
ident ident adding language fragments patterns constructors lingua parse fragments languages 
special action required parsing fragments arbitrary named language context sensitive computation 
recall tdpl nonterminal may compiled parsing routine 
routine standard interface takes stream tokens returns parse tree pair returns failure 
principle function providing interface place nonterminal 
grammar language provision specifying arbitrary parsing functions external directive 
directive form external name string means nonterminal name ordinary nonterminal ordinary parsing function 
rule compiler handles external nonterminals differently 
call parsing function name lisp code written string called 
nature replacement mechanism means replacement code type parsing function function argument returning parse tree residual token stream 
achieve left context dependence left context available replacement function 
replacement function just named function possible 
replacement form open coded function lambda form intermediate return values parse functions left context scope 
parse kth left context symbol bound variable ik sk right context dependence possible 
external mechanism obviously context free replacement function arbitrary computational decisions acceptability input 
simple demonstration ideas grammar fragment external lambda equal car car cons nil foo 
bar bar bar 
fragment accepts bars identical 
external compares parse trees second symbols production 
parse tree bar written car parse function returns pair containing parse tree remaining input 
bar accepts language fa flg foo accepts language fa flg clearly context free 
external parser mechanism construct language form parses fragments language known system 
details grammar module extends language level patterns expressions program fragments 
forms program fragment allowed grammar entry text entry text text form uses different external calls general handler lingua shift 
syntax brackets specified pairs single symbols single symbols comprised characters 
avoid problems lexical analysis combined language 
course taken inputs analysed incorrectly returning token function lingua shift takes stream grammar entry name returns parse failure 
may simple issue parser function grammar entry names looking system descriptions known grammars 
complications arise new language may completely different lexical conventions 
implementation lingua shift quite involved lexical analysers ensure correct synchronisation input 
happens lingua shift called 
current lexer suspended 
token read placed back input 

specified grammar activated input 

appropriate parse function specified grammar entry 
called restarted token stream 
lexer possible escapes 

parse function fails reported 

new suspended token read placed back input 
levels levels levels levels table parsing timings 
original lexer restarted 
tokens placed back input token look ahead required tdpl 
process motivates decision lexical analyser return token fail raising error understand input 
bit program fragment opening syntax bracket just happens token lingua language fail token returned 
error allow correct second chance 
reasoning applies closing syntax bracket prefix legal token program fragment language 
time behaviour section looks time behaviour modular parsers 
important implementation modular parser substantial parse time costs parser constructed efficiently 
parsing time performance parser constructed modular grammar checked see reasonable 
expected run time linear respect length input linear respect size parse tree constructed 
test devised show module construct expression grammars different depths precedence hierarchy 
grammar tested set inputs 
inputs lengths tokens 
inputs sequences numbers separated operators lowest precedence 
produces largest parse tree number bottom long chain unit productions 
grammars hierarchies depth levels 
results expected verified table 
parse time strictly linear size input depth hierarchy 
size parse tree input size hierarchy depth nd gamma cons cells 
independently linear reducing parser construction time parse function abstraction grammars derived imported grammars share substantial sections 
section looks methods characteristic related grammars reduce time space requirements generating parser derived grammar 
nonterminal appears languages identical sets productions analysis parser generation nonterminal may shared 
observation carried nonterminals may sets productions sufficiently similar parser code may shared 
example rule sets expr expr addop term expr term term term mulop factor term factor structure structure revealed uniformly replacing nonterminals productions standard names generating parsing function rule set system single parsing function generated different structure 
parsing function parameterized actual nonterminals yield desired parsing function 
parsing function needs parameterized symbol occur check escapes section 
order rules significant tdpl sufficient compare structure rule set structure rule sets system 
done efficiently looking structure hash table 
order rules unimportant comparing structure difficult 
general problem combinatoric search space may reduced discriminating rule set structures measures 
measure partitions space rule set structures 
ffl distribution lengths right hand sides rules 
rule set rules length rule length unify rule set rules length rule length 
subsumes measure number rules rule set 
ffl distribution frequencies structure unify structure ffl distribution frequencies rule partitions rule set smaller sets 
measures construct cheap hash function 
parse function abstraction clearly saves space time 
new language minor extension old language number new parser functions needed function number nonterminals additional productions 
typically far fewer number nonterminals original language 
worth noting parser functions production sets parameterized grammar usually generated 
reducing parse tree space requirements naive parse tree representation contains node production reduced parse input 
parse trees consume quite large amounts storage 
space efficient alternatives ffl automatically generated syntax trees 
ffl production trees 
alternatives algorithms produce representation phases compiler 
result applying algorithms usually removes distinction related nonterminals grammar 
example syntax factor usually identical expression 
system uses syntax directly manipulation programs maintain ability distinction 
space saving measures described comprehensive responsible success approaches 
concentrated approaches yield saving disruption correspondence concrete syntax internal form 
intention user programmer illusion entire parse tree stored 
constant terminal elision constant terminals right side provide information provided production tag 
expr expr expr expr expr expr contain information position constant terminals recovered tag 
space saved omitting constant terminals right side 
reasoning apply variable terminals identifiers numbers instance terminal may denote different object 
value value terminal stored 
unit production elision unit production production right side consists single nonterminal single variable terminal example term factor variable ident rules typical grammar form actual savings may greater suggests 
parse tree rules unit productions 
rules come metaphors example lingua productions nonterminal unit productions variable terminal unit productions program naive tree constant terminals unit productions cells cells factor cells factor table effectiveness space saving measures ffl hierarchy nonterminals express precedence levels ffl case productions list nonterminals unfortunately unit production elision potential considerable space saving fit unit productions carry type information 
programs example macro scheme need know root nonterminal parse tree 
effectiveness effect measures calculated example programs 
results calculations appear table 
removing unit productions reduces size parse trees third original size 
removing constant terminals saves storage 
figures roughly line reported 
effects measure additive affect independent sets productions 
saving say unit production elision importance constant terminals magnified 
unfortunate unit production elision awkward integrate current system 
integrating alternative languages host lisp system notations different syntactic lexical conventions necessary able determine conventions input particular piece text 
files containing text tagged 
file starts line language grammar entry compiler text common lisp read macro 
lisp reader sees invokes function inspects rest line reads rest file accordingly 
grammar entry specify grammar parse rest file 
compiler name lisp function translates parse tree lisp object sequence lisp definitions 
important compiler function grammar lisp converts grammar description parser 
translation required function identity 
common lisp read macro call appropriate parser neatly integrates new notations lisp environment allowing file read loaded compiled 
bootstrapping earlier section described metaprogramming language built top ordinary language pattern matching 
describe grammar system originally built 
grammar rule compiler written lisp 
initially simple boot grammar hand coded internal representation grammar boot grammar parametric grammar base level lingua application bootstrapping 
rules 
grammar describe simple productions consists rules 
grammar rule compiler convert parser 
boot grammar define grammar grammar displayed 
lisp metaprogramming tools write program convert specifications written full grammar notation internal form understood rule compiler 
subsequent stages translation written lisp tools lingua language defined quite late bootstrapping process 
modular parsing techniques chose top parsing language basis modular parsing system 
straightforward relation context free grammar parsing procedures simple implement modular parser 
parsing function uses information local nonterminal accepts 
parsing techniques information global grammar 
complicates modular implementation 
section describe alternative approaches problem parsing modular grammars 
describe solve problems parsing program fragments shift reduce parser 
lazy ll parsing koskimies describes technique recursive descent implementation ll parser koskimies 
program structured set modules nonterminal 
modules conventional modules sense modula ada 
key ll parsing determine selection set production 
selection set set input symbols may start production symbols may follow nullable 
grammar ll selection sets productions nonterminal disjoint 
parser chooses production input symbol selection set 
selection sets derived follow sets 
unfortunately follow sets global properties grammar 
poses problem write recursive descent style parsing routine nonterminal knowing productions nonterminal knowing productions nonterminals terminals 
essentially language known link run time 
koskimies solves problem lazy parser construction 
conventional parsing tables constructed run time needed 
information available modules linked 
compare limited backtracking 
correct parsing actions trying parse backtracking fails 
effect parsing information regenerated time needed 
koskimies rejects backtracking approach semantic actions integrated parsing actions behaviour compiler nondeterministic 
problem parsing done prior semantic evaluation 
lazy parser construction done encoded form grammars 
result interpreted parser 
loose benefits compiling parser set recursive descent procedures 
new data structure start tree encodes relationship symbols start sets 
start trees constructed lazily predict appropriate production 
method efficient conventional ll recursive descent parsing 
interestingly start trees contain information nonterminals contribute 
allow technique extended parse nonterminal escapes see sections 
modular lr parsing lr parser lr automaton 
state automaton corresponds set partially parsed productions correspond input 
lr automaton constructed directly grammar 
modular lr parsing problem lr automata constructed grammars construct compound automaton corresponding grammar construction problem hard constructing compound lr automaton scratch 
problem compound automaton usually bears little resemblance original automata grammars interfere 
rekers rekers suggests trying construct compound automaton subparts huge automaton created containing union grammar modules 
automaton subset modules restricting compound automaton actions related productions subset 
system mpg implemented rekers extension earlier incremental rules added time lazy parser generator ipg heering part sdf 
mpg incremental adding production module causes adjustment compound automaton reflected restricted view edited module subset defining language parsed 
mpg solution address issues modular parsing 
example issues parameterized modules discussed 
failing ipg mpg sdf parse tree disambiguation done parsing complete 
parser sdf uses variant tomita parser tomita 
parsing conflict shift reduce reduce reduce parser spawned conflicting actions 
input ambiguous parse trees result 
parsers fails thread abandoned 
threads fail input error 
left right associative operators handled parsing table operator precedence handled separate process choosing parse trees multiple results 
inefficient 
expression different parses operator associativity done parse table sdf 
clear program expressions huge number parses 
lr issues sections discuss solution parsing problems faced implementing shift reduce parsing scheme 
assumed reader familiar principles shift reduce parsing explained aho 
parsing multiple axioms usually lr parser constructed parse single axiom 
grammar augmented production start start input symbol 
input symbol shifted input accepted 
grammar multiple axioms parse language nonterminal similar done nonterminal 
incorrect add set productions start cause ambiguity parse conflicts 
solution adopted horspool parser generator horspool add set productions start nonterminal bracketed private input symbol 
parse symbol pushed front input 
selects correct nonterminal 
production ends nonterminal private input symbol 
ensures appear follow sets normally cause shift reduce conflicts 
input containing nonterminals conventional lr parsing table divided parts action table goto table 
action table consulted input terminal decide shift reduce accept input raise error 
reduction takes place goto table consulted newly recognized nonterminal 
distinction hides fact tables encode part lr automaton really representation optimization yields small efficiency factor accessing encoding parsing tables 
distinction possible nonterminals appear input 
goto table encodes shift actions nonterminals 
alternative uniform vision shift reduce parser action gained discarding goto table encoding action table 
scheme reduction performed removing production stack placing nonterminal back input 
primitive cycle see nonterminal select shift action normally part goto table 
parser state revealed removing stack state expecting nonterminal input 
nonterminal item input shifted 
goto table reduces size parse table number primitive operations giving small improvement parsing speed 
nuisance reduced performance caused removing goto table outweighed benefit making possible modify parser accept input containing arbitrary nonterminals just ones put reduction 
modifications merely include nonterminals sets decide parsing actions 
example take grammar blocks procedure calls sl proc sl sl sl ffl state containing reduction sl 
ffl items sl 
sl 
ffl reduction chosen input follow sl contains tokens proc ordinarily table entry state 
follow set extended include contributing nonterminals case just reduction occur input nonterminal allowing sentences hsi proc hsi proc parsed 
requires new reduction second requires shift part goto table 
language shifts problems parsing language shift example expr term term shift reduce framework similar problems encountered building 
activities substituting alternative lexical analyser 
main difference handling errors caused illegal prefix 
top parser handles error gracefully 
fails production requires illegal input shifted backtracks return possible 
contrast shift reduce parser detects error earliest possible moment 
solution modify parser error behaviour parsing language shifts similar approach taken caml recall parser parse expr production start expr expr expr symbol expr placed input 
second expr required language shift correct position known advance 
parser modified insert correct parsing error 
error occur reasons terminal starting terminal language case lexical analyser returns fail token valid token inappropriate 
parsing resumed hopefully shifting expr reducing expr 
errors input really error 
personal communication note top shift reduce parser may inadvertently accept part part language shift 
formal languages unbalanced square brackets happen 
regard syntax brackets improvement french quotation signs caml 
signs cause problems parsing text languages relational operators style shift operators balanced brackets 
languages common warrant different notation 
summary chapter described design implementation modular context free grammars 
modular cfgs useful describing syntaxes consist large independent modules describing dialects differ modestly base language 
grammars applications manipulate programs conventional data syntactic objects 
manipulations convenient concrete syntax subject language 
described special considerations design implementation parsers allow program fragments efficient pattern matching data structure construction 
exercise modular grammars particular parameterized modular grammars revealed support needed modular grammar 
difficult write program works grammar extended part notation 
problem similar discovered chapter addressed chapter 
techniques developed particular type parsing technique limited backtracking top parsing 
show achieve similar results shift reduce parser 
modular attribute grammars modular attribute grammars solution problem dividing translation task features language 
modular system developed process conventional attribute grammar generalizing statements definitions attribute grammar state 
system developed hand hand executable version written lazy functional language 
development stages 
correspondence attribute grammars lazy functional programs established 
correspondence described johnsson 
give algorithm writing attribute grammar functional program written miranda quite similar johnsson algorithm parse tree shift reduce parser 
second form functional program changed separate concerns calculating attributes nature dependencies 
yielded concise general attribute grammar processor parameterized mapping grammar productions attribute equations 
third interesting stage replacement monolithic mapping productions attribute equations structured composition functions responsible different aspect attribute grammar 
function subject assignment responsibility module 
chapter describes stages 
result modular attribute grammar processor conventional graph theoretic analysis dependencies execution model 
inspired relationship lazy functional languages attribute grammars johnsson result similar respects modular attribute grammars dueck cormack terminology formal description attribute grammar taken 
classical attribute grammars attribute grammars declarative formalism describing syntax semantics translation programming languages formalisms 
syntax provided context free grammar cfg 
semantics translation described set rules calculating attribute values associated nodes parse tree 
attribute grammar ag tuple set nonterminal symbols 
set terminal symbols 
vocabulary set symbols 
start symbol 
set productions 
production written 
set attribute symbols name attribute values 
set attribution rules attribute computations form attribute identification form jpj uniquely identifies attribute production position name 
sequence identifications form function defines attribute identified terms identified attribute written selects nth symbol left production may omitted occurs symbol 
arrow indicates synthesized attribute arrow indicates inherited attribute explained 
parse tree derivation string context free grammar 
leaf labeled terminal 
expansion production derivation represented internal tree node labeled children labeled order 
node parse tree associated set attributes attribute values 
values attributes defined attribution rules 
kinds attribute distinguished depending values defined synthesized inherited attributes 
attribute rule form specifies computation synthesized attribute node parse tree representing expansion production derivation 
form attribute rule specifies computation inherited attribute node th child node representing expansion attribute value value obtained applying values identified denotes value attribute th child synthesized attributes may thought traveling parse tree inherited attributes traveling tree 
attribute rules usually written equations beneath production apply 
order equations importance 
simple attribute grammar illustrates points 
calculates value summation numbers example value expr expr expr expr value expr value expr value expr param expr param expr param expr param expr number expr value number value expr expr value expr param middle rule rule synthesizes value attribute expr value number 
synthesizes value attribute expr value determined inherited attribute called param 
rule sums value attributes subexpressions 
passed inherited param attribute subexpressions 
notice different exprs identified number expr may written expr 
example typical computes value depends contextual information held inherited attributes 
simplistic real application compute structured value number traditional translator compute intermediate assembly code program 
dependencies attribute complex real application inherited attributes computed depending parts input example declaration scalar vector alter operation chosen perform addition 
attribute grammar specifies static semantics attribute production nonterminal may attain value 
dynamic semantics defined static collection dynamic parts functions may invoked multiple times run program 
terminal attributes extend attribute grammar framework include terminals productions 
value terminals numbers identifiers denote particular members class terminals property identify individual text input token 
usually visible attribute grammar single synthesized attribute computed lexical analyser 
allowing terminal place production attribute grammar framework gives programmer control 
single synthesized attribute provided lexical analyser additional attributes may computed making inadequacy lexical analyser responding contextual constraint 
example lexical analyser returns identifier mixed case language supposed case sensitive 
programmer define new attribute identifier letters changed upper case 
example interpreting number context different radix choosing operator depending expected type 
connection lazy functional languages attribute computations declarative ag statement declaring value particular attribute value declared exactly described function values attributes symbols rule attribute value declared 
fact attributes defined functions attributes establishes dependency relationship attributes 
done relationship calculate efficient evaluation order attributes kastens 
resulting evaluators usually place restrictions form dependency relationship 
lazy functional language relieves programmer processor burden determining evaluation order attributes 
normal order reduction lazy language ensures attribute evaluated needed 
sophisticated analysis needed determine attribute evaluation order 
careful naming expressions provided circular dependencies attribute evaluated 
effect dependency analysis done circularities normally permitted feasible just lazy functional language 
key observation laziness functional language applies expressions attribute equations 
value defined tenth element infinite list cyclic definition express iterative computations sequence iterated results 
goal expr goal val expr val expr term expr val term val expr expr addop term expr val addop operator expr val term val term factor term val factor val term term mulop factor term val mulop operator term val factor val factor int int scale factor val int val factor expr factor val expr val int digit digit scale int scale int val digit val int int digit int scale int scale digit scale int scale int val int val digit val digit digit val digit digit val digit scale addop addop operator add mulop mulop operator mul binary arithmetic ag dynamically part evaluation process 
evaluator constructed writing function nonterminal grammar 
function case production nonterminal total function case production 
function case specifies synthesized attributes head nonterminal inherited attributes right side symbols 
running example parts binary arithmetic expressions example knuth reproduced 
example dueck cormack 
example allow direct comparison 
attribute evaluator miranda constructed methodology 
result single program produced single complete attribute grammar 
probably consumer storage keeping iterations possibility expressing iterative algorithms attribute grammar framework worthy investigation 
symbols inherited synthesized attributes attributes goal expr term factor val int scale val digit scale val addop mulop operator binary arithmetic ag attributes anticipation modular formulation call program produced applying methodology monolithic translation 

create syntax data types parse tree labeled productions goal expr expr term expr addop term term factor term mulop factor factor int expr int digit int digit digit addop mulop data structure important thing able identify production 
choice particularly efficient dispatch algebraic type compiled computed jump constant time operation 

determine inherited synthesized attributes nonterminal 
attributes grouped tuples attributes tuple inherited attributes tuple synthesized attributes 

nonterminal nt expr create function nts 
function case production nt general form function case nts production inherited attributes synthesized attributes synthesized attributes production pattern matching production expressions calculating synthesized attribute values 

extend function communicate attribute values symbol right side production 
easily done extending clause line right side symbol defining synthesized attributes appropriate function inherited attributes synthesized production inherited expressions synthesized inherited attributes tuples 
production field production corresponding parse tree letrec scoping rules miranda clause ensure attributes visible expressions denoting attribute values 
applying rules binary arithmetic grammar obtain code 
nonterminal attribution function function parameters derivation tree inherited attributes 
function case analysis productions nonterminal 
example ints dispatches productions single inherited attribute int scale 
function case calculates synthesized attributes function inherited attributes attributes symbols 
construction essentially johnsson differs follows 
target language miranda lazy ml 
second parse tree partitioned separate types yields separate function nonterminal 
relaxed expense permitting illegal productions major concern transformation done automatically 
third johnsson scheme developed investigate attribute grammars functional programming paradigm 
result methodology applied large diverse grammars johnsson unreasonable type constraints nonterminals number identically typed attributes 
avoided tagging 
formulation general attribute grammar processor described attribute grammar evaluator may translated directly program lazy functional language 
synthesized attributes inherited attributes collected single synthesized single inherited attribute 
grammar production function case written calculate attributes 
process abstraction arrive formulation attribute grammar completely independent number form productions number type attributes 
attribute calculations abstracted possible break abstracted parts recombine different ways 
provides method factoring attribute rules separate independent loosely coupled sets modules 
generalizations taken enable general function written place attribution functions parse tree types merged attribute collections reduced uniform type variety individual attribute types replaced discriminated union 
parse tree type redefined components production may selected specific knowledge production parse tree general form consists nonterminal derivations internal nodes terminals leaf nodes 
right side production list constraint length 
production nonterminal production terminal example grammar terminals nonterminals goals expr exprs expr exprs term terms term exprs expr addop term expr val addop expr val exprs expr terms term terms factor factors factor terms term mulop factor term val mulop term val terms term factors factor factors int intval intval ints int factors expr exprs expr ints digit intval intval digits digit ints int digit intval int scale intval int val int val ints int int scale digits digit digits digits pow add mul op add mul add mul pow exp log parse tree demo parse complete evaluator binary arithmetic language parse tree int int digit digit sentence miranda data structure int int digit digit zero representation parse tree nonterminal goal expr term factor int digit addop mulop terminal lpar zero plus times type definitions special case miranda algebraic types analogous enumerated scalar types pascal ada 
relates input sentence parse tree miranda data structure representation 
set synthesized inherited attributes production generalized tuple attribute identified position explicit mapping attribute names attribute values 
implies attributes type new attribute type tagged union original attribute types 
example attributes attribute types 
mapping implemented list name value pairs attribute val operator scale num op attributes attribute definitions say attribute names val operator scale 
types attribute values attain numbers operators 
numbers tagged operators functions attribute types values returning third tagged op 
mapping attribute names values declared type abbreviation attributes 
convenient collect inherited synthesized attributes node production node node production attributes attributes attribute calculations production fall similar general pattern 
attribute calculations single production specify calculation attributes nodes 
specify calculation synthesized attributes symbol inherited attributes symbol 
calculations require synthesized inherited attributes symbols production 
process deciding attributes calculate depends production 
production identified attribution thought set partial mappings attribute names attribute values mapping symbol production 
attribute calculations captured function production 
node 
node 
attributes attributes function calculates attribute values production grammar production argument determine production 
takes attributes visible rule arguments attributes symbol left collected single node attributes symbols right list nodes 
value returned pair set attributes synthesized attribute values left side symbol list sets attributes inherited attribute values right side symbols 
function completely generic evaluator function synthesize prodn inh synth prodn synth root rhs syn map synthesize rhs children map node rhs syn prodn node prodn inh syn children synth syn syn prodn node prodn inh syn notice arguments passed depend values returned function 
expresses complex dependencies possible attributes 
possible state directly miranda lazy language 
ag undefined circularities evaluation fail terminate system report infamous black hole message attempt reduce cyclic redex 
generic part attribute grammar data type production function synthesize 
specific attribute grammar determined definitions terminals nonterminals attribute attribute type 
attribute calculations written function case production case terminal 
general form function shown 
naming conventions tree pattern matches tree symbol attribute name attribute value type attribute 
synthesized inherited 
expression calculating value attribute named attribute node miranda variable bound node holding inherited synthesized attributes symbol expressions synthesized attribute inherited attribute written respectively node node functions infix operators recover value attribute node 
note terminal naturally symbols right side second list pair empty 
data type representing parse tree opened allows illegal trees clause function raises error 
tree tree tree head body synthesized attribute synthesized attribute inherited attribute 
inherited attribute inherited attribute 
inherited attribute node node node body production head body 
terminal head body synthesized attributes terminal 
head body error illegal parse tree general form attribute calculation function description probably sense example considered 
miranda code production ag corresponds directly conventional ag definition 
easier write description suggests 
productions binary arithmetic expressions ag int int digit int scale int scale digit scale int scale int val int val digit val corresponding function case production int int digit head body val add int val val scale add head scale scale head scale int body direct translation original production performed quite simple preprocessor 
pattern matches production int int digit 
looks slightly complicated match inspect subtrees left hand side determine type 
add function takes returns values type tagged union attribute types defined add 
critical feature function case written body decomposed list case chosen 
essential 
temptation move pattern matching body top line dispose name body altogether resisted causes program fail 
pattern match body evaluated length body known 
length determined result calls map map synthesize turn result calculated function case 
committed choice structure result calculated pair lists build sufficient body allow pattern match 
demand driven nature lazy evaluation allows write blatantly recursively defined program great care taken prevent value needed possibly calculated 
strict adherence general scheme prevents particular pitfall 
modular decomposition attribute calculations removed mechanism traversing parse tree placed function called 
function replaced give different attribute grammar context free grammar attribute grammar calculating values expressed different way 
particular calculations may expressed combined result functions 
function responsible aspect calculation plays role module 
possible organize functions decompose problem different parts syntax different sets attributes 
call axes decomposition syntactic modularity semantic modularity respectively 
convenient name type module 
attribution function plays role module declare type function type abbreviation module 
module production 
node 
node 
attributes attributes module syntactic modularity limited amount syntactic modularity achieved original translation scheme required separate function written nonterminal 
actions single nonterminal changed replacing function 
functions independent call attribution functions symbols productions 
ag written smaller number modules mind 
different syntactic things belong subparts larger single concept things belong definition objects 
example grammar may conceived grammars expression grammar productions number grammar 
attribution function modified allow similar functions reflect natural decomposition grammar 
module formed omitting cases syntax belonging module 
isolation modules undefined syntax removed 
signalling error syntax tree recognised module invoked handle unrecognized cases 
done writing name default module production attribute grammar module 
default module parameter module writing commitment structure language modules composed module expressions default productions appear default module numbers default productions appear default module main expressions numbers error translation extension miranda straightforward 
module curried function default module parameter 
module composition function application expressions default head body head body 
default numbers default head body 
head body default head body error expressions numbers cases clause local definitions identical corresponding cases original function 
case written parameters miranda curried language correct concise way passing parameters default 
semantic modularity preceding section showed ag decomposed syntactic modules 
basic approach responsibility different parts grammar different modules functions 
simple structure attribution function dispatch syntax 
semantic decomposition calculation different sets attributes different modules 
attributes temporally ordered sequence sets attribute names attributes name set may evaluated name set semantic modularity expresses phase oriented decomposition 
complications arise attributes available functions calculating attributes 
decomposition guaranteed phase oriented simple implementation 
set attributes calculated order function previous set 
conveniences shall discover possible 
practical terms necessary collect combine attributes calculated module function 
module computes subset attributes 
easily accomplished function simply omits calculation attribute value pairs responsibility 
attribute local subset productions 
example ag attribute scale appears factor int digit productions 
cases necessary specify case productions 
cases contribute simply omitted writing module 
module computes attributes important productions define attribute 
module defines scale attribute defined leaving module scale factor int int scale int digit digit scale int scale int int digit int scale int scale digit scale int scale modules communicate attributes define attributes 
example typechecking module assign value type attribute expression subexpression 
attribute code generation module select appropriate instructions 
type attribute export type checking module import code generation module 
attributes calculated modules need combined 
module computes node partial set attributes partial mapping attribute names attribute values 
module contributions collected get complete set attributes node 
union suitable way combining partial mappings 
function override operator suitable flexible 
function override operator phi defined phi fx 
dom dom dom function domains disjoint union function override produce result 
domains overlap function override defines definite value may possible enforce miranda translation declaring module type polymorphic attribute names calculated module production 
node 
node 
attribute type attribute type modules contain free attribute names provided form parameterization 
value defined function effect modifying behaviour module defining general patterns attribute calculation refined modules 
module calculate synthesized attributes left side symbol node inherited attributes right side symbols 
combine results modules partial map produced module combined corresponding partial map produced 
comb operator 
takes attribution functions returns new attribution function computes combined results 
identity value comb attribution function specifies attribute values 
left right identity 
default case module returns empty partial map left hand side symbol right hand side symbol 
functions complete general part modular ag evaluator 
comb module 
module 
module comb prodn head body map prodn head body prodn head body module head body rhs head body map const rhs modular programming combining form modules allows software engineering practices 
modules compute different attributes interfere 
coupling modules restricted forms interaction 
module may values computed modules 
described attribute names form narrow mutual interface 
constraining form coupling occurs modules calculate attributes 
syntax defined modules disjoint interaction 
hand modules define attribute syntax latest module rightmost combined modules takes precedence 
latest module redefines actions previous modules 
viewed process explicit refinement module defines new level refinement iterative refinement iteration formed adding new re definitions rewriting original program keeping history refinement process 
view module precedence form object oriented programming 
early modules correspond specialized classes 
modules refine previous classes 
section shows general statements statements 
module refine stating assignment statements differently 
module combination method shares object oriented programming essential property common behavior shared different objects defined 
points taken section 
generalized modules classical attribute grammar production applies grammar production calculates fixed set attribute values 
introduced modules allow syntax attributes factored programmer needs complete knowledge syntax construct complete attribute grammar 
investigate benefits obtained replacing parts typical attribute grammar production general term 
expected benefit reuse 
general form shorter equivalent ag understandable 
stated times possibility instance may differ 
intentional case difficult spot deviation general case 
difference unintentional bug hard find similar looking cases 
lot scope generalization typical attribute grammar definition 
take example definition comma separated expression list 
environment symbol table passed inherited attribute 
expression list synthesizes code attribute list code attributes synthesized individual expressions expression list collects code expressions 
module expression list expr expr env env env env code expr code code expr expr env env code expr code generalization done concentrating part definition making part restrictive 
name definition env replaced new name 
names written starting upper case letters italics distinguish existing concrete names written entirely lower case 
new name treated determines type generalization 
distinguish types generalization widening abstraction quantification 
definition left new name free 
called widening 
may substituted new name widening generalize pattern matching 
definition may formalized declaring new names formal parameters new definition 
called abstraction parameterization 
example expr replaced xlist respectively 
notation abstraction placing formal parameters parentheses module name 
concrete module obtained substituting back concrete names parameters expr eliminating formals 
called instantiating abstraction 
abstraction quantification instantiating suitable names 
miranda syntax list expressions lists items written commas square brackets separated commas empty list list append operator 
difference widening quantification quantification elements sections various parts grammar definition determine notational conveniences obtained doing 
abstractions investigated ones feasible programming language 
partly result developing ideas concert writing functional attribute grammar processor describe 
generalization production patterns classical attribute grammar specifies set attribute calculations production underlying context free grammar 
production may widened replacing pattern matches productions cfg 
previous example productions attribution rules uniformly replacing expr xlist yields module list code xlist xlist env xlist env xlist env xlist env xlist code code xlist code xlist env xlist env xlist code code production pattern match production consistent substitution grammar symbol names xlist 
typically include lists example formal parameter lists variable lists pascal variable declaration 
production patterns formed means replacing terminal nonterminal free name 
dueck cormack ellipsis notation indicate zero symbols production 
pattern example notation identifies rightmost symbol production symbol 
notation treats sequence symbols 
symbols indexed subscripts may appear indexed attribution equations 
example aspect code generation depends compiler option 
compiler options need transported parts parse tree 
simply stated general rule options options ng symbol inherits options attribute 
attribute calculation replicated special case empty production handled expected symbols attribute calculations generated 
production patterns particularly important key contribution dueck cormack 
allow production pattern small fixed number stand arbitrarily large set productions 
options example single production pattern applies language 
mechanism module reuse module duplicated apply matching rule grammar 
blindly substituted 
widening requires substituted items legal testing quantification generative 
generalization abstraction part definition may abstracted 
abstraction describes general property apply specific instance instantiation 
instantiation requested programmer reuse modules controlled programmer 
attributes may abstracted 
allows describe patterns attribute calculation having fix names attributes involved 
production patterns may abstracted allowing common definitions selectively applied similar pieces syntax 
functions attribute calculations may abstracted provide higher order calculations analogous mapping 
demonstration abstraction apply abstraction code list module naming abstracted parts 
non module disadvantage unit production case applicable 
apply unwanted productions expr term desired productions expr 
abstraction obtain control module instantiate example exprs 
instantiated modules combined module override operator phi module code list xlist xlist xlist env xlist env xlist env xlist env xlist code code xlist code xlist env xlist env xlist code code module desired lists code list expr phi code list defn pervasive inheritance seen example pervasive inheritance compiler options example 
attribute name generalized provide pervasive inheritance particular attribute 
module pervasive inheritance parameterized attribute name 
instantiation pervasive inheritance options yields compiler options example module pervasive inheritance ng note equation replicated symbol bucket brigade languages require derivation tree processed left right traversal 
case languages pascal named things may definition program text 
left right traversal derivation tree equivalent pass traversal source 
attribute grammar phi function override operator module override operator 
correct operator apparent context 
property called regular right part attribute grammar 
bucket brigade module describes attribute dependency 
attributes carry information downwards direction second carry tree module bucket brigade ffl ng level derivation tree value passed left chained right part production passing subtree turn 
passed right 
case null productions terminals value passed straight right side 
module additional needed 
bucket brigade just threads value tree computing useful 
module instantiated desired attribute names 
second inherited attribute defined axiom grammar 
productions useful computation alter value attribute 
simple example module get vars computes set variable names program 
module get vars bucket brigade set set phi get vars detail module get vars detail axiom prog prog set variable ident variable set variable set top level set initialized empty set 
set passed tree bucket brigade variable appears added set 
retrieving set top level gives set variables program 
harvest sow bucket brigade processes things left right order 
ideal languages pascal items defined 
alternative supported languages items scope mutually visible 
easily specified harvest sow module 
definitions harvested scope incorporated environment 
module harvest ng module harvest sow harvest phi pervasive inheritance bucket brigade need interface behaviour defining scoping constructs language 
assume syntactic sorts definition scope 
module environment harvest sow env defs phi scopes phi definitions module definitions defn define ident thing defn defs module scopes scope things things env scope env phi things defs scope defs scope env definition simply tiny environment containing 
multiple definitions collected harvest module 
scope boundary things happen definitions inside scope added definitions outside scope definitions inside scope invisible outside 
conjunction harvest sow module definition scope modules deal specific constructs affect constructs 
definition resilient changes parts language example expression syntax 
harvest sow module similar bucket brigade provide passing variable tree 
advantage harvest sow approach individual definitions affect attribute 
bucket brigade fundamental possible code harvest sow bucket brigade way round 
example bucket brigade collect definitions scope attributes job defs attributes 
sense bucket brigade incremental version harvest sow paradigm potentially efficient subsets definitions added 
generalization quantification consider grammar hierarchy expression nonterminals purely enforce syntactic operator precedence precedence hierarchy defined 
expression derivation tree expr term factor number unit productions carry semantic information 
rules term written term factor factor env term env factor type term type term code factor code 
copy rule attribute 
traditionally copy rules automatically inserted attribute grammar processor 
collection inherited attributes symbol called context symbol 
context mapping attribute names values 
notation stand context membership predicate test context defined attribute name shorthand domain 
implies error 
analogously collection synthesized attributes symbol called symbol 
term meaning nord pfenning alternative writing copy rules quantification factor attr term attr attr term term attr factor attr attr term cases symbol entire context defined symbol context convenient omit quantification directly say symbol context term factor factor term term factor unit production copy rule production patterns allow explicit copy rules example generalized 
useful case unit production copy rule 
rule applies unit productions 
unit productions semantic meaning module useful reusable component 
module unit production copy rule similar situation occurs bracketing constructs 
bracketing constructs occur languages usually allow programmer group things program clearer emphasizing existing groupings 
examples parentheses expressions blocks imperative languages 
bracketing may alter input parsed little impact semantics language 
general definition bracketed illustrates abstraction production patterns quantification 
definition may instantiated terminals parentheses invisible semantic analysis language 
module brackets left right left right list abstractions notations contain lists sequences things 
handle concise efficient manner necessary complexity individual list forming productions 
special list facilities available metaprogramming systems ergo attribute system caml sdf 
necessary modular attribute grammars useful compact syntax description 
syntactic lists isomorphic list data structure provided easily constructed programming languages 
sections show modular attribute grammars exploit creating attribute view list derivation tree list data structure 
conventional programming operations mapping filtering list data structures 
list abstractions insulate programmer particular concrete list syntax subject language 
lists module defines attribute calculations comma separated list items 
generalization expression list defined chapter 
module generalizes syntax attributes 
module list list item list item list attr item attr attr item list item list list attr item attr list attr attr item generalization produces list values attributes list items 
example list produced synthesized attribute items 
specified quantifying attributes 
list productions called base case inductive case 
attribute base case value singleton list containing value corresponding attribute item 
inductive case prepends new item attribute value front list 
lists list zero items may empty 
usually empty list case little semantic import 
example take list separator list items 
programmer attributes look previous type list 
module zero list list item list list attr synthesized attributes list item list list attr item attr list attr attr item base case synthesizes possible attribute 
left associative lists lists right associative derivation tree collects items list right 
derivation tree skewed right 
left associative lists produce derivation trees skewed left 
left associative list list item parts way round inductive production 
base production list item list attr item attr attr item list list item list attr list attr item attr attr item difference attribution rules arguments list append operator reversed 
discussion list examples raises interesting issues convenient 
possible associate single type attribute name 
attribute item type ff attribute list type list ff 
attribute grammar list module allows type assigned symbol attribute pair list module preserves property stated relationship 
lists lists synthesize attributes lists underlying attribution language 
systems take approach 
notably caml cousineau huet distinguishes lists lists 
lists list type lists type theta type individual elements 
sensible type checking point view constructed value member type members type constructed parsed input 
compares approach empty list correct type list 
believe product type lists inconvenient programmer nearly want treat items list way 
empty lists problem synthesize large number attributes value empty list data structure 
non empty list synthesize fewer attributes empty list 
leaves different kinds undefinedness attribute empty lists synthesize empty list data structure non empty lists synthesize attribute 
predicate list attr different attr list 
partial solution problem parameterize list module attribute set attributes synthesized 
notations manipulating syntactically bound structures convenient data structures benefit wadler 
manipulation data types isomorphism discussed views wadler 
monad comprehensions wadler miranda list comprehensions apply data type cons nil constructors viable alternative notation programming list attributes recourse actual list data structures 
summarize universal quantification attributes useful describing default copy rules indicating language constructs semantic importance 
useful imposing convenient data structure view parts derivation tree 
traditionally attribute grammar processors inserted copy rules points mentioned 
ability state rules concisely means automatic copy rule insertion really needed 
higher order operations conventional attribute grammars non interchangeable concepts derivation tree attributes 
possible define attribute part structure tree vice versa 
vogt define higher order attribute grammars extending attribute grammars new operations permit operations vogt 
derivation tree type may manipulated data type attribution language 
convenient linear form somewhat prolog terms writing tree expressions 
new capabilities ffl attribute derivation tree ffl nonterminal tree valued expression simplest 
derivation tree available direct inspection 
example new trees may constructed parts current tree 
second allows parse tree modified 
nonterminal cfg may specially marked nonterminal attribute nta 
nta may assigned 
parsing nta treated single null production affect language accepted 
attribute evaluation nonterminal defined value expression 
nta attributes nonterminal derivation tree 
attributes nta may normal attribute evaluations production 
constraints dependencies example synthesized attribute nta decide tree assign nonterminal 
vogt mechanism write multi phase compilers 
phase calculates new transformed version program processed attribute grammar framework 
explicit manipulation contexts provide similarly powerful notation 
context derivation tree node diverted pass computed tree 
previous chapters shown syntax constructors syntax patterns offer convenient way specifying parse trees notation description 
production pattern seen shorthand special case flat unnested syntax pattern 
equivalent term factor term list list item list flat equivalent term second case nonterminals syntax pattern variables 
general require parsing syntax pattern text run time match cause syntax errors attribute evaluation time 
restricting cases variable nonterminals flat patterns alleviates problem 
reasonable restriction patterns variable nonterminals meta statements grammar meaning independent particular grammar 
addition syntax constructors syntax patterns example illustrates local attributes 
local attributes attributes local set attribute calculations attached part derivation tree 
part symbol context visible inherited synthesized attribute symbol production visible module 
name sub computations notational convenience prevent repeated computation 
simple transformation rule empty set notation may written factor ffi ffl trans factor trans factor factor trans local attribute trans calculated new derivation tree replace original 
tree effectively spliced original tree diverting context symbol new tree new tree back original production 
simple cases context copied directly transformation abbreviated notationally optimal form overwriting transformed tree factor ffi ffl factor overwritten 
form merely convenient abbreviation previous version 
sufficient copy context unaltered 
attributes conditioned new tree 
situation occurs counter generate new names 
time new name required generated value counter counter incremented 
counter called gensym lisp function name yields new unique symbol time called 
take problem replacing wildcard pattern ml prolog haskell unique name 
time wildcard pattern encountered replaced freshly generated name 
value gensym attribute incremented processing transformed pattern 
may written ways 
uses quantification copy attributes gensym handled specially 
pattern new pattern name number string pattern gensym new attr pattern attr attr pattern new gensym pattern gensym pattern new alternatively context seen function overridden exceptional case 
convenient notation 
new pattern phi 
pattern gensym context pre processed translation transformed tree 
naturally may post processed 
higher order attribute grammars scope circular dependencies 
avoid circularities replacement tree calculated attributes depend replacement 
rewritten tree local attribute transformations specified module transformations invisible modules 
safer alternative transformed attributed tree attribute local single production module 
way programmer forced decision tree attribute taken leaving module composition 
vogt write tree write tree puzzle transformations separate modules give surprising results 
particularly surprising thing subsequent modules override action transformation see untransformed tree 
reason suggest transformation purpose attribute grammar just steps 
possible transformed program multi phase application 
rest section describes phenomenon detail posing puzzle explaining answer 
works module composition operations detail 
grammar extended peano numbers 
peano numbers enumerated repeatedly successor zero 
numbers ss algebra extended double successor operator equivalent successor operators ss 
grammar number num num num num num num equivalence forms defined transformation module replaces form module transform num num equivalently module transform num new num new num num new observe transformation calculate value depends directly shape tree 
simple function tree number nodes tree calculated summing sizes subtrees node adding 
terminals count node 
count module parameterized twice module count sum sum delta delta delta sum number num new num num num num parse trees main module module main count pre phi transformation phi count post grammar completely described ask question main calculate input 
answer calculates pre post count pre counts number nodes transformed tree count post counts number nodes original tree 
thought surprising earlier module sees larger transformed tree module doesn 
parse tree input transformed part ss shown 
module overrides calculations previous module 
equations node module table contexts omitted empty 
node node pre node node post count pre count post number num pre fg num post num pre num pre new post num post num pre fg post num new pre num pre fg pre num post num pre num pre fg post num post num pre fg post node num 
pre num phi new phi 
post num 
pre num phi 
pre num phi fg phi 
pre num phi 
post num 
pre num phi 
pre num pre post 
pre num phi 
post num 
pre num pre post 
post num seen pre takes value transformed tree num post takes value original tree num 
implementation generalizations previous sections described useful widely applicable modules written generalizations traditional attribute grammar scheme 
cases generalizations implemented analogous features miranda defining module functions 
abstraction accomplished abstraction 
example seen section syntactic modularity section 
module parameters written parameters function returning module module ag ag pattern head body 
parameters scope entire module body local definition ag desired effect 
production patterns usually implemented pattern matching parse tree 
recall tree node production lhs rhs represented lhs rhs lhs internal program name symbol rhs list trees representing derivation trees ordinary production factor unop factor implementation pattern factor unop factor right side constrained trees tagged symbol unop factor 
constraint derivation tree nodes 
say factor tree valued expression stands entire construction factor 
production pattern variables relaxes constraint symbol values symbol values may constrained op op general case production pattern replaced predicate prodn body matches prodn preferred choice compilers produce better code pattern matching especially matching similar patterns 
predicate conjunction pattern 
necessary predicate example pattern contains names module parameters list modules 
function definition written curried form parameter names pattern part new names fail constrain production pattern correctly 
correct way handle predicate explicitly test equality 
module list coded list list item ag ag list item head body list list item item 
pattern translated general production pattern lhs rhs 
tree symbol may obtained list indexing rhs number length right side rhs 
production patterns written syntax patterns ffi ffl notation implemented ordinary patterns compiled techniques described chapter 
quantification expression repeated iterated construct naturally implemented loop 
miranda metaphor loop list comprehension 
loop quantified range written expr range 
synthesized attributes generated separate lists symbol production 
access written rhs definition attribute accomplished adding pair value th list inherited attributes 
pervasive inheritance module written attr ag ag lhs rhs attr attr rhs ag complex case attributes defined overlapping sets symbols constructed looping symbols building attribute set symbol index appropriate set 
rule compiled code module name lhs rhs head body attrs rhs attrs phi semantic patterns syntax insufficient match production 
example module rule op val apply op op operator val val detect binary expressions 
translated miranda definition ag op head body val apply op opa operator la val ra val la opa ra body rule match production symbols right side example stmts stmts stmt 
example lead error attribute evaluation time stmts asked val attribute synthesize operator attribute 
symbols fulfill promise synthesize val operator attributes 
module rule extended match symbols synthesize required attributes 
extended code looks ag op head body pair pair val apply op opa operator la val ra val opa synthesizes operator la synthesizes val ra synthesizes val dummy void la opa ra body code synthesizes val attribute required attributes defined 
defined dummy attribute synthesized place 
recall section basic form attribution function developed noted parameters head body decomposed parts accessed pattern matching committed 
necessary avoid cyclic redex reason dummy attribute synthesized right side symbols synthesize required attributes 
debugging module debugging module synthesizes debug attribute textual picture attributed parse tree 
production node attributed tree printed list attributes values 
debug attribute omitted list attributes cause infinite regress debug attribute contain printed description 
symbols indented order symbol printout inorder traversal attributed tree 
module useful debugging attribute grammars run small inputs 
large inputs volume output overwhelming idea pass predicate filter unwanted parts tree 
plain version module sketched notation fag pi taken notation spivey called domain subtraction denotes function behaves undefined debug show syn map image pia inh map image newline indent debug ng map image flatten show mg debug show newline module assumes greater reflective capacity attribution language previously 
show function assumed take object return printable representation 
assumes modified passed value function 
rules translating modules miranda cover points module raise special issues generating efficient code discussed section 
sources inefficiency sources inefficiency general attribute grammar processor 
source traced stage generalization attribute grammar processor 
small grammars modular miranda program times slower equivalent unstructured program written rules section 
pinpoint discuss individual sources inefficiency 
section describes efficient evaluator may generated description 
compare behaviour program evaluates modular attribute grammar classical attribute grammar processor ffl parse tree pattern matched module 
classical processor identify production constant time production number 
case modular case pattern determines shape parse tree node identity 
ffl partial attribute sets computed module combined 
classical processor analogous 
ffl attributes accessed searching context 
classical processor accesses attribute record field global variable optimized processors 
ffl values system tagged type 
tagging incurs penalty constraining type system classical ag incur 
factors affecting run time size parse tree 
number nodes parse tree 
number modules 
module inspects parse tree node 
pattern match parse tree module 
attribute sets computed module combined gamma combinations parse tree node average complexity pattern match module 
proportional size modules cases nearly constant pattern matches algebraic data types compiled small trees case statements 
average number attributes associated parse tree node 
affects combination attribute sets 
combination current implementation 
affects access time attribute 
linear search attribute takes time 
factors interact 
rough analysis 
easiest combine factors thinking grammar evaluation place steps setting attribute equations reducing attribute equations 
reality thoroughly interleaved process lazy evaluation 
setup time comprises theta theta time spent pattern matching tree theta gamma theta time combine partial attribute maps equation evaluation stage calculates value attribute node 
assume equations average small constant number attributes reasonable assumption rules simple copy rules attribute space divided small sets related attributes 
time na theta second incurred looking attribute values 
gives time theta theta theta theta na theta number attributes probably grows faster size modules dominant term 
compare na classical attribute grammar na attributes calculated order 
removing inefficiency previous section identified sources inefficiency miranda program models modular attribute grammar 
modular attribute grammars realistic tool inefficiencies removed 
section discusses done 
basic idea transform modular program produce unstructured program overheads due module operators concessions uniform representation allow operators 
ideas section tested producing program transformation 
ideas point areas open research 
modular program inefficient lots pattern matching attributes stored discrete maps combined look attributes values values tagged 
little done modular attribute grammar 
underlying context free grammar known information guide derivation specialized version modular grammar 
specialized version look expr expr addop term expr term prodn inh synth prodn synth expr expr addop term syn expr addop term children node expr node addop node term syn prodn node prodn inh syn children synth expr term syn term children node term syn prodn node prodn inh syn children grammar fragment corresponding specialized version synthesize 
note intermediate results visible named 
program 
sections describe achieved restrictions placed attribute grammar modules help process 
syntax syntax known modular grammar specialized produce set attribute grammar processors nonterminal 
set built specializing synthesize function page axiom production produce function synthesize axiom 
specialized synthesize nonterminal written case production nonterminal 
case production known call map synthesize unfolded calls synthesize replaced calls appropriate specialized versions 
example result transformation 
transformation program top level structure evaluator derived section nonterminal function function case production nonterminal 
task specialize attribution function 
done symbolically executing function production doing possible limited information production template 
achieved single small number productions module selected case calls comb completely unfolded 
attribute sets keeping attributes mapping names values causes inefficiency construction map accessing attributes 
current implementation phi operator assumes attribute names compared equality 
map represented unordered list name value pairs 
maps lengths operation phig takes time theta 
ordering placed attribute names ordering efficient representation 
example map stored ordered list 
operation phi implemented unbalanced merge preferring complexity 
lookup 
example map implemented balanced tree 
phi operation implemented successive updates giving time log access time log 
better approach change representation infer exact structure attribute map replace map tuple constructed tupling operation presumably accessed projection functions 
possible infer structure partially known data types latest techniques partial evaluation discussed feasibility 
aid inference tuple structure necessary choose data structure property final shape regardless order operations construction 
allows lookup operation replaced precomputed direct access function attribute stored place 
problem shape data structure arises attributes nonterminal specified different order production 
balanced trees desired behaviour unordered lists certainly don 
ordered lists property 
attribute map operations reduced single constructor function set projection functions map isomorphic tuple operations replaced tuple operations primitive operations probably efficient 
tagging type inference detect type tag 
attribute map replaced tuple constraint attributes type lifted type tags removed 
really extension operation converting map tuple 
tagged case attribute map represented ordered list structure projection function function returns part argument 
projection function projects point axis 
attr value attr value attr value converted tuple value value value assume inferred map structure attr tag attr tag op 
map structure attr value attr value attr op value converted tuple different types slot value value value feasibility believe specialization approach converting modular attribute grammar monolithic ag feasible developed technology 
major techniques specialization driving interpretation type refinement 
specialization symbolic evaluation function partially determined value 
expressions function marked known static unknown dynamic specialization time 
operations static values performed specializer residual code generated performed operations dynamic data 
driving technique seeding partial evaluator sufficient information generate interesting specializations partial evaluator tries generate infinite program 
example attribute evaluator specialized respect productions nonterminal 
partial evaluator eager description grammar try generate specialized function possible parse tree 
prevented guiding partial evaluator giving nonterminal time 
partial evaluation requires degree interpretation decide value known unknown specialization time 
information interpretation 
fuse partial evaluator weise ruf scheme uses interesting technique concrete values interpretation far possible 
concrete value combined symbolic value information lost 
fuse able deduce information data structures authors give example environment updated unknown list assignments 
partial evaluator deduce bindings environment stay place assignments unknown 
power determine position attribute maps 
test example tried phi operator verify 
type refinement replacement data type operations 
arity raising mogensen kind type refinement 
arity raising splitting compound object passed argument function parts passing separately 
transformed function parameter part arguments raised arity 
arity raising data structure partly known parameter known list unknown items 
efficient pass items separately construct list pull apart inside function 
clear refinement attribute map tuple similar transformation arity raising 
parse tree data type may refined 
original monolithic translation gave example parse tree representation efficient general representation subsequently production unique tag means part parse tree node needs inspected identify production 
modular program specialized respect context free grammar need general representation decision particular production module rule match precomputed specialization process 
remaining pattern matches serve purposes 
residual match pattern patches flat unnested production identifies subtrees production 
non flat pattern specified higher order attribute grammar pattern expr ffi expr term term ffl remaining tests 
cases original parse tree data type production nonterminal production terminal replaced type tagged union tag production tag terminal 
constant terminals empty productions substructures productions tree substructures value terminals data identifier name tree tree tree tree tree ct ct ct ct vt datum vt vt datum vt substitution type straightforward care taken convert instances includes construction replacement parse trees modules higher order attribute grammar rules 
benefit type refinement dispatch specialized functions synthesize expr compiled constant time operation tags topmost tree data structure differ 
features modular attribute grammar notation modular miranda program warrant discussion 
partial evaluation handle higher order functions quantified rules semantic matching 
higher order functions problem functions map comb need unfolded achieve required specialization 
rest specialization order 
latest partial evaluators handle higher order functions case bondorf 
quantified rules pervasive inheritance module look hard handle symbolically remember right side production known specialization time loop unrolled symbolically 
awkward thing handle semantic matching pattern matched symbols synthesize inherit appropriate attributes section page 
context free grammar attribute map domains static removed partial evaluation 
generating dummy attribute semantic match fails changes shape attribute map making dynamic determined run time possible reduce specialization time 
way avoid prove single production question semantic match true false 
task essentially performed dueck cormack analysis global property attributed grammar 
clearly league current partial evaluators perceive need proof 
approaches problem partial evaluator special knowledge built job modular grammars written carefully require semantic matching 
obviously preferable removes unnecessary burden programmer 
give example grammars written carefully 
consider binary operator pattern section 
pattern op pattern general 
replaced patterns addop mulop convenient notation replacing op op maintaining single pattern easier rob power modular grammars satisfactory solution 
designing modular attribute grammars modular attribute grammars described apt discuss issues involved design modules 
attribute grammar modules guarantee clean reusable design tool misused 
coverage term coverage mean set entities module way affects 
syntactic coverage module set productions module defines attributes 
semantic coverage module set attributes calculated module 
convenient group related productions attributes consider coverage separately 
parameterized modules may course variable coverage depending particular instantiation parameters 
coverage module depicted filling grid 
square indicates interaction syntactic semantic feature 
square marked module specifies interaction 
syntax syntax syntax semantics semantics semantics 
attributes general syntax type attributes general syntax type attributes specific syntax type attributes specific syntax type module types ability modules define behaviours attributes general manner recourse specific productions allows coverage grid filled 
ability possible fill diagonal grid 
shortcomings investigations solutions chapter 
attribute grammar modules offer neat solution coverage problem 
issues different semantic modules contribute language description different levels generality 
modules define general rules coverage define specific details implementation small parts language 
modules roughly categorized precision pinpoint language features cover shape coverage 
categorization implications software engineer specifies modules combined 
pays remember modules combined module refining definitions provided previous module 
consider axes attribute coverage syntax coverage values indicating general specific applicability 
clear type modules refine general statements types module type modules refined types module 
clear type modules refined type modules way round 
takes semantics attribute oriented stance type modules refined type modules 
stance acceptable semantics important syntax 
concrete example compare coverage modules earlier 
type module listed withe module 
module type chosen illustrate interact 
unit production copy rule type get vars bucket brigade type get vars detail type list instantiated variable type experiments undertaken similar modules combined order 
discipline order modules give conflicting definitions 
unit production copy rule module matches productions attributes clearly basic general behaviour type module 
list module type module 
specific part syntax general attributes 
general syntactic behaviour module 
bucket brigade module restricted small number attribute applies wide general syntax 
get vars detail module type module 
specific concrete productions concrete attributes 
type modules usually instrument change language new similar language 
modules frequently composed submodules example get vars page 
type module composed submodules different types 
difficult question answer mixed type compound module behaves part submodule types type parts harmless generalizations previous modules combined compound module lower types may override refining effects previous modules 
topic thoroughly investigated deserves attention 
approach combination mechanism sensitive module types combine modules ordering types 
raises question modules inherently mixed type example module written special specific case preceding general case module type recognised automatically 
refinement revision module composition overriding offers opportunity program refinement 
new module modify behaviours specified earlier modules 
mechanism allows different programming practices ffl refinement 
new module provides specific behaviour previous general module 
example get vars module page 
get vars detail submodule provides refinement general bucket brigade instance 
ffl incremental extension 
language extended extending concrete syntax adding modules provide refinements required new features 
ffl revision 
interesting language prototype implementor alter meaning part language 
simple example generate additional code gather statistics say time variable referenced 
prototype builder want alter behaviour new special cases example convenient implement self pseudo variable object oriented language interposing module handles case 
modules perform function different ways complete language module converted language module composing attribute grammar alternative module 
example consider modules stack frame management 
module implements stack frames linked lists second offsets stack array 
implementation imp built module 
implementation built imp phi module reads language imp linear stack 
example consider implementation csp hoare 
different semantics alternative command permitting module env goal env env env env def module def def env def def def env dueck cormack bucket brigade 
quick explanation left symbol inherits env left part symbols inherit env def attribute synthesized left neighbour 
empty production sends env back synthesizes def attribute def synthesized rightmost symbol symbol terminal synthesize def env passed def user errors committing choice immediately 
implementation csp constructed composing implementation alternative module 
comparison dueck cormack similarities modular attribute grammars dueck cormack interesting detailed comparison 
dueck cormack modular attribute grammars define language implementation 
single mag set patterns associated templates 
patterns applied context free grammar 
match production pattern set attribute computations generated 
matching computation generation constrained pattern matching uses definability generated computations selected need 
dueck cormack define new concepts 
angles compare modular attribute grammars dueck cormack 
comparison expressiveness notations 
second compares implementation issues 
model derivation attempts describe attribute computations modular framework approach dueck cormack solution bear number similarities 
origins approaches differ 
approach generalization attribute grammar evaluator 
evaluator generalized stretched provide modular facilities projected back attribute grammar notation 
influenced result modules composed order production patterns applied order versatility production patterns reflects ability underlying evaluator 
contrast dueck cormack developed preprocessor standard monolithic attribute grammar evaluator 
module coupling dependence modules communicate attributes import attributes define export 
analogy module importation weak module may compute attribute 
system provides notation defining imports exports restraint 
modules may define particular attribute 
raises question resolve conflicts attribute values calculated different modules dueck cormack avoid issue tend stick safe methodology defining attribute module 
approach define order modules applied 
modules override decisions previous modules 
expanded programming methodology refinement 
systems allow definition mutually dependent modules 
example mutual dependence appears bucket brigade 
mutual dependence gain phase oriented decomposition module depends previous module allows different related concerns described independently placing execution order parts computation 
syntax abstraction pattern matching nature modules provides tool abstracting away concrete syntax 
traditionally implementor construct syntax tree parsing write attribute grammar syntax 
syntax constructed phase attribute grammar processed phase 
translation concrete syntax syntax simple 
dueck cormack describe patterns directly concrete syntax syntax 
identify common mappings concrete syntax grouping elision 
grouping concrete syntax different nonterminals similar meanings represented syntax nonterminal 
expression hierarchy rich potential groupings 
nonterminals expr term factor grouped single expression sort operators level hierarchy 
productions expr expr addop term term term mulop factor grouped single binary expression tree node expr binop expr operator expr elision removal irrelevant detail 
concrete syntax contains irrelevant detail example parenthesized expression unit productions 
pattern better eliding irrelevant symbols parentheses wholesale copying context scheme permits convenient specifying copy rules 
systems share ability impose view parse tree 
expressions may abstracted complete program pervasive inheritance module transfer information tree 
imposes view tree simply tree uniform type nodes varying arity syntax tree node tree tree tree 
terminals model terminals may inherited synthesized attributes just nonterminals 
slightly unconventional treatment vocabulary symbols uniform provides flexibility additional unit rules different issue conflicts generated internally module discussed give needing device 
attribute grammar pattern terminal looks bit null production having constituents save automatically synthesized attribute allowing pattern matching extend uniformly terminals 
example dueck cormack module template terminal 
terminal def attribute synthesized rules productions caught non nullable nullable 
quite complicated reasoning pattern match consider module greater number complex patterns 
feel intention bucket brigade passes terminal better indicated notation matching terminals explicitly treating terminals nonterminals uniformly 
copy rules system implements automatically generated copy rules 
dueck cormack state hesitate incorporate automatic generation copy rules mag translator particular solution particular problem may addressed general solution 
agree sentiment shown previous sections modules pervasive inheritance unit production copy rule provide framework copy rules 
rule precedence rule matching systems differs significantly 
system rules single module matched parse tree order 
matching pattern taken attributes module calculated attribute equations matching pattern 
pattern match parse tree way 
control flow matching thought operating attribute evaluation time 
way sets attribute equations come bear separate modules 
dueck cormack differ respects 
processed produce monolithic attribute grammar 
mag provides set patterns 
patterns matched production possible ways 
attribute calculations may produced matches 
process yields attribute calculation rules 
eliminated impossible required attributes available symbol may requested produce attribute rule calculate calculation relying eliminated 
formalized set definable attributes 
similarly calculations needed 
may ones calculate values calculation may specified attribute appear calculation 
formalized set needed attributes 
definable needed attributes deduced attribute equations generated 
may ambiguous rules equations specifying attribute 
solved placing partial order rules selecting earliest rule 
partial order gives precedence earlier rules module rules module order importance 
modular grammars allow module match pattern parse tree node 
circumvented making module submodules 
basic submodule pattern limit composite module limit 
possible mimic mag patterns match production 
submodule composition phi operator give submodules priority earlier submodules precisely reverse dueck cormack mag 
possible mimic mag pattern matches single production ways 
semantic matching equivalent dueck cormack definability set 
equivalent need set attribute evaluator lazy automatically evaluate attribute need 
dueck cormack define rule ordering modules 
presume modules define attribute completely unrelated syntax 
situation ambiguity modules compute disjoint sets attributes 
extending rule ordering include patterns different modules give dueck cormack power define refinement modules 
ordering extended patterns single mag ordered pt pt pt occurs pt mag 
dueck cormack ordering 
may ordered order composition phi phi delta delta delta phi modules ordered occurs earlier composition 
pattern ordering extended modules labeling patterns modules 
single item pt replace pair pt 
pairs ordered pt 
pt modules preferred pt 
pt pt pt rules order module generics generic modules 
example bucket brigade generic module may instantiated produce left right data flow attributes 
dueck cormack observe find modules necessarily concerned solely attribute propagation copy rule share similar appearance 
possible solution provide generic modules parameterized attribute production symbols produce module instances 
possible incorporate instance generic generalpurpose bucket brigade module sub module module compose modules entirely instances generic modules 
generic parameterized module implemented 
list parameterizable parts module attribute production symbols added modules syntactic modularity section 
generic modules proven useful difficult conceive general purpose modules generic facility 
parameterization possible reuse module different purposes pre existing modules accident attributes name 
extensions modular attribute grammars improved software engineering tool supported extensions 
local attribute names safer module group modules hide attributes communicate internally 
example noted harvest sow module implemented bucket brigade module additional attributes 
local attribute names hide new name user module prevent accidental 
renaming alternative mechanism parameterization module re renaming 
renamed module structurally original module names example attribute names grammar symbols replaced names 
renaming advantages kind reuse need anticipated original module module particular module functional right 
parameterization required parameterization respect modules 
declaration imports exports module interface set attributes defines set attributes uses 
formalized declarations example module code list xlist uses code env provides code xlist xlist productions page advantages formal declaration interface ffl module checked interface 
ffl modules refine modules detected inspecting interface implementation 
modules provide attribute refine 
ffl modules parameters conform description interface 
worked details system extensions starting point algebraic specification languages obj goguen asf bergstra versatile developed module combination facilities 
summary system modular attribute grammars 
formulation writing attribute grammar program lazy functional language derived johnsson formulation generalized factor attribute equations parse tree traversal yielded single function characterizes attribute grammar evaluation 
factored equations amenable determined different functions 
allowed degree syntactic modularity introduced language specification different productions different functions 
combining form developed allowed different functions calculate different attributes 
allows semantic modularity module concerned single semantic issue represented small number attributes 
productions attributes generalized allow function cases apply large number productions context free grammar 
gives modules longer tied specific grammar 
short monolithic attribute grammar evaluator transformed evaluator allowed syntactic modularity semantic modularity module reuse 
translation grammar modules miranda program described 
translation analysed suggestions improving efficiency 
suggestions directly attacking inefficiency introduced process generalization 
argued done automatically latest program transformation techniques field partial evaluation 
software engineering modular grammars described 
discussed modular attribute grammars support interesting paradigm explicit refinement operations particularly useful language prototyping incremental extension revision semantics 
modular attribute grammars compared detail similar system developed dueck cormack 
extended examples chapter contains extended examples system modular attribute grammars 
section describes language translate set expressions lingua language 
complete implementation set expressions considered set expression syntax built top grammar lingua proper grammar 
second section shows modular attribute grammar description complete simulation language 
description mathematical language design prototyping software components 
functional programming constructive set theory 
theory guide implementation maps relations sequences represented sets 
syntax set notation 
braces denote set 
empty set written 
set elements listed set elements listed set expressions expressions evaluate value naturally copy set set elements may specified integer range 
extension original syntax equivalent range function 
range range sets specified set comprehensions 
set comprehension gives prototype element expression list generators predicates 
generators state values variables prototype expression may assume predicates restrict filter values satisfy predicate 
range range prototype expression may set expression 
triangle function function generates set sets benchmark 
number elements set nth triangular number notice works example sets set pairs diagonal thought folded points diagonal giving triangular shape 
triangle triangle card triangle additional operators defined union bar foo bar baz true addition sets supports tuples 
elements tuples written list parentheses 
pair blue tuple parts number symbol 
symbol string imported part lingua grammar 
relation set pairs 
items related pair set 
finite mapping function relation element pair unique 
translating set expressions implemented translating expressions lingua expressions perform operations 
sets implemented transforming set expressions functional form 
set expression replaced equivalent expression containing set syntax calls library functions perform operations sets 
set data type implemented unordered list elements type tag set head list 
list unordered obvious ordering elements purpose consider efficiency implementation underlying data types 
production implementation probably implement sets asymptotically efficient data structure hash tables avl trees trees 
require placing ordering sets elements arbitrary ordering contrived purpose 
original implementation unordered lists likewise allow accurate comparisons implementations 
transformations set syntax purely functional syntax written lingua 
set comprehension compiled expression comprising mainly functions implement set operations 
ff sg ff fx fxg set operations ultimately reduced primitive operations ffl empty set 
ffl making singleton set fxg 
ffl finding union sets grammar import lingua primary 
set set 
set 
expr generator set 
generator 
pattern primary 
generator 
filter 
filter 
primary 


expr expr 
expr set expressions multiple generators filters reduced simple case single generator 
consecutive filters combined efficient filtering twice fe fe 
filter may combined generator filtering source generator fe fe fx gg case multiple generators interesting 
value generator parameterizes set values produced second generator fe fe fe fe enumerated sets reduced union parts fe fe range fe range fag range case original implementation def primary 
primary emptyset primary expr 
pattern 
primary 
primary fun pattern 
expr 
primary 
primary expr 
generator generator 

primary expr 
generator 

generator 
primary expr 
generator primary 
primary 

primary expr 
generator primary 
primary 

primary expr 
pattern 
primary 
primary 

primary expr 
pattern 
fun pattern 
primary 
primary 

primary 
primary 
primary expr 
primary expr 
primary expr 
expr 
primary range expr expr 

union term 
term 





translation set expressions 
italic numbers label function cases part program implementation function called repeatedly form yields input 
called repeatedly subtrees 
function specifies set transformations described 
patterns containing new construct 
inspection shows construct eventually re written parse tree 
rule simplest 
simply replaces set expression replacement identifier 
structure rules list generators important implications re write rules 
poor choice increase number cases specified transformation rules 
generator list specified list form 
aids traversing list left right item list easily extracted position 
compare favourable left associative list tree traversed extract leftmost item 
generator list specified null 
compare alternative productions set 
expr generators generators 
generator generators generators 
generator generators 
filter generators generators 
filter productions right associative final generator matches different production 
extract generator syntax pattern sufficient set expr 
generator 

alternative productions require cases case list contains element case list contains set expr 
generator 
set expr 
generator 
generators 
rules rewrite part parse tree context 
example fourth case primaries joined form primary primaries second third elements generator list 
transformation significant points 
replacement expression parentheses 
expression primary 
parentheses constructor fragment parse 
secondly rule precedes fifth case absorbs filter generator 
fourth fifth cases reversed fourth case shadowed fifth case matched 
sixth case splits enumerated set subsets combined union 
union associative commutative don care element specification list left associative 
rule written union operator 
advantage union operator function changed occurs place transformations 
note parentheses required operator precedence 
primary 
primary 
union 
union operator simply converted function call library function case 
cases convert simple sets consisting singleton set single range appropriate library function call 
rule rewritten context thing element list 
cases compile enumerated set nested function calls 
example expression transformed steps range transformations assumption library items emptyset range scope final program 
experiments attribute grammars advocated attribute grammar modules structuring reusing programming language fragments 
section gives extended example ideas 
complete examples modules demonstrate issues larger scale description previous chapters 
particular section demonstrates ffl module reuse 
syntax attribute grammar modules reused construction translators 
ffl scopes 
translators uses type information scopes 
prevent module reuse 
ffl higher order attribute grammars 
larger example derivation tree transformations 
translators languages built syntax attribute grammar modules 
languages executable specification language constructive set theory described earlier chapter language specifying systems dynamics models 
example application described language translators fully appreciated 
attribute grammar modules section translated working miranda programs methodology described previous chapter 
translator phases 
transformation set expressions sublanguage expressions functional subset 
second compilation functional subset common lisp 
tasks illustrate processes difficult achieve purely syntax transformations 
phases translator exhibits phase oriented decomposition addition language oriented decomposition 
translator single phase translator 
components common translator 
language reuses concrete syntax module combinations left op right code op operator left code right code op arg code op operator arg code func args code func code args code module operator relop relop operator equal addop addop operator addop union addop operator set union combinations operator modules expressions 
grammar modules define syntax appear appendix translators produce lisp code output 
simplicity presentation code generated string textual form lisp program 
efficient generate internal form lisp program cons cell symbols atoms mechanics doing obscure points wish demonstrate 
translation expressions expressions form important part 
basic expressions translated modules combinations operator 
combinations module concerned basic form expressions general 
operators module concerned meanings individual operators specific language 
combinations module recognises basic forms expression infix operators prefix operators function application 
pattern matching relies syntactic cues semantic cues 
function call case distinguished parentheses operator cases distinguished operator ability synthesize operator attribute 
combinations module exports code attribute imports operator attribute 
rule combinations module translates infix expression lisp prefix form plus 
part attribute equations requires explanation function case assumed variable pattern args matches nonterminal synthesizes code attribute list code attributes arguments 
easily arranged list abstraction section 
operator module synthesizes operator attribute operator production 
uninteresting quite long define syntactic operator module stat stats stat stats code stat code stats stat stats stats code stat code newline stats code stat var expr stat code setq var code expr code stat type var expr stat code stat var expr stat code stat var varlist expr stat code defun var code varlist code expr code translating statements language 
possible decompose module submodules criteria module relop addop better decomposition common operators appear nearly languages specific operators appear language 
common operators module reusable 
statements definitions statements appear top level define global entities 
statement terminated full 
types statement ffl variable definition ffl type definition type ffl type conformance ffl function definition vars global variables mapped lisp global variables symbol values global functions mapped lisp global functions symbol functions 
distinction global functions global variables feature common lisp versions lisp known collectively lisps 
distinction explained 
type information generate code global variable definition translated lisp setq operation 
definition var expr translated lisp operation setq symbol expression declared type information 
keeping original implementation henderson module factor expr factor code expr code map embrace code embrace defn var varlist expr defn code lambda varlist code expr code defn var code defn var expr defn code expr code defn var code local definitions symbol lisp symbol assigned hold variable expression translation expr 
need generate code create allocate symbol lisp system creates mentioned system 
similar manner function definitions translated lisp defun form 
function definition add translated defun add expressions language contains form making local definitions 
semantics expressions form evaluated parallel body expression evaluated scope names bound resulting values 
names visible 
lisp form natural translate form lisp form 
form allows local functions twice twice sqrt functions mutually recursive see 
module translates expression 
definitions construct list names parallel list expression code compute value name 
lists combined pairwise construct lisp definitions 
local function interesting translated anonymous expression 
parameter list constructed way global function 
function call types section describes type information may process program 
example common lisp property functions variables different extension original language added introduce scoping issues name spaces 
generating lisp code requires taken account 
example little unusual type problem shares type problems feature names input language treated differently defined 
modules combinations translate expressions correct lisp code 
problem functions target language common lisp lisp 
different versions lisp classified lisp lisp depending functions values bound names 
lisp allows name designate variable function 
lisp allows name designate variable function just possible values variable assume 
scheme rees clinger lisp 
common lisp lisp 
common lisp dialogue variable function user input italic lisp system prompt 
defun define function 
setq assign variable 
function 
variable consequence having name denote separate variable function function variable interpretation chosen occurrence name program 
default interpretation function name occurs head list variable 
consider function twice applies function argument result application 
define twice naively translated lisp result defun twice call global function defined parameter variable 
function stored variable funcall function apply function arguments 
correct translation twice defun twice funcall funcall funcall convert value function 
second problem converse converting function value passed parameter 
lisp special form function achieves 
call twice sqrt function special form twice function sqrt code function sqrt may abbreviated sqrt 
lisps may implemented associating storage cells symbol value cell function cell 
symbol argument position value stored value cell module pervasive inheritance env phi contours phi funcall module contours program stats stats env stats decls stats stat stats stats decls stat decls stats decls stats stat stats decls stat decls stat var expr stat decls fvar name 
stat var varlist expr stat decls fvar name 
expr env stat env phi reduce phi varlist decls var ident var decls name 
factor expr inner env factor env phi reduce phi decls env inner env expr env inner env defn var expr defn decls fvar name 
defn var varlist expr defn decls fvar name 
expr env defn env phi reduce phi varlist decls module funcall var args code var code args code var name env env var name func funcall env var name obj factor var code var name var name factor env var name env var name func var name env var name obj ident ident code ident name modules function value types 
symbol function position function stored value function cell 
function special form means value stored function cell 
translator needs improved generates funcall function forms appropriate places 
essentially type coercion problem 
identifiers allocated symbol value cells symbol function cells definition 
point type domain names denoting respectively value cell function cell symbol 
symbol may inappropriate type coerced correct type funcall function 
problem specific choice common lisp target language problem example important problem language definition finding name construct means handled appropriately 
elements problem definition visibility 
element responsibility module 
module composite module corrects implementation lisp 
module illustrates features ffl declarations environments 
definitions add information defined name environment assigns type obj func name visible point 
ffl scopes 
names function parameters restricted visibility 
ffl reuse general modules 
pervasive inheritance module away irrelevant syntax 
ffl refinement methodology programming 
redefines function call variable translated 
module overrides naive implementation specified combinations module 
rest translation unaffected 
module composition submodules 
submodule ensures environment available points derivation tree 
contours module collects definitions alters pervasive inheritance environment definitions visible scopes 
called contours module implements contour model nested local scopes 
funcall redefines function call variable translated lisp take type account 
definitions collected decls attribute 
declarations environments modeled functions names types obj defined variable func defined function 
functions extended combined function override operator phi 
sequence statements collects definitions eventually turned round form environment production module 
top level environment contain type information exactly names defined program 
defining forms synthesizes decls attribute specifies implementation type form 
name defined top level definition local definition parameter function 
note top level functions func type local functions obj type 
local functions translated expressions values 
environment function extended local declarations parameters function 
names added overriding environment effect hiding global definitions name 
new declarations obtained reducing decls attribute synthesized varlist 
done list abstractions translator yield list declarations combined 
environment funcall module decide funcall function 
variable name looked environment wrong type appropriate form 
name appear environment defined program 
case assumed default action adequate allowing lisp functions variables defining 
secure alternative signal error 
lisp functions variables permitted added environment production contours module 
translation sets functional subset section describes expressions translated underlying functional subset 
translations similar described section done modular attribute grammars higher order attribute operations 
specific translations require unique symbol generator 
section described gensym attribute 
particular described gensym attribute incremented describe default behaviour 
default behaviour pass gensym counter traversal tree 
convenient bucket brigade module purpose inventing traversal 
attributes copy gensym number tree initialized zero root tree module gensym bucket brigade program stats stats bucket brigade module specifies similar set transformations specified function described earlier 
transformations essentially example replacing identifier emptyset 
transformations superficially different different symbols grammar example added set operations lingua language smallest expression type primary complete language shallower expression hierarchy set expressions rooted factor 
profound difference lingua anonymous functions 
implication translating set mapping filtering operations simple syntactic transformation lingua set 
nameless functions needed set operations defined named functions enclosing scope 
example fifth rule translate set comprehension expression environment function mapping names types name looked applying environment name form env var name 
module factor ffi ffl factor factor ffi factor ffl factor ffi factor ffl factor ffi factor ffi union ffl factor ffi factor ffl newname name factor factor factor phi fg 
factor factor ffi factor ffl newname name factor factor factor phi fg 
factor module 
new name generated inherited attribute new expression replaces set expression 
gensym number incremented passed described section 
case generator generates tuple values translated call function takes element tuple separate parameter 
implemented slightly differently applies function element set builds set results applies function tuple set spreading tuple elements function arguments 
minor modules described completeness 
translates conditional lisp obvious manner 
single virtue module extends conditional expression 
module cond code cond code code code constants generates lisp code constant forms module constants constant number constant code number string number value constant string constant code string value top level complete translator assembled combining modules module lisp translation phi phi phi expr phi varlist var phi combinations phi constants phi operator phi phi defn phi stat phi phi note module placed transformations parse tree visible attribute grammar see section full explanation important 
systems dynamics systems modelling style concentrates aggregate levels rates flow 
system described terms set states levels represent amount substance money population goods changes levels rates 
levels rates represented variables expressions bound set difference equations describe levels rates affect 
language defines model set levels rates auxiliary definitions 
level rate initial value constant expression expression defining value depends levels rates 
concrete syntax model model ident parts parts part parts parts part level var initial expr expr part rate var initial expr expr part var expr model run setting levels rates initial values stepping time 
time step new values calculated levels rates 
process repeated simulation time exceeds preset bound 
systems dynamics model really set order coupled differential equations 
level level time time dt level dt theta rate ffl ffl ffl euler method model level romantic initial romantic dt level initial dt level sane initial sane dt rate initial romantic rate initial rate initial sane days days dt timelimit model example systems dynamics models applied wide range problem domains including economics epidemiology engineering nature reserve management 
example fun epidemiology model epidemics borrowed 
kinds people model people love susceptible sane people susceptible 
contagious disease 
romantic infected person daily probability lasts average days subject sane immune 
sanity lasts average days subject romantic model written language 
difference equations solve differential equations euler method described 
levels model populations 
population model unrealistic epidemiology model 
normally diseases contagious lasts week confers long term immunity lasts years 
population days sane love sick romantic graph results input output positive negative rates equations 
implementation model set level rate parameter definitions 
translator translates lisp program computes values levels rates time 
model thought having parts basic framework handles iterative nature level rate computations models formula part determined particular model 
framework organises activities ffl initialization ffl reporting results ffl re computing levels rates ffl termination model framework essentially loop activities plugged right places specified scheme module 
invariant loop levels rates correct time indicated variable time 
levels rates recomputed step process 
new values computed assigned new variables 
new values copied old values 
parallel assignment done levels may defined mutually recursive fashion rate level function level rate formula containing levels rate variables 
levels incremented shifted rates maintain invariant levels rates appropriate value time 
scheme produces correct results rate variables expressions function levels new levels function rates 
operations printing shifting determined parts specified model 
operations handled separate module 
module phi phi exprs phi model module exprs expr phi varlist var phi combinations phi constants phi operator phi ite phi module model parts part phi scheme phi initial phi increment phi shift phi module scheme model module name parts model code progn setq time dt progn init loop print setq time time dt 
time time limit return init reduce parts initial print model reduce parts reduce parts reduce parts reduce parts ident ident code ident name ident ident name new module shift part level initial part setq code code new part part rate initial part part setq code code new part part part basic scheme expressions list ff summary grammar module usage operations individual parts model collected list abstraction parts part 
levels rates incremented different times shift increment modules synthesize attributes 
effect dividing levels rates explicitly filtering syntax tree list attribute 
module attribute purpose initial initial code initialize level rate parameter increment code increment level code increment rate shift code copy new value level old code copy new value rate old common lisp format print value code access item printed part code printing model expressions language translated modules 
summary larger examples ideas techniques action 
included reasonable sized application application modular attribute grammars construction different language translators 
syntactic transformations difficult 
particular lack list primitive grammar programming difficult repetitive common operations mapping filtering written scratch 
problems alleviated list abstractions defined modular attribute grammars 
attribute grammar examples demonstrated module reuse 
diagrammatic summary module relationships 
attribute grammar modules translated miranda executed verify correctness 
conventional issues handling declarations environments demonstrated declaration types 
example interesting shows module refine previous module modules incompatible simplistic operation combinations module adequate ag lib operator combinations constants debug operator constants stat summary attribute grammar module usage 
truly shared modules italicized 
arrow means module tail arrow built module head arrow 
ag lib contains useful infrastructure modules example pervasive inheritance 
dashed lines mean modules major shared component just happen way 
modules probably reverse engineered increase module reuse 
refined generate code depending semantic context 
environment added translator unduly affecting modules translator 
set expressions sublanguage demonstrates program transformation higher order attribute grammar operations 
summary previous chapters tried answer question write language processor structured component language fragments 
question interesting answer tells construct library existing fragments little glue rapidly construct new language processor 
fragment library approach especially suited building language prototypes library contain fragments adequate exactly implementor mind 
implementor standardized language constrained 
quite stringent constraints modularity achieved conventional programming paradigms 
chapter modular interpreters written functional object oriented algebraic styles order answer question conventional structuring mechanisms adequate expressing language fragments 
restrictions quite severe stem single control flow thread interpreter 
control flow dominates ways 
difficult reconcile modules scan program different ways 
module called information gathering master module needs written anticipation subordinate module requirements 
secondly modules able decisions handle syntax unknown module 
order allow language extended composing modules 
modularity description syntax troublesome 
chapter described modular parsing system top parsing 
parser modular description nonterminal set productions translated independent parsing function grammar description modular final grammar constructed forming composite grammar components similar way algebraic specification module composition chapter describes parse program fragments 
discussed terms implementation top parser integrated shift reduce parser 
small functional programming language called lingua written 
distinguishing feature language program fragments integrated pattern matching data constructor syntax 
previous chapters shown syntactic modularity easier achieve semantic modularity 
evident static modularity grammar descriptions easier understand dynamic modularity composition interpreter fragments 
lessons mind took static description semantics attribute grammars modular 
primary tool process lazy done implementation obj goguen asf bergstra 
functional programming language allowed experimentation evaluation mechanism 
process increasing abstraction evaluator able transform monolithic attribute grammar processor form allowed separate attribute grammar modules 
call modules production attribute module may specify attribute computations attributes productions concrete syntax 
example bucket brigade module uses just rules specify attribute relationship context free grammar 
abstraction semantic attribute grammar modules resilient changes rest language allows reused different concrete syntaxes 
strong case defining syntactic semantic modules independently 
increased generality functional basis attribute grammar evaluator allows increased specificity 
mean restrictive patterns specified restrictive ones 
higher order attribute operations unit matched rule single production concrete grammar combination productions forming incomplete parse tree program fragment 
allows program manipulated recognizing special cases specifying equivalent forms 
program meaning described attribute equations rewriting program form 
major results main result research modular attribute grammar system demonstrates way writing modules facet language combining modules language 
module embodies language fragment 
modular attribute grammar system solution problem writing language processor language oriented decomposition set language fragments 
language oriented decompositions investigated decomposition interpreters modular syntax 
shared shortcoming difficult awkward create modules worked simple syntactic level consider ccs example needed changed allow interworking language fragments managed environment 
modular attribute grammars clear advantage modules written awkward constraints module production patterns specify behaviour parts context free grammar unknown semantic interest 
interesting observation syntax modules attribute grammar modules 
ag modules respect concrete syntax 
dueck cormack observe abstraction serves remove need intermediate syntax 
attribute grammars matched syntactic semantic cues apply large range grammars 
need syntactic modular structure concrete syntax impose semantic modular structure 
dueck cormack mention concrete syntax dueck cormack 
think concrete syntax modules benefit language prototype builder 
syntax ag modules weakly coupled syntax modules ag modules developed time gives confidence attribute modules syntax modules 
implementor builder import syntax modules syntax ag modules semantics 
third main result application programming explicit refinement programming difference language processors 
programming refinement allows existing modules tailored handle new cases increasing reuse existing modules 
allows general statements language structure coded sub parts form evaluated environment things defined 
language features impose control general valid statements 
relationship explicit refinement object oriented programming discussed section 
engineering language fragments modular systems described report developed response inadequate software engineering properties conventional structure language processors 
section discuss engineering qualities new system 
modules written different assignment responsibility 
shows modules system obey basic principle modular decomposition 
consider modules communicate prevent inadvertent communication 
interface modules crude module imports attributes assumes defined 
exports attributes defines values 
modules may export attribute export wins depends syntactic overlap modules order composition 
communication uncontrolled undeclared chapter suggested improvements aimed correcting weakness 
issue function module general infrastructure module specific feature module addressed chapter 
fundamental point clash module autonomy desire able override behaviour 
explain point compare facility explicit refinement attribute redefinition object oriented programming 
object oriented oo programming data type represented class 
class values operations methods associated 
subclasses defined redefining methods defining new methods defined class case multiple inheritance 
usually control parts object visible outside 
example allows programmer define object component method public private protected 
compare ag modules 
ag module defines attribute values class syntactic semantic structures attributes defined syntactic match attribute availability 
ag module independently defines similar set attributes 
module corresponds superclass corresponds subclass depends order modules composed 
better way look think final language processor subclass inheriting modules classes 
conflicts resolved programmer defined order module composition 
poses problems wishing implement similar system object oriented programming language multiple inheritance model bound differ 
smalltalk allows single inheritance allows apparent conflicts resolved actual method clos bobrow complicated scheme depends depth inheritance relationship order importation 
modular attribute grammars object oriented programming ability define shared object production behaviour refine behaviour deriving new subclass grammar said system object oriented parallel extend far find convincing grammar analogues objects classes self super 
software engineering point view reliance module perform function raises question module part declared required second 
easily catered case module consuming attribute generated module modules declare imported exported attributes 
case modules sharing responsibility generating attribute clear required declaration module 
suggest declarations state module may incomplete 
tool determine modules redefine entities defined modules useful especially detects case module entirely shadowed refinements 
engineering question relating refinement point refinement unmanageable 
module composition read clear long cascade refinements unintelligible 
effect noted standish 
level modular attribute grammar language definition unreadable known 
effect suggests level profitable derive new language set fragments add hacking modules existing language define new language features library language fragment reused languages 
summary engineering aspects language oriented decomposition warrant investigation 
implications language design methods processes achieve goal affect perception goal may achieved 
language processors conveniently structured collection fragments reflecting conceptual structure language changes expect programming languages result released conventional structure 
expect freedom pick choose modules result proliferation essentially similar incompatible languages 
language uses particular syntax express language uses slightly different 
different current state affairs 
expression theta theta may evaluate pascal apl left right depending order evaluation languages consider input error postscript forth 
availability convenient modules encourage reuse 
effect making languages alike different 
programming easier rules theta done left right set common language 
consider modern integrated package consisting spreadsheet database word processor 
programmed language 
similarities languages usually painstaking design 
easier implementation languages modules refinement modules define different parts 
things easier programmer basics language making easier learn language things differ different 
facility reuse language fragments encourage implementing application languages take easy option buying language fragments ensure compatibility standard common subset 
benefit language researchers common heritage language accessible public 
new avenues achieve state art previous section needs done 
suggest areas endeavour efficiency module engineering incremental algorithms object oriented approaches 
efficiency 
mechanism appropriate modularity language implementation needs efficient 
outlined partial evaluation significantly reduce execution time language processor 
raises issue efficiency procedure generating processor partial evaluation fast 
alternative take lessons learned incorporate conventional scheme dueck cormack 
software engineering 
written language fragment modules accomplish syntactic semantic modularity need know module 
parnas considers modular structures simple problem reading processing writing lines words parnas 
structured control module handles reading handles processing modules called order accomplish task 
second structure data types 
module handles words access modify 
modules module manipulate data 
superior design components isolation changes requirements affect fewer modules 
lesson carries forward directly language implementations carries forward way 
control structured solution similar syntax linked modular structure 
attribute grammars devoid control selection attribute rules depending particular syntax 
analogue parnas data type structured solution 
suggest module accepts liberal variety syntactic constructs selecting attributes provided syntactic forms 
way module insulated changes syntax 
incremental algorithms 
research incremental algorithms performing language related tasks popular 
usual motivation interactive environments require rapid feedback small changes 
incremental algorithms reusing results computation 
obvious candidates incremental algorithms 
consider language processor defined syntax modules attribute grammar modules phi phi delta delta delta phi phi phi delta delta delta phi mm opportunities ffl change addition ffl change addition mm incremental algorithms perform changes interactive language definition workbench possible allow small changes large existing languages efficiently 
incremental parser generators available heering horspool 
object oriented programming 
relationship attribute grammar modules object oriented programming deserves attention 
possible integrate 
koskimies koskimies progress area solutions rigidly concrete syntax 
appears semantic modules framework difficult result worth 
achieved language oriented programming software engineering paradigm special purpose application oriented languages constructed tool giving succinct powerful descriptions application 
application oriented language abstraction problem domain exposes salient details application hides details 
language oriented programming practicable possible construct language processors cheaply 
recognised key reducing software costs re 
conventionally structured language processors poor reuse properties especially considers kind reuse useful language oriented programming importation ready language fragments arithmetic imperative control flow 
modular attribute grammars allow implementation structured language features 
module collection modules capture essence language fragment 
allows modules created property reused new implementations new languages 
modular grammars overcome restrictions conventional language processor structure 
new languages constructed assembling existing language fragments 
greatly reduces cost building new languages small proportion implementation built scratch 
variant languages defined adding new modules specify alternative implementation parts language 
variant reuses original implementation 
object oriented programming success classes reused creating subclass uses inheritance get functionality new definitions tailor class particular requirements 
similarly ability attribute grammar modules redefine part language important reuse difficult guess advance module may reused 
methodology investigation sound 
lazy functional programming tool expose method calculating attributes defined composition attribute grammar modules 
correspondence attribute grammars functional programs allows attribute grammar translated functional program 
correspondence manipulated put form abstracted attribute grammar 
program transformation executable modular attribute grammar processor derived served prototype attribute grammar processor allowing attribute grammar programs report executed 
prototype gives weight argument language fragments suitable structure language processors 
summary main contributions ffl method modelling languages collections modular language fragments 
ffl prototype tool implementing language processors modules 
ffl description language oriented programming software engineering methodology creating application oriented languages abstractions problem domain 
language fragments embodied modular attribute grammars superior conventional phase oriented structure implementing language processors 
structure superior better software engineering properties reduce cost building language implementations 
turn reduce cost language oriented programming 
ccs inference rules described main part report ccs agent program executed converting standard concurrent form scf choosing terms scf expansion 
note describes algorithm transitional semantics deriving scf ccs agent 
inference rules equivalence ccs agents defined set inference rules 
milner reproduced act ff ff gamma 
sum ff gamma 
ff gamma 
sum ff gamma 
ff gamma 
com ff gamma 
ff gamma 
com ff gamma 
ff gamma 
com ff gamma 
ff gamma 
gamma 
rel ff gamma 
ff gamma 
res ff gamma 
pnl ff gamma 
nl ff ff con ff gamma 
ff gamma 
def note rule nil transitions null agent 
conversion scf scf agent constructed expensive obviously correct method enumerating possible inferences 
done bottom manner 
possible inferences sub agents agent combined inference rules 
asking transitions possible agent write answers transitions fp ff gamma 
ff gamma 
ff gamma 
equivalent scf agent ff ff delta delta delta ff represented set pairs ff ff ff set valid inferences deduced inductively 
scf nil fg scf ff ff scf scf scf scf ff ff scf ff ff scf ff scf ff scf scf pnl ff nl ff scf ff lg scf ff ff scf syntax modules summary diagram summarizes relationship syntax modules 
arrow points importing module imported module 
expressions list ff expr language grammar grammar grammar lisp grammar expressions import list expr expr 
expr relop expr 

addop term 
term term 
term mulop factor term 
factor factor 
expr expr expr factor 
expr factor 
unop factor factor 
var factor 
var factor 
constant relop 
relop 
relop 
relop 
relop 
relop 
addop 
addop 
addop 
addop 
sequence concatenation mulop 
mulop 
mulop 
mod mulop 
unop 
unop 
list language grammar grammar grammar lisp grammar list thing 
thing 
thing 
language grammar grammar grammar lisp grammar import expressions factor 
expr factor 
factor 
expr 
defn 
defn 
var expr defn 
var varlist expr local function relop 
grammar grammar grammar lisp grammar import list varlist var import list factor 

expr generator 

exists pattern expr expr 
pattern expr expr generator 
pattern expr 
generator 
filter 
filter 
expr 
expr expr 
expr pattern 
varlist pattern 
var relop 
addop 
union mulop 
intersect grammar grammar grammar lisp grammar axiom terminal ident string number comments import import program 
stats stats 
stat stats stats 
stat stat 
var expr stat 
type var expr stat 
var expr stat 
var varlist expr stat 
expr constant 
number constant 
string constant 
ident var 
ident language grammar grammar grammar lisp grammar import expressions terminal ident number comments model 
model ident parts parts 
part parts parts 
part 
level var initial expr expr part 
rate var initial expr expr part 
var expr var 
ident constant 
number bibliography aasa annika aasa kent petersson dan 
concrete syntax data objects functional languages lisp functional programming pp 

abelson sussman harold abelson gerald jay sussman 
structure interpretation computer programs 
mit press cambridge massachusetts 
aho ullman aho ullman 
theory parsing translation compiling 
prentice hall 
aho aho sethi ullman 
compilers principles techniques tools 
addison wesley 
aksit mehmet aksit ren 
compiler generation grammar inheritance technical report university twente 
bergstra bergstra heering klint eds 
algebraic specification 
addison wesley 
bobrow bobrow de michiel gabriel keene kiczales moon 
common lisp object system specification sigplan notices 
bondorf anders bondorf 
automatic higher order recursive equations jones ed rd european symposium programming lecture notes computer science pp 

ieee springer verlag 
cameron ito robert cameron robert ito 
grammar definition metaprogramming systems acm transactions programming languages systems 
martin david martin 
order algebraic definition semantics mathematical systems theory 
cordy james cordy charles halpern eric 
txl rapid prototyping system programming language dialects international conference computer languages pp 

ieee 
cousineau huet guy cousineau erard huet 
caml primer technical report inria ens 
cousineau cousineau curien mauny 
categorical machine jouannaud ed ifip intl 
conf 
functional programming languages computer architecture lecture notes computer science pp 

springer verlag 
dueck cormack dueck cormack 
modular attribute grammars computer journal 
earley earley 
efficient context free parsing algorithm communications acm 
rodney 
linguist translator writing system attribute grammars sigplan notices proceedings sigplan symposium compiler construction pp 

acm 
field harrison anthony field peter harrison 
functional programming 
addison wesley 
fpca functional programming languages computer architecture 
acm 
frost frost 
calculus lazy interpreters 
acm 
ganzinger giegerich harald ganzinger robert giegerich 
attribute coupled grammars proceedings sigplan symposium compiler construction sigplan notices 
acm 
giegerich robert giegerich 
composition evaluation attribute coupled grammars acta informatica 
goguen joseph goguen timothy 
introducing obj technical report sri csl sri international 
heering heering klint rekers 
incremental generation lexical scanners technical report cs centrum voor wiskunde en informatica cwi amsterdam 
heering heering hendriks klint rekers 
syntax definition formalism sdf manual technical report cs centrum voor wiskunde en informatica cwi amsterdam 
heering heering klint rekers 
incremental generation parsers proc 
sigplan conference programming language design implementation pp 

henderson peter henderson 
functional programming application implementation 
prentice hall 
henderson peter henderson 
functional programming formal specification rapid prototyping ieee transactions software engineering se 
henson turner martin henson raymond turner 
completion semantics interpreter generation ninth annual acm symposium principles programming languages pp 

hoare hoare 
communicating sequential processes 
prentice hall 
holt richard holt turing programming language design definition 
prentice hall 
horspool nigel horspool 
incremental generation lr parsers computer languages 
johnson johnson 
yacc compiler compiler computing science technical report bell laboratories murray hill johnsson thomas johnsson 
attribute grammars functional programming paradigm 
functional programming languages computer architecture lecture notes computer science 
springer verlag 
kastens kastens zimmermann hut 
gag practical compiler generator 
lecture notes computer science 
springer verlag 
kernighan ritchie brian kernighan dennis ritchie 
programming language 
prentice hall 
knuth knuth 
semantics context free languages math 
syst 
theory 
correction math 
syst 
theory 
koskimies kai koskimies 
software engineering aspects language implementation hammer ed compiler compilers high speed compilation lecture notes computer science pp 

springer verlag 
koskimies kai koskimies 
lazy recursive descent parsing modular language implementation software practice experience 
wolfgang 
system simulation programming styles languages 
addison wesley 

language directed programming meta lisp st european conference practical applications lisp pp 

lesk lesk 
lex lexical analyzer generator computing science technical report bell laboratories murray hill sandra michael kaelbling charles nicholas michael share 
chameleon system solving data translation problem ieee transactions software engineering 
mauny michel mauny 
parsers printers stream destructors constructors embedded functional languages functional programming languages computer architecture pp 

acm 
mccarthy john mccarthy paul daniel edwards timothy hart michael levin 
lisp programmers manual second ed 
mit press 
milner robin milner 
calculus communicating systems 
lecture notes computer science vol 
springer verlag 
milner robin milner 
communication concurrency 
prentice hall 
mogensen torben mogensen 
binding time aspects partial evaluation 
phd thesis diku university copenhagen denmark 
mogensen torben mogensen 
separating binding times language specifications functional programming languages computer architecture pp 

acm 
robert 
algorithm generating syntax trees computer languages 
parnas david parnas 
criteria decomposing systems modules communications acm 
callahan james john callahan 
parse tree annotations communications acm 
rees clinger jonathan rees william clinger 
revised report algorithmic language scheme sigplan notices 
rekers rekers 
modular parser generation technical report cs centrum voor wiskunde en informatica cwi amsterdam 
spivey spivey 
notation 
prentice hall 
stroustrup bjarne stroustrup 
programming language 
addisonwesley 
tomita masaru tomita 
efficient parsing natural language 
kluwer academic publishers 
vogt vogt swierstra kuiper 
higher order attribute grammars proc 
sigplan conference programming language design implementation pp 

vance 
production trees compact representation parsed programs acm transactions programming languages systems 
wadler philip wadler 
views way pattern matching cohabit data abstraction th annual acm symposium principles programming languages pp 

wadler philip wadler 
comprehending monads proceedings lisp functional programming 
acm 
weise ruf daniel weise erik ruf 
computing types program specialization technical report tr draft center integrated systems stanford 
yellin daniel yellin eva maria 
automatic inversion attribute grammars ieee transactions software engineering se 
