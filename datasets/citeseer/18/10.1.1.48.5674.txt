type classes exploration design space simon peyton jones university glasgow oregon graduate institute mark jones university nottingham erik meijer university utrecht oregon graduate institute may type classes introduced haskell regarded fairly experimental language feature warranted fairly conservative design 
time practical experience convinced programmers benefits convenience type classes 
occasion programmers discovered examples seemingly natural applications type class overloading prevented restrictions imposed haskell design 
possible extend type class mechanism haskell various ways overcome limitations proposals designed great care 
example different extensions implemented gofer 
particularly support multi parameter classes proved useful interactions aspects design resulted type system unsound undecidable 
illustration constructor classes haskell came proper generalization notion context 
consequence certain quite reasonable programs typable 
review rationale design haskell class system identify weaknesses current situation explain choices face attempting remove 
type classes distinctive features haskell hudak 
impressive variety applications haskell significantly extended expressiveness introducing constructor classes jones 
programmers want people bumped limitations haskell class system 
language gofer jones developed parallel haskell enjoys liberal expressive class system 
expressiveness definitely useful transferring gofer current iteration haskell language haskell identical haskell respects relevant 
haskell painful experience 
feature particularly missed multi parameter type classes section explains 
obvious question way extend haskell class system enjoy expressiveness gofer provides 
main body explores question detail 
turns number interlocking design decisions 
gofer haskell embody particular set useful tease independently see interact 
goal explore design space clearly possible laying choices factors affect prescribing particular solution section 
find design space large identify separate design decisions possible choices combinations choices sense 
offer opinion sensible set choices section 
new language feature justifiable results simplification unification original language design extra expressiveness truly useful practice 
contribution collect fairly large set examples motivate various extensions haskell type classes 
multi parameter type classes 
visible extension haskell type classes discuss support multi parameter type classes 
possibility multi parameter type classes recognised original papers subject kaes wadler blott gofer supported 
section collects examples multi parameter type classes encountered 
new surprising appeared inter alia papers 
purpose collecting provide shared database motivating examples 
welcome new contributions 
overloading coupled parameters concurrent haskell peyton jones gordon finne introduces number types mutable variables mutvar synchronised mutable variables mvar channel variables cvar communication channels channel skip channels come similar operations take form 
io getx 
io putx 

io ranges mvar similar operations standard state monad 
st 
st 

st manifestly candidates overloading single parameter type class trick 
trouble case monad type type come pair io mutvar st 
want multiple parameter class abstracts class monad 
new 
get 
put 

instance io mutvar instance st 
quite common pattern parameter type class needed class signature really tuple types instance declarations capture direct relationships specific tuples type constructors 
call overloading coupled parameters 
number examples collected ffl class statemonad jones carries state naked inside container example class monad 
statemonad gets puts 
monad carries state type gets extracts state monad puts overwrites state new value 
define instances statemonad newtype state state 
instance statemonad state 
notice coupling parameters arising repeated type variable jones defines related class describes computations read fixed environment class monad 
env 

getenv newtype env env 
instance env ffl glasgow oregon graduate institute hardware description languages led class declarations similar class monad ct 
hard ct sg const 
ct sg op 

sg 
ct sg op 


sg 
sg 
ct instance hard instance hard 
circuit constructor ct monad signal constructor sg serves distinguish values available circuit construction time type int say flowing wires circuit execution time type int say 
instance hard gives different interpretation circuit example produce net list simulate circuit 
example instance type come pair sense give instance hard 
ffl haskell prelude defines defines functions reading writing files readfile 
io string 
string 
io similar functions defined pairs device handles types mice buttons timers windows robots mouse 
io button 
io timer 
io float window 
picture 
io robot 
command 
io timer 
float 
io functions quite similar methods get 

put 


family monad fixed io choice value type coupled box type need multi parameter class overloads class handle receive handle 
io send handle 

io go step unify class class monad 
statemonad parameter class class monad 
device 
example suggested scholz 
ffl appealing application type classes describe mathematical structures groups fields monoids 
long need coupled overloading arises 
example class field 
vectorspace 


operator multiplies vector scalar 
overloading constrained parameters libraries implement sets bags lists finite maps similar functions empty insert union lookup 
commonly agreed signature libraries usefully exploits class system 
reason multi parameter type classes absolutely required job 

consider attempt class collection empty insert 

union 


trouble type variable universally quantified signature insert union 
means equality greater elements sets instance collection defeats object exercise 
far best solution parameter type class class collection empty insert 

union 


multi parameter class allows instance declarations constrain element type instance basis instance eq 
collection empty insert xs 

instance ord 
collection empty insert 

point different instance declarations constrain element type different ways 
look variant coupled parameter overloading discussed preceding section 
second type pair constrained instance declaration ord completely specified previous section 
general form overloading parameters instance variable example suggested sergey 
serves hook arguments instance context member functions 
parametric type classes chen hudak odersky deal quite nicely bulk types example suit examples previous section 
full discussion design choices bulk types library contained peyton jones 
type relations construct applications multi parameter classes relationships different parameters looser examples seen 
general setting multiparameter type class represent arbitrary relation types example relation instance 
ffl imagine defining isomorphism relationship types liang hudak jones class iso iso 
osi 
instance iso iso id ffl imagine overloading haskell field selectors declaring class class 
field label data type foo foo foo int get class declaration class foo 
instance declaration instance foo int foo foo foo foo just cut version kind extensible records proposed jones jones 
examples looser earlier ones result types class operations mention class type variables 
practice typically find relations general type class mechanisms remarkably easy write programs overloading ambiguous 
example type iso iso 
iso function type char 
resulting values iso iso compared type 

bool 
intermediate type completely unconstrained resulting type eq iso char 
bool ambiguous 
runs similar problems quickly trying overloading field selectors 
discuss ambiguity section 
summary view examples section persuasive case multi parameter type classes just monad functor constructor classes 
examples cry haskell style overloading simply done multi parameter classes 
background order describe design choices related type classes briefly review concepts involved 
inferred contexts performing type inference expression type checker infer monotype context set constraints satisfied 
example consider expression xs 
case xs 
false ys 
ys type checker infer expression context type context ford eq eq type 
bool constraint ord arises element list constraint says elements list lie class ord 
similarly eq arises list element 
constraint eq arises tail list says lists elements type lie eq 
typing constraints operational interpretation helpful required haskell implementation particular operational model 
constraint corresponding dictionary collection functions passed overloaded operator involved 
example dictionary eq tuple methods corresponding class eq 
passed second overloaded operator simply select method dictionary apply ys 
think dictionary concrete run time evidence constraint satisfied 
context reduction contexts simplified reduced main ways 
eliminating duplicate constraints 
example reduce context feq eq just feq 
instance declaration 
example haskell prelude contains standard instance declaration instance eq 
eq 
tv dom instance 
inst tv dom class 
super mono trans rules entailment instance declaration specifies equality values type define equality lists type 
terms dictionary model instance declaration specifies construct dictionary eq dictionary eq perform context reduction ford eq eq gamma 
ford eq ag say constraint matches instance declaration substitution type variables instance declaration head equal constraint 

class declaration 
example class declaration ord haskell prelude specifies eq superclass ord class eq 
ord 
means instance ord instance eq 
terms dictionary model read saying ord dictionary contains eq dictionary sub component 
constraint eq implied ord follows perform context reduction ford eq ag gamma 
ford ag precisely say entails written constraints implied define meaning class constraints formally definition entailment relation defined 
rules correspond substitution maps type variables types allows class instance declarations substitution instances types 
example declaration instance eq 
eq 
notice inst appear order top bottom lines rules reversed super 
suggest haskell syntax late correct 
deduce feq feq arbitrary type remaining rules explain entailment monotonic transitive expect 
connection entailment context reduction reduce context necessary sufficient reason entailment sufficient reduction concerns overlapping instances property chosen 
overlapping instance declarations discussed section 
failure context reduction fails type error reported instance declaration match constraint 
example suppose trying reduce constraint eq tree instance declaration form instance 
eq tree 

immediately report error contains type variables instantiated refinement possibly match 
strategy conflicts slightly separate compilation imagine separately compiled library able see instance declarations tree 
arguably reporting error message context reduction deferred see section hope importing module necessary instance declaration 
postpone production legitimate missing instance error messages main module compiled instance declarations occur quite serious disadvantage 
furthermore usually easy arrange module needs instance declaration able see 
failure reported immediately regardless context reduction strategy 
tautological constraints tautological constraint entailed empty context 
example standard instance declarations ord int tautological constraint instance declaration ord ord int allow conclude fg ford int ground constraint mentions type variables 
clear ground constraint erroneous match instance declaration tautological 
obvious tautological constraint ground 
consider gofer instance declaration instance 
brings axiom representation gofer dictionary contains sub dictionaries retrospect probably poor design decision intuitive 
discovered incompatible overlapping instances acceptable combination results unsound type system 
gofer type system suffers problem today concerns removing support feature break lot existing code 
instance eq 
foo assume moment overlapping instance declarations prohibited section 
suppose context int subject context reduction 
regardless type simplified feq intg instance declaration fg int instance eq 
contains type variables constraint foo int reduced fg tautological constraint 
example tautological constraints contain type variables instance declaration instance monad st 
declares state transformer type st monad regardless type hand overlapping instance declarations permitted reducing tautological constraint way legitimate discuss section 
generalisation suppose example section embedded larger expression xs 
case xs 
false ys 
ys 
having inferred type right hand side type checker generalise type obtain polymorphic type possible types ord 

bool ord eq 

bool ord eq eq 

bool types inferred depends context reduction done generalisation topic discuss section 
need note choice time choice moment generalisation 
mean difference context reduction done just generalising just inferring type sub expression ys matters done generalisation 
overlapping instance declarations consider declarations class 
string instance 
instance char programmer wants different method char types 
say instance declarations overlap exists constraint matches 
example constraint char matches declarations 
general instance declarations instance 
instance 
said overlap unifiable 
definition equivalent saying constraint matches 
overlapping instance declarations illegal haskell permitted gofer 
context reduction constraint matches overlapping instance declarations chosen 
discuss question section address question overlapping instance declarations useful 
give examples 
default methods application overlapping instance declarations define default methods 
haskell standard classes class monad 


return 
class functor map 


instance monad sensible definition map idea express instance monad 
functor map instance declarations overlap instances functor 
best way explain instance monad natural definition map debatable 
monad transformers second application overlapping instance declarations arises try define monad transformers 
idea jones fact take forward thinking approach constructor class mechanisms define different families monads supports particular collection simple primitives 
benefit want consider monads simultaneously instances different classes support combination different primitive features 
approach proved flexible jones liang hudak jones 
combine features monads introduce notion monad transformer idea monad transformer takes monad argument produces new monad result provides computational features plus new ones added transformer class monadt lift monad 

example state monad transformer add state monad newtype statet statet 
instance monadt statet instance monad 
statemonad statet 
critically need know properties enjoyed original monad supported transformed monad 
capture formally instance monadt statemonad 
statemonad update lift update note overlap previous instance declaration plays essential role 
defining monad transformers way allows build composite monads automatically generated liftings important operators 
example statemonad int statemonad char 
int 
char 
int char update const update const return call function integer character argument monad constructed type statet int errort state char notice argument statet monad transformer state char enriched monad errort state char assuming errort monad transformer 
overloading automatically sure call update takes place outermost int state monad second call lifted depths innermost char state monad 
ambiguity problem observed earlier programs ambiguous typings 
classic example show read different choices intermediate type result read lead different results 
programs ambiguous typings rejected haskell 
preliminary experience multi parameter type classes give new opportunities ambiguity 
way multi parameter type classes risking ambiguity 
answer 
approach suggested ambiguity problem type classes insist class operations take argument value class type odersky wadler 
theoretically attractive useful classes constraint num example overloaded constants general adopted practice 
clear rule move constructor classes class type variable ranges type constructors 
workable solution ambiguity problem single parameter classes optimistic multi parameter classes 
design choices ready discuss design choices embodied type class system kind exemplified haskell 
goal describe design space includes haskell gofer number options 
express opinions design choices prefer primary goal give clear description design space prescribe particular solution 
ground rules type systems huge design space space explore part 
section briefly record design decisions currently embodied haskell propose 
set ground rules concern larger setting ffl want retain haskell type inference property 
ffl want type inference decidable compiler fail terminate 
ffl want retain possibility separate compilation 
ffl want existing haskell programs remain legal meaning 
ffl seek coherent type system different valid typing derivation program leads resulting program dynamic semantics 
point needs little explanation 
seen way context reduction performed affects dynamic semantics program construction dictionaries operational models experience similar effects 
essential way typing derivation constructed usually program affect meaning program 
give ground rules form class declarations 
class declaration takes form class 
ff ff op 
multi parameter type classes prohibited 
fi fi constraints appearing context say superclass insist ffl class declaration class ffl program uses applied arguments 
ffl ff ff distinct type variables 
ffl tv fff ff ng 
mention type variables ff ffl superclass hierarchy defined set class declarations acyclic 
restriction absolutely necessary applications cyclic class structures limited helps keep things simple 
give rules governing instance declarations form instance 
call instance context instance types head instance declaration 
haskell insist ffl tv tv instance context mention type variables mentioned instance types 
discuss design choices related instance declarations sections 
thirdly require rule types ffl 
type tv tv 
context mentions type variables value type certain ambiguous 
fourthly assume despite separate compilation instance declarations globally visible 
reason want able report error encounter constraint match instance declaration 
example consider type inference gives rise constraint num char 
instance declarations globally visible forced defer context reduction case called module instance declaration num char 
infer type num char 
char 
char really want report immediate error type checking instance declarations globally visible missing instance errors reported main module compiled unacceptable outcome 
explicit type force earlier error reports 
ground rule 
practice get away little weaker insisting instance declaration visible module example compiling standard library need instance declarations unrelated user defined types 
lastly useful articulate principle ffl adding instance declaration typed program alter static dynamic semantics program may give rise overlapping instance declaration error systems prohibit overlap 
reason principle support separate compilation 
separately compiled library module possibly see instance declarations possible client modules 
case extra instance declarations influence static dynamic semantics library conflict instance declarations library compiled 
decision form types decision limitations form context type 
haskell types inferred specified type signature form 
simple context 
say context simple constraints form ff class ff type variable 
design decision defensible haskell lacked constructor classes demonstrably wrong haskell 
example consider definition xs 
map xs xs right hand side definition type bool 
bool context eq bool second constraint reduced simple context rules haskell rejects definition ill typed 
fact insist context type simple function legal types bool 
bool principal general type 
allow contexts types perfectly sensible principal type functor eq bool 
bool 
bool short haskell lacks principal type property typable expression principal type regained allowing richer contexts types 
just theoretical directly affects expressiveness language 
definition class functor section 
similar problems occur multi parameter classes insist arguments constraint context variables natural generalization notion simple context 
example imagine inferring context io ffg ff type variable 
want generalise ff obtain function type form statemonad io ff 
type illegal previous example forced reject program sensible principal type slightly richer system 
choices allowable contexts types choice haskell context type simple extended definition simple 
choice gofer restrictions context type 
choice 
example insist context type reduced possible 
legal type signature illegal introduced new instance declaration type signature longer reduced possible 
decision context reduction decision context reduction done generalisation 
haskell gofer different choices 
haskell takes eager approach context reduction doing possible generalisation gofer takes lazy approach context reduction eliminate tautological constraints 
turns choice consequences jones chapter discusses detail 
consequences mainly concern pragmatic matters complexity types efficiency resulting program 
highly desirable choice context reduction done affect meaning program 
bad meaning program inevitably depends resolution overloading odersky wadler 
worse program meaning depended exact way overloading resolved type system incoherent section 
issues affecting context reduction 

context reduction usually leads simpler contexts readily understood written programmer 
earlier example ord simpler ford eq eq occasionally simpler context natural 
suppose data type set operation union ord instance jones section data set union eq 
set 
set 
set instance eq 
ord set 
consider function definition union context reduction type inferred eq 
set 
set 
set context reduction infer ord set 
set 
set 
set argue natural clear ord constraint comes contains slightly surprising eq constraint results unrelated instance declaration 

context reduction reduces number dictionaries passed functions 
running example section doing context reduction generalisation allowed pass dictionary 
simpler context constraints dictionaries pass dictionary passing implementation 
example instance declaration instance eq eq 
eq constraint eq reduce feq eq bg may simpler certainly shorter 

context reduction eliminates tautological constraints 
example context reduction function double 
int get type double num int 
int 
int type means dictionary num int passed double quite redundant 
invariably better reduce intg fg int instance num 
evidence int instance num takes form global constant dictionary num int 
example uses ground constraint reasoning applies tautological constraint 

delaying context reduction increases sharing dictionaries 
consider example xs xs xs xs haskell infer type ord 


bool dictionary ord passed construct dictionary ord 
example called twice type calls independently construct ord dictionary 
obtain sharing efficiency postponing context reduction inferring type ord 


bool passed dictionary ord dictionary shared calls context reduction postponed top level gofer sharing encompass program dictionary class type combination constructed 

type signatures interact context reduction 
haskell allows specify type signature function 
depending context reduction done contexts allowed type signatures type reduced inferred type 
example full context reduction normally done generalisation valid type signature eq 
type signature decrease amount context reduction performed 
direction context reduction usually done generalisation valid type signature 
eq 
right hand side generates constraint eq 
type signature increase amount context reduction performed 

context reduction necessary polymorphic recursion 
new features haskell ability define recursive function recursive call different type original call feature proved useful efficient encoding functional data structures okasaki 
example consider non uniformly recursive function eq 


bool true possible avoid runtime dictionary construction example call recursive dictionary higher type static bound depth recursion 
follows strategy context reduction top level ensuring finite number dictionaries 
type signature necessary type checker permit polymorphic recursion turn forces reduction constraint eq arises recursive call 
context reduction affects typability 
consider contrived program data tree nil fork tree tree silly nil eq instance tree program arguably erroneous silly performs equality type tree 
context reduction deferred silly complaint assigned type silly eq tree 

bool silly called type error result 
short definition programs typable depends rules context reduction 

context reduction conflicts overlapping instances 
bigger topic defer section 
bearing mind amazingly large set issues possible choices choice haskell eager reduce context simple context generalisation 
seen may mean perfectly reasonable programs rejected ill typed 
choice lazy context reduction constraints program gathered reduce 
decisive gives rise pretty stupid types eq eq eq 

bool num int show int 
int 
string choice gofer fairly lazy context reduction generalisation refrain rule inst tautological constraints 
overlapping instances permitted change tautological ground 
variant refrain super 
choice gofer polymorphic recursion added rule type signature inferred context entailed context type signature variable defined assigned type signature scope 
choice compatible polymorphic recursion 
choice relaxed leave un specified context reduction done generalisation 
actual context term generalised inferred context generalised term context reduces 
rule type signatures apply reason 
avoid problem item require error reported soon generalisation step encounters constraint possibly satisfied constraint reduced 
note rule choice type signatures 
furthermore shall see section choices rule overlapping instance declarations 
intent choice leave flexibility possible compiler efficient choice giving defined static dynamic semantics language ffl far static semantics concerned context reduction performed change set typable programs 
ffl concerning dynamic semantics absence overlapping instance declarations constraint match unique instance declaration 
decision overlapping instance declarations decision instance declarations overlapping identical instance types permitted 
see section overlapping instances permitted need rule specifies instance declaration choose matches particular constraint 
gofer rule declaration matches closely chosen 
general may unique instance declaration rules required disambiguate choice example gofer requires instance declarations may overlap substitution instance 
unfortunately 
mentioned fundamental conflict eager unspecified context reduction overlapping instances 
see consider definition true false defined section 
full context reduction generalising faced constraint arising 
eager context reduction simplify presumably instance declaration obtain type 

string call committed method 
suppose perform simple program transformation inlining call sites obtain expression true false true false calls distinct calls lead constraints char bool respectively lead call second lead call 
simple program transformation changed behaviour program 
consider original program 
deferred context reduction infer type 

string calls lead constraints char bool inlined case leading calls respectively 
short eager context reduction presence overlapping instance declarations lead premature particular instance declaration consequential loss simple source language program transformations 
overlapping instances incompatible reduction non ground tautological constraints 
example suppose declaration instance monad st trying simplify context st wrong reduce fg overlapping instance declaration instance monad st int 
inability simplify non ground tautological constraints practice caused gofer difficulties implementing lazy state threads launchbury peyton jones 
briefly runst insists argument type ff st ff argument type inferred monad st ff 
st ff summarise overlapping instances permitted meaning program depends detail context reduction takes place 
avoid loss coherence specify context reduction takes place part type system 
possibility defer reduction constraint possibly match instance declaration 
restores ability perform program transformations interacts poorly separate compilation 
separately compiled library see instances class client module uses conservatively assume context reduction done constraint involving type variable 
reasonable choices choice prohibit overlapping instance declarations 
choice permit instance declarations overlapping identical instance types provided substitution instance restrict uses inst rule ground contexts condition identifies constraints match instance declaration regardless instance declarations added 
decision instance types decision instance declaration instance 
limitations form instance types haskell single parameter type classes 
furthermore haskell insists single type simple type type form ff ff type constructor ff ff distinct type variables 
decision closely bound haskell restriction simple contexts types section 

faced constraint form unique instance declaration matches case constraint reduced case error signaled 
allowed type variable instance declaration potential match constraint 
example suppose instance foo tree int instance foo tree bool 
note overlap 
constraint foo tree ff type variable ff decide instance declaration know ff 
generalising ff function type form foo tree ff 
haskell allow types context simple sense haskell restrict instance types simple types 
types general contexts clear restriction sense 
come examples sense instance types simple types 
section gave examples instance type just type variable context overlapping instance declarations 
example class liftable lift 
lift 

lift 


instance liftable num 
num frominteger lift frominteger negate lift negate lift instance declaration entirely reasonable says liftable type constructor construct new numeric type existing numeric type declarations precisely generalises behaviour class elliott hudak encountered examples pattern 
probably noticed lift just map class functor functor superclass liftable 
disadvantage liftable haskell types ratio instances num indirectly making instances liftable 
fine complex ratio 
incidentally overcome problem overlapping instances instance liftable num 
num instance num 
num ratio 
reason wanting non simple instance types suggested john matthews 
old types new purposes 
example suppose want define class moveable things class moveable move vector 

points moveable 
point 
just pair floats 
want write instance moveable float float type point float float instance moveable point 
liftable example possible manage simple instance types making point new type newtype point float float instance moveable point tiresome example unzip split list points coordinates coordinates 
choice haskell instance type simple types 
choice instance types simple type type variable type variable 
restriction necessary ensure context reduction terminates 
choice instance types type variable 
choice permit liftable example 
permit instance declarations instance int instance bool overlapping instances prohibited provided course instance 
allow strange looking instance declarations instance 
int turn matching candidate instance declaration constraint little complicated 
overlapping instances permitted clear choices lead type system 
overlapping instances permitted technical objections examples suggest extra expressiveness useful 
decision repeated type variables instance heads decision instance declaration instance 
suggested simon thompson 
instance head contain repeated type variables 
decision really part decision deserves separate treatment 
consider instance declaration repeated type variable instance type instance 
foo 
haskell illegal technical reason exclude 
furthermore useful instance st section repeated type variables iso example section 
permitting repeated type variables instance type instance declaration slightly complicates process matching candidate instance declaration constraint requiring full matching way unification understood algorithm 
example matching instance head foo ff ff constraint foo bind ff check equality bound ff choice permit repeated type variables instance head 
choice prohibit repeated type variables instance head 
decision instance contexts decision instance declaration instance 
limitations form instance context 
mentioned section require tv tv 
haskell drastic restriction requires constraint form ff ff type variable 
important motivation restriction sort need ensure termination context reduction 
example suppose declaration allowed instance 

trouble context reduction terminate reduce context simpler context 
instance declaration reduce constraint complicated context reduction diverge 
occur practical applications instance declarations permitted gofer consequence type system fact undecidable 
short essential place constraints instance context ensure context reduction converges 
need ensure gets smaller passage haskell restriction simple contexts certainly ensures termination argument types guaranteed get smaller 
principle instance declarations irreducible non simple contexts sense instance monad 
foo 
find convincing examples 
context reduction deferred choices permit non simple instance contexts 
example data tree node tree instance eq eq tree 
eq tree node ts node ts ts ts permitted reduce constraint eq tree appear instance context 
lastly constraints involve type variables multi parameter type classes involved ask single constraint may contain repeated type variable instance foo 
baz 
technical reason prohibit 
choice constraints context instance declaration form ff ff ff distinct 
choice choice requirement ff distinct 
choice restrictive way ensuring decidability context reduction 
decision superclasses permitted decision class declaration class 
ff ff op 
limitations section form superclass context 
haskell restricts consist constraints form fi fi fi member fff ff ng fi distinct 
wrong 
class foo 
baz 
case technical reason prohibit 
choice constraints superclass context haskell constraints form ff ff ff distinct subset type variables occur class head 
choice limitations superclass contexts postulated section 
decision improvement suppose constraint properties ffl contains free type variables ffl match instance declaration ffl match instance declaration instantiating constraint free type variables ffl matter legal instance declarations added instance declaration constraint match way 
things true attractive idea improve constraint instantiating type variables constraint match instance declaration 
programs typable 
compromise principles condition ensures adding new instance declarations change way improvement carried 
improvement introduced jones 
full discussion scope 
conditions quite restrictive clear improve useful programs worth extra effort 
choice improvement 
choice allow improvement form 
choice obviously need elaboration design decision formulated 
decision class declarations decision limitations contexts class member type signatures 
presumably type signatures obey rules type signature haskell adds additional restriction 
consider class op 
op eq 

haskell type signature op illegal constrains class type variable technical reason restriction 
simply nuisance haskell specification implementation occasionally programmer 
choice haskell context class member type signature mention class type variable addition subject rules type signature 
choice type signature class member subject rules type signature 
recall matching constraint instance declaration way unification may instantiate type variables instance head constraint 
avenues writing number extensions haskell type class system suggested raise considerable technical difficulties 
enumerate section identifying difficulties 
anonymous type synonyms exposed multi parameter type classes particular higher order type variables programmers seek expressive type language 
example suppose classes foo bar class foo 
class bar 
concrete binary type constructor data baz 
easily write instance declaration declares bar functor instance functor baz map 
suppose baz really functor argument 
really want say type zab baz instance functor zab map 
haskell prohibits partially applied type reason partially applied type synonym effect lambda abstraction type level takes immediately realm higher order unification minimises likelihood decidable type system jones section 
possible incorporate form higher order unification lines miller substantial new complication sophisticated type system 
relaxed superclass contexts ground rules type variables context class declaration subset type variables class head 
rules declarations class monad 
statemonad get set 
idea context indicates monad type rewriting definition overloading state class monad 
statemonad get set 
satisfactory forces pass dictionaries say statemonad state int statemonad state bool really 
really want universal quantification class forall monad 
statemonad get set 
means type system handle constraints universal quantification substantial complication 
ground rule restriction acyclic superclass hierarchies 
gofer puts restriction form predicates may appear superclass contexts particular allows mutually recursive class hierarchies 
example iso class example section written elegant way allow recursive classes class iso 
iso iso 
superclass constraint ensures type isomorphic type isomorphic needless say class declarations easily give lead undecidable type system 
scope instances wishes possible instance declaration instance type extreme case overlap 
example part program instance declaration instance ord 
instance ord 
evidence notice haskell standard library functions take explicit comparison operator argument reflecting fact ord instance data type involved ordering want sort 
having multiple instance declarations type fraught risk losing coherence involves strict control instance declarations visible 
far obvious controlling scope instances right way tackle problem functors ml look appropriate 
relaxed type signature contexts programming type classes case ambiguous type know fact harmless 
example knowing instance declarations program sure ambiguous example section iso iso eq iso int 
bool value irrespective choice possible modify type system deal cases 
type system finely balanced virtually extension destroys desirable properties 
haskell type class system turns property sensible extensions gain expressiveness involving major new complications 
tried summarise design choices fairly un biased manner time nail colours mast 
set design choices define upward compatible extension haskell losing important ffl permit multi parameter type classes 
ffl permit arbitrary constraints types type signatures choice 
ffl inst context reduction rule forced type signature constraint tautological choice 
choice viable 
ffl prohibit overlapping instance declarations choice 
ffl permit arbitrary instance types head instance declaration type variable choice 
ffl permit repeated type variables head instance declaration choice 
ffl restrict context instance declaration mention type variables choice 
ffl limitations superclass contexts choice 
ffl prohibit improvement choice 
ffl permit class variable constrained type signatures choice 
hope provoke informed debate possible extensions haskell type classes 
particularly seek wider range examples illustrate motivate various extensions discussed 
koen claessen thomas john matthews sergey alastair reid scholz walid taha simon thompson carl witty helpful feedback earlier drafts 
meijer peyton jones gratefully acknowledge support oregon graduate institute funded contract air force material command 
chen hudak odersky june parametric type classes acm symposium lisp functional programming snowbird acm 
elliott hudak june functional reactive animation proc international conference functional programming amsterdam acm 
hudak sl peyton jones pl wadler arvind boutel fairbairn fasel guzman hammond hughes johnsson kieburtz rs nikhil partain peterson may report functional programming language haskell version sigplan notices 
mp jones jan system constructor classes overloading implicit higher order polymorphism journal functional programming 
mp jones june simplifying improving qualified types proc functional programming languages computer architecture la jolla acm 
mp jones may implementation gofer functional programming system yaleu dcs rr department computer science yale university 
mp jones may functional programming overloading higher order polymorphism international spring school advanced functional programming techniques sweden springer verlag lncs 
mp jones nov qualified types theory practice cambridge university press 
kaes jan parametric overloading polymorphic programming languages th acm symposium principles programming languages acm 
launchbury sl peyton jones dec state haskell lisp symbolic computation 
liang hudak jones jan monad transformers modular interpreters nd acm symposium principles programming languages san francisco acm 
miller logic programming language lambda abstraction function variables simple unification journal logic computation 
odersky pl wadler june second look overloading proc functional programming languages computer architecture la jolla acm 
okasaki sept purely functional data structures phd thesis cmu cs department computer science carnegie mellon university 
sl peyton jones sept bulk types class electronic proceedings glasgow functional programming workshop www dcs gla ac uk fp workshops proceedings html 
sl peyton jones aj gordon finne jan concurrent haskell rd acm symposium principles programming languages st petersburg beach florida acm 
pl wadler blott jan ad hoc polymorphism ad hoc proc th acm symposium principles programming languages austin texas acm 
