system support software fault tolerance highly available database management systems copyright fl mark paul sullivan system support software fault tolerance highly available database management systems mark paul sullivan today software errors leading cause outages fault tolerant systems 
system availability improved despite software errors fast error detection recovery techniques minimize total downtime outage 
dissertation analyzes software errors commercial systems describes implementation evaluation techniques early error detection fast recovery database management system dbms 
software error study examines errors reported customers ibm systems programs mvs operating system ims dbms db dbms 
study classifies errors type coding mistake circumstances customer environment caused error arise 
observes higher availability impact addressing errors uninitialized pointers software errors 
details frequencies types addressing errors characterizes damage 
error detection evaluates hardware write protection detect addressing related errors quickly limit damage occur software error 
system calls added operating system allow dbms guard write protect internal data structures 
guarding dbms data provides quick detection corrupted pointers similar software errors 
data structures guarded long correct software means temporarily data structures updates 
dissertation analyzes effects different update models performance software complexity error protection 
improve dbms recovery time previous postgres dbms suggested storage system overwrite techniques write ahead log processing 
dissertation describes modifications storage system improve performance environments high update rates 
analysis shows modifications non volatile ram requirements postgres running tp benchmark conventional system despite postgres force commit buffer management policy 
dissertation presents extension postgres support fast recovery communication links dbms clients 
dissertation adds fast recovery capabilities postgres techniques maintaining tree index consistency log processing 
technique similar shadow paging improves performance integrating shadow meta data index meta data 
technique uses phase page reorganization scheme reduce space overhead caused shadow paging 
measurements prototype implementation estimates effect algorithms large trees show limited impact data manager performance 
ii go iii contents list figures vi list tables viii software failures data availability model software errors incorporating error propagation existing approaches software fault tolerance organization dissertation survey software errors systems programs previous gathering software error data sampling retain characterizing software defects results error type distributions comparing products impact error triggering events failure symptoms summary write protected data structures postgres system assumptions models updating protected data overview page guarding strategies expose page update model deferred write update model contents iv expose segment update model performance impact guarded data structures performance guarding dbms performance guarding dbms reducing guarding costs architectural support reliability impact guarded data structures previous related guarded data structures summary fast recovery postgres dbms overwrite storage system saving versions tuple differences garbage collection archiving recovering database failures validating tuples historical queries performance impact force commit policy benchmark conventional disk subsystem group commit non volatile ram raid disk subsystems raid log structured file system summary guarding disk cache recovering session context communication architecture postgres recovery mechanism postgres sessions restarting transactions lost failure summary supporting indices postgres storage system assumptions support postgres indices traditional tree data structure sync tokens synchronous writes technique shadow page indices technique page reorganization indices delete merge rebalance operations secondary paths leaf pages link tree dynamic hashing postgres contents concurrency control shadow indices logical logging performance measurements modelling effect increased tree heights measurements postgres link tree implementation estimating additional costs recovery summary providing availability long running queries fast recovery main memory database manager automatic code error check generation high level languages bibliography vi list figures causes outages tandem systems db error type distribution ims error type distribution mvs regular sample error type distribution control addressing data error breakdown db ims mvs systems summary addressing error percentages previous distribution common control errors distribution common addressing errors mvs overlay sample error type distribution db error trigger distribution ims error trigger distribution mvs error trigger distribution error type distribution error handling triggered db error type distribution error handling triggered ims mvs overlay sample failure symptoms mvs regular sample failure symptoms ims failure symptoms db failure symptoms postgres process architecture example extensible dbms query expose page update model deferred write update model remapping avoid copies deferred write costs updating protected records forward difference chain backward difference chain creating overflow page list figures vii tuple qualification phases client server communication protocol conventional tree page shadowing page strategy shadowing page split page splits transaction page split page reorganization trees merge operation balanced shadow tree normal link tree worst case inconsistent link tree height tree different size trees viii list tables average size overlay distance intended write address operating system dbms error impacts raw costs guarding system calls performance impact guarding cpu bound version postgres performance impact guarding io bound version postgres summary traffic conventional disk subsystem group commit conventional disk subsystem summary traffic nvram available comparison random os raid conventional disk subsystem comparison os lfs raid non lfs conventional disk subsystem insert lookup performance comparison chapter software failures data availability commercial computer users expect systems highly reliable highly available 
system service specification system reliable deviate specification performs services 
system available prepared perform services legitimate users requests 
fault tolerant system designed provide high availability reliability spite failures hardware software components system 
fault tolerant system production maintains high reliability error detection halting operation providing incorrect result 
fault tolerant systems achieve high availability recovering transient state quickly error detected minimizing time increase availability 
traditionally fault tolerant systems focused detecting masking hardware chapter 
material faults hardware redundancy 
today fault tolerant systems software failures hardware failures largest cause system outage 
compares outage distributions years year study tandem highly available systems 
outages classified nature failure caused outage 
software outages caused failures operating system database management system application software 
hardware outages caused double failures hardware components including microcode 
errors people manage maintain system separated operator maintenance errors system owners controlled day day operations tandem responsible routine maintenance 
environment failures include fires floods power outages greater hour 
tandem studies outages shifted time fairly mix sources distribution dominated software failures 
software went causing outages 
second third largest contributors operations hardware fault time respectively 
tandem trend due worsening software quality success outages caused hardware maintenance failures 
tandem systems gradually reliable mean time system failures risen years years 
reliability hardware components systems built increased 
hardware redundancy techniques gone long way detecting masking faults hardware components wear 
increasingly chapter 
failures percent hardware maint 
environ 
operator software causes outages tandem systems 
chart represents results years year study 
outages classified nature component failed 
graph shows dramatic shift software primary cause system outage 
bars year sum causes outages identified 
chapter 
reliable hardware needs maintenance 
maintenance required maintenance tasks automated order limit errors maintenance engineers 
rate operator errors remained constant soon improve reasons maintenance error rates improved 
operator interfaces complex operators mistakes 
time tasks currently done operators automated removes opportunity operator errors 
progress areas noticeable impact growing dominance software outages making continued advances non software fault tolerance important 
second study tandem indicates software related limit system fault tolerance 
software cause original outage determines duration outage 
outage sort occurs system reestablish software state lost time failure 
system unavailable users 
thorough approach improving system availability address software restart time 
dissertation focuses part software fault tolerance problem improving reliability availability database management system dbms 
integrity availability data managed dbms usually important feature environments fault tolerant systems 
tandem outage study dbms accounted third software failures remainder divided operating system communication software applications 
focus dbms chapter 
applicable systems programs 
presenting approach software fault tolerance taken dissertation chapter introduces model errors describes existing software fault tolerance techniques 
model terms defined section dissertation 
review software fault tolerance literature section description error model 
final section outlines remainder dissertation 
model software errors incorporating error propagation software error model dissertation highlights significant differences hardware software failure modes error propagation 
redundancy hardware components detect errors recover disturbing system 
software errors hand cause damage detected immediately 
damaged system initiate sequence additional software errors executes eventually causing system corrupt permanent data fail 
error propagation complicates software failure modes making code difficult reason test debug 
reproducing propagation related failures debugging difficult error propagation timing dependent 
explore software fault tolerance techniques dbms propose model chapter 
distinguishes software errors ways propagate damage parts system 
model breaks software errors classes control errors addressing errors data errors 
control errors include programmer mistakes deadlock point control program counter lost program illegal state transition 
corruption occurs variables representing current state program 
control errors propagate broken module communicates parts system 
addressing errors corrupt values faulty routine intend operate 
uninitialized pointer addressing error example 
propagation addressing errors difficult control standpoint module data corrupted error random happens time module designers expect communicate faulty module 
data errors corrupt values computed faulty routine 
data error causes program result 
control errors data errors propagate modules related routine error 
addressing errors source corruption data control error tracked debugging examining code known corrupted data 
database management systems impact cross module error propagation caused addressing errors may increase trends dbms design data manager extensibility main memory resident databases 
extensible dbmss include extended relational systems object oriented systems dbms toolkits 
extensible dbms lets users database administrators add access methods operators chapter 
data types manage complex objects 
moving functionality dbms clients dbms improves application performance worsen system failure behavior 
extensibility allows different object managers varying degrees trustworthiness run data manager 
time user system tries new object manager combine existing ones different way risk uncovering latent errors 
addressing errors risk confined person new feature affects reliability availability achieved concurrent users database 
system designers realized time dbms performance improve dramatically database resided entirely main memory residing primarily disk 
years ago main memory capacity factor limiting appeal main memory dbmss 
high systems today main memories large hold databases available memory prices dropping 
commercial systems main memory dbmss probably system designers believe data stored main memory corrupted errors data stored disk 
corruption due hardware power failures eliminated existing redundancy techniques discussed applied large main memories 
operator maintenance errors harm data disk easily data memory 
leaves software errors largest remaining reliability difference disk resident databases memory resident ones 
main danger error propagation addressing errors important differences risk data main chapter 
memory disk 
existing approaches software fault tolerance current strategies reducing impact software errors systems fall classes fault prevention fault tolerance 
system designers obviously prefer software errors invent techniques tolerating 
software errors prevented modular design exhaustive testing formal software verification 
survey error prevention techniques 
software designs incorporate techniques complexity size concurrent systems programs operating system database management system error prevention insufficient achieving high system reliability availability 
fault prevention effective software fault tolerance techniques detect mask errors occur system 
hardware fault tolerance software fault tolerance usually redundancy 
software errors usually design errors material failures redundancy techniques limited effectiveness software 
redundant hardware components expected fail independently software design errors cause failure independently redundant components 
redundant software schemes mask software errors triggered hardware transients unusual events interrupts arrive redundant components different times 
chapter 
systems tolerate software faults usually employ spatial redundancy temporal redundancy hybrid 
spatial redundancy uses concurrent instances program running separate processors hope error strikes instance occur 
temporal redundancy system tries clean system state damaged error retry failed operation 
wulf distinction spatial temporal redundancy reliability hydra system 
version programming famous spatial redundancy technique designed software analog triple modular redundancy tmr techniques commonly hardware fault tolerance 
version programming versions program designed implemented different team programmers 
versions run simultaneously comparing results voting resolve conflicts 
theory independent programs fail independently 
practice multiple version failures caused errors common tools errors program specification errors voting mechanism commonalities introduced bug fixes 
furthermore experimental indicated independent programmers mistakes 
surprisingly different programmers find tasks difficult code correctly 
example different programmers forget check boundary conditions 
database management systems rely temporal redundancy recover software errors 
recovery techniques surveyed reuter restore chapter 
database transaction consistent state hopes error occur 
database management system clients aborted result failure 
randell describes temporal redundancy method called recovery blocks 
block code acceptance test run 
test fails operation retried alternate routine 
ideally reimplementation routine simpler efficient original routine 
recovery blocks require fewer hardware resources version programs may ineffective reasons version programs 
process pairing hybrid spatial temporal redundancy identical version program runs backup primary 
primary backup run separate processes different processors 
addition masking software errors process pairs reduce availability impact hardware errors primary backup run different processors 
hardware error causes processor running primary process fail backup process take clients primary 
team programmers required process pair considerably cheaper version program 
similar scheme 
spatial temporal redundancy hybrid method uses redundant data address space reconstruct data structures damaged errors 
error detected operation data structure structure rebuilt redundant data operation retried 
system tolerate software errors errors detected chapter 
place 
common approach error detection systems programs program additional code checks errors 
include data structure consistency checkers pass program data examine internal consistency 
detecting errors quickly systems redundant components limit chance minor errors propagate worse ones 
unfortunately checking errors expensive 
published figures available regarding cost error checking dbms run time checks array bounds overruns fortran programs double program execution time 
furthermore checkers software errors 
error checking usually done systematically 
checking code maintained software checks maintained 
implementing testing error checkers increases development cost 
organization dissertation dissertation contributions goal improving software fault tolerance database management systems 
assembles analyzes body information software errors useful software availability reliability researchers 
second describes implementation evaluation mechanism detecting addressing errors conjunction existing ad hoc consistency checkers 
extends dbms fast recovery techniques postgres storage system order improve availability 
chapter 
chapter examines error data collected software failures ibm customer sites order improve system designers understandings ways software causes outage 
chapter presents results software error studies mvs operating system ims db database management systems compares results earlier software error studies 
chapter shows errors reported systems control errors addressing data errors respectively classified model 
addition control addressing data error breakdown chapter provides finer grain classes include detail exactly programmer error 
mvs study gives specific information error propagation caused addressing errors 
example errors software errors high impact availability experienced customers 
addressing errors mvs tend small corrupt data near data structure software intended operate 
data chapter provide larger picture software failures high commercial systems hope useful studying fault tolerance software testing outside context dissertation 
chapter focuses hardware write protection detect errors quickly limit damage occur software error 
system calls added sprite operating system allow dbms guard write protect internal data structures 
guarding dbms data provides quick detection corrupted chapter 
pointers array bounds overruns common source software error propagation 
data structures guarded long correct software means temporarily data structures updates 
dissertation analyzes effects different update models performance software complexity error protection 
measurements dbms uses guarding protect buffer pool show eleven percent performance degradation debit credit benchmark run main memory database 
guarding percent impact conventional disk database read data structures guarded affect dbms performance 
lessen availability impact errors detected dbms restart quickly errors detected 
chapter develops approach fast recovery centered postgres storage system 
original postgres storage system designed restore consistency disk database quickly consider fast restoration non disk state network connections clients 
chapter describes extensions postgres required fast reconnection dbms client processes 
chapter describes set optimizations reduce impact storage system everyday performance making fast recovery practical databases high transaction rates 
chapter presents analysis impact postgres storage system tp debit credit workload 
analysis shows optimized storage system amount conventional dbms sufficient amount non volatile ram available 
chapter widens applicability postgres fast recovery techniques chapter 
extending postgres storage system handle index data structures 
postgres storage system recovery strategies effective restoring consistency heap relation log processing different strategies taken maintaining consistency complex disk data structures indices 
algorithms described chapter allow postgres recover tree tree hash indices write ahead log 
algorithm similar shadow paging improves performance integrating shadow meta data index meta data 
algorithm uses phase page reorganization scheme reduce space overhead caused shadow paging 
designed postgres storage system algorithms useful conventional storage system support logical logging 
techniques postgres tree lookup operations slower conventional system workloads 
cases postgres lookups require extra disk hand system running transactions immediately recovery restoring consistency database 
sixth chapter concludes describes avenues research 
dissertation distinct sections literature review chapter included chapter 
chapters attack problems interest fault tolerant system designers describe character software errors improve error detection widen applicability existing fast recovery techniques 
chapter survey software errors systems programs technique improving system reliability availability underlying model system failure 
technique successful real systems fail ways covered model 
described model system failure kinds software errors propagate errors different ways 
model guided approach maintaining high availability postgres motivated techniques described chapters 
chapter analysis errors discovered commercial systems programs 
analysis helps clarify control addressing data error model reliability availability impact chapter 
survey software errors systems programs techniques described dissertation 
chapter describes studies software errors identified mvs operating system ims db database management systems 
data available studies comes internal ibm database error reports 
report filed customer service representative software failed customer site field 
ibm programmers repair fault amend error report details fix 
studies considered errors fixes eventually 
classified ibm error data different ways considering cause error slightly different perspective 
chapter concentrates classifications error type error trigger 
error type provides insight programming mistakes cause software failures customer sites 
better understanding programming mistakes help programmers recovery system designers software tool designers improve code quality 
error trigger illustrates circumstances latent errors arise customer sites 
software testing supposed uncover latent errors code shipped customers trigger data help show testing strategies improved 
chapter includes statistics failure symptoms characterize way system failed executed faulty code 
original data classification process prone error studying different programs important 
program provides fairly independent error sample programmers people wrote bug reports different chapter 
survey software errors systems programs 
mvs ideal source error data operating system database management system 
resource management issues dbmss oss 
dbms os programs similar size written similar systems programming languages kinds concurrency availability performance requirements 
available data mvs choice additional source error information 
second reason mvs chosen source error data mvs maintenance programmers noted existence addressing errors standard way 
mvs damage caused addressing related error called overlay ibm field service personnel 
searching error reports term allowed collect large sample error reports discuss addressing related errors 
error reports compared mvs error reports 
error detection mechanism described chapter affects addressing errors important gather additional information possible character addressing errors 
chapter organized follows 
section summarizes related software error studies 
section describes data ibm studies classification systems characterize data 
section presents results studies section summarizes implications results system availability techniques 
additional details studies see compares addressing errors errors mvs focuses control errors discusses differences operating system database management system errors 
chapter 
survey software errors systems programs previous liked survey data collected analyzed researchers evaluate effectiveness postgres error detection techniques gather data 
unfortunately error studies difficult adapt purposes ones original researchers mind 
early error studies tried show importance clear software specifications improved code quality 
endres studied software errors internal testing dos vs operating system 
classification oriented differentiating high level design faults low level programming faults 
glass provides high level picture software errors discovered development process 
study gave detail kind coding errors caused programs fail help 
important reason existing surveys software errors ideal studying system availability focus errors discovered system test code development phases program life cycles 
errors affect availability ones discovered customer sites development testing complete 
early error study provides level error analysis study provides errors discovered testing validation phases 
basili study relationship software errors complexity fortran programs 
study finds predominance errors interfaces modules study focuses development test phases 
knuth chapter 
survey software errors systems programs describes design coding errors uncovered tex text processing program 
presentation includes efforts fault categorization largely collection anecdotes 
applicable studies program written person team programmers different application database manager 
studies covers program development early test phases 
researchers examined failures system software customer sites provide little detail types software errors led failure 
example study software manages ess telephone switch 
study break errors classes uses error data estimate effectiveness standard reliability metrics 
metrics trends bug fix rates guess errors remain piece code 
managers information decisions release dates kind information evaluate potential error detection recovery strategies 
studies data error logs track failures customer sites 
error log records generated automatically system program fails 
log entries generated automatically give extremely high level representations error 
example log entry code indicating program tried store invalid address 
error log include semantic information error needed determine programmer wrong 
chapter 
survey software errors systems programs gathering software error data data available studies came ibm internal field service database called remote technical assistance information network retain 
retain serves central database hardware problems software problems bug fixes release information 
ibm system fails ibm service personnel retain determine failure occurred site 
information stored retain identifies tape containing fix problem 
problem occurred people assigned track repair fault caused failure 
quite possible fault occur multiple sites 
ibm fixes errors soon possible detected customers delay installing fixes systems taken reasons maintenance 
cases customer prefers risk occurrence known bug suffer periodic additional outages install fixes 
new software error arisen ibm product customer service person files authorized program analysis report apar describing fault retain 
apar identifies standard attributes associated faulty software type machine running software software release number symptom code describing failure severity rating 
service person filing apar adds text description fault information available 
error repaired programmers responsible repair writes description fix initial problem description severity rating 
chapter 
survey software errors systems programs contain standardized fields identifying cause fault 
semantic information fault circumstances arises contained apar text 
text oriented retain searches ibm service personnel fault occurs different site 
contains information effects fault fault 
ibm saves apar distinct fault occurs software products apar include accurate count frequency error occurs 
problem reports filed customer outage caused unique fault 
include field apar associated software problem theory determine frequency observed faults 
retained ibm months 
accuracy pmr apar associations questionable 
untraceable software error occurs ibm service customer site agree reboot newest version software hope best 
fault transient error go away new software contain fix 
earlier studies suggest transient software faults fairly frequent 
software errors worse customer perspective mistake error studies give apars retain equal weight 
apars describing errors little impact availability discarded studies 
included suggestions user interface changes errors affected presentation content program results garbage characters printed chapter 
survey software errors systems programs terminal prompt 
errors especially high impact singled examined detail 
retain identify high impact errors directly standard apar attributes estimate impact error described 
severity code supposed indicate badly customer outage 
indicate priority bug people assign maintenance programmers fix 
severity apars worst affect availability 
customer stated site progress fault fixed 
severity errors customer impact lower priority maintenance teams customer temporary solution fault 
severity apars correspond lesser damage range annoyance look feel interface problems 
hiper highly pervasive error flag assigned change team fixes faulty code 
hiper software errors considered affect customer sites just discovered error 
flagging error hiper provides message branch offices encourage customers upgrade fix 
ipl errors destroy operating system recovery mechanism require initiate initial program load ipl reboot 
ipl clearly high impact event cause outage minutes 
metric probably objective impact measurements little room data inaccuracy 
chapter 
survey software errors systems programs labeling error hiper severity judgement call occurrence ipl difficult mistake 
note ipl effective impact estimator mvs dbms error study errors cause operating system ipl 
db ims errors dbms failed restart counted high impact information included apar 
impact estimators retain apars broken groups 
low impact apars severity ratings discarded study 
severity apars serious considered study labeled high impact 
errors flagged hiper ipl severity considered high impact errors 
error distributions chapter high impact errors singled separately 
mvs study uses error data mvs operating system period representing machine years execution 
includes errors operating system low level software products bundled 
ims db apars drawn recorded database management systems years 
second study took errors period conducted year db mature large apar base 
chapter 
survey software errors systems programs sampling retain possible classify apars software apars retain associated mvs ims db classified order find complete distribution errors products 
retain provides help regard 
allows users identify subsets apars simple keyword searches keyed fields hiper severity 
keyword searches allow report customer impact statistics entire population apars associated product 
error type triggering event unfortunately complex identify reading apar text extracting fault information change team problem description 
classifying thousands available apars get information resources available study 
sampled population available apars order restrict number apars read 
mvs study constructed sets apars regular sample overlay sample 
gather regular sample drew apars population severity apars filed mvs 
derive overlay sample just take subset mvs apars involved overlay errors mvs sample small 
searched text parts apar strings containing words overlay overlaid 
restricted set apars drew apars potential overlays 
ibm software engineers term overlay mean stored top data currently memory occasionally overlay legitimate behavior unrelated error described 
reading allowed weed chapter 
survey software errors systems programs apars overlay caused broken software leaving overlay apars 
dbms study randomly sampled ims severity apars db 
mvs regular sample taken straightforward way sampling error initial phases study 
planned examine severity apars 
realized severity errors high customer impact mistake ignore study 
overcome problem pulled second independent random sample population severity apars 
combined results severity samples proportion represented population 
boot strapping combine samples simple weighted average 
boot strapping common statistical technique build assumptions distribution parent population weighted average 
characterizing software defects error studies approach cause error standpoint programmer recovery manager standpoint system test designer 
error type low level programming mistake led software failure 
error trigger classification meant give insight software testing process 
ibm customers test software thoroughly customer relies heavily software failures impact 
error arises customer site chapter 
survey software errors systems programs aspect customer execution environment caused defective code executed code executed system test 
error trigger classification distinguishes different kinds events cause errors remained dormant testing surface customer site 
better understanding triggering events improve testing process 
identify error type error trigger classes passes sample looking commonalities errors 
general categories chosen read apar carefully placing possible categories error type category error trigger 
apars samples associated error type error trigger apar occasionally mentioned related faults software 
classifying apars categories apars merged larger general classes 
apar categories grouped category reasonably grouped apars meaningful error type 
error types programming errors caused errors programs studied 
error types defined study mvs allocation management module deallocates region memory region 
region reallocated original module continues chapter 
survey software errors systems programs original capacity 
errors memory region allocated small data stored counted allocation management errors 
copying overrun program copies bytes past buffer 
data error arithmetic error code produce read wrong data 
pointer management variable containing address data corrupted 
example linked list terminated setting chain pointer nil set head element list 
statement logic statements executed wrong order omitted 
example routine returns early circumstances 
forgetting check routine return code statement logic error 
synchronization error occurred locking code synchronization threads control 
type mismatch field added message format structure code structure modified reflect change 
type mismatch errors occur meaning bit bit field redefined 
undefined state system goes state designers anticipated 
example program may code handle session message chapter 
survey software errors systems programs arrives session completely initialized 
uninitialized variable variable containing pointer data initialized 
error categories members combined single category called 
unknown error report described effects error adequately classify 
dbms study added error types set classify mvs 
additional error types represent refinement classification system data second study 
errors classes mvs uncommon fell class original mvs study 
interface error module interface defined incorrectly incorrectly client 
memory leak program deallocate memory allocated 
wrong algorithm program works uses wrong algorithm task hand 
usually performance related problems 
chapter 
survey software errors systems programs error triggering events classification describes circumstances allowed latent error surface customer environment 
error sample assigned trigger events workload software failures occur limit conditions 
users submit requests unusual parameters please process zero records 
hardware configuration may unique system run faster disk available testing 
workload system configuration unique 
little memory network message buffering 
bug fixes error introduced earlier error fixed 
fix error way triggered customer environment fix uncover latent bugs related parts code 
client code errors occurred errors propagated application code running protected mode 
order appear apars sampled code recovering propagated error contain fault 
recovery exception handling recovery code notoriously difficult debug difficult test completely 
dbms data distinguishes full dbms recovery log cleanup transient errors exception handling 
chapter 
survey software errors systems programs timing timing triggers important special case workload triggers unanticipated sequence events directly causes error 
error occurs program interrupted moment error 
unknown triggering event determined available data 
failure symptom codes apar opened symptom code recorded describing external effects fault 
field customer service personnel search existing fix error discovered 
focus symptoms symptoms usually best information available fault occurs 
symptom code apar assigned part apar studies simply analyzed data retain 
single failure may symptoms 
maintenance programmers decide interesting record apar symptom code field 
interesting failure symptoms maintenance programmer may interesting fault tolerance research 
example unusual error message system printed screen went infinite loop recorded failure symptom infinite loop 
failure symptoms fall classes abend abnormal program termination occurred 
currently running application program failed restarted 
chapter 
survey software errors systems programs address error system fails trying bad address 
endless wait processes wait event occur 
incorrect output system produces incorrect output detecting failure 
infinite loop system goes infinite loop 
error message system perform requested function prints error message screen performs local recovery results describe results ibm studies section comparing mvs ims db possible 
results section divided subsections different apar categorization schemes defined section 
largest subsections discusses error type categorization types programmer mistakes 
error type subsection gives breakdowns control addressing data errors order provide better understanding error propagation model chapter 
gives finer grain description programmer errors error types defined subsection 
subsection describes error triggering events interest system test suite designers 
interest recovery system design indicates frequency repeatable software errors 
third subsection compares number high impact errors chapter 
survey software errors systems programs db ims mvs mvs overlay apar samples 
fourth subsection gives failure symptoms describe system behavior error occurred 
error type distributions figures summarize error type distributions database management system 
shows breakdown error types regular sample mvs study 
shows distributions availability related apars high impact apars 
high impact distribution superimposed distribution high impact apars subset apar sample 
bar represents error types defined section 
length bar shows number errors represented apar sample caused type error 
dbms products undefined state control error largest error type 
ims undefined state errors accounted high impact errors 
largest class pointer management addressing error accounted apars sampled 
db undefined state accounted apars high impact ones 
db highest class pointer management errors 
undefined state important source errors mvs dominate error type distribution ims db high impact errors 
pointer management class mvs errors dbmss 
chapter 
survey software errors systems programs number apars wrong algorithm data error synchronization statement logic memory leak interface error undefined state uninitialized var pointer mgmt 
copying overrun allocation mgmt 
high impact apars apars apars high impact error type freq db error type distribution 
number apars wrong algorithm data error synchronization statement logic memory leak interface error undefined state uninitialized var 
pointer mgmt 
copying overrun allocation mgmt 
high impact apars apars apars high impact error type freq ims error type distribution 
chapter 
survey software errors systems programs percent apars ptf compilation unknown data error statement logic synchronization undefined state type mismatch uninitialized var 
pointer mgmt 
copying overrun allocation mgmt 
high impact apars apars apars high impact error type mvs regular sample error type distribution 
remainder subsection explores error type data greater detail 
combine error types broader classes control addressing data error model chapter 
describe programming mistakes led control errors addressing errors 
subsections focus undefined state errors dominate control error distribution kinds error propagation result addressing errors 
control addressing data error model groups errors products categories control related errors addressing related errors data related errors unclassified errors 
produce error type categories defined section combined cate chapter 
survey software errors systems programs total faults db ims mvs data unclassified addressing control percent control addressing data error breakdown db ims mvs systems 
gories control addressing data model 
errors unclassified group largely performance related problems wrong algorithm errors unknown categories 
mvs study largest fraction unclassified apars part study error types defined study 
axis chart shows percentage errors product sample fall class absolute number apars 
mvs chart mvs regular sample 
products control errors significant fraction errors addressing errors second significant 
control errors common composing total product 
larger fraction chapter 
survey software errors systems programs ims errors control related errors products 
part ims late product life cycle time covered study 
new features added ims changes code occur maintenance 
data maintenance programmers difficulty understanding implications change control flow program 
db data errors products 
errors mistakes calculating cost prospective query plan planning stage query execution 
data comes errors discovered software released customers possible causes error distributions 
possibly distributions represent frequency kind programming mistake occurs 
programmers may simply control errors data errors 
explanation errors data errors detected relatively easily program development test standard debugging techniques 
distribution skewed errors hardest detect normal development test 
shown control errors occur error handling 
error condition difficult generate system test error handling code fully tested 
incomplete testing may prevent addressing errors uncovered early 
addressing errors cause corruption storage near data structure managed faulty code 
order data structures allocated may determine damaged chapter 
survey software errors systems programs ii dos vs mvs ii mvs mvs iii addressing percent total faults summary addressing error percentages previous 
error 
testing cover allocation orders error may occur development test 
chapter suggested addressing related errors dangerous error class terms error propagation 
addressing error corrupt data unrelated module error occurs difficult find remove 
addressing related errors including copy overruns allocation management pointer management problems uninitialized pointers percent apars filed ims mvs db 
consistent studies software errors operating systems summarized 
published studies dos vs mvs 
unpublished study survey errors reported releases bsd unix 
unpublished ii chapter 
survey software errors systems programs operating system error study conducted internally allow release name 
control data errors pictured studies categorize errors way mapped control addressing data error model 
study identified errors addressing related allows comparison studies 
bsd study showed fewer addressing related errors studies 
errors bsd study synchronization configuration problems related device drivers network protocols 
error report information available distinguish errors discovered test phase production phase device driver problems probably discovered testing commercial enterprise large house quality assurance group 
consider post test phase software errors bsd fraction addressing errors closer seen studies 
available information programmer mistakes suggests percent faults cause systems fail involve addressing errors 
percent may upper bound studies usually report addressing errors primary cause software failure 
apar data error report describing control data error occasionally mention system failed address trap indicating secondary addressing errors occurred considered unimportant describe apar 
subsections describe control addressing errors detail 
chapter 
survey software errors systems programs subsection lists major causes control errors 
second details dominant control error undefined state 
third subsection gives distribution addressing error types examples fourth describes additional information addressing errors gathered mvs overlay study 
characterizing control errors shows distributions common control related error types ibm products studied 
bar represents error types defined section 
mvs bars represent error type distributions mvs regular sample overlay sample 
mvs sample memory leak errors memory leak selected error type dbms error study 
memory leak errors mvs identify separate error type study 
memory leak counts control error errors eventually cause system reinitialized order allow reallocation memory lost leak 
products undefined state control error 
errors fairly common db mvs 
db synchronization errors usually occur db interactively related cleanup errors 
clean user cancels command keyboard caused synchronization problems db 
mvs synchronization errors usually related communication protocols highest impact ones errors interrupt handlers 
chapter 
survey software errors systems programs control faults percent mvs ims db undefined state statement logic memory leak synchronization distribution common control errors 
majority control errors dbms caused undefined state subsection describes errors detail 
dbms undefined state errors undefined state error occurs event program execution environment arises program anticipated 
program code handle event event faulty state transition response 
mvs study showed undefined state errors common provide details caused 
general undefined state errors involved concurrency 
example process takes page fault interrupt completion completely initializes page table faulted page 
chapter 
survey software errors systems programs dbms study kept systematic notes undefined states arose program 
turned important undefined state common dbms products operating system 
errors represent db errors sampled retain ims errors 
systems undefined state errors slightly lower impact average error 
ims third undefined state errors occurred program lost track current state 
ims current state network connections database recovery log management represented collection flags 
program changes state updating flags correctly checks wrong combination flags determine current state 
apars error handling 
error occur causing program change state flags representing current state reset 
program wrong response subsequent events mistaken current state 
third ims undefined state errors missing case problems programmer forgot state external event arise execution 
classic boundary conditions 
example programmer writes routine comparing element elements list consider list zero elements 
arose unanticipated error conditions 
example higher level lower level routine expect handle authorization failures 
higher level routine sees authorization failure fails expects error handled lower level 
chapter 
survey software errors systems programs remaining undefined state errors ims came incomplete protocol specifications implementations 
protocol complete consider states arise 
example error condition kinds log records sense 
log record specifying changes sessions sense longer current session 
implementation omitted states defined protocol 
bug fix occasionally prevented portion protocol implementation executed 
db kinds behavior observed somewhat different proportions 
missing case problems common db ims 
nearly half undefined state errors due unhandled error conditions forgotten states arising boundary conditions 
additional db undefined state problems resulted data structure consistency checkers called wrong time 
error checks detected inconsistencies going cause software fail 
fifteen percent undefined state errors db false alarms due data structure consistency checkers 
expect thirds undefined state errors database manager happened programmer omitted logic program programmer incorrectly 
undefined state problems generally arose events forgotten events 
chapter 
survey software errors systems programs misc copy overrun ptr mgmt alloc mgmt address faults percent mvs ims db distribution common addressing errors 
characterizing addressing errors shows distributions common addressing related error types ibm products studied 
shows pointer management allocation management copy overrun errors ims sample db sample mvs regular sample 
control error figures length bar tells percent control errors fall type associated bar 
miscellaneous errors case largely uninitialized pointer errors particular large number miscellaneous addressing errors mvs uninitialized pointer errors 
common types addressing related faults pointer management problems largest classification accounting addressing faults 
chapter 
survey software errors systems programs percent apars unknown uninitialized var 
undefined state type mismatch synchronization pointer mgmt 
copying overrun allocation mgmt 
high impact apars apars apars high impact error type mvs overlay sample error type distribution 
fairly common type pointer management error mis termination linked list data structure 
common pointer error arose different kinds pointers stored location pascal union types 
programmer mistake pointer type pointer type 
third common pointer management subclass register reuse errors 
language ims db mvs written allowed programmers explicitly control register necessary 
explicit control allowed mistakes variables assigned register allowing second value stored overwrite 
pointer value overlay followed 
mvs overlay sample understand addressing errors chapter 
survey software errors systems programs mvs error reports gave additional textual clues addressing related errors mvs overlay error sample constructed containing overlay error reports 
overlay sample shows overlay errors eventually follow non overlay error types occurred 
example synchronization error allowed unsynchronized access pointer data structures 
apar describing synchronization error mentioned mvs corrupted pointers time failure 
gives breakdown error types sample 
bar represents error type defined section 
previous figures high impact apar distribution super imposed error distribution 
mvs operating system tasks involve managing system control blocks buffers connected pointers expect pointers account overlay errors mvs 
fact pointer management errors uninitialized pointers important accounted overlay apars studied high impact overlay apars 
copying overruns data buffers allocation management errors deallocating storage incorrectly accounted total overlay apars high impact ones 
allocation management copying overrun number apars filed copying overruns lower impact 
errors appeared terminal handling code code displaying messages console 
copying overruns caused overflows underflows counter determine bytes copy 
copying overruns chapter 
survey software errors systems programs errors 
network management code terminal handlers buffers processed slightly passed routine 
offset valid data count valid bytes corrupted copying overruns occur 
copying overruns involved bytes 
overruns high impact caused massive corruption memory 
expect overlays caused unsynchronized access storage 
apars studied overlay errors came memory allocation mistakes mistakes acquiring releasing locks 
complexity programming task involves synchronization error involved garbage collection 
example process request software interrupt free region memory interrupt scheduled 
interrupt tries freed memory overlay occurs 
case synchronization correct interrupt scheduled original process memory region 
garbage collection correct region freed operating system finished 
unsynchronized access memory occur usually levels interrupts masked 
cases unmasked interrupts allowed concurrent access linked list data structures 
overlay errors occurred system went undefined state fairly severe 
part errors occurred page fault handling 
page fault handler confused process state process eventually corrupted system recovery possible 
errors extremely complex 
reports usually listed long chain separate events propagations chapter 
survey software errors systems programs overlay size percent overlay apars bytes bytes pages unknown size table average size overlay 
occur failure happened 
overlay sample allowed collect additional pieces information addressing errors propagate overlay size distance correct destination address 
table shows average size overlay bytes 
note overlays small nearly half bytes 
table gives rough distance overlaid data area written 
example copying overrun error corrupts data immediately buffer operating system supposed distance data structure 
example distance type data structure type mismatch error operating system overlays field structure intends update 
summarizing size distance tables find overlays small vast majority close intended destination 
fifth definitely wild stores distant unrelated areas storage quarter apars involved wild stores disregard unknown cases 
subsection described apar categorization error type 
error chapter 
survey software errors systems programs overlay distance percent overlay apars data struct storage data struct unknown table distance intended write address 
type category show kinds programmer mistakes cause system fail customer sites 
important apar categorization schemes error trigger failure symptoms described sections respectively 
trigger symptom subsections compare customer impact apars filed mvs ims db 
estimating impacts mvs errors especially important allows compare impact overlay regular sample 
comparing products impact table compares fraction apars high impact mvs ims db 
rows show differences products severity errors errors identified customer high impact hiper errors error identified maintenance programmers highly pervasive high impact errors 
mvs overlay regular samples table lists fraction errors cause system ipl reboot 
comparing high impact error percentages mvs overlay mvs regular chapter 
survey software errors systems programs sample shows overlay errors higher availability impact non overlay errors 
table lists percent overlay errors high impact 
overlay errors considered regular sample high impact apar total drops percent 
overlay errors times flagged hiper ipl mvs errors 
high impact overlay related errors certainly error propagation 
potential error propagation factor field service personnel consider flag apars hiper 
higher hiper rate overlay errors reason higher impact overlay apars 
propagated errors lessen effectiveness system recovery mechanisms force system ipl error 
table indicates db higher impact errors mvs ims impact metrics 
db fairly early product life cycle software defect rates shown go time 
impact db apars go time 
reasons high hiper severity ratings db suggested product developers 
different people assign hiper severity ratings ims mvs db 
service people assigned db may willing take customer side service people older products 
mvs ims customers know exactly products applications products continue customer satisfied 
system test anticipate workload products fairly 
hand db customers writing chapter 
survey software errors systems programs percent apars impact metric mvs regular mvs overlay ims db ipl reboot na na hiper severity table operating system dbms error impacts 
apar fall high impact category ipl hiper severity 
high impact errors sum figures rows 
new applications 
system test probably harder time anticipating way new applications dbms 
fact high impact db errors triggered unusual workloads boundary conditions supports suggestion 
error triggering events section characterizes events latent faults surface code passed system test 
software faults affect availability customer sites remained latent code time 
program executed successfully months sites fails customer 
trigger meant capture condition causes defective code executed 
determining triggering events apars examined studies hoped help quality assurance engineers retarget testing efforts focus efforts building recovery systems 
chapter 
survey software errors systems programs number apars unknown client code bug fixes database recovery exception handling timing workload high impact apars apars apars high impact error trigger event freq db error trigger distribution 
number apars unknown client code bug fixes db recovery exception handling timing workload high impact apars apars apars high impact error trigger event freq ims error trigger distribution 
chapter 
survey software errors systems programs percent apars trigger unknown bug fixes recovery timing workload high impact apars apars apars high impact error trigger event mvs error trigger distribution 
figures summarize triggering events db ims mvs 
bars case error trigger events defined section 
bar length shows number apars sample associated event represented bar 
figures error types high impact distributions super imposed top trigger event distributions 
conventional wisdom says software failures customer sites usually 
impossible test possible interleavings events software released failures assumed involve untested interleavings events occur months years field 
data support hypothesis 
timing directly triggers relatively small percentage errors apar samples examined 
dominant trigger errors unusual workload conditions 
failures recorded apar samples occurred customers new features new chapter 
survey software errors systems programs hardware configurations old features new way 
ims high impact errors triggered bug fixes error handling full dbms recovery low level exception handling 
db workload error handling full recovery exception handling total common high impact triggers 
mvs high impact errors 
ones saw divided fairly evenly recovery unusual workload conditions unusual timing 
high low impact errors combined workload dominant trigger type db mvs 
considering high low impact ims triggers triggering events workload dbms recovery exception handling bug fixes common timing 
systems roughly proportion timing triggered errors ims db mvs database manager timing triggered errors low impact 
workload triggered fewer errors ims systems probably workload ims defined time 
system test ims anticipate error conditions product workload unusual boundary conditions arise 
db hand broadly defined workload ad hoc queries difficult cover test 
substantially higher fraction errors detected field untested workload conditions 
bug fix errors ims higher impact systems probably comes product age testing procedures 
ims late product life cycle little new functionality added system 
chapter 
survey software errors systems programs higher impact maintenance related apars may just reflect fact activity ims maintenance related systems 
text mvs apars indicated code reuse involved errors triggered unusual workload conditions 
programmers services provided old module write new ones slightly different functionality 
time modules things original designer considered 
increases productivity lessens effectiveness original module level testing 
tests run old module original programmer stress aspects module newer clients 
high level tests run quality assurance stress differences services module designed provide service eventually 
code reuse may caused reliability problems dbms products apparent apars products 
fact unusual workload conditions accounted high percentage triggering events products surprising 
boundary conditions type error expect testing detect easily 
fact unanticipated boundary conditions continue arise software released 
data indicates inadvertently testing new features production environment common cause outage 
fact draw 
test designers focusing new ways uncover timing related errors focus better ways find untested boundary conditions 
second errors described apar database repeatable 
boundary condition arises repeatedly system chapter 
survey software errors systems programs fail way repeatedly 
redundancy recovery strategies version programming process pairs help kind error 
control errors recovery related triggers db ims failures triggered faults error handling dbms recovery code related undefined state 
compare error type distribution sampled db apars sub population errors triggered error handling figures 
distribution shifts undefined state errors 
ims shift undefined state errors sub population defined trigger compare figures 
shift shows undefined state errors arise recovery errors 
unanticipated error conditions implicated significant fraction undefined state errors 
unanticipated error conditions directly caused undefined state error condition handled correctly 
ims error conditions played part problem maintaining state variables 
example error condition caused program change state condition handled correctly state management variables reset 
database manager goes full recovery disk construct consistent state current contents database 
recovery protocol anticipate possible error states database left 
general logging chapter 
survey software errors systems programs percent apars wrong algorithm data error synchronization statement logic memory leak interface error undefined state uninitialized var 
pointer mgmt 
copying overrun allocation mgmt 
high impact apars apars apars high impact error type error type distribution error handling triggered db 
percent apars wrong algorithm data error synchronization statement logic memory leak interface error undefined state uninitialized var 
pointer mgmt 
copying overrun allocation mgmt 
high impact apars apars apars high impact error type error type distribution error handling triggered ims 
chapter 
survey software errors systems programs protocols record changes data database correctly error states occur boundary operating system owned resources dbms records resources 
example protocol restoring database log correctly maintaining consistency operating system directories owned database manager 
failure symptoms figures summarize symptoms failures occurred code containing errors executed 
remember symptom attribute assigned programmer fixing broken software 
assignment primarily assist come similar problems finding fix primary goal assign unique symptom symptom failure relevant availability study 
example operating system prints unusual error message takes address fault error message address fault symptom failure 
spite problems symptom data interesting observations 
shows percent overlay errors detected addressing violations 
imagine addressing errors pointer management errors system take addressing fault fail propagating error 
percent way symptom codes assigned low number addressing faults suggests subsystem damaged overlay uses corrupted data failing 
unfortunately guessing propagation chapter 
survey software errors systems programs percent apars abend address error incorrect output infinite loop error message endless wait high impact apars apars apars high impact failure symptom mvs overlay sample failure symptoms 
occurs necessary apars usually say chain propagated errors 
expected overlay errors cause addressing faults non overlay errors 
common non overlay error types undefined state synchronization appear network device management protocols usually cause processes wait events happen 
non overlay errors cause incorrect output overlay errors 
incorrect output failures include jobs lost printer queue garbage characters written console messages 
errors classified study caused failures corrupted user data 
ims mvs similar distributions failure symptoms 
ims software faults result abnormal program termination mvs chapter 
survey software errors systems programs percent apars abend address error incorrect output infinite loop error message endless wait high impact apars apars apars high impact failure symptom mvs regular sample failure symptoms 
percent apars abend address error incorrect output infinite loop error message endless wait high impact apars apars apars high impact failure symptom ims failure symptoms 
chapter 
survey software errors systems programs percent apars performance mvs abend db abend address error incorrect output infinite loop error message endless wait high impact apars apars apars high impact failure symptom db failure symptoms 
ims takes slightly fewer address faults percentage failures operating system 
remember ims control errors fewer addressing errors programs surprising fewer errors detected hardware addressing violations 
db lowest percentage errors result addressing faults largest result 
fewer endless wait infinite loop failures programs part timeout mechanism turns kinds deadlock errors 
performance failures db usually occur wrong access path taken data problem arise mvs ims access data flexible relational database managers 
chapter 
survey software errors systems programs summary chapter gathered data sources develop picture software faults ways cause system unavailability unreliability 
bulk chapter summarizes analyzes data gathered years software faults discovered ibm systems programs customer sites 
data comes defects reported mvs operating system ims database management system db database management system 
sampled retain ibm field error database represents machine hours product customer sites 
error mvs ims db surveys classified error type error trigger impact failure symptom 
classifications provide different perspectives cause software fault 
importantly error type corresponds low level programming error causes outage 
characterization useful recovery system design 
error trigger describes circumstance allowed error surface field characterizes potential areas enhancement system test 
chapter highlighted importance addressing errors error propagation 
studies chapter illustrated important characteristics addressing errors ways propagate damage modules system 
ranking control errors addressing errors data errors chapter 
survey software errors systems programs products 
half errors control errors percent addressing errors percent data errors 
remainder classified model usually affected system performance corrupted data propagated errors 

addressing related overlay errors higher impact customer availability regular errors mvs 
errors damage mvs recovery mechanisms errors 
ibm programmers view higher risk errors customer base left 
customers viewing failures caused errors rank errors involving overlay high impact average mvs error 

data shows overlays small order bytes occur near address software supposed write 
wild pointers damage module memory addressing errors 
observations character software errors motivate evaluate techniques chapters 
remainder dissertation looks ways detect addressing errors ways limit propagation cause ways recover quickly error detected 
chapter information unrelated propagation addressing errors information researchers find useful 
example error trigger classification showed untested boundary conditions software trigger chapter 
survey software errors systems programs majority failures 
recovery timing triggered failures tend high impact occur 
information help guide design tools help software testing 
suggests software errors surveyed repeatable contrast tandem errors reported 
control errors dominated undefined state error type 
errors related error handling usually involve omitted code state transitions handled incorrectly 
observation suggests tools improve programmer system designer understanding states program go especially errors improve reliability 
hope observations chapter day assist designers system test suites software development tools reliability evaluation techniques recovery mechanisms 
chapter write protected data structures postgres chapter focuses error detection problem describing evaluating techniques detecting addressing errors 
chapter showed addressing errors important class software error 
addressing errors implicated percent software outages errors higher customer impact errors 
dissertation explained addressing errors dangerous source error propagation control data errors usually affect data belonging parts system unrelated faulty code 
order detect addressing errors dbms modified postgres chapter 
write protected data structures postgres hardware supports virtual memory protect data structures propagated errors 
system calls added sprite operating system allow dbms guard write protect parts address space 
dbms uses services protect data buffer pool 
provide read write data protection errors dbms support update model allows correct software modify protected data prevents accidental updates incorrect software 
different update models different tradeoffs regarding software complexity performance kind error protection offered 
experimented models updating guarded data structures expose page deferred write expose segment 
single dbms different update models different program modules necessary 
expose page model simplest 
dbms recognize update protected record page containing record page updated 
deferred write model dbms copies record intends update unprotected memory updates copy 
transaction system call updated record protected memory 
expose segment model lets dbms system call guarded data 
update second system call guarded data 
models guarding dbms data allows hardware detect illegal attempts write protected pages 
systems guarding support improve error detection development production systems 
debugging tool guarding chapter 
write protected data structures postgres help find software errors earlier development cycle 
product release guarding lessens impact addressing related errors detecting errors time propagation occurs damaged data 
guarding detects class errors covered data consistency checkers complements existing fault tolerance techniques 
multi process dbms architectures guarding prevent dbms process errors corrupting data structures processes improving dbms availability 
extensible data manager guarding compromise running application code separate process running full fledged part dbms 
protection separate address space model retained cost closer single address space model 
chapter divided sections 
remainder section describes relevant features postgres dbms sprite operating system test beds implemented guarding 
second section presents previous related guarding 
chapter third section details update models describes implementations 
fourth section shows performance results evaluates reliability effects guarding statistics system software errors chapter 
fifth section gives 
system assumptions discussion follows requires understanding postgres process architecture depicted 
postgres dbms consists cooperating chapter 
write protected data structures postgres shared memory region process process application process process application log tail buffer pool shared caches lock table buffer pool meta data server server postgres process architecture 
server processes address shared memory region containing buffer pool 
conversations server processes applications message passing interface 
server processes 
dbms server process private address space share single common memory region 
shared region contains lock table buffer pool memory data structures server processes 
dbms application programs run separate address spaces communicate dbms message passing 
postgres unconventional storage system results chapter applicable traditional dbms designs 
postgres storage chapter 
write protected data structures postgres system overwrite policy data records updated directly 
update marks current version record invalid inserts new version record relation 
date records removed archived background garbage collector process 
guarding implemented level postgres storage system take advantage overwrite property 
postgres extensible code implementing user defined operators access methods data types added dbms 
extension code access database routines core postgres modules 
generally core postgres routines extension code implement postgres support guarding 
extensions user defined access methods page formats 
extensions know guarding directly 
example tree access methods modified pages adding deleting keys 
sprite operating system modified support guarding unix distributed operating system developed berkeley 
chose sprite test bed source code available documented 
decstation served hardware platform guarding experiments 
uses software loaded hash translation lookaside buffer tlb 
guarding implementation rely decstation hardware characteristics 
cost updating tlb entries hardware specific reflected cost guarding 
chapter 
write protected data structures postgres models updating protected data overview page guarding strategies basic idea page guarding dbms write protects data order detect accidental updates data 
clearly attempted update read data illegitimate write protecting data prevent errors corrupting 
data legitimately updated guarding implementation allow dbms disable guarding overwrite protected data 
postgres guarding protect buffer pool shared memory region shown 
different models section allow dbms enable disable write protection different ways 
model different tradeoffs terms kinds errors protects performance impact 
going model tradeoffs implementation details examples outline models show guarding practice extensible dbms 
simple example basic guarding models described subsections follow terms simple example 
example assumes dbms guarded dbms buffer pool 
example dbms runs simple postquel query replace emp salary emp salary emp name mike stone chapter 
write protected data structures postgres gives mike stonebraker percent raise 
execute query simplest case dbms scans employee relation examining name field record mike stonebraker 
postgres records stored disk database pages buffered main memory buffer pool 
examine records page dbms executor asks buffer pool manager determine page currently buffered 
buffered buffer pool manager reads page buffer pool replacing existing page necessary 
mike stonebraker employee record located executor calculates new salary value record calls lower level replace operation 
replace operation installs new salary value record 
postgres replacing value record done logically physically creating new version employee record containing new salary value 
guarding models different effect implementation postgres replace operation 
guarding model expose page system calls called change write access protected data 
allow dbms change protection finest granularity supported underlying processor architecture 
change salary mike employee record page containing record unprotected replace operation protected replace operation 
third model described expose segment looks dbms expose page model chapter 
write protected data structures postgres underlying implementation different 
implementation different protection performance tradeoffs different 
details chapter 
expose segment model guarding obtain remove write access protected data 
remaining model deferred write change buffer pool protection replace operation defers protection change transaction 
model postgres replace operation creates temporary version mike updated employee record scratch area dbms address space links pointer temporary version list deferred updates 
transaction dbms passes linked list installing updates protected memory single system call 
buffer pool data structures modified replace operation transaction mike employee record sees updated temporary version date protected version 
implementation details advantages technique described sections follow 
guarding strategies achieve extensible dbms 
query helps illustrate guarding inexpensive effective extensible database management system 
hypothetical database example mixture relational data non relational molecule data designed commercial pharmaceuticals research 
query uses relational operator molecule chapter 
write protected data structures postgres append available markers id molecule id expire date molecule patent date years molecule patent date molecule benzene ring true similarity molecule structure similarity root beer molecule structure 
example extensible dbms query 
shows query database extended handle molecule data 
function similarity hypothetical graph matching function determines similar molecules returns similarity index 
oriented extension operator called similarity 
record selected query conventional relational update save update resulting records 
dbms query divided logically phases qualification phase operators determine database data update update phase selected records modified created 
qualification phase passes data applying combination extension relational operations 
qualification phase dbms need permission write database data examining 
update phase permission needed dbms applies different possibly trustworthy set functions operators 
example update chapter 
write protected data structures postgres operations fairly unsophisticated integer operations qualifications extension operations 
guarding support allows dbms explicitly identify qualification phase telling operating system set system calls operator writing database time error 
qualification bugs example qualify wrong record 
corrupt value unprotected memory update phase generate value stored protected memory 
benign errors standpoint error propagation addressing errors randomly corrupt records buffer pool qualification 
thing errors mentioned undone transaction aborts transaction system logged errors allowing updates 
stray pointer corrupts buffer pool hand logging change 
errors involve dbms extensions data unrelated extensions corrupted error 
addressing errors affect entirely unrelated data 
remainder section discusses different models dbms support guarded data abstraction 
subsection follows describes update models 
expose page update model expose page update model dbms process record writing record write 
write protection enforced hardware chapter 
write protected data structures postgres page granularity record records page 
page granularity guarding imply page granularity transaction locks transaction locks enforced software 
managing protected data buffer pool model straightforward 
data manager updates inserts deletes record buffer page page system call 
page unprotected data record changed additional records allocated page 
system call clears write protection bit page table entry pte associated page containing data 
clears protection hardware tlb entry associated page 
system call restores protection bits page table tlb entry 
dbms updated record necessarily record immediately 
dbms delays data subsequent updates record pay costs turning page protection 
unfortunately longer page remains unguarded protection offered 
delaying operation increases opportunity dbms forget page 
implementation record time record updating 
postgres processes page time page issues actual call 
sprite shared memory implementation page dbms process 
sprite uses single software page table chapter 
write protected data structures postgres unprotected page protected page updated record shared buffer pool expose page update model 
smallest granule hardware write protection containing record interest unprotected record updated 
architectures unit page 
shared memory segment 
clears protection bits page postgres processes write unprotected page 
process updates page faulty code executed process corrupt 
system call helps reduce vulnerability buffer pool pages allowing remain protected operation 
dbms uses system call place normal read system call load pages disk buffer pool 
absence explicit call postgres page issuing read 
page remain unprotected dbms processes read completed issuer page 
operating system turns page protection briefly data copied system buffers user address space leaving entire chapter 
write protected data structures postgres expose page best detecting pointer errors affecting pages containing infrequently updated records 
hot pages containing frequently updated records unprotected time receive benefit guarding cold pages 
major costs associated expose page increased number system calls additional tlb operations required change page protections 
guarding implemented processor virtually addressed cache changing page protection status readwrite read require page flushed cache 
virtually addressed caches store protection bits processor cache cached data 
protection bits changed reloading cache line memory 
cache flush normally required change protection bits cached data 
deferred write update model second model dbms data structure protection designed leave record guarded transaction 
dbms process needs update record copies record writable memory updates copy updating record place 
update complete system call copies new record value protected page 
takes argument array destination address length triples records installed single system call 
combines operation operation single system call user level process modifies protected memory directly 
chapter 
write protected data structures postgres operating system changes tlb entry page containing protected version record copies new version record page page 
expose page model deferred write modify page table entry just entry tlb 
section explained processes share page table entries modifying page table entry disables protection dbms processes share page 
processes share tlb entries protected page vulnerable errors postgres processes install operation 
reason modify page table entries operating system write access protected data 
page table entries create tlb entries protection bits page table entry determine protection bits corresponding tlb entry 
modifying protection tlb entry allows access page tlb flush occurs entry replaced tlb 
page referenced new tlb entry constructed page protected 
mask protection faults case sets copy progress bit process control block copying record protected page 
protection fault occurs due reconstructed tlb entry fault handler copy progress bit detect fault spurious 
tlb entry allows write proceed 
operating system copies records protected pages tight loop tlb entries rarely replaced extra protection fault occur infrequently affect performance 
copy progress bit cleared tlb entry chapter 
write protected data structures postgres shared buffer pool address space address space original page modifiable record copy modifiable protected page record copy writable memory dbms process dbms process deferred write update model 
record copied writable memory updated 
copied back protected memory system call 
dbms process returns system call 
expose page model deferred write offers dbms programmer latitude deciding install new version record shared memory 
updated record immediately update 
installed updates transaction commit time 
implementation deferred write model guarded records installed transaction commit time 
deferred write designed record level locking 
records page may updated concurrently different dbms server processes shown 
dbms server process copies record private memory locks record page containing record 
latest version record chapter 
write protected data structures postgres process private memory process holds transaction duration lock data 
update installed transaction commit time lock released 
updates data page deferred transaction record level locking requires updates page header new record created page 
counter page header describes amount free space page 
dbms decrement counter new record added 
record level locking concurrent transactions allowed create records page 
changes free space counter immediately visible dbms server processes 
allocating records page dbms system call update free space counter defer update transaction 
making system call dbms check destination page buffer pool 
long running transactions disk page updated record taken evicted buffer pool 
record installed page longer buffer pool dbms reads page back memory installing data 
modifications postgres record manager required support deferred write 
dbms asks record page record manager see writable copy record 
record copied record manager returns pointer protected record 
copy returned 
hash table tells record manager currently unprotected copy chapter 
write protected data structures postgres record 
dbms decides update record tells record manager sure record writable 
request record writable logically place dbms lock data 
existence copies cause radical changes dbms software 
deferred write higher impact software architecture expose page provides protection guarded records expose page model 
deferred write updates protected records system call dbms store buffer pool page issuing system call 
addressing errors cause dbms accidentally call 
damage writable copy record installed buffer pool 
damage meta data tells record installed buffer pool causing installed wrong place 
combining deferred write little additional error checking reduces error risk 
dbms currently checks update installed cross record boundaries issuing system call 
deferred write allows dbms check addressing errors corrupt storage nearby record modified 
modifiable copy record created dbms put known bit patterns copy 
addressing errors occur near record detected looking corruption known bit patterns 
conventional system expose page nearby addressing errors undetectable 
deferred write model guarding corrupting record directly data errors chapter 
write protected data structures postgres installing update wrong place page ways corrupting protected data 
additional cost errors detected 
dbms checksum record associated meta data record modified 
recalculating checksum installing record buffer pool dbms able detect additional addressing errors 
deferred write additional advantage expose page conventional dbms transaction management 
bad software corrupts data damage detected immediately 
time dbms notices error tell data affected faulty code halted system caused large cluster undetected errors 
guarding deferred write dbms knows protected data corrupted system call transaction 
transaction detects corrupted data simply throws away data 
undetected damage data records caused transaction thrown away 
record level locking free space counter page modified transaction limited portion dbms changes free space counter 
limited amount error checking ensures data buffer pool damaged failing transaction extent propagated damage unknown 
conventional dbms aborts current transaction error detected hopes abort processing removes effects undetected errors 
aborting transaction remove damage software accurately recorded updates chapter 
write protected data structures postgres log 
errors caused corrupted pointers corrupt data logging image record log 
practical way conventional dbms get guarantee deferred write update model invalidate entire buffer pool detecting error 
page remapping techniques large objects deferred write similar respects shadow paging technique system 
shadow paging overwrite transaction management technique new block disk allocated page modified transaction 
page evicted memory forced disk goes new location 
update committed remapping new page original page position home relation 
shadow paging fallen recovery management technique prevents relations allocated disk keyed order 
scans relations lose performance advantage sequential disk reads 
shadow paging deferred write superficially similar shadow paging conjunction write protection system provide error detection benefits deferred write 
shadow paging deferred write affect allocation database pages disk hurt sequential read performance 
memory variation shadow paging conjunction guarding limit copying costs large objects 
small record sizes cost copying record writable location copying back may significant record size rises chapter 
write protected data structures postgres object large object large unprotected page protected page shared buffer pool buffer map remapping avoid copies deferred write 
page contains large object 
updating object private memory unused page buffer pool unprotected object copied 
update complete new version page protected buffer map changed old version page freed 
copy costs 
objects large remapping dbms buffer pool meta data reduce copy costs 
copying large possibly multi page object writable memory region shared protected memory unprotected pages containing object copied see 
unprotected copy object updated place 
commit updates object dbms page changes buffer map associates disk blocks location buffer pool 
pages contained original version object freed updates 
higher performance original version pages unprotected system call protects new version pages 
freed pages unprotected chapter 
write protected data structures postgres needed update 
remapping variation deferred write cost effective object updated large relative size database page 
normal deferred write updating protected object requires dbms copy object twice 
copy occurs original version object copied unprotected memory 
second object updated new version copied back protected memory 
remapping variation deferred write incurs costs place second copy 
small cost change buffer pool meta data update 
second important entire page containing updated object copied unprotected page update occurs just object 
object modified small cost single page sized copy larger cost copying object twice 
expose segment update model expose segment update model similar expose page model protection added removed guarded pages 
dbms system call protected data visible 
second system call returns protection exposed data 
expose segment provides protection models protected routines update critical data structures 
reason expose segment model simplifies management guarded data modules 
expose segment model dbms programmer data procedure chapter 
write protected data structures postgres descendants call tree knowing exactly protected pages written 
postgres expose segment model convenient small fast trustworthy operations needed access data pages 
example protect shared memory hash table implementation lock table 
simplify programming expose segment model pre processor place calls procedures 
dbms programmer flags keyword procedure update protected data 
pre processor adds calls line return statements targeted procedures 
pre processor eliminates class errors data hidden call 
adding protection new data structures easy 
implement expose segment update model sprite modified operating system routine handles write protect faults 
system call sets trusted bit dbms process control block indicating process permission update protected data page table tlb entries changed 
process tries update protected data takes false protection fault 
operating system fault handler distinguishes true false protection faults examining trusted bit process control block 
false protection fault operating system clears protection bits page tlb entry process proceeds update 
data hidden trusted bit cleared mappings guarded pages tlb returned read status 
chapter 
write protected data structures postgres simplest approach restoring page protection flush tlb flushing reloading tlb expensive 
implementation maintains small log process control block containing page numbers tlb entries unprotected 
system call passes log resets protection bits tlb entries corresponding logged page numbers 
log overflows entire tlb flushed exposed pages 
expose segment model guarded update similar conventional protected subsystem 
protected subsystems operating system kernel example require complicated mechanisms expected prevent malicious accidental damage 
slightly safe version expose segment reduce high system call overhead inherent model 
dbms needs update single protected page expose segment model forces enter operating system times 
dbms process system call 
second takes false protection fault attempts update protected page 
dbms process system call restore protection page 
deferred write model requires system call expose page requires 
system call eliminated improve performance 
system call necessary inform operating system dbms process placing trusted mode sets trusted bit dbms process control block 
dbms put trusted bit address space system initialization time identified chapter 
write protected data structures postgres address trusted bit operating system 
making system call expose segment dbms process set trusted bit address space 
operating system handles false tlb protection fault looks trusted bit reserved area process control block 
system call necessary updates tlb entries remove write permission protected data 
variation expose segment safe possible application accidentally go protected mode corrupting trusted bit 
performance impact guarded data structures dbms operating system extra updates guarded records guarding decrease dbms performance update intensive workloads 
extra costs involved guarding include additional system calls tlb operations required change page protections 
deferred write update model additional processing required create keep track record copies 
section evaluates performance guarding ways 
section presents raw costs accessing protected data guarding models 
section shows impact guarding dbms performance debit credit workload 
chapter 
write protected data structures postgres performance guarding dbms table shows raw costs guarding system calls expose page model deferred write model expose segment model 
measurements taken decstation version sprite operating system augmented guarding support 
entry table gives mean standard deviation measurements 
measurement mean system calls 
single byte protected data modified order limit effect data copying overhead system calls 
costs shown test largely attributed sprite system call overhead 
simply sets bit process control block returns 
checks pages unprotected clears bit 
slower operate decstation translation lookaside buffer 
measurements show slightly slower 
system calls identical bits loaded tlb difference significant feature hardware software 
slowest system calls expensive combined 
logically combination operations see performance advantage combining guard operations single system call 
graph shows cost updating small record protected page chapter 
write protected data structures postgres system calls elapsed time sigma std dev sigma sigma sigma sigma sigma table raw costs guarding system calls 
elapsed times microseconds different system calls added decstation version sprite support guarding 
entry table mean measurements measurement mean system calls 
models 
axis number bytes record axis elapsed time microseconds 
table measurement taken elapsed time operations operation copies record guarded memory 
data point graph mean measurements standard deviation measurements mean 
graph includes curves showing cost simple bcopy unprotected memory cost copying record address space unix pipes 
pipes fastest possible interprocess communication mechanism measurements give reasonable comparison protecting data structures guarding protecting maintaining separate address spaces protected data structure clients 
curves slope determined cost copying bytes record 
basic overhead protection models shown chapter 
write protected data structures postgres differs significantly 
multi process model highest overhead 
probably dominated context switch time 
expose segment expensive 
system call required expose protected data hide 
data manager faults operating system time refers data 
expose page expensive expose segment enters operating system twice data guard 
expensive deferred write deferred write enters operating system 
performance guarding dbms microbenchmarks described previous section give complete picture cost guarding 
order measure impact guarding full system compared different versions postgres different protection strategy workload tp debit credit benchmark 
version benchmark transactions run small database 
transaction retrieves tuple account relation updates account relation smaller relations branch teller appends record fourth relation history 
account records pages long 
benchmark branch record teller page long 
measured guarding cpu bound disk bound workload 
cpu bound benchmark postgres operates benchmark database forcing updates disk commit time 
benchmark database small order allow chapter 
write protected data structures postgres microseconds record size bytes elapsed time bcopy deferred write expose page expose segment multi process costs updating protected records 
graph shows cost updating protected record expose page deferred write expose segment models guarding 
compared multi process protection mechanism data structure protected client placing separate address space client 
multi process model interprocess communication unix pipes 
graph shows cost unprotected access record simple bcopy 
chapter 
write protected data structures postgres dbms store entire database main memory 
database small updates forced disk cpu bound benchmark operations saturates cpu 
benchmark disk bound turned force commit back 
resulting operations bring cpu utilization percent 
benchmarks run single user decstation implementation sprite operating system 
compared different versions postgres normal version guarding support 
unprotected copy version deferred write update model protect pages 
comparing unprotected copy postgres normal postgres shows overhead deferred write attributable copy management write protection 
postgres versions different update models described 
read queries version modified version benchmark run expose page guarding 
version just sanity check show guarding impose costs records updated 
postgres version full protection protects shared memory including lock table shared memory lookup tables buffer pool 
full protection version uses expose page update model update data buffer pool expose segment update data structures 
tables compare protection overhead program versions 
benchmark run transactions repeated times get average elapsed time 
standard deviation elapsed times greater percent chapter 
write protected data structures postgres protection update model overhead expose page guarding read queries expose segment guarding full shared memory protection deferred write guarding copy costs table performance impact guarding cpu bound version postgres 
cpu bound case constructed running debit credit benchmark database small fit memory 
guarding dbms ran transactions second 
protection update model overhead expose page guarding read queries expose segment guarding full shared memory protection deferred write guarding copy costs table performance impact guarding io bound version postgres 
io bound case constructed running debit credit benchmark small database forcing updates disk commit 
cpu utilization case 
chapter 
write protected data structures postgres average original runs discarded runs repeated 
tables results percent increase average elapsed time caused protection mechanism 
tables show expensive model updating guarded buffers expose page 
expose segment slightly expensive probably expose segment requires system calls tlb fault access protected data expose page requires system calls 
disk bound case costs different models roughly 
guarding affect disk accesses large impact high cpu utilization 
expect read transaction workload showed additional expense due guarding 
software overhead required manage record copies deferred write apparently significant 
deferred write model cost expose segment cheapest guarding system call 
comparing unprotected copy dbms deferred write dbms shows expense related copy management 
profile data seen nearly copy management costs come allocating freeing searching record copies copy hash table 
records small benchmark physical copying affect performance 
full protection version dbms slower versions protected buffer pool 
version requires guarded memory update process sets lock pins buffer buffer pool 
pins locks acquired buffers updated cost higher 
chapter 
write protected data structures postgres measurements section illustrate costs guarding system uses memory management hardware available today 
costs high performance systems 
subsection discusses ways changes memory management units reduce costs guarding high performance systems write protect data 
reducing guarding costs architectural support advantages current guarding implementation uses conventional memory management hardware making practical tool existing systems 
virtual memory management hardware redesigned performance impact guarding significantly reduced 
large part cost guarding implementation trap operating system required change read write access protected data structures 
system calls copy arguments user space kernel space 
modifying operating system virtual memory management hardware allow unprivileged processes protect parts address spaces bring cost guarding percent assuming system calls microseconds argument passing takes microseconds 
protection violations detected address translation mechanism memory management unit processor 
usually bit indicating page writable stored virtual physical address mapping page 
virtual address chapter 
write protected data structures postgres translated physical address protection bit checked sure address stored writable 
calling hardware manages mapping translation lookaside buffer tlb implementations mapping hardware vary widely 
vax levels hardware tables mapping virtual address physical address 
decstation mapping hardware hash table entry 
machine virtually addressed cache sparc ii information stored cache line 
cheng describes expenses involved managing protection changes environment 
usually supervisor mode instructions change tlb physical address mapping change protection bits 
unprivileged processes execute instruction allowing unprivileged processes change virtual physical address mappings security hole 
unprivileged access allowed process allow address part physical memory 
modification protection bits security hole unix systems code segments shared processes 
malicious user unprotected shared code segment modified code processes executing shared code take actions unintended owners processes 
allow unprivileged processes guard data address spaces quickly processor instruction set include separate unprivileged instruction store protect bit tlb entry 
tlb entry additional bit mode allowed operating system protect tlb entries chapter 
write protected data structures postgres modification code segments 
hardware support operating system cooperate user processes order implement user level guarding operations 
tlbs flushed time operating system example context switch operation 
operating system tlb entry protection information stored process page table 
user process record new instruction takes context switch accesses unguarded data fault operating system context switch 
user level guard operation physically change protection data save new page status way allows operating system determine status tlb reload 
imagine implementations user level operations 
example postgres guarded buffer pool experiments buffer pool guarded time 
records unguarded temporarily updates immediately page dbms process unprotected time 
effective implementation postgres system call user program specifies buffer containing list currently unprotected pages 
user level routine keep list date 
protection fault guarded page operating system check buffer virtual address virtual page number temporarily unprotected page 
protection fault occur tlb entry lost operation modification unguarded record 
chapter 
write protected data structures postgres reliability impact guarded data structures control addressing data error model designed break errors classes differentiated effects guarded data 
order guarding detect errors failing software try update protected data illegally 
broken software managed data structures corrupting guarding detect errors effectively 
guarding impact software failures simply cause program halt overwriting data 
error model data chapter estimate impact guarding software reliability 
data errors corrupt guarded data cause program produce invalid results spite guarding protection fortunately errors uncommon 
data errors occur software calculates stores wrong data value 
guarding protect errors faulty dbms code simply turn protection corrupt data 
data chapter shows assert statements standard debugging techniques current systems excellent job detecting data errors limiting risk guarded data 
control errors unaffected guarding corrupt data turn guarding 
control errors corrupt transient program state cause deadlock directly overwrite 
control error system needs reinitialize transient state accepting transactions 
secondary effects error involve addressing failures 
example chapter 
write protected data structures postgres control errors mvs study address trap failure symptoms meaning control error detected system code tried access memory 
guarding detect control errors limit possibility error propagation control error occurs 
guarding detect addressing errors uninitialized pointers 
studies chapter indicate addressing errors percent recorded software errors 
chapter addressing errors tend wild pointer errors randomly corrupt data arbitrarily far away data failing module 
tell apar data structure corrupted time data structure near data programmer intended update 
guarding detect addressing errors 
wild pointers represented quarter addressing related errors errors detected guarding percent software errors 
guarding detect software errors reducing number software outages percent extremely helpful environments 
chapter showed addressing errors highest impact customer caused serious outages difficult system recover 
resulting outage minor addressing errors represent difficult software errors find fix 
time damage detected module containing error longer executing 
anecdotal evidence chapter 
write protected data structures postgres development postgres systems suggests percent system development effort goes finding repairing addressing related faults 
previous related guarded data structures guarding mechanisms described compare similar mechanisms systems 
alternative protecting shared data structures guarding keep data structures address space clients data structures 
order architecture practical fast space procedure call mechanism taos operating system required 
taos lightweight remote procedure call lrpc optimized communication parameters passed caller called routine 
service request block srb mechanism mvs xa operating system similar lrpc 
srb high priority thread control created remote address space 
lrpc srb fast path scheduler shared memory reduce overhead 
guarding provides kinds protection non malicious damage address space boundary 
access read records faster possible separate address space implementation 
database workloads require dbms scan large amounts data selecting update chapter 
write protected data structures postgres faster read performance distinct advantage 
tandem process pair mechanism relies multiple address spaces prevent propagation software errors 
tandem data manager primary hot spare process executing time different machines 
primary executes transactions sends checkpoint messages spare 
primary fails spare reconstruct data manager state checkpoint messages 
errors propagate primary propagate spare 
process pair prevents kinds errors guarding expensive 
keeping spare date requires resources sending processing checkpoint messages 
worse implementation checkpoint protocol non trivial 
modifications dbms may affect checkpoint protocol making expensive implement test 
model help detect errors 
primary spare large unprotected buffer pools 
undetected pointer error damage buffer making primary turn control spare 
corrupted buffer eventually corrupt permanent data 
system uses page protection bits provide operating system support dbms locking logging page protection increase fault tolerance 
data manager running set locks explicitly 
memory management hardware detects read write unlocked buffer dbms traps operating system 
operating system sets locks implements physical logging byte 
support fine grain locking memory management unit provides write chapter 
write protected data structures postgres protection subpage granularity 
hardware support subpage granularity guarding 
system guarded data structures treats attempt write buffers legitimate 
moving responsibility locking dbms operating system losing information available dbms data updated erroneously 
bad pointer causes write unlocked buffer locks buffer logs normally 
circumstances guarded system immediately halt transaction 
implementing protected operations locking operating system alternative guarding 
installing dbms code operating system operating system vulnerable errors installed code 
guarding gives dbms implementor freedom decide code reliable access protected data 
debugging support available user programs operating system implementing protected subsystems dbms practical implementing operating system 
guarding provides protections protected subsystem mechanism requiring special hardware restricting designer choice programming environment 
existing protected subsystem mechanisms rely special memory management hardware type safe languages 
guarding implemented conventional hardware common systems programming languages 
course guarding designed protect accidental damage malicious damage 
chapter 
write protected data structures postgres existing protected subsystem mechanisms designed protect 
chose implement virtual memory support required guarding modifying operating system 
possible support guarding mach external pager 
implementing guarding directly operating system guarding efficient 
summary chapter describes modifications operating system database manager designed limit software error propagation dbms 
write protecting data manager buffer pool allows early hardware detection addressing related software errors 
guarding reduces complexity software failure preventing errors propagating protected data structures 
guarding techniques improve recovery speed limiting potential error propagation decreases amount required recovery time 
dbms techniques especially important extensible dbms postgres 
guarded system person developing new access methods data types smaller impact availability reliability achieved peers 
difficult quantify reliability improvements result guarding commercial systems 
chapter showed software errors existing systems addressing related 
wild pointers chapter 
write protected data structures postgres damaged parts system unrelated component error 
implies guarding eliminate software errors 
software errors difficult detect ordinary means reduction software errors may result larger reduction engineering effort required produce reliable software system 
errors higher average customer impact reliability increase perceived customer probably 
general performance impact guarding comparable impact software techniques detecting software errors data structure verifiers array bounds checks 
guarding implemented efficiently advantage processors software loaded tlbs 
read workloads guarding provides dbms additional protection extra cost 
update intensive workloads experiments shown additional cpu demand caused guarding percent small records updated 
page remapping techniques method reducing copy cost large records 
deciding guard data structures system designers face tradeoff potential reliability availability improvement small measurable performance loss 
systems reliability gain worth loss performance 
may willing accept small performance loss order achieve reliability improvement 
systems may want option switching guarded normal operations different points system lifetime different customers 
chapter 
write protected data structures postgres time trends system cost probably tilt performance protection tradeoff favor guarding 
processors faster additional processing demands caused guarding concern 
big potential risk long term usefulness guarding techniques cost changing page protection scale processor performance 
hardware designers aware need fast protection changes applications distributed shared memory hopefully consider issue processor architectures 
need guarding certainly increase time 
falling memory prices increasing sizes disk caches dbms buffer pool 
data cache remain unused long periods time 
essential bad writes data infrequent caught time error time data 
essential fast recovery gigantic caches reloaded disk software failures 
non volatile ram expensive frequently stable storage applications database management 
non volatile ram resistant failure disk storage protection addressing errors 
chapter fast recovery postgres dbms fast simple recovery mechanism critical highly available data management fault tolerant systems 
chapter pointed faster recovery leads directly higher availability 
long software restart times lengthen outages occur kind failure longer outages decrease system availability 
section chapter illustrated reliability risk due recovery system software 
software outages caused control errors related recovery error handling code 
data indicates recovery systems hard implement correctly hard maintain 
testing recovery systems difficult requires test suite designers anticipate failure conditions arise field 
daunting task large software system 
chapter 
fast recovery postgres dbms traditionally fault tolerant systems tried mask failures avoid recovery improve recovery speeds 
example tandem harp ha nfs maintain primary backup systems order avoid recovering primary fails 
failure occurs operation switches backup system delay users primary recovers 
unfortunately protocol keeping backups date expensive correctness difficult verify 
protocol works correctly guarantee software errors propagate primary backup 
common approach masking failures provide multi level software recovery mechanism 
integrity operating system attempts correct internal data structures finds errors 
failures occur minutes system assumes correction goes full recovery 
mvs uses multi level recovery scheme different portions system fail recover independently 
tiered recovery mechanism implemented sprite operating system uses reserved area memory hold backup copies state associated distributed file system distributed applications 
event control errors addressing errors backup state quick regeneration operating system application program state disk operations communication remote sites 
power outages hardware errors software errors corrupt reserved memory normal slow recovery path 
postgres approach maintaining high availability improve speed chapter 
fast recovery postgres dbms system recovery errors detected 
failure masked case hardware fast recovery mechanism improve availability eliminating long outages failures 
approach requires little done recovery done normal system restart recovery system may easier debug test conventional multi level recovery mechanisms 
contrast database management systems write ahead log wal recovery techniques surveyed 
wal updates applied database written log 
log processed system restart ensure committed updates lost aborted updates remain 
wal survey published aries took steps improve concurrency restart performance basic write ahead logging techniques increased complexity recovery system software 
aries database recovery time proportional number log records processed recovery 
significantly improve recovery times log processing eliminated 
dissertation takes starting point postgres storage system uses overwrite techniques combine support historical data support transaction management 
details overwrite storage system left section briefly storage system works creating new version tuple updated dbms updating tuple place 
dbms fails updating transaction aborts previous version tuple remains recovery 
falling back previous version involve log processing storage system requires little restart time 
chapter 
fast recovery postgres dbms designers commercial database systems desire faster recovery possible write ahead log processing community applied postgres storage system ideas commercial dbmss 
reasons involve recovery media failures performance considerations 
postgres assumes subsystem handles media recovery depends mirrored disks raid redundant array inexpensive disks disk subsystems 
traditionally write ahead logs media recovery non mirrored disks 
raid storage systems commercially available problem 
important reason postgres storage system ideas widely original design perform traditional storage systems database support high update rate 
data structures implement overwrite transaction support postgres retrieving tuples database expensive 
postgres force commit buffer management policy buffers containing tuples updated transaction written disk transaction commit 
database management systems policy causes dbms disk necessary write ahead logging policy 
increase usefulness postgres fast recovery techniques applications banking stock trading high update rates fast recovery important performance impact storage system reduced 
chapter dissertation contributions fast recovery database chapter 
fast recovery postgres dbms management system 
increase applicability postgres storage system environments high update rates allows dbms environments take advantage fast recovery 
chapter suggests changes way tuples stored postgres 
section describes original postgres storage system new optimizations 
second section uses analytic model evaluate impact storage system raid 
shows non volatile ram modern file systems log structured file system lfs eliminate additional costs associated postgres overwrite techniques 
techniques described section analysis section increase applicability overwrite transaction support applications high update rates 
chapter considers recovery kinds dbms state original postgres storage system ignored 
dbms recovers failure reestablish kinds context lost failure disk database context database disk transaction consistent 
disk cache failure dbms reload frequently accessed database pages main memory 
session context network connections dbms server clients lost failure 
client server means client network protocol determining messages transit time failure 
systems human intervention chapter 
fast recovery postgres dbms required restart application programs dbms server fails 
current transaction context transactions executing time failure transient state associated example query plan structures lock table temporary relations holding intermediate state 
state reinitialized 
postgres storage system addresses item list 
sections describe methods recovering disk cache session context items list ignored original storage system 
regeneration current transaction context item list left 
issue regenerating transaction context important dbms executes short transactions 
case fastest simplest way recovering lost transaction context aborted transactions 
strategies transaction context long running transactions outlined final chapter dissertation 
overwrite storage system postgres storage system differs dbms storage systems user data updated place 
postgres creates new version tuple updates new version 
tuple logically deleted marked invalid left physically place 
write ahead log processing postgres recovers failures falling back previous version data 
transaction aborted chapter 
fast recovery postgres dbms dbms detects ignores changes database transaction 
transaction commits updated tuple versions remain accessible users historical data 
new version data physically located data pages data pages written transaction written stable storage non volatile memory transaction commits 
policy managing data pages called force commit 
subsections follow describe postgres storage system enhancements 
subsections describe important issues affecting performance cost transaction system storage tuple versions reclamation space data pages run time detection invalid updates access historical data 
third subsections discusses actual recovery mechanism 
final subsection tells force commit policy affects performance different kinds subsystems 
current section summarizes design points original postgres storage system design included completeness 
changes improve recovery speed simplify parts storage system improve performance 
places describe details storage system omitted 
differences original postgres storage system version modified dissertation identified arise 
version implemented dissertation referred modified version text 
chapter 
fast recovery postgres dbms saving versions tuple differences order postgres overwrite storage system efficient space consecutive versions tuple stored sequence tuple difference records sequence full tuples 
tuple initially inserted relation anchor point record constructed representing full tuple 
subsequent updates represented difference records containing fields new tuple version differ previous version 
difference records chained starting anchor point chain allow postgres reconstruct version tuple 
original postgres storage system difference record management scheme forward difference chains 
forward differencing anchor point oldest available version tuple 
difference chain goes oldest available version newest queries referring current version tuple pass entire difference chain construct tuple see 
records updated difference chain grow current data increasingly expensive 
modified postgres storage system dissertation improves access current data backward difference chains 
anchor point case version tuple 
update occurs link constructed newly generated version current version difference chain 
current version tuple readily available scans updates current database fast 
chapter 
fast recovery postgres dbms point anchor line table field field field field field field field forward difference chain 
data page contains tuples shown 
line table entry points anchor point bold 
forward difference chain connects records representing versions 
construct current version tuple dbms starts follows difference chain 
field field field field field line table anchor point field field backward difference chain 
uses array style anchor point bold backward difference chain 
difference chain shown dotted arrows connecting records associated versions 
anchor point array points youngest member chain date values fields 
field field updated field values come come 
chapter 
fast recovery postgres dbms anchor point forward difference chain anchor point backward difference chain contain fields different tuple versions 
example transaction updates attribute value attribute tuple version tuple contains fields difference records 
anchor point structured array element tuple attributes 
element points value attribute 
array style anchor point backward differencing uses space forward differencing 
forward differencing simply oldest available tuple difference record anchor point 
clear figures forward differencing backward differencing logically overwrite techniques data stable storage physically overwritten update 
data transferred main memory disk page sized units 
new difference record added page entire page rewritten stable storage 
assume database pages written disk atomically case media failure 
assume media failures detectable 
devices file systems page writes guaranteed atomic postgres operating system checksum page software examine checksum time page read disk 
postgres indices described depth chapter detail regarding important section 
records postgres index point line table entry data page individual record 
line table entry points anchor point index find version tuple 
chapter 
fast recovery postgres dbms overwrite policy force dbms update index records time data records updated 
garbage collection archiving tuple difference chains reduce amount space taken historical data overwrite policy eventually cause database run disk space additional strategy reclaiming storage space 
original postgres storage system allowed space reclaimed ways 
tuple versions created transactions aborted garbage collected removed database time 
second historical data moved cheaper storage medium optical disk freeing space faster medium 
third historical data older user defined threshold destroyed 
section ease presentation address garbage collection archiving destruction historical data separate functions 
section occasionally refers garbage collector separate entities fact implemented single program called vacuum cleaner 
garbage collection capacity vacuum cleaner examines page relation database reorganizing page eliminate tuple versions created aborted transactions 
page reorganized allocating temporary page memory copying historical current tuple versions new page 
copying necessary invalid tuple versions created aborted transactions interspersed valid tuple versions page 
new page constructed dbms buffer pool chapter 
fast recovery postgres dbms meta data modified new page replaces old 
garbage collection layout data page changes contents valid tuples page change 
garbage collection conflict transactions phase read write locks page tuples 
conflict garbage collector lock tuples garbage collection reducing concurrency allowing garbage collector deadlock existing transactions 
high concurrency garbage collection important frequently updated relations highest concurrency requirements consume space frequently 
phase locks required coordination garbage collector transactions dbms necessary dbms process pointers old version page 
dbms detect garbage collection occurred revalidate pointers old page reallocated 
garbage collection completes garbage collector stores pointer new version page buffer header structure associated old page 
dbms re examines tuple checks see new version page 
new version backend process tuple pointers difference records new page old version page 
pin page released buffer containing old version reallocated 
garbage collector hold latch semaphore associated page copies tuple versions old new page 
dbms normally uses latch updates synchronize allocation chapter 
fast recovery postgres dbms space page holding latch prevents updates garbage collection 
garbage collection completed dbms know space available page space allocated new tuple version created update 
archiving vacuum cleaner chooses time value arch delay seconds current time declares archive start time 
selects tuple versions committed start time copies archive destroys 
ensure copies correct tuples uses postgres historical data time query facility look tuples described section 
time query returns data valid archive start time uncommitted updates copied archive 
current postgres implementation stages archived tuple versions magnetic disk write buffer writing archive access archive media tape write optical disk typically order magnitude slower access disk 
data archived deletes historical tuple versions magnetic disk relation 
usually construct new tuple difference record representing oldest available tuple version 
consecutive tuple versions share attribute values oldest available tuple version probably incorporates attribute values difference records deleted 
new tuple difference record retains shared attributes non archived version relation 
details archive cache described 
archive indexing strategies addressed 
garbage collector phase locking guarantee chapter 
fast recovery postgres dbms transactions historical data moved archive 
constructing overflow pages support overwrite policy overwrite storage system policy managing page overflow significant impact dbms performance 
overwrite policy repeated updates tuples data page eventually fill page 
space reclamation strategies described prevent pages filling especially high update rate environment 
high performance commercial database management systems run rates hundreds transactions second pages fill rapidly 
minimum sized tuples original storage system bytes differencing 
approximately updates fill page containing tuple 
original storage system simply extends tuple difference chain new page transaction tries update tuples full page 
high update rate environment strategy causes performance degrade rapidly especially dbms uses forward difference chains 
tuple accessed updated page multi page forward difference chain accessed 
hot tuples receive frequent updates form longest multi page tuple chains 
tuples greatest access cost 
backward difference chains improve access multi page tuple chains important cases greater storage overhead 
pages containing current attribute values need examined backward difference anchor point arrays allowed point chapter 
fast recovery postgres dbms page boundaries 
case attribute field updated repeatedly pages accessed containing anchor point containing difference record 
anchor point array entries larger point page boundaries 
bytes pointer required chains contained page bytes byte page number byte offset required point difference record page 
updates require anchor point difference record page updated 
forward differencing page containing difference record modified update 
modified postgres storage system uses alternative strategy limit performance impact multi page tuple difference chains strategy page reorganization 
transaction updates tuple full page dbms creates overflow page moves tuple difference records original page overflow page technique detailed 
managing overflow pages recoverably complex original postgres storage system strategy common case allows access current database take place examining page tuple 
possible strategies creating overflow pages 
simplest strategy construct new anchor point tuple original page new overflow page 
current version attribute fields assembled overflow page current tuple version constructed single page 
header new page pointer back original page order allow access historical data current version data 
unfortunately dbms may chapter 
fast recovery postgres dbms historical versions time new version old version time overflow page overflow page versions historical original page creating overflow page 
original page overflows split pages 
old page contains historical tuple versions new page contains current versions 
old page written asynchronously stable storage new page mapped temporary location disk 
old page written stable storage successfully new page allowed overwrite original page database temporary location reused 
indices referring records original page 
index updated order indexed access data remain fast 
records page indexes relation creating overflow page require updates pages significant performance impact 
better strategy move older versions tuples original page overflow page shown 
way index entries point page page contains version tuple 
overflow pages chained historical version data reached multi page scan 
creating overflow page containing historical tuple versions way prevents information lost crash tricky 
create overflow page dbms chapter 
fast recovery postgres dbms creates new pages new version overflow page old version overflow page 
new version overflow page contains version tuple original page 
old version contains historical versions tuples original page 
old version page saved stable storage new version page place original 
old version page successfully written stable storage original page contains stable version historical tuples page 
new version page allowed replace original page page stable crash destroy historical tuple versions 
dbms logically replaces original page new version page modifying buffer pool meta data 
buffer pool cache meta data tells buffer main memory associated page database 
page written disk buffer pool meta data tells written 
creating overflow pages expensive small amount non volatile ram available disk stable storage overflow causes extra disk write 
original storage system overflow causes new page written stable storage commit new tuple version original page written stable storage link previous version new 
non volatile ram available modified version postgres storage system creates new version overflow page overflow page blocks old version overflow page copied stable storage 
old version page copied dbms replaces original page new page 
transaction causing overflow commits new version chapter 
fast recovery postgres dbms page written stable storage 
original postgres storage system pages stable storage updated 
disk stable storage new scheme block dbms old version overflow page written stable storage 
disk latency long strategy efficient 
dbms writes old version page disk asynchronously 
tuples original page remain intact overflow page written disk 
allow dbms commit transactions write old version page confirmed new version page mapped temporary location disk 
temporary page chained original page old version chained new version shown 
commit original page new version page written disk 
original page written order preserve pointer temporary location new version page 
pages written disk overflow 
summary overwrite storage system policy creating overflow pages 
original storage system policy allowing tuple difference chains span pages forces dbms examine page update single tuple 
vacuum cleaner runs hourly chains pages run tens pages highly updated tuples high performance dbms 
modified storage system puts historical data new page newly created data access current database remains fast vacuum cleaner runs infrequently 
strategy result extra disk write overflow non volatile memory chapter 
fast recovery postgres dbms available stable storage 
recovering database failures dbms recovery system mask inconsistencies database resulting dbms failure 
postgres inconsistencies take form tuple versions created transactions aborted 
conventional system data pages contain kinds inconsistencies 
tuples may updated place transactions aborted 
second tuples updated committed transactions may written stable storage failure 
kinds storage system require recovery actions ensure transactions starting system restart inconsistent data 
failure conventional log dbms entire database consistent allowing users access data 
log conventional dbms contains sequence records representing updates database records telling transactions committed 
recovery time dbms reads log find transactions committed examines data pages affected log record sure committed updates applied aborted ones 
recovery conventional systems usually bound due data pages read 
cost proportional length log 
subsection follows describes techniques detect ignore invalid tuple versions postgres 
dbms detect invalid tuples chapter 
fast recovery postgres dbms remove inconsistencies database system restart time 
discuss cost postgres database recovery describing technique detecting invalid tuple versions 
transaction status file postgres transaction begins slot reserved transaction transaction status file maintained dbms 
transaction identifier xid pointer transaction status file slot 
status file records current state current past postgres transactions 
original storage system transaction states committed aborted progress modified storage system requires committed aborted states 
progress state synchronization postgres vacuum cleaner described section current transactions 
modified storage system uses conventional synchronization techniques bit bit slots encode state 
queries historical data require dbms maintain second file called commit time file original postgres storage system 
transaction commits stores current time commit time file 
time queries commit time determine data written transaction valid 
note commit time written transaction committed committed transaction valid commit time 
commit time file decomposed slots way transaction status file slot bytes wide bit wide 
chapter 
fast recovery postgres dbms allows dbms xid look transaction commit time current state 
postgres backend processes reserve blocks xids allocating individually 
dbms maintains stable storage available xid indicates xid allocated transaction system failure 
postgres backend runs xids updates xid stable storage reserve available block 
transactions initiated clients backend process assigns xids block consecutively 
block owned single process backends need coordinate allocation new xid need ensure time allocating new xid blocks 
larger xid blocks lessen overhead xid allocation increase number unallocated xids discarded failure 
identifying updating transaction run time postgres storage system detect ignore updates database transactions aborted 
storage system stores xids tuple difference records identify transaction created updated deleted tuple version 
mapping xids slots transaction status file dbms determine transactions committed 
tuples locked conventional phase locking scheme transaction block encounters tuples created written progress transactions 
chapter 
fast recovery postgres dbms uncommitted tuple updates transaction encounters invalid 
modified postgres storage system stores xid anchor point tuple tuple difference record 
anchor point tuple stores tuple xid transaction inserted tuple database 
xid tuple difference record identifies transaction updated deleted tuple version represented difference record 
transaction attempted update delete tuple version xid field difference record contains invalid transaction identifier 
original storage system additional xids stored turn necessary 
difference record kept 
identified transaction created tuple version told transaction updated deleted tuple version 
clearly difference record previous fields merged single xid field modified storage system 
modified storage system maintains anchor point field called indicating dbms command query language statement modified tuple 
query language statement separate command 
command changes tuple change visible command 
example record inserted relation query visible database query inserted completes 
postgres process maintains command counter currently executing transaction 
dbms stores current command counter value chapter 
fast recovery postgres dbms tuple field tuple created modifies field time tuple updated 
transaction ignores tuple version transaction modify tuple current command matches tuple 
associating single entire tuple original storage system associated tuple version way 
modified storage system uses single field tuple command relevant tuple difference chain 
command field transaction updated tuple examining tuple 
current command see updates created element tuple version chain 
tuple version possibly created current command tuple version 
single field tuple created deleted command 
detecting invalid tuple versions conventional database management system uses write ahead log processing remove aborted transaction updates recovery 
postgres detects ignores invalid updates updated tuple failure 
dbms maintains previous versions tuple updated difference record chain described ignoring invalid update simply means whichever previous chapter 
fast recovery postgres dbms versions valid time aborted transaction began update 
invalid update invalid insert 
transaction creates new tuple inserts database aborts due failure 
transaction examines tuple ignore tuple difference records associated transaction 
invalid delete 
transaction delete existing tuple database abort 
transaction examines tuple ignore delete 
invalid replace 
transaction replace field existing tuple creating new tuple version 
transaction aborts transactions previous tuple version difference record chain valid aborted transaction update 
invalid update may create tuple version 
example transaction may insert tuple database update creating tuple difference records 
transaction aborts difference records invalid 
versions tuple difference chain invalid phase locking prevents transaction updating uncommitted tuple versions 
find invalid updates check cases list 
check requires consider xid associated tuple 
note checks described require xids looked transaction status file 
checking invalid tuples common operation examining transaction chapter 
fast recovery postgres dbms field field field version version anchor point field field field field field version version anchor point version anchor point tuple qualification 
shows tuple instances time 
upper left corner tuple inserted transaction 
writes xid slot anchor point 
right field replaced transaction 
writes xid xid slot version tuple 
transaction deletes entire tuple 
status file relatively expensive reducing number lookups tuple gives performance advantage 
check case invalid inserts exactly tuple difference record chain 
check case examine associated tuple header 
xid associated aborted tuple invalid 
tuple difference records chain treat case transaction initiated updates 
check case examine xid associated difference record tuple difference record chain 
xid null transaction attempted delete tuple 
xid valid maps aborted transaction status file bit chapter 
fast recovery postgres dbms transaction attempted delete tuple aborted 
case fall back tuple version created transaction aborted 
check case transaction attempted delete tuple 
see detect invalid replace operation remember replace operation implemented postgres storage system 
replace field existing tuple transaction creates new tuple difference record containing replaced fields null xid field 
transaction stores xid xid field current difference record tuple effectively deleting difference record links new version front difference record chain 
transaction checks replace transaction committed examining xid second difference record chain 
xid mapped committed aborted state replace transaction transaction status file 
transaction committed difference record describes current tuple version 
transaction aborted difference record created earlier transaction valid 
transaction update delete tuple aborted search tuple difference chain locate valid version 
dbms searches chain finds difference record xid field different xid aborted transaction 
equal invalid xid entire difference chain inserted single aborted transaction invalid 
new xid value difference record containing xid valid version 
obviously xid equal aborted chapter 
fast recovery postgres dbms transaction xid initial tuple version valid 
recovery costs postgres storage system factors contribute costs recovery postgres 
system reinitialized failure 
log processing required dbms initialize storage system 
second dbms check invalid tuple versions 
third overflow pages occasionally result extra find current version tuple 
costs addressed time paragraphs follow 
restart modified postgres storage system simply allocates new xid block backend process memory data structures 
new xid blocks allocated failure dbms tell xids old blocks allocated time failure 
efficiency concerns transactions stably record fact individual xid allocated xid blocks 
original storage system needed scan tail transaction status file converting state progress transaction aborted order show transactions progress time failure aborted 
tuple validation required tuple examined transaction validation expensive 
profiles debit credit benchmark chapter showed validation consumed dbms cpu time came mapping xid transaction status file slot 
profile include cost reading transaction status file blocks chapter 
fast recovery postgres dbms disk 
transaction status file large store memory additional disk reads required validate tuples 
notice previous subsection xid tuple looked transaction status file disk read tuple scanned storage system prohibitively expensive 
fortunately vacuum cleaner compact transaction status file keeping file small cached main memory 
implement compaction vacuum cleaner record xid oldest progress transaction time vacuum cleaner begins sweep database 
sweep database contains invalid tuple versions updater xids smaller oldest progress transaction xid 
oldest unresolved xid recorded validate tuple versions 
transaction status file need consulted xids smaller oldest unresolved xid transactions definitely committed 
status file truncated oldest unresolved xid order save disk space 
transaction status represented single bit relatively small amounts memory required status file cache 
dbms executes transactions second consumes kbytes status file hours 
high transaction rates garbage collector easily ensure status file lookups go disk running hours 
extremely long running transactions prevent status file compacted affect performance entire system 
dbms fails creation overflow page dbms chapter 
fast recovery postgres dbms read pages order find version tuples page 
showed postgres created temporary pages prevent historical tuple versions destroyed 
temporary page exists read memory time page accessed failure requiring os find tuples page 
postgres requires recover data conventional write ahead logging system 
conventional system read page referred log record recovery 
data pages read recovery replaced memory data new transactions 
os happened system failed 
postgres recovers page data page accessed current transaction 
point page read memory anyway 
normal case current previous version tuple reside page 
current version tuple invalid extra required access data 
validating tuples historical queries users query historical data postgres examines transaction commit times ensure tuples valid time period interest 
determine commit time tuple version dbms maps difference record xids commit times commit time file 
current version tuple time period interest dbms check version written aborted transaction chapter 
fast recovery postgres dbms transaction status file described 
status file lookups necessary possible aborted transaction valid commit time 
failure occurred time dbms updated commit time file time updated status file effectively aborting transaction 
historical queries phase locking order prevent removing tuples magnetic disk query progress 
order improve performance postgres time queries original storage system copied commit time tuples garbage collection 
commit time file need searched queries data older garbage collector run 
postgres maintains cache commit times allow time queries proceed constantly accessing disk read transaction commit times 
cache times large status cache postgres represents commit time byte quantities 
memory available cache time queries access commit time file disk validation 
performance impact force commit policy commercial database management systems force commit policy managing data pages policy poor performance conventional disk stable storage 
data pages forced different locations disk commit delayed disk arm seeks location 
commit time write ahead chapter 
fast recovery postgres dbms logging storage system writes log records synchronously data pages written asynchronously ejected dbms disk cache 
placing log separate device rest database conventional dbms pay disk seeks commit time 
modern system architectures file organizations large impact performance postgres force commit policy 
section compares performance postgres conventional dbms uses write ahead log 
separate expense postgres historical data feature expense fast recovery consider versions postgres historical data feature 
analysis considers conventional disk subsystems non volatile ram nvram stable storage raid parallel disk subsystems log structured file systems lfs 
analysis analysis consider raid lfs archiving costs impact large disk caches 
analysis section shows system sufficient amount non volatile ram log structured file system postgres history disabled performs conventional system despite force commit policy 
history enabled postgres percent conventional dbms 
benchmark comparison analytic model tp debit credit benchmark 
transaction tp benchmark randomly accesses hot relations branch chapter 
fast recovery postgres dbms teller cold relation account 
read written 
transaction appends history relation writes necessary log records 
subsection follows describe parts tp transaction execution conventional system versions postgres execute way 
describe differences dbms versions executing benchmark 
assume main memory available cache hot relations cold 
steady state dbms read account page disk write different account page disk transaction 
history relation tuples contain bytes data tuple header 
postgres header bytes history tuples fit single page 
history block written disk transactions average 
conventional system maintain information tuple header 
header bytes history page filled transactions 
postgres storage system data blocks updated tp transaction status file block forced stable storage transaction 
version postgres history disabled creates overflow pages 
garbage collects historical data page page fills 
analysis assume version postgres history disabled record commit times 
commit times required historical queries 
history disabled version postgres preserving historical data reason dbms chapter 
fast recovery postgres dbms maintain commit times 
conventional file system tp transaction constructs log records containing image updated tuples 
commit time log records forced stable storage single write 
assume log records required describe tp transactions fill log page 
corresponds bytes log record transaction 
conventional systems typically keep write ahead log disk database order avoid disk seeks commit time 
dbms appends log storing separate device database means disk head near tail log log writes sequential os 
comparison fair postgres allowed disk sequential writes 
unfortunately postgres data structure log strictly sequential access pattern 
transactions commit roughly order initiated transaction status file transaction commit time file accessed nearly sequentially 
analysis assume version postgres disabled historical queries stores transaction status file separate device 
version postgres history support store commit time file separate device 
simplify presentation call sequential random number taken fujitsu eagle drive average seek time ms average rotational latency ms transfer speed ms page 
average sequential takes ms average random takes ms 
chapter 
fast recovery postgres dbms historical data archiving costs version postgres preserves historical data pays additional costs maintain data 
system create overflow pages described section store historical tuple versions archived 
system maintain commit time file users query historical data described section 
historical data eventually copied archive device order leave room disk data generated new transactions 
record historical data overflow pages created time page fills 
rate overflow pages generated depends free space reserved page updates 
database page contains single tuple updates tp account branch teller tuple occur page fills 
percent page reserved historical data tuples stored page page filled updates 
analysis assume percent page left free page initialized 
tp replaces tuples transaction page filled average updates dbms write overflow page transactions average 
environments cost migrating data magnetic disk archive device ignored 
environments slow period night historical data moved magnetic disk archive device 
analysis assume slow period slow period comes infrequently storage need reclaimed operation 
chapter 
fast recovery postgres dbms quite reasonable page fills updates dbms sustained high transaction rate 
dbms runs transactions second creates hour overflow pages historical data consumes mbytes disk space 
analysis assumes cost transaction include cost archiving historical data generated transaction 
account archiving costs analysis considers cost archiving overflow pages cost examining archiving historical tuples current pages database 
overflow pages commit time file grow function transaction rate relatively easy determine costs account transaction 
vacuum cleaner examines non overflow pages historical data cost depends size database rate vacuum cleaner runs 
independent transaction rate 
order simplify analysis assume vacuum cleaner runs infrequently relative transaction rate archiving costs dominated commit time file overflow page cost 
stated section archived data written directly archive device postgres 
pages accumulated write buffer magnetic disk 
buffer fills reread disk data written archive 
preserve historical tuple versions single overflow page dbms create overflow page write disk current database vacuum cleaning read page disk find data chapter 
fast recovery postgres dbms page 
vacuum cleaner writes page archive write buffer 
vacuum cleaner deletes tuples overflow page current database rewrites 
vacuum cleaner write buffer disk pushes archive 
operations done order prevent archived data lost failure 
showed overflow page generated causes os archiving costs taken consideration 
overflow page results random read sequential read random writes current implementation postgres 
total historical data cost random writes transaction random reads transaction plus update commit time file transaction 
section ignores additional costs related archive device manager described section 
assume archive device bottleneck 
currently optical disk archive postgres runs speed magnetic disk 
postgres disk archive device bottleneck 
postgres storage system design assumes new indices constructed data moved archive 
cost creating maintaining indices ignored analysis 
chapter 
fast recovery postgres dbms conventional disk subsystem see costs conventional disk subsystem conventional dbms versions postgres random read get page containing transaction account record 
conventional dbms writes account page disk room cache new account page 
transactions fills history relation block eventually written disk 
cost history relation updates rounded 
version postgres writes pages updated transaction account teller branch history 
force commit policy requires pages written stable storage transaction commit 
conventional dbms writes page containing log records disk sequentially cost random os 
history disabled version postgres writes transaction status file sequentially cost random os 
history enabled version postgres writes transaction status file transaction commit time file 
cost random os files written sequentially 
shown previous section random reads random writes transaction average overflow chapter 
fast recovery postgres dbms conventional disk system read write total postgres history enabled postgres history disabled write ahead log table summary traffic conventional disk subsystem 
postgres designed run non volatile ram stable storage 
conventional system able effective cache write ahead log 
pages 
os summarized table 
analysis shows conventional disk storage system postgres policy expensive write ahead logging historical data retained 
important reasons conventional system outperforms postgres environment 
conventional system take better advantage caching postgres mask disk writes branch teller history relations 
conventional system uses log updates relations recoverable dirty blocks relations need written disk frequently 
second history enabled version postgres records additional information conventional systems commit times overflow pages 
result different benchmark analysis pages written 
conventional system disk cache absorb writes 
chapter 
fast recovery postgres dbms group commit high performance dbmss mechanism called group commit reduce cost transaction commit 
group commit dbms batches transactions commits time 
group commit improves performance conventional dbms log records transactions group written disk single operation 
having log write transaction commit group size 
group commit decrease number random os done conventional system benchmark tp transactions usually update account records different pages 
postgres receives benefit group commit 
transactions share write status file commit time file 
transactions group usually append history relation page 
updates branch teller fall pages 
postgres tp database branches tellers branch relation pages teller relation 
considers overhead postgres page headers tuple headers assumes average percent non overflow page contains free space historical data 
assuming tp transaction chooses record update random expected number pages calculated group size 
group size teller page writes fall dirty pages branch writes 
transactions average write percent teller branch page respectively total random os 
group size postgres write history relation chapter 
fast recovery postgres dbms group commit group size read write total postgres history enabled postgres history disabled write ahead log table group commit conventional disk subsystem 
postgres benefits conventional system group commit random os eliminated 
postgres force commit os tp relations os pages relations consecutive transactions group 
table shows traffic group size 
group times transaction 
total number random os relations 
transaction status file log written sequentially group cost 
history enabled version postgres writes commit time file group cost random os transaction 
non volatile ram original postgres storage system designed non volatile ram reduce number random os required commit time 
postgres nvram presumably combination guarding stable storage data stored recoverably writes disk 
nvram changes costs systems dbms random read get page containing transaction account record 
conventional dbms write dirty account page disk chapter 
fast recovery postgres dbms transaction order room cache new page 
postgres making room nvram account record written commit time 
postgres able store tail history relation nvram 
conventional system fills history relation block transactions cost random os transaction 
postgres history relation blocks filled transactions cost random os transaction postgres larger tuple headers 
postgres nvram mask writes history relation page filled 
nvram available postgres buffer tp hot relations nvram 
branch teller relations take mbytes postgres 
fraction hot relations stored nvram 
nvram available conventional dbms writes log records disk log page filled 
assumed take transactions logging cost sequential random os transaction 
nvram available postgres certainly keep tails status file commit time file 
transactions status file block fills written disk 
historical query version postgres commit time file block fills transactions 
numbers small chapter 
fast recovery postgres dbms omit analysis 
history enabled version postgres write overflow pages disk transactions 
table summarizes disk activity required storage system nvram available stable storage 
postgres costs parameterized fraction hot relations buffered nvram 
postgres tp database branches tellers buffered mbytes nvram 
considers overhead postgres page headers tuple headers assumes average percent non overflow page contains free space historical data 
postgres conventional system comparable speeds nvram available postgres cache hot relations 
conventional system take advantage nvram improvement sees due nvram fewer log writes 
postgres nvram absorb disk writes way conventional system volatile ram cache 
nvram masks cost maintaining commit time file history enabled version postgres 
raid disk subsystems consider cost running postgres raid disk subsystems 
raids parallel disk subsystems parity provide media recovery lower costs standard techniques disk mirroring 
raid divided stripes data blocks parity block different disk 
disk fails block chapter 
fast recovery postgres dbms non volatile ram read write total postgres history enabled postgres history disabled write ahead log table summary traffic nvram available 
number random os required postgres depends amount nvram available 
branch teller relations cached postgres history feature enabled percent slower systems 
postgres history disabled slightly faster conventional system environment write log pages 
failed disk reconstructed parity block data blocks stripe 
unfortunately maintaining parity blocks worsens random write performance significantly 
data block randomly written subsystem read parity block reread data block disk original value determined compute new parity block old parity block old data block new data block write parity block 
random write causes additional random reads random write 
additional reads eliminated random os subsystem physical memory available caching parity blocks original values data blocks 
dbms delaying writes long possible caching effective especially nvram available 
parity blocks raid quadruples number random os required transaction storage system 
raid increases amount chapter 
fast recovery postgres dbms raid nvram postgres history enabled postgres history disabled write ahead log conventional disk nvram postgres history enabled postgres history disabled write ahead log table comparison random os raid conventional disk subsystem 
reading writing raid parity blocks increases penalty insufficient nvram buffer random writes postgres 
fraction branch teller relations buffered nvram 
upper part table shows affect limited nvram database resides raid 
lower table shows effect nvram conventional disk subsystem 
column lower table right column table 
middle right columns plus left column upper lower tables respectively 
takes place insufficient nvram available buffer hot relations 
random writes table random os parity blocks considered 
extra write transaction average extra writes transaction 
raid log structured file system log structured file system lfs described eliminate random writes required dbms reduce cost maintaining parity raid 
lfs organizes disk collection half megabyte segments 
chapter 
fast recovery postgres dbms segments current segment tail log 
updated file block forced disk lfs file system appends block current segment seeking block original location disk writing 
file system meta data updated memory logged current segment reads find newer version block 
eventually lfs garbage collects old segments throwing away date blocks 
blocks date live blocks coalesced new segment rewritten 
lfs improves dbms performance raid turns random writes sequential writes 
nvram available allow system buffer large amount data write traffic transactions batched large sequential write 
data written disk full stripes stripe parity block computed blocks stripe 
eliminates cost reading parity blocks amortizes cost writing parity block blocks user data 
lfs turns random writes sequential writes garbage collection increases number blocks read written tp transaction 
garbage collection cost depends live data contained garbage collected segment 
fraction live data garbage collected segment tp transaction read block rewrite blocks block free space reclaims 
random write table roughly sequential os random os lfs 
table shows bottom line lfs nvram available postgres storage system fast faster conventional chapter 
fast recovery postgres dbms lfs raid nvram postgres history enabled postgres history disabled write ahead log conventional disk nvram postgres history enabled postgres history disabled write ahead log table comparison os lfs raid non lfs conventional disk subsystem 
lfs eliminates os associated calculating parity block changes blocks updated tp transaction 
previous tables fraction branch teller relations buffered nvram 
percent segment garbage collected lfs assumed live data 
postgres outperform conventional dbms environment writes fewer log pages pays little penalty non sequential write behavior 
storage system 
lfs reduces cost constructing parity blocks eliminates disk seeking force commit causes non lfs file systems 
addressed fact lfs randomizes layout pages disk sequential reads queries effectively impossible 
problem discussed database reorganization strategies minimize effect subject continuing research 
measurements comparing sequential account file reads hours tp transactions lfs conventional file system show lfs read slower conventional file system read 
chapter 
fast recovery postgres dbms summary summary large amounts nvram crucial performance postgres update intensive applications tp 
wal system able buffer updated pages volatile memory write ahead log guarantee durability updates 
postgres buffer updated pages nvram 
performance postgres comparable wal dbms heavily updated parts dbms cached nvram 
postgres raid penalty insufficient nvram increases times random os required random required conventional disk system 
log structured file system changes way raid parity blocks calculated eliminates penalty 
raid device postgres performs non volatile raid available 
section indicates dbms fast recovery features postgres losing performance historical data feature reduces performance percent high update rate environment 
analysis section drives home importance techniques page guarding conventional systems postgres 
nvram stable storage sense data stored safe errors 
increasing importance software errors systems assume data nvram safe errors precautions guarding taken 
assumed section archive device bottleneck 
current postgres measurements show data archived optical disk chapter 
fast recovery postgres dbms rate stored magnetic disk 
current implementation archive data generated quickly archive limit performance 
postgres archives information conventional dbms store log 
performance conventional high performance dbms usually limited log device speeds 
conceivable redesign storage system archiving bottleneck 
guarding disk cache large main memory disk caches help dbms performance significantly outage occurs software failure noticeable customers 
software failure disk cache dbms buffer pool usually discarded extent damage caused error unknown 
risk propagating corrupted data permanent database dbms disk cache clean versions cached pages disk 
recovery cost demand paging database main memory disk seek time effective cache size page size 
ignoring effect disk arm contention currently executing transaction recovering disk cache takes minutes disk seek time ms effective cache size mbyte page size kbytes 
chapter showed common types errors ones damage data buffer pool 
errors control errors chapter 
fast recovery postgres dbms affect guarded buffer pool 
buffer pool guarded prevent corruption addressing errors dbms reuse old buffer pool failure 
reliability affected errors propagated buffer pool pages pages stored disk stable memory 
section describes situations additional reliability risk occur 
consider separate cases 
error corrupt values inserted database 
example data error cause dollars deducted bank account dollar 
transaction allowed commit errors unrecoverable buffer pool guarded 
transaction durability updated tuples permanent transaction commit time 
conventional system corrupted values written log postgres corrupted values written data pages forced stable storage 
recovering guarded buffer pool increase reliability risk due class errors 
second error corrupt data page tuple updated dbms 
postgres corrupted page written stable storage transaction 
conventional dbms corrupted page remain buffer pool replaced checkpoint 
dbms fails page written stable storage conventional system recovering buffer pool disk clear damaged page guarding reduces reliability case 
postgres damaged page written disk transaction commit reloading buffer pool provides benefit 
presumably dbms reload pages unprotected chapter 
fast recovery postgres dbms time failure 
class errors argues strongly deferred write model guarding affect unmodified records page containing modified ones 
third error corrupt page updated transactions 
data chapter shows unusual random pages memory damaged errors 
occur errors ones detected guarding 
fourth error case consider corruption buffer map 
buffers identified mapping buffer 
page physically corrupted error corrupting mapping effectively corrupt data 
saving pair header data page kind error detected 
summary recovering reloading buffer pool improve availability risk dbms reliability 
available data software errors lack available techniques measuring software reliability hard quantify increase risk 
case corrupting data near updated tuples case random corruption buffer pool ways recoverable cache decrease reliability 
exact increase risk depends effective guarding preventing errors long errors remain undetected occur 
data chapter conclusive indicates risk guarded data buffer pool small especially deferred write model guarding 
chapter 
fast recovery postgres dbms recovering session context order dbms client program submit queries postgres backend server process establish communication session kinds state lost failure 
sessions clients server slow reasons 
recovery client driven 
clients detect timeouts dbms server failed recovery actions 
second restoring sessions requires messages exchanged client server processes transmission delays incorporated recovery time 
third server clients try reconnect time contend server resources 
client awaiting confirmation transaction commit query database determine commit occurred system crash 
transaction commit client resubmit 
transaction short debit credit workload entire transaction contained single message client needs find transaction committed submitting new 
section describes techniques developed course dissertation reducing impact problems 
modified version postgres recovery 
allows sessions created stored clients run reconnect protocol new queries submitted dbms failure 
session recovery mechanism integrates postgres storage system communication protocol order determine quickly clients transaction succeeded 
recovery mechanism takes advantage guarded memory limit number clients chapter 
fast recovery postgres dbms need communicate server recovery software errors 
communication architecture postgres original version postgres backend client software architecture backend process created dbms client requesting service dbms 
original version postgres dbms considered available dbms server ready accept new connections clients 
little done help clients determine reestablish state lost failure 
partly order support fast recovery architecture changed clients connect share pool dbms backend processes 
message arrives clients queued shared memory 
time backend process idle chooses session pending 
client session assigned backend process backend continues working client transaction 
simplifies implementation substantially backend processes multi threaded postgres great deal transaction state 
order simplify protocols described assume client submit transaction single message 
simplify description recovery mechanism follows break client server communication phases status client outstanding transaction submitted queued executing committed unconfirmed 
phases summarized 
client outstanding transaction communi chapter 
fast recovery postgres dbms cation protocol phase 
second phase submitted takes place message initiating transaction transit client server 
queued phase fills time arrival message assignment transaction backend process execution 
executing phase may involve additional message traffic client server 
dbms commits transaction protocol begins committed unconfirmed phase lasts client receives confirmation commit server 
executing transactions aborted anyway failure unconfirmed aborts effectively executing transactions 
transactions abort executing phase simply continues abort confirmation arrives client 
commit abort status transaction confirmed phase begins 
sending transactions dbms server client application authenticate initialize session 
original version postgres communication protocol implemented operating system supplied virtual circuits tcp ip 
described current section postgres modified reliable datagram protocol built top unreliable datagrams provided operating system udp 
reimplementing parts network protocol user level gave postgres control system state interprocess communication 
state managed postgres operating system saved session establishment time restored failure 
tcp ip connections reliable datagram sessions established message exchange client chapter 
fast recovery postgres dbms phase submitted phase client prepares transaction transaction transit queued phase awaiting service dbms phase client prepares transaction committed unconfirmed executing dbms server confirmation transit executing phase phase phases client server communication protocol 
phase ends client sends message containing transaction dbms server 
submitted phase ends server accepts messages queues contents service 
queued phase ends server process available execute transaction 
executing phase ends server commits transaction 
committed unconfirmed phase ends client receives confirmation transaction commit 
executing phase may contain client server communication transaction requires message phase leads directly phase transaction aborted 
server sequence numbers established client authenticated 
dissertation considers server recovery section follows contains provisions saving restoring state client 
recovery mechanism postgres sessions reestablish communication client failure server restore kinds session state authentication information client authenticated server generates authentication token 
client send token subsequent message prove authenticated 
chapter 
fast recovery postgres dbms peer address client server record network address 
dbms context addition communication related context clients database related context maintained session 
example client states name database operating establishes session 
sequence numbers sequence number recorded incoming outgoing network packet order detect lost duplicated packets 
items generated session modified session closed 
sequence numbers change time message sent received server sequence numbers agree sequence numbers maintained client 
saving sequence numbers session actively expensive practical established unused session described small structure containing kinds state plus initial sequence numbers session 
order sessions ready recovery time postgres allows clients create backup sessions save server side backup session stable storage 
failure client server backup sessions immediately going normal session establishment protocol 
client initially connects server establishes sessions simultaneously single message exchange 
sessions unique authentication token share peer address dbms context 
sessions established chapter 
fast recovery postgres dbms designated active session initial communication client server 
sessions linked ordered list saved stable storage 
backup sessions activated order assigned created 
failure backup session activated ways 
client server activate session simply sending message session 
client ask server activate backup session automatically primary session failed 
request automatic activation client appends backup session session id authentication token request sends server 
primary session lost failure dbms acts received message backup session 
eventually new sessions established replace ones destroyed failure database available backup sessions replaced 
automatic activation mechanism designed help avoid additional communication client submits new transaction server failure 
mechanism server reject message client sent failure force client resend message backup sessions 
mechanism just piggybacks information resent message making message bytes longer avoiding retransmission failure 
note message initiates transaction specify backup session 
transaction begins client extra handle transaction aborts described anyway extra message traffic saved 
chapter 
fast recovery postgres dbms restarting transactions lost failure communication client server associated transaction recovery action required restore data transit time failure fairly straightforward 
client session submitted queued phase outstanding transaction resubmitted 
transaction executing time failure aborted 
aborted transaction resubmitted transaction complex higher level abort recovery procedures required 
section assume aborted transaction resubmitted fast recovery impossible 
transaction client simply continues normally 
client committed unconfirmed phase continue transaction soon confirms transaction committed 
recover data transit time failure client determine resubmit transaction 
determine phase communication protocol time failure postgres uses transaction identifiers xids discussed section 
addition items session state described postgres session allocated xid 
initial xid sent client part session establishment protocol 
time server confirms transaction commit new xid allocated sent client confirmation message 
client saves current xid session recovery server fails 
failure server sends recover message client telling client chapter 
fast recovery postgres dbms failure taken place 
receiving recover message client assumes transaction lost aborted new session 
client sends xid session id transaction time submitted 
items determine transaction committed unconfirmed server failed 
receiving resubmitted transaction dbms server looks xid submitted client transaction status file 
status file shows transaction committed transaction committed unconfirmed time failure 
server resends confirmation message case transaction 
lookup returns aborted transaction states server failed 
dbms assigns transaction new xid associated current session executes 
transaction reuse old xid uncommitted tuple versions xid may created failure 
server fails completing resubmitted transaction client resubmit transaction available backup session 
client send xid transaction originally submitted session id initial session transaction submitted 
sessions ordered server realize received second transaction original session id current session id differ 
time server check xids receives 
original submission transaction may resulted transaction commit 
chapter 
fast recovery postgres dbms xid session determined backup session structure stored stable storage 
committed confirmation sent client 
transaction xid associated current session 
server fails times completing transaction procedure followed client runs backup sessions 
time server fails client transaction new backup session 
sessions ordered client sent session id session submit transaction find xids associated transaction 
dbms checks xid session initial current sending confirmation message committed 
session structures stable storage find xid associated intermediate sessions 
transaction executed client receives confirmation commit send new transaction recovery message 
server receives new transaction old sessions garbage collected stable storage 
techniques server send recover message client recovery time client outstanding transaction resubmit transaction 
guarded memory available server recover reduced message traffic software failures 
guarded memory buffers store messages containing queued transactions 
maintaining guarded memory list clients acknowledged commit confirmation message server avoid chapter 
fast recovery postgres dbms sending messages clients state 
recovery time server sends recover messages clients resubmit state clients executing committed unconfirmed state 
clients executing committed unconfirmed state resubmit transactions 
fewer messages server fewer clients requesting recovery actions help system scale larger numbers clients 
summary fast recovery techniques discussed chapter important component fault tolerant system 
error detection mechanisms normally fault tolerant systems new error detection mechanism chapter halt system error detected 
system reliable prevents producing incorrect results system available users 
addition detecting errors system minimize length time takes accept new transactions 
mechanisms limit downtime simple reduce reliability increase availability 
processing write ahead log consumes bulk recovery time conventional system key fast recovery feature postgres storage system design allows systems restart log processing 
chapter builds original storage system design providing enhancements improve storage system chapter 
fast recovery postgres dbms performance transaction processing workloads 
enhancements include backward differencing tuple versions shorter tuple difference chains shortened transaction status file faster strategy system restart 
provide details data page garbage collection considered original design 
chapter thorough analysis impact postgres force commit buffer management policy tp performance 
analysis shows optimized version postgres storage system amount conventional storage system sufficient amount non volatile ram available postgres historical data feature disabled 
tp mbytes nvram required performance comparable wal dbms 
raid disk subsystem postgres performs conventional system long log structured file system lfs 
postgres historical data feature enabled analysis shows postgres percent chapter extends postgres fast recovery support mechanisms recovering state required communication clients dbms server 
saving client server connections stable storage allows client submitting transactions server immediately server recovers failure going connection protocol 
chapter discusses effects guarded memory facility introduced chapter reduce need reload disk cache failure 
technology trends making fast recovery benefits postgres practical chapter 
fast recovery postgres dbms environments particularly high data processing systems 
increasing cpu speeds reducing small performance impact postgres garbage collection run time checks 
hopefully performance impact guarded memory reduced faster processors 
costs related force commit controlled nvram available dbms 
nvram prices dropping currently times cost volatile ram 
cost effective high performance systems easier build new generations hardware customers willing trade limited amounts transaction performance high availability 
chapter supporting indices postgres storage system original version postgres extended chapter addressed ways overwrite strategies management heap relations improve dbms availability 
chapter considers effects overwrite recovery strategies dbms index data structures issue omitted original postgres storage system 
chapter previous goal support fast dbms recovery reduce time failures 
recovering relying write ahead log database available immediately dbms restarted 
failure causes inconsistencies index data structures detected chapter 
supporting indices postgres storage system repaired encountered 
availability standpoint better strategy checking repairing inconsistencies dbms restart time 
database management systems treat indices heap relations different ways indices higher concurrency requirements heap relations complex structure 
example high performance dbms uses phase locking heap relations short term locks tree index pages 
phase locking data updated transaction remains locked transaction commits 
non phase locking improves concurrency indices unrelated index keys accessed internal pages index 
transaction modifies shared internal page phase locks prevent transactions page transaction committed 
non phase locking complicates recovery transaction insert key shared page modified transaction commits commit shared page order commit inserted key 
aborts undo modifications shared page remove access key inserted transaction postgres storage system techniques described chapter provide recovery non phase locks 
postgres storage system associates transaction identifier xid update database 
data examined xid mapped status bit determine transaction committed 
xids allocated transactions transaction commit changes depend updates transactions 
chapter 
supporting indices postgres storage system second problem index management postgres storage system inserting single key index requires pages updated 
example tree index adding key leaf page cause leaf page split turn causes leaf parent updated 
page split modifies contents pages changes inter page pointers maintain index structure 
failing updated pages written stable storage leaves index structurally inconsistent 
conventional dbms uses write ahead log wal protocol recovery atomicity index updates guaranteed log processing recovery time 
systems log records describing structural changes index written stable storage updated index pages 
recovery structural changes redone inconsistent pointers repaired new transactions allowed update index 
postgres log requires solutions 
dbms maintains consistency tree indices adding extra synchronous disk writes controlling page write order 
example new index page created page split forced stable storage synchronously page index contains pointer postgres index management assumes synchronous writes single file unordered reasons 
synchronous writes page split significantly worsen page split performance 
controlling write order single multi page synchronous write allowed unix operating systems worsen performance disk scheduling algorithms allowed 
chapter 
supporting indices postgres storage system second important reason depend write ordering index management common kinds indices 
section describes example link trees postgres 
write order exists leave data structure consistent entire page split 
file systems support efficient transactional updates files version log structured file system described solutions control write order perform simpler techniques described chapter 
chapter presents general techniques maintaining index consistency write ahead logging 
techniques dbms detects inconsistencies index caused interrupted updates 
inconsistency index discovered consistency restored incomplete page split merge operations 
implemented link trees techniques trees extensible hash indices tree variants trees 
techniques uses overwrite strategy similar shadow paging 
image page split left intact stable storage half pages resulting split written 
recovery mechanisms shadow paging abandoned commercial systems performance problems experienced system practical mechanism chapter refers conventional trees assumes write ahead logging recovery ordered writes 
commercial systems ordered write model despite problems 
customers non recoverable indices preferring rebuild indices scratch indices corrupted suffering performance penalties ordered write model 
chapter 
supporting indices postgres storage system managing indices 
shadow paging sequentially ordered pages file nonsequential disk 
non sequential ordering performance clustered relation scans issue index files 
shadowing technique requires index store pointers locations images pages 
additional pointers cause shadow page tree disk space conventional tree 
second technique page reorganization eliminates space overhead performs poorly index page splits times transaction 
page reorganization scheme ensures keys moved page split available source destination page 
hybrid algorithms preserve best features cost greater software complexity 
hybrid different algorithms splitting pages near root near leaf tree 
shadowing technique leaf nodes page splits common maintain high performance page splits 
page reorganization near root reduce space overhead 
index management techniques postgres improve performance reliability conventional write ahead log storage system 
systems tree index implementations record structural changes index log 
keys involved page splits merges physically copied log order guarantee structural integrity index 
postgres indices allow system log keys inserted deleted index keys involved structural changes 
combining postgres index management conventional write ahead chapter 
supporting indices postgres storage system logging performance software fault tolerance benefits 
remainder chapter divided parts 
lists assumptions chapter 
second section describes new index management techniques 
third section discusses implications techniques conventional storage system write ahead logging 
fourth section evaluates performance impact techniques fifth section gives 
assumptions index allows dbms improve access tuples base relation 
entries index id pairs key value tid tuple identifier pointer page number offset tuple base relation 
index implementation support insert operation adds entries index delete operation removes entries lookup operation returns tid associated key 
trees allow getnext operation returns id pair preceding key looked 
postgres operations implemented options normal lookup operation 
algorithms described chapter require key managed index unique 
indices built attributes duplicate values dbms convert user visible key value pair oid entered index 
oid unique object identifier associated object chapter 
supporting indices postgres storage system referred index entry 
oids unique keys inserted index unique 
conversion adds bytes size key 
note lehman yao concurrency control algorithms tree implementations assumption 
bytes overhead overhead associate shadow page reorganization trees analysis chapter 
postgres pages modified transaction written stable storage transaction commits 
purposes dbms syncs pages modified pages written disk 
written disk order chosen operating system dbms 
crash occurs sync operation subset pages may written disk 
assume single page disk writes atomic 
sync system call assumed block dbms notify dbms page writes completed 
sync operation corresponds limited control page write order unix operating system gives users 
unix allows groups pages written disk allow application control write order pages group 
possible transaction updating data page time transaction page 
index recoverable log processing dbms ensure currently valid keys visible invalid keys invisible index lookup operations 
postgres storage system detect ignore records pointed invalid keys recovery needs ensure valid keys lost 
chapter 
supporting indices postgres storage system postgres indices possible sources inconsistencies inter page intra page inconsistencies 
inter page inconsistencies occur pointer page stored page failure occur written stable storage 
intra page inconsistency happens page written stable storage dbms adding key page deleting key 
concurrency control prevents processes modifying page time 
performance reasons postgres reacquire lock page forces page stable storage 
process modifying page commits page inconsistent stable storage 
crash dbms detect inconsistency repair 
support postgres indices section describes algorithms implementing indices postgres storage system 
describe terms link trees trees managed algorithms 
techniques analogous discussed link trees extensible hashing 
application techniques hashing discussed briefly 
section describes basic tree data structure modifications data structure required postgres shadow page reorganization algorithms 
separate sections highlight parts algorithms required support link trees delete chapter 
supporting indices postgres storage system key key key key key header line table conventional tree page 
operations short term locking 
traditional tree data structure traditional tree page tree contains array pairs header describes space allocation page see 
order keys page recorded line table 
entry line table contains offset pair page 
new key added page line table entries reordered elements stored page 
internal page data element associated key pointer child page 
leaf page data element associated key tuple identifier tid pointer data page line table entry page 
comer describes tree data structures detail details insert delete operations important algorithms summarize 
chapter 
supporting indices postgres storage system simplest tree split occurs amount free space page goes threshold 
split page new page allocated 
half pairs old page inserted new deleted old 
pair representing new page added split page parent 
key removed page page freed 
variations tree data structure merge operation rebalance neighbor pages inserts deletes cause page keys neighbor 
merge moves keys heavy page light adjusts key value parent page reflect change 
simple variations basic postgres page split algorithms support page merges 
variations described section basic algorithms 
sync tokens synchronous writes postgres index management algorithms need able determine tree pages linked pointers written sync operation 
record information postgres maintains global sync counter counts sync operations tree underwent structural changes 
sync operation index split occurred dbms increments global sync counter 
maximum sync counter guaranteed larger global sync counter maintained stable storage 
current global sync counter approaches maximum new maximum chosen written stable storage 
crash maximum sync counter chapter 
supporting indices postgres storage system reinitialize global sync counter 
sync token value global sync counter point time 
sync tokens saved index pages detect inter page inconsistencies 
value maximum sync counter time system crash called crash sync token 
dbms shuts cleanly global sync counter crash sync token written stable storage 
technique shadow page indices postgres shadow trees key internal page contains pointer current previous version child page associated key 
array pairs page shadow tree page array triples see 
previous page associated key page containing key value guaranteed stable storage 
current page pointed date version page may stored volatile memory 
system crashes current page lost crash previous page construct new current page manner described 
page split algorithm shadow trees splitting page shadow tree new pages allocated call half keys copied half split keys modified overwritten 
initialized value chapter 
supporting indices postgres storage system key key current previous key ancestor shadowing page strategy 
keys internal pages tree contain 
points date version page current 
current volatile storage points version page definitely written stable storage 
global sync counter recorded field page header 
split parent page updated 
page initially contains key points traditional tree split algorithm calls new key containing pointer added shadow paging algorithm updated manner new key allocated field contains page number page 
sync token different current global sync counter written stable storage 
case set point added memory freed list 
sync operation added index freelist see 
chapter 
supporting indices postgres storage system key key key key key key shadowing page split 
page split 
verify stable storage original value key page discarded 
previous page key new key 
page splits transaction 
split split transaction 
share previous version key pages existed failure recorded stably page chapter 
supporting indices postgres storage system sync token current global sync counter reused stable storage 
assigned freed immediately 
situation occurs splits occur key sync operations see 
inserted page line table 
modified field contains page number adding page causes split algorithm followed tree root page 
root page splits new root page created containing pairs pointing halves old root 
page index meta data page containing pointer current root tree 
internal page keys root pointer contain previous current page pointer 
order prevent intra page inconsistency careful adding line table 
line table entries intra page pointers offsets page point key values 
line table ordered line table entry offset selected hold offset 
line table extended copying entry line table element line table incrementing field page header 
line table entries copied entry right current position 
offset saved entry 
adding elements line table manner limits kind intra page inconsistency occur 
transaction forces tree page stable storage chapter 
supporting indices postgres storage system adding line table entry guarantee possible intra page inconsistency duplicate entry line table 
subsections explain detected removed 
detecting inconsistencies index section pointed postgres trees kinds inconsistencies potentially arise failure inter page intra page inconsistencies 
intra page inconsistencies occur duplicate line remains page described previous subsection 
crash tree update cause inter page inconsistency parent written stable storage crash child 
case points uninitialized page page reused 
written new child page inaccessible parent child link consistent 
reclamation pages inaccessible crash discussed subsection 
key insert originally caused interrupted page splits may may lost failure postgres force commit policy key index inconsistent 
key certainly uncommitted 
transaction caused interrupted page split aborted crash 
postgres transactions force writes disk commit time split interrupted transaction committed 
uncommitted key leaf page points invalid heap record heap record postgres ignore explained chapter 
committed keys subtree rooted tree internal chapter 
supporting indices postgres storage system page split occurs 
failure effectively causes spontaneous page splits affect committed contents index 
postgres detects inter page intra page inconsistencies index course normal index operations 
descending key lookup insert delete dbms determines minimum maximum key values stepping minimum maximum key values page compared expected key range 
key ranges parent child link consistent search continue 
key ranges differ page zeroed dbms detected inter page inconsistency 
dbms detects intra page inconsistencies checking adjacent entries line table contain offset value 
intra page inconsistencies need detected repaired key added deleted page 
duplicate entry cause key lookups fail ignored key lookups 
repairing inconsistencies index soon broken inter page pointer link discovered dbms completes lost interrupted page split operation 
shows page existed split 
reinitialize date child page dbms uses keys parent page determine range keys missing page 
keys copied directly child page page pointed 
sync token child page initialized current global sync counter 
child page chapter 
supporting indices postgres storage system reinitialized tree search continue new child page 
note possible halves page split lost crash 
case loss detected repaired independently 
root page split new version root lost page copied directly child page 
root page existed failure keys inserted tree lost root page initialized empty page 
dbms repairs intra page inconsistency deleting duplicate entry 
dbms copies line table entries left duplicate entry line table decrements page header 
free space management normal operation linked list pointers pages freed index kept memory freelist associated index 
freelist volatile storage survive system failures eventually regenerated 
discussed chapter postgres heap relations require garbage collector part storage system archiving feature 
adding index freelist regeneration current archiving tasks garbage collection expensive 
freelist regenerated new pages allocated extending index file long file system run disk space 
assume crashes infrequent disk space plentiful index file extended chapter 
supporting indices postgres storage system freelist regenerated 
volatile memory freelist lost system fails 
dbms shut cleanly index freelist written disk 
index meta data records number entries freelist pointer list disk 
dbms restarted freelist disk initialize new memory freelist 
pages freelist new page splits meta data pointer freelist disk invalidated 
list invalidated disk pages disk freelist free failure 
pages taken memory freelist mean time allocated page splits pages reallocated dbms restarts 
freelist postgres indices record information contents free page order ensure broken parent child pointer links shadow tree detected 
show information necessary review freelist shadow tree page split 
new pages allocated free list 
half keys original page copied newly allocated pages 
added freed temporary freelist contents added true freelist page split committed 
parent updated contains pointers remember dbms descends search tree key dbms compares range keys range keys indicated page 
child page contains different key range inter page inconsistency chapter 
supporting indices postgres storage system detected page written stable storage failure technique detecting inter page inconsistencies restricts way dbms allocate pages freelist hold new child pages time page split page allocated freelist contains keys page time deallocated 
inter page inconsistencies detected keys contained freelist page allocated page split legal contents page freelist page contain key range dbms unable determine written stable storage system failed 
order inter page inconsistency detected freelist record key ranges pages list 
page deallocated page split key value recorded freelist usual pointer deallocated page 
allows dbms check page reallocated hold key range 
technique page reorganization indices tree modifications described add bytes key internal page 
keys small extra bytes reduce tree fanout increase height tree 
increasing height tree increases average cost data access 
page reorganization algorithm reduces loss fanout eliminating pairs tree page 
algorithm splitting page chapter 
supporting indices postgres storage system reclaim space page immediately 
split dbms copies half keys new page reorganizes algorithm described see 
reorganization original keys intact page space available new peer original page dbms fails written stable storage new peer keys lost 
reorganized page recovery 
sync operation successfully writes reorganized new peer stable storage space page containing duplicated keys reclaimed 
dbms add keys original page sync operation initiates extra sync operation blocks sync completes 
sync operation done space containing duplicate keys reclaimed dbms add new key page 
page reorganization algorithm adds fields page header 
field page non zero page contains backup keys recovery 
zero page safe update 
describe split page reorganized page 
page contain new key caused split 
note may left right child split 
pointer reorganized page points null 
split page proceeds follows new pages allocated 
allocated memory backed disk 
allocated normally 
chapter 
supporting indices postgres storage system header header header page split page reorganization trees 
split reorganized page mapped top old page disk 
keys saved free space region split pages successfully written stable storage area containing corresponding line table entries free space 
duplicate copies keys recovery 
chapter 
supporting indices postgres storage system half keys copied half just normal split 
field initialized zero 
initialized number keys original page 
keys copied free space area keys allocated page just copied page free space region 
line table keys set just line table guaranteed space keys line table information stored original page 
sync tokens initialized global sync counter 
remapped memory buffer pool meta data location disk 
new key insertion caused split added parent page updated reflect split 
detecting repairing inconsistencies postgres uses technique detecting inter page inconsistencies page reorganization trees shadow page trees 
dbms searching key steps parent page child page 
step dbms checks key range child consistent key range indicated parent 
intra page inconsistencies detected repaired way types trees 
repairing inter page inconsistencies slightly complex page reorganization chapter 
supporting indices postgres storage system tree 
shadow trees inter page inconsistencies occur parent page written stable storage new child pages created page split 
page reorganization trees children symmetric different kinds inconsistencies occur written disk replacing written inaccessible parent parent written parent written parent written 
written tree inconsistent page lost 
note inconsistencies detected kind range check shadow tree 
case shadow trees inconsistencies repaired soon detected 
cases tree consistent regenerating assigning duplicate keys 
case regenerated copying duplicate keys saved case regenerated removing keys represented case split repeated generate time key added deleted page dbms check free space page needs reclaimed 
field zero extra keys stored free space 
sync token page checked 
cases chapter 
supporting indices postgres storage system sync token global sync counter sync operation occurred page initialized duplicate keys page required recovery 
dbms block sync operation key added page 
sync token greater equal crash sync token different global sync counter new key added normally 
sync operation definitely committed keys longer needed recovery 
page sync token crash sync token immediately tell split committed successfully 
dbms crashed page written 
page sibling split lost crash backup keys page needed recovery 
case pointer find sibling 
sibling exists sync token current page larger sibling need recovered parent halves page stable storage split 
sibling zero older sync token sibling date recovered 
new key inserted field zeroed check inconsistencies page split 
chapter 
supporting indices postgres storage system delete merge rebalance operations conventional storage system deleting record database forces dbms delete index keys refer record database 
transaction deleted record aborts dbms reinsert record index keys referred 
chapter explained postgres conventional system 
record logically deleted remains physically place marked invalid 
dbms encounters index key points logically deleted record ignored 
eventually vacuum cleaner process deletes record related index keys 
strategy means index recovery algorithms postgres need consider problem index keys failure 
vacuum cleaner physically deletes index keys transaction logically deleted definitely committed 
dbms halts completing index key delete operation vacuum cleaner eventually encounter key dbms restart delete 
recovery related problem needs considered delete operations ensuring structural inconsistencies index occur result failed delete operations 
simplest kinds trees deletes potential causing inconsistencies inserts 
delete operations remove inter page pointers pages store pages 
deletes leave pointers allocated uninitialized pages occurred page splits 
simplest trees page ready deallocate key page deleted 
page empty key parent page deleted 
chapter 
supporting indices postgres storage system key key key key key key key old heavy old light new heavy new light key key merge operation balanced shadow tree 
keys including key moved heavy page light page order sizes pages 
ancestor page dummy key added represent keys moved heavy light 
case shadow algorithm deallocated parent written stable storage sync operation 
delaying deallocation ensures reallocated pointers page exist valid parts index stable storage 
intra page line table inconsistencies resulting interrupted deletes look exactly interrupted inserts duplicate entries remain line table handled way 
general merge operations required balanced trees trees handled recovery algorithms way page splits 
page reorganization treat merge operations exactly splits 
merge operation moves keys heavy page light page balance leaves peers exactly state page reorganization peers heavy page treated original peer split chapter 
supporting indices postgres storage system light page treated new peer created split 
new peer case initially contains keys recovery mechanism need aware 
shadowing merge operations done little carefully new light page effectively original light page original heavy page 
merge proceeds usual keys moved heavy page light page modifying key light page ancestor add new key 
new key represents keys moved heavy light page merge operation 
child page new version light page old version heavy page 
new pages written stable storage dummy key light key merged order reclaim space ancestor page 
see example 
subsections section described shadow page reorganization algorithms managing basic tree operations write ahead log 
postgres commercial systems slightly complex variation basic tree called link tree 
data structures additional pointers pages achieve better performance 
section explains structures shows changes required support write ahead log 
section discusses conventional index concurrency control algorithms ways modified support postgres index recovery techniques 
chapter 
supporting indices postgres storage system root leaf peer normal link tree 
leaf nodes connected peer pointers 
path parent child referred root 
secondary paths leaf pages link tree link tree indices performance indexed scans improved doubly linked peer pointer chain leaf pages consecutive keys see 
peer pointers allow scans move leaf page leaf page reading additional internal pages 
key inserts traverse path root leaf 
page split left neighbor right left shadow page algorithm page re linked peer pointer path consistent 
link trees complicated failure modes simple trees 
paths leaf page key leaf page may reached peer pointer root leaf path 
techniques described correct inter page inconsistencies path worst case failure mode paths inconsistent 
example root leaf chapter 
supporting indices postgres storage system worst case inconsistent link tree 
page split written stable storage system crashed 
peers 
tree peer pointer path consistent tree split root leaf path consistent tree split 
path contains post split version page bold old peer pointer path contains pre split version page 
worst case failure corrupt index key added deleted duplicate pages created failure 
transaction incomplete split created duplicate paths commit paths successfully written disk 
insert delete failure duplicate pages contain set valid keys 
detecting inconsistencies index link tree scan peer pointer path checked inter page inconsistencies 
unfortunately key ranges detect inconsistencies root leaf path chapter 
supporting indices postgres storage system peer pointer path 
peer pointer path page know peer key range record accurately page updated keys added peer 
detect inconsistent peer pointer paths additional sync token fields included page header associated peer pointer 
peer pages pointer pointer sync token associated 
peer pointers reconciled split sync tokens peer pointers neighbor pages reset 
comparing peers sync tokens path traversal detect inconsistency path 
link broken crash update sync tokens adjacent pages agree 
inconsistent link repaired root leaf path correct peer 
root leaf path broken repaired repair algorithms described 
sync tokens detect existence completely separate pointer paths occurs 
case peer pointer path internally consistent sync tokens match peer pointer path consistent root leaf path 
key inserted page ensure linked peer pointer path 
inserting key page dbms checks sync token greater crash sync token 
know page part consistent peer pointer path 
path inconsistent system failure 
dbms chapter 
supporting indices postgres storage system follow peer pointer path directions leaf page targeted insert 
search stops page different sync token discovered page sync token peer pointer sync token 
peer pointer path consistent point leaf page inserted reachable peer pointer path 
done reinitialize sync token page 
prevent dbms path subsequent insertions 
inserting key page page written stable storage anyway 
reinitialized sync token reach stable storage transaction causing extra worst case searching path expensive part algorithm 
page splits occur time resulting pages sync token 
insert pages cause read 
case insert performance affected key inserted page path failure key lookup affected failures 
insert performance crash improved worst case small lru cache sync tokens 
sync token verified searching peer pointer path insert finding inconsistencies token added cache 
insert cache checked verifying peer path 
cache size handle worst case occurs large index created single transaction 
case page index sync token 
chapter 
supporting indices postgres storage system dynamic hashing postgres hash indices hash function applied index key determines address page bucket containing id pair 
dynamic hashing algorithms allow hash table grow keys added 
linear hashing maps value produced hash function directly bucket address 
extendible hashing uses hash value find directory entry 
directory entry contains pointer find bucket address 
hash table grows additional bits hash value considered mapping key hash bucket 
bucket overflows split second bucket chained pointer link 
bucket split extra bit hash value rehash keys old bucket new bit zero new new bit 
see surveys dynamic hashing algorithms 
postgres index management schemes applicable extendible hashing linear hashing 
shadowing algorithm take advantage extra level indirection provided directory extendible hashing 
direct hashing algorithm linear hashing shadow algorithm page reorganization 
inconsistent directory pointers detected storing bit mask number bits considered bucket header key ranges trees 
inconsistencies pointers overflow pages detected split tokens way peer pointers link trees 
extendible hash index implementation estimate chapter 
supporting indices postgres storage system impact shadowing algorithm hash index read performance 
extendible hashing requires lookup key value directory entry memory directory entry fetched disk 
shadowing scheme doubles size directory prev pointer doubles amount memory directory increases average access cost parts directory demand paged memory 
concurrency control postgres link tree implementation uses concurrency control algorithm designed lehman yao 
lehman yao readers writers descend tree root leaf find page containing key 
writers ascend splits deletes propagate leaf 
descending locks coupled readers release lock acquiring 
ascending locks coupled lock child page released lock correct parent page acquired 
pointed algorithm deadlock free lock coupling traversing tree direction 
lock coupling directions allows deadlock reader holding lock ancestor tries acquire lock child page time writer holding lock page split tries lock complexity arises lehman yao fact reader descending may find split period reader holding locks 
chapter 
supporting indices postgres storage system descending reader saves pointer child page releases lock parent acquires lock possible reader operating system right acquires lock processes split reader rescheduled 
original lehman yao scheme page split operation move key sought reader neighbor page 
pages deallocated lehman yao trees page split moves higher valued keys new page leaving lower valued ones place 
reader finds key searching longer reader moves horizontally tree coupling finds key 
event page splits descent reader may traverse pages 
postgres trees especially shadow trees account page deallocation 
postgres pages deallocated split dbms ensure page deallocated reader try examine deallocated page 
algorithm calls reader pin buffer containing child page memory releasing parent lock 
allocator knows reallocate pages buffers pin count greater 
reader may buffer soon child lock released 
solution add synchronization overhead buffer pinned memory anyway 
shasha discuss complex techniques solving problem case pages recycled key deleted 
lehman yao reader process postgres shadow trees find chapter 
supporting indices postgres storage system pages produced split child page lehman yao guarantees pages results split 
reader process start horizontal movement original page guaranteed find key time split 
postgres page reorganization trees true 
shadow trees page replaced new pages 
allow reader find pages add page replacement pointer tree page header 
page replacement pointer original page set point new left page 
process visits page non null page replacement pointer traverses link new left child 
analogous horizontal movement described required key interest high half split page 
note page replacement pointer interest page pinned memory current reader 
need written disk need survive failures 
original lehman yao locking algorithm assumed peer pointers unidirectional page pointer right peer 
restriction means rightward scans faster leftward scans 
order eliminate restriction introduce new locking protocol ensure peer pointers adjusted correctly 
postgres protocol relies new type lock called split lock allows distinguish page splits reads writes 
split locks conflict split locks 
process holding split lock split page add keys page 
processes may adjust peer pointers page holding split lock 
protocol described detail description easier chapter 
supporting indices postgres storage system follow clear bidirectional peer pointers give rise deadlock 
dbms process splits page acquires lock page ensure split processes add keys delete keys concurrently attempt split page 
split complete process adjust peer pointers new pages resulting split accessible original page neighbors 
adjust neighbor page peer pointers neighbor page locked 
situation case lock coupling 
dbms process holding lock page split acquiring lock neighbor 
adjacent pages split concurrently deadlock occur process holds page tries acquire neighbor 
unidirectional pointer case processes lock couple opposite directions deadlock occurs 
deadlock possible bidirectional case processes lock coupling opposite directions 
postgres uses normal write locks pages combination new split locks order avoid deadlock processes lock couple opposite directions 
dbms process inserts key page acquires write lock page prevent processes inserting keys time 
process finds page split releases write lock acquires split lock write lock 
split necessary gotten write lock split page process released write lock process splits page 
write lock original page released peer pointers neighboring pages updated 
updating neighboring peer pointers requires write lock neighbor page chapter 
supporting indices postgres storage system split lock neighbor page 
split lock original page released neighbor peer pointers updated 
deadlocks impossible processes acquire split lock write lock acquire pair tree time 
split locks write locks conflict processes hold split lock page acquire write lock peer causing deadlock 
concurrent access inter page links temporarily inconsistent algorithm distinguish true inconsistencies false inconsistencies arise concurrent updates 
link token inconsistency discovered inconsistent tokens compared crash sync token 
inconsistent tokens crash sync token inconsistency transient caused concurrent access 
older crash sync token inconsistency caused concurrent update 
shadow indices logical logging far discussed index management techniques terms postgres storage system techniques support logical logging conventional wal storage system 
conventional index management schemes aries im require modifications index written log 
tuple updated dbms logs keys inserted indices result chapter 
supporting indices postgres storage system update 
index insert results page split keys moved page split logged inserts destination page 
deletes original page split logged simply changes line table abbreviated log record constructed tells key range moved page split 
stated chapter conventional systems logged information restore index consistency failure 
logical logging scheme save index changes log 
tuple updated changes tuple logged keys inserted deleted index 
logged tuple attributes serve implicit log records indices attributes 
recovery index keys affected update derived logged attribute values 
logged change undone redone dbms deletes inserts keys indices necessary 
dbms detect ignore reinsertion pair 
difference logical log conventional log logical log contains keys inserted deleted index 
log keys move index due page split merge operations 
logical log allows system determine keys inserted deleted index maintain structural integrity index 
technique ones described chapter maintain index consistency page splits 
conventional system postgres index consistency techniques need sync index transaction 
postgres storage system chapter 
supporting indices postgres storage system dbms sync index transaction order keys inserted deleted transaction permanent 
logical log inserts deletes index permanent logical logging 
log processing restore keys lost failure 
logical logging performance disk space advantages conventional index management 
conventional log longer logical log conventional logs store pairs split merge 
conventional system log keys moved original page new peer page page split adds half page log kbytes kbytes typical page sizes 
longer log means data needs written disk commit log pages need read disk recovery 
conventional log log takes space disk 
importantly logical logging fault tolerance advantages conventional tree management 
little special case code required recovery 
insert delete operations normal execution recovery 
specialized recovery code includes code repeat incomplete page split inconsistency detected 
logical logging stores high level representation index operations systems propagate damage caused software errors log 
example internal index page corrupted software error conventional physical logging techniques copy corrupted keys log 
recovery corrupted keys restored index 
logical logging copies chapter 
supporting indices postgres storage system information index log 
software corrupts index index recovered backup version checkpoint log 
comparing system aries mohan levine suggest reasons write ahead logging techniques aries superior shadow logging approach system 
objections apply logical logging shadow trees deadlocks undo usual response deadlock abort deadlocked transactions 
abort requires undo potential deadlocks undo means aborting transaction active time 
lock coupling strategy described section prevents processes index operations 
concurrent aborts execute concurrent shadow tree operations 
concurrency overhead recovery processes recovery system concurrency overhead incurred logical undo redo operations 
aries requires concurrency control index recovery recovery operations applied page independently 
parallel recovery shadow trees concurrency control just system locks involved short term locks phase locks 
simulation results indicate short term locks concurrency control overhead limit recovery performance 
concurrency control scheme simulated dbms running insert workload main memory buffering tree 
simulations showed workload bound high degrees multi programming 
concurrency chapter 
supporting indices postgres storage system overhead significantly affected performance simulation workload bound especially large amount buffer space available 
overhead recovery system shadow trees require operations recovery aries logical undo operations traverse path root leaf operation undone redone 
aries page oriented recovery usually undo redo operation single read write leaf page 
additional required shadowing scheme small 
root upper pages tree index loaded memory operations processed 
memory scarce pages remain memory rest log processing 
page oriented recovery may require pages brought recovery pages brought useful done index recovery 
operational logging reduce number disk reads required process log log compact 
tree consistency failures dbms failures leave indices inconsistent file system uses shadow paging 
mohan levine objections maintaining index consistency shadow pages poor performance shadow paging system system shadow paging file system technique support recovery indices data files 
data files shadow paging reduced performance sequential scans dramatically 
shadow paging pages file non sequential disk 
techniques force extra chapter 
supporting indices postgres storage system lookup page map direct access file pages 
consistency maintenance techniques described allow shadowing page reorganization algorithm shadowing limited index files 
indices sequential order pages disk unimportant performance 
shown section shadowing algorithm impact performance pronounced impact shadow paging system data files 
summary dbms relies conventional write ahead logging postgres storage system index recovery techniques chapter helpful 
index recovery techniques conjunction logical logging reduces amount information stored log giving performance fault tolerance advantages conventional index management 
similar logical logging scheme caused performance problems system postgres techniques designed avoid problems 
performance measurements index management techniques described chapter increase cost indexed access data database ways 
shadow trees larger space requirements conventional trees 
stored shadow tree keys keys bigger fewer keys fit page 
shadow trees eventually higher conventional trees number keys 
higher trees chapter 
supporting indices postgres storage system mean pages accessed get indexed data 
order illustrate cost section presents comparison shadow normal tree heights 
second dbms check inter page inconsistencies descends page page tree key range checks described subsection 
quantify cost checking inter page inconsistencies implemented techniques measured implementations 
section presents measurements 
third special cases cause postgres trees extra disk read write recovery page split 
section enumerates cases estimates impact performance 
modelling effect increased tree heights performance concern regarding postgres link tree indices additional space overhead incur increase height tree driving access costs 
order quantify cost calculated index capacity fixed heights normal page reorganization shadow link trees 
expected normal trees add levels slowly shadow trees add levels quickly 
page reorganization trees grow nearly rate normal trees omitted analysis follows sake brevity 
illustrates differences height normal trees postgres shadow page trees different tree sizes 
curves labelled normal byte shadow byte show heights normal shadow link trees storing byte keys 
curves labelled normal byte shadow byte show chapter 
supporting indices postgres storage system storage capacity vs height tradeoffs trees byte keys 
note axis logarithmic 
shaded regions highlight tree sizes shadow trees greater height normal trees 
regions axis values shaded areas shadow normal trees height 
trees modelled kbyte pages 
normal link trees byte internal page keys shadow link trees byte internal page keys byte 
page header normal tree bytes shadow tree header bytes sync tokens replacement pointer 
growth rate calculations pessimistic shadowing strategy tree height calculated assuming keys inserted worst case order ascending values 
ascending order leaves maximum amount unused free space index forces tree grow fastest rate 
trees grew slowly curves relationship shaded regions area steps occur larger tree sizes 
page size kbytes analysis default postgres 
shows overhead shadow trees lower impact key size increases 
height difference capacity trees storing byte keys smaller difference storing byte keys 
space consumed internal pages causes reduction fanout eventually causes greater tree height smaller capacities 
reduction fanout caused shadowing function ratio overhead key size 
larger keys proportionally overhead chapter 
supporting indices postgres storage system keys number height normal byte shadow byte normal byte shadow byte height tree different size trees 
chapter 
supporting indices postgres storage system show proportionally smaller reduction fanout 
practice space overhead shadow index usually affect tree height key size small 
small trees levels internal pages overhead negligible 
heights link trees levels coincide tree sizes height impact shadowing minimal 
intermediate height shadow tree stable non coincident values running reorganization utility redistribute free space reduce height index level normal tree 
significant height differences masked reorganization arise keys small tree levels 
worst case insertion order link tree type storing byte keys exceed gbyte maximum size unix file reached levels 
measurements postgres link tree implementation measure performance shadow page reorganization index implementations ran tests type index 
test built indices different sizes byte keys 
calculations previous subsection measurements give worst case performance keys added ascending order order give largest number page splits greatest tree height 
second test retrieved random keys index created insertion test 
keys uniformly distributed range represented index 
measurements decstation running ultrix postgres 
chapter 
supporting indices postgres storage system operation size index keys tree type inserts normal page reorg shadow lookups normal page reorg shadow table insert lookup performance comparison 
chapter 
supporting indices postgres storage system times shown table mean elapsed times repetitions test 
standard deviation set measurements mean 
entry table includes parentheses normalized time test 
normalized time calculated dividing elapsed time test elapsed time conventional tree 
example shadow tree normalized read time percent slower conventional tree workload 
time spent link tree access method routines calls reported table 
includes cost reading writing index pages operating system cache include cost committing transactions 
commit cost depend logging scheme chosen 
results show shadow algorithm percent cost ordinary link trees insertions 
higher cost due added expense verifying inter page links traversing tree 
reads shadow tree percentages half percent worse ordinary link trees 
measurements show cpu costs algorithm account extra necessary shadow tree higher normal tree 
cases shown heights shadow tree normalized tree 
ranges shadow tree higher normal tree shadow lookup pay additional costs page reorganization algorithm similar 
reads percent expensive normal tree 
page reorganization insertions expensive percent higher cost insertions chapter 
supporting indices postgres storage system ordinary link tree 
extra done order data old pages splits page reorganization 
noted chapter page reorganization best suited environments low insertion rates 
cost index management strategy small workloads dbms spends little time index access methods 
example wisconsin benchmark postgres spends percent time indexed access methods 
debit credit benchmark int chapter spends percent time index access methods 
percent worst performance degradation smaller measurement error benchmark 
estimating additional costs recovery postgres index management techniques workload dependent costs measured dissertation 
normal case postgres tree page split conventional tree page split require pages written disk parent child 
page reorganization tree force synchronous page write index page splits twice transaction 
keys bytes long pages kbytes inserting keys worst case order single transaction cause additional synchronous write 
workload related cost occurs time keys inserted page reorganization tree link tree pages failure 
trees inserting key page requires dbms read additional pages determine chapter 
supporting indices postgres storage system page split created committed 
example page split occurs page reorganization tree duplicate keys reorganized page overwritten peer page definitely written stable storage 
time key inserted page split committed page marked cleared key insertions consider state peer 
failure occurred split comparing sync token page global sync counter provides information examining peer 
key insertion reorganized page occurs failure peer read examined ensure token reorganized page larger token 
key insertion link tree page occurs failure dbms check page linked peer pointer path explained section 
extra done key inserted page split created page 
workload measurements difficult determine exactly additional occur situations practice 
assume key values drawn uniform distribution estimate number pages untouched time crash 
estimate number pages extra os required simulated construction trees randomly selected size averaging random valued byte keys sigma 
level trees pages 
average pages untouched page split 
additional rarely required 
simulating trees byte chapter 
supporting indices postgres storage system keys average untouched pages recovered 
pages encountered key insertions extra recovery limited effect performance 
summary postgres dbms relies overwrite storage system avoid log processing recovery 
avoiding log processing postgres recovers failures quickly eliminates great deal complex recovery code data managers 
unfortunately concurrency requirements inter page pointers postgres storage system techniques difficult apply index data structures link trees 
chapter techniques managing indices write ahead log processing usual overwrite techniques postgres storage system 
technique shadow paging second page reorganization splits 
algorithms redundant information index pages detect inconsistencies caused system failures encountered 
inconsistencies removed repeating interrupted page split merge operations 
techniques useful wal data managers want avoid physical logging page splits 
measurements prototype implementation suggest algorithms little effect data manager performance 
performance measurements show key chapter 
supporting indices postgres storage system inserts lookups percent slower tree entirely main memory 
estimates effect algorithm tree height show key lookups shadow page link trees read page disk lookups conventional link trees workloads 
height estimates performance measurements indicate hybrid algorithms reduce costs preserving best features algorithm 
shadow paging near leaf pages eliminate cost page reorganization splits part tree splits common 
page reorganization nearer root reduce space overhead caused internal pages significantly increase fanout 
chapter days users simply accepted computer systems go hours minutes rapidly drawing close 
fault tolerance longer specialty service required military systems hospitals banks stock exchanges 
trends prices non volatile ram nvram hardware reliability reduced costs hardware components fault tolerant systems 
advances operator interfaces maintenance fault tolerant systems probably enter mainstream systems soon 
lead widely available reasonably priced conventional systems mask hardware errors power outages 
tools administer systems prevent eliminate operator maintenance errors 
order modern systems remain reliable available long periods time run reliable system software 
careful software engineering help somewhat software complex software failures chapter 
occur 
face failures fault tolerant system able halt produce incorrect results 
halted system recover quickly hopefully interrupting people system 
regeneration lost program state fast mask failures users system eliminate temptation system designers build complex unreliable recovery systems 
dissertation examined software fault tolerance problem standpoint database management systems 
addressed problems faced designers fault tolerant software 
analyzed data software errors uncovered commercial systems order help characterize software errors 
second described evaluated technique detecting addressing errors controlling error propagation cause 
extended postgres fast recovery feature improve day performance high update rate environments handle fast recovery communication state index data structures 
data commercial systems programs chapter assessed root causes software outage 
proposed model errors different kinds error propagation control addressing data errors 
studies mvs operating system ims database manager db database manager showed distribution kinds errors similar systems 
control errors half errors addressing errors data errors rest miscellaneous 
chapter showed programs lost point control largely due forgotten error conditions unanticipated program events 
addressing errors memory chapter 
management necessarily bad pointers 
addressing errors higher average customer impact probably error propagation difficult diagnose correct 
data chapter showed addressing errors small affected working data structures data structures far away point control 
repeatable errors relatively common 
fact combined difficulty designing primary backup communication protocols ill common redundancy software fault tolerance techniques 
chapter evaluated models page guarding technique uses conventional virtual memory hardware limit propagation addressing errors 
models differed manner dbms specified legitimate updates data offering different protection cost tradeoffs 
implementation decstation showed eleven percent impact protecting buffer pool update intensive mainmemory database percent impact database disk os considered 
chapter indicated kinds wild pointer errors easily detected guarding uncommon errors hardest find fix conventional debugging techniques 
important error detection ability guarding techniques help eliminate set errors affect data cached main memory differently data written disk 
guarded version postgres primary reliability difference data disk data cached main memory data structures manage resources different subject different software errors 
chapter 
chapters attacked system availability problem extending postgres dbms fast recovery features ways 
original postgres storage system design dbms optimized fast restart fast commit order improve system availability 
chapter described enhancements postgres storage system reduce cost high update rate environment 
enhancements include backward differencing new strategy handling overflow pages access current database fast database contains great deal historical data 
performance analysis chapter suggests enhancements postgres amount conventional dbms sufficient amount non volatile ram available log structured file system lfs postgres historical data feature disabled 
historical data enabled analysis shows postgres percent chapter showed changes transaction status file eliminate examination file system restart 
database remains unavailable clients connected dbms chapter added postgres techniques quickly recovering communication clients dbms server 
chapter extended postgres storage system handle index data structures write ahead log 
described index management techniques shadow pages page reorganization 
postgres fault tolerance strategy anticipate technology shifts faster processors non volatile ram assume new hardware chapter 
mask performance impact simpler recovery strategies additional error detection 
non volatile ram postgres storage system possible softening performance impact force commit buffer management 
faster processors mean additional processing costs associated guarding postgres demand database recovery little noticed customers 
faster processors mean routines recovery normal processing limited effects performance 
important reliability implications example index management code code recovery time continually tested normal processing just recovery time 
providing availability long running queries recovery model discussed dissertation considered dbms available new transactions initiated data 
consider cost discarding done uncommitted transactions 
high update rate short transaction environment current postgres model works 
forcing clients simply resubmit failed transactions worthwhile complexity availability tradeoff 
dbms long running complex queries restarting query failure may unacceptable 
complex queries run minutes hours high performance system 
dbms fails frequently relative query execution chapter 
time users may able progress database available users submit new queries moment notice 
provide high availability long running queries postgres checkpoint intermediate state current state query plan temporary relations 
current commercial systems limit rollback long running transactions record updates long running transaction 
complex query checkpoint mechanism record intermediate state read transactions record dbms data structures addition database changes 
mechanism require tunable parameter set frequency checkpoints taken 
additional open question design system determining restore phase locks associated query 
fast recovery main memory database manager important disadvantage postgres storage system reliance force commit strategy managing buffers 
raid lfs nvram minimize disadvantage cost magnetic disk stable storage significant cost today systems 
obviously database management systems designed reside main memory disk eliminate concerns related force commit 
postgres nvram lessen commit costs designed disk database 
example care taken previous current tuple versions reside disk page reduce os required recovery index scans 
chapter 
nvram prices approach conventional main memory idea maintaining main memory large safely store entire database practical 
system maintain high reliability availability variations page guarding postgres fast recovery techniques 
database organized probably single append log facilitate page guarding tail log unguarded 
indexing strategies changed structures trees designed speedy access data disk 
garbage collection strategies closer log structured file system ones described dissertation 
storage system conventional write ahead log log contains actual data values just undo redo information recovery 
fast main memory database management system require kind checkpointing mechanism order provide media recovery 
automatic code error check generation control error problem ims programmers missing case considering error condition timing condition arise 
software engineering tools track error conditions handled helpful 
especially true program maintenance 
change team repairs software error discovered field may understand change affects rest program control flow 
regression testing show error chapter 
conditions handled previously handled bug fix 
older programs ims significant fraction software errors come program maintenance 
software engineering tools helped show small modifications code affect program control flow helpful 
db small number false error detections occurred program changed assert statements designed detect bad internal state 
software engineers help alleviate problem designing tools generate assert statements flag assert statements affected code changed 
solution requires programmers surface error prone 
programmers supposed think assert statements 
assert statements generated automatically incorrect data structures generate incorrect assert statements 
high level languages dissertation assumed current generation low level systems languages remain popular system designers 
languages probably go away conceivable fault tolerant system designers switch languages debugging anti features ones construct postgres systems studied chapter 
important area examine error characteristics languages hermes modula higher degrees type safety current languages 
addressing related errors catalogued chapter involved errors memory chapter 
management unsafe pointer operations errors type coercion union type problems languages designed prevent 
knowledge detailed error studies systems programs written languages exist 
interesting find languages additional classes errors conventional programming languages 
programming language ada built exception handling facility 
seen errors systems programs result error conditions 
large ada programs exist study error reports language especially users exception handling code interesting 
study useful designers software engineering tools help programmers write code handle errors 
bibliography appel li 
virtual memory primitives user programs 
proceedings th international conference architectural support programming languages operating systems april 
auslander larkin 
evolution mvs 
ibm journal research development september 
avizienis 
version approach fault tolerant software 
ieee transactions software engineering se december 
mary baker satoshi etienne john ousterhout margo seltzer 
nonvolatile memory fast reliable file systems 
proceedings th international conference architectural support programming languages operating systems october 
mary baker mark sullivan 
recovery box fast recovery provide high availability unix environment 
proceedings summer usenix conference june 
bibliography kim kim korth 
semantics implementation scheme evolution object oriented databases 
proceedings sigmod conference pages december 
bartlett 
nonstop kernel 
proceedings th symposium operating system principles 
basili 
software errors complexity empirical investigation 
communications acm 
bayer mccreight 
organization maintenance large ordered indexes 
acta informatica 
bershad anderson lazowska levy 
lightweight remote procedure call 
proceedings th symposium operating system principles pages december 
elnozahy morgan 
implicit replication network file server 
ieee workshop management replicated data november 
bitton dewitt 
benchmarking database systems systematic approach 
proceedings large data bases conference november 
borg blau oberle 
fault tolerance unix 
acm transactions computer systems february 
bibliography carey dewitt frank graefe shekita 
architecture exodus extensible dbms 
proc ieee international object oriented systems september 
castillo siewiorek 
workload performance reliability digital computing systems 
digest th international symposium fault tolerant computing 
chang mergen 
storage architecture programming 
acm transactions computer systems february 
cheng 
virtual address cache unix 
proceedings summer usenix conference 
comer 
ubiquitous tree 
acm computing surveys 
comer 
internetworking tcp ip 
prentice hall englewood cliffs new jersey 
dewitt katz olken shapiro stonebraker wood 
implementation techniques main memory database systems 
proceedings sigmod conference june 
efron tibshirani 
bootstrap methods standard errors confidence intervals statistical accuracy 
statistical science 
bibliography ellis 
annotated manual 
addison wesley 
du 
dynamic hashing schemes 
acm computing surveys june 
endres 
analysis errors causes system programs 
ieee transactions software engineering 
eswaran gray lorie traiger 
notions consistency predicate locks database system 
communications acm november 
anon measure transaction processing power 
technical report tandem january 
fagin pippenger strong 
extensible hashing method dynamic hashing 
acm transactions database systems september 
glass 
persistent software errors 
ieee transactions software engineering se march 
gray 
computers fail done 
proc 
th symposium reliability distributed software database systems 
bibliography gray 
census tandem system availability 
ieee transactions reliability october 
gray mcjones lindsay lorie price traiger 
recovery manager system database manager 
acm computing surveys june 
gupta 
fresh look optimizing array bounds checking 
proc acm sigplan notices conference programming language design implementation pages june 
guttman 
trees dynamic index structure spatial searching 
proceedings sigmod conference pages 
reuter 
principles transaction oriented recovery 
acm computing surveys 
harbison 
modula 
prentice hall englewood cliffs new jersey 
ibm 
mvs extended architecture overview publication number gc edition 
ibm 
ms vs extended recovery facility technical 
barnes krieg bruckner 
preliminary ada manual 
sigplan notices june 
bibliography iyer 
effect system workload operating system reliability study ibm 
ieee transactions software engineering se december 

integrity fault tolerant unix platform field failures operating systems 
digest st international symposium fault tolerant computing june 
gerry kane 
risc architecture 
prentice hall englewood cliffs new jersey 
kim 
highly available systems database applications 
acm computing surveys march 
knight st jean 
large scale experiment version programming 
digest th international symposium fault tolerant computing 
knuth 
errors tex software practice experience july 

indexing techniques multi dimensional spatial data historical data database management systems 
phd thesis university california berkeley eecs department computer science division 
ucb erl tr 
lampson redell 
processes monitors mesa 
communications acm february 
bibliography shasha 
symmetric concurrent tree algorithm 
proceedings fall joint computer conference pages 
lehman yao 
efficient locking concurrent operations trees 
acm transactions database systems december 

defects reliability analysis large software systems field experience 
digest th international symposium fault tolerant computing june 
levy lipman 
virtual memory management vax vms operating system 
ieee computer march 
liskov ghemawat gruber johnson shrira williams 
replication harp file system 
proceedings th symposium operating system principles october 
witold litwin 
linear hashing new tool file table addressing 
proceedings large data bases conference 
lorie 
physical integrity large segmented database 
acm transactions database systems march 

dynamic crash recovery balanced trees 
proceedings reliability distributed software database systems pages july 
bibliography mohan lindsay pirahesh schwarz 
aries transaction recovery method supporting fine granularity locking partial rollbacks logging 
acm transactions database systems march 
mohan levine 
aries im efficient high concurrency index management method write ahead logging 
technical report rj ibm 
morgan taylor 
survey methods achieving reliable software 
ieee computer february 
mourad andrews 
reliability ibm mvs xa operating system 
ieee transactions software engineering se october 
olson 
extending postgres database system manage tertiary storage 
master thesis university california berkeley eecs department computer science division may 
ousterhout douglis nelson welch 
sprite network operating system 
ieee computer february 
patterson gibson katz 
case redundant arrays inexpensive disks raid 
proceedings sigmod conference june 
randell 
system structure software fault tolerance 
ieee transactions software engineering se june 
bibliography rosenblum ousterhout 
design implementation log structured file system 
proceedings th symposium operating system principles pages october 
schroeder saltzer 
hardware architecture implementing protection rings 
communications acm march 
seltzer 
file system performance transaction support 
phd thesis university california berkeley eecs department computer science division 
seltzer 
new hashing package unix 
proceedings winter usenix conference january 
leveson 
empirical comparison software fault tolerance fault elimination 
ieee transactions software engineering se february 
srinivasan carey 
performance tree concurrency control algorithms 
proceedings sigmod conference pages june 
stonebraker 
postgres storage system 
proceedings large data bases conference pages september 
stonebraker rowe 
design postgres 
proceedings sigmod conference june 
bibliography robert strom david bacon arthur goldberg andy lowry daniel yellin alexander yemini 
hermes language distributed computing 
series innovative technology 
prentice hall 
isbn 
sullivan 
software errors reported bsd unix 
unpublished notes survey bsd error report database 
sullivan chillarege 
software defects impact system availability study field failures operating systems 
digest st international symposium fault tolerant computing june 
sullivan chillarege 
comparison software defects database management systems operating systems 
digest nd international symposium fault tolerant computing july 
sullivan olson 
index implementation supporting fast recovery postgres storage system 
technical report university california berkeley 
taylor morgan black 
redundancy data structures improving software fault tolerance 
ieee transactions software engineering se may 
thayer nelson 
software reliability 
trw north holland publishing 
bibliography tso avizienis 
community error recovery version software design study experimentation 
digest th international symposium fault tolerant computing 
velardi iyer 
study software failures recovery mvs operating system 
ieee transactions computers june 
webber 
architecture 
digest st international symposium fault tolerant computing june 
wulf 
reliable hardware software architecture 
ieee transactions software engineering se june 
wulf cohen jones levin pierson pollack 
hydra kernel multiprocessor operating system 
communications acm june 
young tevanian rashid golub chew bolosky black baron 
duality memory communication implementation multiprocessor operating system 
proceedings th symposium operating system principles pages december 
