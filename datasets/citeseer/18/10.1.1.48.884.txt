design modelling parallel data server telecom applications mikael ericsson ab ericsson ab rights reserved reason thesis written inspiration lord possible conclude constant flow inspiration lord 
inspired church jesus christ day helped find balance life family church activities research 
constant support wife marianne love worthwhile perform 
am grateful ericsson telecom ab ericsson ab especially department manager ran vision importance databases telecom network section managers martin jan hans department manager klaus time granted 
economic support possible 
large part performed race monet race projects 
am grateful advisor professor tore risch department computer information science link ping university professor anders mathematical statistics institution university stockholm 
provided help inspiration deserve mentioning olaf telenor research trondheim lars royal institute technology stockholm mats thomas muth ericsson 
different dbms design teams ericsson provided ideas helpful 
master thesis students worked part research larsson malik daniel johansson bj rn patrik johansson arne eriksson larsson andersson christer worthy mention 
daniel andreas contributed parts research 
david jakobsson valuable contribution structure tuple storage 
help number students 
mother helped take steps life father taught reach stars satisfied reach 
am grateful sister ann charlotte oden illustration cover family living dead dedicate 
ii telecom databases databases operation telecom network parts applications telecom network 
telecom databases service control points scp intelligent networks 
provided number translations various services 
databases keep track mobile phones home location registers hlr mobile telecommunications early starters 
platforms service execution telecommunication services 
telecom databases management network especially real time charging information 
information servers web servers cache servers mail servers file servers part telecom databases 
servers common answer massive amounts simple queries reliable requirements short response times 
need large storage needs send large amounts data users 
requirements telecom applications architecture parallel data server developed 
architecture contains new ideas replication architecture phase commit protocols extension concept writing main memories writing disk commit 
phase commit protocol integrated protocol supports network redundancy replication clusters 
ideas described linear hashing trees data structure tuple storage provides efficient logging 
shown data server handle types reconfiguration recovery activities system line 
advanced support line schema change developed 
includes support splitting merging tables service interruption 
ideas represent architecture parallel data server provides non operation 
distribution transparent application important designing load control algorithms applications data server 
parallel data server opens new usage area databases 
telecom applications traditionally seen area proprietary solutions 
achieved performance reliability response time data server thesis possible databases new telecom applications 


ii 

research method 
application study 
requirements architecture telecom databases 
reliability 
performance 
delays 
storage types 
object orientation 
triggers 
indexing 
persistent locks 
counters 
complex queries 
create tables 
major features parallel telecom data server 
technical study 
summary contributions 
system design 
thesis outline 
ii applications telecom databases 
applications characteristics 
telecom applications 
service network 
information network 
charging network 
mobile telecommunications 
conceptual schema umts 
umts procedures 
session management 
user registration management 
attach detach 
call handling 
handover 
location update 
advice charge 
service profile management 
umts characteristics 

news demand 
news demand characteristics 
multimedia email 
multimedia email characteristics 
event data services 
umts event records 
news demand event records 
email event records 
characteristics event data service 
genealogy application 
conceptual schema 
traffic model 
transactions types 
reliability availability telecom databases 
definitions 
empirical studies 
module failure rates 
hardware approaches 
software approaches 
transaction availability 

architecture telecom databases 
telecom database benchmarks 
formal benchmark definitions 
umts benchmark 
data definition 
full scale benchmark definition 
simple umts benchmark definition 
table look benchmark 
data definition 
full scale benchmark definition 
small scale benchmark definition 
news demand benchmark 
data definition 
benchmark definition 
email server benchmark 
data definition 
full scale benchmark definition 
simple email benchmark definition 
charging database benchmark 
data definition 
full scale benchmark definition 
small scale benchmark definition 
telecom database benchmark 
part 

iii architecture parallel data server 
basic architectural decisions 
parallel database architectures 
shared memory 
shared disk 
shared 
hybrid architectures 

client server technology 

server architecture 
session database 
network redundancy 
interface types 
interface data server 
interface query server 
interface internal network 
interface external networks 
interface application servers 
interface management servers 
transaction concepts 
flat transactions 
flat transaction 
distributed transactions 
replica handling distributed transactions 

theory concurrency control 
transaction dependencies 
locking theory 
degrees isolation 
isolation concepts 

log handling 
log information 
log handling distributed systems 

phase commit 
transfer commit 
read commit optimisation 
linear commit optimisation 
non blocking commit coordinator 

archive copy production 
system architecture parallel data server 
replication structure 
local replication structure 
global replication structure 
local fragment states 
related 

reconfiguration recovery protocols relation information parallel database 
replication information 
handling node failures 
handling system failures 
handling add node 
handling drop node 
handling time events 
handling overload events 
handling schema changes 
protocols 
schema definition 
tuple keys 
schema entities 
fragmentation tables 
distributed indexes 
secondary indexes 
related 
user transaction protocols 
normal commit phase handling 
tpc transaction 
simple write optimisations 
handling node failures commit phase 
failure data node 
failure transaction coordinator 
special error situations 
handling prepare commit requests application 
referential integrity secondary indexes 
update secondary index 
referential constraint 
related 
read queries 
simple read transactions 
read transactions 
related 

line recovery reorganisation protocols 
basic protocols 
am alive protocol 
state transition protocol 
node fail protocol 
copy fragment protocol 
create global checkpoint protocol 
replica handling protocols 
promote backup replica primary replica 
create backup replica 
create stand replica 
switch primary replica backup replica 
start node protocol 
create dictionary information 
create distribution information 
join split fragment 
split algorithm 
join algorithm 
split join coordinator 
node failures split join process 
related 
protocols implement global replication 
protocol telecom databases 
adaption transaction protocols global replication 
commit phase primary system 
transaction handling backup system 

handling processor node failures global replication 
handling node failures backup system 
handling failure transaction coordinator backup system 
failure primary replica primary system 
failure primary replica backup system 
failure primary replica primary backup system 
global recovery protocols 
restart backup system primary system 
promote backup system primary system 
switch primary system backup system 
related 
crash recovery protocols 
system restart 
find global checkpoint restart 
restore schema information 
restore fragment information 
schema information crash recovery 
archive copies 
restarting fragment 
handling logical fragment redo log 
creating backup replica stand replica restarting fragment production local checkpoint 
local logging method 
method 
primary log node failure 
backup log node failure 
global system checkpoint 
related 
schema changes 
concepts schema changes 
soft hard schema changes 
simple complex schema change 
simple complex conversion function 
summary 
handling schema changes 
schema version 
reading schema information user transactions 
execution simple schema change 
simple schema changes 
table operations 
attribute operations 
index operations 
foreign key operations 
complex schema changes 
general approach 
change attributes 
add index 
split table 
vertical split table 
merge tables 
vertical merge tables 
schema changes backup system 
schema information backup system 
log channel schema information 
simple schema changes 
complex schema changes 
remarks 
related 

new variant lh lh 
handling hash value bits 
data structure lh 
copy fragment protocol 
alternative solutions 
algorithm descriptions 
detailed data description 
container data 
element data 
page memory handling 
element split containers 
overflow handling 
split join handling 
local bucket split join 
fragment split join 
lock handling 
secondary indexes 
unique secondary index 
non unique secondary index 
handling physiological undo log 

compressed distributed tree tree 
compressed tree long names 
searching tree 
memory handling 
split merge tree fragments 
copy tree fragment 
node data structure 
handling physiological undo log 
related 

data structure tuple storage 
recovery support tuple storage 
copy tuple parts 
data structure tuple 
structure tuple header 
support various data types tuple 
page structure 
page identifiers 
disk attributes main memory attributes 
handling undo log 
changes tuple structures 
special handling large attributes 
related 

modelling parallel data server 
computer architecture performance modelling 
performance comparisons 
performance line recovery 
performance crash recovery 

iv 
summary 
related 
achievements thesis 
part 
part 

abbreviations 
glossary 

ericsson ab rights reserved aim research study dbms telecom databases 
times text thesis dbms referred telecom database 
definition telecom databases thesis data storage nodes operation telecom network applications part telecom network 
research method research thesis started general objective find ways build efficient database servers current telecom applications 
efficient storing searching reading data 
decided focus research 
find research focus items started 
application study beneficial understand requirements telecom databases 
second technical study understand current systems major bottlenecks 
result studies actual research performed 
started development essential algorithms needed databases high reliability 
development algorithms platform developed 
developing essential algorithms system architecture developed 
currently platform developed system architecture algorithms developed thesis 
application study large part application study performed participating race project called monet 
project objective perform pre standard research build third generation systems umts 
main databases project service control points handles services locations authentication users 
studies performed real time charging applications information services 
area difficult acquire estimates databases 
reason uncertainty applications 
idea perform information services reflect current mail tv newspapers radio forth 
evident application study requirements high reliability response times order ms needed 
application study converted set benchmarks reflect number important telecom applications 
requirements architecture telecom databases study various applications telecom databases draw certain requirements telecom database 
reliability availability class telecom databases 
means unavailability seconds year 
means planned downtime system allowed 
performance typical performance requirements telecom databases requests second 
requests write read single record 
applications need network redundancy handle earthquakes catastrophes 
delays short delay read operations particularly crucial write operations short delays 
typical delay requirements ms 
impact delay requirement disk writes transactions 
means availability requirements handled way 
thesis study method main memories ensure high availability 
probability processor nodes failing time small 
general power failures handled battery backups ensure log information sent disk battery runs energy 
storage types data studied kept main memory 
applications great needs larger data sets need disks need form data box 
disk storage needed documents demand application email bodies attached files set scanned objects genealogy application 
examples blobs 
furthermore necessary store event records disk 
exception applications small tuples need stored disk 
blobs attributes obviously possible separate attributes stored main memory attributes stored disk table 
solution blobs stored special blob table stored disk 
main memory data email server genealogy application news demand application 
cases store control structures indexes descriptive information blobs 
requirement charging database possibility insert tuple main memory specifying move disk time timer specific request 
achieved insert main memory table followed delete insert disk table 
object orientation charging database genealogy database draw requirements object oriented databases relevant 
need possibility perform queries tables contains types objects common base class 
need methods class attributes 
genealogy database needs complex data structures provided object oriented model 
primary keys table application key telephone number object identifier 
triggers applications need informed relevant events take place database 
means support trigger mechanism included 
simplify application development support referential integrity constraints automatically maintained 
indexing support indexes needed especially indexes various telecom addresses addresses file names 
primary indexes secondary indexes needed 
persistent locks study application telecom database cache server www joh requirements persistent locks 
problem application needs lock tuples longer time transaction 
means database able handle locks tuples involved transactions 
locks persistent crashes 
counters cache server needs maintain persistent counters needed applications 
important counters handled normal concurrency control protocol 
create hotspot degrade performance 
complex queries support complex queries important aspects 
charging database require 
charging database benefit updated concurrency control large queries problem 
create tables noted disk applications create applications 
deletes occur usually tables large parts table deleted time 
simplify recovery transaction handling applications 
major features parallel telecom data server requirements lead significant features telecom database scalability telecommunication systems small users large users 
database telecommunication applications scalable upwards downwards 
scalability downwards achieved portability various platforms 
covered thesis aim distributed real time run time system described 
data server described thesis implemented portable run time system data server portable runtime system security different kinds catastrophes times catastrophes earthquakes storms forth important telecommunication network fail 
database system telecommunication applications secure different kinds catastrophes 
high availability telecommunication network available 
lost telephone call serious matter 
databases centralised crucial high level availability 
high reliability transactions committed lost 
transaction critical operator lost 
users telecom network accept system forgets transactions 
load regulation overload control telecom networks built assumption subscribers active time 
means overload situations occur 
important databases scheme handle overload situations 
covered thesis item 
openness discussed thesis certainly important requirement 
necessary able reuse code tools platforms forth developed enable quick development new services 
technical study technical study consisted finding bottlenecks computer communication systems find solutions overcome 
bottlenecks may occur design system 
occur software parts code data usage utilisation cache memories bad 
problems instruction caches instructions dbms fit cache memories 
operating system bottleneck wrong way 
overhead switch processes disk handling communication handling easily main source performance bottlenecks 
dbms executing tpc tpc benchmarks shown spend time executing operating system 
bottlenecks occur electronic systems packaging due insufficient number pins package high delays communications printed wiring board 
find solutions problems necessary study software optimisations data structures cache memories careful manner ways achieve better usage instruction caches 
avoid excessive usage operating system important feature 
parts studied initially research 
major bottlenecks excessive usage operating system communication processes operating system 
excessive usage communication protocols implemented operating system software 
excessive usage disk implemented operating system software 
bad behaviour instruction caches 
bad behaviour data caches 
excessive disk writes update transactions 
interesting observation major problems dbmss 
major bottlenecks heavy operating system services 
operating systems designed databases prime application 
new result stonebraker 
result observation platform development started 
reported thesis 
main idea platform development build platform database database developed modular structure interfering operating system absolutely needed 
platform development solves problems items attacked 
currently products provide possibility handle 
bottleneck covered development new index structures development data structure tuple storage reported thesis 
bottleneck covered development new phase commit protocol 
solution bottleneck inspired development stand replica reported thesis 
requirements high reliability dbmss application study number open research areas 
reliability support dbms important research item covered thesis 
requirement response time application study handled platform development 
hardware development particular processor development progressing rapid speed 
bottleneck included research 
area mainly studied find parameters performance modelling telecom databases 
hardware development effect software design important study area 
summary contributions major results new data structure pages possible avoid logging logical undo parts sacrificing flexibility writing pages disk 
uses fact action consistent checkpoint produced copy changed parts saved tuple storage undo information 
reliability extreme situations level replication scheme developed 
level replication machines located physical vicinity 
second level systems located large distance 
king provided input 
major new integrate algorithms king new phase commit algorithm efficient manner 
proposed handling replication consistency system systems flexible differ attribute level 
example covered thesis algorithm line schema changes 
algorithm possible split merge tables vertically stopping system 
changes maintained levels replication 
shown changes occur presence foreign keys tables split merged 
new indexing technique lh developed extends earlier scalable data structures especially lh litwin lh litwin lh lh karl 
lh lh lh distributed data structures modified exist environment replication transactions 
new compressed distributed tree developed 
assumption cheap communication cost achieved new technological development consequences system architecture set new ideas developed thesis transaction protocols replication strategies 
research thesis focuses development reliable distributed dbms 
research earlier research distributed databases extended number ideas research nth trondheim olaf prof 
algorithm developed trondheim inspiration developing new transaction protocol 
removes need flush log buffer disk commit making possible handle updates second 
system design step thesis ideas design 
started 
design consists platform development axe virtual machine development ndb cluster parallel data server telecom applications 
thesis outline chapter describes set telecom applications databases 
includes study reliability availability requirements 
chapter contains set benchmarks developed application descriptions chapter 
chapter contains explanation basic concepts decisions underly algorithms developed thesis 
example decision hybrid shared model 
includes explanations databases applications currently 
chapter describes system architecture 
includes description replication structure description protocols database relate discussion schema entities handled 
includes new result area replication structure 
stand replica introduced able handle multiple failures cheaply 
chapter describes new phase commit protocol protocols handling reads updates indexes forth 
chapter describes number protocols needed line recovery reorganisation database 
includes automatic creation new replicas node failures automatic fragment split merge nodes added removed 
ideas chamb 
chapter describes support network redundancy conjunction new phase commit protocol 
ideas king 
chapter describes crash recovery protocols 
chapter describes handle line schema changes 
introduces soft schema change previously reported conjunction software change 
extends possibilities line schema changes handle split merge tables 
results section new 
chapter describes extension lh litwin lh litwin lh lh karl lh index 
shown index integrated handling replicas provides cache misses accessing index data 
chapter describes new compressed distributed tree tree 
useful storing indexes file names addresses telephone numbers forth 
ideas developed bayer 
method favourable processors capability process hundreds instructions time accessing buffer main memory 
chapter describes data structure tuple storage 
tuple storage pages enable structure handles main memory disk data 
main memory data faster access pages fast page index 
shown ideas main memory databases avoid logical undo log 
chapter reports simulations new phase commit protocol new replica structure 
parameters simulations early design effort ndb cluster 
chapter reports related 
ii applications telecom databases aim part understand requirements applications put telecom databases 
find information necessary investigate possible applications 
necessary predictions services manner 
investigation load telecom databases deduced 
knowledge great value designing telecom database analysing performance design 
characteristics applications described part studied 
traffic models derived traffic models flow requests telecom databases estimated 
requirements telecom databases 
findings go define suit benchmarks telecom databases 
major difficulty finding requirements information services new applications 
course email example long time 
private persons email transfer multimedia files 
requirements services drawn extrapolations way currently similar services ordinary mail newspapers television news radio news 
ericsson ab rights reserved applications characteristics application studied thesis mobile telecom services new information services 
services need line billing services 
necessary enable payment electronic world informed price services realtime 
services telecom databases described services describe database behaviour conceptual schema application details works 
doing better understand database structured data types needs support types interaction optimised 
telecom applications step finding characteristics application look network architecture telecom databases part 
generic network architecture telecom network shown 
access network access network fixed terminals access network mobile terminals 
access network structure complex issue thesis 
communication network connects various access networks 
highly complex different types transport networks pdh digital sdh synchronous digital hierarchy transport network 
top transport network atm network circuit switched connections ip network packet switched networks circuit switched networks 
communication network routing servers assist routing name servers translate addresses various networks 
name servers translate logical names physical names inside network 
service network assists providing communication services users 
service network logical network 
means contains number nodes connected communication network 
basically nodes network telecom databases 
email servers service control points home location registers directory servers 
charging network similar network contains special type telecom databases providing charging services event data services 
services nodes telecom network various external systems network planning market research 
information servers connected directly communication network access network 
nodes provide information services communication services telecom network 
example physical network architecture provided show details access network transport network 
user connected mobile terminal fixed terminal 
local info server represents info server provided part network operators services subscribers 
service include email personal homepages www storage function store personal files applications provided network operator 
mobile users server situated connection hlr 
local info servers placed network furthermore necessary service provided network operator 
gateway atm ip network shown 
routing name server support gateway function 
service network telecom databases provide services network common service comprises various kinds address translation services 
important type service directory services possible translate user name user address directories available services telecom network essential service information network 
number portability networks telephone numbers fixed telephones connected particular local exchange easy route calls mapping number physical location telephone 
create problems operator meets problems necessary change network configuration customer change number permanently moves away area local exchange 
prevents subscribers keeping numbers change operator 
solve problem operators going numbers portable 
eu requirement operators 
means number longer connected physical location subscriber 
contain directions subscriber resides country code area code 
option numbering schemes global number scheme country code 
generic network architecture aau nt dir email home service local transit local bs base communication network service network charging data network info info network info network fixed access mobile access network network route server name server server server charging data base charging data base charging data base info server location register control point station controller exchange exchange exchange ip router ip router ip router ericsson ab rights reserved possible scheme involving number translation needed 
routing principles telecom network necessary numbers tied physical locations 
numbers routing network number portable number 
point number translated number network routing 
proposals implement network kind intelligent network solution local exchange sends translation request scp service control point number translated 
technique today services numbers 
particular service uses telecom database reading request simple table look ups 
high number necessary translate calling number called number telephone call consists requests telecom database 
number updates small necessary update operator changes structure network subscriber permanently moves necessary change routing number 
requirements reliability high function necessary network operate 
conceptual schema service simple basically contains numbers 
table numbers stored queries translate number look select network number number table user number user number bs nt bsc aau aau le msc atm transit atm international atm local info server ip router info server news server scp hlr routing name server charging database local info server example physical network architecture new index structures developed thesis useful particular query 
optimised speed uses hash structure 
optimised memory usage uses compressed tree structure 
routing server currently routing decisions taken control processor switches routers 
necessary common operation requires information date network performance 
required distributed routing algorithms 
capabilities telecom databases increase possible put routing control telecom databases database course part switch router 
requires telecom database updated frequently network performance 
switches routers ask routing server information route calls messages performed call call basis periodic basis 
internet exist specific routing protocols specify router routing table 
router normally routing protocols inform neighbours destinations serve moment 
updating performed seconds 
routing server common actions 
routing decision involve number retrievals records routing table 
second periodically update routing table new information 
actions occur concurrently need examine concurrency control 
possible routing decisions routing table updated version scheme needed 
simply keep copies switch routing table update solution sure reading performed consistent copy routing table implemented multi version concurrency scheme 
service requires extensive updates reads 
updates routing server need reliable cases 
routing data perfectly consistent routing server performs updates independently routing servers 
routing server find ip address internet erroneous routing decisions quickly recovered routers 
name server name server functionality translating logical addresses physical addresses number portability case translating address network address network 
example user telephone number email address ip address atm address 
passing gateways networks necessary translate addresses 
example translating logical physical addresses translation urn address address www logical address needs translated 
url address specifies physical location message directed fetch file specific directory specific machine www 
example translating different networks ip message sent 
ip destination address find atm destination address final destination gateway node 
service uses telecom database simple table look ups number updates small compared number reads 
requirements reliability high network operate function 
conceptual schema simple table type translation necessary queries look select atm address atm ip table ip address ip address www address translation select url url urn table urn address urn address intelligent network services intelligent network development started numbers usa 
companies needed flexible billing strategies calling offices routing flexible 
type requirement route calls different offices dependent time 
requirement led development intelligent network services 
services idea translating numbers redirecting charging 
functions involve functionality 
studies experiments implementations providing supplementary services call waiting call redirection intelligent network techniques 
example architecture intelligent networks shown ssp service switching point triggered action performed needs interrogation scp service control point 
ssp scp takes action delivery response scp 
scp located ssp sscp adjunct processor ssp acp various scenarios possible 
ssp part type switch implementations part transit international switch 
located local exchange 
telecom database case diverse transactions update telecom database services read various data 
similar usage reported mobile telecommunications 
study mobile telecommunications network infrastructure intelligent network concepts 
application le ssp le ssp te ssp scp example intelligent network architecture mass service way services type service considered 
telecom database handle applications investigated thesis able handle application 
directory service service directly user network node 
translates names recognisable user network addresses 
example translate joe shannon telephone number 
interacting user necessary name unique directory service provide records match description 
network nodes name unique network node intelligence select possible persons 
service mainly table look function little bit complex table look unique 
requirement reliability service dependent important service operator users 
service absolutely necessary network continue operation 
lower reliability system sufficient 
service studied thesis envisioned mass service 
require people call name number evolution foreseen 
people 
slightly complex queries directory services 
example similarity searches searches partial names performed 
great value partial information subscriber known spelling errors occurred 
mobile telecommunications mobile telecom network needs telecom databases handle location users mobile telephones services users 
requirements tough studied greater detail thesis 
characteristics telecom applications service network characteristic number portability service handle table lookups user hour 
requirement easier handle requirements mobile telecommunications considered 
requirements name server dependent network architecture size messages bandwidth forth 
basically table lookups database better 
specify particular requirements type application 
information network usage internet world wide web www exploded usage email ftp various internet services quickly increasing 
network limited bandwidth bottlenecks places 
possible transfer large files network bottlenecks network preclude usage video sound broadband services large scale 
design network handle load millions possibly billions concurrent users need text sound video pictures various qualities necessary analyse need network nodes network links network switches 
necessary usage modelled sense 
aim thesis find requirements general information server contain data objects sizes gbyte 
objects greater size long video sequences specialised applications virtual reality 
assumed solved specialised servers handle continous streams information server focus thesis requires fast access small medium sized objects concurrent users 
global information system distributed system seen user exist different types servers 
different servers parts general multimedia server general servers distributed systems 
part system number signal processors part number data servers part contain video servers part contain query servers part contain application servers 
thesis applications analysed greater detail 
general email server second news demand server large newspaper genealogy application 
believed applications smaller requirements throughput compared server applications 
email application mass service provide large storage volumes 
news demand mass service needs higher bandwidth objects fetched larger email objects 
storage news demand service caching larger extent email service pages newspaper read users 
genealogy database service high requirements storage volume needs store scanned images high resolution 
need look images session 
genealogy service provides interesting application global information application 
application millions people concurrently similar problem find ancestors 
common ancestors global database spread information research results immediately 
charging network charging needed telecom applications requirements charging applications tougher due events telecom network due fact billing performed immediately usage service months previously case 
studied greater detail thesis 
mobile telecommunications mobile telecommunication systems developed long time ago 
systems generated mass market analog systems 
systems generally called generation systems 
examples nordic standard tacs english standard amps american standard 
exist countries form substantial part market 
second generation system development started generation system catch mass market 
second generation systems digital better frequencies tried achieve better sound quality 
better frequencies smaller size cells possible sell second generation systems larger market 
market expanding quickly 
major systems second generation 
gsm european standard amps american standard japanese standard 
parallel development second generation systems new systems developed houses urban areas vicinity person home 
large number systems developed major system survived market european standard phs japanese standard 
project defined race program research advanced communications eu define umts universal mobile telecommunications systems 
aim project study third generation mobile telecommunication networks 
essential part study look integration isdn network mobile network 
race follow project performed 
phase reality exploding second generation system gsm changed surrounding world 
www took giant steps defining generation broadband applications 
third generation mobile systems second generation mobile systems network able internet 
initial aims difficult reach 
studies performed race programs develop second generation systems standardisation umts proceeding aim having systems available 
explosion second generation systems development phs attracted large market driven development generation 
usa development led pcs started 
generation existing systems developed higher bandwidth better radio resources efficient frequency smaller cells 
packet switched data important issue generation 
integration second generation systems phs occur generation 
thesis mobile telecommunications studied perspective users current fixed network lower prices higher usage current systems 
telecom databases application keep track users mobile telephones 
provides platform network services provide interface intelligent terminals possible implement services 
databases store information services location information directory information 
information compact possible store main memory 
procedures require rapid responses monet delay queueing ms dependent query type telecom databases gave delay fixed network call set simulations top delay access network 
telecom database response time order ms loaded system 
delay requirements retrievals call set procedures delay sensitive 
ms delay time updates acceptable 
network studies performed estimation users mobile users 
users charged calls fixed phones usage similar fixed network traffic models derived mathematical models movement people cities 
results reported mainly monet 
deliverables race program took issues consideration 
basic assumptions 
network architecture architecture evolved second generation mobile telecommunication network 
results race program message service included study results derive results loads nodes links 
results thesis derived analysis research third generation system 
figures applicable evolved second generation systems 
main difference current systems assumption traffic model mobile phones similar manner current fixed phones assumption functions moved telecom databases communication services systems 
main differences current second generation systems third generation systems bandwidth type calls diverse 
data communication calls fax calls message service calls common third generation systems current second generation systems speech connections dominating feature 
conceptual schema umts conceptual schema umts system described monet 
course real system schema supplied details 
schema mention basic entities relationships 
set identifiers numbers umts network 
spi service provider identity identifying service provider 
icsi international charged subscriber identity identity subscriber entity pays bill business relationship service provider 
international mobile user identifier identifies certain umts user international mobile user number number umts user 
si service identity registered service 
terminal address composed di domain identifier identifies network operator tmti service provider data spi provided services offered services agreements barred subscribers subscriber profile data icsi subscribed services user data user profile user keys session data keys visited terminal data di tmti lai terminal status terminal keys registration data si di tmti user status user profile visited routing data si user status schema temporary mobile terminal identifier temporary identifier terminal particular network 
lai location area identifier identifies location area paging terminal 
mobile roaming number routing purposes set connection exchange user currently resides 
service provider data consists information service provider needed execution umts procedures 
consists services offered home users services offered visiting users agreements operators list barred subscribers 
subscriber profile data consists information subscription relevant execution umts procedures includes list services subscribed home operator maximum number users terminals 
user data contains information specific user service profile authentication encryption keys 
user number registrations service user registered 
registration connected specific terminal 
terminal data contains terminal status keys security procedures 
necessary routing data connected registration able find terminal user registered 
user active sessions connected 
simultaneous sessions session service provider means umts database contains session record user 
data umts network distributed databases home operator databases visited operator 
various ways handle distribution 
way home database stores service provider data subscriber data user data 
routing data needed home network able route call exchange network user visiting 
session data registration data terminal data created visited network parts registration data stored home network 
parts user data transferred visited network execution umts procedures efficient 
information umts conceptual schema distribution data umts network monet monet monet monet 
umts procedures procedures umts network 
procedure impact telecom database analysed queries generated shown 
procedures general necessary mobile network fixed network 
information flows procedures monet document information flows mapped physical architecture 
major differences information flows compared information flows current systems sessions communications system user separation terminal user universal personal telecommunications services 
telecom database involved call set process involved originating terminating part call set 
network architecture information flows shown 
scp service control point sdp service data point normally collocated chosen separate entities presentation databases focus thesis 
interface sdp internal interface scp network interface 
way derive number requests scp database handle internally 
dir node defined race monet keep track database user data resides 
major reasons architecture avoid umts number pointing physical network node changes database structure network cumbersome 
presentation show actions dir node 
information flows show dir nodes 
dir nodes basically simple table look databases user number mapped database address 
procedures possible information flow 
example user registration different information flow invoked visited network compared invoked home network 
account calculation transaction flows network necessitate detailed mobility model possible information flows studied 
mobility model 
thesis show version information flow 
keeps presentation short avoids unsure mobility model 
information flows chosen representative common cases 
retrieve update create delete operations information flows unique primary key access data mentioned 
means retrievals appear select attributes table primary key primary key update create delete performed similar way 
procedures requests part transaction 
section discuss charging information generated discussed section 
scp scp le tx le le le tx tx scp sdp sdp sdp dir bss bss bss bss gw service network access network communication network bsc bts mobile terminal mobile terminal bss core network network architecture information flows bts session management sessions ensure secure communication 
user allowed network resource session set 
major reason sessions authenticate user terminal 
authentication ensures user allowed umts services difficult stolen umts equipment 
part session set exchange encryption keys air interface sure interfere listen messages conversations 
terminals umts identifiers terminal sessions 
terminal receive temporary identifier terminal session 
services relate user performed attach terminal session 
user involved service terminal session upgraded user session 
sessions initiated network terminating call user originating call 
assume terminal session exists longer period user session assume normal case exists terminal session execution umts procedures 
session communications 
means sessions established calls 
session established longer time duration call 
user calls row part session 
user sessions normally released specified time service completion 
system originated user session set information flow system originated user session set shown 
information flows shown flow occur special payment methods 
database checked see sessions available sess par 
database find user number user identifier conv ui 
terminal user authenticated term auth terminal authentication encryption key needed retr enc par security database user authentication encryption key authentication key needed security database sec 
session data stored database sess store 
exists terminal session necessary authenticate terminal possible proceed user authentication immediately 
seen requests database directed security database 
requests retrievals create request 
retrieval encryption data terminal authentication removed terminal session existed 
retrieval session parameters retrieval umts number combined retrieval request database 
retrievals create request procedure 
user originated user session set user originated user session set shown 
major difference apart initiated session necessary retrieve encryption key necessary convert identifier number 
retrievals create procedure 
user invokes service terminal session needs user session upgrading terminal session user session performed 
information flow procedure similar user originated user session requests database 
setup tmti sess conv sdp access type type session tmti temporary mobile terminal identifier sess parameters conv term tmti retr enc tmti retr enc parameters term status setup setup status user sec req sec conf security parameters user status sess parameters sess setup status system originated user session set bss scp international mobile user identifier international mobile user number setup tmti sess bss scp sdp sess parameters setup status user sec req sec conf security parameters user status sess parameters sess user originated user session set user user status system originated terminal session set information flow system originated terminal session set shown 
procedure terminal authenticated retr auth par new encryption key stored security database store enc par new tmti assigned tmti upd 
message creates new terminal record 
assignment performed retrieval update transaction 
comprises retrievals updates create request database 
user originated terminal session set user originated terminal session set shown terminal authenticated encryption key retrieved security database retr enc par new tmti assigned database tmti upd 
message creates new terminal record 
retrieval create assignment message 
retrievals create update database procedure 
session release sessions released information flow user session release shown session object deleted database sess rel 
system originated session release performed way initiator different 
delete operation procedure perform database 
releasing terminal session terminal number involves update 
setup tmti bss scp sdp ek encryption key ak authentication key new tmti term tmti retr auth tmti retr auth ak term status tmti tmti tmti setup par status system originated terminal session set setup setup status store enc tmti ek store enc status tmti tmti tmti user registration management user registration performed user wants assign specific communication service voice fax specific terminal 
users registered terminal 
registration necessary able receive calls terminal 
outgoing calls performed part session registration needed outgoing calls 
registration performed session 
registration user different services 
registration procedure see complex procedures mobile network 
necessary fetch parts service profile user sure allowed register service prof data 
user registering visited network profile fetched home network retrieval visited network retrieval home network fetch requested data 
secondly new registration created 
involve steps creation new registration create reg deletion old registration del reg creating routing information home network upd rout 
procedure consistency requirements studied monet 
included procedure shown 
traffic model assume registration new deletion old registration necessary 
information flow show full scenario old registration deleted 
retrievals creates user registration 
user simpler deletes registration del reg deletes tmti bss scp sdp term tmti retr enc tmti retr enc ek term status tmti tmti tmti setup parameters status user originated terminal session set bss scp sdp user originated session release destroy destroy sess parameters sess ing information home network del rout 
sdp sdp messages domains 
messages pass scp scp interface umts standard 
attach detach attach attach terminal network detach detach terminal network power 
procedure executed update request sent database changing attach detach attribute terminal profile upd term seen 
call handling call handling set release modify calls 
call modification similar call set database accesses needed discuss call set call release 
call release easy involve database 
call set see retrievals originating side terminating side means retrievals call set 
retrieval performed check user profile requested service time prof data 
second access database retrieves new visited home le scp scp sdp sdp le bss bss prof si prof si prof si prof si si create si tmti mta upd si upd bss sdp del si del create si del si del si del del mobile roaming number mta mobile terminal address si service identifier spi service provider identifier prev visited user registration user current location user loc user 
originating network needs information setup call right network terminating user needs detailed location information page user 
scp le bss sdp tmti upd tmti tmti upd tmti upd attach detach le scp scp sdp sdp le bss sdp bss originating terminating home loc si parameters loc tmti lai loc tmti prof si prof si prof si loc si parameters parameters parameters parameters prof tmti tmti parameters tmti base station identifier originating international mobile user identifier originating international mobile user number terminating international mobile user identifier terminating international mobile user number lai location area identifier session set handover handover performed change radio base station new base station located new exchange 
located new network 
handover performed internally base station channels base station 
database normally involved handover procedures 
handover transferring call network necessary access security database twice retrieve keys update keys 
location update location updates performed terminal moving network moves new network 
tracking user movement location updates user called mobile 
location update changes network called domain update umts 
involves moving registrations old network new network 
location update updates location area information database upd loc see 
domain update means user moving network operator domain 
part move registrations old network moved new network 
procedure similar user registration 
registration retrieved old domain necessary delete registration old domain 
authentication procedure assignment temporary terminal identifier performed 
necessary user terminal performs domain update 
assume performed terminal session set performing domain update 
location data updated reflect new location 
assume registration user terminal retrieval updates create delete domain update 
scp le bss sdp tmti upd tmti upd new location area identifier new temporary mobile terminal identifier location update advice charge advice charge information flow shown involves retrieval tariff information home database tariff retrieval usage information visited database um 
retrieval scan operation generates record reply slightly complex retrieval operations umts database 
service profile management user interrogate update service profile user procedures 
gets access interrogate update database network checks request allowed service profile user 
user interrogate update database possible service profile 
involve retrieval number user supplied retrievals updates 
normally accesses user manages service profile 
access assumed service profile management action 
umts characteristics important issue determining characteristics telecom databases mobile telecommunication systems traffic model 
find requirements specific telecom database estimate number users database 
current mobile systems traffic model affected high price mobile communications 
third generation mobile systems price communicating mobile similar price communicating fixed terminal today 
calling rates estimated looking calling rate current wireline networks 
calling rate networks calls hour user includes originating terminating calls 
terminals mobile services offered telecom network estimated calling rate increase 
call modifications multimedia calls increase rate call handling 
estimated calls call modifications hour 
split originating calls hour terminating calls hour user 
valid busy hours day 
le scp scp sdp sdp le bss bss originating home ci si si si ci ci ci si ci call identifier ci ci advice charge user session handling performed umts procedure 
instances user session calls interactions network 
user sessions current network estimated 
estimate hour user 
necessary terminal sessions 
sessions active longer time estimate sessions user hour 
user registration new procedure measurements estimating registration rate 
probable users register times day 
estimate registrations user busy hour number 
attach detach estimate user busy hour 
number location updates dependent mobility model 
model depends parameters size location areas mobility users 
busy hour location updates coincide busy hour calls 
busy hour smaller 
rate varies depending conditions 
user hour calculation monet 
estimate hour user estimate changing domain changing operator network 
gives location updates hour user domain updates hour user 
inter domain handover uncommon 
erlang multiply 
domain switches calls 
gives inter domain handovers users perform service management 
estimated rise compared today due services 
rate estimated hour user equally divided interrogate register erase activate deactivate service 
advice charge handled section event data services considered section 
number users telecom database depends users network policy operator 
databases essential operation network operators require system continues function telecom databases 
requires network redundancy telecom database ready take goes 
minimum number telecom databases network 
means theoretically operator users telecom database 
redundancy errors cause system fail 
users appropriate 
way large operators build systems intelligent backup strategies nodes assist telecom database fails 
estimates users telecom database 
discussion reach figures shown table 
table umts procedure rates procedure events user hour total events second relative rates originating call set terminating call set inter domain handover location update figures table information flows preceding section derive number retrievals updates creates deletes database see table 
figures seen modify queries put substantial load umts database modify query complex execute compared read query seen forthcoming sections 
description interaction scp service control point sdp service data point obvious large amount interaction database application application message received 
reason database store session information telephone call security information 
requirements performance low delays grow compared requirements second generation mobile networks 
domain update user registration user de registration attach detach system originated user session set user originated user session set system originated terminal session set user originated terminal session set session release interrogate services register service erase service activate service deactivate service total table umts database accesses procedure events user hour total events second relative rates retrieval update create delete total table umts procedure rates possible visualise database contains actual state telephone call 
state variable need updated times call 
create new possibilities creating services telecommunications 
active database features implement telecommunication services 
news demand current www service envisioned similar multimedia newspaper look 
possible read text images look video sequences access large information databases depth explanations interested reader 
access service provided home computers personal digital assistants display terminal new old 
access fixed terminals mobile terminals 
news demand service people access latest news 
access depth stories time need background headline news news 
new standards developed multimedia documents capabilities contain links text images documents links documents real time requirements presentation documents audio video documents 
standard hytime sgml standard graphic markup language 
documents standards highly structured 
multimedia document represented sgml hytime hierarchical tree objects 
contains number structured objects consist structured objects contain leaf objects 
leaf objects objects text audio images video objects 
news demand system consists distinct parts 
part news production facility second part news presentation facility 
news production facility journalists editing documents providing links information 
experts presentation facilities help developing multimedia documents real time properties proper quality service provided 
part databases flexible performance requirements high reliability requirements high 
system taken service times workload consists large task small ones 
requirements telecom databases applicable environment 
multimedia documents created news presentation facility management node retrieves document news production facility stores news presentation facility 
documents read documents new versions added indexes added removed documents 
main task answer user queries database optimised queries 
architecture shown 
common query user wants view multimedia document 
query course document fetched 
means video text images audio sequences features document retrieved large object 
inflexible require information replicated places 
foreseen query performed steps step fetches document description synchronisation requirements objects part document 
second part fetches parts documents document requirements synchronisation presentation 
means objects fetched database contain internal structure 
news presentation facility similar requirements telecom databases high performance high reliability large storage requirements 
conceptual schema news demand application extensively studied 
user course specifies document wishes view splitting query small queries performed application server 
application server part user terminal part network server handles user request 
find simple conceptual schema news demand database 
contains document objects 
objects contain set attributes describes document author date creation subject title key words forth 
contain lists objects connected document 
document description stored attribute basically binary large object attribute blob 
document object contains quality service parameters 
text documents document description contains text object document 
database contains file objects image objects video objects text objects audio objects 
objects contain actual objects format compressed mpeg jpeg gif tiff format 
contains set attributes describes object 
descriptive attributes user issues searches information 
links followed link specifies name document fetch 
example multimedia document shown 
document description describe placement text object image objects contain text object image objects 
text contain text represented sgml standard format text contain links documents describe queen information sources information sources information sources news production facility news presentation facility user user user user sgml hytime sgml hytime telecom database news demand systems news demand conceptual schema news presentation facility document data name key format qos parameters file data name key format descriptive attributes descriptive attributes file document elisabeth ii australia 
image showing australia boat contain links documents text 
second image contains links video presentation news audio presentation news 
example document description contains text object contains links objects links text objects image objects 
document retrieved queries appear select document format document table name document name document format attribute specifies format document description stored 
client process document description issue queries image objects appear select file format file table name image name news demand characteristics trials news demand service exist large scale characteristics arrived making estimates user behaviour current technologies characteristics application similar reading news watching television news similar reading www pages 
news demand really interactive newspapers radio news television news similar www user interface 
figures scientific reports 
considered valid perform anyway better estimate 
user spend fifteen minutes time news demand service evening longer time 
watch video clips audio clips 
video audio clips normally seconds minutes long 
users queen elisabeth ii sydney cruiser queen elisabeth ii landed today sydney day visit australia 
ship met thousands interested people wanted see large cruiser ships carry passengers going continents 
go canada 
video clip audio clip text portion document 
image portion document 
example multimedia document linked objects linked objects subject media scan news documents watch interesting news particular user interests video clips depth information information video best presentation media 
reading newspaper readers scan pages newspaper 
doing read pages fifteen minutes 
documents displayed user terminal somewhat smaller newspaper pages interactions user user terminal fifteen minutes 
addition user watch video clips news 
video clips heavily evening 
users interact news demand service morning evening 
evening interaction little longer possibly half hour 
course everybody interacts heavily estimate normal user registered news demand service interacts half hour day 
activity spread morning evening 
morning mobile device news demand service reading newspaper 
evening user fixed terminal home watch video clips 
interactive morning 
half hour normally divided sessions 
sessions busy hour morning evening 
estimate sessions started user hour busy hour 
size documents images vary largely document description text document small kbyte 
images kbyte 
normal document estimated kbyte figures mean size kbyte 
user terminal course requests larger chunks document time 
decrease number requests telecom database 
increase bandwidth need user normally reuse cached information information prefetched bandwidth wasted 
bandwidth possibility handle user requests bottleneck known 
mobile terminals low bandwidth essential 
fixed terminals bandwidth issue 
models introduced table mobile model fixed model 
mobile model assumes user connected mobile device 
user reads documents interactive news demand service 
user interacts telecom database request save bandwidth avoid unnecessary file transfers 
number video clips small model video clips lower quality save bandwidth fixed model 
assume video clips transmitted kbit sec mobile model 
reader watches half minute video clips fifteen minute session 
fixed model user connected fixed terminal connected television set 
number video clips higher interactivity 
video clips transmitted mbit sec model user spends minutes minutes watching video clips 
models derive mobile model puts heavy requirements response times telecom database 
puts high requirements message processing capability 
need bandwidth fixed model 
fixed model requirements similar requirements video server 
interactivity higher video server bandwidth requirements times higher mobile model 
derive figures stated table 
obviously tough requirement handle video bandwidth fixed model 
discussion easy see news reader high requirements response times 
response time half second user bothered 
video clips user accept little longer delay seconds start 
response time telecom database ms delays network user terminal 
regarding mobile model bandwidth demand required 
bandwidth mbit sec able transmit documents kbyte size half second 
requirements umts originally possible achieve bandwidth radio cells small densely populated areas 
information news demand database cached information server 
affects load various information servers handle query mix 
table news demand characteristics busy hour behaviour mobile model fixed model user sessions user interactions telecom database interactions non video bandwidth user mbyte mbyte video bandwidth user mbyte mbyte video clips table news demand database characteristics procedure events user hour bandwidth user hour total events second total bandwidth sec retrievals document table fixed model retrievals file table fixed model bandwidth requirement fixed model mbyte gbyte sec retrievals document table mobile model retrievals file table mobile model bandwidth requirement mobile model mbyte gbyte sec news read users today news 
benchmark focuses browsing today news 
normal newspaper pages long combined television news radio news 
hour video clips hour audio clips 
newspaper bigger resources available currently size today news demand 
probably bit bigger normal newspapers television news 
short discussion model daily news demand consisting articles documents video clips audio clips 
articles consists document part zero images 
size document part bytes kbytes mean kbyte 
images vary size kb kbytes 
mean kbyte mean number images 
audio video clips seconds minutes long mean time minutes 
video clips stored form kbit sec mbit sec transfer rates supported 
audio clips stored form transfer rate kbit sec 
figures interesting drawn 
transfer rate telecom database high storage need small document part consists mbyte video part mbyte plus mbyte audio part mbyte 
total storage need gbyte clearly fits main memory telecom database 
real news demand database course connections video archives document archives various information sources 
information sources course require higher storage volume 
part telecom database distributed information network 
multimedia email people electronic mail systems 
helps people stay contact person difficult reach phone 
provides way share information sending documents various types 
explosion internet years service heavily private persons 
solve communication problem small organisations limited budget difficult inform everybody change schedule current techniques 
email broadcast mail mail group inform everybody easily efficiently 
small organisations home users necessary servers available subscribed 
expensive server connected internet send receive emails 
affordable large organisations 
large organisations problems servers fail software change needed forth 
definitely large market multimedia email service providers network operators 
network operators service provider supplies email server reliable store large pieces information 
accessed user wants read create delete send emails 
email service requires high reliability 
user accept emails get lost 
crucial email service works catastrophic situation 
building database emails necessary table various emails exist database 
table receiver sender title email time received identifier email stored 
user defined category part email object 
email object table 
object contains list objects attached email properties attached objects 
attachments text files hytime documents video files properties attached objects stored part attached object see 
major usage email service display email titles user defined email folder display email list attachments create new email delete email show attachment play video display text send receive emails usage easy find query functionality email server optimised 
query displays emails specified folder normally connecting email service sql query look select sender title receive time email id email table receiver user folder folder response message contains set emails specified category user mailbox 
second query reading email consists parts 
part retrieves email checks attachments select email body email property attachments email table email id email id attachments query retrieves properties attachments email data email id title attachment sender multimedia email conceptual schema attach data attachment id email id name format receiver received time email body format category size attached file size select attach id attach property attach name attach table email id email id response queries contains email body properties set attachment properties id name 
third query sending receiving emails 
procedures email attachments created 
accomplished create transaction appear start transaction insert email table email body email body format format sender sender receiver receiver title title format email format category category size size attachment attachment insert attach table attachment email id email id format attach format name attach name attached file attach file commit transaction delete email easy simply deletes email email table attachments attachment table 
appear start transaction delete email table email id email id delete attach table email id email id commit transaction showing attachment attached file needed fetched query appear select attach file attach table attach id attach id sending receiving emails performed email server network protocol extended smtp simple mail transfer protocol 
receiving activity emails created 
sending email email attachments fetched database sent receiving site 
description email service personal normal email tool assumption email services similar current email tools 
multimedia email characteristics email service heavily today heavily 
major problem email heavily dependent user maturity computers culture user behaviour 
pax study development internet 
report usage email wide area connections increasing year person email wide area connections day user report shows size email growing 
mean size emails kbyte 
growth trend continues reach mails day additionally report include local email connections increasing email usage 
easy see impossible predict behaviour users email 
presentation model users behave today ordinary mail supplemented possibility email fast communication person reachable 
large part current mail system distribute advertisements various products 
email traffic today generated email reflectors email lists 
fairly certain major part email traffic broadcast traffic 
easy see normal users receive emails send 
email person person communication currently answering machines voicemail short message services mobiles faxes 
multimedia email service include services voice messages fax messages text messages video messages part email service 
usages emails common today transfer small text messages transfer files attachments 
size text messages constant size number files transferred multimedia email increase long time ahead voice messages file transfers video messages fax messages common type usage email service 
email user perform email sessions check email received send emails 
sessions occur times day mean email sessions user hour busy hour 
business users communication services private persons thesis distinguish treat community entity 
person receive emails day send emails 
busy hour emails received emails sent email sent normally user session emails received 
derive figures table 
table multimedia email procedure rates procedure events user hour total events second relative rates connect email session read email send email receive email delete email total reason emails deleted sent possible broadcast emails sending email reflected deletions emails creation emails 
connecting email session scan email table performed email titles displayed user 
reading email email body read scan attachment table performed attachments 
sending email involves creating email attachments sending communication channel receivers 
receiving email creates email attachments database deleting emails deletes email email table attachments attachment table 
current size emails kbyte pax 
grow slowly voicemail fax mail file transfers increase estimate mean size email messages kbyte 
number email messages stored user mailbox highly dependent user 
user pay extra larger storage capacity mailbox 
normal user messages stored mailbox 
estimates derive figures table 
total number users umts database users 
derive access rates database email service necessary estimate number attachments email 
attachments emails time mean number attachments estimate email 
derive figures table 
table multimedia email bandwidth storage users user total input bandwidth kbyte mbyte sec output bandwidth kbyte mbyte sec storage volume mbyte table multimedia email database accesses events user hour total events sec relative rates retrieve email retrieve attachments scan email table scan attachment table create email create attachment delete email delete attachment total event data services applications mentioned far necessary bill services 
current billing procedures telecom operators provide bill predefined time 
information network possible pay service way done shops 
possible tell system want pay bill way restaurants 
possible pay electronic cash pay credit cards method paying 
possible necessary audit users doing network 
information immediately available billing system line billing possible 
information get information network usage ways 
necessary regulate information legally gathered information users provide network 
systems market research network planning operation maintenance regulatory organisations 
information gathered defined event records created nodes event happening 
event records sent charging database collects usage records transfers parties need access 
database transfer records records stored database queries issued stored records 
particular database update information database information added 
times old event records deleted possibly saved archive 
charging database telecom database presentation focus requirements charging database 
flow information accordance ccitt recommendation accounting process consists processes number usage metering functions functions generate event records 
ii charging process formats distributes collects event records form service records service records 
iii billing process uses information provided charging process create bills 
um fe usage metering network entity um fe network entity um fe network entity charging database grouped event record event record info usage event record call event record call charging process billing system market research network planning operation event records storage distribution query function maintenance data generation data aggregation data formatting data correlation data distribution regulatory reporting architecture adopted race monet project candidate accounting process third generation mobile systems 
similar process adopted digital audio visual council standard video demand information services developed 
detailed description charging process umts proposed race monet shown 
events collected visited network sorted formatted transferred home operators charging process 
home operator records associated user events stored service records 
records tariff data create service records 
records transferred billing process home operator 
umts event records monet events identified mobile originated call record generated call terminated originating side 
mobile terminated call record generated call terminated terminating side 
bearer usage record specify bearer resources call 
emergency call record 
feature usage record metering umts procedures registration session management location domain updating 
supplementary service record supplementary services invoked call call waiting 
association usage metering charging usage record storing collection billing inter administration charging storing sorting inter administration association usage metering charging storing collection billing inter administration charging storing sorting inter administration modified usage record bill service records service records usage record home operator charging database visited operator charging database usage record umts charging accounting subscriber value added service record value added services invoked call directory service 
service record user involved umts call 
management service record user invoked service management function 
service record call services call 
handover record handover 
handovers information 
operator decide handovers 
incoming outgoing gateway record coming new network leaving network 
event records contain user subscriber event 
events part call type service call identity service invocation identity grouped service records 
network entity generated record 
list possible parameters monet 
news demand event records events news demand application simple specify 
news provider know documents readers interested time document fetched usage record created 
performing searches database event record created 
event records part user service reading newspaper 
service record created user session 
email event records email events definitely recorded emails sent received 
interaction email server generate event record 
exactly events record decision operator 
creating sending emails service connecting email server service generates service records performed email session 
characteristics event data service analyse flow event records umts application news demand multimedia email application 
umts application generates event record time umts procedure invoked 
event records generated specify network resources supplementary services emergency calls services services value added services 
call release generates event record specifies duration time call 
news demand multimedia email assume user accesses server generates event record 
usage models previous sections deriving characteristics charging database 
extra information need umts case shown table 
process charging database correlates usage service records various needs 
records pertaining call umts session email session news ondemand session brought stored service record 
records stored charging database external systems perform queries usage information 
process formats usage records service records various needs 
formatted records distributed external systems requested distribution list records 
grouping event records triggered events specify service completed 
part process tariff applied service record producing service record 
record line line billing 
formatting performed records produced formatted records distributed 
assume event record service record service record produced formatted distributed external systems 
way avoid large query transactions time user wants calculate bill get advice charge calculate bill incrementally means updated time set service records produced 
assume performed application 
performed having triggers database 
types transactions charging database 
type storage event records 
transactions trigger type transaction 
transaction formats event records distributes formatted records groups event records updates billing information possibly information requested application user 
charging process relation transaction types shown 
problem event records stored 
sent disk erased main memory eventually 
long time interval event records user session event records sent disk user session call finished 
avoid event records stored tables 
table represents original stored disk eventually 
records read sooner sent disk soon possible 
second table contains similar information stored main memory 
record deleted soon charging process finished 
sure queries charging process table umts procedure rates procedure events user hour total events second network resource usage service advice charge supplementary value added services formed main memory data 
procedure service records necessary save process 
estimates assume grouping transaction formatting transactions part transaction need save database 
information held local variables application 
fourth type transaction issues queries calculate bill perform advice charge 
transaction simple read user record information produced part charging process 
fifth type uncommon type transaction queries user records tariff records event records service records service records 
management systems perform data mining charging database various purposes 
delete transactions occur occur regular basis 
normally records kept months deleted 
provide characteristics deletions retrievals updates creations 
updates user records table event records inserted retrieved deleted 
updates user records table normally performed applying function tuple 
database supports sending methods method sent database proper input 
retrieve followed update performed 
calculate characteristics charging database need analyse happens mentioned transactions 
events lead creation records deleted user session call ended 
time user session service call ended service record service record created 
event records table main memory scanned event records belonging user session service call 
update user table performed retrieve tariff information performed 
gives retrieval scan update create operations user sessions services calls 
event record service scan operation needed 
reception event record usage metering function event records tables store service records tables user records table group event records service records create service records service records tables retrieve store store tariff records table retrieve retrieve update retrieve retrieve retrieve format event records service records service records distribute external systems charging processes usage telecom database umts application actions triggers session actions call release inter domain handover location update domain update user registration user attach detach interrogate service register service erase service activate service deactivate service service supplementary services 
call release contain event record 
derived characteristics umts news demand multimedia email charging database shown table 
genealogy application genealogy application uses historical records trace ancestors families 
immense amount historical records search 
currently done reading historical records directly reading copy record 
means needs visit archive place read microfilms genealogy 
difficult trace searching records 
forthcoming storage database technology tedious research 
groups objects application 
group comprises historical records scanned directly 
group contains refinements objects computers images clearer increase sharpness brightness contrast possibly adding colours text visible 
means versions scanned objects 
desirable possible delete objects especially original scanned objects 
represents immense storage volume 
today exist millions microfilms historical records containing images normally format 
image needs mb storage compressed form 
image needs high resolution represents hand written text 
text difficult read necessary parts image magnified readable 
records 
object class constantly increase storage volume store new originals new copies 
start need thousands terabytes millions gigabytes billions megabytes 
increase records added historical database 
class objects catalog objects 
objects specify historical records represent 
researcher goes wants see historical records exist area ancestors 
table charging database characteristics application users retrievals sec scans sec updates sec deletes sec main memory creates sec disk creates sec umts news demand multimedia email total third class objects transcriptions scanned objects 
means person computer program read text note written 
versions transcribed objects 
transcription exist versions original simply tries read character character written version older words translated modern words version text translated modern language course translations languages 
course transcriptions text 
need mistakes especially text difficult read 
fourth class objects comprises application objects represent information sought 
genealogy means information births marriages deaths information link persons families 
versions objects representing findings different 
course information applications apart genealogy 
application historical research 
applications requirements application objects 
section focus genealogy application 
fifth class objects comprises link objects link information 
transcribed object needs linked original possibly version transcription 
application objects needs linked sources scanned objects transcribed objects application objects 
scanned object normally represents page historical record 
page consists number information objects 
book births information objects pages represent births 
book marriages information objects pages represent marriages 
tax record information objects pages represent taxes paid paid 
information objects mapped scanned objects 
mapping represented set scanned objects information located area scanned objects information object consists 
information object linked various objects 
linked transcriptions information object application objects connected information object 
example birth record normally short item name child birthplace name father mother 
information information 
birth record transcribed transcription object created somebody finds relative application object data person collected information parents spouses children 
application object linked information object 
information object transcribed objects application object links information objects collecting data person family connections 
sixth type object comprises name translation objects 
necessary provide translation standardised names 
historical records uncommon name spelled ways 
example spelled ways swedish records ret 
spellings represent name different records represent person 
different versions names differ different geographical areas 
provided name translation object information usage name common history name forth 
different objects shown 
works objects different ways information 
scanned objects derive new information fetched object time transcribed objects application objects searched sought information 
interesting challenges application telecom databases 
represents application vast need storage 
current technology satisfy requirement possibly requirements met right price level 
represents application needs object oriented technology represent information relational database technology efficient searches deductive database technology assist specialists genealogy technology efficiently 
need fuzzy queries names standardised 
solutions multidatabase technology needed enable queries similar sources sources contain information information represented different formats 
represents interesting application millions people application distributed database global 
needs versioning system database grow information possibly marked invalid seldom entirely deleted 
conceptual schema description conceptual schema genealogy application 
scanned objects relations catalog objects number scanned objects represents information covered catalog object 
scanned object page catalog object 
copies original scanned objects relation original object 
scanned objects consist number information objects represented link object transcribed objects 
typical information object information birth death marriage 
information court cases taxes letters types information objects 
information objects normally short fit page 
span pages court case 
catalog objects scanned objects transcribed objects application objects object classes link objects name translation objects link object contains information pages information objects seen 
link object specifies part page covered linked object 
specified coordinates upper left corner length axis length axis 
information objects transcribed text objects machine readable search queries 
translation process supported software helps interpreting handwritten text 
application issue dealt database 
scanned object scan object quality descriptive info copy belongs page catalog object country state county region source type time period descriptive info link object belongs position page coordinates information type transcribed object event date information type application object sourced sourced sourced specific object specific attributes specific application object specific attributes name translation object original name standard name country state county region info scanned object jun birth jon jonsson father jon hansson link object transcribed object name jon jonsson date jun event type birth father jon hansson mother region county birth record sweden state country sweden handwritten text example relations scanned objects linked objects transcribed objects len len transcribed objects scanned objects sources find information store application objects 
detailed description relations application objects 
basic application object object describing person 
person relations marriage relations relations parents relations children 
relations foster parents parents forth possible 
names transcribed objects application objects form written original document 
names similar spellings represent name 
name translation objects translate original names standardised name 
traffic model analyse behaviour application need guesses traffic model 
traffic model user behaviour users active different activities 
people interested browsing data data accessible people 
limited set people updating data providing new research results 
people time people browse data high percentage currently active updating data 
transactions types part describe common transaction types provide performed world wide basis 
insert original scanned object transaction performed scanning original object original record 
activity performed centrally set scanners expensive perform scans normal working hours 
estimate films scanned year 
require number years converting films person object birth data birth sources death data death sources descriptive info application specific information father mother relation married relation type relation info marriage data marriage sources descriptive info application specific information conceptual schema application object activity slow original records scanned 
suggests films day films busy hour 
means transactions second assuming pages film means transactions second 
transaction inserts large object 
insert derived scanned object activity performed anybody powerful computer improve clarity original scanned object 
different versions scanned object needed sure text readable possible 
rate times high insertion original scanned objects 
leads transaction rate transactions second 
transaction insert original scanned object 
insert transcribed object inserting transcribed object activity performed interested normally perform areas research 
transcribing objects area helps genealogical research area take great steps forward 
sweden association established 
main purposes transcribe genealogical records 
association active years collected half records births marriages deaths rh rsl records yearly activity people written birth data marriage data death data data ability read ability read forth 
books written covering period years sweden early 
records list records describing heritage dead people law books forth 
tax records written year days 
active perform transcription people 
persons transcribe records year 
represents hours year person 
global association existed data available immediately transcription gain interest transcribing records 
thousands people gain interest sweden millions world 
possible transcribe billions records year world wide basis 
people perform research free time busy hour evening 
records day achieved times create load busy hour records 
gives transactions second world wide basis 
transaction inserts transcribed object database requests insertion transcribed object 
standard name table update fields standard names 
fields absolutely necessary represent replication information 
reads transcription tables common probably idea store standard names transcribed objects 
means read accesses standard name table 
links scanned object transcribed object need inserted 
insert update links depending implementation links 
check transcribed objects transcribed objects checked determine copies correct correct transcribed object inserted table 
table links objects check 
half insertions transcribed objects appear 
means transactions second 
transaction consists reading checked objects normally inserting correctly transcribed object 
search transcribed objects searches transcribed objects normally scans objects particular type specific region 
normally objects scanned objects returned average 
common transaction 
people performing research browsing genealogical database 
difficult guess searches performed 
searches inserts probably 
searches second performed world wide basis average records scanned 
busy hour 
write application object insert update new application object means case insert update information person genealogy marriage persons inserted 
application object inserted updated number links ensured 
links parents links source objects 
source objects application objects transcribed objects scanned objects 
means insert update application object normally causes insertion number link objects reading number linked objects 
understanding number insertions difficult 
performed researchers browsers create copy application object write added information think valuable 
second world wide basis busy hour 
search application objects searches applications useful common 
knowledge person known 
search performed 
estimate searches second world wide basis busy hour performed 
search scan objects 
link common operation follow links set write transaction 
browsers particular technique find information ancestors 
links followed scanned objects catalog objects transcribed objects application objects 
guess represent read operations second world wide basis busy hour 
transaction read object estimate accesses scanned objects 
reliability availability telecom databases seen presentation applications reliability availability important 
section definitions terms empirical studies failures number approaches provide reliability availability 
material section covered greater detail gray tor 
definitions common measurement reliability system mean time failures mttf common measure maintainability system mean time repair mttr 
measures define availability measure availability probability system available 
require high level availability common discuss unavailability 
gs defines availability classes table 
availability requirements telecom databases availability class 
telecom databases need availability class handle availability class 
requirements catastrophic failures service available weeks months 
empirical studies causes failures 
major contributors failures hardware failures software failures operator failures maintenance failures environmental failures 
main contributor software failures errors design 
hardware failures caused errors design errors handling hardware environmental causes hardware fail due age 
operator maintenance failures human failures 
caused erroneous operator maintenance manuals 
humans cause failures strikes sabotage forth 
classified environmental faults 
environmental faults hardware faults caused disturbances nature earthquakes radiation forth 
table system availability classes system type unavailability min year availability percent availability class unmanaged managed managed fault tolerant high availability high availability ultra availability availability mttf mttf mttr gray see number failures due hardware maintenance decreasing 
due improved hardware lesser need maintenance 
software failures increasing failure types constant 
gray tor evident design telecom database 
necessary maintenance personnel trained changes carefully planned changes performed necessary 
security precautions sabotage 
stable environment hardware air conditioning power supply sites available takeover major failure system network redundancy 
plans disasters occur 
line backups stored safe places stand systems available take case disasters 
thesis pursue issues mainly focus performed proper design 
increase availability design focus highly automatic recovery maintenance procedures 
recovery procedures automatic involve operator interaction 
maintenance procedures supported tools maintenance procedures tested properly 
tools check operator errors simple 
maintenance procedures system line 
module failure rates module failure rates applicable hardware software 
production software normally design faults lines code 
hardware disks boards connectors cables normally mttf years properly designed 
lifetime products shorter figures continous replacement old hardware 
high failure rate new hardware run new hardware factory delivering customer 
failure rates increase operating temperature high factors increase failure rate shocks vibrations thermal changes mechanical stress 
hardware faults classified soft faults hard faults 
soft faults temporary faults cause error failure disappears 
examples processor mistake interprets error behaves correctly 
failures need repair 
hard fault disappear module repaired 
software faults classified ways 
classification separates 
difference show time code executed 
show specific occasions special conditions occur 
faults production software reason course careful testing removes 
second classification classifies bugs benign bugs 
benign bugs bugs occur come back 
bugs tendency come back 
classification software failures production system caused faults 
faults cause failures rarely called benign faults 
remaining software faults production software extremely hard remove 
studies show time fixing bugs mean number bugs increase bug fixes introduced 
reason introducing bug fix number new bugs eas ily arise 
drawn facts possible current methods avoid software errors 
possible mask software errors 
accomplished making sure single software failure hamper availability system 
occur special conditions bugs hit processor nodes simultaneously state processor nodes synchronised 
hardware approaches past hardware main cause failures advanced approaches hardware redundancy exist 
common variant hardware doubled 
hardware benefit voting scheme correct hardware modules identify faulty module 
software faults dominating reason failures 
means redundancy provided software 
solved dbms replicating data 
hardware redundancy needed dbms puts data independent processor nodes 
conclude need hardware redundancy 
needed modules 
hardware module function correctly immediately report failure 
means software trust hardware function correctly 
need hardware redundancy communication network 
communication network doubled 
software approaches approaches availability software approaches 
approach called version programming 
means specific function system solved design teams independently 
execution result functions compared 
agree ok problem 
approach problems 
difficult detect version function correct 
difficult recover version failed 
problem faults arise complexity function means really complex parts erroneous versions 
similar examination school hard problems solved correctly 
approach transactions fault detected transaction rolled back system continues operating 
reasoning fault benign bug fault reported major investigation fault performed 
approach commonly high availability systems system pairs 
means data primary system replicated backup system 
means backup system ready take primary system fails 
approach internally system provide high availability system performed network level achieve availability fault situations environmental faults maintenance faults operator faults 
approach called defensive programming basically programmer trust input performs integrity checks internal data structures 
checking internal data structures performed executing normal functions executed specific programs execute check consistency data structures 
programs called auditors 
approaches combined system 
transaction availability availability databases handles issues 
issue available system execution transactions 
second issue committed transactions lost 
call availability system execute transactions transaction processing availability 
measure probability system abort transaction due internal database failure 
probability losing committed transactions called transaction processing reliability 
clearly desirable transaction processing reliability higher transaction processing availability 
database replication approach develop method increases transaction processing reliability cheap way special log server stand node 
obvious requirements telecom database replication data system 
hardware fault tolerance replication handled software 
replication exist systems ensure catastrophic failures system easily 
possible maintenance recovery operator procedures automated minimise chances human failures 
means recovery procedures automatic operator maintenance procedures supported advanced tools 
easy tested 
maintenance organisation carefully managed human failures minimised 
redundancy maintained software automatic recovery procedures need highly available processor nodes 
need processor nodes 
common way provide doubled hardware comparator checks perform equally 
processor node immediately go failed mode 
doubled hardware questioned systems 
hardware failure hits system quickly show way software discovers failure 
compared probability software failures cause similar problems probability small 
telecom database replicated data internally network level 
communication hardware hardware fault tolerant doubled hardware 
processor node hardware fails immediately error occurs 
applications necessary 
improve mttf called executed part software 
check data structures inconsistencies calculate checksums various data check checksum correct quickly finds faults caused software hardware faults 
processor nodes restarted remove latent faults data structures 
thesis investigate fault tolerance disks 
technologies providing fault tolerant disks various raid architectures 
architecture telecom databases study various applications telecom databases draw certain requirements telecom database 
data studied kept main memory 
applications great needs larger data sets email server genealogy databases charging database need disks need form data box 
typical performance requirements telecom databases requests second 
requests write record read record 
applications need network redundancy handle earthquakes catastrophes 
short delay read operations particularly crucial write operations short delay 
typical delay requirements ms 
impact delay requirement disk writes transactions 
means availability requirements handled way 
thesis study method main memories ensure high availability 
probability processor nodes failing time small 
general power failures handled battery backups ensure log information sent disk battery runs energy 
disk storage needed documents news demand application email bodies attachment files set scanned objects genealogy application 
examples blobs 
necessary store event records disk 
exception applications small tuples need stored disk 
blobs attributes obviously possible separate attributes stored main memory attributes stored disk table 
solution blobs stored special blob table stored disk 
main memory data email server genealogy application demand application 
cases store control structures indexes descriptive information blobs 
requirement charging database possibility insert tuple main memory specifying move disk time timer specific request 
achieved insert main memory table followed delete insert disk table 
reliability requirements studied previous section 
charging database genealogy database draw requirements object oriented databases relevant 
need inheritance defining tables need able put queries 
need methods class attributes 
genealogy database needs complex data structures provided object oriented model 
pure objectoriented database desirable mean classes need store object id tables need attributes indexes providing object id create unnecessary large memory overhead 
mixture techniques relational databases object oriented databases desirable 
applications need informed relevant events take place database 
means support trigger mechanism included 
simplify application development support constraints automatically maintained declaration 
naturally support indexes needed especially indexes various telecom addresses addresses file names 
primary indexes secondary indexes needed unique non unique 
study application telecom database cache server www joh new requirements 
requirement discussion experienced developer database applications 
problem application needs lock tuples longer time transaction 
means database able handle locks tuples involved transactions 
locks persistent crashes 
cache server needs maintain persistent counters needed applications 
important counters handled normal concurrency control protocol 
create hot spot degrade performance 
support join queries important aspects 
charging database require 
charging database benefit updated concurrency control large queries problem 
noted disk applications create applications 
deletes occur usually tables large parts table deleted time 
simplify recovery transaction handling applications 
important features parallel data server telecom applications scalability telecommunication systems small users large users 
database telecommunication applications scalable upwards downwards 
scalability downwards achieved portability various platforms 
covered thesis aim distributed real time run time system described 
data server described thesis implemented portable run time system data server portable run time system security different kinds catastrophes times catastrophes earthquakes storms forth important telecommunication network fail 
database system telecommunication applications secure different kinds catastrophes 
high availability telecommunication network available 
lost telephone call serious matter 
databases centralised crucial high level availability 
high reliability transactions committed lost 
transaction represent income operator lost 
users telecom network accept system act told way 
load regulation overload control telecom networks built assumption subscribers active time 
means overload situations occur 
important databases scheme handle overload situations 
covered thesis item 
openness discussed thesis certainly important requirement 
necessary able reuse code tools platforms forth developed enable quick development new services 
telecom database benchmarks able develop high performance telecom database necessary set appropriate benchmarks 
benchmarks design decisions evaluated bottlenecks 
serves base performance models designs analytical models simulation models 
new benchmarks remove need benchmarks 
benchmarks tpc tpc oo database benchmarks valid discussion telecom database benchmarks 
formal benchmark definitions execution telecom database benchmark officially recognised follow formal rules set section 
benchmark results reported conform rules rules conformed explicitly stated 
telecom database benchmarks executed model seen 
assumed communication request generator lan local area network wan wide area network allowed figures lan wan separately reported 
particular requirements communication hardware 
typically communication hardware memory channel sci scalable coherent interface myrinet atm communication hardware 
delay successive requests data servers exponential probability distribution 
distribution achieved function mean mean time requests desired test random function part library delivers result random number log natural logarithm function 
deciding generate request necessary decide type request 
performed random function 
applying int floor floor function library gives largest integer smaller argument simply uses input table values data server data server communication hardware request generator request generator benchmark set delay mean log value representing percent requests 
value table corresponds request 
requests specific kind values table specifying function 
allowed pack number requests larger packet stored procedure handles number requests single request time 
allowed generates requests measured delay includes time waiting number messages packed larger packet 
delay requirement met premises 
requirements data server interface specific 
assumed kinds stored procedures data server 
request generator responsible measurement response delays measurement performance benchmark 
benchmarks parts clause tpc benchmarks fulfilled gray 
acceptable tests smaller tables normally tpc benchmark 
tests verify database benchmarked satisfies requirements atomicity transactions consistency transactions concurrency requirements system durable recoverable 
partitioning rules clause tpc benchmarks 
rule allows fragmentation tables allow vertical fragmentation tables 
clause tpc benchmarks holds clause overridden response time requirements defined various telecom database benchmark definitions 
clause defines term measurement interval 
clause defines term response time clause defines compute transactions second benchmark 
clause gives additional requirements reported results 
clause tpc benchmark holds clause defines steady state duration tests 
benchmarks require replication system 
special requirements system downtime possible telecom database possible change software hardware run time system operating system interruption service 
replication safe replicas updated local transaction 
safe supported system achieved performance figures multiplied factor way show cost reliable system 
benchmark results reported different models network redundancy 
system network redundancy cases involve network redundancy 
means update transactions executed primary telecom database backup telecom database 
telecom databases geographic distance km 
means delay communication systems placed distance km 
types update mechanism possible scenario 
uses safe transactions 
means updates sent backup telecom database transaction committed primary telecom database reporting client case request generator 
second called safe case primary telecom database backup telecom database updated part transaction telecom database nodes failed allowed benchmark 
final important issue system test contain request generators data servers 
possible architecture data server 
databases placed process application 
allowed take advantage locality way request generators 
request generators perform exactly algorithm allowed ensure accesses data server processor node 
umts benchmark develop benchmark umts necessary define tables accessed operations performed tables 
developing benchmark result preceding sections 
data definition umts user data places home database database currently visits 
home database see full service profile resides 
routing data find currently visits current registrations user 
visited database see current registrations terminal data session data stored 
table assignment temporary mobile identifiers 
redefined umts model somewhat session record session set session release record updated session status 
derive proper benchmark necessary realistic set database tables size tables necessary keys tables access rate different tables various keys 
table shown tables various procedures 
noted benchmark involves normal actions taken procedures 
specific supplementary services invoked set tables store data complex queries 
table table usage umts procedures procedure home registration table visited registration table routing table session table terminal table assign table routing table si key user status umts table home database registration table si key user profile visited session table key alt 
key keys visited terminal table di tmti key lai terminal status terminal keys registration table si key di tmti user status user profile visited umts table visited database assign table tmti key assigned step developing benchmark assess size tables 
size tables dependent number users terminals 
size estimates educated guesses 
errors impact validity umts benchmark errors access rates 
important aspect benchmark size keys 
length international telephone numbers numbers 
compacted representation possible bytes 
session table key assign table key bytes 
tables mixed keys size sixteen bytes 
visited registration table routing table contains record active registration user assume mean number 
home registration table contains record types registrations user assume mean number 
session table contains record user 
terminal table contains record terminal network estimate terminal user average 
record user terminal table 
assign table contain terminal identifiers situations assume contains records user 
size registration tables somewhat bigger rest tables 
estimate size home registration table bytes record visited registration table bytes 
records estimate bytes records assign table estimated bytes 
user originated user session set system originated user session set user originated terminal session set system originated terminal session set user session release terminal session release user registration user attach detach service management call handling location update domain update table table usage umts procedures gives bytes user reasonable estimate umts database 
information stored database various services tariff data forth 
incorporate benchmark information affect validity benchmark 
users umts database table definitions table derived 
table table derive request rates shown table 
table table definitions umts application table name record size including key number records table key size home registration table bytes bytes visited registration table bytes bytes routing table bytes bytes terminal table bytes bytes session table bytes bytes assign table bytes bytes table request rates umts application table request type size attributes exclusive key percentage requests routing table read bytes routing table update bytes routing table create bytes routing table delete applicable home registration table read bytes visited registration table read bytes visited registration table create bytes visited registration table delete applicable session table read bytes session table update bytes full scale benchmark definition full scale umts benchmark figures table sizes derived previous section 
number users users database total size database gbyte data 
top gbyte data needed index data structures 
replication overhead various kinds top required memory size benchmark system order gbyte 
request definition umts benchmark table table definitions table 
request definition table results shown table table 
requirement response time retrievals database ms response time queries update create delete ms requirement fulfilled queries benchmark test 
simple umts benchmark definition defining benchmark simplicity important 
define simple benchmark tables 
table bytes byte key size second table bytes size byte key size 
table merge session assign table 
second table merge rest 
benchmark defined table table terminal table read byte terminal table update byte terminal table create byte terminal table delete applicable assign table read byte assign table update byte table table definitions simple umts benchmark table name record size including key number records table key size large table bytes bytes session table bytes bytes table request rates umts application table request type size attributes exclusive key percentage requests table look benchmark number portability name server directory services examples table lookup applications 
basic functionality translate number address number address 
define simple benchmark define tables attributes 
data definition table attributes bytes large second attributes bytes character array 
equally requests tables 
attributes indexed possible translate number address direction 
possible translate logical physical physical logical see 
full scale benchmark definition benchmark parameters defined table table 
table request rates simple umts benchmark table request type size attributes exclusive key percentage requests large table read bytes large table update bytes large table create bytes large table delete applicable small table read bytes small table update bytes table request definition table lookup benchmark table key requested attribute percentage requests address translation physical address logical address address translation logical address physical address name translation physical name logical name address translation bytes attr 
physical address key logical address key name translation bytes attr 
physical name key logical name key table lookup tables requirement response time retrievals database ms byte addresses representative representation telephone numbers byte names representative addresses internet url addresses 
result reported number users database handle premises number requests second handled 
small scale benchmark definition small scale benchmark defined 
benchmark records table sufficient specific requirements availability reliability 
news demand benchmark news demand benchmark benchmark service read news electronic media 
basic assumption people read news manner behaviour similar behaviour person reads newspapers watches news tv 
data definition tables benchmark document table file table see 
consist set descriptive attributes format definition key information large object 
descriptive attributes key format definition document table assumed kbyte size file table smaller bytes 
name translation logical name physical name table table definitions table lookup benchmark table name record size including keys number records table key size primary key key size alternate key address translation byte bytes bytes name translation byte bytes bytes table request definition table lookup benchmark table key requested attribute percentage requests news demand tables document table name key format qos parameters file table name key format descriptive attributes descriptive attributes file document database consists documents document table size kbytes size kbytes size kbytes 
files file table size kbytes size kbytes size kbytes 
video files file table mobile model kbit sec fixed model mbit sec 
video objects seconds minutes minutes length 
contents database shown table 
benchmark definition request rates news demand benchmark shown table database definition table 
retrieval chooses documents files videos random equal probability 
delay requirement documents files sent ms videos retrieved chunks size 
chunk arrive ms chunks arrive faster kbit sec mobile model mbit sec fixed model 
email server benchmark email server benchmark benchmark multimedia email service description previous section 
table database definition news demand benchmark number documents size number files size number videos mobile model size number videos fixed model size kb kb kb mb kb kb mb mb kb kb mb mb table request rates news demand benchmark request type mobile model fixed model retrieve document retrieve file retrieve video data definition tables email server benchmark contains emails contains attachment see 
size attributes email table bytes plus size email body attributes attachment table bytes plus attached file 
pax size emails distribution bimodal mode text messages mode file transfers 
size email body distributed mode attachment files distributed second mode 
size mode mean kbyte distributed log normal distribution 
simplify benchmark size email body bytes probability kbyte probability kbytes probability 
attachments distributed log normal distribution mean distribution kbytes 
simplify benchmark attachments kbytes probability kbytes probability kbytes probability 
probability attachment probability attachment probability attachments 
assume benchmark attachments 
figures shown table format table table 
table definition email body email size percentage emails number attachments bytes kbyte kbytes table definition email attachment attachments attachment size percentage attachments kbytes email table email id key title attachment sender multimedia email tables attach table attachment id key email id name format receiver secondary key received time email body format category size attached file size full scale benchmark definition email server benchmark executed database built 
building database process run create email transactions 
transactions create email attachments table 
total users system giving total data email database building process 
receiver emails chosen random database building benchmark start executing 
types events occur email benchmark 
user connects email server check emails 
event represented control flow 
second event create email transaction 
reading deleting emails means email body properties attachments attachments read deleted 
scanning email table means email table scanned 
bytes email user returned application events connect email sessions events create email transactions table 
connect email session contains different types transactions 
connect email session starts picking user email table scanned find emails particular user 
request generator selects number emails reading emails read 
emails picked timestamp 
read transactions delayed exponential distribution 
exponentially distributed time read email transaction seconds mean value 
read transaction create email transaction issued exponentially distributed delay mean seconds exponentially distributed delay seconds number delete transaction executed 
transactions read emails deleted emails oldest timestamp deleted 
original emails deleted 
rounding closest integer upwards integers 
control flow session shown 
supported investigations marketing normal mail 
marketing papers normal mail immediately 
kbytes kbytes table request definition email benchmark procedure percentage events connect email session create email transaction total table definition email attachment attachments attachment size percentage attachments create email transaction independent connect email sessions creates email random user 
response time ms read transactions scan email table requests 
specific delay requirements delete create transaction 
simple email benchmark definition simple benchmark application decrease mean size attachments kbyte decrease number users users 
charging database benchmark common benchmark defined charging databases includes umts new demand multimedia email characteristics 
data definition data definition charging database complex applications 
way simply table event 
sufficient queries mainly asked records event type 
queries request usage records belong specific subscriber create vast need join queries system 
queries optimised particular type query acceptable 
way model system choose user random scan emails user bytes email select emails set emails test node activity database request test node activity delay exp seconds read email emails emails test node activity test node activity test node activity database request delay exp seconds test node activity create email database request select emails plus previously selected emails set emails delay exp seconds delete email emails emails session test node activity test node activity test node activity test node activity test node activity database request email session usage object tariff object 
user table contains attributes derived event records updated part transactions insert event records 
subclasses objects event type tariff type 
system needs optimised perform queries 
response queries attributes subobjects 
simplify benchmark development definition benchmark normal tables event table main memory event table tariff table user table shown 
functional requirements checked checking abilities databases benchmarked 
event table benchmark represents tables described application description event table service transaction table service transaction table 
table contains massive amount records represents disk tables benchmark 
assumed contains records size bytes start benchmark 
benchmark new records gathered 
operator normally needs store records months actual data storage bigger 
change critical part benchmark require records start 
event table main memory contains important attributes event table record length bytes 
attributes table retained generation event record time event group finished 
mean time creation deletion minutes 
means number records table half balance creation deletion reached normal amount records 
tariff table contains tariff information records kbyte size 
user table contains record user bytes assumed users benchmark 
tables simple keys bytes normally contain telephone number 
table table definition charging database benchmark table record size number records key size event table bytes bytes tariff table event table event id key event type id time subscriber id key tariff type id user id charging database data definition tariff id event group id user table user id key subscriber id foreign key current bill derived attributes event table event id key event type id time user id event group id descriptive attributes descriptive attributes tariff descriptive attributes main memory full scale benchmark definition types transactions system 
receives event records creates event record event record main memory 
second type transaction session call ended 
scans event records main memory creates new event records deletes retrieved record event table main memory retrieves data tariff table updates user table 
third transaction event records represents charging event 
similar second type transaction scan delete event records main memory necessary 
fourth type transaction retrieves data user table calculate bill 
definition transaction type transaction contains inserts event table event table main memory 
transactions type 
definition transaction type second transaction type somewhat complex generates new event records retrieves tariff information updates user table 
scans event table main memory events belonging charging event 
scan retrieves records table event group id equal entity 
type transaction create records event table main memory bytes bytes tariff table kbyte bytes user table bytes bytes table type transaction table query operation size data query query repetitions event table insert event table main memory insert table table definition charging database benchmark table record size number records key size event group id chosen way user records retrieved average 
retrieved records deleted 
transaction type represents transactions benchmark 
definition transaction type benchmark simpler type requests scan delete removed 
transaction type represents transactions benchmark 
definition transaction type represents simplest transaction 
merely reads user table finished 
represents transactions benchmark 
table type transaction table query operation size data query query repetitions event table insert bytes event table main memory delete applicable tariff table retrieve bytes user table update bytes event table main memory scan bytes table type transaction table query operation size data query query repetitions event table insert bytes tariff table retrieve bytes user table update bytes table type transaction table query operation size data query query repetitions user table retrieve bytes small scale benchmark definition small scale benchmark needs store gbytes disk data mbytes data main memory start benchmark defined table 
telecom database benchmark telecom database benchmark defined logarithmic mean number users particular telecom database handle benchmarks defined benchmark set tpc tpc oo 
benchmarks executed data replication high availability 
part telecom database applications analysed seen common sets basic operations 
set simple operations main memory database 
read write create delete objects 
second set simple operations disk databases create operations 
third set operations read write create delete set files possibly send set destinations 
fourth set comprises complex management queries issued disk database 
set uncommon operations related management system restart reload software change hardware change conceptual schema changes management operations 
means system basically divided parts 
part handles transactions recovery logging trigger management 
parts handle different types storage 
handles main memory database objects second handles disk database objects third handles transactional file system 
benchmark definitions needs refined management operations included benchmarks 
benchmarks need tested executed able refine studies telecom applications detailed level regarding data structures needed 
give input impact constraint definitions indexes telecom databases input refined benchmarks 
table table definition small scale charging database benchmark table record size number records key size event table bytes bytes event table main memory bytes bytes tariff table kbytes bytes user table bytes bytes iii architecture parallel data server part description part describes basic concepts architectures dbms telecom applications 
provides understanding basic decisions concepts architectures telecom database 
software architecture parallel data server described detail 
algorithms protocols developed thesis designed hybrid shared architecture 
important failure node disturb nodes reliable system built 
architecture parallel data server designed systems database store semi permanent data data long life change seldomly context data context information saved communications user systems 
means session data stored database 
puts heavy requirements performance response times database 
new communication technology sci scalable coherent interface memory channel gill combination building database top real time virtual machine possible 
step describing software architecture describe replication system 
levels replication introduced level internally parallel data server level parallel data servers 
called network redundancy 
secondary indexes tuple keys described preparatory section 
replication architecture shown 
replicated systems primary backup replica 
thesis introduced stand replica 
stand replica contain log 
stand replica involved transactions 
means primary backup replicas failed committed transactions lost stand replica contains log transaction 
useful systems large number nodes 
ericsson ab rights reserved data log data log log primary backup replica replica stand replica replication architecture designing distributed database support levels replication complicated requires different kinds protocols 
support stand replicas logging main memories flushing log disk creates requirements protocols set new protocols 
describing protocols describe protocols needed protocols related 
normally replicas transaction important decrease need communication 
linear commit replicas 
serious degradation response times linear commit fragments involved transaction 
new phase commit protocol developed combines normal phase commit protocol linear commit shown 
described chapter covers details phase commit protocol read queries handling secondary indexes foreign keys 
step describe protocols needed line recovery reorganisation 
online recovery mean processor node fails system tries achieve replication failure set replication protocols 
line reorganisation includes set protocols change fragmentation replication adding dropping processor nodes 
protocols enable better load regulation system 
achieve non system necessary able change schema service interruption 
involves able maintain complex relationships tables tables split merged 
solution requirements 
basic idea perform complex schema changes steps 
step creates new tables attributes set foreign keys special attributes triggers needed perform schema change 
saga table complex schema changes recoverable consistent primary backup systems 
phase commit protocols necessary new protocols needed support network redundancy 
systems crash necessary able start system crash 
crash means processor nodes system failed backup system take 
information crash recovery created normal operation 
involves logging checkpointing 
tc commit committed prepare prepared prepare commit new phase commit protocol sections dedicated describing new indexes lh distributed compressed tree tree 
shown indexes play important part line recovery protocols 
lh optimised fast execution time optimised tree optimised low memory requirements space optimised 
basic architectural decisions section gives overview important issues design parallel dbms 
presents basic architectural decisions underlie design telecom database 
includes parallel database architectures client server architecture efficiently database session data context data interface types data server transaction concepts handling replication concurrency control logs data server phase commit protocols produce archive copies 
parallel database architectures literature number different architectures parallel databases described 
shared memory shared disk shared hybrid ones 
description architectures best meets requirements telecom databases 
see dewitt overview parallel database systems 
shared memory shared memory architecture processors share common memory number disks seen 
due development processors solution quite infeasible cache memories processors 
creates need cache coherence protocol interconnection network 
common architecture supported major suppliers dbmss 
servers architecture delivered major hardware suppliers sun digital ibm forth 
advantage shared memory structure easy balance load 
easy port dbms single processor implementations data common single processor 
parallelism easy obtain 
intra query parallelism needs new algorithms relatively simple 
shared memory architectures disadvantages 
limited extensibility 
processors memory structures 
seen semaphores serialize access memory bottlenecks number nodes increases valduriez 
problem achieve faulttolerance memory disks need replicated 
difficult problem overcome achieve reliability processor node software error corrupt data system 
shared memory architectures easy way extend current dbmss parallelism limited extent 
solution systems high requirements fault tolerance high performance 
shared memory architecture interconnection network disk disk main memory main memory processor processor shared disk shared disk approach processor main memory accessible nodes seen 
disks common processor access disk 
major difference shared disk compared shared memory main memory private faulty processor possibility write processor memory 
solves major availability problem shared memory architecture 
introduce complex coherence problem disk buffers 
shared memory structures shared disk architecture scales better shared memory architecture 
shared disks limit scalability processor nodes valduriez 
achieve availability essential disks doubled possibly 
shared disk architecture handle requirements fault tolerance cases performance requirements 
advantage load balancing greater complexity administering disk buffers 
complicated achieve software changes structures disks changed 
shared shared means processor access disks memory communication nodes message passing seen 
means system viewed homogenous distributed database system 
research distributed database systems reused shared architectures 
data structures shared data contention scalability 
data replicated contention processor resources limits scalability 
scale thousands processors load balancing multiple replicas data valduriez 
shared disk architecture main memory main memory processor processor interconnection network disk disk shared architecture interconnection network main memory main memory processor processor disk disk processor node processor node availability failure processor node affect processor node apart erroneous messages error checking reception messages 
shared architecture contains complex functions 
shared architecture provides possibilities improve availability 
require software solutions 

shared architecture provides possibilities improve availability scalability 
necessarily easiest implement 
hybrid architectures ways combine shared memory shared disk shared architectures 
interesting thesis combine shared memory shared having cluster processor nodes processor node shared memory architecture 
computer architecture world shared memory architecture called symmetric multiprocessing common method increase performance workstations 
shared memory architecture inside processor node problem availability 
scalability solved shared architecture 
shared memory structure processor node powerful processor nodes necessary 
scalability improved compared shared architecture 
hardware shown called workstation clusters 
requirements high performance scalability high fault tolerance short response times necessary communicate quickly processor node 
accomplished new communication techniques sci memory channel gill 
database vendors hybrid shared model achieve reliability 
normally systems primary node backup node 
nodes multi processor node 
disks physically shared 
processor node set files 
disks logically separated physical sharing disks 
shared memory architecture accomplished computer architecture shared disk shared architectures having cache coherency protocol interconnection network 
architecture shared memory shared disk shared dependent software structure 
software processors access data hybrid shared architecture interconnection network main memory main memory processor processor disk disk processor processor processor processor processor node processor node machine shared memory architecture 
software gain access memories disks architecture shared disks memories disks accessed locally shared architecture 
thesis shared model 
system may symmetric multiprocessor machine shared memory architecture 
reason choosing architecture need high performance scalability high fault tolerance telecommunication systems 
build system desirable clean interfaces modules interaction message passing 
implies node operating system distributed operating system desirable 
reason having multiple processors system fact unit system board 
technology possible build processors single board 
teradata potential successor dbc uses example processors board shared memory 
intel standard high volume server example processors placed board common memory 
example high performance server ultra server processor server 
possible shared disk architecture 
scalability solutions availability necessary 
client server technology number reasons client server technology 
reason provide specialised services applications 
examples file servers printer servers email servers database servers 
servers provide clients possibility mobile clients heterogeneous communication clients servers performed messages 
issues security cost efficiency organisational benefits important 
section concentrate database servers 
tor guidelines client server design proposed 
server interface general independent application 

client server communication protocols adhere international standards transport level application level support heterogeneous clients 

communications insensitive delays 
data volume sent low 

possible processing done client side achieve high server throughput low latency 

easy program point analysis important due technical breakthroughs technology sci scalable coherent interface communication costs systems decreased cheaper internal communication processes operating system 
designing telecom database clients servers application servers email servers web servers forth 
point need great importance division database server application server 
common ways separate functionality client computer computer database server shown 
scenario common object oriented dbmss long transactions objects checked needed checked completed 
scenario access data telecom switch 
telecom switch needs fast access data uses cached copy data updates propagated database server 
applications access data applications data dbms 
small update transactions heavy communication costs scenario 
scenario standards iso sql rda trying accomplish 
clear separation client computers handle application computers handle dbms 
scenario solution tries minimise communication client server performing processing data server 
thesis distinguish stored procedures methods 
stored procedures operate data database procedural language 
interface useful stored procedures perform algorithms data needed 
implementing language interpreter database server clients crash database server writing erroneous stored procedures 
tpc needs functionality performance charging server stored procedures 
scenario separation client server application dbms functionality separated 
proprietary systems 
analyse scenarios reliability point view see scenario support stored procedures interpreter database server promising scenario 
database queries scenario perform application server 
major benefit programming errors application small impact reliability database server 
reliability database server high code database server thoroughly tested 
dbms dbms dbms dbms application communication communication communication application application application client server client server separation functionality dbms communication application capacity point view scenarios similar performance characteristics 
chosen scenario benefits database server full control processor resources cache memory resources memory resources resources 
gain advantage performance 
analyse scenarios soft real time performance mind see scenario give best real time behaviour 
possible processing job performed processor 
priority scheduling jobs high priority quickly taken care 
cases communication processors processes means job split tasks task queued execution 
tasks execution time greater variance delay job 
difficult priority job consists tasks 
problem alleviated extent rapid development processors communications memories 
delay executing job rapidly decreasing making easier meet real time requirements 
furthermore telecom applications soft real time requirements 
means long delays acceptable long occur 
possible distinguish read transactions update transactions 
possible optimise transactions 
scenario benefit transaction coordinator aware records attributes updated sending update requests 
execution triggers updates secondary indexes foreign keys performed parallel actual update 
scenario useful storing complex data types supported dbms 
data stored blobs searches data performed user provided function execute database server 
server architecture study applications shows applications applications need simple query interface 
management applications need complex query interface 
divide database server parts call data server query server 
data server data stored simple interface applications query server 
query server contains logic perform complex queries data server interface 
query server act gateway data sources data sources system 
query server accessible standardised protocols enable open management platform 
layering similar design dbmss storage manager handles storage data recovery concurrency simple search functionality 
data server corresponds distributed storage manager 
query server contains functionality handle complex queries joins various advanced queries 
separation functionality decrease complexity data server gain higher reliability 
layering various servers shown 
shows interface data server handles accesses data 
application gain access data directly data server send query query server accesses data server 
network protocols access data application protocols query server protocol directly access data server 
management server protocols mentioned 
protocols telecom database protocols supported telecom database 
see application protocols query server protocol data server protocol 
discussion derive architecture shown clusters data servers query servers application servers management servers 
set application servers course wide servers support various communication protocols various communication services forth 
various application servers issue thesis mainly concentrate build parallel data server support telecom applications 
applications query server data server telecom database protocols telecom database parts management server data parallel data server parallel query server parallel application server parallel management server high performance communication network ericsson ab rights reserved telecom network communication gateway client server architecture major benefit architecture provides server contains data data server 
servers contain uncommitted data transient data logic 
application management servers contain hardware communication links considered thesis 
accomplished application query management server uses data server store permanent data 
need hardware redundancy servers 
data server implemented hardware redundancy shown section 
means need computers hardware redundancy means ordinary server computers interconnect reliable communication network 
provides price performance ratio telecom databases 
session database important feature load balancing able choose loaded server serve client requests 
achieve servers access information 
accomplished storing session information database 
application session client session data stored data server application waits client action 
means time client request arrives part session server chosen serve request 
data server context database shown 
telecom systems configured shown 
communication servers need keep information application server contains session data reliability needed parts system 
communication server choose loaded application server 
architecture puts heavy requirements data server terms response times performance 
supporting type architecture essential part design parallel data server described thesis 
client server server request response request response context database read write context database network redundancy discussion previous section reliability deduced reliability provided parallel data server sufficient 
necessary provide redundancy able handle environmental faults operational faults 
example earthquake destroys parallel data server 
survive type fault necessary provide redundancy network level 
parallel data server support network redundancy reliable data stored telecom databases seen 
solution network redundancy adopted small changes act replication mechanism applications 
example application mirroring web servers 
interface types dimensions interfaces 
dimension application interface actual database interface defined 
second dimension network interface contains specification interface send retrieve application messages 
communication servers application servers data servers common system architecture data server data server data server data server data server data server application server application server application server application server application server application server telecom database telecom database network redundancy database interface dimensions 
dimension defines protocol data server 
simple interface possibilities read insert update delete data 
contains functionality define new data tables database 
second dimension interface query server 
interface functionality placed support complex queries support standard interfaces 
network interface dimensions 
dimension interface internal network communication optimised local communication 
second dimension interface external network communication wide area networks support communication adopted standards local environment 
interface data server data server place actual data stored 
supports high levels reliability support applications high requirements performance 
possible interface general applications interface query server 
possible applications common queries 
generic interface data server fast path interface data server 
fast path interface invocation stored procedure optimised particular application 
generic interface uses identities names tables attributes 
possible support execution programs data server interface data server 
implemented having interpreter data server 
data server distributed architecture definition application specific interfaces available nodes may interface 
stored procedures interact distributed nature dbms distribution data data server 
interface query server query server complex queries executed serve management servers application servers 
reasons query server 
advanced functionalities query server support complex triggers complex queries 
provide interface database server look relational dbms object dbms knowledge dbms type dbms 
lastly purpose provide standardised interface applications sql odbc omg standard 
various uses query server shown 
interface internal network interface internal network optimised local communication 
give efficient support interface uses distributed shared memory implement message passing processor nodes 
advantages scheme messages sent internally telecom database need go operating system 
type communication op data server generic interface read update delete insert transactions fast path interface fast path generic interface stored procedures data server interfaces erating system involves kernel trap high price tag 
involves context switches operating system processes 
involves copying data user space kernel space involve copying data kernel space 
involves standardised protocols tcp ip 
furthermore implementation protocols operating system normally performed calculating checksum software 
costs lot performance 
distributed shared memory available processor nodes communication network handles error situations hardware 
communication performed application process context switches kernel traps needed 
examples interfaces sci scalable coherent interface memory channel gill 
interface internal network interface visualised 
interface internal network supports distributed shared memory put 
useful applications request large data structures data server avoid passing message passing interface 
performed providing pointer memory space object resides 
memory space normally locked processor nodes opened request passing large data structures blobs binary large objects file 
objects transferred mechanisms higher bandwidth achieved messages 
interface external networks telecom database provide interface external world 
interface conform international standards wan networks wide area networks tcp ip communication internet applications ccitt communication telecom applications standards forth 
protocols carried protocols wide area communication support high bandwidths atm asynchronous transfer mode sdh synchronous digital hierarchy 
issues involved discussed thesis 
interface external networks handled communication gateway shown 
gateway function exist processor nodes implemented separate function specialised hardware 
data server query server generic interface stored procedures knowledgebase objectbase sql odbc omg interface query server communication buffers shared memory main memory blob protected area parts opened internal network interface processor node processor node interface application servers interface application servers common way access telecom database 
interface represents functions application get html file update location mobile terminal insert event record forth 
interface implemented top external network interfaces 
common application protocols hypertext transfer protocol tcp ip smtp tcp ip map mobile application part ccitt application part ccitt forth 
examples protocol stacks application protocols shown 
mtp message transfer protocol lower layers ccitt protocols 
add mtp provide logical network addresses 
mtp uses physical network addresses 
transaction oriented add provides transaction protocol services application protocols 
aal adaption layer top atm transporting data packets top atm 
ip internet protocol internetworking protocol internet 
tcp transmission control protocol transaction protocol service top ip 
protocol world wide web smtp protocol emails 
tcp udp user datagram protocol 
udp provide secure delivery mainly small datagrams tcp seen overkill 
interface management servers management applications telecom database accessed interfaces common interface telecom applications interface 
interface possibility read update insert delete data objects events reported 
transaction protocol interface 
transaction concepts transaction concept powerful concept heavily applications 
extensions basic transaction concept possible 
applications consider type presentation presents basic transaction types 
flat transactions type transaction called flat transaction 
flat transaction atomic unit processing performed 
flat transaction acid properties acid atomic consistent isolated durable 
mtp layer mtp layer mtp layer map mtp layer mtp layer mtp layer atm layer aal ip tcp atm layer aal ip tcp smtp application protocol stacks atomic property says actions transaction performed 
consistent property sure roll back transaction data structures kept consistent 
consistent property assumes transactional modifications application consistent properties database 
isolation property gives transaction program view program accesses database 
common isolation property serialisability 
set transactions executed parallel behaviour transactions executed serial order 
means possible see intermediate states transaction transaction 
durable property means transaction committed actions transaction durable case system failures 
losing data committed transactions serious failure 
database inconsistent 
normal action happens restart system archive copy 
flat transaction transactions applications flat transactions sufficient 
management transactions internal transaction seen transactions 
idea transaction rolled back start transaction 
advantageous large transactions complex transactions needs roll back previous state transaction 
example application travel booking system 
persistent system restarted live transaction complex support 
distributed transactions assumptions telecom database distributed system necessary update processor node flat transaction 
means need distributed transactions 
common way proceed phase commit protocol 
protocol part transaction standards description protocol bhg 
necessary optimised versions phase commit protocol versions protocol higher reliability blocking 
major reliability problem twophase commit protocol coordinator fails 
leave transaction unknown state means resources transaction kept coordinator restarted 
clearly desired shall situations means choose new coordinator case coordinator fails 
coordinator retrieve sufficient knowledge transaction decide transactions commit abort 
necessary optimised version phase commit protocol decrease load system cost slightly higher delay 
transaction protocol important contribution thesis described chapter 
shown integrate phase commit protocol network redundancy copies data reside telecom database 
replica handling distributed transactions phase commit protocol developed coordination transactions consisting updates data residing processor node 
update replicas data part transaction requires method maintaining copies 
common way handle copies read write available method 
means read performed copies update available copies updated 
methods reading writing quorums copies systems nodes node low availability 
helal methods 
distinction copies updated inside transaction soon possible 
updates inside transaction called safe soon possible called safe 
section normal flat transactions sufficient applications 
building parallel data server necessary distributed transactions 
transaction protocol important issue needs study thesis achieve balance quick responses low communication overhead 
processor nodes seldom fail method updating replicas data 
theory concurrency control concurrency control needed isolate transaction programs execute parallel 
bhg gray contain deeper studies concurrency control 
databases means users able access database simultaneously view respective execution currently active database 
important laws concurrency control important follow implementation gray concurrent execution application programs cause malfunction 
concurrent execution application programs lower throughput higher response times serial execution application programs 
resources spent researching various ways achieve concurrency databases 
methods developed basically divided dimensions 
dimension locking methods timestamp methods 
locking methods works locking records point transaction transactions possibility access records records unlocked 
timestamp methods ensure execution transaction ensuring updates records follow increasing timestamp 
dimension method pessimistic optimistic 
pessimistic methods mainly achieve execution waiting resources accessing records 
optimistic methods access records directly validate execution correct transaction 
execution incorrect transaction aborted 
pessimistic methods abort cases mainly due deadlock situations 
research performed implementations locking methods pessimistic 
exceptions rule mainly optimistic locking methods 
common method strict phase locking described 
reason concurrency control method highly affects algorithms dbms 
locking methods easier integrate logging recovery distributed transactions 
pessimistic methods development distributed replication recovery algorithms straightforward 
applications discussed previous part thesis locking record level problems foreseen hot spots 
possible hot spots occur course counters 
heavily application alternative concurrency control methods considered data bern 
performance pessimistic locking problem locks integrated index structure 
extra cost locking 
thesis concentrate pessimistic locking methods behaviour replicated databases 
ways allocate locks method allocate locks start transaction called static allocation locks 
useful systems known early records included transaction 
systems case common method dynamic allocation locks case record locked known going transaction 
pessimistic locking methods means record locked immediately record time transaction 
presentation assume dynamic allocation locks performed 
transaction dependencies actions performed dbms 
database actions read update delete insert 
categorised read write actions 
support increment decrement database actions third category delta bern 
actions transactions prepare commit rollback 
various transactions shown delta operations behave writes relation reads writes 
bad dependencies dependencies avoid isolated system 
lost update occurs transaction reads object uses read update object 
transaction possibility write object read write write lost overwritten transaction 
write second transaction lost 
second bad dependency comes transaction writes object writes rollback second transaction reads write reads committed reads dirty object 
transaction dependencies lost update third bad dependency occurs transaction reads object twice transaction writes object reads 
called reads reads transaction deliver result 
shown dependencies avoided execution transactions isolated 
locking theory transactions execute isolated follow rules 
objective rules ensure execution number transactions parallel serialised 
saw previous section bad dependencies need avoided accomplish 
opted pessimistic locking means lock held actions taken database objects 
shared locks read exclusive lock write delta locks delta 
table compatibility matrix locks shown 
proceed definitions definition transaction formed read write delta unlock actions covered locks lock action eventually followed corresponding unlock action 
definition transaction phase lock actions precede unlock actions 
means transaction phases growing phase locks acquired shrinking phase locks released 
important locking theorem proved gray bhg locking theorem transactions formed phase transactions isolated history serialised 
table lock compatibility matrix compatibility shared exclusive delta shared compatible conflict conflict exclusive conflict conflict conflict delta conflict conflict compatible dirty read read proof theorem showing dependency graph transactions contain cycles transactions formed phase 
cycle dependency graph transaction executed transaction history 
interesting extension strict phase locking scheme telecom databases multiple versions data 
old versions transactions read data 
transactions large query transactions simple read transactions 
reading old version data ensure concurrency problems 
read transaction find data read 
elaborated section 
degrees isolation problem strict phase locking application read large part database making parts database inaccessible write transactions 
desirable databases users 
applications need full serialisation lower degrees isolation sufficient 
levels isolation defined degrees 
degree degree transaction overwrite transaction dirty data transactions degree higher 
degree transactions lost updates 
degree transactions lost updates dirty reads 
degree full isolation provided strict phase locking 
leads locking protocols degree transaction locks data writes releases write lock soon finished write 
degree transaction locks data writing 
keep lock commit time 
degree transaction sets write locks properly acquires read locks reading 
release read locks immediately reading data 
degree transaction release read locks transaction committed 
means degree transactions provide benefits repeatable reads seldom necessary large query transactions definitely small transactions 
transaction degree interest 
degree transactions read uncommitted data avoided 
degree transactions get higher concurrency reading old version data data write locked 
degree transaction reads object updates object release read lock directly reading 
read lock released immediately lost update occur means transaction degree 
dependency graph cycle isolation concepts issue lock tuple level lock page level 
applications update activity performed new objects users updating data 
tuple locking decrease contention locks 
page locking increase contention considerably respect frequency update activity applications 
issue locking pages fit distribution data complications due locking pages 
locking performed tuples 
issue support delta locks add subtract supported locking protocol 
uses add subtract applications investigated decided avoid complexities delta locks introduce 
statistical attributes case delta locks useful 
possible solve problem statistical attributes means 
ordinary pessimistic lock methods strict phase locking 
reading data performed kind time stamp needed increase concurrency reads 
desirable telecom applications avoid unnecessary waiting 
reading old consistent version data acceptable means waiting locks introduced 
log handling reason logs need atomic durable transactions reasons discussed thesis 
transaction updating data objects atomically simply overwriting old data 
methods achieve durable atomic transactions 
methods log 
methods perform updates updates performed atomic write operation 
called shadowing performance problems gray logs useful system crashes needed recover old version database 
log records involves parts redo part undo part 
redo part recovery update data object reflected durable media disks 
undo part data object written decision abort transaction taken 
old state new state old state new state old state new state undo redo log record log record log record undo redo protocol methods redo undo part undo redo algorithm undo redo algorithm undo redo algorithm undo redo algorithm shadowing gray 
undo redo algorithm flexible algorithm pages written durable storage time uncommitted data stale data data pages 
wal write ahead log rule obeyed 
states dirty page written disk log records belong dirty writes flushed disk 
log recover date version data objects 
undo redo algorithm requires updates reflected durable data pages commit 
pages contain updates transaction flushed durable media commit 
undo redo algorithm requires data page durable media contains uncommitted data 
dirty pages flushed disk 
undo redo algorithm requires pages disk contain committed updates date 
means dirty pages flushed disk committed 
transaction commits pages written atomic transaction 
postgres sullivan uses scheme having versions tuples pages 
means committed value new uncommitted values disk pages 
technique shadow technique system gray 
bhg describes variants logging detail 
disk databases undo redo algorithm commonly 
main memory databases common undo redo dali dbn dbs main memory easily working record transaction commit simply install date version 
redo part needed main memory durable medium enable crash recovery old version database needs installed 
undo redo algorithm benefit log records smaller improves performance database logging substantial part load database 
implementation logs lsn log sequence number 
number basically primary key log record 
undo redo algorithm log record undo transaction aborted 
part log record 
undo redo necessary know start reading log recovery needs order log records possible find points log 
points start log file lsn 
log contains redo information started recovery start point read log marker log 
delta locks lsn give idempotent log records log record applied tuple lsn read update insert delete operations idempotent 
log basically append file grows time 
files grow implementation done set files file full log moves file 
lsn usually consists concatenation file number byte address file log record placed 
undo redo algorithm combination necessary introduce clr compensation log records able get increasing lsn number records pages clr log undo update 
clrs needed undo redo algorithm undo log records performed 
avoid forced redo log log checkpoints system knows transactions checkpoint installed data pages 
means restart necessary perform redo log checkpoint log records installed data pages 
ways achieve checkpoints transaction consistent checkpoints action consistent checkpoints fuzzy checkpoints 
transaction consistent checkpoints means checkpoint disk contains committed updates 
action consistent checkpoints means data disk contains uncommitted updates database operations completed 
means data disk consistent remain uncommitted updates 
fuzzy checkpoints guarantees consistency contain uncommitted updates 
normal implementation transaction consistent action consistent requires updates data pages postponed duration checkpoint clearly undesirable highly available system 
fuzzy checkpoints 
action consistent checkpoints transaction consistent checkpoints achieved combination fuzzy checkpoints logging physical page updates 
performed informix online dynamic server informix dali dali 
fuzzy checkpoints created writing checkpoint log record writing data page time disk means data pages written disk transactions preceding checkpoint log record flushed disk 
crash occurs checkpointing system start checkpoint log record completed checkpoint 
log information redo undo information specifies update database information different types gray 
old state new state old state new state undo redo log record log record idempotence log operations type called physical logging means updates data structures internally dbms logged 
basically means updates pages logged 
means logical update operation result updates pages log records 
simple method requires large amount log information 
type logical logging 
scenario logical update logged information updates pages logged 
creates problems atomicity database update contains number updates pages single update 
difficult create atomic update pages performance 
third type mixture previous called physiological logging 
scenario log information logical pages physical pages 
log records describe logical operations pages updated 
log handling distributed systems distributed database new problems new possibilities occur needs handled 
method decrease load disks undo redo algorithm neighbour wal 
means updating log main memories log safe disk 
means writing disk necessary log pages full 
undo redo normal phase commit protocol sufficient ensure reliable data storage 
data replicated updated main memories ensure update lost 
issue comes requirement automatic recovery node failures 
boils able move copy fragments processor nodes 
means log records created processor node able recover processor node 
means log records location replication independent 
accomplish log records logical involves problems 
problem logical log records checkpointing process action consistent undesirable 
overcome problem log divided local logs physiological fragment logs logical 
local log contains log updates pages local node 
fragment log contains updates database records 
local log create action consistent state needed execute logical fragment log 
shown 
node log node log copy fragment log fragment fragment log fragment node log node log copy fragment log fragment fragment log fragment location replication independent log records problem handle fragments split joined fragment logs handle 
solved putting split log record fragment log fragment similarly join log record put fragment log fragment joined 
necessary location replication independent log records updates database 
internal updates pages logged local log 
previous implementations concept local logs combination undo redo log informix dali tor 
undo redo new ideas tuple storage 
undo redo semantically rich locking schemes updates idempotent updates performed times record risk inconsistency 
simplifies recovery algorithms 
phase commit known method achieve distributed transactions phase commit 
phase commit consists phases concerned committing transaction 
phase updates transaction performed 
second phase asks participants prepare part transaction commit reply possible 
promise commit transaction told 
participants voted third phase commits transaction transaction aborted 
protocol actions shown 
participants transaction number sub participants controlled knowledge coordinator 
coordinator participants organised hierarchical scheme seen 
coordinator participant actions start update prepare local prepare write prepare record vote propose commit abort write decision log commit rollback local commit write completion record log lazy send ack durable acknowledge write completion record log log force lazy force phase commit protocol root coordinator participant coordinator participant participant participant session branch hierarchical phase commit proceed show optimisations extensions phase commit protocol useful reliable telecom database 
transfer commit issue possibility transfer commit decision 
useful situations client unreliable server reliable 
clearly desirable user home pc able commit coordinator telecom database 
clearly produce undesirable reliability characteristics telecom database 
read commit optimisation transactions read prepare phase needed 
commit phase needed release locks read participants read write transactions optimisation 
linear commit optimisation performing full phase commit protocol contains messages 
optimisation decreases number messages involved phase commit linear commit bhg 
gives higher delay decrease communication costs transaction 
optimised communication schemes thesis desirable decrease communication cost 
linear commit optimisation performs transfer commit participant sending prepare message way final participant receives prepare message 
notes chain commits transaction sends commit decision back participants see 
complete phase protocol piggy backed messages telecom database 
non blocking commit coordinator final extension phase commit protocol need avoid reliance commit coordinator 
lead participants blocked coordinator restarted locks kept long time decreases system availability 
avoid backup coordinator transactions shown 
scheme decision taken primary backup coordinator recorded decision 
primary coordinator fails backup coordinator take immediately commit decision taken informing backup coordinator 
coordinators fail get blocked situation coordinator knows status transaction 
prepare prepare prepare commit commit commit linear commit optimisation design relies high availability transaction blocked easily 
normal phase commit protocol transaction blocked transaction coordinator fails 
clearly acceptable 
approach non blocking commit coordinator 
approach taken 
create performance overhead desirable 
choose method system coordinator new transaction coordinator failure transaction coordinator described chamb 
new transaction coordinator creates status transaction asking processor nodes supply information transactions transaction coordinator failed 
node knows commit decision transaction committed 
participant prepared transaction aborted 
transactions prepared participant committed status transaction unknown 
data server coordinating transaction transaction aborted situation rare cases 
data server participant transaction distributed systems transaction aborted unknown state 
traditional phase commit protocol benefit low delay 
linear commit benefit smaller communication overhead larger delay 
replication structure normally involves replicas data written fragments involved transaction 
tpc typical example transaction gray 
linear commit increase delay 
normal phase commit protocol advantageous delay point view increases number messages tpc transaction fragment replicas 
solution mixture normal phase commit protocol linear commit protocol 
internally replicas fragment linear commit 
fragments normal phase commit protocol 
gives extra delay decreases number messages tpc transaction 
simple transactions involves fragment commit protocol degenerates linear commit protocol 
case optimisations performed decrease number messages 
prepare ack prepare prepared commit ack commit committed completed ack primary coordinator backup coordinator participants non blocking commit coordinator archive copy production create archive copy necessary able recreate consistent state distributed database 
perform necessary point time decided transaction happened time 
call time global checkpoint 
checkpoint transaction consistent 
way simply broadcast message cease commit processing insert checkpoint logs commit processing continue usual 
new global checkpoint written disk lazy manner assure system stops commit processing short time 
archive copy transaction consistent created reading database checkpoint preceding global checkpoint restore apply log records smaller global checkpoint global checkpoint restore 
sophisticated methods smaller impact delay transactions invented dbn 
systems processor nodes delay creation global checkpoint done millisecond sufficient seriously impact real time behaviour 
assumes real time run time system priorities 
system architecture parallel data server section thesis system architecture described 
encompasses description replication structures data various protocols needed relationships 
handling keys schema fragmentation secondary indexes 
replication structure section describe replication structure 
replication levels internal system second systems 
show replication method internal system 
models assume mean time failure mttf processor node months due software failures failures decrease mttf months 
repair time hour mttr 
mttf report japan discussed gray mttr structure recovery done copying process primary node new backup node 
local replication structure ideas section developed discussions malik details error handling malik 
distributed databases replication objects fragments table 
fragment contains subset table 
fragmentation function described section 
section presume fragmentation performed possible deduce replicas fragment reside type 
common method replicating information primary node hot stand node 
call hot stand node backup node article 
provides reliable operation 
probability primary backup node failing time small 
primary backup node fails fragment committed transactions lost write disk log involved commit process 
consistency system causing shutdown system 
system fails case nodes fail time 
assuming mttf mttr calculate probability shutdown system hour number hours months number processor nodes system 
shutdown causes system unavailable hours shutdown system acceptable years system operation 
means greater reliability requirements longer met 
avoid problems reliability requirements scenario write transactions disk commit time primary alive 
lead transactions suffer long delay performance impacted failures 
means primary backup strategy possible fulfil delay requirements reliability requirements 
reliability requirements important probability transaction meeting delay requirements 
factor comes fact transactions affected node crash 
transactions try access fragment primary backup failed node 
transactions consist operations probability missing delay requirements increases 
write disk commit process creates performance overhead 
overhead writing disk block similar execution database requests processor nodes 
overhead comes time node failed case primary node overhead assist creating new backup node 
solution problem backup nodes 
creates increase price system acceptable 
memory needs triplicated case 
solution problem introduce third type replica stand replica call owner replica stand node 
stand node participates transactions logs transactions 
similar idea 
difference log records sent stand node committing transaction 
type replication referred safe 
case stand node involved phase commit protocol type replication referred safe 
stand node stores log records transactions 
log records sent disk soon possible causing performance overhead 
small log buffer needed main memory 
processing stand node small cause large performance overhead 
relies assumption communication processor nodes cheap 
case 
tcp ip messages ethernet cost order execution database requests 
new technology sci gill possible send messages shared memory processor nodes 
decreases load communication factor factor 
communication costs severe performance problem 
replication structure shown 
benefit stand node primary backup nodes crashed stand node ensures system available 
fragments data server unavailable system available 
stand node restart new primary node 
stand node needs access archive copy addition log records restart new primary node 
restart primary backup nodes costly process data log data log log primary backup replica replica stand replica local replication architecture involves creating date replica data 
creation process take hour size database large 
start stand node easy performed seconds 
option primary node stand node 
provides reliability availability low 
replica primary node called primary replica 
updates start primary replica write locks granted 
primary replica fails new primary replica assigned take able continue processing transactions 
primary replica involved read operations part updating transactions 
shown system replicas involved read operations updating transactions replication global level 
replicas backup nodes called backup replicas 
backup replica todate part update transactions fragment involved 
replica contains locks data 
reason backup replica special read operations 
handle read commit tuple read degree 
handle readonly transactions degree 
means reads backup replica hold lock tuple reading tuple read lock released 
deadlock situations introduced due reading backup replica 
simplify handling failures backup nodes 
backup node contain unique data read locks failure backup node easy handle 
able perform simple reads backup node introduces possibility load regulation seen telecom applications contain simple read transactions 
conceptual model distribution fragments telecom database shown 
replicas primary replica backup replicas stand replicas telecom database safe participate phase commit protocol 
local fragment local fragment copy distributed index tuple sd belongs part part pa rt index cardinalities number pds number bds number sds number fragments distributed index number local fragments global fragment number tuples local fragment number tuple global fragment number distributed indexes global fragment rules invariants distributed index user defined relations pd processor node stores primary replica local fragment primary data node 
bd processor nodes stores backup replicas local fragment backup data node 
sd processor nodes store stand replicas local fragment stand data node 
pd bd global fragment local index part part prn conceptual model local distribution fragment log records part contains prn processor node local fragment primary replica backup replica stand replica 
local fragment part global fragment distributed secondary index 
seen global fragment part table stored view globally distributed index 
deduce architecture fragmentation functions 
fragmentation function fragments table telecom databases fragmentation function fragments global fragment telecom database 
local fragment part global fragment global fragmentation function ensure tuples local fragment part global fragment 
thesis local global fragmentation means mapping global local fragments 
requirement simplification thesis great impact long global replication protocol standardised 
telecom databases developed different vendors cooperate fragmentation scheme 
global replication structure telecom databases mainly concerned providing safety catastrophic situations methods develop globally distributed databases 
support catastrophic situations extra copy usually sufficient 
copy possible start soon possible stand replicas case 
primary replica system level stored primary system 
backup replica system level stored backup system combination safe safe transactions 
decision data involved transaction 
decision data safe safe decided application developer 
decision attribute level updates involving attributes safe means transaction safe 
attributes involved transaction execute safe 
applications need line replica stored line system receives transactions safe 
receive transactions delayed manner 
discuss types global replicas primary replica backup replica line replica 
global fragment tdb global index tuple ps bs belongs part part part index cardinalities number pss primary systems number bss backup systems number oss line systems number global indexes table number global fragments global index number global fragments table number tuples global fragment number tuples table number tables database rules invariants user defined relations ps tdb stores primary replica global fragment primary system 
bs stores backup replicas global fragment backup system 
os stores line replicas global fragment line system 
table stored view conceptual model global distribution os tdb telecom database local fragment states better understand reliability availability features model state diagram local fragment shown 
state avoided unrecoverable state 
state reached committed transactions lost consistency database unsure 
system shut restarted checkpoint transaction consistent 
restart procedure described thesis 
states recoverable shutdown system necessary 
fragment available user queries accessible 
primary replica fragment accessible state inaccessible state 
time node fails state fragment goes unsafe states 
node failures correlated nodes immediately force log disk failure situations force log disk commit certain period time node failure 
node completed force log disk state reaches safe states 
primary replica replicas fragment unprotected state protected state 
unprotected state log forced disk commit node copy 
accessible safe states recovery procedure start state goes means recovery process ongoing 
fragment state recoverable unrecoverable accessible inaccessible active active backup stand unsafe stand stand safe unprotected todate active backup safe active backup unsafe switch date todate safe todate unsafe protected state diagram local fragment primary replica backup replica fragment active backup state 
reaching safe state backup replica promoted primary replica recovery process start 
primary replica backup replica available stand replica available fragment reaches active state 
reached safe state recovery process start protocol promote stand replica primary replica 
protocol node contains archive copy fragment saved disk 
stand node contain waits processor node contains archive copy restarted 
restarted node protocol promote archive copy primary replica archive copy log saved stand replica 
unusual case stand node fails stand safe state state stand 
state primary replica backup replica stand replica 
information available disk start new primary replica losing committed transactions 
system continue operating fragment unavailable 
example local distribution shown 
important issue replication structure handle failures 
approach soon failures occur system reconfigure 
node fails fragments left backup replica reaching date unsafe state 
am alive protocol described section finds node failed system coordinator distributes information 
node primary configurator decide new distribution replicas 
assume decides create new backup replica node new backup replica created node copy fragment protocol described section 
node fails backup replica node created recovery process lost fragment reaches state active backup unsafe 
backup configurator promoted primary configurator decides new distribution replicas 
promote replica primary replica 
node node node node node primary node stand node backup nodes example fragment distribution primary configurator backup configurator replication global level state machine local fragments connected state machine global fragment belong 
local fragment state goes unrecoverable system longer usable 
state reached backup system backup system take primary system going shut restarted 
backup system goes unrecoverable backup system restarted 
inaccessible states primary system active backup active states affect state global fragment temporary solved aborting transactions 
state stand allowed backup system 
stand node backup system backup system participate transactions committed primary system 
backup system unrecoverable goes state stand 
related replicated databases uses primary hot stand architecture 
updates performed primary node safe safe mixture safe safe update hot stand node 
hot stand node ready take processing primary node fails 
examples systems tandem remote duplicate database facility tandem sybase replication server sybase ca open ingres replicator ingres informix online dynamic server informix 
systems support shared support kind fragmentation 
shared disk architectures usually support replication site support node system 
node course powerful symmetric multiprocessing node sun enterprise server stand server storage log records ibm remote site recovery rsr remote recovery data facility 
stand server gets log records safe fashion 
idea raise fault tolerance installed ibm systems 
products research prototypes known writer thesis system primary hot stand architecture combined safe stand server save log records 
stand server cheap way achieving higher reliability system 
involve great processing overhead main memory overhead 
benefits gained safe stand server due cheap cluster communication run time system optimisations phase commit protocol described section 
replication structure described thesis avoids system failures long replicas fail short time ms 
supported database management systems cost forcing log disk commit 
system disk operations needed write transactions 
normal read write operations involve disk operations traffic disks serious 
communication cheap communication overhead small 
means reliable system built small cheap modules standard hardware 
high performance system needed nodes multiprocessor nodes highperformance processors 
multiprocessor nodes mainly board multiprocessor nodes nodes gives best price performance ratio 
single processor systems 
case disk commits reliability performance sacrificed 
minimum reliable system nodes minimum system high reliability minimum nodes 
reconfiguration recovery protocols relation protocols parallel data server complex relationships 
start description relationships describing types information needed parallel database choose replicate information 
protocols described simply various methods change recover information 
parallel database differs centralised database able continue operation presence node failures 
protocols parallel database defined action presence simple complex scenarios node failures 
serious complication building parallel database reliable 
actions reliable parallel databases handle concurrently user transactions adding new nodes dropping nodes updating schema information 
able react load changes change distribution data means regulate load 
means regulating load supported 
top underlying run time system able handle software changes fault tracing memory management provide real time services applications 
information parallel database little thought basic idea database 
idea store application information separate entity handles data application need worry data structures safe storage recovery complex transaction handling 
provides advanced search facilities data 
basic idea insert update delete retrieve application information transactions 
information structure parallel database able find application information storing information structured 
application information structured tuples 
tuples organised tables 
tables defined set attributes 
find data usually index tuples 
simple concept tuples tables indexes attributes basis databases 
database contain definition tables attributes indexes 
information change treated care 
refer information schema information 
modern databases included lot application support addition simple concept tables indexes attributes 
tables relationships definition inheritance attributes complex 
database provide alternative views data kept date original information 
referential constraints constraints maintained 
triggers react database operations supported database management systems 
reaction perform database operation inform applications database events 
complex set additional information database maintained database management system 
additional information part schema information 
schema information updated transactions changes schema information occur concurrently user transactions 
parallel database tables fragmented enable storage node 
fragments replicated 
maintain information need information nodes system 
information updated special transactions 
call distribution information represents knowledge distribution system 
types information handled system recovered failure situations 
gives hint order usage information 
schema information accessed user transactions 
distribution information needed find data checked accessing application information 
replication information replication information important part architecture parallel database 
types information replicated manner 
schema information needed nodes handle application requests 
schema information read transaction 
updated rarely 
decide schema information fully replicated nodes parallel database 
distribution information read transaction updated seldom compared number times read 
decide distribution information replicated processor nodes system 
replication application information index information covered section 
replication application information performed systems 
distribution information unique system replicated systems 
schema information contains different parts 
table attribute information replicated systems 
schema information necessarily replicated unique system 
existence secondary index primary system necessitate secondary index backup system vice versa 
schema information controls execution transaction schema information primary system 
backup system needs know changes table attribute information act properly 
backup system replicate schema information primary system able take primary system 
application information distribution information schema information information parallel database handling node failures recovery protocols include protocol find nodes alive 
earlier studies distributed databases concluded node failures transactions bhg state transition protocol needed ensure node failures 
node failure affect reliability system 
causes set fragment replicas unavailable 
idea data server automatically start copy process fragments lost replicas 
protocols data server methods handle node failures occur handled properly 
mentioned failure node event lot easier handle proper way 
actions started node failure shown 
node failures discovered am alive protocol 
promotion backup primary primary replica fragment fails 
creation backup replica backup replica fails creation stand replica stand replica fails 
restarting fragment primary backup replicas failed uses stand replica local checkpoint restart fragment 
system restart needed committed transactions lost happens state unrecoverable reached described section 
failure node may cause number transactions lose transaction coordinator 
protocol start new transaction coordinator transactions retrieving transaction information participants alive 
failure node cause failure replica local log 
log replicated node fail 
happens new log node started 
system involved replicating systems node failure cause log channel systems lost 
system communication restarted 
decision start protocols distributed logical entities 
fragments recovered owner primary replica replica promoted primary replica 
node system assigned coordinator new transaction coordinator transactions lost transaction coordinator 
node checks system restart needed 
new log node started owner log 
handling system failures system restart needed system restarts old consistent global checkpoint 
system backup system dropped backup system restarted information primary system information 
system primary system backup system take primary system crashed system restarted backup system 
am alive node failure system restart create stand replica create backup replica promote backup primary restart fragment new transaction coordinator start log node protocols started node failure restart system communication handling add node new node added result node restart operator placing new node system 
major issue start new node 
start node create distribution information schema information information fully replicated nodes system 
node fully started information created 
operator placed new node system fragments eventually split new node efficient manner 
split delayed proper time avoid overload situations 
new node helps nodes fragment replicas moved node 
move performed creating new replicas added node dropping replicas nodes 
handling drop node drop node similar node failure 
drop node operator initiated event controlled node failure 
means node allowed system ensure fragments replicated table definition remaining nodes system 
performed moving replicas nodes 
drop node means fewer nodes system fragments joined 
necessary fragmentation greater number nodes system 
join fragment performed time suitable avoid overload situations 
able join fragments essential requirement 
fragments system create memory overhead 
handling time events activities save information crash recovery performed certain time intervals 
activities started time event 
am alive protocol started timeout 
basic activities performed prepare crash recovery 
creates global checkpoints 
checkpoint transaction consistent represents point system restarted 
transactions tagged global checkpoint identity 
system restart promote backup system primary system restart backup system primary system protocols started system restart network redundancy add node start node split fragment create distribution information create dictionary information move fragment replicas protocols started add node create replica switch primary backup create backup replica create stand replica drop replica ensure transactions global checkpoint included restart transaction global checkpoint reflected restarted database 
actual information crash recovery local checkpoints performed node certain time intervals information saved fragment logs 
transaction completed check performed see global system checkpoint increased 
transaction completed log records saved disk 
transactions belonging global checkpoint completed global checkpoint recovered restart 
global system checkpoint newest global checkpoint system restarted 
handling overload events event cause start recovery protocols overload situations 
set load regulations performed parallel database 
protect highly loaded node ensure overloaded node transaction coordinator 
step ensure simple read transactions performed node necessary 
step taken switch roles primary backup replicas 
primary replicas processing handle read operations update transactions primary node executes methods 
moving primary replicas overloaded node step decreases load node 
previous steps able prevent overload situation final step abort transactions need access data overloaded nodes 
node overloaded long term actions taken moves fragments nodes 
action preferably performed low load situation reached occurs low load situation occurs long term actions performed ensure traffic handled change 
drop node join fragment move fragment replicas protocols started drop create replica switch primary backup create backup replica create stand replica drop replica time am alive start local checkpoint local checkpoint create global checkpoint protocols started time events overload event move fragment replicas protocols started overload event create new replica switch primary backup create backup replica create stand replica drop old replica switch primary backup handling schema changes schema changes require number special protocols 
set possible schema changes large thesis try cover possible schema changes 
study adding dropping tables attributes indexes foreign keys 
complex changes attributes table studied 
splitting merging tables studied 
schema changes cover large part common ones 
levels replication schema changes performed backup system proper way 
studied set schema changes 
protocols protocol normally specific purposes switch primary system backup system 
protocol started explicitly operator wishes replace telecom database newly installed 
new telecom database developed different vendor switch protocol switch old new system 
switch situations necessary change load situation long term basis 
schema definition number facts schema definitions need specified 
concern primary secondary keys tables fragmentation tables methods class attributes stored procedures views constraints triggers 
tuple keys relational databases primary key get access record 
primary key unique normally related way application information 
object databases normally object identifier primary key class 
object identifier generated database management system object created 
investigation applications chapter showed types primary keys needed 
call key types tuple keys thesis 
call object identifiers tuple identifiers word tuple define records objects database 
accessing tuple database tuple key 
tuple key tuple way scanning table 
fragmentation tuple key necessary attributes fragmentation available part query direct access tuple 
fragmentation tuple key performed hash lh structure shown chapter 
fragmentation attributes uses hash function 
attributes hash function called fragmentation attributes 
attribute query search possible processor nodes tuple 
reason accessing record goes tuple key tuples move 
processor node move pages move processor nodes telecom databases 
possible type key associated physical storage information 
log records needs contain tuple key 
processor node local index maps tuple key physical key 
index dependent fragmentation function lh lh karl 
accesses tuple go index natural place locks tuple index 
query specify tuple key fragmentation attributes beneficial secondary index 
secondary index maps attributes part query tuple key fragmentation attributes direct access tuple 
types tuple identifiers 
unique system shorter 
bytes 
bytes table identifier tuple bits contain unique number normally assigned sequential manner 
tuple identifier globally unique 
sixteen bytes long 
sixteen bytes bits table identity 
bits contain sequential number assigned system assigned object 
bits consist country code network code 
bits deduce responsible creating object 
indexes built tuple identifiers sequential number needed elements index 
schema entities defining tables number attributes types specified 
stored procedure represent programs access tuple table database 
executed transaction coordinator compiled program interpreter 
stored procedures decrease communication application database 
tpc benchmark full transaction stored procedure 
request response needed application database 
fragmentation tables enable scalable system tables fragmented 
various types fragmentation fragmentation vertical fragmentation 
vertical fragmentation distributed databases built number autonomous databases 
parallel data server fragmentation enable parallel execution database queries table 
natural fragmentation 
vertical fragmentation attributes hot spots 
vertical fragmentation security reasons 
handled application defining tables defining original table view tables 
tables 
tuple locking concurrency vertical fragmentation 
fragmentation ways derive fragmentation 
mentioned methods 
normal case parallel data server tuple key lh structure derive fragmentation 
case fragmentation performed automatically dbms declared user 
cases fragmentation fragmentation attributes tuple key 
example receiver emails natural fragmentation attribute email table 
way emails particular user clustered easily looking 
advanced methods fragment tuples discussed thesis 
fragmentation table full meaning usually fragments node 
fragmentation medium percentage 
case percentage nodes store fragments table 
fragmentation methods lh structure derive fragmentation 
distribution transparency desired fragmentation declared single 
means table fragmented 
single specified specify desired nodes table stored 
system try nodes possible nodes node failures overload situations cause things change 
final possibility specify number fragments lh structure 
case possible specify desired nodes fragments 
distributed indexes types distributed indexes needed primary indexes secondary indexes 
primary index access tuples secondary indexes translate secondary key tuple key 
primary indexes tuple key 
case assume lh 
local part lh fragmentation tuple key 
normal procedure databases secondary indexes tables placed processor nodes 
distributed database problems method secondary key contain fragmentation attributes 
possible find processor node index resides broadcast processor nodes 
secondary indexes handled similar way tables handled fragmentation attributes secondary key attributes 
secondary indexes stored special type table fragmentation independent table 
exception secondary indexes fragmentation key 
case database strives collocate fragments secondary index fragments table 
means entry secondary index tuples node 
secondary indexes types secondary indexes possible unique index maps attributes unique key tuple key 
mapping value unique key value tuple key 
second type index tuple key provides fragmentation attributes 
normal unique secondary index maps tuple key sought attribute opposite 
third type non unique index attributes index maps set tuple keys 
secondary index basically treated normal table regarding fragmentation 
index fragments contain stand replicas 
natural recreate index failures case 
backup replicas secondary indexes needed 
indexes local parallel data server possible global 
databases secondary indexes lock ranges keys provide scanning tables consistency degree 
case able lock broadly negative impact real time delays database 
applications real need lock ranges keys locks possible hold specific key values 
possible lock non existent tuple possible lock range key values 
specific lock record key value locked tuple 
locks gained tuple key located processor node tuple 
index operations interested fetch insert delete 
fetch possible fetch degree supported assurance value range inserted scan 
fetch reads index find tuple key 
insert performed retrieving lock tuple primary replica delete operation 
insert secondary index performed secondary index tuple locked transaction committed deleted secondary index tuples locked transaction committed 
readers find possible key values including uncommitted 
lock released tuple may deleted checked read operation 
transaction reads secondary index tuple short term lock 
reading lock released 
done avoid deadlocks transaction needs update index holds lock tuple 
reader uses tuple key find tuple tuple may changed reading secondary index tuple longer fulfil search condition 
tuple checked gaining lock tuple ensure secondary index attributes 
transaction releases lock tuple retries action secondary index fetches 
updates secondary indexes described section 
solving deadlock problems secondary indexes problem deadlocks mentioned earlier secondary indexes 
reason locks tuples indexes 
readers index start acquiring read lock entry secondary index try acquire lock referred tuple 
transactions update secondary index acquiring lock tuple acquiring write locks secondary index 
obviously deadlock occur readers writers secondary index 
deadlocks common avoided discovered time function 
problem mentioned order locking differs 
secondary index copy tuples table natural decide owner lock tuple higher priority owner lock secondary index 
change necessary behaviour write transactions write transactions knows lock held secondary index released shortly participate deadlock tuple lock 
reader perform back function ways 
lock data try lock tuple 
read lock tuple acquired continue normal write lock held transaction put lock request queue time release lock secondary index 
lock released acquired reader necessary check tuple fulfils search condition tuple changed due actions write transaction 
second possibility acquire short term lock secondary index reading secondary index releasing lock trying acquire read lock tuple 
argument method valid tuple checked search condition true lock tuple acquired 
search condition longer true new search secondary index performed 
second method chosen releases lock secondary index immediately 
necessary release lock commit transaction tuple locks need released part commit 
related distributed indexes distributed databases db mohan 
method avoiding deadlocks new knowledge author thesis 
method accessing tuples primary key tables indexes partitioned 
user transaction protocols important part recovery handling commit phase protocol 
efficient achieve high performance part write transactions 
designed avoid blocking situations proved totally non blocking commit protocols possible design skeen 
time designed handle real time requirements 
variants commit phase protocols handled separately 
variant application transfer commit decision data server 
normal situation data server reliable application 
second variant application coordinates commit phase 
reason systems involved transaction 
case application sends prepare message data server commit abort message 
positive response prepare message promise commit decided data server ensure commit presence node failures 
start describing commit phase started commit message application transfers commit decision data server 
show protocol handle prepare message application 
show read queries handled 
transaction protocol developed chapter important result thesis 
combination normal phase commit linear commit protocol 
benefits performance delay transactions 
shown simplifies design recovery protocols disk writes 
chapter show nicely integrated second level replication network redundancy 
normal commit phase handling normal messages sent commit phase fragment shown 
basic component phase commit protocol thesis 
major reason sending commit messages opposite order ensure primary data node receives message 
primary data node prepared send log records backup system knows backup stand nodes heard commit decision 
primary data node release locks commit phase reason 
primary locks tuple basically backup nodes need lock tuples 
enable fast take enable simple reads backup backup nodes lock data 
reason starting prepare messages primary data node prepare update put 
update message go primary data node node receives lock requests 
complete message basically go order reason sending linear fashion decrease number messages 
complete messages normally piggy backed messages start prepare commit 
extra delay incurred backup stand nodes wait longer lock release message 
means simple read messages delayed somewhat longer cases 
simple read transactions read latest committed ver sion waiting incurred due waiting lock release 
send complete messages special messages incur substantial performance overhead 
speed lock release processing simple read transactions reason send special complete messages 
backup nodes receive new operation object locked committed completed backup safely release lock committed tuple primary obviously released lock 
extra waiting due uncompleted transactions necessary 
tpc transaction tpc example transaction involves tables fragments gray 
fragments involved tpc transaction 
transactions handled commit phase protocol parallel fragments 
means normal phase commit protocol fragments linear commit optimisation inside fragment replicas seen 
linear commit fragment substantially decreases number messages 
described mechanism gives messages prepare commit phase number fragments number replicas fragment 
gives messages transaction replicas fragment 
normal phase commit protocol give messages messages 
linear commit give messages messages 
decreasing number messages measure interest obviously linear commit optimisation preferable 
linear commit give delay messages sent serially 
normal phase commit gives delay maximum commit commit commit committed complete complete completed commit phase complete prepare prepare prepare prepared application request application response tc commit committed prepare prepared commit phase protocol tpc transaction prepare commit sages executing parallel 
variant leads delay maximum messages executing parallel 
clearly variant achieves balanced effort short delay high throughput 
simple write optimisations simple write transaction optimisations performed distribution cost transaction diminished 
optimising simple write transactions normal linear commit basically achieved 
simple write transaction refers transactions write tuple 
refer number writes fragment 
applications studied observed common transaction type important optimise 
optimisations performed changing basic ideas commit phase protocol 
matter moving transaction coordinator role 
seen messages prepare commit phase 
enable transaction coordinator migrate possible decrease number messages 
step communication node prepare chain transaction coordinator removed 
means message node says prepare commit 
messages removed 
message flow shown 
produces messages prepare commit phase 
optimisation optimisations perform phase commit protocol 
locality transaction coordinator decrease number messages 
transaction coordinator placed node primary replica messages removed message chain 
leaves messages prepare commit phase seen 
system architecture opted separation application nodes database nodes architecture relies efficient communication mechanism 
means message flows described request message application response message application 
efficient communication mechanism available system need collocate application database tc commit commit complete complete completed optimised commit phase complete prepare prepare prepare commit application request application response completed tc commit commit complete completed optimised commit phase locality primary replica transaction coordinator complete prepare prepare commit application application request response replicas 
scenario optimised commit phase achieved messages needed prepare commit phase seen 
optimisation method fragments savings substantial savings applied fragment 
fragments cost 
transactions fragments distributed processors information transaction coordinator 
easy move transaction coordinator 
simple write scenario replica contains information writes role transaction coordinator easily taken replica 
handling node failures commit phase action node failure ensure nodes know node failed 
recovery processing started desired replication achieved soon possible 
actions discussed previously discussed section protocols copy fragments 
second action handle active transactions node fails 
studied section 
study cases node failures transactions 
participant transaction failed second transaction coordinator failed 
failure data node major problem case failure data nodes breaks linear sending prepare commit complete phases 
message come back transaction coordinator action taken 
assumed full responsibility failure situations transaction coordinator data nodes fail 
data nodes take actions time similarly 
simplifies failure processing source actions failures 
node failure reported transaction coordinator check active transactions ensure stopped due node failures 
performed scanning active transactions 
transaction waiting nodes nodes checked detect failure occurred 
failures occurred action restart phase transaction started 
messages sent order failed node excluded 
risk messages arrive nodes order normal linear order 
transaction receives message received simply ignores message passes node 
find transactions need restart phases transaction table scanned 
multiple node failures occur new node failures occur scan process 
handled shown node failures marked scan process currently node failed 
application tc commit complete completed optimised commit phase locality primary replica transaction coordinator application prepare commit failures data nodes handled fashion failure primary data node prepare phase 
case obvious transaction aborted phase started new prepare phase 
optimisations simple writes algorithm original transaction controller 
means longer chain messages occur 
failures common 
failure transaction coordinator transaction coordinator fails transaction stopped new transaction coordinator taken role transaction 
new transaction coordinator system coordinator 
node receives report node failure starts scans 
scans transaction table described 
starts scan transactions node participant 
scan transaction participant table transaction checked see transaction coordinator failed 
transaction coordinator transaction failed node sends report transaction new transaction coordinator 
report contains transaction status fragment identities involved role node fragments transaction simple write transaction 
scan process uses marker method described 
scan process completed node sends scan complete message new transaction coordinator 
new transaction coordinator received transaction information received scan complete nodes alive necessary information decisions transactions 
decision abort transaction node reports heard commit decision 
described exception rule fragment lost 
case transactions blocked nodes reached prepared state 
node heard commit decision decides commit transaction 
abort commit message complete messages sent usual linear fashion fragment 
new transaction coordinator fails finished coordinator automatically chosen new coordinator performs exactly actions 
way method continues nodes failed system finds inconsistent state decides perform shutdown system 
mark node failed mark node failed mark node failed lap check node lap check node node lap check node node node second lap check node node second lap check node scan completed transaction table scan transaction table transaction coordinator optimisations simple writes failure original transaction coordinator functionality 
special error situations actions taken processor node behalf transaction survive node crash information written disk 
nodes fail contain copies fragment writing committed information disk fragment inconsistent system shut restarted global checkpoint local checkpoint information local logs fragment logs 
phase commit protocol forces log disk processor node fails time failure 
replica fragment log forced disk committing transaction 
situations nodes contain copies fragment fail system operational 
approach situation participants prepared simply abort transaction leave 
called presumed abort mohan 
problems approach database locks backup replicas released commit phase 
assume backup node heard commit decision releases locks proceeds new transactions 
backup node process simple read transactions 
assume get situation obviously get inconsistency due releasing locks backup data nodes early 
ensuring primary node releases locks backup nodes ensuring nodes replicas fragment got commit message locks released problems inconsistencies due problem avoided 
solution commit message mean backup stand nodes release locks 
release locks complete message arrives primary node requests new transaction locked data 
happens primary node released lock locks released backup stand nodes 
problem method aborting alive nodes prepared aborted committed 
problem arises replicas fragment crashes releasing locks transaction aborted 
addition system crash 
example events lead situation shown 
problem replicas fragment lost transaction committed logged disk 
tc bd bd pd tc transaction coordinator pd primary data node bd backup data node sd stand data node tc sends commit bd bd fails bd commits releases locks tc fails bd executes new simple read transaction bd fails pd new coordinator aborts transaction aborted results displayed causing inconsistencies new transaction coordinator decides abort transaction 
conclude fragment lost transaction allowed abort unsure situation 
particular situation transaction blocked 
problem scenario 
new transaction coordinator know fragment missing transaction 
able get information new transaction coordinator know involved fragments cause increase message sizes sent transaction 
increase really justified small benefit 
better block transactions unsure fragment totally lost node crash 
special transaction simple write transactions unblocked small effort 
transactions fragment id sent anyway part messages bit needed specifies simple write transaction 
transactions blocked 
fragment lost obviously node heard transaction nodes lost 
handling prepare commit requests application application sends prepare request data server creates number problems 
problem failure transaction coordinator reason restart system 
necessary algorithm described 
problem participants prepared transaction aborted committed application sends decision data server 
algorithm changed fragments involved transaction prepared committed transaction wait application requested abort commit 
algorithm new transaction coordinator failure transaction coordinator 
fragments available failure transaction coordinator new transaction coordinator check involved fragments replicas reported transaction state 
fragment unavailable fragment saved transaction state disk failing system operational 
fragment replica received commit new transaction coordinator commit transaction 
fragment prepared transaction safely aborted reported application 
fragments prepared new transaction coordinator waits decision application 
abort commit arrives executed fragments 
performed situation fragment available 
assumed application decides commit pd bd bd pd tc tc sends commit bd tc fails bd commits pd commits releases locks pd participates new transaction commits bd fails pd fails bd pd decides abort transaction cascading abort multi fragment transaction heard prepare old transaction coordinator failure 
reporting prepared application performed new transaction coordinator knows involved fragments reported status transaction 
problem failures primary replica state allowed crash system 
means nodes complete information tuples locked transaction stand replica 
means read requests transactions performed nodes read lock needs set backup stand replicas 
read locks lost primary replica fails transactions cause serialisability errors 
stand node set locks update operations performed 
problem relates schema information 
locks schema information set transaction coordinator 
previous algorithm locks released commit message sent nodes 
failure transaction coordinator cause problems concurrency schema information 
problem relates hard schema changes need serialised user transactions 
soft schema change allows versions execute concurrently presents problem case 
failure transaction coordinator causes locks schema information lost transaction 
situation new locks requested transaction 
schema information updated abort necessitate rollback schema information 
phase locking rule adhered failure case 
remain problem removing tables indexes attributes involved query commit performed transaction 
removing views constraints referential constraints triggers stored procedures forth cause problems transaction reached prepare phase 
removal additions schema information done serialised transaction 
adding new tables indexes attributes causes problem involved transaction 
solution problem hard schema changes need remove tables attributes wait prepared transactions failed transaction coordinator committed aborted 
referential integrity secondary indexes various constraints 
type constraint attribute values specified domain 
constraint checked transaction coordinator reception update insert message 
constraint unique constraint ensured having unique index attributes unique values attributes index transaction aborted 
foreign keys implement referential constraints 
tuple inserted contains foreign key ensured referred tuple exists 
accomplished reading referred tuple gaining read lock tuple ensure disappear executing transaction 
tuple deleted tuple action performed referencing tuples 
action specified declaration table 
possible declarations cascade delete set null delete set default value delete action 
deleting transaction gain exclusive locks tuples referring deleted tuple 
secondary index foreign key indexes find tuples refer tuple deleted 
strategy inserting transaction try acquire lock referred tuple acquiring locks index foreign key 
means deleting transaction safely get tuples refer tuple 
deadlock occur tuple updates foreign key refer tuple deleted 
situation solved normal deadlock handling transactions aborted 
delete transaction acquire write lock tuple deleted searching secondary indexes foreign keys 
referential constraints cause situations foreign key refers table 
foreign keys normally tuple identifier foreign key 
find tuple table identifier foreign key 
tuple identifiers contains table identifier 
number possible ways handle indexes constraints referential constraints replication data server 
possibility primary replica perform checks attribute constraints referential constraints updates indexes forth 
mean primary replica sub coordinator set operations transaction 
solution produces minimum number messages 
increase size messages necessary transfer schema information 
course schema information available node primary replica 
access schema information node causes problems concurrency control schema information 
necessary handle failures primary replica special protocols 
complicate recovery protocols 
option send operations primary replica 
primary replica discovers need updating index performing constraint checks forth sends information transaction coordinator 
increases number messages 
require special handling failures primary replica 
solve problems concurrency control schema information 
third solution transaction coordinator control activities advanced database facilities 
sending requests primary replica get information index updates needed referential constraint checks needed forth 
manner transaction coordinator full control activities transaction start activities parallel 
transaction coordinator needs check schema information difficulties concurrency solution 
drawback solution messages sent solutions 
data server uses efficient communication scheme decide serious problem 
centralised design advanced database facilities simplifies design simple algorithms perform complex tasks 
show chosen method examples 
update secondary index executing update insert delete operation schema information checked see operation influences secondary indexes 
able perform index updates attributes secondary index read 
necessary set write lock tuple time 
necessary avoid deadlock situations described previous section 
update tuple reading tuple requested message 
reading index attributes index updates insert delete performed parallel 
flow messages shown update messages 
messages shown similar tpc transaction shown 
referential constraint example show delete tuple number 
attributes refer tuple deleted example set null 
step delete tuple 
ensures tuple locked transaction able create new tuple 
tuple locked delete lock indicate operation try delete tuple 
dummy read message create quick acknowledge lock operation 
indexes foreign keys scanned find tuples referred tuple 
ensure deadlocks introduced transaction inserting tuple contains foreign key start trying get lock referred tuple inserting index foreign key 
transaction updates foreign key attribute existing tuple transaction try lock referred tuple 
finds tuple locked deletion knows deadlock occur schema information 
abort transaction ensure deadlock occurs 
means lock tuple acquired risk running deadlocks requesting entries index foreign key 
referring tuple keys returned set null operations deletion entries index foreign key performed parallel 
tc update commit update read insert delete pd tuple pd pd example index update prepare index attributes tc delete commit delete read scan delete update set null pd pd tuple pd example referential constraint prepare related handling referential integrity secondary indexes standard information textbooks databases 
new information thesis integrate constraint handling parallel database 
referred complex problem 
solution thesis relies fact communication cheap 
avoids need complex solutions avoid communication 
zsu treats centralised distributed handling constraints 
read queries describing recovery protocols describe protocols handle read queries 
read queries simple read queries benchmarks tuple read transaction 
transactions handled extra optimisations 
read transactions somewhat simplified 
shown secondary indexes read queries 
read transactions part updating transactions read primary replica 
situations read queries need set locks replicas 
simple read transactions transactions involve simple read operation tuple key simple 
operations involve safe data primary system backup systems accessed primary system accessed 
chosen system primary copy backup copy accessed primary copy accessed 
safe data backup system done risk reading inconsistent data guarantees consistency safe data recovery procedure propagated updates transactions backup system 
read queries logged locking part phase commit protocol needed commit phase locks released 
simple read queries performs immediately reading tuple 
means coordinator transfer commit responsibility node data read 
node send data directly requesting application seen 
worst thing happen message lost due failure 
discovered application time 
time message resent 
simple read query goes distributed index query little bit complex 
case index unique index scan transaction 
normal case reading tuple secondary index shown 
case tuple node supposed unique attributes tuple correct reading tuple 
application coordinator primary node backup node messages simple read query possibility exists tuple deleted coming primary node unique attribute changed 
case simply sent unique index retried 
unique index says message sent application 
messages transfer control message receiver error cases handled time application node followed resend 
read transactions covers transactions consist read requests secondary index tuple key covers scan queries 
major difference set read queries compared simple read query coordinator transfer control 
coordinator contacted data node ensure coordinator release locks commit time 
commit time locks released linear commit optimisation prepare phase updates involved 
coordinator fails system coordinator take coordinator transaction described 
related reports written various commit phase protocols 
important protocol phase commit protocol variants protocol include linear commit protocol gray non blocking phase commit protocol gray presumed abort mohan presumed commit mohan 
number variants described section 
chapter new version phase commit protocol developed 
uses linear commit protocol replicas fragment uses normal distributed phase commit protocols different fragments involved transaction 
uses presumed abort protocol certain restrictions total failures fragments releasing locks backup stand nodes 
new transaction coordinator automatically assigned transaction coordinator fails chamb 
change direction linear commit protocol case ensure primary replica receives commit decision 
primary replica knows transaction safely committed release locks 
show provide network redundancy 
linear commit protocol fragment provides better performance simplifies recovery protocols number possible states handle reduced 
application coordinator primary node backup node unique index messages simple read query unique index normal case protocol tries achieve high reliability phase commit protocol soft real time high performance 
conflicting requirements mixture variants phase commit protocols achieves balanced solution requirements system communication cheap messages executed run time system soft real time 
line recovery reorganisation protocols section describe protocols handle recovery node failures remains operational primary backup replicas 
important item fragments database grows 
support protocols number basic protocols needed 
basic protocols basic protocols need find failed nodes handle transaction changes distribution information 
line recovery protocols copy fragment protocol send fragments new replicas 
am alive protocol reason having am alive protocol ascertain nodes errors quickly rest nodes reach consensus nodes running 
idea node enter trusted set nodes confirming nodes trusted set running 
kept trusted set node certain time interval report neighbours alive 
neighbour nodes agree node start node failure transaction 
nodes agree new node ready enter trusted set start add node transaction 
add node drop node transaction started operator 
reason informing nodes raise level security making right decision 
erroneous decisions temporary faults nodes links software faults error detection 
course possibility error smaller 
idea protocol arrange nodes doubly linked list 
idea nodes send am alive neighbours linked list 
error occurs discovered neighbours 
shown 
node receive am alive message predefined number time intervals node sends coordinator node node linked list 
failed node coordinator chooses node linked list new coordinator sends node 
message acts indication receiver appointed new coordinator 
coordinator receives neighbours failed node initiates node fail protocol 
am alive protocol node discovers failed node keeps information new active decision activated failed node dropped 
way subsequent failures coordinators forth lead incorrect active sets activated 
coordinator proposes new set active nodes failed node active node report coordinator 
coordinator remove failed node node reporting failed node 
node reports failures nodes discover node reporting failure dropped set active nodes coordinator 
am alive protocol executed higher priority level user messages ensure bounded delay time discovering failed nodes 
state transition protocol state transition protocol change state set active nodes change set copies fragment 
type protocol shown 
idea protocol ready new decision message received nodes system commit processing processed activate new decision message received 
means state change inserted time commits ready new decision message occurred state change commits message occurred state change 
means transactions executed state commit time state time 
nodes fail transaction processing primary replica transaction committed failed node new nodes added fragment transaction processing nodes inserted transaction transaction committed 
reason failures backup nodes cause need aborting transaction transaction protocol 
primary accessed method uses primary copy locking 
information lost backup fails 
simple read transactions lost backup node 
simple read transactions restarted time reply arrived 
state transition protocols execute higher priority user messages ensure bounded delay state transition protocols 
number state transitions need commit processing prepare message 
example fragment copied new replica 
necessary prepare replica involved transactions 
necessary inform nodes agree node date primary failure situations 
node node 
node ready new decision nodes receive store decision ack ack ack activate new decision nodes start commit processing broadcasts broadcasts configurator ack state transition protocol nodes commit processing node fail protocol node fail protocol executes state transition protocol state updates set nodes currently active 
protocol initiated system coordinator receiving information nodes node failed am alive protocol 
system coordinator takes role transaction coordinator transactions failed node transaction coordinator 
node receives fail message replies state transaction involved failed node transaction coordinator 
node fail protocol execute higher priority user messages ensure node fail protocol bounded delay time 
means user messages sent failed node may message buffers node fail protocol executed 
easiest solution problem run time system removes messages receiving ready new decision ensuring messages arriving failed node accepted node restarted 
am alive messages failed node accepted times ensure decided failed node recovered 
possible network partitions ensure happen keeping certain rules node fail protocol executed 
majority nodes previous active set active nodes remains set active nodes new decision new decision activated state transition protocol 
half nodes majority nodes failed system coordinator node fail protocol executed 
happens nodes set nodes active told commit processing 
decision set nodes taken operator 
operator inserts proper command commit processing suspended 
solution shut system restart 
copy fragment protocol new backup replica created primary node executing state transition protocol system informed new copy 
basic idea copy fragment protocol simple 
sending node sends fragment tuple tuple sent 
tuple sent new state transition protocol executed inform system new copy date 
receiving node receives write transactions 
affected tuple arrived applies write transaction tuple 
tuple arrived ignores write participates phases phase commit protocol 
shown 
insert operations processed new copy 
new backup node primary node arrived tuples arrived tuples update update prepare prepare prepare prepare handling write transactions new backup node ignore update complexity protocol shown 
basic problem transactions proceed execute parallel copy fragment protocol algorithms needed accomplish protocol algorithm handles copy process primary node algorithm handles transactions primary node algorithm handles receive process algorithm handles transactions new backup node 
copy fragment protocol highly integrated distributed data structures description chapters distributed data structures 
steps declaring new replica date 
step reported copying process finished new replica contains tuples 
new replica declared recoverable perform local checkpoint 
means node fails declaring date recoverable useful total failure situation 
reason local checkpoint replica stably stored disk 
create global checkpoint protocol idea global checkpoint create checkpoint transaction consistent 
transactions log records belonging transactions marked identity global checkpoint belong 
restart situations recover total failures 
useful starting stand nodes 
stand node started received log records belonging global checkpoint participating current transactions 
global checkpoints restarting fragments failed 
global checkpoints necessary copy fragment protocol protocol integrated normal transaction processing 
global checkpoint generated simply executing state transition protocol coordinator assigns new global checkpoint identity 
complex protocols developed simple protocol seen context 
bounded delay time achieved executing higher priority keep delay time ms acceptable applications 
short delay dependent database system executing realtime run time system 
prepare message received commit processing transaction coordinator stopped global checkpoint record inserted fragment logs 
global checkpoint id updated new value 
activate message arrives commit processing start subsequent commits new global checkpoint id log records belonging global checkpoint id log record describing global checkpoint 
copy node locks indexes tuples copy process transaction processes receiving node locks indexes tuples receive process transaction processes algorithms copy fragment protocol commit processing transaction coordinator stalled 
operations executed reaching commit point transaction coordinator continue operations passed commit point transaction coordinator 
schema information needs part transaction consistent checkpoint 
shown chapter needed read version numbers describes current schema version describes completed schema version 
replica handling protocols replica handling protocols needed new copies copy failed 
needed change state replicas 
backup primary switch roles backup replicas promoted primary replicas 
failure primary backup replicas standby replica recovered promoted primary replica 
protocols performed primary node nodes promoted primary node fragment 
idea protocols ensure fragments replicated desired node failure 
fragment processor node primary node action taken decide nodes receive backup replica execute state transition protocol new decision execute copy fragment protocol mark new decisions active drop old decisions parallel check stand replicas performed node decide nodes receive stand replica execute create stand replica protocol primary node failed actions taken node primary node execute state transition protocol promotes backup node primary node marks new decision active drop old decisions backup copies starting primary node failed kept information copy fragment protocol actions state transition protocol described 
execute actions described primary node 
find actions specific node perform node failure nodes scan fragment distribution table 
failures occur scan process necessary put marker starting scan process failure scan process 
failure occurs scan process scan continues marker put spot fragment distribution table 
promote backup replica primary replica transaction executed primary replica fails 
transactions prepared aborted primary replica failed 
transactions commit transferred data server prepared committed transactions aborted 
performed normal commit phase transaction check primary node alive 
request promote backup replica primary replica immediately acknowledged promotion primary replica completed soon activate new decision message received 
simple logic possible possible difference states primary backup replica state active transactions set locks acquired primary replica backup replica 
active transactions aborted transient states set aborted locks released primary backup replica differ 
global replication protocol reads simple read transactions set locks nodes 
important information lost primary replica fails 
necessary abort transactions committed 
create backup replica specific actions take creating backup replica sufficient execute copy fragment protocol 
create stand replica nodes fail system starts force log disk commit 
systems replica fragment log records forced commit fragment 
avoid having force log disk commit system create new stand replica raise reliability level log need forced disk 
stand replica valid certain global checkpoint 
ensure clearly defined log records produced creation new stand created new global checkpoint started simultaneously create stand protocol 
new stand replica immediately valid global checkpoint 
primary send older log records new stand replica restart situations 
log records global system checkpoint 
mark node failed mark node failed mark node failed lap check node lap check node node lap check node node node second lap check node node second lap check node scan completed transaction table scan fragment distribution table new global checkpoint number log records belonging global checkpoint earlier shipped new stand replica date total recovery 
primary replica discovers log records sent informs nodes new stand replica useful global system checkpoint 
switch primary replica backup replica case primary node backup nodes active 
receiving decision new operations fragment started new phases phase commit protocol initiated 
active operations execute finished likewise transaction phases 
operations fragment halted primary replica backup replica set lock state 
lock information transferred new primary node contain locks old primary node 
finished new state installed ready new decision acknowledged soon activate new decision received switch performed operations continue 
simple read operations proceed switch process 
behaviour independently read primary backup node 
start node protocol node started restarted failure dictionary distribution information invalid 
node participate user transactions create dictionary distribution information valid 
cases starting node 
node started failure nodes nodes started 
nodes start complete failure selected start 
node start nodes parallel 
slightly slower simplifies start node protocol recovery complete failure uncommon 
create dictionary information dictionary contains set system defined tables tables seldom updated 
simplest path create information assign node copy data locking dictionary information 
starting node dictionary information recovered recovery process disk files 
complex procedures designed allow concurrency dictionary updates start new node 
difficult design unnecessary complexity burden 
simple idea keep log updates copy process 
completion copy process log executed lock dictionary information set remaining log records executed new node locks dictionary information released 
node assigned copy information fails copy process new node assigned copy information scratch 
possible better complex start node protocol 
create distribution information starting node distribution information simple alive node fragment assigned node 
new nodes added existing system change distribution information new node added 
case possible lock distribution information copy process 
doing mean node failures allowed certain 
repairing node failures important starting new nodes simple protocol 
variant copy fragment protocol shown section 
start performing state transition protocol inform nodes new node started 
transaction new node involved am alive protocol part updates distribution information 
step start copying information 
node information table information fragment information 
avoid complex problems protocol executed time create dictionary information 
means dictionary updates possible tables created changed dropped copy process 
need consider updates table information 
updates node information course occur time size node information assume copy atomic event 
node information copied chunk 
updates information occur chunk update acknowledged ignored new node 
occurs copying chunk update performed usual 
fragment information shipped fragment time 
split fragment join fragment transactions allowed copy process 
fragments remain copy process updates fragment information necessary consider 
updates fragments performed new node performs update fragment arrived ignores update acknowledges update 
receive update information fragment shipped 
prepare transition message arrives fragment record locked shipped 
lock released activate transition message arrives 
join split fragment join split fragment actions handled copy fragment protocol conjunction algorithms local node 
split join algorithms dependent distributed linear hashing distributed tree 
splitting joining fragment process consumes resources 
fragment splits index split fragment file split tuples shipped processor node 
disk fragments contain gbytes data moved 
main memory fragments contain number mbytes data moved moved caution 
reason split fragment divide fragment processor nodes 
telecom database adds nodes management activity splits occur result adding nodes system 
nodes removed system joins occur decrease number fragments system 
reason split join fragments perform load balancing 
time load balancing handled moving fragment replicas switching roles primary backup replicas 
transaction coordinator role removed loaded nodes 
short term solutions load problem 
joining splitting fragment performed long term solution load balancing problem 
join split fragmentation activity performed system highly loaded 
join split activity postponed time system moderately loaded low load 
join split fragmentation performed line telecom databases line 
split algorithm split algorithm long process consists number steps involving previously described line recovery protocols 
number algorithms local nodes 
idea fragment created prepared split operation 
split operation reuse done line recovery 
fragment replica created split prepared split operation 
fragment replicas prepared split replicas moved split take place 
split algorithm consists steps primary replica prepared backup replica created 
finished roles backup replica primary replica switched 
switch old primary replica dropped 
backup nodes prepared perform algorithm create new backup replica finished drop old backup replica 
stand replicas need split actual split performed 
software prepared handle requests concurrently old fragmentation new requests new fragmentation 
replicas prepared split distribution information nodes updated reflect split 
local checkpoints produced split fragments distribution information keep information split performed previously stably saved disk 
join algorithm join algorithm similar split algorithm 
merging fragments assigned moving fragment 
fragment moved collocated fragment replica 
fragments locally merged copy process 
join decision broadcasted nodes state transition protocol 
consists steps create new backup replica moving fragment 
replica collocated primary replica remaining fragment 
switch new backup replica moving fragment primary replica moving fragment 
delete old primary replica moving fragment 
create new backup replica moving fragment 
collocated backup replica remaining fragment 
delete old backup replica moving fragment 
backup replicas perform step backup replicas moved 
create new stand replicas stand replicas moving fragment 
collocated stand replicas remaining fragment 
step inform nodes system join fragments 
software prepared handle requests join join concurrently 
split join coordinator split join process long task obviously possible error situations process 
system coordinator handle starting steps described 
state split join process reported nodes part state transition protocols executed process 
system coordinator handles load situation capable assigning proper node receive moving fragment situations nodes fail 
node failures split join process error occurs split join process process stops 
restarted involved fragments fully recovered failures occurred 
means executing steps steps performed 
simply acknowledged immediately finished step started 
activities disrupted split join process reused possible 
related am alive protocol old concept realised products 
called heartbeat function 
operating system interface am alive protocols digital workstations memory channel 
am alive protocol thesis added extra ring am alive protocol 
sure failing node start deleting neighbour alive set 
skeen state transition protocol update copy status table contained information distribution copies status copies 
contains description node fail protocol protocols describing handle node failures 
chamb describes state transition protocols scanning fragment distribution tables handling node failures 
appendix chamb proof method dynamically distributing data produces correct behaviour 
method chamb performs system restart replicas fragment fail support access primary key 
thesis contains new information chapter perform copy fragment protocol conjunction derivative linear hashing compressed tree 
chamb uses line recovery fragments fragment scanned transactions updating fragments 
lock full fragment transfers 
approach transfer tuple time general idea 
general idea scan process user transactions update new old fragment algorithms 
applied schema changes perform scan table receive result consistent locking entire table 
concept splitting joining fragments discussed 
details split join performed 
split join process handle node failures handling growing shrinking database systems 
considered perform line split merge fragments fragmentation algorithm static tandem sybase 
details sybase method 
split performed moving data 
possible data clustered fragmentation attribute 
case possible fragmentation performed hashing algorithm 
possible prepare splits eventually split data moved necessary 
tandem approach log new fragment created scan process number scans log 
outage required actual change fragmentation 
approach avoids handling requests split requests split concurrently 
soft split fragment process 
outage approach 
splitting fragments lh variants 
report karl 
reports consider transactions 
report litwin considers replication scheme consider transactions replication static change case failures 
research reports discuss protocols create schema distribution information starting nodes 
necessary part design parallel database normally reported research articles 
protocols implement global replication section describes second level replication protocols local replication protocols ensure higher level reliability 
idea replicas telecom database exist telecom databases 
telecom database replicated 
possible different replication different fragments level 
telecom database replicated 
replicas backup system may fragmented 
chapter detailed account failure situations handled 
protocol telecom databases transaction executed primary system executed backup system backup system contain data transaction 
basis protocol protocol developed king extended details interface global replication protocol local replication protocols thesis 
fragmentation backup system fragments global replica placed different telecom databases 
primary systems viewed part globally distributed database 
view primary system backup system shown 
kick nodes send log records certain fragment backup system log records received kick node backup system 
terminology king kick nodes host nodes 
king set store nodes correspond data nodes 
contain actual data fragment 
basic idea king transaction uses serialisability protocol phase locking access data primary system 
transaction executed completed primary system contacting backup system 
commit decision reached primary system assigns ticket transaction global fragments 
messages propagated backup system tickets retrieve locks serialisability order 
data resources primary system held data node ps bs fm fm bs global replication architecture kick node data nodes data node data nodes data node data nodes data node data nodes data node data nodes data node data nodes data node data nodes data node data nodes ticket assigned backup system completed transaction acknowledged transaction 
case safe second case safe 
protocols chosen transaction 
idea application describes attributes table need updated safe manner 
attribute updated transaction transaction safe 
operations primary system assigned ticket number log record generated sent backup system 
read operations belonging transactions perform updates part log records reason shown king brief explanation section 
pure read transactions need sent backup system change state database 
transaction backup system handled phase commit protocol distributed transaction 
necessary synchronise updates different fragments backup system 
shown backup systems involved transaction 
fragmentation global replication level local replication level may different 
different kick nodes primary system take care assigning tickets transaction 
kick nodes backup system take care locking protocol backup system 
model fragmentation primary system backup system 
fragmentation decided primary system 
means fragment splits fragment joins handled network interface 
global replication protocols standardised local fragmentation primary system backup system differ 
protocols develop thesis specify fragmentation algorithm global replication protocol 
systems protocols implement fragmentation algorithm locally 
describe implemented implementation efficient 
adaption transaction protocols global replication model shown previous section data nodes set nodes store primary backup stand replicas fragment 
shown global replication architecture local replication architecture interact 
idea local replicas ordered local replication protocol 
primary replica acts kick node primary system 
assignment tickets performed primary replica 
necessary nodes information ticket number primary replica fails 
kick node backup system normally primary node rare cases replica type 
possible backup system reads fragment stand replica fragment continue participate transactions primary system 
backup system strive primary replica fragment take processing fast 
mentioned message backup system sent commit decision 
means backup system commit 
allowed vote abort transaction 
certainly true safe case safe case enable flexible safe safe 
sure commit safely stored commit decision sent stand backup replicas 
primary replica node receive commit message 
means locks tuples held message sent backup system 
commit phase primary system commit phase extension commit phase described section 
idea simple 
commit decision reaches primary replica gathers log records fragment transaction sends backup system 
safe commit phase continues soon commit message reached primary replica seen 
commit phase concluded waiting backup system 
completion phase finish backup system acknowledged execution transaction 
safe processing transaction commit phase waits backup system seen 
messages backup system shown 
kick nodes data nodes kick nodes data nodes primary system backup system global replication architecture conjunction local replication architecture replicas fragment primary replica backup replica stand replica tc commit commit commit committed complete complete completed safe commit phase primary system complete prepare prepare prepare prepared bs bs log message bs acknowledge application request application response tc transaction coordinator bs backup system simple adaption needed phase commit protocol described previous section 
optimisations usable multiple fragments involved transaction protocol described fragments 
fragment log channel backup system 
considerations lock handling mentioned king read operations write transactions logged 
reason protocol aims restart consistent backup system lost transactions 
particular transaction lost performed updates reading tuple transaction updated read tuple survive crash 
transaction survive crash consistency backup system ensured restarted 
read operations write transactions performed safe need logged 
safe transactions certain survive crash backup system completed primary system 
means read operations need executed replicas 
actual reading object needed primary replica replicas keep track objects read 
primary replica fails log message sent backup system backup stand replica able send log message transaction backup system 
needed primary system decides commit sends message backup system 
failure primary replica situation mean transaction abort backup stand able take processing global replication king involves keeping track read operations 
backup stand replica keep locks tuples ensure serialisability endangered 
primary replica fails locks tuples kept 
backup stand replica keep locks tuples 
ticket assignment primary replica node receive commit decision ticket assignment performed prepare phase 
separate ticket sending phase needed backup system contacted 
means primary replica assigns ticket number prepare phase committing transaction 
introduce bubbles ticket numbering transactions aborted report reaches backup system 
aborted ticket numbers reported backup system 
tc commit commit commit committed complete complete completed safe commit phase primary system complete prepare prepare prepare prepared bs bs log message bs acknowledge application request application response transaction handling backup system transaction handling backup system normal phase commit protocol described king 
phase commit phase protocol described previous section adjusted handle transactions backup system 
receiving message primary system backup system understands number operations prepare message 
starts combined update prepare phase going primary replica chain 
message sent transaction coordinator 
transaction coordinator sends commit message replica chain commit decision propagated primary replica sent backup system primary system 
assigning transaction coordinator issue left open king assign transaction coordinator backup system 
solution primary replica chain simple writes enable optimisations described previous section 
transactions involve fragments algorithm 
primary system decides node transaction coordinator 
assign logically 
assigns logical node id bytes random round robin fashion 
number translated real node id backup system 
translation table handled fully replicated data structure backup system 
logical node id global checkpoint identity find transaction coordinator 
backup system change mapping perform local load regulation involving primary system 
involving global checkpoint identity change performed system need complex algorithm 
fragments know global checkpoint identity transaction choose transaction coordinator 
coordinator fails handled transaction coordinator failed described previously 
message sent commit phase primary system backup system shown transaction fragments involved 
ideas build global databases 
important restriction backup system contain data contained primary system 
primary system distributed 
delay aspect important consider building global databases 
necessary place primary close possible changing data 
applications difficult scheme 
telecommunication applications connected part world 
subscriber data placed part world subscriber lives 
genealogical data sweden swedish 
architecture create global databases newspaper genealogy subscriber data forth 
handling processor node failures global replication global replication introduces new complexity handling connection primary system backup system 
connection set primary replicas primary backup system 
failures primary replicas handled assure correct behaviour 
backup system handles transaction different way compared primary system 
primary system ability abort transactions failures occur 
allowed backup system 
failure commit transaction backup system leads failure backup system transaction 
transactions ensured commitment backup system 
means handling node failures commit phase little bit different backup system compared primary system 
handling node failures backup system nodes containing replica fragment fails backup system backup system fails participate transactions 
backup system declared failed case 
means problems node failures see section backup system disappear 
primary system necessary delay releasing locks backup stand nodes primary node committed 
reason possibility reading backup data simple reads possibility total failure fragment 
restrictions apply backup system 
locks released commit phase backup stand nodes 
actual design feature probably 
solution primary system higher concurrency anyway 
primary system backup system commit phase globally replicated architecture tc tc commit prepared commit committed prepare commit lower possibility failure backup systems new stand node started replica fragment fails 
creation stand copies somewhat different backup system 
due global checkpoints taken primary system 
stand node started lowest global checkpoint received backup system 
complete failures fragment replicas handled backup system 
backup system restarted anyway case total fragment failure 
necessary flush log disk error situations 
handling failure transaction coordinator backup system handling transaction coordinator failed similar handling primary system 
coordinator takes performs actions 
difference handle committing aborting transactions 
primary system allowed commit transactions 
allowed backup system 
aborting transaction backup system performed primary system failed 
backup system aborts transaction known committed primary system backup system declared failed 
uncertain situations backup system wait required messages arrive primary system 
failure primary replica primary system primary replica fails new primary replica take communication primary node backup system 
started new primary replica find ticket number certain bigger sent backup system known assigned failed primary replica 
new primary replica knows transactions sent backup system completed 
taken care normal handling failures primary system 
new primary replica knows transactions prepared new replica 
definitely aborted due failure primary replica 
matter failed primary replica assigned ticket number transaction 
transaction safely discarded list possible owners ticket numbers 
problematic messages passed new primary replica committed passed new primary replica backup replica message stating backup system received message 
transactions unknown state 
possible options happened 
message sent 
message sent acknowledged 
message sent acknowledged 
find unknown transactions new primary replica asks primary node backup system state ticket numbers 
asks particularly ticket numbers higher equal minimum unknown ticket numbers 
time primary system waits reply primary system started process requests 
new primary replica sends information primary node backup system priority order new committed transactions aborted ticket numbers highest lowest ticket number old committed transactions highest lowest ticket number idea time waiting backup system respond avoid possible resending messages received backup system 
performed possibility duplicate messages backup system beneficial simplification design 
response received backup system states ticket numbers known 
new primary replica sends information tickets priority order aborted transactions highest lowest ticket number unknown backup system old committed transactions lowest highest ticket number new committed transactions arrive failure primary replica backup system new primary node backup system assigned sends take message primary system 
message contains information response primary node backup system failure primary replica primary system 
handling take message handling response previously 
failure primary replica primary backup system case handled way handling failures primary replica backup system 
global recovery protocols recovery protocols needed protocols restart system backup system primary system alive 
protocol needed promote backup system primary system primary system failed protocol switch roles primary system backup system 
ensure view systems alive am alive protocol network level 
restart backup system primary system idea protocol simple 
idea scan fragments send tuple time backup system 
fragment performed independently parallel activity fragments 
restart finished fragments backup system declared date 
fragment declared date scan transactions entire fragment acknowledged see king 
scan process formed algorithm copy fragment protocol 
major difference receiver system 
read lock released soon message sent backup system 
details behaviour protocol shown section describing lh tuples read sent tagged ticket ensure concurrent transactions performed 
sending system fails restart completed restart unsuccessful procedures continue 
system contains backup copy database crashed restarted archive copy 
promote backup system primary system process backup system take failure primary system follows king 
locks write transactions order primary system transactions committed abort 
active transactions committed aborted backup system ready take primary system 
switch primary system backup system controlled switch primary backup system occur necessary bring primary system reason 
primary system replaced major software replacement performed 
switching primary backup replicas telecom database performed stopping operations proceeding transactions new constellation 
possible necessary move transaction coordinator 
switching systems coordinator transactions moved new system 
plausible 
doe overkill create complex take protocol perform type switch second faster 
uncommon action allowed costly executed 
switch performed steps prepare backup system fragments primary replica start global state transition protocol switches roles primary backup systems prepare message arrives new transactions accepted wait active transactions executed primary backup system set backup system primary system primary system backup system start accepting new transactions new primary system activate new global state transactions started simplifies design switch active transactions switch performed 
easy create distinct time switch performed 
necessary send states primary system backup system 
type switch take seconds acceptable happens rarely 
protocol replace system system global replication 
replacement starts starting new system backup system switch performed old primary system taken action 
avoid lengthy switch due long transactions ensured long transactions occurring switch 
mistake transactions running long time transactions aborted switch time 
related major sources providing network redundancy global replication secure crashes due earthquakes example king poly 
ideas king appropriate architecture major rework 
chapter thesis describe handle simple complex schema changes relation system global replication 
main new result chapter integration network redundancy new twophase commit protocol writes disk performed 
handle node failures involved communication primary system backup system discussed 
crash recovery protocols fragment replica fails active fragment replicas alive primary backup replicas possible recover fragments line recovery protocols 
fragment replicas fail necessary restart fragment information saved permanent storage disks 
fragments fail system shutdown occur 
system restart handled performing initial load schema information restarting fragments independently 
soon fragment recovered system start accept transactions fragment 
able perform restart system fragment need store information normal transaction processing possible 
information needed described describe information restart fragment different failure cases 
item needed restart fragment fragment log 
previous chapters fragment log referred log 
go detail crash recovery find need local log 
name fragment log differentiate logs 
log saves operations fragment information transaction outcome 
log logical necessary location replication independent 
independence possible log produced node restart node 
basic requirement able idea stand nodes described earlier 
restart node local checkpoint fragment log resides node 
log saves logical information operations log records database indexes tuple information transaction information consistent available 
means fragment logs applied produce action consistent database 
means database reflects state action active transactions alive 
requirement fulfilled stopping database creating action consistent checkpoint 
means real time requirements telecom database met 
solution 
fuzzy checkpoint method 
fuzzy checkpoints produce action consistent checkpoints 
need add log fuzzy checkpoint produce action consistent checkpoint 
log possible put data structures action consistent state log logical database operations 
log actions internal data structures database 
database organised pages log saves actions pages 
avoid need logging management activities form physiological logging gray specify logical manner actions specific database page 
production fuzzy checkpoint log performed locally node call log activity local logging 
files saved disk normally node nodes access common disk subsystem files node restart fragment 
telecom database uses shared operating database pages internal processor node 
recovery files taken node hardware system supports 
section start describing restart information 
restart necessary restore schema information fragment information restore fragments 
system restart system restart performed method assigning global checkpoint restore 
schema information restored find tables recovered 
distribution information find fragments tables restore recover information fragment 
fragment recovered system prepared start distribution information built restarted system 
find global checkpoint restart step system restart decide point time restart performed 
case means deciding global checkpoint restore 
failure occurred system restart ordered alive nodes alive nodes know latest global checkpoint restored 
system restart happens total failure nodes failed difficult decide latest global checkpoint restored nodes failed manner 
difficult find information restart situation nodes available 
assume options solve 
operator decision error reports operator received total failure 
latest global checkpoint nodes restart global checkpoint restore 
skeen contains description solution problem restarting proper checkpoint 
restore schema information step recovery process find tables indexes global checkpoint restored crash recovery 
includes tables indexes defined schema version current global checkpoint restore 
version checkpointed creating global checkpoint 
older versions schema needed crash recovery obviously active transaction uses older schema versions 
current schema version needs restored 
nodes access schema information nodes recover information parallel 
information files describing checkpoint schema information files containing log schema changes performed checkpoint seen 
exceptions needs special care 
situation table index part global checkpoint restore local checkpoints start restoration 
case table index created local checkpoint produced crash 
empty table index created information local checkpoint 
log records fragments executed empty table index 
file containing checkpoint schema information files containing log schema changes files needed restore schema information case table local checkpoints part global checkpoint restore 
case table dropped global checkpoint 
table ignored crash recovery 
saga table described chapter complex schema changes 
contains information schema information removed crash recovery complex schema change finish crash 
number tables indexes foreign keys attributes dropped crash recovery starts 
needed define entries saga table defines continue processing complex schema change 
case entries performed crash recovery system started 
case final schema change needed specified 
schema checkpoint able restart system schema information checkpointed 
schema checkpoint easily synchronised global checkpoints 
schema checkpoint contain schema information current version time global checkpoint 
simply written disk background process global checkpoint 
efficient complete write schema information occasionally write log records describing transaction changes schema 
checkpoint schema information contain file complete schema information log file 
restart information dropped completed version dropped 
schema checkpoints performed nodes enable nodes system restart 
system uses physically shared disk subsystem avoided nodes version database software 
restore fragment information restoring schema information known tables indexes part crash recovery 
step find fragmentation table find information needed restart system 
node access fragment information needed crash recovery 
node acts coordinator crash recovery information restart system 
coordinator decides nodes restore fragments 
actual method restore fragment described section 
node restart system access file contains descriptions fragments 
fragment items stored table identifier fragment identifier nodes replicas global checkpoint completed local checkpoints global checkpoint completed local checkpoint local checkpoint information backup log node needed see section information file created checkpointing distribution information 
node restarts system choose fragment node restore primary replica fragment 
inform node local checkpoint global checkpoint restore 
node contain information files local checkpoint files fragment logs global checkpoint local checkpoint global checkpoint restore files local undo log description states information items needed able restart system restored schema information 
information typically set files predefined names 
files contain files contain actual information needed system restart database pages fragment logs local undo logs 
provide formal textual description information 
set table descriptions table table name table properties set fragment descriptors fragment fragment properties primary node node completed global checkpoint set local checkpoints local checkpoint properties local checkpoint global checkpoint completed local checkpoint node primary node set description file local checkpoint set description file local undo log node backup log node endif node primary node set description file fragment logs endif set backup nodes node completed global checkpoint set local checkpoints local checkpoint properties local checkpoint global checkpoint completed local checkpoint node backup node set description file local checkpoint set description file local undo log node backup log node endif node primary node set description file fragment log endif set stand nodes completed global checkpoint node stand node set description file fragment log endif set backup logs node backup log node local checkpoint primary log node set description file local undo log endif node contain fragment logs local undo logs node controlling restart inform primary node nodes contain information 
fragment information specify table fragmented 
fragment entities need 
local checkpoints fragment 
kept processor node defined database administrator normal 
desirable access physiological undo log records 
log records restore database pages consistent state 
saved main memory avoid forcing log disk page write 
crash situations necessary access undo log processor node backup local log 
need access fragment log 
find local checkpoints fragment table identity fragment identity provided 
set local checkpoints information processor node created local checkpoint identity local checkpoint global checkpoint finished local checkpoint 
information files local checkpoint retrieved 
find undo log files fragment table identity fragment identity provided 
set undo log files information identity local checkpoint processor node created local checkpoint processor node saved file 
information find files 
find files fragment log table identity fragment identity provided 
set files fragment logs information specifies processor node created file starting global checkpoint file global checkpoint file 
log records belonging global checkpoint fragment replica saved file 
schema information crash recovery logical log records marked version number schema 
schema information needed recovery information tables attributes indexes 
recovery performed fragment fragment part table secondary index 
possible log entries table defined 
table dropped fragment restarted mentioned 
schema information regarding attributes need handled 
attributes specified log records attribute identity 
schema information known attributes global checkpoint restore 
known schema version attributes created 
attribute identity log record needs update attribute created obviously attribute log record dropped global checkpoint restore 
attributes ignored log records 
analysis find attributes needed define storage defined current schema version global checkpoint restore 
local checkpoint know schema versions active created 
deduce attributes local checkpoint dropped attributes need added attributes added local checkpoint 
show schema versions concurrently available 
local checkpoint specifies completed schema version time local checkpoint current schema version time local checkpoint 
attribute created current schema version local checkpoint need added 
attributes attribute identity new attributes obviously dropped attributes attribute identities currently defined attributes dropped local checkpoint 
archive copies schema information fragment information information restore fragments written line media tapes archive copy produced 
files archive copy exactly structure described 
processor node treated directory archive copy 
archive copy needs contain copy information entity 
system restart archive copy similar restart information disks 
difference information read line media copied various nodes receive copies restart performed normal system restart 
restarting fragment restarting fragment part system restart 
replicas failed replica survived long flush fragment log disk 
system operational fragment inaccessible 
situation fragment restarted losing committed data 
stand node backup node 
useful fragment large disk 
stand node access data pages backup node undo log node 
able data support version data structures log structure backup node 
restart handling fragment shown 
simple idea basically start physiological undo get action consistent checkpoint undo operations active checkpoint apply logical redo log fragment 
mentioned previously local checkpoint action consistent 
local checkpoint contains set locked tuples checkpoint 
simplify recovery undo operations executing fragment log 
take care independence local global checkpoints 
ensured global checkpoint older local checkpoint 
restart fragment total failure fragment performed algorithm install transaction information local checkpoint install local checkpoint action consistent consists steps execute local undo log start checkpoint marker 
page accessed execution local log main memory read disk 
main memory fragment read pages disk main memory 
undo active transactions starting execution redo log 
case performed aid list tuples involved transactions 
locks set starting execution redo log 
execute redo fragment log global checkpoint production local checkpoint 
log executed log fragment restarted global checkpoint restored system restarted 
recovery different fragments independent 
soon fragment recovered possible start processing requests access recovered fragments 
undo local log local log start local checkpoint redo fragment log fragment log start global checkpoint fragment restart handling undo operations active local checkpoint handling logical fragment redo log fragment logs synchronised 
fragment logs produced primary backup stand need equally ordered 
equivalent terms serialisability 
means fragment log contain marker exactly local checkpoint produced 
possible fragment log generated processor node local checkpoint produced 
possible fragment log stand replica restart fragment 
necessary start processing fragment log point log sure production local checkpoint 
point placed global checkpoint 
global checkpoint defined point fragment log possible find global checkpoints produced production local checkpoint 
certify scheme works check executing log records produced production local checkpoint harm consistency system 
need analyse possible events occur 
log record produced local checkpoint tuple existed executing log record 
need perform event analysis updates inserts deletes 
insert log record tuple exists happen local checkpoint ignore log record 
insert set old values overwritten log records set value set time local checkpoint 
insert log record tuple exist happen local checkpoint 
insert performed local checkpoint tuple deleted log record executed local checkpoint insert safely performed 
possibility distinguish case case log record local checkpoint 
delete log record tuple exist happen local checkpoint ignore log record behaviour deletion tuple 
delete log record tuple exists checkpoint deletion obviously remove tuple database 
way know executing log record knowledge executes local checkpoint 
deletion performed 
tuple certainly inserted log record local checkpoint 
tuple local checkpoint 
update log record tuple exists way know executed local checkpoint perform update 
update sets older value local checkpoint new value certainly set log record 
update log record tuple exist happen local checkpoint ignore log record 
followed delete log record local checkpoint log record safely ignored 
fragment log records executed normal log records 
special actions needed strange situations occur deletions deleted tuples inserts inserted tuples updates non existing tuples 
strange events occur due executing log records local checkpoint 
log records simply ignored known execute local checkpoint produced 
log records executed normally shown action produce consistent database 
creating backup replica stand replica restarting fragment scheme special consideration needed upgrading stand node backup node 
reason transactions ongoing upgrading performed 
stand replica ensures executed committed transactions fragment log 
step start executing ongoing operations 
abort commit new operation tuple transaction arrive execution operation 
event queued execution completed 
wait operations transaction completed 
execution transactions started new transactions queued previous transactions completed 
previous transactions finished queued operations started 
step inform nodes state change 
production local checkpoint produce local checkpoint necessary produce snapshot action consistent database objects see 
mentioned accomplished producing fuzzy checkpoint conjunction physiological logging checkpoint production 
physiological log undo log redo log 
redo log means checkpointed pages overwritten checkpoints 
means directory needed specifies pages 
main memory database possible change having copies data 
undo log means place updating 
verified products prototypes research articles place updating superior method gray 
reason directory pages written time page written causing serious degradation performance 
solution undo log 
consequence necessary wal write ahead log 
means page written disk undo log records stored safely 
index pages tuple pages tuple tuples involved transactions database objects action consistent local checkpoint production local checkpoints performed fragment means portion pages processor node needed 
pages contains data fragment participate local checkpoint production 
pages information fragments stored 
algorithm produce local checkpoint operations fragment stopped 
active execute completed 
new operations allowed start 
active operations completed start checkpoint written local undo log 
includes information tuples locked active transactions directory lh index structure 
information saved operations start processing 
production log records started 
operations hanging lock started started local checkpoint 
ensures complete fragment suffer deadlock due deadlock situation involving tuple fragment 
possible allow read operations continue 
allowed necessary ensure set locks covered checkpoint consistent 
start fuzzy checkpoint process 
means page time locked 
undo log records flushed page written disk 
page written page unlocked 
main memory data versions pages disk need flush log records writing pages disk 
flushed checkpoint finished 
page written disk start local checkpoint activities page logged local log 
information undo log records dependent structures stored pages 
writing log records local logging stopped page main memory described 
pages written disk local checkpoint completed 
checkpoint log record written 
undo log files sent disk files involved local checkpoint 
certain information stored disk nodes informed completion 
part distribution information 
local logging method disk pages normally stored disk accessed reading writing kept main memory buffer 
means pages main memory buffer allowed written disk time checkpoints 
place updating checkpointed pages overwritten checkpoint 
means undo logging performed time checkpointing process 
main memory pages written disk checkpoints 
stored main memory pages 
versions main memory pages disk page writes checkpoint destroy previous checkpoint 
possible avoid lot undo logging 
undo logging needed start checkpoint process actual writing dirty page 
pages clean start checkpoint process preferably taken care immediately need written disk checkpoint 
checkpoint finished pages written version database 
shown 
main memory databases versions disk great overhead cost performance 
method 
method described previous section thesis system optimised 
idea wal avoid crash situations page written disk information undo changes page 
important case version pages exists disk 
versions pages disk needed 
log records written disk asynchronously page writes 
disk data normally version disk wal needed undo log records method crash recovery 
means forcing log disk log sent backup node saved main memory node 
call backup node backup log node owner data call primary log node 
log saved nodes log defined stored safely 
obviously writing log records disk produce lot flushes disk pages actual information needs forced disk time small 
node safe storage decrease amount information flush speeds process neighbour nodes closer local disk modern communication techniques opt method local log disk data 
fragment log handled phase commit protocol system 
need ensure local log safely stored node backup log node writing main memory pages disk 
means need design algorithms handle failures primary log node backup log node 
need handle primary log node failures backup log node failures 
handling failures publicly available nodes consistency system known exist 
primary log node failure node containing data fails backup log ensure log saved disk 
started immediately report primary node failure received 
log saved disk reported nodes 
primary log node restarted backup log node fails seen 
start checkpoint checkpoint start checkpoint page written checkpoint process dirty disk page written give space main memory buffer undo logging needed undo logging needed version switch page version write pages optimisation local logging version version backup log node failure backup log node fails primary log node wal write log local disk page written disk writing log backup log node new backup log node started 
checkpoint processing currently ongoing processing suspended soon active page writes concluded 
primary log node sends log disk soon possible 
finished wal processing started primary log node reports nodes 
new backup log node started soon accomplished wal processing concluded processing starts normally 
checkpoint processing proceed starting new backup log node 
global system checkpoint important part preparation recovery processing know global checkpoint restart system total failure 
global checkpoint completed system restarted 
system keep track global checkpoint finished 
global checkpoint finished transactions belonging previous checkpoints completed log records transactions sent disk 
condition fulfilled system certain able restart system checkpoint cases failure nodes 
system keeps track maximum global checkpoint finished 
coordinator decides new maximum global checkpoint exists information provided processor nodes stored safely disks 
global checkpoint called global system checkpoint 
system restarted find maximum global checkpoint start system earlier global checkpoint 
processor maintain oldest transaction fully completed 
time transaction completes check performed see global checkpoints fully completed processor node 
related method described related method described section 
contributions mainly provide necessary details show crash recovery works situation combination fuzzy checkpoints location replication independent logs local logs 
local undo log new describe detail 
show primary log node fails backup log node flush log disk backup log node fails primary log node starts backup log node starts primary log node recover total failure failure scenario solution global checkpoints various nodes logs location replication independent 
show schema information crash recovery 
informix online dynamic server uses similar scheme undo log record changes database pages logical redo undo log produced describing operations database 
recovery pass uses checkpoints physical undo log create action consistent database 
redo pass followed undo pass performed logical redo undo log 
method uses method ideas chapter enable avoid storing undo information fragment log 
sullivan reports scheme postgres log database stores versions tuples 
assumes existence persistent ram memory avoid frequent disk os 
approach furthermore uses local checkpoint global checkpoint process 
processes synchronised 
approach reported previously checkpointing knowledge author 
reported thesis log records local checkpoint destroy consistency database crash recovery 
certain precautions needed reported 
schema changes section discuss schema change operations performed major interference user operations 
great variety schema change operations possible 
describe 
literature distinction schema evolution change propagation pet 
schema evolution defines schema changes allowed change propagation handles propagation changes existing database information 
chapter deals change propagation 
research literature focused problem schema evolution schema contains tables indexes attributes 
changes affect local data storage prepared actual schema change transaction performed 
attributes methods read readable updatable 
method readable updatable separate method reading updating needed 
method operate attributes tuple method part 
schema contains attribute constraints 
removing attribute constraint pure update schema 
adding attribute constraint means tuples table need checked changed accordance attribute constraints 
covered thesis 
table constraints real time database difficult handle 
sum salaries employees allowed increase limit sum kept tuple updated update table 
tuple hot spot endanger availability data table 
adding table constraints covered thesis 
schema updates triggers covered thesis 
triggers part solution implement schema changes 
adding simple trigger removing simple trigger done simply updating schema information 
complex trigger changes cause problems 
views covered thesis 
referential constraints require set changes schema information described 
tables tuple identifier tuple key affected structure tuple identifier 
case include table identifier tuple identifier 
easy follow link new object 
include table identifier need secondary index tuple identifiers find table identifier tuple 
inclusion table identifier affects schema changes change table structures split merge tables 
show schema changes propagated backup system global replication 
concepts schema changes section concepts schema changes introduced 
soft hard schema changes possible ways update schema 
soft schema change 
case old transactions executed old schema new transactions started new schema 
old new transactions execute concurrently 
case concurrency problem schema information smaller 
option hard schema change 
case transactions old schema executed finished 
time transactions affected schema change start 
schema changed new transactions started new schema 
schema changes performed soft method 
changes incompatible hard method 
example assume old schema contains attribute hours worked attribute payment hour 
new schema replaces information attribute total payment attribute product previous attributes 
obviously updates total payment converted updates total time payment hour 
hard schema change needed 
changes schema information specified adding dropping schema entities 
tables attributes attribute methods attribute constraints table constraints secondary indexes foreign keys views stored procedures added dropped 
changes specified number adds drops 
changes obviously soft schema change 
adding conflict earlier transactions allowed 
dropping cause conflicts 
earlier transactions safely entities dropped long exist new transactions bothered 
means changes schemas serialised 
transactions old schema information committed transactions new schema information 
shown cause problems hard schema changes need serialisation 
changes cause logical conflicts shown 
problem changes specified function map previous entities 
inverse function exist transactions change execute concurrently 
definite border exist transactions change 
implemented hard schema changes 
transactions changed entities finished schema change performed 
problem problem exists updates views 
simple complex schema change dimension schema changes simple complex 
simple schema change executed transaction 
simple schema changes involves schema information 
section refer simple schema changes schema changes involve changes schema information 
complex schema changes long running transactions 
execute complex schema change transaction block update operations long time 
telecom applications require constant availability data updates 
typical example hlr mobile systems nodes keep track mobile phones 
need updated mobile phones move 
need implement complex schema changes set small transactions form long running transactions 
similar approach line reorganisation salzberg 
complex schema changes example long running transaction 
concept sagas garcia control long running transactions 
complex schema changes fit saga model 
idea run long running transaction set transaction 
rollback long running transaction set undo transactions performed 
schema changes type add drop 
provides undo transaction schema changes 
complex schema changes incorporates adding new schema entity depends data tables old schema 
undo long running transaction new schema entity dropped 
involve long running undo transaction 
important part solution problem schema change triggers small transactions 
dayal describes general triggers transactions combined form long running transactions 
contribution thesis apply problem complex schema changes 
simple complex conversion function dimension problem schema changes conversion functions simple complex 
definition introduced 
simple conversion function uses local information tuple accessed create converted data 
complex conversion function information tuples create converted data 
method performing complex schema changes allows simple complex conversion functions 
summary dimensions schema changes soft hard schema changes simple complex schema changes simple complex conversion functions 
simple schema changes involves changes schema information conversion function soft schema changes 
complex schema changes involve changes number tuples 
changes require conversion function 
conversion function case implemented transactions scan tables triggers ensure new schema entities contain correct data 
conversion functions simple complex 
schema change soft hard depends conversion functions 
conversion functions invertible schema change soft 
hard 
handling schema changes section describe important items needed performing schema changes 
schema version concurrent transactions different schema versions system able handle schema version 
transaction uses specific schema version schema change creates new schema version 
version number tagged log records system provides natural path ensure schema changes occur backup system order 
version number handled system coordinator 
node increment version number 
node fails new system coordinator assigned 
new coordinator check maximum known version number ensure nodes consistent 
new coordinator start executing transactions change schema 
version numbers manner creates bottleneck 
bottleneck cause problems 
tens hundreds schema changes performed second 
busiest period number schema changes minute exceed 
bottleneck serious 
active schema change table time 
schema change starts changing table definition transaction start changing table definition concurrently 
true execution complex schema change see section 
means logical lock acquired tables involved schema change execution schema change 
reading schema information user transactions user transactions read schema information stages new versions created process 
user transaction continue schema version stages 
user transaction sets locks schema entities 
ensures hard schema changes started transactions changed entities finished 
transaction tries access schema entity locked hard schema change transaction able read schema information schema version stages 
transaction aborted 
desired possible transaction restarted immediately 
soft schema changes moment locks released version counter incremented 
new schema new transactions 
old transactions continue old schema versions 
execution simple schema change simple schema change performed similar phase commit 
phase prepare phase actions schema change distributed nodes 
software entities prepared handle new tables attributes indexes phase 
involves preparing initial fragments new tables indexes 
involves allocating storage fragments initialising storage 
new attributes prepared handled dynamic attributes exist null 
storage allocation needed new attributes attribute value set new attribute tuple 
attributes methods need software loaded linked database software nodes 
system coordinator schema databases prepare new schema entities save schema change prepared disk commit schema change retrieve new version number save committed disk update version number wait old transactions completed remove schema entities longer wait clean save completed disk start lock schema hard schema change transaction changing schema phase prepare phase phase commit scheme locks entities schema change set 
change soft locks immediately acquired 
schema change hard locks acquired transactions released locks schema information 
locks acquired nodes schema information updated 
update schema information logged disk sending prepare message 
easy discover schema version current restart 
acquiring locks logging disk performing updates acknowledge sent system coordinator 
locks acquired transaction start hard schema change 
transactions old schema completed 
soft schema change performed transactions continue execute old new schema information 
old new transactions execute concurrently 
second phase commit phase 
starts nodes acknowledged locks acquired schema information updated 
step phase acquire version number schema change system coordinator 
acquired commit version number sent nodes 
log message describes commit schema change flushed disk nodes locks released operations start 
version number updated nodes releasing locks 
node ensures schema versions installed order prescribed version number 
commit acknowledged transactions old schema numbers completed 
ensures system coordinator knows old schema longer receives commit nodes 
third phase clean phase similar complete phase phase commit starts nodes acknowledged commit phase 
clean message sent nodes 
tables attributes indexes longer removed software entities 
nodes acknowledged phase transaction change schema completed 
simple schema changes start describing simple schema changes add drop tables attributes foreign keys drop indexes 
operations difficult maintain database system 
table operations adding table easily performed preparing fragments table performing schema change 
old transactions know table new transactions concurrency problem 
reasoning holds adding view 
course attributes table defined schema change 
dropping table slightly complex 
change performed soft manner 
course updates old transactions dropped table dropped 
new transactions able access table 
reasoning holds dropping views 
attribute operations adding attribute simple operation performed soft schema change 
slightly complex prepare 
attribute null easily added 
true necessary prepare tuples number unused null bits new attributes tuple 
attributes specify null attribute defined 
similar treatment add attribute default value simple schema change 
set value function old attributes complex schema change needed add attribute tuples fragments table 
schema change performed preparations completed 
adding method new attribute performed easily preparing nodes handle method 
consider methods operate tuple 
dropping attribute performed soft schema change 
preparations necessary 
dropped attributes remain tuples tuples 
performed local process part copy fragment protocol 
copy fragment protocol transfers attributes 
index operations dropping index simple schema change performed soft schema change 
dropping index means number stored query execution plans recompiled 
performed schema change transaction 
doing schema change ensures real time capabilities user transactions kept recompiling done user waiting 
transactions change schema course take longer time 
time critical operation user transactions allowed schema change 
foreign key operations adding foreign key adding attributes foreign table index attributes adding foreign key 
additions performed transaction change schema information 
normal user transactions perform scan operations needed foreign key 
foreign keys needs set method perform complex schema changes 
foreign key represented set attributes foreign table special trigger referred table 
index attributes normally kept ensure consistency checks actions performed efficiently 
foreign key dropped entails dropping special trigger index attributes foreign key transaction changes schema 
changing foreign key means operation deletion referred tuple changed performed soft schema change 
complex schema changes set schema changes complex require change performed set schema changes set user transactions 
needed databases times performed user transactions written especially particular change needed 
describe general approach handle complex schema changes changes attributes adding secondary index splitting table merging table adding foreign keys 
split merge performed tuples vertically attributes 
complex combinations schema changes 
thesis investigate side effects combinations cause 
general approach complex schema changes phases 
phase schema change adds number attributes tables foreign keys triggers indexes 
adds number triggers foreign keys needed ensure new attributes tables indexes date second phase finished 
add number triggers foreign keys ensure soft schema change possible 
second phase performs scan processes number tables 
phase finished new old tables attributes consistent 
transactions new schema start soon phase completed 
third phase possible execute transactions old new schema change soft 
hard schema changes test transactions schema parts compatible 
phase contains possible security check new schema 
new transactions behave schema change committed 
errors new schema schema change aborted 
security check performed executing test transactions executing small percentage transactions new schema 
executing test transactions completion decision taken abort commit schema change 
schema change management activity handled database administrator 
database administrator responsible handling tests new schema 
telecommunications usually personnel responsible operation maintenance role 
decision abort schema change new tables attributes foreign keys triggers removed old schema kept 
transactions new schema allowed 
decision commit schema change transactions start new schema 
currently executing old transactions executed finished 
transactions started new schema 
old transactions completed phase removes triggers needed scan processes removes attributes change process removes attributes tables indexes foreign keys old schema part new schema 
control flow complex schema change shown 
phase different hard schema changes 
waits old transactions completed 
transactions started wait 
schema changed new schema transactions started 
transactions new schema 
possibility restore old schema system restart 
complex schema changes examples long running transactions 
transactions performed complex schema change finished 
able abort complex schema change system maintain undo information 
necessary decision abort schema change necessary primary system fails change 
complex schema change aborted 
needed completion schema change clean phase 
redo information needed ensure performed cases failures 
redo undo information maintained transactions stored reliable manner 
special saga table store redo undo information 
saga table replicated backup system global replication 
show saga table schema changes 
normally undo entries inserted saga table phase redo entries inserted phase entries deleted phase 
changing schema affects applications top database schema changes extent synchronised software changes 
natural path take perform software change parallel schema change 
new transactions new schema generated new software 
decision continue schema change affected quality new software 
option ensure schema change backwards compatible 
means transactions old schema continue 
case old transactions operate view database schema directly tables database 
soft schema changes combined check avoids circular triggers 
update original table trigger update new table 
update turn trigger update original table 
avoided keeping track originated update 
create new tables attributes foreign keys triggers scan old schema update new schema entities run set test transactions new schema new schema ok remove new schema entities transactions new schema old transactions execute completed remove old schema entities complex schema change phase phase phase phase phase phase change attributes case depends type change change soft hard 
consider changes occur table 
situations consider adding new attribute derived old attributes 
ii changing attributes adding new attributes time dropping old attributes 
show perform change attributes adding derived attribute solved similar way 
phase step add new attributes add method operates old attributes update new attributes 
trigger installed update old attributes performs update new attributes added method 
soft schema change possible inverse method derive new attributes exists 
method exists added trigger updates old attributes inverse method new attributes changed 
performed transaction changes schema information 
transaction saga table updated undo information 
phase scan tuples update new attributes added methods 
operations triggers active 
update tuple scan process treated normal user transaction 
phase scanning tuples fragments table new attributes exist tuples table 
method directions dependent change hard soft 
inverse method exists old new transactions execute tuple order causing problems schema change soft 
case old attributes kept methods triggers kept 
inverse method exists schema change hard 
complex schema change performed described previous section 
add index adding secondary index existing table uses phases index new old transactions 
soon scan process completed schema updated 
creating secondary index empty table compressed phase 
phase phase informs nodes new secondary index schema change 
phase secondary index state specifying building phase 
state secondary index read 
special attribute added table describes tuple updated secondary index 
attribute defined tuple updated secondary index defined 
trigger table specified 
transaction updates tuple secondary index updated special attribute defined 
trigger specified inserts update secondary index define attribute 
entry inserted saga table specifies removal special attribute removal trigger removal index case aborting transaction add index 
phase phase performs actual creation 
process started old transactions completed ensure transaction update index attribute scan process trigger fired 
process tuples scanned entry secondary index created special attribute defined 
phase scan processes completed schema updated reflect secondary index readable 
schema change soft 
entry saga table removed special attribute defined phase 
normal secondary index special trigger updates attributes secondary index 
error handling simple node fails scan process simply restarts scan 
special attribute specify change secondary index performed 
recovery needed faster creation process special attribute specified volatile meaning involved recovery operations opposite durable 
means failures necessitate restart creation secondary index 
problem algorithm index tables 
tables scanned failure handling 
split table types splits possible splits table separates tuples number tables dependent condition 
second splits table tuple split table vertically split 
study operations split table 
attributes new tables split combined changes add drop attributes 
tuple sent new tables 
split complicated foreign keys secondary indexes 
updates scan process change tuple belong new tables 
treated preparation phases triggers 
split performed normal phases 
phase phase new tables created usable normal user transactions 
secondary indexes new tables added 
foreign keys foreign tables refer original table foreign keys updated reflect split 
performed adding new foreign key foreign tables characteristics old foreign key 
original table equipped foreign key refers tuple created new tables 
foreign key specifies tuple new table shall deleted tuple old table deleted 
new schema entities usage shown 
start split process new attributes null new secondary indexes empty new tables empty 
index new foreign key empty foreign keys equal null start 
phase types triggers introduced 
triggers ensure foreign keys secondary indexes new tables consistent scan process 
trigger executed foreign keys foreign tables updated 
foreign key updated referred tuple checked able update new foreign key 
new foreign key original table contains null value scan process reached tuple special action needed 
value foreign key original table copied new foreign key foreign table 
second trigger executed new foreign key original table updated 
update means new foreign keys foreign tables updated 
tuple key original tuple find foreign keys needs updated 
trigger invoked scan process inserts updates changes new table tuple 
third trigger ensures updates table performed new tables 
means updating original table update sent affected new table 
transaction coordinator read original table deduce new tables affected write operation 
reads set write lock ensure proper concurrency parallel updates started secondary indexes new tables foreign keys forth 
updates new table updates secondary indexes new table 
trigger specified inserts inserts new table updates foreign key original table 
cases update affects new tables update tuple moves tuple new table 
example table split salary attribute 
persons salary table new table new 
person receives increase record moved new new 
case update leads update original table delete new table insert new table shown primary node shown replication important problem 
new foreign key original table needs updated reflect tuple moved new table 
sec 
index sec 
index sec 
index fk indexes sec 
index index secondary key fk index index foreign key foreign table old foreign key nf new foreign key fs fs foreign key new tables original table new table new table ii split table tc orig new new update delete insert replicas replicas replicas read set write lock update changes table identity tuple new tables primary node fourth trigger transactions new tables 
updates propagated original table 
performed foreign key new table refers original tuple original table 
inserts new table performed original table 
changes transaction change schema information entry saga table created represents undo information 
schema change soft 
information specifies attributes tables foreign keys secondary indexes removed complex schema change aborted 
phase triggers new indexes new foreign keys inserted scan processes start 
scans original table inserts tuples new tables 
tuple read original table inserted new table foreign key original table updated reflect connection original tuple new tuple 
new foreign key original table null transaction performed needed scan process transaction need performed 
update new foreign key original table fires trigger updates new foreign keys foreign tables 
secondary indexes new tables updated tuples inserted updated deleted new tables 
scan process completed new tables exist new foreign keys updated reflect new tables secondary indexes new tables exist 
triggers ensure original table new tables kept consistent 
completion schema change follows description section 
error handling primary replicas fails scan processes scan process restarted 
foreign keys original table ensures necessary redo performed node failure 
cases desirable original secondary index kept resulting tables creating new new table 
create special problems secondary index created entries refer tables 
index multi table index entry contains tuple key plus table identifier 
vertical split table vertical split simpler split 
foreign keys refer table refer tables 
table keep table identifier problems foreign tables 
necessary create table necessary remove attributes complex schema change 
case caused problems secondary indexes 
table split secondary index normally follows new tables 
necessary update table identifier secondary index entries secondary index 
easy conversion table identifier needed 
tables need secondary index secondary index attributes created follow table 
approach feasible possible complex schema change basic ideas triggers transaction foreign keys 
performed normal phases described section 
phase new tables attributes added schema information 
foreign key needed new tables 
set null start 
value null new tuple created 
trigger needed ensure updates original table reflected new tables 
foreign keys original table null update needed new tables tuple created 
foreign key exists updates original table reflected new tables 
insertion new tables updated foreign keys updated trigger 
foreign key defined delete new tuples tuple old table deleted 
similar trigger foreign key placed new table ensure transactions new table update original table 
complication possible original table contains tuples create duplicates new table 
case updates new table update tuples refer new tuple 
transaction original table updates attributes new tuple affected done care 
refer tuple tuple deleted tuple removed 
update creates new tuple new table 
tuple exist tuple created 
entry saga table created ensures added attributes foreign keys tables indexes removed schema change performed 
phase phase contains scan old table creates tuple copies new tables updates foreign keys old table 
inserting new tables scan process tuple exist new table 
reason split third normal form tables needed replicated information removed new tables shown 
inserts find duplicates insert tuple new tables 
update foreign key refer duplicate tuple 
duplicates removed scan process 
phase performs actual schema change user transactions described section 
nf null new table split table original table nf new foreign key split table vertical split table nn nn new foreign key new table indexes shown merge tables merging number tables similar split 
major complexity comes fact tuples original tables identical tuple key 
problem occurs tuple key primary key 
tuple key tuple identifier contains table identifier 
tuples different tables equal 
necessary include extra information tuple key new table 
description assumes problem exists 
tuple key original tables usable risk duplication tuple identifier problem simpler 
case tuple key original tables new table functions foreign key original tables new table 
foreign keys refer original tables need change table identifier foreign key refers 
refer foreign key includes table identifier needs removed changed merge described 
phase new table created secondary indexes attributes 
foreign key original tables needed 
original tables need foreign key new table 
foreign tables referring original tables equipped new foreign key refers new table 
trigger set original tables updates propagated new table foreign key original table null 
insert transactions update original table new table trigger simplify scan process 
trigger set updates foreign key attribute foreign tables 
trigger follows updated foreign key original table reads new foreign key update new foreign key foreign table 
trigger set updates new table ensure original table kept consistent new table 
sec 
index sec 
index sec 
index fk indexes sec 
index index secondary key fk index index foreign key foreign table old foreign key nf new foreign key fs fs foreign key new tables new table original table original table ii merge tables usual entry saga table created provides undo information remove new foreign keys tables indexes attributes 
phase old tables scanned tuples copied new table foreign key null 
normal completion performed described section 
vertical merge tables vertical merge number tables seen adding number attributes existing table called merge table derive attribute values old table called originating table 
originating table dropped merge kept 
perform merge tables tuple key merge table foreign key originating table 
situation common tuple key seen special case foreign key 
solution works originating table 
foreign keys merge table need handled table remains tuples tuple key 
foreign keys originating table handled ways 
originating table dropped merge action needed 
originating table dropped foreign keys dropped 
foreign keys moved merge table 
description assume originating table kept action needed foreign keys referring table 
merge performed phases change installs new attributes remove attributes 
soon scan process completed new transactions start new attributes 
phase add new attributes merge table 
similar attribute adding index 
attribute null tuple copied old table null specific value 
trigger updates originating table specified 
updates originating table affect tuples merge table refer updated tuple 
update attribute specifies copy performed set 
deletion tuple originating table set new attribute values null tuples referred deleted tuple 
phase merge table scanned tuple new attributes updated foreign key access originating table 
tuple update transaction 
fk merge table new attributes merge table originating table attributes merge table fk existing foreign key originating table vertical merge tables phase scan completed schema change performed 
schema change soft 
schema change includes dropping necessary originating table dropping triggers phase forth 
includes deleting entry saga table 
schema changes backup system schema changes affect backup system changes tables attributes 
affect backup system new attributes represented storage structures new tables handled number new log channels new storage structures 
rest schema changes necessary updating schema information 
schema information perform checks backup system requested application 
checks performed primary system 
necessary ensure updates schema information serialised updates application information 
schema information backup system desirable types schema information backup system 
activated schema information deactivated schema information 
deactivated schema information activated case backup system promoted primary system 
activated schema information marked indicate backup system 
type schema information deactivated backup system promoted primary system 
example deactivated schema information types constraints performed primary system deemed necessary perform backup system 
view represents statistics management systems example information marked active backup system 
idea move processing power primary system backup system 
care taken backup system allowed abort transactions failure cases 
possibility affect primary system report failures cause promotion backup system primary system 
primary system contain schema information replicated backup system 
example special attribute creating secondary index 
secondary indexes independent different systems 
system defines set indexes 
normally requirements application 
database point view necessary equal 
log channel schema information send transactions backup system log channel needed fragments 
define schema information fragment 
version number ticket number 
write transactions including read operations sent log channel 
transaction specifies schema version read 
log records specify attributes 
log records sent log channel specifies fragment table log records tables defined 
schema version attribute identity actual attribute update derived 
problem attribute identifiers reused deletion attribute 
log records contain attribute identity attribute name schema version specified deduce attributes updated 
ensuring attribute identities reused previous user attribute identity dropped schema information needed information specifies attributes stored 
simple schema changes schema changes important backup system adding dropping tables attributes 
affect execution backup system 
operations affect schema information performed replicate schema information backup system primary system needed 
information deactivated backup system promotion primary system 
table added fragments need set log channel 
log records start shipped backup system 
log channels set phase preparatory phase schema change 
dropping table log channels performed transactions completed systems 
attributes added part preparatory phase transaction changes schema committed transaction sent log channel schema information 
information dropping attribute sent log channel schema information 
actual dropping attribute performed clean phase 
software entities backup systems reported removal attribute attribute identity reused 
complex schema changes complex changes saga table saga table part schema information replicated backup system 
saga table promotion primary system undo changes completed 
remarks complex schema changes drawback consumption computation resources memory processing resources 
avoid difficult 
possible method change fragment table time complex schema change 
old new schema copy data 
case 
course change complicated impact low level details database software 
method install extra hardware schema change needed 
necessary dimension system schema changes 
equipment temporarily performing schema changes 
achieve possible perform line reorganisation system disturbance 
dbms uses methods described thesis efficient implementation triggers 
related research articles schema changes dealing schema evolution object oriented databases pet 
concept soft schema change author thesis 
common treat updates schema information normal transaction 
means schema version active time hard schema change achieved 
similar concept soft software change nils 
software changes involves changes data structures similar nature schema changes 
ideas reused area schema changes 
salzberg number small transactions change record id tuples 
record id contains physical page id difficult database 
transaction record possible perform changes record id seamless fashion 
dayal describes general triggers transactions combined perform long running transactions 
thesis applied approaches solve problem complex schema changes schema changes require database reorganisation 
mohan uses different method create indexes line system 
log approach 
triggers combined transactions log approaches techniques common techniques perform line 
thesis exclusively triggers transactions 
reason simplicity 
solutions elegant easy understand 
combining soft schema changes network redundancy new area 
king briefly mentioned schema changes separate log channel primary system backup system 
implicit hard schema changes normal transaction update schema information 
method saga concept garcia handle schema changes conjunction system crashes network redundancy 
saga table find undo ongoing complex schema changes crash system 
undo complex schema changes performed simply dropping tables attributes created phase 
undo complex schema changes considerably simpler general sagas 
describes implementation schema changes complex schema changes handled combination user defined conversion functions migration functions 
schema change performed different order thesis 
begins performing schema change 
actual change objects performed object access object 
possibility perform soft schema changes mentioned assumed hard schema changes supported 
method conversion functions applied data accessible applications 
provides possibility execute test transactions schema change generally accessible applications 
method briefly describes schema change integrated software change 
lerner lerner treats complex schema changes 
develops special purpose language specifies propagation data old schema new schema 
distinction change propagation conversion emulation 
conversion converts old objects new objects emulation provides new old schema interface converts proper schema 
method thesis possible approaches 
software changed simultaneously schema conversion appropriate 
old software needs function changes emulation appropriate 
emulation approach mean old schema new schema provided views methods stored procedures 
kim treats versions schemas 
approach provides possibility schema versions concurrently 
respect similar kim 
kim treat simple schema changes adding removing attributes adding removing classes superclasses discussion conversion functions kim 
databases support simple schema changes add remove tables attributes methods 
dbs semi relational database axe dbs 
supports line hard schema changes complex 
providing special purpose language reads data old schema transfers new schema 
reports written concerning perform complex schema changes stopping system 
reports dealt managerial problems maintaining schemas schema evolutions allowed 
line schema changes performed implementations essential systems rarely reported literature 
solution section received inspiration software change management 
similar ideas nils 
section contains results rarely reported complex schema changes 
items need developed complete check possible schema evolutions supported 
possible specify algorithms section simple fashion deal changes tables attributes foreign keys indexes 
resulting implementation algorithms left system 
creating indexes line discussed number reports ibm zou 
approaches handle creation index outage 
approach concept derived chamb minor modifications 
number protocols change schemas developed 
seen general approach handle complex schema changes 
approach chance usable type schema change 
solution derived making set related simple schema changes set scan processes create new tables attributes indexes foreign keys new schema 
possible changes 
important issue consider combining different schema changes schema change transaction 
side effects combinations easily predicted 
open research issues area 
new variant lh lh section describe lh extension lh lh described karl 
lh lh extension lh described litwin lh distributed version lh litwin 
main difference treatment local linear hashing function 
idea improve data structure linear hashing 
extensions original idea lh developed cooperation reported details implementation lh atta 
data structure extended storage tuples index 
approach possible find tuples disk read 
main focus decrease number cache misses index main memory 
accessing storage structures cause cache access 
cost cache misses equivalent cost hundreds assembler instructions cache misses generation processors 
important decrease number cache misses number disk os 
describing extension lh lh briefly describe lh lh lh lh 
lh hash algorithm provides dynamic growth decline 
achieved performing growth small steps big step 
hash function key provides hash value 
hash value mapped bucket 
number buckets algorithm determine bucket 
bitwise hash value performed 
keep significant bits hash value 
resulting value equal greater resulting value bucket number 
resulting value smaller perform new bitwise ff hash value 
value bucket number 
time key added increase counter time remove key decrease counter 
counter goes certain threshold bucket split counter goes certain threshold buckets merged 
example bucket number bucket split 
merge occurs bucket merged 
split bucket occurs calculating hash value key bucket performing bitwise hash value 
keys get value kept bucket moved bucket number 
major extension lh compared lh bucket processor node local data structure page 
lh involves advanced schemes perform splits clients know parameters lh algorithm 
features lh thesis splits fragments performed atomic action 
lh lh extends lh lh scheme internally processor node 
hash value necessary careful hash value bits 
way lh extension lh lh lh static number bits hash value find direct hit element 
handling hash value bits shown bits hash value lh variant 
name suggests hash value steps 
step access lh bits 
bits specify fragment identifier tuple 
distribution information find replicas fragment 
normal lh uses static distribution 
simple function translates lh bits node address 
requirements reliability means possibility dynamically move fragments available 
lh lh bits fragment identifier 
fragment identifier index table 
table replicas fragment shown 
step lh bits 
pointer simple directory shown 
directory simple array page identifiers 
page index find correct buffer correct page predefined calculation 
page index fixed number bits 
example assume page index bits page size kbyte 
page index bits means buckets stored page 
bucket splits merges performed normal linear hashing function lh bits page index form bits local linear hashing function 
number bits page index fixed creation table 
fixed large value number tuples table large 
allocates page kbyte time memory needed 
number lh bits dynamically grows shrinks affecting number lh bits 
reason bits reside left side lh bits 
lh bits grow shrink 
number lh bits grows number lh bits decreases 
lh split occurs bit lh bits transferred lh bits lh bits 
bits page index bits lh bits bits lh bits bits bits hash value bits hash value bits lh bits fragment table backup node stand node directory pageid index pages lh bits page index primary node buffer buffer hash value bits lh happen split simply pages lh bit number stay pages odd lh bit number moved new storage node 
easy see easy split fragment 
simply matter splitting directory 
approach see finding correct bucket entail searches large data structures 
number fragments grows large problem 
local index searched directory accessed 
directory kbyte normally cache memory 
access pages entail cache case prefetching performed ensure full bucket fetched main memory 
cache needed access index 
course data structures needed find proper directory page forth 
details data structures jointly developed atta 
access small data structures normally cache memory 
data structure lh ordinary linear hashing directory find linked list disk pages 
special handling internal structure pages described litwin 
larson implementation linear hashing main memory developed 
data structure shown 
lowest bits linear hashing value pointer segment table higher bits pointer directory table 
elements traversed key compared searched key 
obviously fast method find data main memory long linked list long 
directory segment segment segment element element element element element element element element element element element element data structure linear hashing main memory shown larson analysing data structures cached computer architecture find directory cache time 
segments caches segments hash table 
large table consisting records segments kbyte 
means easily mbytes segments processor node gbytes memory 
elements cache memory element access cause cache performance search hampered number cache misses cost performance modern processor architectures 
solve problem cache element access put number elements container 
container suitable size size cache lines 
problem possible segment access solved page index part linear hash value 
bucket predefined place page easily calculated 
describe solution method elements placed segment 
data structure somewhat complex executes faster 
resulting data structure shown 
analysing data structure see directory structure cache memory 
accesses containers cache misses 
probability cache high containers larger cache lines 
full container prefetched main memory cache memory ensure cache container access 
number cache misses data structures substantially decreased compared normal data structure 
containers fixed size easily lead waste memory 
reason containers contain zero element waste lot memory 
counter problem container fixed size containers 
container 
described detail section 
side benefit get data structure usable disk access 
possible pursue idea integrate tuples structure 
increase size elements point containers lost 
indexes charging database store indexes main memory 
better index structure fast access element 
access tuples fast cache see chapter 
directory container head container element element head container element element element element head container element element element element head new data structure linear hashing pageid index page lh bits page index negative effect algorithm bucket split creates 
previous approach relink elements 
number cache misses method splitting 
computing resources cheap generation processors long cache misses occur 
copy fragment protocol study details data structures describe copy fragment protocol 
creates requirements data structures containers elements 
fragment created primary replica node executing state transition protocol system informed new copy 
basic idea algorithm copy fragment simple 
sending node sends fragment tuple tuple sent 
sent new state transition protocol executed inform system new copy data 
receiving node receives write transactions state transition protocol executed 
tuple arrived write transaction performed applies write transaction tuple tuple arrived ignores write sends phases phase commit protocol 
insert operations performed new replica 
idea protocol modification extension dynamic data distribution protocol described chamb lh lh bucket transfer protocol described karl 
sender receiver node fails copy process copy process aborted restarted new sender receiver nodes 
alternative solutions possible solution copy fragment protocol handled primary replica time copy created 
simplifies action taken receiver node copy process 
tricky part primary replica hand control new copy system 
performed state transition protocol performing new copy involved committed actions 
problem transaction committed state transition protocol executed reach primary replica state transition protocol completed primary replica fails commit message arrives new copy informed commit message 
new copy able find coordinator transaction primary replica fails 
able find coordinator coordinator flushes transaction state log 
happened mean data locked log searched find transaction state 
solution primary replica inform coordinator new copy prepare phase 
necessary copy process state transition protocol started outstanding transactions added add new copy prepare phase 
algorithm descriptions show achieve protocol new data structure lh idea fragment consists number buckets lh algorithm 
bucket time transferred 
simple way proceed simply lock bucket records 
locks granted tuples transferred 
creates simple way move records locking table 
opt fine grain algorithm tuple time transferred copy process cause deadlocks 
deadlocks occur bucket locked transactions trying lock tuples bucket 
copy process splits merges buckets controlled 
scan process starts bucket proceeds allowed merge buckets copy process 
reason merge moves elements bucket earlier list buckets seen 
problem overcome keeping elements move backwards special list ensuring tuples elements refer moved new replica 
splits problems elements moved bucket 
receiver need bother splits merges 
sender specifies buckets start transfer fill level 
notify receiver changes occur transfer 
receiver sets proper number buckets hash table start copy process 
tuples received receiver split merge proper amount buckets get proper fill level buckets 
split merge proceed normal linear hash function 
algorithms necessary protocol 
sender receiver algorithm handle copy process algorithm handles write transactions occur copy process 
algorithms shown 
loop transfers bucket starts set phase 
phase involves setting receiver understand messages bearing tuples arrive 
necessary tuples transferred array bytes 
descriptive information transferred set phase 
sender node scan algorithm perform set sender receiver state transition protocol create new copy copy process merge moves element earlier buckets problem merge copy process set state fragment moving set tuple state tuples moved buckets tuples bucket acquire simple read lock tuple lock granted tuple state moved read send tuple wait acknowledge receiver node set tuple state moved release lock set state fragment moving state transition protocol new copy created receiver node copy fragment algorithm start state transition protocol create new copy discovered state transition protocol new copy created discovered tuple received sender node tuple exist acquire exclusive lock insert tuple release lock endif send acknowledge sender node major problem copy process inserts 
ensure tuples missed simple method performing receiver node 
risk scan process sender misses tuples 
avoid unnecessary copy process sender best effort ensure inserted tuples transferred 
shown receiver check duplicate tuples sending tuple existing receiver catastrophe 
sender node checks list nodes involved operation find receiving node involved transaction 
receiving node involved sender node knowing due commit protocol 
mentioned harm done case 
sender transfer tuple scan process discovered receiver node duplicate 
sender node write transaction algorithm insert receiving node involved transaction set tuple state moved perform normal operation endif receiver node performs insert operations 
performs read update delete operations tuple exist arrived previously 
operations tuples exist arrived handled successful reported transaction controller 
ignore operations reflected tuple arrives 
possible tuple copy mini transaction locks tuple moving 
copy process serialised normal transactions 
receiver node write transaction algorithm insert perform normal insert tuple exists update delete perform normal write transaction tuple exists update delete ignore writes send positive phase commit messages detailed data description described algorithm copy fragment prepared describe details data containers elements 
container data better understand details container describe data structure detail 
header contains information items 
contains length container allow variable container length 
maximum size container bytes bit container length space allocated byte chunks 
header indicator specifies container page overflow page 
container page pointer contains page index page 
means gbytes pages accessed pointer 
pointer pointer table page 
table specific frag ment 
case fragment address gbytes overflow pages 
header extended bytes bytes 
option larger page size overflow pages 
container indicator containers bucket 
indicate container achieved setting bit pointer page bit container 
method save bits container header 
overflow page id mapped table physical page id possible location replication independent index 
system restart fragments created different nodes created node 
number elements container 
overflow pages simple handle page pointer 
overflow page time 
simplify recovery overflow page fragment 
fragment recovered overflow pages recovered 
element data element data structure shown 
ensure small overhead data structure 
tuple locked need transaction pointer full bit header hash value lock mode tuple status lock status local key length tuple key length 
tuple locked transaction pointer needed 
enable fast searching hash table need keep local tuple key length tuple locked 
place transaction pointer simply move hash value tuple status lock mode transaction record 
get bits transaction pointer 
transaction pointer find transaction record lock owner lock queue transaction record 
container length bits element element overflow page id bits container data structure assuming kbyte pages bit pointer page container length bits element element pointer bits bit pointer page page index bits container bit unused bits tuple status bit lock status bits hash value bits local key tuple key element data structure tuple key length bits local key length bits transaction pointer bits lock status bits local key tuple key tuple key length bits local key length bits lock status unlocked lock status locked transaction record lock mode hash value tuple status tuple status copy fragment protocol indicate tuple moved 
ensure concurrent copy process proceed simultaneously bits 
concurrent copy processes handled simultaneously 
copy process handle sending fragment node 
lock status contains information tuple locked locked lock mode specifies type lock 
local key length contains length local key 
local key find tuple machine 
contains page identifier page index size local key needs bytes large database tables 
index secondary index index table local key sought attribute 
tuple key length contains length tuple key 
lengths counted number words bytes 
size zero means word key length key 
keys length handled short keys handled efficiently terms storage overhead 
hash value placed element reason speed split merge processing 
optimisation linear hashing suggested 
storing full hash value purpose creates large memory overhead storing window nineteen bits hash value 
purposes 
bits minimum number lh bits bits fragments needed split processing 
fragments minimum number entries directory table 
bits minimum case 
bits grow hash table times hash value window missed 
window missed bit hash values tremendous growth index 
window gets misplaced window moved 
performed setting fragment status window hash value bits 
means hash value needs computed split merge processing 
fragment record describes new window 
insert operations storing elements 
background process starts move window 
bucket time processed window changed computing hash value storing new window 
performed element locked interfere transaction processing 
background process completed status fragment updated new window hash value split merge processing 
page memory handling buckets hash table size storage buckets 
necessary careful memory area pages 
allocation new page storage buckets buckets assigned positions bytes bits page index bits lh bits bits lh bits bits unused bits hash value window split merge processing bits bits split merge processing container header 
elements inserted access manager tries allocate memory consecutively limit 
successful size container simply grows allocated amount 
limit space consecutive containers 
spacing dependent cache line size computer 
current computers cache line size bytes suitable spacing 
processors ultrasparc ii alpha handle outstanding cache misses simultaneously bytes current systems 
generations cache line size increase spacing increase 
appropriate increase processing time larger cache time 
spacing carefully tuned generation 
need header area page advantage get overflow area 
spacing slightly smaller bytes 
byte key size common benchmarks defined normal element size bytes byte local key 
size zero elements bytes size element bytes elements bytes elements bytes elements bytes elements bytes 
byte keys keys bytes 
byte keys keys bytes byte keys keys bytes 
discussion derive bytes suitable spacing 
allows room byte header page overflow area consisting byte buffers 
byte buffer contain containers 
container grows referred left container grows buffer referred right container 
right containers overflow containers 
buffer container ends longer free list 
free space buffer handled locally containers 
page allocated free list byte free buffers free list right containers 
overflow buffers allocated right side moved free list right containers 
left container grows high limit right container removed free list 
left container grow way bytes 
limit bytes left container grows low limit right side container put back free list 
page data structure shown 
page data structure gives different containers 
left container grows right right container grows left 
look grow different directions 
page size easily extended larger sizes 
size kbytes containers free containers page header bytes 
cache line size grows buffer size grow 
perfect fit comes buffer size bytes 
case byte tuple keys keys container byte tuple keys keys container byte keys keys container byte keys keys container cases perfect fit 
element split containers buckets organised linked list containers described 
important reflection element cross boundary containers 
easier handle large keys data structure 
small keys table option avoid element split 
catering element split cost little bit performance suitable parameter hash table 
marker indicating container begins middle element necessary 
reason processing starts container proceeds 
processing context held local variables markers needed 
overflow handling overflow pages arranged manner original pages 
overflow page page container page pointer 
simplify recovery desirable overflow page fragment 
overflow handling simple overflow page time allocated 
split join handling local bucket split join maximum load factor number elements fragment element sizes maximum load factor 
load factor gives bytes bucket maximum load factor 
bytes added bucket split initiated load decreased bytes bucket join initiated 
bucket split larson method larson necessary rearrange pointers 
amount instructions perform action small 
number cache misses substantial necessary access different memory areas 
new method elements moved split copied head byte byte page header bytes head byte byte head byte byte byte kbyte page size page data structure free buffers static bucket buffers byte limit limit high low new container 
bucket split compressed 
means new method uses instructions method 
instructions performed small number cache lines cache misses occur 
fragment split join splitting fragment easy model 
simply matter splitting directory 
directory entries zero bit stay directory new position bit move new directory 
large data structure consisting page mb page gbyte pages split affects original directory size kbytes new directory size kbytes 
process simple copy process performed microseconds 
hash table remember split split information sent nodes distributed database 
lock handling lock data structure combined index structure essential accesses tuples go index tuple key 
locks tuples stored disk handled manner ensuring disk pages removed main memory locks page released 
data structure locked tuples main memory index normal lock data structure gray 
secondary indexes unique secondary index structure unique secondary index difference tuple key secondary key local key sought tuple key 
non unique secondary index options index non unique secondary index non unique primary index 
non unique index major difference elements key 
different ways handle 
list elements search structure bucket 
index primary access tuples index normal index tuple key 
difference tuple key specified lh consists tuple key table secondary key 
necessary provide tuple key secondary key able find tuple 
handling physiological undo log shown chapter necessary physiological undo log connection fuzzy checkpoint able create action consistent checkpoint logical fragment log 
supported index structures data server 
system crashes ongoing transactions aborted 
system restarts locks tuples set 
information stored index structures basically mapping key local key connection lock information key 
actions need logged inserts key container deletion key container locking key container deleting overflow container creating overflow container allocating overflow page deallocating overflow page moving elements containers split merge elements updated local key updated 
unlocking key necessary log mandatory crash 
key unlocked lock key entry removed undo log 
ensure locks removed restart locks time checkpoint logged undo log 
item undo log checkpoint specify size directory time checkpoint size directory overflow pages 
accesses overflow pages go directory ensure checkpoints location independent 
structure linear hashing especially suitable computers cache memory cache equivalent large number executed processor instructions 
fits small key sizes byte keys benchmarks developed benchmarks 
reflects real life applications normally short key 
larger keys 
variable sized keys supported 
indexes instance addresses file names better provided index types 
addresses preferably handled tree structure compression shown chapter 
tree structure compression results smaller storage space linear hashing structure fast access tree structure small storage overhead 
indexes telephone numbers structure speed important compressed tree structure memory space important 
optional parts hash table stored record describing hash table 
record accessed types accesses 
number records fairly small accesses incur cache misses 
linear hashing method types tuple keys primary keys tuple identifiers 
primary key long tuple identifier assigned tuple key 
primary key secondary key unique index 
index index needed 
typical example news demand application documents accessed document name 
tuple key unique secondary index 
unique secondary indexes linear hashing method 
nonunique secondary key indexes method adaptation described 
compressed distributed tree tree need ordered data structures applications trees popular variant 
distributed variant trees root page fully replicated processor nodes database 
root page fully replicated possible find processor node immediately 
root page changes tree fragments join split tree fragments move 
changes handled state transition protocol 
ordered index means possible compress keys certain keys addresses file names timestamps telephone numbers forth 
show accomplish compressed distributed tree 
ideas compression course valid local tree 
distributed tree types secondary indexes 
tuple keys studied thesis 
data structures described useful unique secondary index non unique secondary index 
ideas chapter development prefix trees bayer gray 
developed extensions useful 
important note nodes chapter describe part page 
node tree 
contrast chapters node short form processor node 
compressed tree long names index uses fact names organised alphabetical order differ neighbours list 
compress data structure factor 
speed processing data structure memory better hit rate cache memory 
starting point structure normal tree structure 
storing full name entry difference previous entry stored 
index maps name tuple key local key tuple key index 
tuple key file handle data server implement scalable file systems 
example compression algorithm provided start www ericsson se ndb description html www ericsson se ndb html www ericsson se ndb system arch pdf www ericsson se ndb system arch ps describe compressed algorithm need start value equal start 
described equality bit bit minus plus bit difference information exists bit extension html bits bits bits equal bits node bytes equal bit bit minus plus bit difference information exists bit extension pdf bits bits bits system arch bytes equal bit bit minus plus bit difference information exist extension ps bits total bytes bytes originally 
amount compression course dependent naming style forth 
substantial compression cases 
tree organised normal tree number pages organised hierarchical structure 
pages tree structure find key page 
nodes smaller size pages bytes 
node sequential search performed compression algorithm 
means types nodes 
type top intermediate level nodes page find leaf level nodes page 
leaf level nodes leaf level nodes top intermediate level page leaf level node leaf level page 
data structure types nodes shown 
header type contains bits bit specifies byte counts bytes equal word second bit specifies bits bits minus plus information third bit specifies difference information 
cases descriptive information single byte cases 
example index telephone numbers extensions common ends telephone numbers 
list telephone numbers contain byte telephone number 
header type bit extension type bits minus previous bits plus previous bits equality bits difference information bytes right node pointer byte left node pointer byte header type bit extension type bits minus previous bits plus previous bits equality bits difference information bytes right page pointer byte left page pointer byte header type bit extension type bits minus previous bits plus previous bits equality bits difference information bytes transaction pointer lock status bit tuple status bits tuple key length bits tuple key intermediate top level nodes leaf level nodes top level intermediate level pages leaf level nodes leaf level pages different element data structures lock status unlocked lock status locked lock status bits transaction record tuple key length tuple key tuple status lock mode table different uses header information shown 
information bottom tree similar lh data structure 
tuple status moving tree fragments tuple key length tuple key lock status 
information locked transaction record pointer put tuple key tuple key length tuple status indicate moved moved fragment split lock mode temporarily saved transaction record 
alternative solution place lock information data structure allows room tuple key length 
copy fragment protocol transfers bucket time need tuple status 
tuple key length static tree need tuple key stored element 
need index mapping telephone numbers identifier specifying country state owner number resides bytes bytes entry index 
telephone numbers earth index fit gbyte memory 
index city subscribers need byte identifier telephone number 
bytes mbyte storage full index 
fit cache memory high computer 
table possible ways header information equality difference information exists bit bit minus plus minus plus number equals extension type difference information bit upto bytes bit upto bytes bit upto bytes bit upto searching tree search starts root page proceeds downwards 
difference information stored entries tree necessary start value levels search 
start value difference information real key stored 
root node root page start value null 
search top bottom necessary store start information 
search able calculate start value levels 
management tree easier start values stored page 
requires study details tree 
seen searched key compared key smaller equal key follows left pointer follows compares key smaller equal key follow pointer 
start value node pointer points key keys greater key node 
manner proceeds nodes page 
moves new page page start value root node page proceeded tree respect pages 
means start value page leftmost item start value value keys greater seen 
seen analysis start value implicitly known time search index performed 
storage start values needed behalf searches 
splits nodes occur pages split left node page start value node page split 
right node page receives start value equal rightmost key left node page 
value inserted level split level 
tree structure nodes keys shipped nodes pages 
case rightmost key remaining node page update level ship level 
left pointer key pointer key right pointer left pointer key pointer key right pointer root node keys keys fulfil key left pointer key pointer key right pointer left pointer key pointer key right pointer nm keys fulfil key start null start key start key start key assignment start values search compressed tree index scan operations 
operation start bottom tree leftmost node 
start value null 
start value element entry scans keep track start value 
elements inserted deleted entry right updated difference left neighbour changed 
inserted records inserted start value calculated search 
key node page deleted start value node page updated affects element node page parent node page 
needs updated tree uses pointers directions ensure fill level high 
page split anyway page split ships node new page 
reason improve real time performance split pages root level occurs 
time overflow page occurs move node new page 
split activity spread longer time better real time behaviour 
index compact better fit main memory 
index map global telephone number country code bytes number needed numbers earth fit gbytes 
left pointer key pointer key right pointer left pointer key pointer key right pointer root node leaf page key element key start key left pointer key pointer key right pointer intermediate page intermediate node leaf node element start key start key leaf page keys fulfil key assignment start values pages page full split needed split split process pages memory handling architecture perform cached computer architectures nodes size fits size cache lines 
node size bytes appropriate see reasoning section 
size node insert exceeds bytes causes split shipping elements neighbour node 
large key inserted larger bytes nodes size bytes 
normally size elements small scheme 
split merge tree fragments split performed performing proper split root page tree fragment 
part tree replicated processor nodes containing tree part includes root page 
new pages allocated root pages 
root pages assigned tree fragments internally processor node 
new root page refers split pages created 
split processor node accept requests search old non split fragment split fragments 
replicas tree fragment performed split split performed distributed level state transition protocol 
old new fragment identifiers particular requirement stopping traffic state transition protocol 
operations old fragment identifiers completed created root page removed tree fragments independent fragments 
move fragments performed needed 
merge performed order 
tree fragments merged moved processor node replicas 
local merge performed followed operation update distributed information 
copy tree fragment necessary copy fragment tree performed simultaneously lot transactions update tree fragment 
necessary move keys tuples possible coarser locking linear hashing protocol 
copy leaf level node time new fragment copy 
starting copy process lowest node possible easily find key received new fragment 
key start value key copied 
receiver upper levels tree created building independent tree structure 
received nodes seen new keys inserted tree 
major difference normal inserts inserts inserted tree 
previous copy fragment protocol sender fragment primary copy owner 
cases copy fragment 
indexes copies attributes table index created tuples table 
reliability index critical tuples 
necessary support stand copies indexes support backup copies needed 
algorithms needed scan fragment receiver receive scanned nodes algorithm sender receiver handle operations index copying fragment 
scan algorithm sender inform copy process starting state transition protocol start fragment set read lock leaf level node read lock node acquired read node send node ack receiver release lock node goto start copy fragment finished locking node needs done carefully deadlocks easily occur 
transaction owns lock node allowed acquire new locks transactions allowed set read locks 
problem occur nodes split keys shipped neighbour nodes pages 
solved pointer situations 
splits create new nodes right 
trying lock node split node create new node left 
possible new node missed copy process 
splits occur part copied create problems inserts triggered split performed independently receiving node part transaction 
problems merging easily solved allowing merges occur copy process 
page splitting merging affect nodes cause problems scan 
algorithm receiver receive node simple 
inserts new node updates upper levels tree fragment particular update root node reflect new fragment 
operations sending node continue usual need check node status ensure read locked inserting deleting 
operations receiver node performed usual start key tree fragment operation acknowledged performed 
operations indexes performed starting primary normal tuple operations 
node data structure discussion obvious node needs status bit pointer 
lock status bit useful leaf level nodes 
handling physiological undo log undo log tree similar handling lh difference containers nodes 
related bayer gray reports prefix trees suffix trees 
tree implementation extension prefix trees 
extended having tree structure pages 
important achieve usefulness gained prefix trees 
searching page sequentially prefix trees simply idea 
implementing nodes page size adapted cache lines node needs searched 
modern processors extremely fast processing working cache structure useful 
extensions added common endings common addresses file names 
commonalities neighbours handled 
prefix method levels tree 
mainly leaf level benefits certain commonalities www removed higher levels 
new compressed distributed tree described useful developing secondary indexes long names telephone numbers timestamps forth 
useful implementing distributed file system parallel data server 
secondary index translate file name file handle file handle get direct access file attributes 
data structure tuple storage ideas described section developed cooperation david larsson 
details data structures lars 
aim chapter describe design tuple storage 
includes copies tuple parts avoid need logical undo log 
action consistent checkpoint provides opportunity remove need logical undo log copies tuple parts undo log records data structure tuples 
tree structure tuples enable flexible tuple structures 
details handling pages 
undo log tuple storage 
handling large attributes 
ideas lehman shown integrate tuple storage support large attributes 
recovery support tuple storage recovery model provides facilities advanced data structures tuple storage 
provides possibility avoid saving logical undo information log 
logical fragment log necessary undo information ensure data structures consistent fragment log executed 
small physiological undo log needed connection logical fragment log redo log 
main memory databases common redo log dali dbs dbn 
record updated copy record created 
copy destroyed update committed 
possible main memory databases checkpoint 
data structures intact recovery 
common procedure achieving transaction consistent checkpoint copy committed records disk pages 
data structures disk necessarily look data structures main memory 
disk databases common fuzzy checkpoints aries 
means recovery internal data structures consistent 
tuple copy pointing wrong place 
page trusted 
databases undo redo logging scheme aries informix 
possibility exists redo log disk databases 
requires uncommitted data written disk 
undesirable buffer manager choose write pages disk flexible way 
recovery scheme provides action consistent checkpoint 
necessary provide support logical fragment log 
implemented performing fuzzy checkpoints conjunction physical undo log 
physical undo log possible restore data structures checkpoint time 
aim keep undo log sent disk small possible 
action consistent checkpoints interesting implications data structures tuple storage 
implication trust pages database 
reason create consistent copy pages database 
pages value time checkpoint 
action consistent implies actions ongoing problems due tuples middle update 
trust pages implies things scheme main memory databases databases 
redo log allow buffer manager write pages disk flexible manner 
implies new copy changed parts tuple stored database pages 
storage structure tuple span pages 
allow totally flexible data structure tuple 
copy tuple parts various applications put different requirements tuples 
applications telecommunications large records attributes 
times applications data model highly optimised performance 
desirable build data structures contain unnecessary known limitations 
desire flexible data structure performs simple cases 
flexible structure means avoid creating large copies tuples update small parts tuple 
affected parts need copied 
decision store tuples data structure shown 
shown copy tuple header contains necessary undo information 
case tuple header updated copies tuple clusters needed transaction 
soon transaction completed copy tuple header removed 
scheme provides simple means querying old versions tuples 
case keeps copies certain needed querying transaction 
optimisation scheme allocate copies small number pages pages time 
means accesses pages hit cache level 
means copies little memory space 
copy tuple header tuple header attribute cluster attribute cluster attribute cluster page page page 
page data structure tuples concept tree structure tuple storage possible arbitrarily large tuples 
general structure tuple shown 
entities contain part data tuple 
data structure tuple internally tuple basic organisations possible gray 
structure shown uses fixed positions attributes 
means additional data structure needed specifies fixed positions 
course attributes variable length need special treatment scenario 
second structure shown 
case tuple contains directory 
attribute fixed position directory entry directory points attribute tuple 
means extra data structure needed show attributes stored 
th th tic tic ac ac ac ac ac ac th ac organisations general structure tuple th tuple header tic tuple index cluster ac attribute cluster header attribute fixed position tuple structure attributes fixed positions header 
attributes attribute pointer tuple structure attributes flexible positions flexibility second data structure severe cost memory space introduces possible second cache reading directory 
study closely scheme attributes fixed position 
structure tuple header show example tuple header organised briefly describe various fields 
describe pseudo language 
int type header int words store null bits int words store attribute fields tuple header int tuple index clusters attribute clusters tuple header int type copy tuple header copy tuple header updates tuple int type dynamic attributes dynamic attributes optional attribute set int word consisting null bits optional attribute set sequence int offset start word tuple structure cluster referenced int type referred cluster referred cluster set int attribute field tuple header clusters headers discussed chapter similar structures 
common tuple structures simple structure 
common tuple benchmarks tuple fixed size bytes 
contains attribute null words header information copy tuple header null bits 
comes bytes attribute information 
means tuple header bytes overhead tuple bytes 
possible decrease overhead 
basic idea tuple headers tuple clusters attribute clusters data structure 
type data structure known 
common information data structure byte specifies type 
support various data types tuple different data types foreseen database 
fixed size attributes various lengths bits 
fixed arrays fixed size attributes arrays fixed size attributes array variable length 
fixed size attribute different types 
unsigned integer signed integer floating point number decimal number datetime character forth 
type meaning database operations performed attributes 
simply stored retrieved database really care attribute type 
complication data types variable arrays blob 
type attribute needed store multimedia objects shown applications described thesis 
arrays put fixed start position 
allow provide fixed part tuple 
fixed position tuple actual variable attribute dynamic part tuple 
structure cause problems size array increasing decreasing 
necessary reallocate data attribute size increasing decreasing 
opt separate data structure particular variable array element 
structure reuses structure tuple shown 
attributes described null able null attributes 
null bit assigned null bit tuple 
null take space fixed area 
table store attributes classes object oriented database 
example table store base class inherited classes 
classes common tuple key normally object identifier tuple identifier terminology scenario different tuples table contain different attributes 
idea put attributes fixed area 
waste memory space 
solution provide support dynamic attributes 
attribute part tuple need 
attributes put special dynamic part tuple 
application needs functionality charging server described section 
dynamic part tuple referenced tuple header 
dynamic part handled separate tuple basically 
structure tuple tuple header tuple index cluster attribute clusters 
variable attribute arrays 
difference size fixed part dynamic part 
start dynamic part directory existing attribute pair installed 
pair shows attribute identifier pointer fixed area 
structure shown 
dynamic attribute header treated manner tuple 
type structure useful representing unstructured information untyped information 
useful providing support storage home pages unstructured 
example table stores transcribed records genealogical record 
different genealogical records store information different ways useful records specify structure schema 
basically means schema information integrated tuple 
lorel information semistructured data 
providing possibility attribute refer dynamic attribute directory store flexible tuples 
vac vac vac vac vac vac vac general structure variable array attributes variable array attribute header variable array attribute index cluster vac variable array attribute cluster organisations tuple header dynamic attribute directory dynamic attribute header handling dynamic attributes foresee special data structures search structures foreseen time database implemented 
provide support extensibility database equipped procedural language 
language need know structure tuples interpreting language suitable task 
page structure structure pages important item designing database architecture 
description applications shown common type table table tuples tuple small consists mainly fixed size attributes 
important optimise access supporting general data structure 
tuple structure accessed pair consisting page identifier page index 
allow reorganisation pages page index direct pointer data pointer page directory gray 
allow fast access tuple header indexes page 
contains index pointers tuple structures second directory contains tuple headers 
size tuple headers depends table 
table size bytes tuple header bytes fit 
table larger tuple sizes bytes proper size tuple header 
directory shown bit page index 
page identifiers find page issue 
disk database known pages reside main memory 
flexible data structure needed find page main memory 
common hash table 
reasons disk database slower main memory database 
page access requires search hash table 
need support disk data main memory data need different solutions disk pages compared main memory pages 
disk pages uses hash structure normal 
main memory pages page identifier refers memory page 
reason want checkpoint location independent 
means node restart fragment checkpoint created node 
physical page fragments checkpoints created different nodes 
tuple header page directory tuple headers page directory tuple structures page structure need logical page identifier main memory pages 
assume pages allocated fragments discussion 
translated physical page identifier 
mapping performed data structure similar tree 
consists mapping table start intervals logical page identifiers 
base address interval specifies number start page logical page interval 
small table entries cater needs needed allocation size known 
cases complicate things 
memory fragmented 
possible allocate large chunks smaller chunks allocated 
second problem dbms know size allocated properly starts allocating small chunks 
avoid problems giving major impact data structure organised tree 
fragmented memory supported performance 
mapping table shown 
disk attributes main memory attributes database support disk data main memory data 
selection data put disk data put main memory flexible tuple structure flexible 
page disk main memory algorithms performed 
choice attribute level 
typical example needed table store files 
attribute stores file variable array bits disk descriptive attributes better suited storage main memory 
useful news demand application multimedia email application genealogy application seen chapter 
handling undo log described chapter necessary create physiological undo log logical fragment redo log execute consistent data structure 
undo log local checkpoint create action consistent checkpoint 
checkpoint include tuple structures index structures 
undo log index structures described chapter 
start base type leaf leaf leaf ptr start base type leaf leaf leaf leaf mapping logical page identifiers physical page identifiers main memory pages logical page id physical page id logical page id physical page id local checkpoint execute fragment redo log 
means committed updates local checkpoint going performed executing fragment redo log 
crash recovery data read 
necessary undo log restores attribute values local checkpoint taken 
necessary restore data structure local checkpoint taken 
means size undo log diminished 
especially interesting disk data data need undo log time 
attribute values changed transactions abort shall handled different manner 
operations undo log restore attribute values undo part fragment log 
release memory connected deleted tuple long operation 
write start checkpoint record tuples currently deallocated 
tuple storage lose memory tuples crash 
changes tuple structures various operations update create delete change data structure tuples 
change divided update phase commit phase abort phase 
updates attributes fixed size differ updates attributes variable size 
go update attribute fixed size variable size change size create tuple copy updated parts tuple change attribute values commit update attribute fixed size variable size change size delete tuple copy updated parts tuple abort update attribute fixed size variable size change size copy data tuple copy tuple original delete tuple copy updated parts tuple update attribute variable size increasing size create tuple copy updated parts tuple allocate new parts tuple update new parts tuple commit update attribute variable size increasing size delete tuple copy updated parts tuple abort update attribute variable size increasing size copy data tuple copy tuple original deallocate new parts tuple delete tuple copy updated parts tuple insert allocate parts tuple write attribute values commit insert abort insert deallocate parts tuples delete commit delete mark tuple deleted deallocate parts tuple unmark tuple memory tuple released abort delete shown necessary log updates committed attribute values undo log 
changes data structures changes data structures logged 
means create tuple copy delete tuple copy allocate new parts tuple deallocate parts tuple update new parts tuple logged undo log 
marking tuple deleted needs logged undo log 
deallocation deleted tuples logged 
attribute values aborted operations logged ensure undo log restore committed values 
means creation tuple copies log attribute values undo log 
copying tuple copies original necessary write undo log 
possible decrease size undo log 
performing action create tuple copy delete tuple copy belonging operation changed data structure 
possibilities log correct manner 
log 
applies create tuple copy copy tuple copy original tuple 
important deleting entries undo log performed correct order 
added tuple part operation removed undo log 
reasoning holds true allocate new parts tuple deallocate parts tuple aborting transaction 
means normally committed insert delete operations update operations change size variable attributes stored undo log 
allocation deallocation blocks logged undo log 
special handling large attributes method described capable handling types data dynamic manner 
optimised tuples extremely large 
problem large attributes reside disk necessary write large blocks fragment log data pages 
data written undo log 
lehman reports interesting solution problem large attributes data part located special region data pages 
pages located region handled scheme 
data pages handled shadow page scheme 
updates allowed old values 
updates placed new area 
scheme single write needed 
write disk performed transaction commits 
related gray contains thorough description common techniques store tuples disk databases 
garcia overview main memory databases shows main memory data structures heavy pointers 
common allow application access data directly main memory dali 
case distributed database database application reside processor node 
better database api disk databases 
informix describes solution similar problem logical redo undo log connection physical undo log 
describes scheme logical redo undo log connection log handles local events block splits forth 
reports redo log techniques disk databases known author 
new result thesis 
tree structures storing large tuples reported gray 
lehman choice main memory disk performed table 
sullivan reports data structure postgres 
structure old copies attributes kept storage provide queries old versions 
action consistent checkpoint assume force commit stable main memory 
log needed 
major achievement chapter development tuple structure removes need storing undo information log 
shows flexible structure tuples 
structures assumed new rarely reported database literature 
log pages shadow pages tuple header attribute cluster attribute cluster handling large attributes connection advanced data structures particular log strategy thesis step forward designing dbms 
achieves small volumes log compared strategies 
modelling parallel data server section performance analysis various ideas architecture parallel data server 
necessary order understand different features developed 
start describing computer architecture performance modelling 
analyse performance replication structure stand nodes analyse new transaction protocol 
analyse recovery performance various situations 
total crash failures nodes line recovery performed 
performance figures early estimates prototype developed ericsson ab figures descriptions sun systems sun 
figures simulation performed understand interworking various features 
computer architecture performance modelling estimates chapter execution times usage cluster ultra servers equipped ultrasparc processors mhz 
server contains gbyte disks releases ultra servers gbyte disks ultrasparc ii processors mhz sun gbyte disk said maximum data rate mbytes sec 
new disk seagate reports average sustained data rates mbytes sec maximum data rate mbytes sec www seagate com 
shown sun actual data rate dependent size buffers sent disk 
kbyte buffers kbytes sec slightly faster disk 
kbyte buffers data rate goes kbytes sec 
largest size buffers handled solaris sun 
recovery large buffers read disk files large sequential files 
types files read recovery 
data buffers fragment logs local logs 
read sequentially recovery 
assume knowledge set parameters solaris possible reach mbytes sec disk recovery 
database entirely main memory data activities performed disk writing checkpoints writes data buffers writing fragment logs writing local logs 
assume mbytes sec reached 
disk data read written continuously random pattern 
data rate disk goes 
certain applications charging server create data searches 
disk accesses sequential 
disks assume data rate mb sec available 
performance comparisons crude estimates performance data server deduce overhead stand replica deduce decreased overhead error cases 
estimates prototype developed axe research development thesis 
prototype early phase figures crude 
figures estimate cost sending message microseconds 
achievable figures sci memory channel simple message interface 
report implementation message passing sci memory channel 
current versions hardware achieve microseconds delay messages bytes size 
delay reader receive message 
sending processor node continue activities sooner 
execution time receive message message read local memory 
figures relate execution simple write transaction updates record primary node backup node stand node 
complete phase ignored discussion 
handled part background processing 
load transaction coordinator microseconds prepare phase microseconds commit phase microseconds completing commit phase sending response application 
load primary backup node microseconds prepare phase microseconds commit phase 
stand node uses microseconds prepare commit phases 
results total microseconds including execution time messages 
microseconds executed stand node 
overhead caused stand node write transactions 
read queries affected stand node 
complete phase ignored performance comparisons 
figures help estimating delay various scenarios 
scenario need consider read queries 
estimate load microseconds transaction coordinator microseconds primary node 
total microseconds communication costs added 
mixture write transactions read transactions umts benchmark 
assume simple model load processor nodes 
performed simulations figures 
simulations measure impact stand nodes delay time impact load delays new twophase commit protocol 
costs divided participating processor nodes normal write transaction transaction coordinator primary node backup node stand node application transaction coordinator primary node application server server costs simple read transaction simulation model consists set servers 
assumed communication bandwidth bottleneck 
table simulations stand node shown 
obvious figures stand node affect response time particularly negative way 
deduce new phase commit protocol gains better performance adding ms delay write transactions 
trade certainly acceptable 
table figures stand node shown 
performance gain new phase commit protocol slightly higher 
delay go ms write transactions scenario 
extra cost stand nodes 
table new pc load normal pc load normal pc load new pc mean delay read reads sec mean delay write writes sec confidence interval read delay confidence interval write delay table new pc load normal pc load normal pc load new pc mean delay read reads sec mean delay write writes sec confidence interval read delay confidence interval write delay discussion derive customer willing pay extra capacity increase reliability system avoid having problems delay requirements failure situations 
choice customer replication tables configurable interface data server 
stand replicas large configurations probability replicas failing simultaneously rises 
comparison normal phase commit protocol linear phase commit protocol shows delay normally smaller normal phase commit protocol 
performance benefit version phase commit protocol cause problems delay requirements 
benefit version phase commit protocol simplifies handling recovery 
messages arrive replicas order fewer possible states failures occur 
simplifies handling node failures 
shown chapter simplifies integration network redundancy phase commit protocol 
performance line recovery performing line recovery new backup replica created similar performing insert operation 
main difference great deal protocol overhead avoided 
assume tuple read sent primary replica microseconds 
time assumed reception tuple 
means nodes recover mbytes sec entirely working recovery bytes record 
working system possible 
assume exists pool processor nodes ready processor node fails 
role primary replica divided survivors 
processor new backup replicas devoted restarting new backup replicas 
larger tuples possible transport mbytes sec overhead tuple major part cost 
machine contains gbytes data time recovery minutes 
new backup replica involved transactions starts new backup replicas time longer 
estimate take minutes recover processor node failure 
obvious stand nodes worthwhile avoid risk system crash time 
primary replica new backup replica insert line recovery model performance crash recovery complete restart crash necessary read entire database disk apply logs 
described section restart consists phases 
phase reads pages belonging fragment disk 
data produced local checkpoint data disk copy older time local checkpoints 
step execute local undo log entry backwards time local checkpoint 
third step execute fragment log global checkpoint concluded local checkpoint produced 
major consumer resources read database fragment disk 
computer architecture described disks perform reads parallel 
umts benchmark processor nodes gbytes data restore processor node 
take little minutes mbytes sec disk bandwidth 
possibility shortening time crash recovery disks processor node 
assume primary replica created phase crash recovery 
production backup replica start soon primary replica recovered 
benefit system restarted quicker 
time perform local checkpoint time recover data involves writing data pages disk 
trying detect pages dirty 
writing large buffers disk efficient better write data disk local checkpoint 
assume local checkpoints taken minutes 
fragment log read completed global checkpoint local checkpoint 
global checkpoints taken local checkpoints achieving global checkpoint small operation involving major compared producing local checkpoint 
approximate need read fragment log local checkpoint 
umts database produced transactions sec little half updates 
assume log records consists bytes data need log mb sec total system 
means mbytes fragment log handle recovery 
divided processor nodes system 
time takes read logs disk obviously compared gbytes data pages 
applying log uses mechanisms performing line recovery 
local logs main memory data smaller fragment logs written start checkpoint writing page disk 
fragment time checkpointed time seconds means approximately mbytes local logs total system 
time apply logs assumed compared activities crash recovery 
discussions performance normal operations recovery operations seen requirements umts application met 
architecture possibilities useful applications 
research needed performance modelling system particularly disk applications 
research modelling load balancing algorithms necessity operational real time system telecom network 
iv summary summarize important related thesis summarize contributions thesis produced 
area described 
related number projects worked developing products prototypes focused databases telecom applications 
report compare approaches 
trondheim norway team database researchers worked issues long time 
developing product 
project reported tor brat tor 
author close contact team learned ideas developed extended ideas 
uses primary hot stand called backup thesis architecture 
primary hot stand involved transactions 
hot stand update data immediately 
log records shipped hot stand updated order hot stand delay 
primary reading hot stand merely reliability reasons 
hot stand takes ms tor failure primary node 
primary node fails log hot stand copied node decrease risk system failure 
nodes communicate message passing atm fddi ethernet 
cost communication high message costs ms sparc compared ms sci sparc 
software developed unix processes self developed thread package 
parallel data server developed thesis uses primary hot stand architecture 
extended stand replicas 
ensure double faults crash system 
backup replicas updated transaction immediately available take primary node failed 
possible backup replica take aborting transactions 
possible updating transactions set read locks backup replicas 
backup replicas updated transaction possible simple read transactions access backup replicas 
simple read transactions common telecom applications great benefits algorithms load balancing 
major differences underlying software architecture 
major difference communication parallel data server assumes message passing implemented shared memory nodes sci memory channel 
decreases communication costs factor especially short messages common applications 
parallel data server uses run time system concurrent programming language highly modular efficient sorts communication 
reported mean delay simple write transactions ms send application prepare phase 
simulations thesis show possible achieve ms waiting commit phase com plete sending 
adding stand node increase delay ms difficult compare simulations uncertain values real measurements 
furthermore machines measurements powerful parameters simulations 
delays simple reads architecture ms means database transactions performed part application message database cause problems due delay 
performance simple write transactions reported transactions second node cluster hp mhz workstations interconnected mb fddi network 
sci decreases delay 
figures achieved excellent 
major difference sci removes performance impact distribution completely 
clearly visible expect achieve umts transactions second node cluster ultra servers ultra sparc processors frequency mhz 
major reason expect performance figures sci cooperation distributed real time run time system described 
additional features reported thesis line schema changes 
parallel data server undo redo logging combination physiological undo scheme data structures 
distributed databases undo redo logging combination local physical log changes data structures 
prototype theoretical ibm great value development ideas dynamically creating new replicas chamb 
deals tuples accessible record identifier 
handle crash recovery line recovery 
ideas thesis extended secondary indexes foreign keys schema changes 
ideas chamb karl developed achieve copy fragment algorithm tuple time locked shipped 
chamb locks fragment ships karl ships bucket time 
fried reports prototype intelligent network applications 
optimised simple read transactions 
communication efficient ibm sp communication switch rs workstations 
top communication horus group communication technology 
horus optimised small messages group messages send message ms achieved throughput reads sec processor node processor node rs processor frequency mhz 
interesting ideas reads waited time simply retried replica 
estimated results shows simple read transactions second processor node achievable ultra server 
achieved packing messages architecture highly optimised simple reads 
discovering failed node took seconds fried ms 
assume able discover failed nodes ms achieve take time seconds excellent 
scheme performs take ms failed node discovered 
take means new transactions start new scheme 
dealing transactions waiting failed node takes somewhat longer 
take ms case 
updating transactions simply wait fail message retry described section 
simple read transactions ideas fried resends disastrous overload situation 
check overload situation exist avoid real performed overload situations 
major source inspiration king 
slightly extended method assigning transaction coordinator backup system 
major thesis show integrate king ideas local replication protocols 
extended line schema changes change schema backup system 
ideas distributed databases developed 
skeen representative ideas 
describes system support line recovery 
scheme log applied old replica residing disk 
handle reconfigurations replicas 
thesis scheme chamb updates applied recovering fragment simultaneously copy process sends tuples new backup replica 
simplifies protocol declare new replica date 
assumes communication cheap 
fragment disk large recovering node old copy idea protocol developed skeen 
internal database product ericsson major source inspiration dbs database subsystem axe switches delivered ericsson 
database specialised applications written axe switch 
uses preprocessor compiler implement efficient read queries 
reading tuple attributes dbs performed microseconds table stored module query uses pointer index normal case telecom switches 
linear hashing development distributed linear hashing pram litwin karl litwin 
contributed scalable distributed data structures 
thesis extended integrating replicated database transactions enabling dynamic moving fragments 
algorithm enables shipping tuple time developed lh 
original data structure linear hashing litwin extended double linear hashing internally processor node 
enables number cache misses normally find entry linear hashing index 
achievements thesis part achievement part serves vision telecom databases need handle 
studies impact network databases people mobile telephones email read news electronic means payment handled line electronic systems 
presents study genealogy database example application requirements massive data storage complex schema needs globally defined 
studies provide important requirements developing generation database management systems 
provide new set benchmarks developing database management systems 
part achievements part design enables division telecom database various servers 
application servers application logic resides 
management servers operation management applications telecom database handled interface service information creation environment 
database server divided servers data server query server 
reasons applications telecom databases require simple query interface complex query interface 
complex query interface management operations application queries 
query server handles complex query interface simple query interface data server 
data stored data server 
benefits making logical division physical division 
data server damaged malfunctioning applications clients means data server better control processor resources 
means data server better handle real time requirements applications put 
better control usage memory spaces cache memories essential processor resources 
implementation efficient data server easier task 
architecture development possible due development high performance communication networks sci possible communicate intrusion operating system 
communication performed distributed shared memory handled hardware processor nodes sci communication network 
architecture full responsibility reliability applications parallel data server 
server implements reliability software methods necessary hardware reliability 
normal cheap workstations pcs configured clusters achieve scalable systems high reliability 
parallel data server parallel query server parallel application server parallel management server high performance communication network telecom network communication gateway client server architecture achievement development replication algorithm stand nodes 
development enabled development main memory databases development algorithm new efficient communication technology sci 
primary backup nodes date copy database high availability database achieved 
sending log records stand nodes extremely high reliability database achieved 
stand nodes consume small processor resources small main memory resources providing extra reliability cheap price 
replication strategy combined new variant phase commit protocol combines efficiency real time properties 
shown phase commit protocol combined protocol network redundancy developed king 
index structures designed especially suitable modern risc processors developed index structures suitable web addresses file names tuple identifiers telephone numbers 
time optimised index space optimised developed 
keys dominating types keys telecom databases 
improves search time indexes 
important achievement searching indexes commonly action innermost parts data server 
accessing dictionary times access data 
lh lh data structure developed karl extended lh shown integrate parallel data server full support transaction automatic recovery handling 
lh data structure integral part recovery protocols 
new result area method performing split join fragments transactions executing system knowledge fragment distribution fully replicated 
tree new distributed tree results compressed size indexes large keys addresses file names forth 
uses ordering tree repeatable directory structures addresses file names compress keys large factor 
provides better main memory provide efficient search algorithms 
efficiency better smaller working set compression smaller comparison key delta change needed check key 
lh structure appropriate performance index important 
tree useful large indexes 
indexes fit main memory lh 
tree fit main memory performance better disk accesses avoided 
final result thesis new data structure pages storing tuple information 
data structure provides possibility undo redo logging totally flexible scheme writing pages disk 
important result research 
thesis focused developing basic data access functions reliable system 
performed showing perform changes interrupting system operation 
basic data structures needed applications developed 
openings 
test algorithms developed thesis real implementation 
provides opening testing benchmarks developed thesis 
direction started described 
needed load balancing system 
involves simulation studies analytical models study behaviour database 
simulations done low level software database 
find real bottlenecks lead cache misses processing 
needed extend ideas active databases 
active components maintained sacrificing reliability 
examples area ceri strip 
extension support unstructured data lorel 
data structures developed buffer manager extended support unstructured data 
abbreviations aal atm adaption layer acid atomic consistent isolation durable amps american mobile phone system atm asynchronous transfer mode axe switch developed ericsson blob binary large object bss base station system ccitt global standardisation organisation clr compensating log record amps digital amps organisation multimedia services dbs database subsystem part axe dbms database management system european system cordless terminals fddi fiber distributed data interface lan wan network ethernet lan network gif format storing pictures files gsm groupe special mobile european mobile telephone system hlr home location register 
node mobile telephone network contains subscriber data 
hyper text transfer protocol hytime extension sgml real time multimedia documents intelligent network intelligent network application part runs top input output ip internet protocol itu new name ccitt jpeg compression standard pictures lan local area network le local exchange lh linear hashing lh distributed variant linear hashing lh lh variant lh linear hashing locally 
lh variant lh lh developed thesis 
lsn log sequence number map mobile application part runs top memory channel cluster interconnect developed digital monet research project umts race mpeg compression standard video mtp link layer part network layer stack mtbf mean time failure mttf mean time failure mttr mean time repair nordic mobile telephone system neighbour wal oo object database benchmark pcs american system mobile telecommunication japanese mobile telephone system pdh digital hierarchy phs japanese system cordless terminals standard protocol communication management services telecom applications race european research projects telecommunications raid redundant disk arrays ram random access memory risc reduced instruction set assembler read write available part network layer stack sci scalable coherent interface cluster interconnect standard uses shared memory model scp service control point 
physical node intelligent network 
sdh synchronous digital hierarchy sdp service data point 
physical node intelligent network 
sgml standard graphic markup language smtp email protocol sql standard query language databases tacs british mobile telephone systems transaction protocol top stack tcp ip safe transport protocol top ip te transit exchange tiff format storing documents pictures files tpc database benchmark tpc database benchmark udp unsafe transport protocol top ip umts universal mobile telephone systems 
third generation mobile telephone system developed europe 
wal write ahead log wan wide area network www world wide web network protocol osi open systems interconnect glossary telecom database database telecom applications system thesis system defined cluster processor nodes acts parallel data server 
systems cooperate provide network redundancy primary system backup system 
processor node node acts node cluster 
normally multi processor machine workstation application system uses database set communication services provide service endusers systems 
anderson culler patterson case networks workstations ieee micro feb 
aries mohan lindsay pirahesh schwarz aries transaction recovery method supporting fine granularity locking partial rollbacks write ahead logging acm transactions database systems vol 
march 
atta design access manager network database master thesis university stockholm completed 
bayer bayer prefix trees acm trans 
database systems vol 
bern bernstein lewis concurrency programming database systems jones bartlett publishers isbn 
partially informed distributed databases conceptual framework knowledge model tech rep monash university australia dec 
bhg bernstein hadzilacos goodman concurrency control recovery database systems addison wesley isbn 
brat 
location replication independent recovery highly available database submitted vldb 
dbc industrial supercomputer database machines parallel architecture languages europe paris 
ceri widom ceri editors triggers rules advanced database processing morgan kaufmann isbn 
chamb chamberlin schmuck dynamic data distribution shared multiprocessor data store vldb 
schema evolution integration distributed parallel databases vol jan issn 

telecom database high availability high throughput real time response 
proc 
st vldb large data bases zurich switzerland sep 
comer comer tree acm computing surveys june 
performance characterisation alpha microprocessor tp spec workloads second int symposium high performance computer architecture hpca feb san jose california ieee 
dewitt de witt ghandeharizadeh schneider rasmussen gamma database machine project ieee trans 
knowledge data eng 
vol march 
dali jagadish rastogi silberschatz sudarshan dali high performance main memory storage manager proc th vldb conf 
santiago chile aug 
dali bohannon rastogi seshadri silberschatz sudarshan architecture dali main memory storage manager memoranda lucent technologies www bell labs com project dali papers html 
dayal dayal hsu ladin organizing long running activities triggers transactions acm 
dbn internal design documents ericsson describing distributed main memory database 
dbs internal design documents ericsson describing database implemented axe switch developed ericsson 
dewitt de witt gray parallel database systems high performance database systems comm 
acm june 
dolphin sci interconnect white feb 
eng booth crow nation parallel sci links ieee micro vol 
feb 
felt felten alpert clark iftode li early experience message passing shrimp multicomputer rd ann 
int symp 
computer architecture 
meyer zicari schema database evolution object database system vldb zurich 
flanagan nelson thompson transaction processing workloads comparison spec benchmarks memory hierarchy performance studies proc 
fourth int workshop modelling analysis simulation computer telecommunication systems mascots 
fried friedman birman group communication technology implement reliable scalable distributed coprocessor submitted tina conference 
garcia garcia molina salem sagas acm 
garcia garcia molina salem main memory database systems overview ieee transactions knowledge data engineering vol 
dec 
gill memory channel network pci ieee micro vol 
feb 
gold goldman ultrasparc ii advancement digest papers compcon spring feb 
lehman locking latching memory resident database system vldb aug 
gray gray notes data base operating systems operating systems advanced course bayer graham eds springer verlag 
gray gray mcjones lindsay lorie price traiger recovery manager system database manager acm computing surveys june 
gray gray benchmark handbook database transaction processing systems morgan kaufmann isbn 
gray gray reuter transaction processing concepts techniques morgan kaufmann 
gs gray siewiorek high availability computer systems ieee computer vol 
page sep 
helal helal bhargava replication techniques distributed systems kluwer isbn 
herlihy herlihy moss transactional memory architectural support data structures crl dec cambridge research lab dec 
tuple oriented recovery method available distributed dbms shared computer ph thesis nth trondheim isbn 

hardware architecture available shared parallel dbms atm technology sintef stf oct 

software architecture available shared parallel dbms atm technology sintef stf oct 
recovery parallel database systems vieweg isbn 
ibm iyer survey online reorganization ibm products research bulletin technical committee data engineering jun vol available internet 
informix informix online dynamic server database server informix software dec 
ingres ask replicator user guide 
product documentation rep ask group dec 
jagadish mumick silberschatz view maintenance issues chronicle data model pods 
karl karlsson litwin risch lh lh scalable high performance data structure switched multicomputers th int conf extending database technology edbt 
kim kim 
chou versions schema object oriented databases vldb los angeles 
king king garcia molina management remote backup copy disaster recovery acm trans 
database systems vol 
jun 
lars larsson design tuple manager master thesis royal technical institute kth stockholm 
larson larson dynamic hash tables communications acm april 
switching systems generic requirements bellcore technical tr issue march sec 
table traffic capacity environment 
lehman lehman shekita cabrera evaluation starburst memory resident storage component ieee transactions knowledge data engineering vol 
dec 
lehman lehman lindsay starburst long field manager vldb amsterdam 
lerner lerner habermann schema evolution database reorganization proc 
acm oopsla ecoop ottawa canada oct 
lerner lerner type evolution support complex type changes technical report um cs university massachusetts amherst oct 
litwin litwin linear hashing new tool file tables addressing reprinted vldb readings database systems nd ed stonebraker ed morgan kaufmann 
litwin litwin neimat schneider lh linear hashing distributed files acm sigmod int conf 
management data 
litwin litwin neimat high availability lh schemes mirroring 
lorel abiteboul quass mchugh widom wiener lorel query language semistructured data technical report department computer science stanford university 
malik malik efficient reliable dynamic data distribution erd method master thesis university uppsala 
mark markatos high performance networking parallel processing workstation clusters sec 
int symp 
high performance computer architecture feb ieee 
larsson network aspects umts master thesis ericsson telecom ab 
mmdb ieee transactions knowledge data engineering vol dec 
special issue main memory databases 
mohan mohan efficient commit protocols tree processes model distributed transactions proc 
nd acm symp 
principles distributed computing 
mohan mohan supporting large tables proc 
th brazilian symp 
database systems porto may 
mohan mohan algorithms creating indexes large tables updates acm sigmod 
monet ote mf ds umts charging accounting algorithms race monet deliverable dec 
monet ptt nl mf ds implementation aspects umts database race monet deliverable may 
monet era ne ds evaluation network architectures umts procedures race monet deliverable dec 
monet ptt nl mf ds baseline document functional models race monet ii deliverable dec 
monet sel una ds distributed database umts integration race monet ii deliverable dec 
monet sel una ds performance evaluation distributed processing umts race monet ii deliverable dec 
nils nilsson ulf kl system changing software computer operation usa patent filed jul 
performance analysis ultrasparc multiprocessors connected sci internet 
pax paxson growth trends wide area tcp connections lawrence berkeley laboratory 
pax paxson empirically derived analytic models wide area tcp connections extended report lawrence berkeley laboratory 
theory database concurrency control computer science press isbn 
pet peters zsu axiomatization dynamic schema evolution th int conf data engineering mar 
pettersson pettersson main memory linear hashing enhancements larson algorithm university link ping sweden march 
poly garcia molina evaluation remote backup algorithms transaction processing systems acm transactions database systems sep vol 
signal explosion due mobility aug 
portable distributed real time run time system internal ericsson document 
ndb cluster parallel data server telecommunications applications ericsson review remote recovery data facility operations guide version release 
technical report net nov 
rsr ims esa administration guide system version edition 
technical report sc ibm apr 
salzberg salzberg principles transaction line reorganization vldb vancouver 
skeen skeen stonebraker formal model crash recovery distributed system ieee trans 
software engineering may 
skeen skeen chan reliability subsystem distributed database manager technical report cca computer america 
stonebraker stonebraker operating system support database management communications acm vol 
strip garcia molina widom strip rule system efficiently maintaining derived data technical report department computer science stanford university 
sullivan sullivan system support software fault tolerance highly available database management systems ph thesis 
sun sun performance tuning sun microsystems isbn 
sybase replication server technical publications sybase mar 
sybase chung sybase system online capabilities bulletin technical committee data engineering jun vol available internet 
tandem rdf overview 
tandem systems review oct 
tandem nonstop sql mp availability database configuration operations bulletin technical committee data engineering jun vol available internet 
tor 
multi site declustering strategies high database service availability ph thesis university trondheim isbn 
tor 
overview dbms report telenor trondheim 
tremblay connor ultrasparc issue processor supporting multimedia ieee micro vol apr 
cache architectures pressure match cpu performance computer design march 
valduriez valduriez parallel database systems open problems new issues distributed parallel databases vol april kluwer 
zsu szafron el logical design multimedia database news demand application tr university alberta dec 
object oriented multimedia database system news demand application technical report tr university alberta june 
zsu zsu valduriez principles distributed database systems prentice hall isbn 
