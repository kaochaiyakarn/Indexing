functional programming july cambridge university press comparing id haskell monte carlo photon transport code je rey cs colostate edu lanl gov colorado state university olaf oml lanl gov los alamos national laboratory wim bohm bohm cs colostate edu colorado state university functional id haskell versions large monte carlo radiation transport code compare languages respect expressiveness 
monte carlo transport simulation exercises abilities parsing input output recursive data structures traditional number test problem languages compilers 
code examples compare programming styles encouraged languages 
particular discuss ect laziness programming style 
point resource management problems currently prevent running realistically large problem sizes functional versions code 
capsule review monte carlo technique long history 
importance grown tandem availability computing power 
authors outline functionality large monte carlo simulation program demonstrate simpli ed kernel version cleanly coded functional style 
illustrate ects functional language implementation programming style 
characteristic monte carlo method code validation debugging depend high statistics results 
authors describe problems encountered obtaining results functional codes 
experiences highlight need research address speci implementation problems 
chief needs ective debugging tools inspecting partial results cient unobtrusive methods memory management 
reports kind provide important empirical data practice functional programming help guide application development language support research 
supported part nsf mip cda arpa contract po motorola monsoon donation arpa bohm presents functional language community large monte carlo radiation transport code language comparison benchmarking 
compare functional languages id nikhil haskell hudak respect expressiveness write complex scienti code point de ciencies currently prevent program executing realistically large problems 
describe purely functional id haskell versions photon transport simulation code mcnp fortran code los alamos national laboratory lanl 
id code discussed uses explicit structures 
side ecting required input output 
monte carlo photon transport simulation test problem languages compilers 
exercises abilities parsing input output recursive data structures traditional number 
contains high task parallelism monte carlo nature execution irregular highly dependent user problem speci cation 
codes useful benchmarks compilers run time systems machines reveal capabilities de ciencies programming language implementation 
mcp id code developed mit id world version includes compiler simulator called mint ability execute compiled code motorola mit monsoon data ow machine hicks stages development done node monsoon lanl 
mcp haskell code developed chalmers haskell compiler version run sun sparc machines 
id haskell codes structured similarly 
main di erences lie way input output handled 
programming styles di er primarily id encourages loops arrays ciency resource management reasons haskell programs tend higher order function composition lists 
resource management problems severely limit problem size haskell id versions code run 
rest organized follows 
section describe monte carlo photon transport simulation problem 
section program structure introduced 
section haskell id programming styles discussed 
section haskell id codes compared example code fragments 
section deals resource management issues 
section conclude discuss 
description problem name mcnp refers original fortran code developed los alamos simulates transport photons electrons 
mcnp general code allows myriad parameter settings applications sites worldwide 
name mcp functional refers photon transport codes monte carlo photon transport mcnp written pure functional way called mcp id functional id code mcp haskell haskell version 
overview monte carlo photon transport monte carlo radiation transport problem involves simulating statistical behavior certain particles travel objects speci ed shapes consisting certain materials 
model problems areas reactors radiation shielding medical physics 
mcp functional deals photon radiation 
simulating behavior particles collisions nuclei material particles travel called tracking 
nucleus kernel speci atom certain element 
tracking takes place statistical information certain events gathered histograms process called tallying 
user monte carlo transport code describes problem geometry radiation source information needs tallied 
program simulates individual source photons collide nuclei materials problem geometry photon contributes information tallies collected 
accuracy tally results proportional square root number source particles simulated 
shows example photon track 
intermediate event collision surface crossing 
exact nature events described sections 
photon splitting occur source photon track forms irregular tree 
track lengths degree splitting highly dependent user problem speci cation 
photon tracking essence photon simulation tracking photon series movements collisions nuclei 
collision potential absorbing photon energy changing photon direction travel 
possible photon split multiple photons separately tracked 
splitting physical see section statistical see section 
eventually photon track ends due reasons energy weight falls speci ed threshold photon reaches region little interest regard tallies collected photon absorbed 
collisions kinds collision possible photon interacts nucleus 
compton incoherent scatter new angle energy result 
thomson coherent scatter new angle unchanged energy result 
pair production photon absorbed new photons produced mev energy opposite directions bohm source energy cutoff scatter scatter scatter scatter user specified plane energy cutoff scatter scatter pair surface crossing importance splitting fig 

example source photon track 
ect zero new photons may produced photo possible specify di erent physics treatments simple detailed handle collisions 
simple model ignores coherent scattering photo uses computationally faster approximations computing new energy scatter angle incoherent scatter 
simple treatment useful high energy photons accurate low energies heavy 
user specify understanding problem simulated threshold energy simulation switch detailed physics routines 
empirically derived cross sections collected re ned years 
determining accurate cross section data ongoing activity 
main limitation mcnp ability model problems correctly lack known cross sections 
cross sections monte carlo photon transport stored table indexed energy values units called collision types 
arbitrary photon energy cross sections interpolated 
sum cross section values energy density material allow mean free path length calculated average distance collision 
value random number select actual distance collision 
ratios cross section values indicate relative likelihoods kinds collision allowing random selection collision type 
case collision composite material random selection determine material involved collision 
addition cross section tables tables data relate interpolations scatter collisions selecting new energy angle de ection 
small tables relate probabilities photo heavier 
cross section data large mcp functional expects read cross section le contains data problem run 
user describes geometric cells problem speci ed shape material composition 
step photon track move cell boundary collision location 
select photon move distances computed distance cell boundary photon current direction travel distance collision cell material composition photon energy 
smaller selects takes place 
collision photon moved trajectory collision distance new energy direction computed 
photon simply moved cell boundary 
variance reduction get better accuracy compute time variance reduction 
cells assigned importance values user devise somewhat ad hoc way 
time photon crosses cell things happens cell importances equal photon simply crosses new cell 
new importance higher photon splits multiple photons 
energy location direction travel seeded di erent random number weight old photon equally new ones 
new importance lower russian roulette takes place random choice weighted cell importance ratio decide photon continue tracked die 
survives weight increased proportionate cell importance ratio 
crossing zero importance cell simply means probability death russian roulette photon track ends crosses zero importance cell 
bohm important understand photon weight statistical physical 
weight tells fraction source photon represents 
source photons weight 
photon contributions tallies scaled weight 
intuitively importance splitting occurs photon weight split daughter photons maintains conservation photons 
typically auser represent object multiple cells cell assign importances cells way keep reasonable number photons alive travel away source 
idea source photon push photon photons reduced weights tallied surfaces tallied cells 
number cells spacing importances chosen degree photon splitting approximately compensates photons die due absorption energy cuto migrate tally locations 
exact techniques choosing importances cell speci cations learned experience 
user experiment problem speci cation doing small runs noting rate statistical convergence tallies 
user satis ed behavior simulation full run performed 
general cell partitioning importances ect speed convergence answer 
possible speci cations result simulations 
documentation lanl mcnp describes selection importances art 
possible user set geometry cell may non zero importance 
photon enters cell surface trajectory simply travels forever 
code detects aborts error message 
errors avoided simply surrounding problem geometry cell zero importance 
user speci cation problem describe user sets describes problem simulated 
aided example followed rest 
geometry dimensional geometry built number cells certain material shape 
running example geometry consists sheet carbon steel aluminum half sphere shell top gamma radiation source just center 
dimensional slice shown shows mcp haskell speci cation le comments explaining information le 
haskell style comments ignored lex function standard prelude parsing input 
mcp functional cell associated information 
region describing space cell occupies 
material composition 
material density monte carlo photon transport cell cell sfc sfc sfc sfc fig 

vertical slice example geometry 

statistical importance see section sfc sfc sfc sfc sfc regions de ned surfaces planes spheres cylinders 
surface de nes primitive regions positive negative half spaces de ned plane inside outside regions cylinder sphere 
complex regions de ned intersection union complement operators 
de ning regions cells user responsibility ensure point dimensional space cell 
run time error photon reach location isnotin ofthe de ned cells 
impossible photon reach point point cell 
users specify zero importance cell region contains points covered cells 
describe material composition cells separate array de ned referenced cells 
material consists list fraction pairs range hydrogen 
user ensure fractions material add 
atom density cell material expressed atoms cm statistical importance oat value described section variance reduction 
running example sheet carbon steel de ned boundary planes bohm number photons simple detailed threshold energy cutoff weight cutoff source location iso isotropic source source cell source energy histogram mev mev mev mev surface definitions pz sfc plane pz sfc plane pz sfc plane pz sfc plane sfc sphere origin dia sfc sphere origin dia sfc sphere origin dia sfc sphere origin dia pz sfc plane cells geometry mat importance density cell cell cell cell cell cell cell cell cell materials iron carbon aluminum list carbon iron aluminum cross sections file bench tallies collisions flux random seed fig 

example input le monte carlo photon transport parallel plane consists multiple cells di erent statistical importances 
cell de ned intersection region surface region surface importance 
aluminum half sphere de ned anumber cells sphere plane surfaces 
example cell intersection region outside surface smallest sphere region inside surface smallest sphere region surface plane 
importances cells grow source compensate photons absorbed closer cells 
photon source distribution photon source described properties 
location 
direction unidirectional isotropic 
energy distribution form cumulative histogram isotropic source emits photons evenly directions 
example isotropic gamma high energy photon source just center sphere 
energy histogram produces half source photons mev half mev energy 
tallies user speci es list desired tallies describe histograms gathered simulation output program execution 
tally types inherently related surface crossings related collisions interior cells 
useful partition tally energy bands bins 
tally consists information 
kind tally current ux collision count 
list locations surfaces cells depending kind tally 
list energy bin partition values time photon passes tallied surface collides nucleus tallied cell contributes information appropriate tally 
nature information depends kind tally performed 
example current tally simply counts number photons crossing surface tally incremented photon weight 
tally speci ed bin appropriate bin chosen incremented photon energy chooses rst bin partition value photon energy 
error photon energy exceeds largest bin user largest bin value equal largest possible source energy 
example shows tallies performed 
rst collision count photon weight cells 
inclusive bin tally set equal largest photon energy bohm occur 
second tally measures ux takes account photon weight crossing angle surface 
partitioned energy bins 
information remaining pieces input information 
simple detailed threshold described section 
energy threshold photon longer tracked 
weight threshold photon longer tracked 
starting random seed 
name le containing cross section information simulation output output mcp functional reports average source photon energy various kinds photon creates losses values error estimates user tallies 
creates losses give user insight kinds tracks place demonstrate photons accounted number creates equals number losses 
shows output running example source photons 
expected average source energy exactly mev half photons half mev 
photon creates losses equal 
inequality indicate program bug 
rst tally gives number collisions source photon non vacuum cells cells 
second tally gives photon ux outside aluminum shell surface subdivided energy bins 
tally line rst number value second number error estimate 
tallies normalized source photon 
comparison mcp functional mcnp capabilities mcp functional implements subset mcnp photon part 
di erences programs noted 
lanl mcnp impressive code person years ort devoted 
simulates transport photons electrons 
primitive surfaces include cones addition mcp functional 
great deal user exibility including photon tally types kinds variance reduction 
tally bins speci ed variety parameters just energy 
photon sources probability distributions energy position direction energy function angle flux tallied point ring detectors surfaces 
tally bin gets pass pass tests applied determine simulation behaved 
hundreds pages mcnp users manual attest capabilities 
monte carlo photon transport average energy photon creation source cell importance annihilation second photon loss escape energy cutoff weight cutoff cell importance capture pair tally tally bin bin bin fig 

example output le creating mcp functional taken prohibitive amount implement mcnp photon capabilities 
tried choose representatives things mcnp code structure behavior faithfully re ect job performed 
mcnp user tends handle problem steps 
construct problem specifying geometry source tallies specify variance reduction techniques parameters including subdividing cells assigning importances 

small run yielding information convergence general behavior simulation 

information modify problem speci cation especially variance reduction parameters 
bohm 
iterating previous steps obtaining satisfactory behavior execute long runs 
runs may involve millions source particles 
mcp functional feedback user middle steps process probably inadequate real world 
mcnp produces large amount information helps give user picture happening simulation 
example cell importances manipulated user keep reasonable population photons alive migrate tally locations user interested number photons entering leaving cell crossing surface 
information change importances appropriately 
mcp functional program structure correctness top level code consists input parsing simulation output formatting 
simulation part divided tracking tallying producer consumer relationship event list serves interface 
event list provides clean separation tracking tallying tasks means new kinds tallies added touching tracking code way 
photon tracked collision surface crossing appends event photon event list 
event contains useful information photon time energy weight location direction angle crossing event list traversed tallying code extract required information output 
section mcp haskell code fragments shown mcp id counterparts nearly identical syntax di erences 
shows function mcp generates source photons tracks tallies results produces output string gure ow diagram code 
list random seeds generated sample source function mapped list yielding list source photons seeds 
list determine average source energy track function mapped yielding list event lists 
user tally functions applied event lists yielding list tallies source photon 
list lists transposed accumulations performed 
list event lists total various photon creates losses 
tracking tracking code parts physics geometry 
physics part tracking code bears strong resemblance corresponding fortran code mcnp spaghetti 
fortran functions exact counterparts mcp functional 
routines include interpolations cross sections sampling statistical distributions techniques direct methods rejection sampling 
chapter carter contains full discussion statistical sampling 
monte carlo photon transport mcp user spec info spec info tally entry seed int string mcp user info info tallies seed recip particle list particle seed particle list map sample source take iterate seed avg foldl map particle list recip event lists event event lists map particle list particle sd create source track user info particle sd tally list array int int double tally list transpose map event lists evs map tally source evs tallies array int int double map accum tally tally list squares array int int double squares map accum tally squares tally list totals int totals tally bal event lists nal tallies zip tallies squares repeat recip 
shows results avg totals nal tallies fig 

top level haskell code bohm iterate random generator map sample source seed seed list particle list map get energy map track fold energy list energy sum avg transpose map event lists evs map tally source evs tallies event lists fig 

data ow view mcp tally list tally bal map accum tally map accum tally squares squares geometry part mcp functional developed independently original fortran code mcnp easier start scratch powerful data structuring facilities functional languages 
recursive data structures express direct way region expressions speci ed user 
region de ned haskell code follows data region prim int base case primitive region absolute value int speci es surface sign indicates side surface compl region complement region intersects region intersection regions unions region union regions geometry part responsibilities 
rst determine distance cell boundary photon location direction 
done calculating distance surfaces form leaves cell region structure eliminating cutting cell forming part boundary half line de ning trajectory photon selecting minimum 
calculating distance surface direction photon taken account surfaces crossed photon parallel trajectory nite distance 
totals monte carlo photon transport second responsibility ofthe geometry part code determine surface crossed cell entered 
involves testing cell new location lies cell boundaries 
search lists surface precomputed start program devised cells head list tested rst 
track function uses physics geometry routines track photon 
begins determining energy weight cuto terminates photon track 
termination occur determines event collision move cell boundary described section 
functions called simple physics detailed physics surface 
functions capable terminating photon track absorption russian roulette continuing track producing multiple photons pair production photo importance splitting tracked 
track function functions mutually recursive 
call track handles collision move cell boundary appends event accumulating event list 
photon survives collision cell crossing track function called photon updated information continue tracking 
cases splitting occurs track called split photons returned event lists concatenated 
avoid ine ciency actual list concatenation accumulating event list parameter 
tallying tally code takes event lists produced track function extracts tally reduces tally information averages standard deviations error estimates 
user input speci cation le read list tallies created tally speci cation held data structure de ned follows data tally entry tally tally function speci es current ux int list surfaces cells tally array int int table mapping sfc cell nums array index int number surfaces cells tallied array int double energy bins accumulation event list user tally performed function takes event list tally returns tally array tally source event tally entry array int int double tally source evs tally ref bins accumarray ss bin idx vj bin idx map evs bohm ss bounds bins event int int double gev idx bin val val ev ref idx bin num bin num length takewhile nv bin val elems bins bin num ss error bin value bin num inrange bounds ref idx jj bin num val shows intermediate data structures represented 
rst particle list list source photons seeds 
second event lists result mapping track function particle list 
third fourth list tally arrays transposition 
transposition done prepare horizontal accumulations performed produce squares tally results 
addition user tallies program reports tally photon creates losses called totals accumulating histogram indexed various kinds births deaths 
assessing correctness possible approaches checking correctness monte carlo simulation code 
rst devise simple tests analytical solution known 
simulator result matches analytical solution error estimate simulator considered correct particular test case 
second approach tests code faithfully re ects underlying theory tests theory simulating real world problems comparing results measured physical experiments 
photon seed monte carlo photon transport photon seed event event event event event photon seed source photon list called particle list event event event photon seed event event list event lists called event lists list tally array lists transposed accumulating called tally list fig 

main data structures mcp 
event event event bohm monte carlo outputs testing debugging monte carlo codes di cult due statistical nature outputs 
source di culty comes fact codes produce just values values error estimates 
consider example development simple monte carlo code output single scalar value 
code written various low level components glued form program 
low level routines individually tested completely practical 
program tested running problem known result analytical solution empirical real world measurements 
program run value error estimate produced 
known correct value outside error range probability problem simulation 
problem programming error error simulation model 
correct value lies error range concluded simulation working correctly 
words error range contains correct value necessary su cient condition correctness 
shows happen 
point represents output value run vertical bar represents error range value plus minus error estimate 
known correct result shown 
scenarios error range produced run size impossible size run know simulation working correctly 
run size cuts error range half 
larger runs performed rst scenario shows convergence correct known value value error bars 
second scenario problem apparent run size error bar range contain correct value 
determination correctness problem come doing large runs su ciently small error bars reveal convergence 
note convergence values necessarily monotonic error bar range preceding error bar 
correct value correct value run size run size wrong 
correct simulations incorrect simulations fig 

hypothetical monte carlo photon transport low level routine statistical nature problem exists testing program testing individual routine early stages program development 
bug known exist nding source di cult manifestation statistical 
dumping traces simulation little individual steps simulation look feasible aggregate steps known wrong 
determining correctness mcp functional important activity radiation transport group maintains mcnp code lanl involves validation mcnp analytically solvable problems empirical measurements 
mcp functional validation considerably easier assume mcnp correct simply seek duplicate results 
comparing exactly identical outputs turns impractical require random number streams identical value stream decision point executions 
fortran functional codes random stream sequence unsigned integers generate sequence converted oat range zero decision point 
mcnp designers gone trouble bit seeds bit intermediate results multiplies maintaining machine portability hendricks 
bit seeds functional versions awkward integers bits 
mcnp random stream duplicated challenging con ning force mcp functional stream order mcnp 
mcp functional uses bit integers stream bit intermediate results multiplies 
mcnp mcp functional generate random streams di erent ways comparison results statistical mcnp gives error estimates comparisons mcnp error bars mcp functional error bars 
shows hypothetical comparison outputs monte carlo programs various run sizes 
consider programs agreement error bars show amount overlap 
note amount change di erent run sizes variations random streams uses 
resource management problems mcp id mcp haskell able run problem sizes allow meaningful comparisons outputs mcnp see section necessary rst develop code resource usage adequately constrained allowing detection bugs development validation nal program 
id allows explicit synchronization memory releases id code preceded haskell code development impure version mcp id created imposed limit number photons run allowing meaningful statistical comparisons outputs 
impure code various problems simulated bohm run size fig 

hypothetical comparison monte carlo programs statistically comparable results mcnp 
problems include photon benchmarks analytical solutions produced lanl group validate mcnp 
running example run modi ed mcp id mcnp 
shows graphical form outputs programs source photons 
horizontal bar width indicates range energy bin coordinate tally value vertical bar shows error range 
note sizes error ranges agree error ranges tallies overlap 
extremely close agreement middle energy bin coincidence smaller runs show overlap band 
programming style fortran mcnp code quite large consisting lines code including comments counting replicated common blocks just 
coded compact possible local variable names characters long 
re ects coding style clearly counter modern computer science programming philosophies 
cases bottom level physics subroutines isolated understood hopeless fortran code signi cant way writing mcp functional side ecting di erences code structure 
development approach attempt fortran code point departure started fresh structured view problem 
strong parsing capabilities coupled recursive data structures allow geometry code expressed straightforward way 
event list mcp functional serves interface tracking tallying parts program mcnp geometry collision parts code call routines side ect tally arrays 
important di erences fortran functional codes occurs handling random numbers 
functions pure func flux area monte carlo photon transport running example particles fig 

comparison mcnp mcp id output id fortran energy mev tional program state random seeds propagate code function parameters 
split points seed able fork seed able generate seeds correlations 
easiest solution forking mcnp code 
linear stream seeds stream characteristic possible constant time leap forward sequence desired number steps 
source photon xed segment stream track ofa photon splits split photons seeded di erent sub segments photon segment 
strided approach random number generation ideal 
possible long photon tracks cross photons segments making theoretically possible correlations occur 
possible entire random stream loop large number source photons run 
experiments performed show ect answers usually negligible probably due fact part random stream reused value decision point completely di erent hendricks 
noted section debugging monte carlo codes requires reasonably large bohm problems run 
development process seriously altered developing pure functional code rst making necessary adjustments allow run large problems hardware resource limits impure version developed development process 
version fully debugged pure id haskell codes derived 
id impure version development sequence 
impure id 
pure id mcp id 
pure haskell mcp haskell correct impure id code hand pure versions came easily codes deterministic expected produce identical results 
id non functional part useful note relevant aspects id non functional language features 
language built pure higher order functional core augmented side ecting capabilities 
semantics parallel exact execution order concurrent operations vary run time 
programmer able exercise control execution order loop bounds barriers 
loop bound speci es concurrent iterations allowed take place 
barriers create synchronization points code block concurrent operations preceding barrier guaranteed complete operations barrier start 
note barrier syntax dashes haskell programmers confuse haskell comment syntax 
id allows expression explicit reads writes kinds data access behavior structures structures 
kinds synchronized word word basis readers reader attempts read empty memory location block writer lls 
structure memory imposes single assignment restriction second write location cause run time error 
memory cell emptied read making possible writer ll cell new data making possible programs structures produce non deterministic results 
heap memory implicitly allocated id data structure created monsoon run time system garbage collection 
explicit releases required source code return structure heap 
release placed block concurrent operations statements guaranteed take place operations block completed 
programmer responsibility place release way occur structure complete 
function call execution id program monsoon requires frame memory 
remains allocated lifetime function call released function returns value side ecting statements monte carlo photon transport function completed 
monsoon limited frame memory tolerate deep recursion id library functions written loop recursive form 
example known map function loops source list creating return list 
return list built head tail iterative form uses side ecting iteration creates cons cell unwritten structure tail pointer succeeding iteration writes tail 
common practice functional programmers accumulating parameter avoid list concatenation bird wadler :10.1.1.100.9674
technique recursion replaced iteration 
iteration necessary id programs execute monsoon resource limits id library de nes open lists allow list concatenation take place constant time 
similar map implementation open list maintains tail tail pointer unwritten structure 
list represented pair pointers head tail cell 
concatenation lists done writing tail rst list pointer head second list 
special close operation writes null pointer tail open list turning normal list 
side ecting open lists care 
speci cally great care taken open list shared concatenate close operations ect list 
comparing id haskell id haskell strong similarities functional functional subset currying higher order functions 
creating mcp id mcp haskell attempted languages features re ect way experienced programmers write languages 
discuss style di erences languages reasons di erences 
coding styles uenced language characteristics purposes codes limitations machines execute 
id programmers tend try balance exploitation parallelism cient space usage haskell programmers removed machine issues rely compiler ective mapping program target machine 
id language closely associated monsoon data ow machine machine characteristics especially resource limitations uence way id codes written 
id requirement explicit heap memory releases ect coding style number ways id function composition style discouraged intermediate data structures glue functions released 
releasing heap structure id requires structure named expression composes functions broken function application bound name 
composing functions id programmers tend write style fusing functions function loop eliminating intermediate structures entirely 
bohm contrast combination higher order functions partial applications laziness extensive library functions haskell encourage compositional style programming 
laziness compositional pipeline insures necessary parts intermediate data structures created automatic garbage collection possibly deforestation optimization compiler eliminate intermediate data structures compile time haskell programmers concerned costs style 
insulated target machine details sequential semantics means need concern control parallelism 
id language views functions curried mit compiler optimizes situations function application arguments 
creating closures consume heap memory uses special cient call mechanism uses heap 
id programmers tend avoid partial applications require explicit releasing closures heap memory reclaimed 
haskell programmers directly control reclamation heap memory fact know implementation details compiler run time system costs partial applications appear may di erent costs functions 
id arrays preferred lists array scalars released operation releasing list requires traversing list releasing cons cells 
cumulative ect concerns experienced id programmers avoid recursion higher order functions partial applications function composition language allows ciency resource issues encourage imperative looking relatively side ect free style abundant loops 
mcp id code shows evidence uences 
pronounced simulation part program vast majority execution time spent 
liberal higher order composed functions occurs code reads input sets simulation ciency ects negligible 
code uenced fact pure functional mcp id version came pure version mcp haskell developed pure id version written debugged 
comparison codes mcp haskell mcp id codes large structured identically di erences tend local 
discussion highlights major contrasts codes 
monte carlo photon transport input output languages di er signi cantly handling input output 
code routines written way extended capabilities language 
id library le stdio id comes id world software holds large number functions imperative way 
le opened reading writing stream pointer returned argument input output functions exist various data types 
functions side ect directly le explicit sequencing seq construct explicit barriers enforced programmer avoid interleaving accesses 
higher order functions allow building functions complex data structures 
example format list function de ned library takes rst argument format function appropriate kind element list 
writing input output routines mcp id consisted extending scan format functions routines recognize various structure types de ned program routines parameters existing scan format functions 
example new function called scan cell created reading array cells typeof scan cell io stream cell def def scan cell reg scan region mtl scan int scan oat density scan oat reg atten reg mtl cells scan array scan cell de nition scan cell barriers force sequential access le read 
obtaining necessary values appropriate scan functions 
scan cell argument higher order function scan array read array cells 
haskell di erent entire le handled string 
standard prelude provides various functions extracting information strings bohm building haskell overloaded reads shows functions powerful 
mcp haskell input functions written style described section hudak fasel 
mcp haskell counterpart mcp id scan cell shown string cell def string cell reg atten reg mat imp density reg reads mat reads imp reads density reads instance text cell def method reads 
cells reads haskell approach needs barriers reads shows functions side ecting 
overloading programmer specify kinds read performed body type system infer correct method call reads 
true material importance density parts scalars function reads region region earlier code instance class text method reading regions created 
similarly code cell def instance text method reads 
type synonyms mcp id including cell def shown data types mcp haskell speci purpose making possible read overloaded reads function 
necessary create constructor function 
example shows declaration cell def code id cell def region list haskell data cell def cell region int int double double monte carlo photon transport haskell allows programmer get text representation data type derived instance type constructor names program source constructors text representations input output 
possible derived instances data types mcp haskell speci ed syntax closer mcnp types surface 
laziness mcp haskell derived mcp id surprising laziness deep fundamental way 
laziness places simplify code clearer 
laziness simpli es conditional expressions 
example computes distance point plane perpendicular axis direction cosine axis 
comes geometry part code distances cell boundaries computed 
special cases tested trajectory parallel plane plane photon distance 
id code computation protected outer conditional avoid division zero 
haskell code requires single conditional expression value demanded left side operator evaluates false 
id def dist sfc px max oat max oat tg haskell dist sfc px jj signi cant situation involving nested conditionals large incorporate occurs function handles photo track 
sequence tests determine zero photons produced photon absorbed 
id code various computations bohm occur code blocks di erent levels nested conditionals 
haskell code computations lifted function top level eliminating blocks allowing laziness particularly second argument protect things unneeded computations bounds array accesses 
result code easier read 
laziness played role generation source photon seeds 
function takes seed returns new seed forward initial random stream steps 
mcp haskell list seeds number photons tracked seed initial seed speci ed user easy generate take iterate seed iterate function terminating condition laziness decouples problem generating seeds problem terminating list 
id library iterate function third parameter allow terminate list 
unfortunately variety wish terminate iterate function 
id library function iterate terminates applying predicate list members generated equivalent haskell composition takewhile iterate poorly suited terminating basis list length 
special iterate function written mcp id function composition loops mcp id mcp haskell little explicit recursion 
mcp id loops mcp haskell higher order functions 
simple example illustrates id typeof sample array def sample bounds tot tot tot tot nally gg haskell sample double double double double double int sample monte carlo photon transport length takewhile sums map cross sections array id list haskell summed cross value crossover index selects composite material involved collision 
note laziness map sums functions takewhile function satis ed 
resource management resource management problems severely limit number source photons mcp id mcp haskell run 
consequences limited usefulness codes 
section points large runs needed development detect presence bugs 
run large numbers photons separate impure version mcp id created rst 
heap managed id code goals version code 
release structures heap 
ective space leak eventually heap millions source photons run 

control parallelism stay frame memory limits 

force evaluation order peak requirements heap frame memory constant respect number source photons 

remove intermediate data structures possible 
important aspect version top level restructuring tightly couple producers consumers 
structures explicit implicit prevent consumer running ahead producer prevent producer running far ahead consumer prematurely creating structures sit waiting consumer catch 
prevent entire ow diagram combined loop body iteration creates tracks tallies frees structures source photon ffor bound bnd seed seed particle sample source seed particle energy acc energy acc sure track doesn free particle read events ol cons create source ev track user info particle events ol close bohm tally aggregates tally balance events user tallies ffor low high sequential tally source events accumulators squares complete tallying releasing event list list allowed elimination intermediate lists importantly heap requirements constant regard number source photons new iteration source photon start previous completed returned memory heap 
tally accumulations part loop longer expressed id accumulator array syntax 
tallies explicitly accumulated structure arrays tally source tally balance procedures 
conserve frame memory sequential processing source photon enforced sequential loops barriers track function split photons executed concurrently parallelism comes bound loop 
recursions replaced loops possible 
included putting loop track function process linear photon tracks recursion 
splitting occurs split photons tracked recursive calls split photons continues tracked loop 
loop form incompatible accumulating parameter event list id open list library functions allow appending concatenation done constant time 
safe sharing lists code 
heap memory space leaks plugged adding releases 
included making modi ed version open list library functions releases added 
synchronization barriers strategically placed ensure releases occur prematurely 
example consider situation structure allocated elds written consumer reads elds structure released 
barriers possible structure released subsequently reallocated elds written causing structure double write errors occur 
placing barrier immediately writing elds structure readers completely written solves problem 
sharing data structures eliminated copying counts needed reader release structure nished 
monte carlo photon transport hard di culty involved producing working version debugging process involved iterations plugging memory leaks running problems tracking bugs xing 
change code required revision memory releases code parts modi ed 
finding space leaks done running small numbers source photons mint simulator producing trace heap allocations 
leaks located isolated doing repeated runs di erent function colorings user assigned tags di erent code blocks allocations tagged color 
structure size source function known identi ed release added code 
long tedious process 
debugging id imperative approach input output helpful 
possible execution open le writing stream pointer globally available program 
structure lock le created help synchronize writes le prevent interleaving writes due parallel asynchronous execution program 
allowed print statements embedded code 
typically suspect function print statements entrance exit points show input output values function call 
finding synchronization problems di cult 
typically manifested structure memory errors usually running multiple processors 
way know program data structures associated error error repeatable 
show mint simulator simulates single processor sequential execution order may cause illegal operation occur 
absence support diagnosing synchronization errors gaze code wait inspiration 
modi ed version mcp id runs correctly tests impossible rule possibility contains subtle synchronization error shown 
eventually full statistical agreement mcnp reached 
longest run consisted source photons approximately hours node monsoon machine lanl 
correct execution increases con dence memory leak elimination synchronization done correctly 
code hand easy reverse engineer pure functional version outputs heap releasing id code pure functional id code absolutely identical 
divergence debugging easy detect isolate leading directly 
expect output mcp haskell identical mcp id quite true di erences handling oating point numbers id haskell produce small variations values occasionally random value fall di erent sides decision threshold cause divergence mcp id mcp haskell 
di erence statistically insigni cant 
bohm heap problems mcp haskell heap releases control parallelism concern haskell code automatic run time garbage collection release memory execution sequential 
unfortunately evaluation order mcp haskell requires heap size grows linearly number source photons 
heart problem data structure sharing interacting lazy evaluation 
understand problem consider simple example pr integer integer int pr xs sum xs length xs list xs shared function calls 
lazy evaluation rst return tuple demanded entire list xs built garbage collected sum traverses list may needed second tuple demanded 
sum nished traversal entire list xs exists memory 
gure forks diagram represents sharing data structure analogous example 
consider sharing event lists structure millions source photons run millions events live simultaneously structure exhaust heap memory 
obviously problem evaluation order 
consumers interleave accesses necessary entire list live memory time 
simple attempt haskell look pr integer integer int pr xs xs su cient 
laziness prevents addition second parameter rst tuple demanded 
simple example desired behavior obtained providing strictness information allowing additions invocation performed pr integer integer int pr xs strict strict xs function uses resources constant respect length list 
application technique mcp haskell considerably monte carlo photon transport complicated questionable programmer expected go lengths modifying source code 
performance overriding aspect mcp functional codes performance inability run usefully large problems resource issues 
heap managed id code primary focus ability long runs codes compared performance fortran mcnp 
important realize mcp id patterned ways mcnp di erences blind comparison dangerous 
speci cally code doing geometric computations determining identities cells patterned mcnp code signi cant di erences exist computations 
mcnp collects information analysis results give user idea degree success translating problem behaved speci cation 
performance heap managed mcp id monsoon embarrassing compared mcnp cray 
running example source photons run single processors performance mcp id seconds mcnp seconds factors ect performance machines including compilers memory characteristics instruction di erences cpu design clock speed monsoon ns 
cycle versus ns 
cycle 
full performance comparison require closer investigation issues subject 
monte carlo photon transport problem coded cleanly pure functional way mcp functional produces results statistically comparable mcnp 
functional codes useful language implementors features coding styles languages 
laziness helpful allows somewhat cleaner style coding cause resource management problems large shared data structures 
development mcp functional proceed order expected 
develop pure functional version modify necessary run large problems cient heap released version done rst statistically meaningful results detect bugs 
ability explicit heap releases id tedious print output traces side ecting nearly impossible debug code due statistical nature 
bohm resource management issues far biggest obstacle development mcp functional 
problems correctly reclaiming heap memory managing order program evaluation keep peak requirements machine capacity solved functional languages accepted scienti codes 
requiring programmer provide explicit releases heap memory goes grain functional programming introduces imperative time dependent operations requires precise understanding control evaluation order program 
compilers smart handling issue hicks languages give programmers means express straightforward way information needed executing program live resource limits 
research directions include study heap usage haskell environment compilation techniques avoid creation complete structures multiple situations exploration sisal strengths weaknesses expressing code especially regard sisal streams express producer consumer relationships help control heap memory 
interesting research directions suggest area compiler directed program transformations similar done manually allow mcp id version run large problem sizes 
obtaining source code documentation source codes available anonymous ftp schubert cs colostate edu 
addition id haskell sources full cross section les allowing users set problems di erent 
wish tom booth patiently helping understand mcnp 
bird wadler 
functional programming 
prentice hall international 
editor 

mcnp general monte carlo particle transport code version los alamos national laboratory report la 
carter 
particle transport simulation monte carlo method 
critical review series tid 
hendricks 
ects changing random number stride monte carlo calculations 
nuclear science engineering pp 
hicks 
experiences compiler directed storage reclamation 
conference functional programming languages computer architecture acm press pp 

hicks ang arvind 

performance studies id monsoon data ow system 
journal parallel distributed computing vol 
pp 

hudak fasel 
gentle haskell 
acm sigplan notices 
monte carlo photon transport hudak peyton jones wadler 
editors 

report programming language haskell non strict purely functional language version 
acm sigplan notices 

id world environment development data ow programs written id mit lcs tr 
nikhil 
id version manual 
computational structures group memo massachusetts institute technology 
hendricks 
mcnp photon benchmark problems 
los alamos national laboratory report la 
