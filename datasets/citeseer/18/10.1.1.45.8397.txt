lorel query language semistructured data serge abiteboul quass jason mchugh jennifer widom janet wiener department computer science stanford university stanford ca quass widom db stanford edu www db stanford edu lorel language designed querying semistructured data 
semistructured data prevalent structured documents html performing simple integration data multiple sources 
traditional data models query languages inappropriate semistructured data irregular data missing similar concepts represented different types heterogeneous sets object structure fully known 
lorel user friendly language sql oql style querying data effectively 
wide applicability simple object model underlying lorel viewed extension odmg language extension oql 
main novelties lorel language extensive coercion relieve user strict typing oql inappropriate semistructured data ii powerful path expressions permit flexible form declarative navigational access particularly suitable details structure known user 
lorel includes declarative update language 
lorel implemented query language lore prototype database management system stanford see www db stanford edu lore 
addition presenting lorel language full briefly describes lore system query processor 
discuss lorel implemented top conventional object oriented database management system 
amount data available line grows rapidly find data semistructured 
semistructured mean data may structure structure rigid regular complete structure required traditional database management systems 
furthermore data fairly structured structure may evolve rapidly 
traditional relational database management systems require strict table oriented data notion schema defined advance adhered data managed system 
object oriented supported air force wright laboratory aeronautical systems center arpa contract air force rome laboratories arpa contract equipment digital equipment ibm corporations 
author permanent position inria rocquencourt le chesnay france 
database management systems permit richer structure relational systems require data conform predefined schema 
management semistructured data requires typical database features language forming ad hoc queries updates concurrency control secondary storage management semistructured data conform standard database framework trying conventional dbms manage semistructured data difficult impossible task 
stanford goal lore project lightweight object repository provide convenient efficient storage querying updating semistructured data 
presents lore query language lorel lore language 
implemented lorel home grown dbms designed specifically semistructured data data model underlying lorel defined extension odmg model language extension oql 
see cat specification odmg oql 
lorel implemented top conventional object oriented dbms yielding flexible system suitable managing structured semistructured data 
semistructured data arises number common situations 
data sources designed non rigid structures convenience 
concrete example acedb genome database tmd somewhat concrete certainly known example world wide web 
web imposes constraints internal structure html pages structural primitives enumerations may 
frequent scenario semistructured data data integrated simple fashion heterogeneous sources discrepancies various data representations information may missing sources attribute may single valued source multi valued entity may represented different types different sources 
querying semistructured data expect user fully aware complete structure especially structure evolves dynamically 
important require full knowledge structure express meaningful queries 
time want able exploit regular structure query processing happens exist user happens know 
remainder introductory section examples semistructured data queries data english lorel 
explain relationship lorel underlying data model oql odmg 
discuss related preview remainder delving details 
examples give example queries demonstrate simplicity power lorel semistructured data 
details lorel sections 
examples assume guide database collects information local restaurants variety sources newspaper reviews regional guidebooks personal web pages 
example shows lorel handles type coercion important underlying lore system lightweight senses object model supported lore lightweight system lightweight currently support locking logging security heavyweight dbms features 
data untyped irregularly typed may missing fields 
second example shows wildcards regular expressions lorel important structure data irregular unknown 
example find addresses restaurants zipcode 
lorel query directly follows english statement select guide restaurant address guide restaurant address zipcode necessary know zipcode represented integer string value lorel coerce accordingly strings integers expected result retrieved 
furthermore address contain zipcode cause error simply fail condition 
query languages sql oql type error ensue types match field missing 
addition lorel necessary worry cardinality set versus singleton components path expressions oql 
restaurant addresses address expected result returned get address zipcode 
example find names cheap restaurants 
time assume zipcode part address may direct subobject restaurant 
know string cheap part category price description subobject 
able ask query lorel follows select guide restaurant name guide restaurant address zipcode guide restaurant grep cheap address means address optional path expression 
wildcard match subobject restaurant comparison operator grep return true string cheap appears subobject value 
equivalent query sql oql allow regular expressions wildcards 
lorel oql data model underlying lorel called oem object exchange model 
oem simple flexible object model introduced initially tsimmis project stanford pgmw 
roughly speaking database conforming oem thought graph complex values internal nodes atomic values leaf nodes labeled edges 
lorel language scratch oem done previous version lorel qrs clarity wider applicability chosen define lorel formally extension oql oem extension odmg model 
users familiar oql additional features introduced lorel handling semistructured data simple learn 
hand knowledge minor changes original model introduced facilitate lorel labels vertices edges original model added distinguished names entry points database 
heterogeneity oql oem translation translation compilation lorel access access oql odmg relationship lorel oql oql necessary lorel common lorel queries expressed easily compact intuitive form reminiscent simple sql 
define semantics lorel oem database terms oql odmg add odmg model new type represent oem objects 
core part formal lorel language definition extend equality base predicates functions oql handle oem objects 
extension relies heavily coercion number levels relax strong typing oql 
time lorel extends oql powerful flexible path expressions allow querying precise knowledge structure 
path expressions built labels wildcards place holders regular expressions allowing user specify rich patterns matched actual paths database graph 
relationship lorel oem oql odmg depicted 
lorel translated syntactically extension oql includes heterogeneous objects described section path variables wildcards described section 
consequently convenience features included lorel syntactic sugaring extension oql 
query processor lore system performs exactly mapping accessing oem data store process depicted solid arrows lore system implementation described somewhat detail section 
encode oem objects odmg model case lorel mapped pure oql 
process depicted dashed arrows 
section discusses approach implement lorel top odmg conforming database management system 
related version lorel dubbed lorel introduced qrs implemented initial version lore system 
lorel designed defined scratch including full denotational semantics language qrs 
mentioned earlier decided base new version lorel dubbed lorel existing query language approach provides understood semantics wider applicability 
syntax simple queries identical lorel lorel 
syntax complex constructs changed aggregation path variables construction complex query results 
addition define lorel terms oql coercion takes importance lorel lorel 
detailed comparison lorel conventional languages oql cat kks sql ms appears qrs comparisons carry directly lorel 
oem language called msl designed mediator specification stanford tsimmis project 
msl rule language designed different goal lorel specify integration data drawn multiple sources 
plan try characterize relative expressiveness msl lorel 
closely related language called unql designed querying semistructured data 
unql model similar oem bds 
primary feature unql powerful construct called traverse allows restructuring trees arbitrary depth 
restructuring operations expressible lorel designed primarily simple query language 
cacs ccm extensions oql proposed somewhat similar spirit goals lorel 
cacs rigidly typed approach followed heterogeneous collections introduced model strong similarity oem 
language proposed cacs called oql doc coercion way lorel treatment path expressions quite different 
optimizing evaluation generalized path expressions considered ccm 
optimization object algebra operators dealing paths schema level paths data level 
schema context directly optimization techniques 
describe briefly section concept data guide may serve role schema oem database 
plan consider adapting optimization techniques ccm oem data guide 
related query languages world wide web emerged ql ks focuses extensibility websql mmm provides formal semantics introduces notion locality weblog lss datalog syntax 
additional relevant includes query languages hypertext structures mw bk cm mw integrating sgml gr documents relational databases bck object oriented databases ya cacs sgml documents viewed semistructured 
area heterogeneous database integration suggested common scenario semistructured data focused integrating data structured databases 
particular systems pegasus kim designed integrate data object oriented relational databases 
spectrum systems gaia willow fre acl kif gf provide uniform access data minimal structure 
note environments corba omg ole mic operate different level lorel 
approaches provide common protocol passing messages objects distributed object environment 
distributed settings lorel certainly built top take advantage environments corba ole 
believe powerful user friendly features lorel clean semantics inherited oql declarative update language working prototype implementation lorel unique languages cited context managing semistructured data 
outline section specifies object exchange model oem explains viewed extension odmg model 
sections specify lorel query language 
section discusses important novel concept lorel extensive coercion 
sections introduce second important concept path expressions 
simple path expressions described section complex expressions introduced section 
section describes results lorel queries constructed 
lorel declarative update language specified section 
section suggests lorel implemented top object oriented dbms 
section briefly covers lore system describing architecture features explaining query processing somewhat detail 
section covers status implementation availability system plans 
appendix contains grammar full lorel language 
note constructs lorel described body focuses aspects lorel novel designed specifically semistructured data 
object exchange model section object exchange model oem pgmw data model particularly useful representing semistructured data 
data represented oem thought graph objects vertices labels edges 
show oem treated extension odmg data model 
oem data model entities objects 
object unique object identifier oid type oid 
objects atomic contain value disjoint basic atomic types integer real string gif html audio java objects complex value set object denoted set label oid pairs 
labels taken atomic type string 
show example oem database 
line shows label reach object object oid 
object atomic value line 
object complex described earlier subsequent indented lines describe object subobjects 
example object oid guide restaurant category name chef chu address street el real city palo alto zipcode restaurant category name address mountain view address menlo park zipcode price cheap restaurant category fast food name mcdonald price textual representation objects oem database category name price 
object oid atomic object type string value fast food 
adopt odmg feature distinguished object names 
facets concept name ffl name viewed alias object database 
instance guide name object contains collection restaurants object 
ffl seen example queries name serves entry point database 
way objects accessed queries paths originating names 
ffl odmg model require objects database reachable names 
rationale object unreachable query manage access object garbage collected 
names serve roots persistence object persistent reachable names 
oem easily model relational data odmg model hierarchical graph data 
structure close tree graph structure cycle objects 
insist data strongly structured standard database models allowing model semistructured information sources data originates integration heterogeneous sources documents conform precise schema 
observe example restaurants zero addresses ii address string complex structure iii zipcode may string integer iv zipcode occurs address restaurants directly restaurant 
lorel designed handle incompleteness data structure type heterogeneity exhibited example database 
give formal definition oem database treated graph 
definition oem schema consists finite set names oem instance consists finite labeled graph disjoint sets oid corresponding respectively atomic complex objects edges labeled strings ii name function iii value function val maps objects atomic values 
instance satisfy conditions 
atomic vertices outgoing edges 

vertex reachable object name name say object subobject object edge labeled provides example oem database graph 
corresponds data textually 
note subobject relationship containment object subobject objects 
view guide category nearby category name address name address nearby el real palo alto restaurant restaurant restaurant mountain menlo park street city zipcode address nearby fast food cheap category name zipcode price mcdonald chef chu oem graph extending odmg data model show extend odmg data model represent semistructured data typing oem objects odmg objects 
approach provides additional intuition readers familiar odmg model 
allows oql basis defining lorel language 
suggests implementation lorel top traditional object database system discussed section 
difficulty typing oem objects clearly heterogeneity oem data 
deal heterogeneity think complex oem object tuple consisting fields 
labels currently database 
alternatively think complex object tuple infinitely fields possible string label 
objects represented finitely time finite number fields nonempty object 
important consequence encoding complex objects database type oem formally specified 
particular names oem database type 
value field particular oem object possibly empty set subobjects set objects referenced labeled edge 
objects labeled edge field value field empty 
example database shown complex objects typed representing tuples restaurant category name address nearby street city zipcode fields 
object oid restaurant field contain set fields empty 
type definitions symbol denote union types 
oem type follows 
type oem type struct set oem set oem type string type integer type list distinct labels occurring database 
integer string atomic values shown explicitly order simplify presentation 
single object type object purpose clear section 
definition quite valid odmg type odmg model support union types 
consider coding oem objects pure odmg objects implementation odmg database section 
object label expression denotes set subobjects atomic object label occurring database cases field empty set 
observe denotes set objects 
having expression result type regardless structure underlying data key idea extending oql handle semistructured data 
coercion sections describe detail novel aspects lorel query language coercion powerful path expressions explain query results constructed 
readability features primarily terms extend oql language 
note focusing features designed specifically handling semistructured data useful features lorel language inherited oql covered see appendix specification full lorel language 
main issues defining lorel extension oql coerce comparisons objects values intuitive thing return type error comparing objects values different types 
section illustrate need coercion example define precisely coercion introduce new comparison operator useful semistructured data 
assume rudimentary knowledge oql syntax semantics queries self explanatory 
consider carefully query asking addresses restaurants zipcode ignoring moment zipcode nested address 
pure oql syntax lorel permits simpler expression query query select address guide restaurant zipcode strictly speaking object object zipcode subobject object 
query corresponds intuition oql type error equating object integer 
lorel query legal returns desired result 
guiding principle lorel query sense result run time error oem data 
write query know precise structure complex objects bother precise types atomic objects 
flexibility achieved extending base predicates base functions oql perform extensive coercions sections ii defining new value equality operator section 
readers familiar object oriented languages may think extended predicates functions calls methods attached type oem see section 
comparing values atomic objects general certain predicates functions expect arguments particular atomic types 
accept type comparator works integers reals 
context semistructured data prefer accept conditions true object value value 
section consider coercion comparing atomic objects values 
coercion compare complex objects collections objects considered section 
focus basic comparison operators 
comparing atomic objects values want coerce operands values comparable possible 
assume integer oem object 
compare integer say coerce object value dereferencing 
compare real dereference coerce integer value real 
process guided type operands 
integer object comparison arbitrary atomic value proceeds follows 
value case integer compare real compare int real string coerced real false compare int real string real additional atomic types included case statement 
general coercion rules provided basic atomic types corresponding predicates functions 
provided application specific atomic types coercion dollars months days gifs table shows omitting dereferencing coercion takes place atomic types string integer real basic comparison operators 
note symmetric cases omitted 
coercion basic comparison operators trivial need coerce values comparable atomic types 
example comparison particular table outcome lively lore meeting stanford 
interesting issue addressed development access techniques indexing raj hashing support comparisons 
arg arg string real int string gamma string real real real gamma int real int gamma table coercion basic comparison operators string integer coerced real order perform comparison 
coercion non arithmetic comparison operators simpler 
instance lorel includes string comparators grep soundex expect operands precise atomic type string 
rule case simply coerce operands expected atomic type possible 
atomic types comparable compare gif images audio clips 
case comparing values incomparable atomic types comparison return error simply returns false 
furthermore atomic types comparable coercion may fail string apple compared integer 
cases comparison returns false 
comparators mentioned need coercion functions language arithmetic functions addition multiplication 
coercion functions handled similarly 
comparing objects sets objects section consider coercion comparing atomic objects complex objects sets objects 
lorel variable assigned atomic value atomic object complex object set objects 
table presents coercion rules equality 
coercion rules inequality similar 
symmetric cases shown 
note cases table covered section 
instance compare value atomic object dereference object 
leads comparing atomic values handled coercion rules table 
consider new cases 
object object 
case equality exactly oql oid comparison 
users want compare objects value equality 
instance querying restaurants nearby restaurant zipcode intension comparing value object equality zipcode 
consider equality operator section forces value equality comparing objects 
issue value versus object equality arise inequality operators inequality operators defined objects comparison fails returns false values 
arg atomic set complex arg value object objects object value coerce dereference existential false atomic object existential false object set set false objects equality complex object object table coercion equality value atomic object set objects complex object 
know subobject complex object comparison 
comparison fails returns false 
set objects set objects 
case standard set equality element set equal element set 
value atomic object set objects 
interesting case 
consider example query expressed oql syntax select address guide restaurant name chef chu condition name chef chu example type error technically name set name subobjects 
user may believe name single valued attribute may care case 
lorel interpret clause exists chef chu comparison string follows coercion rules table 
approach captures intension users expect single name field gracefully handling restaurants multiple names 
introducing existential quantification viewed form coercion set element 
coercion involved comparing object set objects similar 
equality mentioned earlier semistructured environments users interested primarily values objects 
value equality appropriate oid equality lorel 
lorel chosen retain oid equality comparison objects objects may useful test oem object occurs arg atomic set complex arg value object objects object value coerce dereference existential false atomic value existential false object set existential false objects sides complex value object table coercion equality locations detect sharing subobject 
handle value equality introduce new operator denoted 
operator substantial increase complexity naive user lorel form equality ignore certainly get desired result 
illustrate example 
consider query select name john name jn john child name xn jn xn intended meaning retrieve children john bearing name 
see simpler way expressing query 
note jn xn names john child john respectively 
operator expects atomic values sides jn xn coercion performed obtain object values results comparing strings oid 
note query get desired answer assuming names stored separate atomic objects shared 
better way express previous query select name john child john name name case comparison sets 
predicate expects atomic values sets coerced atomic values existential quantification follows select name john child exists jn john name exists xn name jn xn jn xn involves coercion string values 
coercion rules operator summarized table 
simple path expressions querying semistructured data especially exact structure known convenient form navigational querying path expressions 
idea specify paths oem graph sequence labels edges 
section describe simple path expressions allow obtain set objects reachable sequence labels starting named object oem graph 
powerful form path expressions wildcards regular expressions described section 
simple path expression sequence labels object name variable denoting object 
data path sequence objects edge labeled gamma starting object may data paths match simple path expression path expressions extremely convenient user friendly feature lorel 
see simple path expressions merely syntactic convenience 
explain semantics simple path expressions section describing reduced query oql style object component 
illustrate reduction example 
consider object named guide simple path expression guide path interpreted start object guide follow edge edge 
possibly labeled edges path expression matched number data paths oem graph 
alternatively interpret path expression oql style object component referencing guide denotes set objects edge guide guide denotes objects guide edge similarly guide concrete example illustrates notion 
lorel query left equivalent oql query right path expression reduced 
select select guide restaurant zipcode guide restaurant zipcode precise reduction simple path expression depends path expression appears select clauses 
consider case turn 
clause case path expression appearing clause illustrated previous example 
example suggests general intuition reducing path expressions clause insert variable label 
actual algorithm somewhat complex lorel gives particular semantics common prefixes multiple path expressions 
consider clause guide restaurant address zipcode guide restaurant name sql name relation variable ranges relation 
essentially spirit want think guide restaurant variable ranges restaurants occurrences path expression bound variable 
previous clause translated guide restaurant address zipcode name general case follows directly example 
select clause consider simple path expressions select clause 
cases arise entire path expression occurs clause 
path expression select clause occurs clause possibly prefix longer path expression translating clause variable denotes meaning path expression 
suffices replace path expression corresponding variable 
precisely largest prefix path expression select clause occurs clause replaced variable introduced clause prefix 
example query select guide restaurant guide restaurant address zipcode translated select guide restaurant address zipcode suppose path expression select clause shares common prefix path expression clause label assignment variables clause returns set objects resulting path expression variable assigned clause gamma gamma defined similarly recursion 
set expressed oql translating remainder label nested select clause returning result example query select guide restaurant address zipcode guide restaurant translated select select address zipcode guide restaurant query returns set associated restaurant 
observe restaurant addresses restaurant may empty sets query return error 
clause consider path expressions occurring clause challenging case 
select clause path expression clause prefix necessarily strict path expression clause replace path expression corresponding variable clause 
suppose path expression prefix consider simple example select guide restaurant guide restaurant guide restaurant address zipcode query compares set integer 
coercion rules introduced section get select guide restaurant exists address exists zipcode query return restaurants address zipcode matching 
generalizing treatment simple path expressions difficulty arises fact simple path expression may occur clause occurring clause 
general philosophy identical path expression prefixes match data paths occurrences relate existentially quantified variable 
instance consider query select guide restaurant name guide restaurant guide restaurant address zipcode guide restaurant address street el real guide restaurant address city palo alto returns names restaurants having address zipcode located el real palo alto 
possibility place existential quantifiers clause query select guide restaurant exists address exists zipcode exists street exists city el real palo alto solution satisfactory semistructured data discard restaurant address zipcode cases address street 
query selected exists street fail 
overcome difficulty newly introduced variables allowed take value 
presence value condition condition false false 
approach guarantees existential quantification block evaluation condition condition true mistake nil objects 
correct translation previous query select guide restaurant exists address union set exists zipcode union set exists street union set exists city union set el real palo alto conclude section final topics implementation simple path expressions sharing path expressions select clauses allowing queries clause 
implementing simple path expressions needed general case cases avoid 
usually suffices push existential quantifier innermost point clause encompasses occurrences corresponding variable 
example query previous section translated select guide restaurant exists address exists zipcode exists street el real exists city palo alto existential quantifier address needs placed surrounding conditions involving address existential quantifiers need surround condition 
case restaurant having address zipcode succeed clause street city missing 
unfortunately approach fails certain unusual cases shown queries equivalent problem explains notion partial object assignments introduced define semantics lorel qrs 
remainder subsection essentially shows achieve effect partial object assignments oql 
select select exists exists exists exists exists exists absence edge right false left true appropriate paths 
note adding union exists clause righthand query yield correct answer 
possible simple test verify expression free pathological behavior example ii push existential quantification shown avoid 
select clauses path expression common select clauses variable path expression occurs clause 
consider instance select guide restaurant price guide restaurant guide restaurant price query translated oql follows select select price guide restaurant exists price subtlety connection prices select clause 
prices restaurant price retrieved prices 
keep prices write select select price guide restaurant exists price observe different roles clauses clause filters restaurants embedded query select clause filters prices 
omitting clause queries lorel need clause 
clause provided query generated select clause introducing path expression clause path expression select clause 
clause omitted select clause consist paths originating database names 
example select guide restaurant name guide restaurant category select guide restaurant name guide restaurant guide restaurant category brings back familiar ground 
simple path expressions omitting clause find straightforward queries extremely easy express lorel shall express manner remainder appropriate 
general path expressions section extend notion simple path expressions powerful syntax path expressions called general path expressions 
note general path expressions generalized path expressions ccm 
disregarding details syntax moment examples general path expressions guide restaurant address zipcode guide restaurant comp name guide restaurant nearby name expression specifies paths starting guide restaurant edge zipcode optional address 
ignoring term second expression specifies paths starting guide restaurant edge followed arbitrary number edges unspecified labels symbol followed edge having label comp comp terminating edge labeled name 
path variable bound data path matches path expression 
ignoring term frg expression specifies paths going restaurant edge arbitrary number symbol nearby edges name edge 
data path matching path expression object variable bound frg object immediately name label 
note frg just useful syntactic way attach variables objects middle long paths 
general path expressions obtain name restaurants zipcode address directly field restaurant 
note query employ syntactic conveniences introduced section 
path expressions clause generate clause practice doing unnecessary 
note generating clause cases missing entirely take general approach add missing components clause path expressions appearing query 
simplicity decided general approach 
select guide restaurant name guide restaurant address zipcode consider exact syntax specifying general path expressions turn wildcards 
subsections deal path object variables general path expressions 
important simple path expressions translated oql general path expressions 
regular expressions paths general path expression gpe simple path expression starts object name variable 
general path expressions extend simple path expressions allowing object name variable followed gpe components just sequence labels simple path expressions 
syntax gpe component 
label gpe component 

object variable unquote gpe component 

gpe components gpe components js 
unquote function case takes value object variable string uses label path expression 
instance contains string restaurant guide unquote guide restaurant 
case symbol disjunction means occurrences means means 
difficulty regular expressions kleene closure general path expression may match infinite number data paths data cyclic 
care objects extremities paths finite number 
care paths path variables considered infinite number paths issue 
lorel choose avoid dealing infinite sets paths deciding data path allowed cross object twice matching gpe component terminating general path expression 
acyclicity condition may appear artificial general applications considered far easy implement cycle detection mechanism 
alternative method compute finite representation infinite set data paths matching path expression possible regularity set cou 
approach seriously complicate implementation 
wildcards regular expressions specified allow flexibility querying 
querying semistructured data know labels objects relative orderings precisely 
useful concept wildcards 
wildcard matches characters label 
combination letters digits place label definition gpe component 
example suppose know restaurants label zip zipcode label contains description pertaining price 
express query find names cheap restaurants zip code follows select guide restaurant name guide restaurant zip guide restaurant cheap second wildcard 
symbol path expression shorthand expression useful matches data path length 
practice find frequently queries 
path variables important feature general path expressions ability attach variables data paths path variables 
value path variable data path oem graph list objects labels 
value path variable output query result 
path variables test data paths equality function path turns data path single string containing labels data path separated dots 
path function allows ask queries discover structure data 
instance ask select distinct path guide zipcode path variable obtain set paths database lead zipcode 
obtain restaurant restaurant address restaurant nearby restaurant nearby address practical path variables obtain names labels 
suppose want obtain labels leading objects containing string cheap 
query select distinct path guide cheap query return label path guide object value cheap final label path variable path length flexibility query lorel built string matching predicates grep place 
thought label variable 
note guide bind entire path labels originating guide 
path variables consider path force identical path expressions match distinct paths oem graph query select guide restaurant nearby nearby 
query returns restaurants distinct paths nearby restaurant 
object variables sample general path expressions section far object variables appeared path expression 
show object variables introduced middle path expression simple feature provided primarily syntactic convenience 
query select guide restaurant name category equivalent select guide restaurant name category object variables path expressions alternative way distinguishing path expressions syntactically identical assigned variable 
example query finds restaurants addresses palo alto menlo park select guide restaurant name address city palo alto address city menlo park single existential variable address result empty query result assuming single address single city 
summary general path expression sequence qualified gpe components object name variable denoting object 
qualified gpe component expression form gpe component fy optional path variable optional object variable 
restrict path object variables path variables allowed appear path expressions select clause path object variable may defined path expression query 
constructing results select query lorel semantics select query sql oql results bag multiset set keyword distinct 
lorel result collection oem objects duplicate elimination oid 
top level query query nested subquery query top level assignment see section final collection packaged single oem object 
explain results constructed detail 
sql oql assignment variables clause passes condition clause value generated expressions select clause 
values coerced oem object 
coercion explained detail 
coercion may result creation new objects edges oem graph 
query result may refer original database objects new objects created coercion 
mentioned result top level query single oem object generated hold query result 
default name answer identifies object edges link elements answer 
instance query select guide restaurant generate answer object answer restaurant restaurant restaurant observe new object 
result query reused queries renaming necessary section answer overwritten 
discuss label restaurant chosen edges leading elements answer 
value result select clause coerced oem object oem coercion function specified table 
examine line table 
previous example function oem oem object 
atomic value creates new oem object appropriate type value function new oem 
return function dealing updates section 
interesting cases value returned select clause collection case function creates new complex object holds collection default labels discussed leading subobjects select clause returns struct values case function creates complex object uses attributes case result select expression coercion function oem object coercion needed atomic value new oem type type type collection new oem complex struct default fto oem vg struct new oem complex struct oem collection oem table function oem coerces values single oem object struct labels leading subobjects 
select clause lorel containing expression interpreted implicit struct construction case arises frequently 
note coercion applies result nested subqueries 
example query contains nested subquery select clause result coerced set oem objects coercing result observe coercion extended transform arbitrary portion odmg database object exchange model 
oem object created odmg object values objects coerced rules table 
example query illustrates multiple expressions select clause 
query returns names addresses restaurant guide 
select name address guide restaurant result query sample database answer restaurant name chef chu address restaurant name address mountain view address menlo park restaurant name mcdonald lorel determines appropriate label element result run time 
cases object exists database label data path matched query causing object selected query chosen 
new object existing object projecting subobjects new object label leading existing object chosen 
holds label default new object 
updates seen novel features lorel querying semistructured data 
section introduces lorel declarative update language 
update language possible create delete database names section create new atomic complex object section modify value existing atomic complex object section bulk load oem database section 
mentioned earlier deletion occurs implicitly object unreachable explicit deletion operation 
assigning names objects names entry points database created name statement name name 
expression 
names may created bulk loading database discussed section 
expression returns single object assigned name 
coercion performed coerce expression single oem object necessary function oem specified earlier table 
expressions may queries new object creations null keyword 
name exist statement creates new name called name 
name exists reassigned returned object 
example statement creates entry point restaurant 
name element select guide restaurant guide restaurant name name may reassigned follows name element select guide restaurant guide restaurant name chef chu names deleted assigning null name null note deletion unreachability garbage collection assignment null may result deletion objects 
object creation object creation function new oem new oem val type value object function creates single object specified type value 
objects may created bulk loading course 
possible value types object atomic types integer real string gif complex object type complex 
complex object values specified struct field describes label element oql keyword extracts returns single member singleton set 
set oem objects label 
lorel includes second function load oem creating binary large objects gif images audio 
load oem identical new oem name file containing value place value 
examples new oem int complex struct int example constructs integer oem object value 
second example creates new complex object say puts edge new object value puts edges objects named allow shorthand notation creation objects omitted information redundant 
value type deduced value may omitted 
example inferred integer 

values coerced objects function oem table needed 

struct constructor may omitted 
examples may written compactly note particular operator new oem may omitted understood new oem int coercion 
updates objects values objects may modified update statement 
consider updating single named complex atomic objects look updating objects simultaneously construct 
suppose price named atomic integer object 
value may modified statement update price statement changes value inside object identified price 
statement price continues identify object 
contrast name price create new object containing value assign price 
updates may increment add decrement delete value 
example adds price value update price similarly decrement value 
complex objects may modified changing adding deleting subobjects label 
instance update indicates new branch favorite restaurant opened sunnyvale 
update address sunnyvale general form update statement complex objects update object selector label 
expression 
semantics updating complex objects defined follows 
object selector 
determines object updated 
usually database name unique object result query element 
expression 
identifies set objects 
operator new edges created object label label 
operator existing edges label label 
objects removed 
operator edges label label 
removed new edges label label 
introduced object observe change type object simply assigning value different type important convenience feature semistructured data 
consider way modifying objects simultaneously 
statement form update expression 
clause 
clause 
variable bound clause 
clauses lorel select statement 
binding variables clauses done evaluating update variables may query expression 
logically update expression performed binding clause satisfies clause 
modify values multiple objects construct 
example query adds restaurant city direct subobject restaurant object city palo alto menlo park update city guide restaurant address city palo alto menlo park observe takes operations update label 
example statements transform restaurant labels labels 
update guide select guide restaurant update guide restaurant bulk loading lorel provides load filename statement reads load file filename 
creates objects described 
load file objects may type 
object atomic type value 
object complex described subobjects may include new objects created load file named objects existed prior load 
cyclic data supported 
persistent name may assigned new object part load 
lorel load statement add additional subobjects existing named objects 
load file syntax details hw 
implementation top oodb section briefly consider lorel implemented top standard odmg database 
reconsider type oem defined section 
discussed sections primary aspects translating lorel oql extended heterogeneous objects touch additional issues including briefly issue physical database design 
oem objects implemented odmg object definition language odl type definition interface oem interface oem attribute set struct label string values set oem complex value interface oem attribute string atomic value interface oem attribute int atomic value interface oem changes type definition section due minor restrictions odl internal structure object tuple simply atomic value forces introduce attributes atomic value ii need represent complex oem object set pairs label set values 
type extent type oem empty 
certain methods apply oem objects defined type oem subtype instances 
methods obtain value oem object compare oem objects update example method extract subobjects complex oem objects set oem field string label complex oem object expression field address returns set address subobjects complex address subobjects empty set returned 
comparators defined methods 
instance methods class oem comparing oem objects boolean value equal oem val boolean equal int int val boolean equal string string val 
note instance method equal int defined false class oem redefined class self atomic value val self atomic value int real val class 
updates implemented methods 
consider updates modify type objects updates permitted odmg 
object creation simply uses new function type argument 
atomic objects new function takes initial value argument argument complex oem objects initialized empty 
update methods boolean assign real real new value boolean assign int new value boolean add edges label string added set set oem boolean method remove edges label string removed set set oem methods defined class oem 
methods applied object complex effect database simply returns false 
considering updates object type say improper update assigning real complex object effect database returns false 
particular assign real redefined class real obvious meaning classes integer string new value appropriately coerced performing update 
conclude section noting performance implementation depends heavily issues clustering indexes 
clustering system capable clustering object subobjects recursively 
second important issue indexes managing complex objects subobjects 
example index speeding evaluation method field described 
lore system implemented lorel query language prototype database management system lore 
interested exploring facets managing semistructured data lore built entirely scratch 
shown previous section lorel implemented top conventional object oriented dbms 
discuss architecture query engine comprise lore system 
comprehensive discussion lore system scope 
basic architecture lore depicted 
section focus query processor briefly describe textual interface html graphical user interface object manager 
query processing parsing preprocessor logical query plan generation query optimization physical query plan generation execution physical query plan parsing preprocessor logical query plan generation query optimization physical query plan generation execution physical query plan textual interface html gui object manager query processing lore architecture current lore system user interfaces 
simple textual interface primarily developers debugging 
graphical interface primary interface users provides powerful tools browsing query results data guide feature seeing structure data formulating simple queries example way saving frequently asked queries mechanisms viewing exotic atomic types video audio java 
object manager component appears just persistent storage component lore architecture functions interface query processor low level file constructs 
supports basic primitives fetching object comparing objects performing simple coercion iterating subobjects complex object 
addition performance features cache frequently accessed objects implemented component 
query processor resides user interface object manager follows basic steps answering query 
query parsed 
parse tree preprocessed translate oql query 
logical query plan constructed 
query optimization occurs 
optimized logical plan translated physical query plan 
physical plan executed 
example consider simple lorel query select oa true aggregation groupby oa op exists target oa join scan oa restaurant oa scan oa address oa select oa scan oa category oa join join project oa scan root guide oa sample lore query plan select guide restaurant address guide restaurant category query parsed translated oql query techniques described 
oql query select guide restaurant address exists category logical query plan generated 
plan example query shown 
lorel object oriented data model query execution strategy primarily familiar relational operators 
relational tuples operate object assignments oas 
recursive iterator approach query processing described gra 
explain oas constructed operated nodes logical plan 
oa simple data structure containing slots corresponding range variables query additional slots depending form query 
example oa structure example query oa oa oa oa oa guide oa restaurant oa address oa category aggr intuitively slot oa holds oid node data path currently considered query engine 
example oa oid restaurant oa oa hold oid address subobjects category subobjects respectively 
note point query processing necessarily case slots current oa contain valid oid 
function query execution build complete oas 
briefly explain operators 
scan operator leaf nodes similar functionality relational scan 
scanning tuples name relation scan returns oid subobjects oid respect gpe component 
scan operator defined scan scan starts search oid stored iteration places oid subobject satisfies gpe component 
gpe component string describing labels scan match similar syntax gpe components described section 
scan called repeatedly longer holds valid oid 
example consider scan appears example plan scan oa address oa scan iterator place slot oa time address subobjects oid slot oa note special form lower left scan scan root guide oa 
oa slot argument value root system known oid names reached 
child join node fills information current oa 
relational join operator function join node coordinate left right children 
partially completed oa left child returns right child called exhaustively new oas possible 
left child instructed retrieve partial oa 
iteration continues left side produces oas 
select project nodes nearly identical corresponding relational operators 
difference relational select project deal relation attribute names lore query plans operators implicitly operate objects identified oid current oa 
project operator limit subobjects returned specifying set oa slots select operator applies predicates objects identified oa slots 
aggregation node shown right child join node somewhat novel way 
functioning standard grouping aggregation operation serves evaluation mechanism quantified variables 
aggregation node groups oas received child specified slot oa example applies aggregation operator case exists 
adds specified slot current oa oa example result aggregation value true existential quantification satisfied false 
filtering oas quantification true occurs final select node 
note exists operator short circuits finds satisfying oa aggregation operators need look oas group 
fairly obvious optimizations done logical plan pushing top select right subtree moving selection conditions scans 
current lore query processor query optimization techniques implemented physical query plan similar logical plan 
essentially evaluate plan shown directly 
implementation query optimization real physical plans design 
lore system includes novel features addition lorel language 
particular interest data guide external objects ffl data guide oem database oem object encapsulates structure graph terms edge labels repeating identical paths :10.1.1.25.9024
essentially data guide provides structural summary current database semistructured environment extremely useful understanding data structured formulating queries 
graphical user interface data guide form simple queries example style 
ffl external objects allow lore dynamically fetch integrate information stored external data sources query processing cache information 
object lore may placeholder external object allowing lore serve storage repository semistructured data query driven integration engine 
system status summer query processor rest lore system functional robust subset lorel language 
language features implementation underway include path variables external predicates functions complex select clauses full aggregation declarative update language 
addition complete functionality general path expressions implemented substantial useful subset lore currently maintains indexing structures query plans intelligent 
noted currently little query optimization takes place considerable amount area query processing 
lore designed initially lightweight dbms primarily single user read mode find uses lore feeling need add heavyweight features transactions concurrency control recovery 
lore server number sample databases available public 
users submit queries subset lorel query language currently frozen experiment features result browsing data guides external objects 
please visit www db stanford edu lore 
members lore research project past including roy goldman kevin haas luo nestorov anand rajaraman hugo sagiv jeff ullman rest stanford database group lively discussions lorel 
bck blake consens larson snider tompa 
text relational database management systems sql sgml 
proceedings international conference applications databases pages sweden 
bancilhon delobel kanellakis editors 
building object oriented database system story morgan kaufmann san francisco california 
bds buneman davidson suciu 
programming constructs unstructured data 
proceedings international workshop database programming languages dbpl 
bk beeri 
logical query language hypermedia systems 
information sciences 
cacs christophides abiteboul cluet scholl 
structured documents novel query facilities 
proceedings acm sigmod international conference management data pages minneapolis minnesota may 
cat cattell 
object database standard odmg 
morgan kaufmann san francisco california 
ccm christophides cluet moerkotte 
evaluating queries generalized path expressions 
proceedings acm sigmod international conference management data pages montreal canada june 
cm consens mendelzon 
expressing structural hypertext queries graphlog 
proceedings second acm conference hypertext pages pittsburgh pennsylvania november 
cou courcelle 
fundamental properties infinite trees 
theoretical computer science 
fre freedman 
willow technical overview 
available anonymous ftp ftp cac washington edu file willow tech report ps september 
gf genesereth fikes 
knowledge interchange format manual 
available logic stanford edu sharing papers kif ps 
gr goldfarb 
sgml handbook 
clarendon press oxford uk 
gra graefe 
query evaluation techniques large databases 
acm computing surveys 
hw haas wiener 
bulk load lore database 
working document stanford university database group july 
kim kim 
object oriented database technology 
product literature 
kks kifer kim sagiv 
querying object oriented databases 
proceedings acm sigmod international conference management data pages san diego california june 
ks konopnicki shmueli 
qs query system world wide web 
proceedings international conference large data bases pages zurich switzerland september 
lss lakshmanan sadri subramanian 
declarative language querying restructuring web 
proceedings sixth international workshop research issues data engineering ride new orleans february 
mic microsoft 
ole programmer 
microsoft press redmond wa 
mmm mihaila milo 
querying world wide web 
draft 
ms melton simon 
understanding new sql complete guide 
morgan kaufmann san francisco california 
mw watanabe 
queries structure hypertext 
foundations data organization algorithms fodo pages 
springer 
mw mendelzon wood 
finding regular simple paths graph databases 
siam journal computing 
nestorov ullman wiener chawathe :10.1.1.25.9024
representative objects concise representations semi structured hierarchical data 
technical report stanford university database group 
available db stanford edu pub papers representative object ps 
omg omg 
common object request broker architecture 
object management group framingham ma 
papakonstantinou abiteboul garcia molina 
object fusion mediator systems 
proceedings second international conference large data bases bombay india 
papakonstantinou garcia molina ullman 
mediation system declarative specifications 
proceedings internation conference data engineering icde pages 
pgmw papakonstantinou garcia molina widom 
object exchange heterogeneous information sources 
proceedings eleventh international conference data engineering pages taipei taiwan march 
qrs quass rajaraman sagiv ullman widom 
querying semistructured heterogeneous information 
proceedings fourth international conference deductive object oriented databases dood pages singapore december 
qrs quass rajaraman sagiv ullman widom 
querying semistructured heterogeneous information 
technical report stanford university database group 
document available ftp db stanford edu pub papers querying full ps 
raj rajaraman 
indexing semistructured data flexible comparisons 
working document stanford university database group march 
ahmed desmedt du 
integration strategies pegasus object oriented multidatabase system 
proceedings fifth hawaii international conference system sciences volume ii pages january 
rao janssen rajaraman 
gaia technical overview 
technical report xerox palo alto research center 
tmd thierry durbin 
syntactic definitions acedb data base manager 
technical report mrc laboratory molecular biology cambridge england 
ya yan 
integrating structured text retrieval system object oriented database system 
proceedings twentieth international conference large data bases pages santiago chile september 
syntax complete lorel syntax appears figures 
note constructs language discussed body focuses innovative features lorel 
grammar fg means repetitions fg means repetitions means optional 
exception rule delimit character class means sequence characters drawn class 
rule higher precedence rule meaning path expression consisting multiple label expressions separated dots parsed multiple qualified paths single qualified path consisting multiple paths 
note factoring grammar occurred facilitate parsing safe set query 
query set query atomic query value query set query query path expr set query intersect set query set query union set query set query set query set query atomic query var element set query value query atomic query constant path var external function name query list query arith op query gamma query abs query aggr function set query query list query query query query select distinct select expr select expr expr expr predicate select expr query select identifier select identifier query new oem select expr select expr select identifier expr path expr var var path expr predicate predicate predicate predicate predicate predicate query comp op query safe set query exists set query boolean constant exists var safe set query predicate var safe set query predicate safe query safe set query safe query comp op quantifier safe set query external predicate name query list predicate lorel syntax safe set query set query path expr safe query query constant variable path expr atomic query select identifier identifier unquote path var arith op gamma mod comp op 
grep soundex aggr function min max count sum avg constant nil integer literal real literal quoted string literal boolean constant boolean constant true false path expr var gpe qualified gpe component gpe component path var path var identifier var identifier gpe component label expr gpe component gpe component gpe component gpe component gpe component regexp op regexp op 
label expr za unquote path var lorel syntax continued 
