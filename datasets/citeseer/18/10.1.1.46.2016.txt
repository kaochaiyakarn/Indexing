representing layered monads andrzej filinski brics department computer science university aarhus ny munkegade dk aarhus denmark andrzej brics dk considerable research constructing modular monad speci cations computational ects state exceptions nondeterminism programming languages 
simple framework tradition church style ect typing system ml language 
semantics language formally de ned series monadic translations expanding away layer ects 
layered speci cation easy reason direct implementation parameterized interpretation actual translation prohibitively ine cient 
exploiting deeper semantic properties monads possible derive vastly cient implementation show layer ects uniformly simulated continuation passing multiple layers simulated standard semantics call cc mutable state 
multi ect programs executed scheme sml nj full native speed generalizing earlier single ect result 
example show simple semantics concurrency allows directly simulate shared state program possible dynamic interleavings execution threads 
monads established key concept functional programming semantic framework ml languages mog structuring technique purely functional programs computational ects wad 
situation clear prospect monads structure multiple potentially intertwined ects number frameworks proposed mog ste cf esp gained overwhelming acceptance 
surprising truly modular characterization computational ects probably ill basic research computer science www brics dk centre danish national research foundation 
permission digital hard copies part personal classroom granted fee provided copies distributed pro commercial advantage copies bear notice full citation rst page 
copy republish post servers redistribute lists requires prior speci permission fee 
popl san antonio texas usa copyright acm speci ed problem unique solution 
monad formalisms tend leave areas de nite room improvement conceptual overhead 
usually clear single monad isolation represents particular notion computational ect mutable state exceptions individual ect operations reading writing state raising handling exceptions expressed terms monadic structure 
multiple ects initial cost higher notion ect speci ed integrable form speci cation operations likewise parameterized 
cases operations ect fundamentally incompatible monadic structure signi cantly complicating semantics resulting language 
practical overhead 
distinct problem executable speci cations interacting ects computational ciency 
explicit purely functional de nitions ects easier reason programs practice key monads state usually implemented imperatively compiler 
ciency problems compounded multi level ects naive implementation cost computational step generally directly proportional total number ects modeled built monads generally integrable multi ect framework exibility user speci ed ones 
hardly nal word subject framework monadic effects addressing problems novel way conceptually ers simple declarative speci cation nested translations practically cient imperative implementation terms low level control state primitives 
detail notion ect speci ed independently formal monadic translation state passing exception passing de nes monadic re ection rei cation 
establish trivial bijection opaque transparent representations ect computation allowing de ne usual ect operations terms transparent representation write general programs opaque form 
speci cation purely local written independently ect 
secondly show monadic translation simulated continuation passing translation re inl inr case val ect typing subtyping rules tains original transparent representation ects substitutes di erent opaque 
result show correctness direct implementation terms control operators shift reset 
previously shown fil fil operators implemented scheme style primitives call cc state uses call cc operation host language 
show addition de ning shift reset regenerate call cc implement ects interference 
monadic tower embedded language scheme primitive ects 
accordingly structured follows section translation speci cation monadic ects 
section show correctness continuation implementation logical relations concrete realization construction sml nj 
section contains practical examples including simulation shared state concurrency 
section compares results related monad layering control operators section presents outlines 
specifying layered ects section introduce simple functional language type system keeping track ect behavior terms show language systematically extended new programmer de ned ects 
multi ect language purpose formal results convenient syntax computational steps explicitly sequenced 
results non trivial operations explicitly named normal monadic normal forms hd 
ultimately able write concrete programs ml notation implicit call value sequencing 
re ne language type system keeping track ects similar tolmach lesser degree wadler intermediate languages ml tol wad 
ect types de ne new language descriptively analyze 
raw syntax follows inl inr case val 
ranges set ect names classify range ects expression typing judgment states typing assumptions mapping variables types type possible ects particular ect means evaluation ects behaves value purpose equational reasoning 
distinguished ect partiality indicates evaluation may diverge ects 
typing rules displayed 
parameterized ect layering relation expressing layered immediately sense precise section 
typically means de ned formal translation language ects 
re exive transitive closure 
pattern matching binding syntax projections particular write write simply complete program closed term base type 
simplicity may put restrictions potentially escaping ects programs preference complicating top level semantics 
example may require complete program handles exceptions may raise catch exception wrapper 
language parameterized signature assigning potentially polymorphic types basic constants language 
typically include standard arithmetic functions particular family cbv xed point operators note recursively de ned functions ect partiality 
complete programs monomorphic need extra generality type schemas order de ne monad components polymorphic terms section 
lines add implicit sube ecting subtyping language 
note subtyping relations introduced changes ect annotations 
expand occurrences general construct primitive ones follows val similarly typed terms system subsumption expanded system replacing instances rule appropriate coercion terms val case inl inr subtyping systems potential coherence problem semantics ensure di erent ways inserting coercions program give result 
see application automatically ensured see note theorem 
layered monads ect semantics concreteness denotational semantics language setting cpos chain complete posets necessarily containing elements continuous functions 
speci choice essential 
start standard concept de nition monad consists triple maps cpo cpo computations family value inclusion functions 
ta 
normally written family binding functions ta tb tb tb tc 
generally omit type subscripts clear context 
de ne tf 
ta tb tb ta 
tb 
intuitively elements ta represent computations yielding values represents trivial computation represents computation consisting evaluating value possibly ects followed evaluating possibly effects monad laws ensure sequencing ects behaved 
simple monad identity monad ia important non trivial example lifting monad computation type constructor domain theoretic lifting la 
unit inclusion binding strict extension 
fa 
introduce concept useful stacking monads de nition layering monad monad consists function family ta ta ta algebra ml vi ta id ta algebra morphism tf ta tb de nition layering bit technical captures requirement computation meaningfully interpreted general computation 
explicitly constructed terms generally obtain suitable directly shape shown section 
additional condition usually immediate verify informally expresses computation represented performs latent ects rst 
monad layered id ta ta ta 
layered layered ta ta ta ta 
layered de ne computation inclusion lifting tol function family ta ta 
easily checked monad morphism mog satisfy equations 
conversely monad morphism obtain layering id ta formulations allow de ne mixed binding operation ta tb tb ia tb tb de ning layering terms inclusions may natural turns primitive notion leads direct implementation monadic ects section 
monad trivially layered identity layered lifting ta pointed cpo element ta allowing ta strict original computation divergence ect 

conversely layered lifting ta necessarily pointed ta strict lf 
de ne semantics language 
done style church give meanings typed terms de nition ect semantics semantics ect language assigns rst base type cpo ect monad layered assignment induces semantics general type phrases follows 
assignment cpos type variables type de ne cpo follows extends straightforwardly semantics type assignments dom assign constant family elements 
de ne typed term meaning omitting subscript semantic brackets 
val 

straightforward clauses sums products include collection result interpretation functions meanings complete programs observations countable set nal outputs character strings 
complete program de ne standard semantics language take identity monad lifting 
implementation semantics may di erent interpretation example give continuation semantics partiality result interpretation function adjusted appropriately 
standard interpretation 
pointed layered partiality 
reason terms language means formal equational theory including particular equations ex fv val val val fv usual ones products sums 
note strong rules functions valid restrict terms application ects 
adding new ect course enrich language adding new ect level semantics 
wide variety ects de ned purely syntactically de nition formal monad ect consists type constructor polymorphic terms type type glue unit bind denotes actual monad layered semantics 
ta glue 
unit 
bind 


note require denote monad interpretations ect example formal list monad give semantics nondeterminism section properly layered commutative monad kw partiality 
component glue usually constructed systematically just form follows glue glue val glue val glue val fact cases rst rule su ces 
easy check glue satis es algebra conditions de nition veri cation additional property bind usually straightforward 
construct extension new ect new proto operations monadic re ection rei cation fil re ect reify write re ect conversely reify 
informally evaluating performs action represented datum returns datum representing action result evaluating note proper extension program valid program meaning 
means de ne semantics formal monadic translation jj back expanding new type term constructors de nitions 
translation ect ect type constructor jej jtj jej types function spaces non trivial translation jej nally de ne translation jj terms jej jej nontrivial clauses ej unit jej bind je je glue je val je ect tj tj syntactic translation agrees denotational semantics lemma jj semantics determined extending re ect ta reify ta 
example base type exn exception names formal monad ex exceptions de ned 
exn glue unit inl bind case val inr fact denote monad monadic interpretation calling new ect ex de ne operations types raise exn ex handle ex 
exn ex ex terms proto operations raise exn ex val inr handle ex exn ex ex ex case val ex hx raise constructs exception computation immediately returns right tagged re ects ex ect 
conversely handle rei es computation sum typed value performs computation returns result passes exception name handler easy check semantics operations capture usual behavior ml style exceptions presence state ect 
note reason programs directly expanding programs computing denotational meanings 
particular sound equations typed terms val unit bind glue val equations section easy derive laws particular operations ex raise raise handle val ex val ex handle raise hx ect ordering monadic re ection hierarchical organization ects crucial translation de nition 
able integrate ects mutual ordering desirable goal di erent orderings correspond di erent intended semantics illustrated 
important consequence layering source terms meaningless ect erasures simply typable 
speci cally attempting apply rei cation operator lower level ect higher level computation counterpart program written explicit ect passing de ned meaning translation 
appropriate desired meaning construct expressed explicitly 
simple example analyze issue context mutable state exceptions 
saw de nitions raise handle section 
similarly formal state monad st type constructor st state 
state base type state de ne new ect st operations get st state set state st state st follows get st val set st val st val operations interact exceptions consider ml layering exceptions state partiality st ex state persistent exceptions 
composite translation de ning away rst exceptions state corresponds ect type jj st st state 
exn state started initial state state computation may diverge may result new state value raised exception exn 
proto operators types reify st st state state re ect st state state st reify ex ex st 
exn re ect ex st 
exn ex setting coerce st computation ex computation subtyping system coercion left implicit 
means previous de nition handle ex rei cation works changes expression guarded state ects includes partiality ects 
want extend computations may raise exceptions explicitly account 
example de ne general operation state ex ex ex ex st ex val st rst explicitly ex reify original computation st computation exn perform original operation nally ex re ect back result may ect raising exception 
note applied computation provably exception ects behavior provably coincides original 
show st ex val ex ex val ex equations section 
general optimizer higher order programs preferable maintain explicit ect types advocated tolmach tol 
note behavior di ers naive de nition st ex get st ex set ex st ex set val ex unhandled exception raised modify global state observable di erence exception eventually handled 
versions behave programs raise exceptions 
su cient merely require programs original language partiality state retain meaning extended language partiality state exceptions interactions ects need considered explicitly case 
hand suppose want transactional semantics transient state layered atop exceptions corresponding ect type jj ex ex state 
state exn type shows state discarded computation aborts exception 
ex st monad re ection operators types reify st st state ex state re ect st state ex state st reify ex ex 
exn re ect ex 
exn ex st rei cation computation de ned need explicitly de ne meaning ex reifying computation may state ects handling exceptions 
case natural revised de nition handle handle st exn st st ex st ex case val ex hx st state threading explicit ex rei cation 
worth considerations typically arise want assign de ned meanings terms language ect typing system ect delimiting operations handle 
re ection rei cation concise notation programs written explicit ect passing con icts de nition resolved original program 
implementing layered ects previous section describes framework adding programmer de ned ects ml language 
direct implementation semantics problematic reasons context full programming language requires ectively write full language processor including parser type checker module system standard library perform major surgery existing implementation 
level translation imposes potentially substantial execution time overhead especially programs rarely particular ect provide infrastructure connecting scattered uses 
signi cantly semantics induction explicitly sequenced fully ect annotated terms 
verbosity essentially equivalent writing program explicit monadic style imposes heavy burden programmer accustomed ml anonymous guarantee left right call value evaluation completely implicit sequencing computations 
section show problems solved 
doing demonstrate monad equations layering conditions merely arbitrary category theoretic overhead mere convenience manual automated reasoning programs fact key vastly cient implementation speci cation 
result falls parts individual monadic translation uniformly simulated layer continuation passing tower continuation passing layers simulated single notion ect comprising scheme style rst class continuations mutable state 
phrase simulations terms realizations language realization replaces necessarily new ect ect new constant term meanings complete programs preserved 
relating monadic ects continuationpassing fairly simple observation continuation passing simulate monadic style pw showing translations equivalent surprisingly complicated 
sketched fil single ect completely pure language unfortunately approach mw generalize general settings unrestricted recursion 
fil proof redone admissible relations style rey extended base language arbitrary pre existing ects approach generalize multi ect language previous section sketched 
major complication obtain proper simulation pick answer type cps transform large 
particular means simple base type need recursively de ned type answers implementation language speci cation language remains simply typed 
ect new ect name xed type ects extended de ne extended new constants shift reset types shift reset write syntactic sugar shift reset 
conversely shift hk reset 
informally sk evaluates bound functional representation current evaluation context evaluated empty context 
conversely evaluates empty evaluation context returns result current context 
example writing sequencing explicitly sk kx val val val val general ects give formal semantics continuation passing translation type de ne rst parameterized translation ect ect type constructor jkj isomorphisms 


note contain ects depend simply take isomorphisms identities 
de ne formal monad continuations glue unit ka bind ak easy check determines actual monad interpretation formal monad de ne syntactic translation jj extended clauses specialized control operators kx val val val val operators explicitly terms result translation 
note shift reset operations depend choice answer type 
usual continuation passing translation parametric answer type 
su ciently large type embed type want reify 
particular program chosen nite sum need reify outermost level state base type 
precisely nite nite set types functions val value actual simulation take td allowing de ne realization re ect td val bind glue reify glue val unit val bind unit want show program translations give result 
precisely show speci cation semantics implementation semantics complete programs jej jef gj complete programs show statement simple variation directly induction problem higher types direct equational characterization relationship jej jej general relational invariant give original equation special case 
say relation cpos admissible chain complete upper bounds pointwise related chains related 
write arel set admissible relations de nition logical relation ect language assigns base type relation arel interpretations ect relational action mapping relation arel arel 
map type variables cpos arel 
type de ne relation arel easy check relations admissible 
relations respect interpretations effects constants require 


relation environment arel require related meanings complete programs interpreted observation purposes su ces take relation base types simple equality interprets lifting monad de ne relational action rg note simply equality relation 
cases explicitly construct suitable action proof theorem 
state usual logical relations lemma straightforwardly extended ects polymorphic terms lemma logical relations lemma logical relation list type variables type environments relation environment arel 
type assignment environments dom typed term proof 
straightforward induction note standard interpretations related 
easily seen xed point induction fact admissible contains 
follows de nition 
previously interpreted type constructor cpo constructor de ne type constructor relational action arel arel suppose logical relation semantics language want extend take extended semantics 
need de ne 
intuitively representing computation computation want natural choice computations related continuations mapping related values related results uk related suitable relation pick 
suitable answer take intersection admissible relational interpretations need 
formally lemma relational action de ned ta ka arel 
td uk og extends logical relation semantics proof 
relatively direct veri cation new effect new constants re ect reify fil 
fact lemma interpretations term components related de ne monad theorem simulation related semantics complete program jej jef gj 
proof 
lemmas jej jef result follows assumption relating continuation passing primitive effects consider implementation language essentially scheme sml nj containing rst class continuations state primitive ects 
keep things simple consider state allocated program execution proper begins 
state assignment 
mapping ref cell names types language cs 
contains basic syntax section products sums functions single ect cs constants escape cs cs cs get cs 
set 
cs escape simple variation call cc nable scheme sml nj operators 
usually write get set formal semantics language scheme interpret cs continuation state monad cs 

cs cs 
dom 


note types 
may contain cs annotations 
recursively de ned cpo 
elide associated isomorphisms conciseness 
interpretations operations escape vz get set 
de ne cs print initial store xed element 
add new ect cs shift reset language described section obtain cs 
view continuation passing transform speci cation new language de ne di erent implementation 
see obtain implementation consider interpretation ect kj cs cs 











composite semantics continuation state semantics larger state 
suggests implement cs 
simple embedding cs 
extends 
new cell hold metacontinuation df fil original computation 
formally de ne realization cs 
cs cs con ating previously distinct layers ects reset cs escape 
cs cs ka cs cs shift cs cs escape cs cs reset cs kv cs escape cs cs escape cs cs err ka cs new cell cs err cs error continuation invoked ect type correct program 
realization ensures newly exported escape respects meta continuation shift reset 
signi cant aspect construction eliminates entire layer ects technically con ates layers state passing single layer larger state making vs cs annotation vals lets unnecessary 
formally result rede nition seen principled justi cation practice rede ning call cc available programmer order accommodate implementation dynamic wind scheme ree implicit adaptation callcc throw primitives sml nj save restore exception handlers bcl 
theorem cs simulation complete program cs 
cs 
cs 
jej cs 
ef cs 


cs dom 
proof 
sketched 
proof logical relation semantics cs 
cs cs 
de ne relational actions ects source language ka cs ka ka auxiliary relations intermediate answers arel 


metacontinuation state pairs arel 




state 
arel 




note relations mutually recursively de ned 
existence automatic established fairly easily pitts techniques pit fil 
check directly interpretations constants semantics related corresponding relations result follows lemma 
putting pieces nally obtain main result theorem cs simulation formal monad de ne composite realization cs cs cs td basic language ects standard semantics cs realization cs 
tn denote sequence monads layered previous 
exists store typing 
complete program 
jej tn 
cs 
ef cs gf cs 
cs tn proof 
base case need relate standard lifting semantics continuation rel take 


general theorem follows induction lemma theorems step 
writing composite realization note ects lcs lcs cs coercions lcs lcs 
ect annotations matter purpose program evaluation particular write source programs ml implicit sequencing syntax standard elaboration single ect monadic normal forms 
void void void funfunfun coerce void coerce endendend escape valvalval escape void void endendend structurestructurestructure escape escape funfunfun escape cont callcc fnfnfn coerce fnfnfn cont throw endendend ctrl ans valvalval shift ans ans valvalval reset unit ans ans escape endendend ans structurestructurestructure escape ctrl ans ans ans ans funfunfun fail unexpected control effect valvalval mk ref ans void funfunfun abort mk funfunfun reset escape fnfnfn valvalval mk mk fnfnfn mk abort endendend funfunfun shift escape fnfnfn abort fnfnfn reset fnfnfn coerce funfunfun escape escape fnfnfn valvalval mk mk fnfnfn mk endendend endendend representing continuation passing escapes state representation sml nj suggested development construction applies directly language rst class continuations state scheme sml nj 
show sml syntax parameterized modules represent syntactic realizations 
straightforward encoding construction section 
shows simple implementation universal type required answer embedding lemma alternative implementation terms sml extensible datatype exn exception names possible 
shows implementation monadic proto operations control operators section 
monad component show corresponding operation run formally part construction useful visualization ect layering 
dynamic dynamic dyn valvalval unit dyn dyn endendend structurestructurestructure dynamic dynamic dynamic dyn dyn unit unit funfunfun valvalval ref fnfnfn dyn fnfnfn fnfnfn dyn dynamic endendend endendend universal type state implementation examples applications section show examples programming ects direct style 
rst simply explores ordering exceptions state 
second substantial shows layered monads simulate nondeterministic behavior shared state concurrent program 
exceptions state de nitions exception state monads represent language exceptions layered state familiar ml structurestructurestructure eff structurestructurestructure represent structurestructurestructure exceptions structurestructurestructure structurestructurestructure rex structurestructurestructure structurestructurestructure rex structurestructurestructure represent structurestructurestructure state structurestructurestructure structurestructurestructure rst structurestructurestructure structurestructurestructure rst valvalval run fnfnfn set ok val ok string valvalval run fnfnfn set err ok val string valvalval run fnfnfn set fhandle fnfnfn set err ok fnfnfn int tostring get val err string switch order ect de nition blocks prologue putting state block rst 
running examples gives valvalval run fnfnfn set ok val ok string valvalval run fnfnfn monad valvalval unit valvalval bind valvalval glue unit valvalval show string string endendend structurestructurestructure monad valvalval reflect valvalval reify unit endendend escape valvalval run unit string string endendend structurestructurestructure eff escape funfunfun run endendend represent structurestructurestructure monad structurestructurestructure endendend structurestructurestructure ans dynamic dyn structurestructurestructure structurestructurestructure funfunfun reflect shift fnfnfn bind fnfnfn glue fnfnfn funfunfun reify valvalval dynamic glue fnfnfn bind reset fnfnfn unit unit endendend valvalval escape escape funfunfun run show reify fnfnfn run endendend representing monadic ects continuationpassing set err ok val string valvalval run fnfnfn set fhandle fnfnfn set err ok fnfnfn int tostring get uncaught exception fail unexpected control effect raised ctrl sml computation shows raised exception simply discards current state 
shows happens attempt execute ect ill typed program state ect rst argument fhandle meaningless ordering ects 
consequently translation speci cation says meaning program simulation theorem constrain behavior implementation 
structurestructurestructure exceptions monad res ok exn string unit res funfunfun glue fnfnfn funfunfun unit fnfnfn ok funfunfun bind fnfnfn ok exn exn funfunfun show ok exn endendend structurestructurestructure exceptions valvalval string valvalval fhandle unit string endendend exceptions funfunfun reflect fnfnfn exn funfunfun fhandle reify ok exn endendend structurestructurestructure state monad state int state state funfunfun glue fnfnfn funfunfun unit fnfnfn funfunfun bind fnfnfn valvalval endendend funfunfun show valvalval endendend endendend structurestructurestructure state valvalval get unit int valvalval set int unit endendend funfunfun get reflect fnfnfn funfunfun set reflect fnfnfn endendend structurestructurestructure monad unit list funfunfun glue fnfnfn funfunfun unit fnfnfn funfunfun funfunfun bind fnfnfn fnfnfn funfunfun disp disp disp disp funfunfun show disp endendend simple monads operations shared state concurrency larger example consider monadic approach modeling concurrency sketched mog semantic concept resumptions sch 
strictly speaking example goes language outlined section positive recursively de ned type monad speci cations 
relevant theorem extends easily case 
monad resumptions straightforward unit extension operations 
resumption computation computation yields value representing nal result resumption computation representing remaining computation 
ml representation monad associated operations 
long resumption computations suspend periodically calling yield setup directly simulate parallel operation plo returns true arguments evaluates true false evaluate false diverges cases 
note por constructs resumption computation branches parallel contain parallel subcomputations 
generally model concurrent system collection resumption computations corresponding runnable processes 
scheduler collection single computation repeatedly picking element collection running single step terminated putting back collection 
individual processes communicate shared store contains state ects 
alternatively re ned monad 
req rsp computation suspends produces request type req resumed response type rsp 
setup suitable structure requests responses simple write scheduler matching senders receivers purely functional style 
similar ciency traditional call cc thread package wan system achieves direct relationship usual denotational speci cation 
pursue important aspect concurrency making scheduler pick runnable processes strict round robin fashion choose non deterministically process run step 
layer entire construction atop nondeterminism monad structurestructurestructure eff structurestructurestructure represent structurestructurestructure structurestructurestructure resumptions structurestructurestructure rrs structurestructurestructure structurestructurestructure rrs structurestructurestructure represent structurestructurestructure structurestructurestructure state structurestructurestructure rst structurestructurestructure cell structurestructurestructure rst structurestructurestructure represent structurestructurestructure structurestructurestructure structurestructurestructure rls structurestructurestructure conc structurestructurestructure rr rrs structurestructurestructure rl rls structurestructurestructure shared funfunfun store yield cell set funfunfun fetch yield cell get endendend structurestructurestructure resumptions monad res done susp unit res funfunfun glue fnfnfn funfunfun unit fnfnfn done funfunfun step done step susp susp bind bind fnfnfn step funfunfun disp done disp susp show show disp endendend structurestructurestructure resumptions valvalval yield unit unit valvalval por unit bool unit bool bool endendend resumptions funfunfun yield reflect fnfnfn susp unit funfunfun por funfunfun step done true done true step done false step susp susp step reflect reify reify endendend endendend structurestructurestructure rr resumptions structurestructurestructure rl valvalval par unit unit valvalval atomically unit endendend resumptions funfunfun atomically funfunfun step done susp unit done step susp step true atom step false rr reflect atom rr reify endendend funfunfun par funfunfun step done done done step done susp tb susp bind tb fnfnfn unit step susp ta done susp bind ta fnfnfn unit step susp ta susp tb susp ta tb rl reflect fnfnfn true false step susp step susp rr reflect rr reify rr reify endendend endendend resumption monad associated operations valvalval run fnfnfn conc par fnfnfn shared store fnfnfn shared store shared fetch int tostring shared fetch val valvalval run fnfnfn conc par fnfnfn shared store fnfnfn conc atomically fnfnfn shared store shared fetch int tostring shared fetch val see bracketing part concurrent computation atomic section reduces set possible changes store 
number possible interleavings easily gets astronomical substantial concurrent program simulation perfectly usable exhaustively testing individual fragments mutual exclusion protocols 
re nements possible 
example layering data monad int resumptions model thread speci data running computation perform equivalent getpid call obtain thread unique identi er 
provide thread local exceptions global ones aborting entire concurrent system 
add output monad tracing inspect nondeterministic paths exception raised 
related large number proposals layering ects structuring denotational semantics mog esp functional programs kw ste 
generally approaches pursue modularity multi ect language explicit ect typing system 
accordingly central problem frameworks concerns de ning various ect operations way lift ects may 
speci ects ad hoc solutions exist operations involve rei cation behavior exception handling admit general solution 
approach ambitious basic translation derived framework exposes layering explicitly ect types proto operations 
con icts automatically resolvable ect subsumption exposed programmer typing restrictions go simple typability akin keeping track function ects java desired semantics explicitly encoded de nitions programmer visible operations 
course existing results lifting speci operations particular monads 
di erence executable speci cations monad constructors construct full compound monad explicitly implicitly actual evaluation programs usually substantial cost 
strong distinction simple ine cient speci cation cient especially multiple layers easily analyzable implementation care agree meanings complete programs 
second line related concerns implementation various computational paradigms control operators directly involving monads 
examples include uses basic call cc thread packages wan imperative backtracking hdm simple composable control df nondeterminism basic effects number proposals hierarchical control df sf grr represent general layered ects 
operational de nitions control operators terms actions evaluation contexts include sample implementations terms scheme primitives 
take minimalist approach view control operators explicitly exposed programming abstraction right means implementing monadic speci cation 
course surprisingly rarely natural description computational ect fact terms continuations monadic framework encompasses simply instance 
frees constraint de ning general purpose control mechanism intuitive operational behavior allows provide lean mean implementation formally analyzed 
practically compelling monad framework ects needs minimize overhead conceptual computational 
address concern basing speci cation intuitively familiar concept definitional translation explaining away ect cient implementation keeps execution cost roughly native levels long ect invoking ect delimiting operations comparatively rare case functional programs 
words aim steer clear extremes hand speci cation implementation resulting executing monad speci cation exceptions literally hand implementation speci cation resulting particular imperative implementation thread package guide specifying interactions ects 
propose paradigm monadic re ection uniformly relate layered declarative speci cation ect tower ultimate imperative implementation terms low level primitives 
implementation nominally complete operational sense viewed proof concept prototype nal solution 
construction establishes availability call cc support compiler runtime system needed ciently implement layered ects 
mean support undesirable 
particular type system enforcing ect restrictions statically big help constructing large programs 
practical probably need largely minimal explicit annotations include support notion ect polymorphism 
semantic side re nements possible 
particular possible extend formal simulation result ect recursive monads new ect de ned implicitly speci cation higher order state store procedures state ects 
allow uniform treatment continuation monads non base answer types 
worth investigating results simulating linear hierarchy extended general orders 
acknowledgments author indebted olivier danvy number perceptive comments popl reviewers uenced earlier versions 
bcl ken cline peter lee chris okasaki chris stone 
safe space threads standard ml 
higher order symbolic computation 
cf robert cartwright matthias felleisen 
extensible denotational language speci cations 
hagiya john mitchell editors symposium theoretical aspects computer software number lecture notes computer science pages sendai japan april 
df olivier danvy andrzej filinski 
abstracting control 
proceedings acm conference lisp functional programming pages nice france june 
df olivier danvy andrzej filinski 
representing control study cps transformation 
mathematical structures computer science december 
esp david espinosa 
semantic lego 
phd thesis graduate school arts sciences columbia university may 
fil andrzej filinski 
representing monads 
proceedings st acm sigplan sigact symposium principles programming languages pages portland oregon january 
fil andrzej filinski 
controlling ects 
phd thesis school computer science carnegie mellon university may 
technical report cmu cs 
cormac flanagan amr sabry bruce duba matthias felleisen 
essence compiling continuations 
proceedings sigplan conference programming language design implementation 
matthias felleisen mitchell wand daniel friedman bruce duba 
continuations mathematical semantics handling full functional jumps 
proceedings acm conference lisp functional programming pages snowbird utah july 
grr carl gunter didier emy jon riecke 
generalization exceptions control ml languages 
functional programming computer architecture pages 
hd john olivier danvy 
generic account continuation passing styles 
proceedings st acm sigplan sigact symposium principles programming languages pages portland oregon january 
hdm robert harper bruce duba david macqueen 
typing rst class continuations ml 
journal functional programming october 
preliminary version appeared proceedings symposium principles programming languages 
richard kelsey william clinger jonathan rees editors 
revised report algorithmic language scheme 
higher order symbolic computation 
appears acm sigplan notices september 
kw david king philip wadler 
combining monads 
launchbury sansom editors functional programming glasgow pages ayr scotland 
springer verlag 
sheng liang paul hudak mark jones 
monad transformers modular interpreters 
proceedings nd acm sigplan sigact symposium principles programming languages pages san francisco california january 
john launchbury simon peyton jones 
state haskell 
lisp symbolic computation december 
ml saunders mac lane 
categories working mathematician volume graduate texts mathematics 
springer verlag 
mog eugenio moggi 
computational lambda calculus monads 
proceedings fourth annual symposium logic computer science pages paci grove california june 
ieee 
mog eugenio moggi 
view programming languages 
technical report ecs lfcs laboratory foundations computer science university edinburgh edinburgh scotland april 
robin milner mads tofte robert harper david macqueen 
de nition standard ml 
mit press revised edition 
mw albert meyer mitchell wand 
continuation semantics typed lambda calculi summary 
rohit parikh editor logics programs proceedings number lecture notes computer science pages brooklyn june 
pit andrew pitts 
relational properties domains 
information computation june 
plo gordon plotkin 
lcf considered programming language 
theoretical computer science december 
pw simon peyton jones philip wadler 
imperative functional programming 
proceedings twentieth annual acm symposium principles programming languages pages charleston south carolina january 
ree jonathan rees 
scheme things june meeting 
lisp pointers 
rey john reynolds 
relation direct continuation semantics 
jacques editor nd colloquium automata languages programming number lecture notes computer science pages saarbr west germany july 
sch david schmidt 
denotational semantics methodology language development 
allyn bacon 
sf dorai sitaram matthias felleisen 
control delimiters hierarchies 
lisp symbolic computation january 
ste guy steele jr building interpreters composing monads 
proceedings st acm sigplan sigact symposium principles programming languages pages portland oregon january 
tol andrew tolmach 
optimizing ml hierarchy monadic types 
xavier leroy atsushi ohori editors types compilation second international workshop number lecture notes computer science pages kyoto japan march 
wad philip wadler 
essence functional programming invited talk 
proceedings nineteenth annual acm symposium principles programming languages pages albuquerque new mexico january 
wad philip wadler 
marriage ects monads 
international conference functional programming 
wan mitchell wand 
continuation multiprocessing 
conference record lisp conference pages stanford california august 
