foundations temporal query languages david toman mgr university brno czech republic dissertation submitted partial fulfillment requirements degree doctor philosophy department computing information sciences college engineering kansas state university manhattan kansas approved dr jan chomicki major professor temporal databases repositories information dependent time 
major difference standard relational database systems need storing possibly infinite objects time spans 
years numerous proposals introduce time standard relational systems 
unfortunately attempts ad hoc extensions existing database systems query languages tquel tsql 
extensions create problems precise semantics needs developed exists 
survey chomicki clean way defining temporal databases logic proposed 
methodology views temporal databases multi sorted finitely representable order structures 
query languages formulas suitable logics vocabulary structures 
method quite successful existing proposals subsumed approach minor adjustments special cases 
dissertation try address issues connected approach development temporal databases ffl current implementations temporal databases seemingly natural restriction structure relations imposed relations stored database exactly bounded number attributes represent time tsql tquel 
restriction naturally corresponds single dimensional modeling time 
raises obvious question generality solution 
show order case imposing discipline query language affects expressive power rules interesting queries database 
ffl store handle infinite objects time spans 
idea generalized databases encode infinite objects formulas appropriate logic 
generalize common requirements encodings suitable query evaluation 
propose new class infinite objects periodic sets efficient procedures allow deductive queries evaluated objects 
ffl efficiently evaluate queries encodings 
propose new query evaluation procedure combination resolution method proposed logic programs fixed point computation deductive query evaluation 
theoretical complexity bounds experimental measurements show performance gains achieved method 
contents contents list figures iii temporal databases 
overview contributions 
expressive power order query languages 
querying finite encodings infinite objects 
organization dissertation 
background databases order structures 
temporal databases 
temporal databases order structures 
temporal query languages 
complexity query evaluation 
expressive power 
order query languages temporal databases 
ehrenfeucht fraiss games 
ehrenfeucht fraiss game temporal logic 
structures indistinguishable fotl formulas 
time domain set 
time domain dense linear order 
additional results 
separation fotl fotl 
expressive incompleteness dimensional fotl 
temporal relational algebras 
ordered data domain 
fixed data domain 
maximal expressive power fotl 

related 
constraint databases 
constraint classes 
closed form bottom evaluation 
classes constraints disjoint domains 
order queries negation 

related 
constraint classes integers 
periodicity graphs 
datalog periodicity constraints 
complexity bottom evaluation datalog jz 
combining classes constraints integers 
gap order constraints 
complexity consistency checking 
bottom evaluation 
equality constraints 

related 
constraint classes constraint classes 
interpretation 
formalisms 
evaluation methods 
goal oriented evaluation strategies 
top evaluation datalog 
optimizations 
magic set transformation mst 
performance 
theory 
implementation 
experimental results 

related 
bibliography ii list figures dependencies chapters dissertation 
temporal databases order structures 
restriction scopes individual temporal variables 
round game compatibility individual temporal moves 
interpretation structures 
round game temporal logic 
dense function gamma 
fa 
constraints order query evaluation 
example datalog query uses integer constraints essential way 
datalog jz program unrestricted number modulo factors 
consistency checking conjunctions simple periodicity gap constraints 
pseudocode algorithm 
summary constraint classes query evaluation 
application constraint queries interpretation 
slg evaluation goal constraint 
annotated slg evaluation query tc 
test programs 
semi naive bottom evaluation algorithm 
structure experimental system 
running times test queries various evaluation procedures msec 
datalog element chain tc chain 
datalog gap order constraints element chain path iii jan chomicki major professor support encouragement half years studies 
support able come kansas phd 
studies invaluable technical insights taught important part doing research write research papers 
prof damian teaching basics finite model theory continuous interest temporal logic culminated joint chapter dissertation prof peter revesz valuable discussions help encouragement area constraint databases 
go people kansas state stay enjoyable professionally personally olivier danvy rod howell mizuno dave schmidt allen stoughton george strecker brian howard sergey anindya banerjee christian adrian taylor helped necessary certainly lost nice people met studies 
jason dale cindy liu niblett proofreading parts dissertation helping improve approximation english 
people back czechoslovakia nowadays czech republic slovakia especially parents patience professors teaching lots math computer science theory helped tremendously studies research 
iv chapter representing storing manipulating time dependent data focus active research years 
approaches evolved ad hoc extensions existing database systems sophisticated systematic studies fundamental properties temporal databases repositories time dependent data 
main difference standard database theory temporal databases required store encodings infinite objects time spans possibly infinite sets time instants 
development appropriate storage techniques new languages querying manipulating data encodings developed 
temporal databases systematic approach studying temporal databases proposed 
approach viewing temporal databases precise mathematical objects order structures properties rigorously studied tools model theory 
contrast classical model theory area databases main focus lies finite finitely representable structures 
approach raises important questions answered implementations temporal databases 
precise specification temporal databases needs questions answered answer questions relevant technical development dissertation complete discussion domains individual sorts data stored database 
precise description database mathematical object requires description data plan store database strings numbers conveniently achieved order structure domain particular data type storable objects 
structure provides built relations defined data objects equality linear order arithmetic example classical theory relational databases simplest incarnation uses set uninterpreted constants equipped equality names elements underlying domain objects storable database 
legal queries combinations questions equality components individual tuples stored database constants 
case temporal databases need domain data domain represents time instants representing time equality relation constants longer sufficient 
modeling time instants need model progression time temporal ontology 
goal conveniently achieved ordering time instants 
choices particular ordering depending structure time try model 
considering bounded unbounded time time 

discrete dense model time time instant successor instant comparable instants 

time ordered linearly single time line 
branching alternative time lines 
branching alternative futures 
dissertation consider linearly ordered unbounded time domains 
choose familiar number structures linearly ordered integers discrete time linearly ordered rationals dense time domains advantage choosing familiar number domain modeling time general domains lies studied properties number structures 
note time domains inherently infinite necessarily countably infinite 
side effect constant symbol element domain constants important time points 
chapters introduce richer structures modeling time structures equipped gap order relations congruence relations 
signature user defined relations 
choice underlying order structures fixes objects handled database 
capture relationships objects need set user defined relations called tables world relational databases 
relations encodings computer storage actual data stored database predetermined meaning order equality 
temporal databases designed store relationships time instants data objects elements data domain 
user defined relations need sorted approaches enforce sort type discipline introduce built relations chapters 
consider temporal databases sorted order structures sort represents data objects models time instants 
extension framework sorts straightforward cf 
section 

common approach chosen virtually implementations temporal database management system dbms user defined relations varying arity data sort exactly distinguished attribute temporal sort 
clear underlying semantic interpretation arrangement express fact related time simply say element tuple distinguished temporal attribute 
choice viewed uniform extension standard database schema adding distinguished attribute time sort relation 

choice varying arity relations sorts unrestricted database schema 
choice natural interpretation 
gain greater flexibility approach 
chapter see choice preferable facilitates desirable properties query languages 
finite encodings temporal databases 
far defined temporal databases sorted order structures equipped built relations sorts equality order user defined relations conforming particular sort discipline 
impose restrictions size user defined relations structures obviously problem implementation point view current computers store finite amounts information 
store possible instances structures defined previous paragraph provided chosen non trivial domains 
major approaches problem 
allow storage structures user defined relations finite approach taken virtually relational systems 
store finite encodings subclass structures appropriate query languages 
described way precise description temporal database view sorted structure appropriate sorts extended finite set user defined relations finitely encoded 
effort worthwhile need define tools allow asking questions contents temporal database data stored user defined relations 
capitalize definition temporal database queries simply functions class temporal databases thought order structures 
language logic vocabulary vocabulary structures representing temporal database query language 
queries defined formulas answer query simply relation consisting tuples valuations particular formula true temporal database built relations usually infinite need worry interpretation fixed need stored database provided algorithm membership testing 
clearly finitely encode structures cardinality reasons 
order structure 
answers queries viewed temporal databases particular choice appropriate logic depends required expressive power required efficiency 
logics explore dissertation 
single sorted order temporal logic cf 
chapter 
sorted order logic cf 
chapters 
datalog universal horn clauses fixpoint semantics chapters 
informally described fragment framework temporal database theory dissertation 
addition chosen domains representing data objects time instants shapes user defined relations finite encodings query languages fit formally properties satisfied choices faithfulness encoding 
advantage choosing logic query language temporal databases clear semantics easy way declarative formulation queries drawback choice semantics queries defined structures finite encodings 
sure evaluation query computer program derived formula preserves meaning query evaluated formula logic respect temporal database 
closure 
view queries maps class temporal databases 
second natural requirement answer query representable database consisting relation holding answer appropriate finite encoding answer 
particular implies queries algorithms produce answer finite time finite encodings relations valid answers 
note dealing large amounts data implementation query evaluation algorithm may need store final result query intermediate results produced query evaluation represent answers subformulas original query 
possible query language subquery closed subqueries queries 
genericity 
generic queries defined queries invariant respect permutation constants 
definition intended prevent queries answer depends particular way storing constants representation numbers strings computer storage 
framework generalize notion follows require different encodings encode temporal database answers generic query evaluated respect encodings encode answer 
note case encoding simply embedding relational systems generalized notion genericity equivalent original notion 
provided user sufficiently mathematically sophisticated 
overview contributions goal dissertation address issues connected design implementation temporal databases databases allow represent store encodings infinite objects 
expressive power order query languages part dissertation addresses choice allowed types userdefined relations 
show restricting number temporal attributes fixed number common virtually current implementations temporal databases major drawback closed language express firstorder queries 
result resolves negatively long open problem existence expressively complete set connectives order temporal logic linear orders 
means order complete relational algebra cf 
chapter properly implements order queries restricted schema 
querying finite encodings infinite objects light result concentrate schema unrestricted finite representations infinite relations representing temporal contents database 
formulas logic constraints basis finite encodings potentially infinite user defined relations 
contributions part dissertation follows 
define properties need satisfied finite representation infinite relations guarantee correct evaluation queries representation 
show composition disjoint domains causes additional problems 

introduce new class finitely representable structures integers allows manipulation infinite periodic sets operations needed deductive query evaluation 
study termination complexity query evaluation class temporal databases 

develop efficient method evaluating deductive queries finite representations 
support suitability query evaluation algorithm theoretical complexity results benchmarks experimental implementation proposed method 
organization dissertation dissertation organized follows chapter introduces precise definitions concepts informally introduced chapter needed technical development 
chapter shows result separation sorted firstorder logic order temporal logic arbitrary finite set connectives dense linear orders 
result implies enforcement sort restriction database schema shapes user defined relations closure order query language respect schema rules large class order queries dependencies chapters dissertation 
temporal database 
propose unrestricted database schema avoid penalty 
chapter presents general methodology finite representation infinite temporal relations 
chapter introduces new class finitely representable structures integers operations finite representation needed query evaluation 
studies complexity query evaluation 
chapter presents list known finitely representable classes briefly discusses properties 
chapter introduces efficient query evaluation strategy studies properties 
thorough comparison existing methods carried theoretically experimentally 
chapter concludes dissertation possibilities directions research 
chapter starts brief overview concepts goals concluded discussion relevant brief bibliography 
shows logical dependencies individual chapters dissertation 
chapter background chapter introduce necessary theoretical foundations temporal databases extension standard relational database theory 
introduce concepts needed technical development 
databases order structures define database class possible databases want consider mathematical object need answer questions 
values stored database 

values stored storing values particular way mean 

stored values 
question answered definitions standard relational systems case temporal databases extension approach definition data domain order structure countable carrier jdj equipped equality constant symbol element carrier jdj 
call data domain domain uninterpreted constants 
note constant symbols equally represented unary relations containing exactly element 
example typical examples data domains 
natural numbers probably common choice objects stored manipulated database system ultimately encoded binary numbers computer storage 

set strings finite alphabet 
common choice 
way conveniently represent usual objects stored database names addresses note strings thought numbers digits finite alphabet strings 
relation defined sets equality diagonal relation 
choice data domain setting crucial countably infinite structures equality equivalent isomorphism 
answer second question complicated sufficient store elements data domain database trying capture relationships values values different approaches developed address problem called database models 
dissertation relational approach relationships individual values captured tuples stored user defined relations sets tuples 
contents encoding contents relations stored database written permanent storage 
important decision shape relational type user defined relations allowed arities multi sorted case types components individual tuples 
consider definitions relational case definition database schema countable set predicate symbols finite arities 
database schema finite subset ae set allowed user defined relation names relational types domains allowed values individual attributes tuples stored relation named particular predicate symbol 
choice determines shapes individual user defined relations 
case relational databases assume contains possible predicate symbols arities pick ones want database schema 
definition instance database schema ae database schema data domain 
instance database schema ae finite set relations jdj arity finite instance database schema ae instance jr finite definition relational database data domain ae database schema instance ae structure extended fr relational database domain schema ae 
define class relational databases class extensions instance database schema ae finite ae call elements data domain uninterpreted constants 
class finite relational databases class extensions finite instance database schema ae finite ae difference standard relational theory fix underlying domains advance choice eliminates problems closed world vs open world assumptions need active domains see choice influences structure databases shapes user defined relations example set unary binary predicate symbols 
relations database unary binary 
class relational databases define query languages order logic definition relational calculus predicate symbols 
arity give natural tarskian semantics formulas relational calculus definition semantics calculus db relational database schema ae formula relational calculus valuation assignment values variable names 
define db induction structure db arity ae arity db atomic db db db db db case db db jdj db db interpretation predicate symbol database db 
answer query database db set tuples answer relation jf db jf restriction valuation free variables formula 
note queries thought functions mapping input database output database contains just answer relation query 
usual way implementing query evaluation algorithm relational database management systems translating calculus queries relational algebra evaluating resulting algebraic terms having relatively simple algorithm elementary algebra operation 
define algebra need define universe operations universe case universe contains possible user defined relations extents predicate symbols valid concerns 
orthogonal topics dissertation 
definition order definable algebra data domain set allowed relational types 
universe order definable algebra set fr jdj arity rg relational type define subset relations type universe fr jdj arity type function ary order definable relational operator type relational calculus formula database schema ae 
free variables relational type relation fv type 
relational type 
instance ae 
safe relational operator maps finite instances ae finite relations defined safe relational calculus formula 
order definable algebra set relational operators bounded arity defined order formulas bounded quantifier depth 
ae database schema gamma order definable algebra 
algebraic query form defined rules 

gamma algebraic queries 
answer algebraic query schema ae database relation defined inductively structure main intuition definition relational algebra follows try define generic operations relations efficient algorithms 
evaluate queries terms operations composites functions defined operators 
example algebra standard relational algebra defined follows single sorted case arities predicate symbols relations relational types 
allow multi sorted relations define algebra operations respect types relations respect arities 
example relational algebra data domain class relations finite arity define operators product theta defined schema formula 
projection gamma defined schema formula selection oe defined schema formula quantifier free order formula language union defined schema formula 
set difference gamma defined schema formula 
relational types determined uniquely relation arities case fact definition relational algebra 
note arity operators bounded quantifier depth defining formulas family operators forms relational algebra 
easy verify operators safe 
define operator schema defined formula 
clearly order definable operator 
easy see operator safe data domain infinite 
note restriction definition operators quite natural general need infinite family operators 
example thought finite set operators polymorphic arities relations quantifier depth defining formulas arities operators bounded 
correctness evaluating calculus queries translation algebra shown proposition true selection finitely quantifier free formulas arity logical equivalence 
proposition languages express queries relational databases 
relational algebra theta oe relational calculus 
safe relational algebra theta oe gamma safe relational calculus 
temporal databases generalize methodology temporal databases essentially steps 
choice domains ffl data domain data domain single sorted case cf 
definition 
ffl temporal domain similarly choose order structure model time class temporal databases elements domain serve representation time instants relations defined structure determine relationships individual time instants time ontology 
usually require order relation defined temporal domain 
common choices temporal domain linearly ordered integers modeling discrete unbounded time rationals model dense time 

choice allowed relational types user defined relations ffl uniform temporal relations common choice 
relations required exactly temporal attribute fixed number attributes 
corresponds relational types theta stands temporal sort data sort 
ffl temporal relations varying temporal arity unrestricted relational types relax uniformity requirement allow relational types theta 
note case unrestricted schema consider predicate symbols arbitrary relational types theta theta permute attributes relations obtain relation sort theta temporal databases order structures case temporal databases distinguish order structures finite encodings 
distinction necessary case relational databases finite encodings just finite structures formed proper subclass possible relational databases 
avoid restriction finite structures distinguish class temporal databases temporal databases class finite encodings concrete temporal databases class temporal databases defined analogously class relational databases simply add temporal domain models time choose appropriate types user defined relations definition temporal database data domain temporal domain ae database schema 
db fr temporal database instance ae class temporal databases note ae contain predicate symbols allowed relational types theta case uniform schema theta 
definition concrete temporal database countable set meaning function 
class concrete temporal databases class 
definition captures idea set codes individual temporal databases interested function captures meaning individual codes 
store individual codes number sufficiently large computer storage 
particular classes concrete temporal databases defined various ways ffl store finite structures approach taken rdbms 
encodings structures meaning function simple embedding 
ffl finitely encode interesting classes infinite structures constraint databases codes formulas order logic meaning function satisfying valuations function 
disadvantage solution sets time instants storable database finite means case dense time allowed sets singletons finite unions 
may sufficient representing temporal databases 
consider examples example interval representation currently common approach encodings infinite temporal databases linearly ordered temporal domain encode possibly infinite intervals temporal domain endpoints elements jt gamma assuming jt countable 
meaning function uniform extension mapping pairs 
ft bg identity structure temporal database 
note data domain mapped identity mapping relational case userdefined relations finite time instant 
temporal databases images concrete temporal databases concrete temporal databases eval eval ke ke concrete temporal databases represent temporal database temporal databases order structures shows example query evaluated interval representation temporal databases 
clearly intervals represented quantifier free formulas language temporal domain represented formula generalize idea general way representing sets time instants quantifier free characteristic formulas example representation constraints language temporal domain 
denote subset quantifier free formulas class sorted finite relational databases sorts 
consider databases finite encodings temporal databases meaning function identity 
jf mapping formulas sets tuples mapping uniformly extended meaning mapping concrete databases databases 
temporal query languages definition class temporal databases allows immediate query languages logic dissertation consider formalisms 
temporal logic modal extension single sorted relational calculus cf 
chapter 
relational calculus algebra easily extended single sorted relational databases sorted multi sorted general case temporal databases cf 
chapter 
deductive queries temporal databases cf 
chapters 
meaning query languages defined respect temporal databases need provide conditions allow answer queries query evaluation algorithm works class concrete temporal databases definition query evaluation algorithm class concrete temporal databases query language 
query evaluation algorithm recursive function eval relationship encoding query evaluation algorithm eval captured definitions definition closure encoding temporal databases query language temporal databases 
closed respect concrete temporal database kd concrete database definition identify subclass query language results queries finitely represented 
analogous definition safe relational calculus queries case finite relational databases 
case general definition depends chosen class finite encodings concrete temporal databases 
closure sufficient need effective way evaluating queries finite encodings preserves meaning queries definition faithful encoding encoding temporal databases eval query evaluation algorithm encodings 
faithful encoding temporal databases respect eval eval concrete temporal databases queries temporal databases query language closed respect faithfulness property guarantees semantics queries preserved query evaluation algorithm eval 
property guarantees temporal database encoded different ways injective queries evaluated different encodings database yield results modulo encoding definition generic queries encoding temporal databases query class concrete databases 
say generic respect kd kd oe clearly queries satisfy condition expressed queries temporal databases generic queries correspond queries temporal databases 
proposition similar proposition 
allow implement order temporal queries translating temporal relational algebra see chapter 
easy see proposition extended case temporal databases relations varying temporal arity chapter show correspondence breaks uniform temporal databases 
complexity query evaluation important property query evaluation algorithms complexity difficult answer queries need study complexity query evaluation algorithm eval 
note complexity closely tied chosen query language class concrete databases finite encodings 
different approaches measuring complexity queries introduced definition data complexity closed query language arbitrary concrete database 
query evaluation algorithm eval data complexity query execution eval takes steps concrete database size rationale choice size database usually bigger size representation query 
complexity query evaluation defined function size database ignoring size query stronger result obtained definition combined complexity closed query language arbitrary concrete database 
query evaluation algorithm eval combined complexity execution eval takes steps concrete database size query number symbols standard complexity eval algorithm respect size inputs 
precisely study complexity possible fixed query function size concrete database 
bibliographical notes relational model introduced computer science including proposition 
concepts earlier tarski 
standard relational database theory various textbooks brand new book crisp mathematically precise definitions 
concepts classical order logic model theory 
concepts virtually book mathematical logic 
algebras capturing order logic 
thorough discussion application methods temporal databases survey temporal databases query languages 
chapter expressive power queries temporal databases involve time 
study differences approaches including order query language relational calculus explicit typed variables quantifiers vs implicit finite set modal connectives 
show approach order query language implicit time appealing simplicity ease express queries expressible general 
result settles longstanding open problem expressive power order temporal logic 
consequence result order complete query language subquery closed respect uniform database schema temporal relational algebra uniform relations evaluate order definable queries 
years various languages querying temporal databases proposed literature 
order query languages divided main categories 
query languages sorted version relational calculus tsql tquel 
query languages extension relational calculus algebra temporal operators historical relational algebra temporal relational algebra approaches considered equivalent expressive power temporal relational algebra extension relational calculus temporal operators proposed basis order completeness temporal query languages 
assumption known property propositional temporal logic proposition kamp theorem propositional temporal logic expressively complete set temporal connectives linear orders 
means propositional temporal logic expressive power monadic order logic linear orders 
result established kamp complete linear orders extended linear orders times various proof techniques 
section show correspondence generalize relationship order temporal logic fotl sorted order logic fol query languages fol strictly expressive languages fotl finite set temporal connectives defined dense linear order 
show fotl express large class queries involve time instants equality database relations different time instants 
result interpreted temporal query languages simultaneously subquery closed order complete 
result strong implications design temporal query languages essentially subquery closed relational algebra languages incomplete complete relational calculus languages preserve closure 
problem implementation point view subquery closed query languages easier implement essentially intermediate results bottom query evaluation structure database relations order queries formulated languages 
despite drawback fotl basis temporal query languages specification temporal integrity constraints 
main reason choice simpler efficient implementation generalize full fotl 
design expressively complete temporal relational algebra requires unbounded number temporal attributes relations guarantee completeness preserve closure products 
solution allow store intermediate results needed evaluate query uniform temporal database auxiliary relations 
addition separation fotl fol show results especially 
expressive equivalence temporal logic full temporal logic past temporal connectives generalize firstorder case 

expressive completeness achieved general temporal logic dimensional order temporal logic 
note restrict attention solely order languages 
higherorder properties property relations cardinality expressible fol fotl 
assuming closure respect database schema temporal relations including derived ones exactly temporal attribute general bounded number attributes 
natural requirement imposed virtually practical temporal databases timestamp relations tsql tquel 
rest chapter organized follows section introduces formal definition temporal database order temporal query languages databases 
sections introduce model theoretic games allow study expressive power fotl 
section games show main result fol section shows non expressibility results established games 
section chapter summarize obtained results conclude directions research 
order query languages temporal databases show separation order languages need fix class structures languages defined 
approach previous chapter slightly general form temporal structures considered section built basic building blocks 
order signature hae ae class order structures ht ae ae single structure class serve temporal domain 

order signature hp class order structures hd single structure serves data domain database 

single sorted set predicate symbols hr arity symbol choice defines database schema temporal database 
arrangement abstracts particular choice data temporal domains allows wide range applications proposed method 
rest chapter fl denote signature hae ae temporal domain ffi signature hp data domain oe signature hr database schema 
temporal databases considered chapter uniform extensions single sorted database schema ae single distinguished temporal attribute definition uniform temporal database ht ae ae temporal domain signature fl hd data domain signature ffi oe hr database schema 
define sorted relation symbols sort theta database schema oe 
call uniform temporal extension temporal signature hae ae rm sorted signature composed fl ffi temporal extensions symbols oe 
define temporal database sorted structure ht ae ae sets finite extensions define interpretation symbols database schema element time domain formally holds time iff ae denotes proper 
oe note interpretations predicate symbols connected solely temporal domain data domain fixed interpretation symbols depends actual contents database 
example hq temporal domain dense linearly ordered rationals hd data domain ae database schema consisting single binary relation ae holding employee ids salaries 
temporal structure representing temporal database defined db hq fact salary time encoded salary holds time db db salary note relations fixed meanings domains linear order diagonal hand interpretation relation salary depends actual contents database 
relation salary infinite general sets salary finite fixed choice order query language extension straightforward obviously sorted relational calculus equivalently sorted order logic fol express queries structures 
disadvantage solution refers augmented database schema original schema 
time explicit variables quantification time domain 
elegant solution order temporal logic fotl order logic augmented finite set temporal connectives past 
solution preferable reasons refers original database schema extended schema 
main advantage solution time properties underlying temporal domain encapsulated inside temporal connectives added language time implicit define query languages uniform temporal databases represented structures definition 
sorted order logic language 
order temporal logic language definition language straightforward extension definition 
variables sort variables sort definition fl signature temporal domain ffi signature data domain 
sorted fol language fl ffi database schema oe defined bnf rule ae temporal extension oe ae fl ffi semantics formulas language standard order tarskian semantics cf 
definition 
note database schema monadic respect sort predicate symbols database schema exactly distinguished argument sort preserve closure query language restrict set valid queries formulas exactly free variable sort result query stored temporal database cf 
definition 
easy see closure achieved artificially formulas valid queries 
subformulas valid query may valid queries 
example consider formula formula defines query find intervals contains exactly values ends intervals 
clearly valid query 
subformula valid query contains free variables sort section show formula property subformulas valid queries expresses original query 
definition second query language need careful 
language defined steps temporal connectives defined 
note definition temporal connectives independent data domain database schema 
definition temporal connectives purely syntactical depends chosen temporal domain 
semantics connectives defined translation fol cf 
definition 
approach differs usual definition connectives intended semantics uses truth tables 
definition temporal connective fl signature temporal domain ae predicate variables ae fl 
ary temporal connective fl formula exactly free variable free predicate variables denote connective omega gamma fl denote finite set names temporal connectives fl 
superscripts denote explicitly temporal contexts appropriate subformulas temporal connective 
definition quantification temporal connective omega gamma fl form ae ae restricted temporal connective 
example express usual temporal connectives temporal signature linear orders follows similarly express past temporal connectives note connectives restricted connectives restricted 
call temporal logics restricted restricted temporal connectives fotl past fotl respectively 
second step definition temporal extension language order logic straightforward augment syntax fol signatures data domain database schema finite set temporal connectives definition omega gamma fl finite set temporal connectives fl ffi signature data domain 
order temporal logic language omega gamma fl ffi database schema oe defined bnf rule oe ffi omega gamma fl 
rest chapter place fl ffi omega gamma fl ffi respectively 
definition say propositional temporal logic ptl relations database schema oe ary 
easy see formulas naturally embedded language formulas 
embedding defines semantics formulas relatively semantics definition embedding embed mapping formulas language omega gamma fl ffi language fl ffi defined follows embed embed embed embed embed embed embed embed embed embed 
embed embed formula denoted omega gamma fl substitution development assume formulas merely restricted formulas translation formulas yields valid fol query embed free variable sort translation formulas preserves closure query language 
note translation subformula original formula property 
obviously true subformulas arbitrary formula original formula valid query cf 
example 
example temporal database example formulate queries fol fotl personal id salary negative fotl salary fol salary personal id salary decreased fotl salary salary fol salary salary example illustrates fotl easier fol fotl introduce variables time encapsulated temporal connectives 
easy see essential difference full fol language temporal extension order logic subformulas formula associated exactly temporal context represented variable translation context changed temporal connective 
distinction comes play temporal connectives merely quantifiers sort quantifiers sort interleaved single formula 
quite clear structures distinguishable formula distinguishable formula embed 
structures distinguishable formula may distinguishable formula 
section find concrete examples structures distinguishable formula distinguishable formula 
ehrenfeucht fraiss games show separation technique originally developed capture expressive power order logic ehrenfeucht fraiss games 
games provide complete combinatorial characterization order definable properties main result summarized order structures distinguished order formula structures distinguished ehrenfeucht fraiss games prove structures equivalent indistinguishable respect games know order formula true structures false 
idea formal consider definitions definition ehrenfeucht fraiss game order logic order structures signature 
round ehrenfeucht fraiss game length sequence moves form 
player picks element carrier 
player ii picks element carrier remaining structure 
pairs chosen elements say player ii wins round game mapping defined 
partial isomorphism structures say player ii winning strategy player ii win round game length notation winning strategy player ii defines equivalence relation order structures 
write player ii winning strategy rounds ehrenfeucht fraiss game length proposition ehrenfeucht order structures signature 
iff set order sentences nested quantifiers cf 
definition 
proposition gives method showing order non definability properties subclasses order structures corollary property order structures signature pairs structures 
show order definable property sufficient show 


example characterization linear orders technique show known characterization finite linear orders lm finite linear order length lm iff gamma show direction lm trivially 
gamma 
winning strategy player ii 
player plays element gamma gamma elements lm player ii answers corresponding element distance left endpoint 

similarly player plays element gamma gamma elements lm player ii answers corresponding element 
player ii plays arbitrary element distance endpoints gamma similarly player picks element player ii uses symmetric strategy choose element lm move splits original linear orders parts elements bigger smaller elements just played 
clearly jl jl gamma gamma jl jl similarly 
gamma gamma result follows induction complete proof 
particular show formula true contains number tuples false clearly express query need order formula distinguishes gamma 
possible characterization finite linear orders cf 
example 
ehrenfeucht fraiss game temporal logic situation slightly complicated try separate fotl order logic try show fol formulas define properties definable fotl 
rules game modified match exactly syntactic restrictions placed temporal formulas definitions 
modification captures precisely expressive power fotl 
definition closed formula free variable formula embed 
define partial order oe variables embed follows oe embed oe subformula subformula embed assuming quantified variables unique names different clearly formulas form embed variables appear arguments single atomic subformula leaf syntactic tree embed follow certain pattern 
pattern defined terms compatibility individual variables 
translation scope scope diagram graphical representation scopes individual variables sort easily see scope variable subformula rooted fol formula 
scope extends point temporal connective represented shaded area encountered 
body connective expansion definition subformula rooted connective 
restriction scopes individual temporal variables 
easy way thinking compatibility variables considering scopes variables defined expansion temporal connectives restrictions imposed scopes individual variable names formula embed depicted follows example shows restrictions scopes individual variables translation embed fotl formula 
general variables appear arguments atomic formula scopes intersect note restriction impact pairs variables sort natural restrictions connected solely sort lemma shows variables compatible respect temporal formula variables appear arguments atomic formula 
lemma closed formula atomic subformula embed variables arguments parts syntactic tree formula variable question legally appear 
sort sort oe maximal set fv sort oe sort oe sort oe oe maximal set fv sort sort oe oe induction structure embed 
lemma define winning condition game temporal logic 
game defined follows definition game temporal logic structures sequences elements elements respectively round game consists ordered sequence moves form player chooses element carrier player ii chooses element carrier structure 
players obey rules 
corresponding elements sort 
pair sort say th move data move sort temporal move elements sort call pair initial temporal context vectors initial assignment 
vectors handle open formulas cf 
theorem 
additional rules game temporal logic ehrenfeucht fraiss game order logic 
rule enforces sort compatibility individual moves game natural requirement sorted structures assume relations empty arguments match required sorts 
second rule needed define initial temporal context subsequent moves relative context 
note closed temporal logic formula free variable sort represents initial temporal context cf 
semantic definition temporal logic section 
rules game need define winning condition game temporal logic 
observation example definition compatible moves round game temporal logic moves game precedes 

data moves 
data move temporal move round game compatible moves 

round game compatibility individual temporal moves 

temporal move preceding data move 
temporal moves moves temporal moves 
temporal moves temporal move preceding data move holds say moves compatible 
set moves self compatible elements compatible 
definition related definition temporal connectives example 
blocks consecutive temporal moves correspond temporal connective subsequent temporal connectives number nested quantifiers compatibility criterion exactly matches compatibility scopes corresponding variables formula example shows round game structures lower part shows moves compatible individual temporal moves particular round game 
easy see compatibility moves game exactly corresponds scopes variables formulas 
note case fol scopes individual variables extend rightmost edge th column 
definition implies restrictions winning condition game temporal logic definition round game fotl length say player ii wins round game fotl conditions hold 
ffi data moves fk self compatible ku ku 
ae fl kw temporal moves fk kw self compatible ae kw ae kw 
temporal extension oe temporal move data moves fk self compatible kv kv say player wins round game temporal logic 
player ii win game say player ii winning strategy 
easy verify winning strategy player ii defines equivalence relation class structures length initial assignment number moves game definition quantifier depth define function qd 

atomic qd 
oe qd qd oe 

oe oe qd oe qd oe 
oe oe qd qd oe 
definition set formulas subformula embed qd general sets countably infinite find finite subset set represents formulas lemma finite subset phi formula oe equivalent formula phi free variables fv induction notation phi formula vector elements carrier order structure write note variables free variables 
show relationship initial assignments sets phi example consider formula fotl formula translation embed translation renaming variables renaming variables allows set phi particular subformula embed belongs phi phi phi phi phi sorts individual variables correspond sorts elements initial assignment show non definability particular formula 
note phi elements initial assignment sorts respectively 
verify winning condition respect phi atomic 
idea theorem shows equivalence order temporal formulas games temporal logic 
theorem structures sequences elements elements respectively phi induction base iff phi definition phi atomic formulas negations conjunctions 
note atomic formulas preserve compatibility criterion subformulas embed induction step assume claim proven suppose phi arbitrary formula 
assume form phi correspondence boolean combinations formulas determined result formulas 
cases know sort 
induction hypothesis phi pick quantifier appropriate sort 
covers formulas set phi proves claim 
leaves obey variable compatibility restrictions 
guarantees subformula embed conversely suppose 
exists element induction hypothesis satisfies rules game formula phi phi finite lemma form oe oe oe allowed rules game 
similarly previous case pick oe constructed phi 
note crucial restriction scopes individual variable names base case induction inductive step restriction compatibility variables example definition holds subformulas temporal formula especially atomic formulas 
note structures indistinguishable closed formulas quantifier depth arbitrary set temporal connectives built definition initial temporal context procedure similar corollary show non definability fotl 
need careful show separation languages need show non definability order definable property 
structures indistinguishable fotl formulas prepared necessary techniques show main result language strictly expressive language show standard choice data domain set uninterpreted constants equality standard choice linearly ordered temporal domain ffl propositional temporal logic expressively complete set temporal connectives ffl finite set temporal connectives expressively complete order case 
result implies choice fotl arbitrary finite set connectives basis order complete query language temporal databases adequate order queries expressible language 
prove result steps 
show fotl language strictly expressive fol language degenerate choice temporal domain set elements structure elements equality signature temporal domain empty standard data domain uninterpreted constants equality 

second step extend result dense linear orders 
time domain set claim proven follows ffl empty signature ffl temporal connective omega gamma ffl fotl language 
lemma propositional tl ffl expressively complete respect monadic fol ffl 
induction structure ffl 
note propositional case signature data domain irrelevant 
notation fs set element subsets element set mg 
prove lemma generalize order case logic omega gamma ffl strictly expressive logic ffl theorem define gammat hz ng gamma hz ng temporal structures signature hffl 

distinguished formula quantifier depth 
distinguished formula quantifier depth equal gamma 
clearly ffl prove define winning strategy player ii data moves temporal move prefix round game satisfies winning condition 
show sequence moves shorter extended move 
case analysis assuming player picks element carrier structure 
player plays data move ng player ii responds ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl negative time positive time ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl negative time positive time interpretation relation symbols structures respectively 
dot means data element line appropriate relation time instant dot column 
interpretation structures 
player plays data move ng player ii plays ng gamma similarly cases player ii find elements chosen far 

player plays temporal move js gamma jg 
player ii plays js jg gamma exists contains element subsets ng number data moves played far choice may unique case player ii choose arbitrarily elements indistinguishable signature ffl 

player plays gamma jg 
player ii plays gamma jg similarly previous case exists 
similarly player chooses element carrier structure player ii replies element symmetric strategy 
cases new move violate winning condition 
theorem follows theorem 
example move game game structures need distinguish cases depending data moves played far 
data moves easy case player ii reply arbitrarily temporal move player restriction play nonempty state player plays nonempty state guarantees able find answer data move 
player plays data move player ii plays data move assume move player picked data element game far looks follows player ii looks th state finds picks element arbitrarily 
data move case player ii maintain similarity temporal states reply temporal move player respect partial mapping 
assume player plays temporal move gamma player ii answer gamma gamma gamma reply data move similar previous case 
assume player plays gamma gamma player ii picks appropriate relations times gamma gamma cf 


data moves strategy finding answers temporal moves player just look played data elements interact temporal moves player previous case watch just element 
problem relations contain possible subsets size 
data moves game 
note number temporal moves matter long data moves player ii maintain winning strategy number temporal moves 
round game temporal logic corollary fotl omega gamma ffl strictly expressive fol ffl arbitrary finite set connectives omega gamma ffl 
theorem corollary provide example expressive completeness propositional case imply existence complete set connectives order case 
time domain dense linear order show similar result temporal logic linear orders complicated 
need account structure temporal domain 
consider definition definition linear order finite set non trivial interval function 
say dense 
clearly dense linear order define functions dense finite codomain 
lemma dense linear order open interval ji 
finite set gamma 
dense immediate density 
shows example function dense element set 
theorem dense linear order gamma 
dense non trivial interval ae nontrivial open disjoint intervals define hq ng gamma hq ng temporal databases 

distinguished formula quantifier depth 
distinguished formula quantifier depth equal gamma 
immediate proof theorem follows proof theorem observation dense player ii find appropriate answer temporal move player respects compatible temporal moves played far follows immediately density 
corollary fotl omega gamma dense linear order strictly expressive fol arbitrary finite set connectives omega gamma 
open unit interval split sub intervals equal length 
inner boundary mapped letters fa dg alphabetical order 
process applied subintervals 




remaining elements mapped remaining element range dense function gamma 
fa 
additional results technique prove additional results fotl 
results show gap fotl fol bridged powerful version fotl weakness inherent restriction maximal temporal arity dimension logic fotl 
separation fotl fotl similar technique theorem separate fotl arbitrary temporal connectives full fotl 
note logics expressively equivalent propositional case 
lemma dense linear order left endpoint 
ae non trivial open interval gamma 
dense define ng 
hq ng gamma hq ng temporal structures 

structures distinguished formula quantifier depth 
distinguished formula quantifier depth equal gamma 
clearly 
follows observation dense player ii find appropriate answer temporal move player fact quantifiers fotl formulas restricted means player return time played temporal move sequence temporal moves game fotl non decreasing sequence elements 
expressive incompleteness dimensional fotl fotl query language express queries distinct time instants essential way cf 
section 
due limitation number temporal contexts passed individual subformulas fotl formula 
dimensional propositional temporal logics studied 
logics easily modified dimensional order temporal logics fotl dimension logic 
main idea approach allow temporal contexts temporal sub formulas 
clearly fotl express query theorem exactly temporal contexts needed query 
technique show fotl strictly expressive fotl expressive fol 
definition dimensional temporal connective fl signature temporal domain variables ranging tuples elements time instants 
ae predicate variables ae fl th component tuple variable ary dimensional temporal connective fl formula exactly free variable free predicate variables denote omega gamma fl denote finite set names temporal connectives fl 
define language fotl exactly way case fotl cf 
definition 
semantics defined way definition small fix base case embed game dimensional temporal logic similar game fotl 
difference temporal move pick tuples elements sort single element 
guarantee winning condition met components tuple move 
note uniform temporal databases relations monadic sort clearly higher dimension base relations temporal sort leads separation result immediately 
restriction database relations prove separation fotl fotl 
show equivalence structures respect game dimensional temporal logic consider definition definition subsets ng 
cover ng respect collection equivalence classes generated relation ng defined kg elements covers respectively 
say corresponds relation obviously equivalence relation reflexive symmetric transitive 
sets snapshots temporal structures respect temporal move game 
definition shows covers generated sets influence winning condition game fotl definition fa fb covers ng respect respectively pairs elements ng 
say similar respect pairs essentially moves game match covers generated sets vice versa 
ensure sequence data moves extended maximal number moves particular round game 
sure element cover cardinality equal length game corresponding element cover exactly cardinality distinguished data moves 
build pairs structures similarly way built theorems definition natural numbers 
define set subsets cardinality set subsets cardinality kn set subsets cardinality bigger kn set ng 
sets similarly way theorems represent contents relations distinct time instants 
lemma shows tuple time instants player chooses temporal move player ii find similar tuple structure lemma pairs elements ng pairwise different projections vice versa 
similar respect 
ja jb ja jb pairs corresponding elements covers 
fb clearly jb ja satisfy condition sufficient element cover generated contains corresponding set easily achieved follows bijection ng ng need modify cardinality kn members 
clearly cardinality kn 
cover ja js 

especially true sets cardinality equal kn element cover jaj cardinality kn move element set new collection cover satisfies conditions theorem 

proceed similarly distinction consider empty intersection note ja similar procedure produce cover opposite direction trivial ae identity mapping covers satisfies requirements lemma immediately 
consequence lemma player ii find answer temporal move player compatible data moves played far sequence data moves extended sequence length satisfies winning condition 
ordering temporal moves handled similarly ordering theorems depending signature temporal domain 
theorem ik expressible fotl fotl 
expressible fotl follows immediately lemma theorems constructing structures sets relation structures sets construct relation structures respectively 
show expressible fotl consider dimensional connectives note variables range tuples temporal elements 
equivalent ik fotl formula 
dimensional fotl logics form proper hierarchy respect relative expressive power fotl ae fotl ae ae gamma fotl ae fotl ae ae fol note arbitrary finite set connectives find fotl express connectives previous results know fotl ae fotl ae fotl fotl hand hierarchy fotl approximates fol theorem fol formula 
natural number fotl formula 
maximal number free variables subformulas form formula encoded choosing maximal subformulas syntactically temporal operators 
connectives form finite set connectives dimension gives immediately formula fotl 
temporal relational algebras previous results show temporal relational algebra strictly weaker temporal relational calculus theorem gamma order definable relational algebra uniform relational types 
relational algebra queries gamma express order queries 
maximal arity operators gamma maximal quantifier depth defining formulas clearly operator expressed fotl 
result follows theorem 
ordered data domain theorems hold presence linear order data domain usual assumption relational databases 
difference choice cardinality subsets elements relations subsets chosen similarly proof theorem 
choose data domain define structures hq gamma hq strategy player ii essentially linear orders cardinalities gamma distinguished data moves cf 
example player pick gamma data moves round game temporal logic length fixed data domain corollary may suggest logic fotl strictly expressive fol order case 
true example consider situation finite set fixed size 
case proof lemma build structures arbitrary size 
element constant replace quantifiers follows easy see case essentially case propositional temporal logic 
note fixed size domain order property defined order theory 
size resulting formula depends size maximal expressive power fotl natural question strongest possible fotl dimension bound 
turns complete linear orders fotl logic 
result follows immediately proposition observation temporal connective decomposed embedded applications connectives temporal connectives thought formulas propositional temporal logic 
introduces propositional logics complete particular choice 
chapter defined model theoretical game captures expressive power fotl general setting definition independent underlying signatures theories 
game resolve open questions temporal logics 
main result separation fotl fol fol strictly expressive variant temporal logic dense orders 
fotl basis design order complete temporal query language 
conjecture results hold expressive power sufficiently large linear orders proof theorem discrete orders needs modified restricted density property allows maintain winning strategy player ii order isomorphic standard linear order integers 
prove theorem fotl unary temporal connectives discrete linear orders 
claim full generality goal ongoing research 
research area concentrate topics 
case complete order query languages new general implementation techniques need developed handling temporal information cf 
section 
intermediate results query evaluation algorithms may complicated allowed uniform database schema 
intermediate results stored uniform temporal database auxiliary relations 

area incomplete subquery closed temporal query languages relationships different sets temporal connectives need investigated 
applications limited number simultaneous temporal contexts may sufficient 
allow sufficiently large set temporal connectives tailored specific application 

temporal databases infinite structures general 
data stored database finitely representable cf 
chapter 
restriction disallows arbitrarily complex temporal databases cf 
definition sufficient restriction class allowed temporal databases may sufficient guarantee closure completeness 
seen bounded number elements data domain restriction 
nontrivial restrictions especially temporal domain guarantee closure completeness 
related separation proven modification ehrenfeucht fraiss games capture properties temporal logic 
pebble games show expressivity results monadic logic linear orders 
results techniques different interested order temporal logics corresponding fol method introduced longer sufficient handle unrestricted quantification data sort 
restricted version fotl introducing connective allows reset temporal context subformula original evaluation point 
logic shown strictly stronger fotl 
technique apply temporal databases proof fact carried firstorder structures finitely encoded contents database relation infinite time instant sets represented data domain theory equality finitely encode finite sets 
result separates fotl connectives fol case finite sufficiently large linear orders supports conjecture 
uses counting argument proof generalize arbitrary linear orders 
relationship various sets temporal connectives defined clear 
bibliographical notes temporal logic connectives introduced 
prior note databases proofs finitely representable 
complement infinite 
temporal logic studied form modal logics unlabeled transition systems transition relation order 
substantial interest temporal modal logics specification verification community 
volume oxford logic guides dedicated study various aspects temporal logic 
exception effort spent propositional logics corresponding monadic order counterparts useful area temporal databases 
chapter constraint databases leading approaches finite encodings classes infinite databases constraints quantifier free characteristic formulas describe sets elements particular domain 
section introduces notion constraint class basis finite encoding classes infinite sets 
introduce basic building blocks terms evaluation datalog deductive queries representation defined 
standard bottom query evaluation procedure defined terms building blocks 
prove correctness evaluation encoding show sufficient condition termination query evaluation 
discuss general method combining different classes constraints framework datalog 
generalized databases infinite databases represented finite sets generalized constraint tuples 
number query languages databases studied 
proposed query languages differ respect ffl underlying inference mechanism order vs deductive ffl constraint language 
section study generalized datalog programs function free logic programs operate constraint tuples ground atoms 
idea comes area constraint logic programming allows declarative specification problems solvable standard datalog framework reasoning infinite periodic sets integers 
constraint tuples natural extension relational tuples tuple arity representing set jx gamma generalized tuple jx yg order constraint gamma divides gamma periodicity constraint tuples represent infinite sets integers 
constraint tuples combined conjunction gamma note constraint represents finite set handled standard relational techniques 
conjunction produce tuples higher arity gamma constraint representation compact explicit representation set potentially amenable efficient evaluation 
give definition objects constraints deductive query evaluation algorithm defined 
constraint classes objects constraints finitely encode infinite sets generated set atomic constraints 
constraints serve basis defining underlying set objects operations needed query evaluation defined definition set satisfiable atomic constraints 
define set constraints satisfies rules 
true 

satisfiable 
fv exists quantifier free formula dnf equivalent satisfiable 
renaming variables definition similar definition constraint domain 
contains satisfiable constraints 
elements finite representation possibly infinite relations constraint database similarly definition notation kck denote set valuations set constraints define ksk kck 
query evaluation representation operations definition constraint class constraint class set constraints definition equipped computable operations constraint conjunction theta computes conjunction pair constraints theta conjunction satisfiable returns 
diagram commute gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma 
kc kc gamma 
kc kc kc set free variables constraint identify tuples valuations finite sets variable names 
relational algebra join 
constraint projection theta vars constraint set variable names fv ae vars computes set fc projection satisfies condition delta delta delta fv gamma diagram commute gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma 
fc kck gamma 
kck kc note definition function defined returns finite subset constraint subsumption theta bool satisfies condition implies kc ae kc operations world constraints equivalents relational algebra operations join projection 
case ground tuples represented equality constraints constraint projection returns constraint tuple case general constraints definitions constraint projection may return set containing tuple 
operation constraint subsumption eliminate redundant answers reduces checking equality case ground tuples 
note unique definition imply oe 
better approximation oe relation operation reduces number possible duplicate answers improves efficiency evaluation methods cf 
chapter 
text omit superscripts strict version shows example naive evaluation procedure order queries constraint database 
definition states fundamental property constraint classes termination proofs bottom query evaluation procedures implicitly 
definition constraint compact class constraints constraint class 
finite set variables set fv vars set legal variable names 
similarly duplicate elimination ground case 
preserving 
finite subset fin fin fin covers respect constraint class called 
property plays central role termination proofs evaluation methods deductive queries particular constraint class immediate consequence operator 
definition datalog program constraint class atom predicate symbol distinct variables arguments 
datalog program set clauses form atoms simplicity assume extensional database edb represented set unit clauses form part constraint database datalog program 
query database tuple containing atom constraint returned tuples satisfy 
database included component query definition query datalog program atom call tuple query answer query set valuations gc 
query evaluation procedure algorithm computes answer query 
query partially instantiated constraint nontrivial true 
note definition query clouds distinction data complexity complexity query evaluation 
chapters assume data complexity query measured respect number clauses complexity respect size natural corresponds intuition definitions 
number clauses includes number facts equal size generalized edb relations constant multiple 
fc generalized relation order query relation 
query evaluation order query thought gamma 
gamma 
quantifier elimination procedure conversion dnf 
answer relation generalized relation fc constraints order query evaluation 
closed form bottom evaluation usual approach query evaluation datalog variation bottom evaluation algorithm 
simplest form bottom evaluation algorithm defined follows definition interpretation atom constraint fv fv 
pair named constraint 
interpretation set named constraints 
named constraints play role ground atoms tuples stored tables standard relational deductive system 
definition immediate consequence tp operator constraint representation similar definition operator ground atoms 
constraint case operations definition tp operator defined respect chosen constraint class cf 
definition 
definition immediate consequence operator interpretation datalog program 
define tp exists ig shorthand fv 
variables constraints renamed variable names associated atoms body clause lemma tp monotonic continuous preserves suprema directed chains 
continuity chain interpretations gamma gamma directed chain 
tp named constraint 
clause tp tp 
tp 
tp 
similarly previous case clause tp 
monotonicity follows immediately continuity 
standard bottom evaluation algorithm remains ground tuples modifications needed evaluation constraint queries encapsulated definition tp operator 
algorithm naive bottom evaluation query variables interpretations 
repeat tp return fc ig algorithm produces result standard bottom evaluation program respect ground interpretations 
show fact relating iteration standard tp operator ground interpretations iteration tp definition immediate consequence operator ground interpretations ground interpretation datalog program 
define tp fa ig compare results obtained iteration tp tp respect datalog program theorem datalog program predicate symbol tp tp tp standard consequence operator herbrand interpretations 
simultaneous induction tp tp base case holds trivially 
tp 
exists clause ground substitution tp holds 
ih tp exists representation constraint 
definitions cm exists fv tp fv 
tp ground assign values free variables 
definition exists clause tp gamma cm ih tp gamma definition tp tp 
tp tp continuous 
tp oe tp note number iterations tp tp 
tp operator operate infinite ground interpretations 
arrangement shows evaluation procedures tp operator utilized constraint query evaluation semi naive bottom evaluation cf 
chapter 
show termination algorithm need theorem termination constraint compact class constraints 
algorithm terminates query 
contradiction assume algorithm terminate 
iteration loop produces named constraint subsumed named constraint follows immediately termination condition algorithm repeat 
loop 
datalog program contains finitely different predicate symbols predicate symbol algorithm derives infinite sequence named constraints 
sequence fc class constraint compact 
finite subset fc fc covers infinite sequence 
definition subsumed constraint fc contradiction tp derive named constraints subsumed definition 
note tp may infinite set 
set tp finite constraint compact class constraints corollary finite class constraints 
algorithm terminates query 
instance general definitions standard datalog ground interpretations tuples example flat domain uninterpreted constants equipped equality relation 
define language datalog follows 
interpretation set tuples ra predicate symbol ra tuple 
conjunction atoms ra rb tuple fields ra matched fields rb name conjunction consistent matching successful 
projection operation removing field tuple 
named constraint ra subsumes sa iff sa ra tp operator bottom evaluation procedure termination argument follow immediately definitions 
classes constraints disjoint domains previous section suggests integrate various classes constraints datalog 
main difficulty doing design quantifier elimination procedure constraint projection cf 
chapter 
combining classes constraints disjoint domains integers uninterpreted constants problem 
due constraint approach typing variables evaluation classes independent classes 
definition datalog classes constraints datalog program finite set clauses form bm bm predicate symbols satisfiable constraint note classes contains trivial constraint true 
definition constraint class tp consequence operator datalog datalog program clause consequence operator relative defined tp respect program fcg denoted tp interpretation set tuples predicate symbol finite representation constraint arity atom definition datalog program domains disjoint interpretation ig define tp bm tp note exist tp produce output 
correctness termination bottom evaluation datalog proven follows theorem datalog program predicate symbol tp tp simultaneous induction number iterations tp 
base case holds trivially 
tp 
exists clause ground substitution tp holds ih constraints tp tp definition consequence operator 
opposite direction similar 
claim holds observation tp tp continuous similar lemma 
lemma datalog program 
tp tp immediate definition 
note tp operator applied clauses projected datalog constraint goals replaced true clauses corollary tp finite tp finite bottom evaluation datalog programs terminates 
immediate lemma 
corollary constraint compact evaluation datalog program terminates 
standard bottom algorithm evaluate datalog queries termination guaranteed 
product cardinalities tp sets limits number applications operator tp needed reach fixed point 
especially sets polynomial size program ptime evaluation procedure 
order queries negation clearly operations constraint class evaluate positive existential order queries relational calculus 
easily seen positive existential query written non recursive datalog program 
methodology evaluate order queries constraint databases need extend definition constraint class allowing sort complementation definition constraint class closed complementation constraint class 
say closed complementation exist 
fc require existence computable function computes complement constraint note image finite set constraints 
operation compute complements generalized relations follows lemma constraint class closed complementation generalized relation defines constraint complement gamma krk rk immediate definition definition laws 
queries specified formulas containing 
note generalized relation previous lemma gives algorithm computing complement contains finitely constraints iterate constraint conjunction 
similarly complementation case datalog case need sure constraint class constraint compact guarantee termination chapter defined notion constraint class terms encode classes infinite databases 
general conditions evaluation deductive queries possible 
correctness evaluation termination guaranteed classes constraints constraint compact 
related chapter generalization concepts specific results various concrete constraint query languages 
extracted common underlying ideas shown general properties abstracted model 
similar approach general constraint logic programming languages 
technical differences constraint class defined semantically constraint domain generated syntactic closure main aim show termination deductive queries issue general constraint programming languages extensions general purpose logic programming languages easily shown turing complete 
bibliographical notes constraint representation infinite sets elements originated area databases 
logic programming community area constraint logic programming active area research years 
survey results implementation techniques applications 
main difference database approach logic programming approach uses quantifier elimination uses resolution basis query evaluation computation 
comprehensive quantifier elimination various theories 
survey constraint databases query languages 
approach syntactic restriction datalog clauses guarantee termination restricted class queries restricting constraints complemented relation unary ones 
note restriction syntactic shape datalog programs implies limited version complementation 
chapter constraint classes integers chapter introduces generalization datalog operating periodicity gap order constraints set integers 
instantiate general definitions previous chapter particular classes constraints prove properties 
free bonus closed form evaluation procedure running ptime class constraints 
chapter define finite representation periodic sets integers 
sets quite useful encoding storing information periodic activities temporal databases schedules experimental data 
addition show kinds constraints combined classes constraints integers gap order constraints equality constraints 
example simple example datalog program uses integer constraints database airline connections cities cf 

natural query database get paris toronto monday starting arrive 
example takes advantage periodicity gap order constraints 
note time units need converted smallest common unit example smallest common unit minute day just shorthand similarly mon mon mod day syntactic sugar 
representation inherently periodic information flight day natural periodicity constraints 
conditions type need minutes check captured easily gap order constraints 
main contribution chapter definition closed form bottom evaluation procedure datalog programs integer periodicity order constraints 
language simple expressive query language temporal databases 
evaluation gap order constraints results 
proposed bottom evaluation procedure polynomial data complexity 
general method incorporating various classes constraints datalog studied 
mild restrictions 
database connections connection paris london flight day mon mod day mon mod day 
connection paris london weekdays mon mod day mod day mon mod days fri mod days connection london toronto twice week tue mod days tuesday tue mod days 
connection london toronto fri mod days friday fri mod days 
change times airports london change planes planning trips trip start connection dtime atime start dtime check atime 
baggage claim trip start trip change start atime trip change dtime change atime dtime 
specific airport example datalog query uses integer constraints essential way 
rest chapter organized follows 
section gives definition finite representation periodicity constraints operations needed bottom evaluation 
section describes bottom evaluation procedure gives proofs correctness termination 
complexity evaluation procedure analyzed 
section deals combining periodicity constraints order constraints 
correctness termination complexity results 
chapter concluded open problems discussion relevant 
periodicity graphs section describes graph representation periodicity congruence constraints 
representation operations defined serves basis closed form bottom evaluation datalog programs periodicity constraints 
definition periodicity constraint finite set natural numbers ck set formulas defined inductively follows 
variables gamma 
variable gamma 
ck ck element ck set free variables call periodicity constraint variables constraint built rules called simple periodicity constraint 
context datalog restrict attention class simple constraints losing expressive power 
restriction allows efficient query evaluation procedure 
general theory applied logic query languages generalized databases periodicity constraints simplification possible conjunctive queries 
constraints form place ground atoms bottom evaluation 
directly represented graphs definition periodicity graph ng complete graph nodes ng edges labeled pair positive integers ff fi fi ff 
call periodicity graph variables arity 
define ff ff fi fi ng complex periodicity constraints represented set graphs representing disjunct corresponding dnf 
definition assignment periodicity graph fx assignment integers nodes 
say satisfies ng ff fi call satisfiable periodicity graph exists assignment combine constraints variables proposition proposition chinese remainder theorem gcd divides jc gamma exists unique lcm lcm 

proposition allows combine periodicity constraints variables single constraint show inconsistency original constraints 
definition periodicity graph periodicity constraint set variables 
say equivalent assignments constraint ck shown equivalent periodicity graph 
graph defined inductively respect structure constraint lemmas lemma periodicity constraint periodicity graph fx ff ff fi fi ff fi equivalent immediate definitions 
lemma periodicity constraint periodicity graph fx ff fi equivalent immediate definitions 
define constraint class periodicity constraints need define operations representation individual constraints algorithm conjunction periodicity graphs set variables respectively 
construct periodicity graph follows 
ng ng ng nodes graph 
edge condition gcd ff ff divides jfi gamma fi violated conjunction satisfiable graph produced 

label edges follows ff lcm ff ff ff gamma ff gamma fi fl fi gamma fi gamma fl ff unique solution equation ff fi ff fi proposition 
lemma periodicity constraints sets variables respectively periodicity graphs equivalent respectively 
satisfiable exists periodicity graph equivalent arbitrary assignment 
assumption proposition condition algorithm allows combining constraints pairs nodes single unique constraint 
assumption conjunction constraints satisfiable hand obviously assumption theorem ck satisfiable periodicity constraint exists periodicity graph set variables equivalent constraint 
induction structure base case follows lemma lemma 
induction step follows lemma lemma 
checking assignment values nodes periodicity graph satisfies constraints represented graph need check paths nodes general 
avoid problem introduce normal form periodicity graphs single edge needs checked satisfaction 
definition normal form periodicity graph 
say normal form ng ff fi gcd ff ff fi fi gcd greatest common divisor lemma periodicity graphs normal form satisfiable 
induction size graph 
algorithm periodicity graph normalization ng arbitrary periodicity graph 
repeat ng gamma fx lcm ff gcd ff ff divides jfi gamma fi fi ff fi fl graph produced algorithm fails ff changes fl unique solution pair congruences ff fi gcd ff ff fi fi proposition 
normalization procedure detect inconsistent satisfiable periodicity graphs 
lemma periodicity graph satisfiable equivalent normal form 
periodicity graph produced algorithm applied obviously resulting graph normal form 
assignment labels implied paths nodes satisfied 
satisfied label combination composite labels paths proposition 
step algorithm propagates composite constraint implied path step closer edge 
paths inconsistent algorithm fails 
longest simple path complete graph nodes length need repetitions outermost loop algorithm 
satisfiable lemma 
closed form bottom evaluation additional operations periodicity graphs needed 
quantifier elimination procedure constraint projection algorithm projection periodicity graph set variables construct periodicity graph set variables gamma fxg follows 
normal form 
ng gamma fxg gamma jy labeling edges restriction labeling lemma satisfiable periodicity constraint set variables periodicity graph equivalent periodicity graph gamma fxg equivalent arbitrary clearly 
obviously iff note iff preserved graph normalized paths nodes implied edge nodes 
case simple periodicity constraints step 
algorithm omitted 
operation representation periodicity constraints required definition constraint class definition subsumption checking definition subsumption periodicity graphs set variables 
say subsumes assignments implies lemma normal periodicity graphs set variables 
subsumes edge 
ff divides ff 
fi fi mod ff immediate definitions 
datalog periodicity constraints previous section introduced finite representation periodicity constraints 
representation bottom evaluation datalog jz programs periodicity graphs serve elements computed interpretation 
datalog jz programs defined naturally follows definition datalog jz program finite set function free clauses form atoms satisfiable periodicity constraint ck datalog jz program 
note usual datalog constants allowed 
problem constants added technique section 
datalog jz program constraints ck integer constant identified remainder class operations numbers performed modulo arithmetic 
similarly definition define interpretation datalog jz program respect constraint interpretations zn additive cyclic group elements 
definition named periodicity graph datalog jz program predicate symbol occurs arity consistent periodicity graph set variables fx call pair named periodicity graph 
named periodicity graphs take role ground atoms standard bottom evaluation datalog definition datalog jz program 
set named periodicity graphs interpretation 
define fv bm normal form gm gc fv subsumed atom ig fv set free variables tp tp tp gamma 
note nodes periodicity graphs renamed variable names associated subgoals clause conjunction operation performed respect names similarly natural join cf 
definition 
definition upper bound datalog jz program fc set constraints modulo factor constraint say ff ng maximal modulo factor show datalog jz program respect fixed set ck labels edges periodicity graphs bounded constant 
shown periodicity constraints lemma satisfiable periodicity constraint occurs datalog jz program periodicity graph equivalent ff ff 
structural induction atomic claim holds trivially claim follows lemma claim follows lemma 
application preserves bound lemma datalog jz program tp 
ff ff 
induction claim holds trivially 
tp 
definition operator result applying operator set tp 
claim holds ih periodicity graphs tp holds satisfiable periodicity constraints lemma 
constructed clause fv gm gc 
claim holds lemma lemma idempotence lcm operation 
lemmas theorem class periodicity constraints constraint compact 
immediate consequence theorem theorem corollary bottom evaluation datalog jz terminates 
complexity bottom evaluation datalog jz number applications operator algorithm bounded datalog jz program follows lemma datalog jz program predicate symbol arity number different elements tp form ff edge ff different labels ff lemma ff different labels fi definition periodicity graphs definition 
graph components elements tp exactly edges 
actual number periodicity graphs resulting model usually smaller due subsumption checking lemma 
simple constraints bound ff nontrivial edges periodicity graphs 
corollary datalog jz program atomic constraints ck maximal arity atom number distinct variables single clause number predicate symbols number clauses including facts maximal number goals clause algorithm terminates steps 
application operator takes mo steps clause ff possible assignments named periodicity graphs goals body clause 
subsumption check takes ff steps 
different elements tp lemma total time needed compute model delta ff delta mo delta ff constants respect ck simple constraints application takes mo time 
note complexity subsumption checking affect complexity bottomup evaluation depends maximal arity predicates size database 
testing standard relational tuple belongs computed model done ptime theorem tuple recognition datalog jz program atomic constraints ck ground atom 
decidable 
bottom evaluation procedure takes time corollary testing belongs tp takes constant time respect size lemma 
easy show restriction fixed ck crucial obtaining polynomial bound consider example natural number gamma distinct prime numbers distinct constants 

cong 
cong gamma edge 
cong 
cong gamma 
edge gamma 
cong gamma pn gamma 
cong gamma pn gamma gamma gamma 
go 
go cong edge go 
query start go 
datalog jz program unrestricted number modulo factors 
example consider datalog jz program 
query query produces set constraint tuples fx pg delta delta delta gamma size set clearly exponential size input database gamma 
gamma fact program generates constraints follows immediately proposition proposition cyclic primary decomposition theorem finite abelian group isomorphic finite product cyclic groups prime power orders list prime power orders unique permutation 
fact growth rate sequence primes approximately log element isomorphic product appropriate elements individual groups elements represented constraints particular element group uniquely determined conjunction constraints combining classes constraints integers periodicity constraints integers clearly interesting class constraints 
section consider possibility combining different classes constraints domain case integers 
gap order constraints combine constraint language developed far datalog datalog gap order constraints 
definition gap order constraint integers nonnegative integer variables integers 
finite conjunction formulas form called gap order constraint 
conjunctions gap order constraints efficiently represented gap graphs directed acyclic graphs nodes represent variables lower upper bounds constraints directed labeled edges represent gaps minimal integer distances nodes 
representation necessary operations closedform bottom evaluation 
show combination approaches closed form evaluation procedure complexity bounds increase 
definition datalog jz programs finite set clauses form atoms satisfiable periodicity constraint ck satisfiable gap order constraint 
datalog jz program 
note immediately apply technique section periodicity gap order constraints domain integers 
complexity consistency checking consistency satisfiability checking periodicity graphs gap order graphs separately done polynomial time respect size graph cf 
section 
theorem consistency checking conjunction periodicity graph gap graph np complete 
reduction sat satisfiability conjunctions constraints form instance sat variables clauses encode quantifier free conjunction periodicity gap order constraints follows encoding variables variable create formula ffi gamma gamma encoding clauses define formula fl 
instance reduced formula ik ffi fl easy see satisfying assignment values free variables yields satisfying assignment true 
consistent acyclic path gamma 
gamma 
gamma gamma 
en gamma 
ff dpe ff od return false od return true return false ff value gap associated edge lower bounds dpe rounding smallest integer greater equal satisfying constraint ff fi 
searching paths efficiently achieved dynamic programming technique 
consistency checking conjunctions simple periodicity gap constraints 
fortunately theorem consistency checking conjunction periodicity graph constructed simple periodicity constraints gap graph computed ptime 
generalization consistency checking procedure algorithm computes length path lower bound upper bound adding gap sizes edges path 
node path length partial path lower bound node rounded respect periodicity constraint associated node 
graph consistent iff length path shorter difference lower upper bounds gap graph 
gives algorithm consistency checking conjunctions 
limiting periodicity constraints form reduce expressive power query language 
constraints form defined datalog jz clauses gamma gamma 
gamma gamma gamma similar way represent constraints form periodicity graphs simpler smaller limited case especially normalization needed anymore 
disadvantage solution need store rules database 
complexity bottom evaluation exponential arity predicate symbols program 
np complete consistency checking procedure impact data complexity 
consider simple periodicity constraints rest chapter 
bottom evaluation show compose classes integers immediately reuse large portion algorithms developed far 
reuse constraint conjunctions subsumptions individual classes 
develop new constraint projection operation satisfiability check 
interpretation set triples predicate symbol periodicity graph gap graph respectively 
arity 
definition consequence operator 
reuse conjunction subsumption procedures defined component classes constraints 
consistency check theorem 
complex operation quantifier elimination take care interactions periodicity constraints gap order constraints 
example assume want eliminate quantifier constraint clearly replace simply case gap order constraints need take account periodicity constraint need sure integer form fd gamma equivalent quantifier free formula 
easy see variable successfully eliminated resulting constraint disjunction conjunctions periodicity gap order constraints 
idea projection operation needed 
operator similar idea procedure simpler due different representation constraints especially omit normalization sense constraint tuples normalization different definition requires relations normalized qe indegree return gamma fyg gamma fyg node eh number nodes eh create gap graph eh eh gamma ff ff ff create simple periodicity graph xj ff gammaff gammai return consistent qe fg pseudocode algorithm 
algorithm projection periodicity graph gap graph node nh eh labeled nh eh labeled form set graphs modifying follows 
delete edge 
insert edges label 
add constraint gamma gamma 
check resulting pair consistency discard inconsistent pairs 
apply transformation recursively consistent pairs edges eliminated gap graphs 
remove node resulting pairs graphs including incident edges 
lemma ji ig set graphs produced algorithm pair respect variable valuations immediate example resulting pairs represent exactly consistent disjuncts dnf quantifier free formula 
algorithm defines projection operation periodicity graphs combined gap graphs 
eliminate existential quantifiers apply algorithm recursively output existential quantifiers eliminated original pair gap periodicity graphs 
projection operation produces possibly fairly large set graphs single graph 
considered space complexity problem 
framework datalog true standard datalog relation represented collection tuples 
case manage represent infinite sets tuples single element 
consequence operator defined standard way definition datalog jz program 

bm gm gc hm hc fv consistent subsumed ig gc periodicity graph corresponding hc gap graph corresponding show bottom evaluation datalog jz program algorithm 
correct respect standard bottom evaluation theorem datalog jz program predicate symbol tp tp 
simultaneous induction number iterations tp 
base case holds trivially 
tp 
exists clause ground substitution tp hold 
ih tp 
exists periodicity graph gc equivalent gap graph gc equivalent gc gc tp 
definition 
operator 
opposite direction similar 
claim holds observation 
continuous note proof theorem similar proof theorem special case domains periodicity gap order constraints disjoint 
interpretation 
define ig 
ig lemma datalog jz program 
tp 
tp tp 
tp induction continuity 
proven similarly continuity tpc lemma 
corollary union classes periodicity gap order constraints constraint compact 
corollary bottom evaluation datalog jz program terminates 
show polynomial bound tuple recognition procedure datalog jz programs technique tuple recognition runs ptime follows theorem complexity test algorithm equality constraints far mentioned natural class constraints integers equality constraints needed include standard datalog integers 
equality constraints handled adding extra information gap graphs 
case datalog jz done way cases need mechanism represent single constraint form constraint classes closed conjunction lemma lemma constraint free variables 
applying lemma eliminate quantifier elimination procedure described previous section 
constraint just ignore 
described bottom evaluation procedures versions datalog enhanced constraints provided general way combining various classes constraints single language 
proved complexity bounds bottom evaluation algorithm 
directions research extensions negation negative gap order constraints 
gap order constraints allows specify minimal distance variables 
maximal distance constraint maximal waiting time changing planes example expressed limited way enumeration technique similar technique algorithm 
note general solution adds gap order constraints negative size gap gamma leads immediately undecidable theory define successor relation integers succ gamma gamma 
degree polynomial higher standard datalog atoms arity exactly datalog datalog jz 
values assigned pairs attributes single attributes 
cases exponentiated expression constant respect size program 
reason possible extend language standard stratified negation 
limited version negation included language penalty 
syntactic subclass datalog introduced termination shown 
main idea unary constraints passed negations effectively prevents defining successor relation constraints derived evaluation program gap order constraints non negative gap value 
note periodicity constraints negation problem constraint form introduced problems cf 
section 
expressiveness 
expressiveness number deductive constraint query languages discussed 
monadic programs considered 
interesting see expressiveness query languages defined section formally characterized 
efficient implementation 
periodicity constraints define non convex sets 
respect differ common constraint languages 
describes adapt interval management techniques constraint databases 
approach works convex sets 
periodicity constraints call new storage management techniques 
related proposals introduce classes infinite integer relations query languages 
datalog gap order constraints introduced 
relational calculus generalized relational databases order constraints linear repeating points studied linear repeating point form fc zg fixed integers just different notation periodicity constraint 
proposed approach limited order queries simple inductive queries transitive closure expressible 
clear adapt approach datalog obvious termination argument 
solution tries keep different classes constraints separate long possible meeting points quantifier elimination consistency checking procedures 
arrangement provides potentially general framework adapted combinations constraint languages integers 
approach comes area temporal databases 
datalog extended limited successor function symbol restricted single distinguished argument literal 
way possible represent infinite periodic sets integers horn rules 
clear add constraints language maintain computational properties 
particular order constraints expressible language 
unary successor symbol deductive layer top database 
approach allows representation infinite relations stored directly database 
extension datalog proposed 
extension combines linear repeating points order constraints unlimited successor function 
resulting language expressive termination query evaluation language guaranteed 
summarizing handle periodicity constraints handle recursion handle ordering guarantee termination 
language step tractable expressive query language temporal databases 
bibliographical notes combination datalog rules integer order constraints pursued 
integer constraint queries proposed 
results integers easily books number theory read polish 
useful results cyclic groups books group theory modern algebra general 
chapter constraint classes section surveys known constraint classes summarizes properties 
show majority constraint classes semantics defined fixed point iteration tp operator apply general theorems chapter 
constraint classes section surveys constraint formalisms notion constraint class allows application bottom evaluation algorithm immediate consequence operator tp 
approach allows immediate efficient evaluation methods constraint databases developed chapter 
constraint compact classes ffl standard datalog defined class constraints generated set fx ag set constants datalog program cf 
example 
allowing general equality may cause problems standard evaluation strategies rules may non range restricted 
case simply generate appropriate class constraints set fx ag fx yg 
evaluation remains unchanged general evaluation mechanism 
ffl incorporation interesting constraints constraints integers discussed chapter gap order constraints generated set fx zg fu zg fx similarly periodicity constraints generated fx chapter closed form bottom evaluation procedure cj developed including necessary operations constraint class required definition 
ffl incorporate dense order constraints slight modification constraint operations defined 
ffl set order constraints introduced ffl boolean algebra constraints constraint classes constraint compact 
constraint classes 
constraint classes constraint operations defined constraint compact class generated set fx zg gap order constraints possibly negative size gap linear arithmetic constraints 
interpretation interesting application constraints area programming languages analysis especially analysis interpretation 
main idea technique execute program respect formal semantics set values respect concrete values program designed 
domains values simpler finite 
domains values designed way analysis terminates 
semantics programming languages natural form set inference rules 
easy see connection interpretation deductive queries constraint database instances semantic rules syntactic construction analyzed program form set recursive datalog rules cf 
appropriate domain values 
goal interpretation find minimal solution rules evaluate queries constraint database 
note domains values constraint compact guarantee termination analysis 
advantage constraint approach provides correctness proofs analysis provided correct abstractions atomic values operations 
approach applied techniques compiler optimization data flow analysis closure analysis 
formalisms extensions datalog constraints 
extensions evaluation algorithms fixed point iteration formalisms directly handled techniques developed dissertation 
ffl datalog datalog ns extension datalog geared limited function symbols successor successors 
successor symbols confined single distinguished argument individual literals program 
arrangement guarantees termination queries 
ffl datalog sequences 
introduces extension datalog interpreted function symbols manipulating sequences 
syntactic restriction class queries guarantees termination query evaluation 
bibliographical notes individual results various constraint classes 
forthcoming survey constraint query languages borrowed discusses individual results detail 
domain constraints relational calculus datalog datalog ac ptime ptime logspace ac ptime ptime logspace nc dexptime non elem 
dexptime hard undec 
ptime ptime ptime dexptime dexptime dexptime bm bm ptime pi hard undec 
ptime dexptime comp undec 
nc pspace comp pspace comp nc undec 
undec 
cn undec 
undec 
lrp ptime undec 
undec 
nc undec 
undec 
undec 
undec 
undec 
safe queries answers finite relations 
inflationary semantics 
syntactically restricted stratified datalog cf 
section data complexity 
fixed set modulo factors cf 
chapter 
table summarizes combined complexity query evaluation various classes constraints query languages 
summary constraint classes query evaluation 
simple language demonstrate constraints interpretation skip od stands boolean expressions form boolean variable 
give meaning syntax consider fragment natural semantics ae tt ae ae ae ae ae ff ae ae ae ae ae ff ae ae ae tt ae ae ae ae ae ae shown fragment semantic definition allows proceed example 
sequents rules form ae ae ae ae storage vectors executing commands 
consider procedure naively sorts values variables procedure sort tt asg ff asg tt skip asg tt skip asg labels right column labels individual syntactic constructions 
individual statements sort instantiate individual semantic rules written datalog clauses unfolding rules sequential composition sort asg 
ff 
tt asg 
asg 

asg 

asg tt 
asg ff 
asg tt 
asg tt 
datalog program ask queries respect program query sort gives answer execution sort storage vector satisfying constraint produces output application constraint queries interpretation 
chapter evaluation methods chapter proposes efficient method evaluating deductive queries general constraint databases 
method combination top resolution memoing closed form bottom evaluation 
way top evaluation terminates queries bottom evaluation terminates 
main advantage proposed method direct information partially instantiated queries need rewriting original program 
evaluation algorithm automatically propagates necessary constraints computation 
addition top evaluation allows compilation techniques developed compilers logic programming languages query evaluation efficient 
propose new method evaluating deductive queries constraint databases 
cf 
chapter 
evaluation queries constraint databases different standard database systems 
constraints actual representation data stored database mere restrictions contents ground relations 
algorithms query evaluation constraint databases satisfy criteria 
evaluation algorithm terminate possible input queries 

constraint language encompass wide class constraints particular domains 

partially instantiated queries evaluated efficiently 
requirement especially difficult achieve case constraint databases extensions constraint relations usually infinite 
main approaches satisfy requirements case datalog 
address requirements 
approach fixpoint bottom evaluation rules 
cf 
chapter 
condition usually met datalog datalog integer constraints chapter sets 
classes allowed constraints restricted guarantee termination 
evaluation process evaluation partially instantiated queries quite inefficient approach top resolution method 
second third conditions usually met 
termination queries sacrificed exception constraints allowed order improve expressiveness efficiency 
methods take full advantage compilation techniques developed logic programming languages 
greatly improves practical efficiency query evaluation case datalog 
show similar results achieved case constraint databases 
chapter try combine advantages approaches 
propose evaluation method constraint memoing applicable constraint extensions datalog datalog stands chosen class constraints cf 
chapter features ffl termination 
constraint memoing guarantees termination queries classes constraints closed form terminating bottom evaluation procedure 
complexity bounds bottom procedure preserved 
ffl expressiveness language easily extended accommodate various classes constraints long class constraints equipped elementary operations underlying representation constraints 
step quite subtle termination queries preserved 
contrast bottomup methods possible extend query language classes constraints termination guaranteed ffl top method allows fully goal oriented query evaluation information partially instantiated queries prune search space 
efficiency achieved method better efficiency comparable bottom methods including program rewriting techniques magic set transformation cf 
section 
top evaluation strategy allow direct compilation techniques developed area logic programming 
rest chapter organized follows section presents main ideas goal oriented evaluation procedures 
section describes proposed evaluation method constraint memoing includes soundness completeness termination proofs possible optimization techniques specific processing constraint deductive queries 
section introduces general magic set transformation mst datalog comparison purposes 
section studies analytical complexity query evaluation constraint memoing gives results show empirical evidence practicality proposed evaluation method 
section concludes presentation possibilities improvements directions research 
application program transformation techniques solve problem general 
cases termination guaranteed algorithm reduces possibility nontermination 
goal oriented evaluation strategies standard improvements naive bottom query evaluation algorithm semi naive algorithm 
strategies fail consider information contained partially instantiated query goal oriented 
major approaches solving problem framework standard datalog 
rewrite program magic set transformation mst subsequently evaluate transformed program bottom 
adopt top evaluation strategy resolution principle 
section consider mainly top resolution method 
mst transformation constraint deductive query languages introduced comparison purposes 
known standard top strategies despite efficiency major drawback query evaluation procedures lead nonterminating computations situations bottomup algorithms guaranteed terminate 
note breadth traversal sld tree guarantee termination general 
drawback caused occurrence infinite paths sld search trees 
observed papers alternative sld resolution proposed various names 
main idea consists remembering sets answers resolved subgoals 
method guarantees termination function free logic programs 
extend method constraint deductive queries preserving termination complexity bounds bottom evaluation 
top evaluation datalog chapter bottom evaluation datalog defined terms elementary operations specific class constraints 
section shows top query evaluation procedure slg resolution refined operations handle constraint queries 
approach allows build efficient top evaluation procedure class constraints closed form bottom evaluation procedure 
termination property bottom algorithm preserved 
modification slg resolution constraint memoing slg resolution defined set rewriting rules definition slg rewriting rules root body goal ans atom literals constraints class nodes build slg trees rules action node children conditions clause resolution root gamma body 
body satisfiable query projection body gamma goal 
goal answer propagation goal gamma body 
body ans satisfiable answer projection body gamma ans 
ans atoms ans set answers collected leaves slg tree rooted introduced notation 
slg tree tree built node root finite application rules 
slg forest set slg trees 
note answer propagation answer projection rules cooperate time new answer produced specific slg tree propagated nodes resolved answers particular tree 
answer propagation rule responsible creating new slg trees slg forest tree root node subsumes goal resolved 
main difference slg slg additional rules query projection answer projection 
query projection rule responsible determining goals resolved answer resolution goal constraint pair looked computed answers 
answer projection rule responsible storing computed answers goal subsequent lookup propagating appropriate goal nodes 
note essential constraint projection allows determine relevant constraint atom 
slg resolution handle negation additional rules 
presence negation constraints leads non termination 
current proposal allows positive programs 
adding negation briefly discussed section 
slg rewriting rules query evaluation follows answer subsumed answer tree generated earlier 
definition slg slg forest generated query follows 
create slg forest containing single tree froot 
expand leftmost node rules definition long applied 

return set ans answer query 
slg slg tree rooted node root 
order answers nodes ans slg forest time particular answer derived definition ans ans leaves slg forest generated slg rules cf 
definition 
say ans older ans node ans generated node ans 
notation ans set ans slg older ans slg lemma ans leaf slg tree slg 
application answer propagation rule path root ans ans answer propagated rule ans older ans 
immediate definitions 
soundness completeness constraint memoing proven reduction soundness completeness bottom evaluation cf 
algorithm 
note set ans may unique depends order nodes ans generated 
sufficient purposes set valuations ans unique 
lemma slg slg tree valuation 
ans induction height slg tree slg 
prove correctness algorithm show derived answers derived bottom computation lemma query 
slg slg valuation ans oe tp induction age answers assuming slg trees ordered order created 
choice selection strategy affect soundness completeness algorithm 
ans slg path root body ans slg starts clause resolution step clause cf 

definition answer propagated slg tree slg 
exists extension clearly induction hypothesis answers ans path computed ans lemma tp 
definition tp fact tp 
operation slg tree goal slg trees root clause resolution delta delta delta fi fi fi fi delta delta delta body query projection delta delta delta fi fi fi fi delta delta delta goal cc gamma gamma gamma gamma 
root answer propagation delta delta delta fi fi fi fi delta delta delta oe slg tree body new gamma gamma gamma gamma delta delta delta ans delta delta delta 
goal cc gamma gamma gamma gamma 
root answer propagation delta delta delta fi fi fi fi delta delta delta oe slg tree body new ak gamma gamma gamma gamma delta delta delta ans delta delta delta answer projection delta delta delta fi fi fi fi delta delta delta ans slg evaluation goal constraint answers main query subqueries represented remaining slg trees slg forest generated main query sound 
lemma atom constraints 
oe ans ans immediate definition ans 
tc tc tc 


tc 


root tc gammabody tc tc tc tc tc tc get results gammabody tc tc answer node tc tc get results new tree gammabody tc answer node tc new answer gammabody tc answer node tc gammabody tc answer node tc new answer gammabody tc tc answer node tc tc get results gammabody tc answer node tc gammabody tc answer node tc gammabody tc tc gammabody tc tc answer node tc tc get results new tree gammabody tc tc gammabody tc tc new answer root tc gammabody tc tc tc tc tc tc get results gammabody tc tc answer node tc tc get results gammabody tc answer node tc new answer gammabody tc answer node tc gammabody tc tc gammabody tc tc answer node tc tc get results gammabody tc answer node tc gammabody tc answer node tc gammabody tc tc gammabody tc tc tc tc gammabody tc tc gammabody tc tc new answer gammabody tc tc new answer root tc gammabody tc tc tc tc tc tc gammabody tc tc column indicates order individual nodes created second column shows slg trees generated column describes answers generated propagated slg trees 
annotated slg evaluation query tc thing show algorithm computes answers query 
little bit complicated algorithm compute answers uninstantiated query bottom evaluation 
lemma lemma query 
slg slg valuation tp oe ans induction stages tp 
tp claim holds vacuously 

clause extension tp gamma 
construct path slg ends node ans assumption corresponds application clause resolution rule 
element inductive hypothesis ans fact turn yields node ans slg previous assumptions general element gamma clearly gamma applications induction hypothesis induction hypothesis ans exactly corresponds application query projection answer propagation rules definition 
steps da element achieved answer projection rule 
ans 
actual algorithm application answer propagation rule necessarily tree slg answer resolution 
uses different tree slg case lemma ans ans answers possibly lost 
composing lemmas theorem soundness completeness query tuple 
valuations tp ans soundness follows lemmas 
completeness proven lemma 
soundness completeness proof reduction fixpoint computation ground instances 
prove termination query evaluation bottom top cases finite encoding potentially infinite result evaluation needed cf 
chapter 
theorem termination class constraint compact slg evaluation terminates queries 
constraint compact class constraints 

number trees slg forest slg finite finitely predicate symbols predicate symbol set fc root slg finite definitions 
root node finitely children finitely clauses datalog program 
body node finitely children set finite 
goal node finitely children finitely elements set ans atom definition 
slg finite depth finite number subgoals bodies clause rules definition applied finitely times 
termination constraint memoing guaranteed cases bottomup algorithm terminates computing finite interpretation tp 
usually easy decompose original bottom evaluation procedure extract elementary operations constraints needed constraint memoing definition 
optimizations reduce overhead introduced slg resolution comparison standard sld resolution explore possibilities solving general goals necessary action node children conditions query projection body gamma goal 
goal oe modification may reduce number slg trees slg forest cj 
propagation constraints time goal resolution reduced 
soundness completeness properties preserved lemma 
termination guaranteed similarly theorem 
version modification action node children conditions query projection body 
goal true case slg tree predicate symbol 
hand constraints propagated time goal resolution constraints merely restrict returned answers 
computation essentially computes answers uninstantiated query similarly bottom algorithm performance suffers mixed slg sld resolution memoing subset predicate symbols program 
action node children conditions non tabled resolution body gamma body 
body tabled goal satisfiable different way reducing number slg trees generated algorithm slg trees generated subset predicate symbols remaining symbols resolved program clauses similarly sld resolution 
soundness completeness preserved simple modification theorem 
termination guaranteed literal resolved slg resolution cycle dependency graph follows easy extension theorem 
infinite branch may appear slg trees 
may lead non termination similarly case sld resolution 
bounded number sld resolution steps slg resolution steps bodies clauses unfolded bodies callers 
transformation completely eliminates need sld resolution steps 
program transformation similar factoring previous folding transformation may introduce unnecessary recomputation conjunctions goals 
avoided factoring technique folds common parts bodies clauses creates separate clauses 
note recomputation avoided making heads clauses tabled 
optimizations program transformation 
contrast magic set transformation transformations completely 
magic set transformation mst section describes simple version program transformation approach query evaluation constraint deductive databases magic set transformation 
transformation slightly modified context constraint databases performance approximately evaluating uninstantiated query 
definition variable say free respect valuation valuation dom 
say bound denote bound set variables bound note definition consider mutual dependencies different variables 
case ground datalog issue variable free bound single constant 
take optimistic approach mst fb fg meaning argument adorned going free time goal processing adorned may bound constraint 
note adornment guarantee variable bound example consider goal constraint adorned fact constrained 
avoid situation complicated analysis constraint queries needed including analysis data stored constraint database may feasible general 
case datalog constraint class generated set fx ag mst transformation reduces standard mst datalog 
definition adornment atom arity adornment atom string fb fg length say th argument adorned th position respectively 
say adornment respect th position th argument bound th position th argument free clause adornment adornment clause respect set fab abn ab adornment adornment atoms body clause constructed follows th argument adorned ab 
th argument occurs head clause argument adorned 
th argument variable bound 
th argument occurs variable subgoal preceding th argument adorned magic atom atom adornment atom arguments adorned arity equal arity depending arguments adorned arguments adorned removed 
simplicity left right sips rule previous definition 
corresponds selection rule constraint memoing 
cases different sideways information passing style 
selection rules may improve efficiency query evaluation 
case mst sips fixed program transformation phase technical difficulties combining different sips program 
case slg evaluation selection rule adjusted evaluation process dynamically preserving correctness answers 
algorithm mst program transformation mst ab ab ab 
ab ab ab gamma gamma ik mst ab fab ab adornment respect ab ab magic atoms respectively 
definition mst query 
mst query query mst adornment respect difference classical version mst version definitions free variable seed magic computation clauses derived quantifier elimination procedure original query 
theorem soundness completeness mst transformation datalog query query obtained applying mst satisfies condition tp tp ground part tp 
exists proof tree inference rules inference rules exactly clauses program axioms atomic clauses 
easily replace inference rule rule adornment created copy original rule 
assume magic predicates true facts tree valid proof tree rules remains shown application inference rule magic predicate true derivable transformed program 
note magic predicates just restrict rule true sufficient show restriction severe done induction distance root base case root inference simply seed defined restriction query arguments instantiated ones 
obviously allows derive tuples implied original constraint partially instantiated query 
induction assume true applications inference rule distance root th inference form mst created magic rule literal form gamma gamma literals body rule true induction hypothesis contained head clause true soundness inference remember arguments just restrictions arguments 
true nodes distance root 
proof tree inference rules magic predicates considered true atoms proof tree completeness exist 
part tp 
exists proof tree inference rules inference rules exactly clauses program axioms edb relations 
inference rules follows pattern gammad magic predicate adorned literals 
interested expanding predicates know true antecedents rule applied proof tree true 
easy see project magic predicates obtain proof tree uses rules tp 
easy find cases mst static method predict binding patterns precisely performance inferior slg strategy example consider fragment datalog program mst goal body clause adornment bb cf 
rule definition 
clauses resolving bb bb bf bb bb fb test cases ground datalog transitive closure tc chain cycle tree tc tc tc 
edge 
edge 
edge 
tc edge 
edge 
edge 
edge 
edge 
edge 
queries tc tc tc tc chain tc cycle tc tree 
test cases datalog gap order constraints monotonic path path path path path 
path edge 
chain unit edges chain equidistant nodes edge edge 
edge edge 
queries path path path path path path test programs case bottom evaluation transformed program evaluate bf fb evaluating ff sufficient projections yield trivial constraint true 
correctly realized slg algorithm slg tree created 
performance section analytical complexity bound constraint memoing evaluation provided 
complexity top evaluation depends particular class constraints analysis relative comparison time space complexity bottom evaluation procedure 
analytical results confirmed experimental results show performance gain achieved constraint memoing 
theory show complexity slg algorithm worse complexity bottom query evaluation theorem tp result bottom evaluation query function jp 

slg forest slg nodes 
delta repeat tp delta delta gamma delta tp tp addition requires clause named constraints set delta 
arrangement avoids unnecessary recomputation known results preserving correctness 
semi naive bottom evaluation algorithm 

applications slg rules evaluation query 
follows observation slg tree slg forest leaves nodes height trees fixed number subgoals clauses different slg trees slg forest size tp limits number possible roots slg trees 
follows immediately application rule creates new node slg forest 
careful implementation needs store single path fixed length slg forest 
space requirements reduced 
hand quadratic number rule applications avoided general 
analysis bottom algorithm number applications clauses quadratic respect bottom algorithm recompute element interpretation times added interpretation tp 
implementation implemented experimental version deductive query evaluation algorithms 
naive bottom straightforward implementation algorithm 
semi naive bottom modification algorithm see 
semi naive bottom mst 
slg implementation evaluation algorithms independent underlying class constraints 
constraint class need provide elementary operations representations constraints cf 
definition additional auxiliary operations representation constraint true variables 
operation create fresh representation constraints evaluation individual clauses datalog program 
cn atom 
cn finite set list constraints equivalent constraint variables eliminated 
operations query projection project constraint free variables goal resolved answer projection eliminate variables head clause 
algorithm subsumption checking 
goal succeeds subsumes 
assume constraints set variables operation deciding new named constraint derived particular method 
cn operation computes constraint conjunction constraint constraint variables renamed respect variables atom operation constraint derived subgoal clause ed constraint variables body clause 
operation produces consistent constraints conjunction satisfiable operation fails 
operation solely mst transformation determine variables cf 
section 
operations just convenience user system allows pretty printing results evaluation allows entering constraints formulas actual representation prolog terms 
addition need specify datalog programs intend evaluate 
depicts structure experimental system 
operations class constraint evaluation methods constraint operation lookup clause constraint program query answer structure experimental system 
experimental results table summarizes running time milliseconds test programs 
examples partially instantiated queries optimization achieves naive semi naive semi naive top query data bottom bottom mst tc tc chain tc tc chain tc tc chain tc tc cycle tc tc cycle tc tc cycle tc tc tree tc tc tree tc tc tree path path path path path path path path running times test queries various evaluation procedures msec 
effect 
seen graphs figures 
graphs show time needed find path exists nodes represented axes 
axis represents elapsed time milliseconds 
results show implementations various evaluation methods comparable results uninstantiated queries approximately evaluation instantiated queries efficient constraint memoing 
boost inherent topdown evaluation method caused sophisticated implementation 
proposed practical approach query evaluation generalized constraint databases 
analytical empirical results show constraint memoing worse comparable bottom method cases practical performance better naive implementation 
performance constraint memoing boosted utilizing compilation techniques developed performance similar ground datalog expected 
research area focus issues compilation constraints 
achieve efficient implementation constraint memoing data structures efficient representation constraints developed 
main differences distinguish top processing constraint deductive queries general purpose logic programming languages addressed top msec 
magic sets bottom datalog element chain tc chain ffl cases size constraint representation bounded respect arity literal 
general logic programming engines allow unbounded terms built 
exploring property may lead efficient stack implementation evaluation procedure need heap 
ffl hand classical logic programming assumes variable free bound single term binding changed backtracking 
assumption longer valid presence constraints restrictive conditions may derived variable originally bound 
constraints specify complex relations individual variables possible standard approach 
development representation enables building efficient query evaluation engines partial evaluation atomic constraints class similar wam code 
analysis binding patterns 
similar mst transformation queries analyzed determine flow information clause bodies 
considerably complicated task presence constraints longer sufficient focus single variables relationships groups variables considered noted section 
assumption edb relations ground top msec 
magic sets bottom datalog gap order constraints element chain path resolution edb goal variables bound constants longer valid generalized relations store representation sets tuples may infinite 
analysis purposes query optimization mst rewriting optimization access constraint database indexing goal reordering interface existing rdbms 
constraints finitely encoded representation stored tuples standard relational database system 
query evaluation carried respect meanings encoding perform join constraint relations join operation underlying rdbms directly 
propose top evaluation procedure front built top standard relational dbms 
techniques proposed directly applied 
negation 
adding negation datalog way termination preserved nontrivial task stratified negation leads immediately turing completeness 
essentially adding negation preserving termination queries requires constraint class closed negation complementation preserving 
condition easy satisfy case finite constraint class 
constraints infinite domains integers possible 
storage access methods 
achieve efficient implementation constraint databases new storage management techniques developed access methods suitable fast retrieval stored information efficient updates generalized relations indexing techniques benchmarks 
performance various implementations logic programming languages prolog judged performance standard benchmarks nrev 
propose develop similar suite benchmarks measuring performance query evaluation methods constraint databases 
benchmarks independent particular class constraints 
test suite allow compare performance various query evaluation methods 
related attempts query evaluation efficient presence constraints 
main directions research 
direction roots deductive database community techniques pushing constraints query proposed 
goal methods preprocess query goal rules respect constraints subsequent bottom evaluation 
completely different evaluation strategy constraints propagated dynamically need preprocessing query 
standard database approach constraints considered conditions restrict ground answers 
constraint memoing uses constraints tool representing data computed queries stored database 
dramatically increases expressive power query language preserving termination efficiency 

direction pursued area logic programming top evaluation constraint logic programs proposed 
cases general constraint solving procedures 
methods directly useful query evaluation constraint databases termination guaranteed 
closest 
method proposed allows propagation constants constraints form constraint part query essentially computed bottom 
approach allows full propagation possible constraints evaluation process 
bottom approach equipped query transformation phase shown worse top approach restricted classes datalog programs ground relations 
show top approach worse bottom approach worst case empirical examples top evaluation faster bottom evaluation query 
bibliographical notes topic query processing sources 
depth analysis bottom evaluation second volume ullman book 
overview different deductive query evaluation strategies brief description methods 
top bottom strategies discussed relative performance analyzed 
top query evaluation area logic programming general 
vast amount articles various implementation techniques logic programming languages resolution 
ideas modern compilers languages 
chapter dissertation investigated questions concerning design implementation temporal databases databases intended handle inherently infinite information 
particular shown ffl restrictions database schema look natural may lead problems query languages need designed 
ffl restrictions crucial finite representations subclasses infinite databases developed framework constraint databases 
ffl efficient implementation query evaluation techniques finite representations 
discussed directions development ends chapter dissertation 
areas need investigated solutions commercially viable applications technology developed ffl need expressive constraint classes 
run problems termination datalog queries cf 

syntactic subclass datalog queries datalog introduced termination guaranteed 
possible restrict datalog queries classes constraints order achieve termination decidability 
general approach restricting class allowed datalog programs guarantees termination respect constraint class 
ffl important feature practical database system addition aggregation operators language 
fairly difficult add operators clean declarative semantics order query languages 
main approaches solving problem 
logic approach usually addition limited iteration operators contents relations 
complex object approach allows relations nested relations nf enforced 
extension query evaluation order languages appropriate structures extremely hard possible 
current approaches solves problem aggregation satisfactorily 
development area needed 
bibliography abiteboul van den bussche temporal connectives versus explicit timestamps temporal query languages unpublished report 
preliminary version proc 
international workshop temporal databases zurich switzerland 
abiteboul hull foundations databases 
addison wesley 
abramsky hankin interpretation declarative languages 
ellis horwood 
aho sethi ullman compilers principles techniques tools 
addison wesley reading ma 
aho ullman universality data retrieval languages 
proc 
acm symp 
principles programming languages pp 

apt blair walker theory declarative knowledge 
minker 
ed 
foundations deductive databases logic programming pp morgan kaufman los altos ca 
ait kaci warren machine tutorial reconstruction 
mit press 
bancilhon maier sagiv ullman magic sets strange ways implement logic programs 
proc 
acm symposium principles database systems 
bancilhon ramakrishnan amateur recursive query processing strategies 
proc 
acm sigmod 
birkhoff maclane algebra 
macmillan 
berman precise bounds presburger arithmetic reals addition 
proc 
th ieee symposium foundations computer science pp 

chomicki wolper temporal deductive databases 
temporal databases theory design implementation tansel 
editors 
benjamin cummings 
wolper representation infinite temporal data queries 
th acm symposium principles database systems pp 
ben kozen reif complexity elementary algebra geometry 
jcss 
chomicki snodgrass toman querying tsql databases temporal logic 
appear proc 
edbt 
bol underlying search magic templates tabulation 
proc 
international conference logic programming 
chandra harel computable queries relational data bases 
journal computer system sciences 
chandra harel structure complexity relational queries 
journal computer system sciences 
chandra harel horn clause queries generalizations 
logic programming 
chomicki temporal query languages survey 
proc 
international conference temporal logic july bonn germany springer verlag lnai pp 

chomicki history checking dynamic integrity constraints 
ieee international conference data engineering phoenix az 
chomicki efficient checking temporal integrity constraints bounded history encoding 
acm transactions database systems pp 


chomicki nski temporal deductive databases infinite objects 
proc 
th acm symposium principles database systems pp 
chomicki nski finite representation infinite query answers acm transactions database systems pp 

chomicki feasibility checking temporal integrity constraints 
proc 
th acm symposium principles database systems pp 
full version appear jcss 
chomicki toman implementing temporal integrity constraints active dbms 
ieee transactions knowledge data engineering special section temporal real time databases vol 

clifford historical relational data model algebra lifespans 
proceedings international conference data engineering pages los angeles ca february 
clifford tuzhilin completeness historical relational query languages 
acm transactions database systems vol 
pp 

clocksin mellish programming prolog 
springer verlag 
codd relational model data large shared data banks 
comm 
acm 
codd relational completeness database sublanguages 
ed 
courant computer science symposium data base systems pp 
prenticehall 
cousot cousot interpretation frameworks 
logic computation 
enderton mathematical logic 
academic press 
ehrenfeucht application games completeness problem formalized theories 
fund 
math 
ershov mathematical logic 
moscow mir 
ferrante efficient decision procedure theory rational order 
theoretical computer science 
ferrante rackoff 
decision procedure order theory real addition order 
siam comp 
sur les classifications des systemes de relations 
publ 
sci 
univ 
gabbay expressive functional completeness tense logic 
aspects philosophical logic 
gabbay declarative past imperative executable temporal logic interactive systems 
barringer 
ed 
temporal logic specification vol 
pp springer verlag lncs 
gabbay pnueli shelah temporal analysis fairness 
proc 
acm symposium principles programming languages 
gabbay hodkinson reynolds temporal logic 
mathematical foundations computational aspects 
vol 

oxford logic guides oxford science publications 
gabbay temporal logic historical databases 
proc 
international conference vldb 
theory matrices 
new york chelsea pub 

gao warren powerful evaluation strategy clp programs 
proc 
intl 
workshop principles practice constraint programming 
godel 
uber formal der principia mathematica und systeme fur mathematic und physik 
vol 

gunter foundations programming languages mit press cambridge ma 
hardy theory numbers 
oxford university press 
henkin monk tarski cylindric algebras 
north holland 
immerman kozen definability bounded number variables 
information computation pp 
jaffar maher constraint logic programming survey 
logic programming 

jensen snodgrass temporal specialization generalization 
ieee transactions knowledge data engineering 
jaffar lassez constraint logic programming 
proc 
th acm symposium principles programming languages pp 
johnson memoization constraint logic programming 
proc 
intl 
workshop principles practice constraint programming 
kabanza wolper handling infinite temporal data 
journal computer system sciences 
kamp tense logic theory linear order 
phd thesis university california los angeles 
kamp formal properties 
theoria 
kanellakis goldin constraint programming database query languages 
proc 
nd tacs 
kanellakis ramaswamy vitter indexing data models constraints classes 
proc 
acm symposium principles database systems pp 
kanellakis kuper revesz constraint query languages journal computer system sciences 
kemp stuckey analysis constraint query optimization 
proc 
international conference logic programming 
kreisel krivine elimination quantifiers 
elements mathematical logic north holland 
lim stuckey constraint logic programming shell 
plilp 
saake monitoring dynamic integrity constraints temporal logic 
information systems 
lloyd foundations logic programming 
springer verlag 
mecca bonner sequences datalog transducers 
proc 
th acm sigact sigmod sigart symposium principles database systems pp 

mendelson mathematical logic 
princeton van nostrand 
mumick query optimization deductive relational databases 
phd thesis stanford university 
prior time modality 
oxford university press 
ramakrishnan magic templates 
approach logic programs 
logic programming 
reddy loveland presburger arithmetic bounded quantifier alternation 
proc 
acm symp 
theory comp 
renegar computational complexity geometry order theory reals 
journal symbolic computation parts iii revesz closed form datalog queries integer order 
proc 
rd international conference database theory pp springer verlag lncs 
revesz constraint query languages 
phd dissertation brown university 
revesz closed form evaluation datalog queries integer gap order constraints 
theoretical computer science vol 

revesz datalog queries set constraint databases 
proc 
th international conference database theory 
revesz safe stratified datalog integer order programs 
proc 
international conference constraint programming montanari rossi eds springerverlag lncs france september 
revesz constraint query languages 
survey 
unpublished manuscript 
rosenstein linear orderings 
academic press new york 
schmidt structure typed programming languages mit press cambridge ma 
schmidt natural semantics interpretation 
proc 
static analysis symposium springer lncs 
sierpi nski part ii 
snodgrass temporal query language tquel 
acm transactions database systems june 
snodgrass editor 
tsql temporal query language 
kluwer academic publishers pages 
srivastava ramakrishnan revesz constraint objects 
proc 
intl 
workshop principles practice constraint programming 
srivastava ramakrishnan pushing constraint selections 
logic programming 
srivastava ramakrishnan revesz constraint objects 
proc 
nd workshop principles practice constraint programming 
functional completeness rationals 
unpublished bar ilan university ramat gan israel 
stuckey compiling query constraints 
proc 
acm symposium principles database systems 
swift warren analysis slg wam evaluation definite programs 
proc 
international logic programming symposium mit press 
swift warren machine slg resolution definite programs 
proc 
international logic programming symposium mit press 
swift warren chen operational semantics slg evaluation 
tech 
report suny stony brook 
tamaki sato old resolution tabulation 
proc 
rd international conference logic programming 
tansel clifford gadia jajodia segev snodgrass temporal databases 
theory design implementation 
benjamin cummings 
tarski sur les ensembles de nombres fundamenta mathematicae english translation logics semantics metamathematics second edition 
toman chomicki rogers datalog integer periodicity constraints 
proc 
international logic programming symposium mit press 
toman order temporal queries inexpressible temporal logic 
workshop theory constraint databases pods 
tr unl cse 
appear proc 
edbt 
toman top beats bottom constraint extensions datalog 
proc 
international logic programming symposium mit press 
tuzhilin clifford temporal relational algebra basis temporal completeness 
proc 
international conference vldb 
ullman principles database knowledge base systems vol 

computer science systems 
vardi complexity relational query languages 
acm sigact symposium theory computing pp 
vardi temporal fixpoint calculus 
acm symposium principles programming languages 
warren prolog instruction set tech 
report sri international ai center palo alto 
weil basic number theory 
ed 
springer verlag 
williams fourier motzkin elimination extension integer programming problems 
journal combinatorial theory pp 
list publications refereed journal papers 
jan chomicki david toman 
implementing temporal integrity constraints active dbms 
ieee transactions knowledge data engineering special section temporal real time databases vol 
august 

david toman 
implementation techniques prolog 
informa cn syst emy czech 
refereed conference submissions 
david toman damian 
order temporal queries inexpressible temporal logic 
workshop theory constraint databases pods tr unl cse 
appear proc 
edbt 

david toman 
top beats bottom constraint extensions datalog 
proc 
international logic programming symposium mit press 

michael jan chomicki richard snodgrass david toman 
querying tsql databases temporal logic 
appear proc 
edbt 

david toman jan chomicki david rogers 
datalog integer periodicity constraints 
proc 
international logic programming symposium mit press 

david toman jan chomicki 
implementing temporal integrity constraints active dbms 
proc 
ride active database systems houston tx pp 

adriana david toman 
register allocation wam 
proc 
th iclp paris pp mit press cambridge ma 

david toman 
implementation prolog compiler proc 
compilers pp czech 

david toman 
implementation techniques logic programming proc 
pp invited tutorial czech 
david toman 
prolog ai applications proc 
ai pp 

david toman 
implementation freeze wam proc 
lop pp czech english version tr mu brno 

david toman 
prolog wam case study implementation proc 
lop pp 
publications 
david toman 
query evaluation constraint databases 
tutorial proposal second international conference principles practice constraint programming cp 

david toman 
point vs interval temporal query languages 
submitted acm pods 

adriana petr ik david toman jir 
wam efficient implementation logic programming languages final report 
ibm academic initiative research project 


david toman 
operational semantics prolog semantics wam 
ms thesis university brno 
foundations temporal query languages david toman mgr university brno czech republic dissertation submitted partial fulfillment requirements degree doctor philosophy department computing information sciences college engineering kansas state university manhattan kansas temporal databases repositories information dependent time 
major difference standard relational database systems need storing possibly infinite objects time spans 
years numerous proposals introduce time standard relational systems 
unfortunately attempts ad hoc extensions existing database systems query languages tquel tsql 
extensions create problems precise semantics needs developed exists 
survey chomicki clean way defining temporal databases logic proposed 
methodology views temporal databases multi sorted finitely representable order structures 
query languages formulas suitable logics vocabulary structures 
method quite successful existing proposals subsumed approach minor adjustments special cases 
dissertation try address issues connected approach development temporal databases ffl current implementations temporal databases seemingly natural restriction structure relations imposed relations stored database exactly bounded number attributes represent time tsql tquel 
restriction naturally corresponds single dimensional modeling time 
raises obvious question generality solution 
show order case imposing discipline query language affects expressive power rules interesting queries database 
ffl store handle infinite objects time spans 
idea generalized databases encode infinite objects formulas appropriate logic 
generalize common requirements encodings suitable query evaluation 
propose new class infinite objects periodic sets efficient procedures allow deductive queries evaluated objects 
ffl efficiently evaluate queries encodings 
propose new query evaluation procedure combination resolution method proposed logic programs fixed point computation deductive query evaluation 
theoretical complexity bounds experimental measurements show performance gains achieved method 
