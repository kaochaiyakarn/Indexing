formalizing real time scheduling program refinement zhiming liu department mathematics computer science university leicester joseph department computer science university warwick shows feasibility scheduling real time program consisting number parallel processes tasks proved step refinement program specification 
verification step refinement formal methods results real time scheduling theory 
keywords real time program specification refinement schedulability feasibility 
typical real time program required respond external events specified time bounds executed system sufficiently fast 
general external events may occur rate results process program simultaneously execution time fewer processors system active processes scheduling decisions taken allocate processors processes 
schedulability condition scheduler execute real time program system meet deadlines 
deadline assumed timing constraint events time occurrence event subsequent despatch response event 
examine proved real time program schedulable executed particular system scheduler implementation feasible 
program defined abstractly set atomic operations operation enabling condition called guard operation performed true operation enabled 
timing constraints execution operation program specified assigning operation lower time bound upper time bound 
leads real time semantics program different interpretations timing bounds 
interpretation operation performed continuously enabled time units performed continuously enabled time units 
shall call volatile time bound 
interpretation operation performed enabled total time units necessarily continuously similarly performed enabled total time units 
shall call persistent time bound 
volatile bounds widely hmp fs know prior persistent bounds 
time constraints including schedulability described volatile time bounds 
dealing pre emption interruption real time scheduling volatile time bounds requires scheduled operation explicitly divided smaller operations steps execution pre emption occur 
feasibility program scheduler established reasoning step level program 
difficult reason formal methods results scheduling theory refinement framework 
shows kinds timing bounds united single framework reasoning schedulability real time programs 
volatile time bounds describing deadlines persistent time bounds model behaviour real time program pre execution 
program specification verification refinement shall represent programs action system model similar underlying unity programs cm transition systems hmp temporal logic actions tla lam specification verification program properties 
shown section tla expressive full characterization action systems action systems intuitively easier understand value real time system engineers 
action system model program represented action system pair theta consisting initial condition theta finite set atomic operations finite set state variables 
state program mapping associated set values value domain denote value state initial condition theta predicate free variables defines permitted initial states execution start 
atomic operation represented guarded nondeterministic multiple assignment vector state variables vector logical variables order predicate state variables logical variables 
guard true enabled state executed change state state ffl variables assigned values variables remain unchanged ith element ffl predicate satisfied operation get executed satisfiable 
operation shall refer guard body respectively guard operation may omitted constant true 
deterministic assignment special case nondeterministic assignment 
atomicity operations behaviour program represented infinite sequence oe oe oe oe states oe initial state satisfies initial condition theta oe obtained oe stuttering step oe oe executing operation program set behaviours program stuttering closed infinite state sequence oe behaviour program behaviour obtained oe adding deleting finite number stuttering steps 
behaviour terminating infinite suffix stuttering steps 
tla reason action systems models tla lam defined infinite sequences states oe oe oe oe state set state variables 
property program represented formula defines set behaviours action formula boolean valued expression specifies relation values variables execution operation values primed variables execution operation 
interpreted pairs states hs holds variables assigned values state primed variables fx vg assigned values state hs called step hs formulas tla constructed action formulas way 
action formula formula 
satisfied sequence oe program denoted oe hoe oe order state predicate particular action formula primed variables oe satisfies initial state oe oe satisfies oe 
formula 
oe satisfies suffixes oe satisfy 
formula eventually defined satisfied oe suffix oe satisfies 
formulas composed boolean connectives standard semantics 
quantification possible logical variables values fixed states state variables values change state state 
specify stuttering steps execution program define notation action formula vector variables delta unchanged unchanged 
relationship action systems tla defined relatively straightforward way 
syntactic operation action system corresponds equivalence class action formulas 
action formula class pair hs states state variables execution state terminates state iff hs step 
operation translated action formula unchanged representative equivalence class action formulas corresponding variables primed counterparts complement variables program variables action enabled holds 
enabled executed program state changed new values variables related old values way defined substituting leaving values variable outside unchanged 
examples simply omit unchanged part specify operations confusion context simply logical counterpart 
action system program theta delta state transition relation atomic operations exact specification expressed formula pi delta theta formula specifies possible sequences values may taken state variables including internal variables 
existential quantification hide internal variables external safety specification phi delta pi behaviour satisfies phi iff sequence values assigned pi true 
note syntax action systems equivalent internal variables 
possible rewrite specification theta program var theta explicit declaration internal variables 
shall leave treatment internal variable declarations informal 
imposing fairness properties formulas pi phi safety properties satisfied infinite behaviour iff satisfied finite prefix behaviour 
safety properties allow behaviours system performs correctly leaves values variables unchanged 
behaviours undesirable distributed systems ruled adding fairness properties 
action formula state predicate enabled true state exists state step 
vector variables hai delta hai unchanged weak fairness wf delta hai strong fairness sf delta ai weak fairness condition wf says point behaviour hai disabled infinitely hai step eventually occur 
strong fairness condition wf says point behaviour hai enabled finitely hai step eventually occur 
safety specifications pi phi usually strengthened conjoining fairness properties 
canonical forms exact external specifications respectively psi delta theta delta theta fx tuple internal variables action formula defines state relation set variables conjunction fairness properties action formulas defines fairness requirement action system specification property described formula prove satisfies property prove tla validity implication example liveness progress property form read leads defined delta 
prove satisfies property just prove 
refinement mapping relation characterises refinement program correctly implements theta theta canonical specifications respectively fx fy refinement relation formalised iff refinement relation proved implication 
prove implication define state functions terms variables prove implication psi psi psi obtained psi substituting free occurrences psi collection state functions called refinement mapping 
shown validity implication imply existence refinement mapping 
general refinement mappings modify specifications adding dummy variables 
specification refinement real time programs deadlines define timing constraints program providing lower upper bounds execution operations 
time represented non negative real numbers infinity 
atomic operation lower bound upper bound 
timing bounds operation volatile persistent 
real time program represented triple hp ui untimed program defined previous section functions atomic operations time domain operation define exact specification pi real time program introduce distinguished state variable represent time operation advance time assumptions hmp ffl time starts initially 
ffl time decreases methods results apply discrete time domains 
ffl time diverges 
time divergence called non zeno property ensures finite number operations performed finite interval time 
assumptions combined specify real time evolution rt delta assume program state time change simultaneously program state changed program operations 
rewrite pi pi delta theta conjunction pi rt specifies interleaving program operations time evolution 
program operations constrained lower bound upper bound conditions 
specify volatile lower bound operation introduce volatile timer auxiliary state variable 
enabled state disabled executed assigned clock time current time plus units time delta specify persistent lower bound operation introduce persistent timer auxiliary state variable 
persistent delta taken enabled taken gamma disabled operation executed time reaches clock time mintime delta true 
conjunction timer mintime timer volatile persistent persistent specifies lower bound operation lower bound condition conjunction lower bound conditions operations denoted lb 
similarly specify upper bound operation timer defined timer obtained substitution definition timer 
operation executed passes clock time maxtime delta formula true 
conjunction timer maxtime gives upper bound specification operation conjunction upper bound specifications operations specification ub upper bound condition 
time bound specification program conjunction lb ub 
real time executions exactly specified pi delta pi rt hiding internal variables auxiliary timers denoted timer gives canonical specification phi delta timer pi prove real time program satisfies implements timing property ffi delta ffi prove implication phi ffi 
refinement relation realtime programs proved implication phi phi refinement mapping 
model parallel execution program partition operations sets processes shared state variable operations different processes private state variable operations process 
operations executed parallel process share variables shared variables accessed mutual exclusion 
concurrent system processes communicate executing operations shared variables 
results scheduling theory assume process concurrent program sequential atomic action process enabled time 
scheduling processes real time program implemented system assigning processes set mg processors executing scheduler 
implementation correct iff meets functional requirements defined operations timing constraints defined time bound functions add scheduling primitives programming specification language hmp hoo program scheduler modelled specified single semantic model correctness proved separately 
application scheduler program set processors described transformation program schedulability program determined reasoning transformed scheduled program 
transformational approach separation program scheduler helps preserve independence program scheduling decisions 
programmer need take account system scheduler program ready implemented 
allows investigation feasibility program different schedulers effect scheduler different programs 
feasibility implementation program proved considering scheduling policy low level implementation details 
shall describe functional timing aspects scheduler determine affect execution untimed scheduling assume scheduler allocates process execution processor submit operation removes process processor retrieve operation 
shall say process processor process allocated processor 
atomic operation process executed process processor operation enabled guard holds 
boolean variable run ik true process processor running true process processors running delta run ik effect scheduling represented transformation atomic operation process transformed strengthening guards boolean variable running denote transformed operation 
running gamma 
logical counterpart running process executed processor operations enabled 
scheduler functionally described untimed program initial condition idle guarantees process processor submit retrieve operations modify variables run ik generic description scheduler applied program system number processors 
program set processors left parameters replaced respectively concrete program definition specific system 
scheduling set processors described transformation 
assuming initially process processor initial condition scheduled program conjunction initial conditions idle theta 
operations formed union operations execution interleaved 
execution state sequence oe 
initial state oe satisfies initial conditions theta idle 
step oe oe conditions holds oe oe oe produced oe operation oe produced execution operation process guard predicate running true oe denote set variables modified set executions specified pi idle theta idle delta running assume change state pi pi pi seen holds operation pi pi 
pi implies pi 
shows refines preserves functional properties timed scheduling timing properties executions depend number processors execution speed processors 
assume hard execution time needed atomic operation processor lies real interval execution processor starts time finishes time total execution time interval lies interval 
functions define time bounds operations realtime program delta hg delta delta 
guarantee implementation satisfies real time deadlines computational overhead submit retrieve operations bounded 
scheduler time bounds operation real time scheduler real time scheduled program delta hi functions respectively union functions union words execution speed processors timing properties scheduler determine timing properties scheduled program 
operations scheduler interrupted timing bounds operations volatile 
execution process operation may pre empted priority pre emptive scheduler 
timing bounds operations persistent general 
concurrent program pre empted operation may disabled execution operations processes 
pre empted process resumed pre empted disabled operation executed enabled operation process selected execution 
reason persistent timer operation slightly different section 
persistent ffi timer operation process ffi defined follows persistent ffi delta ffi ffi taken running ffi disabled running gamma preempted fourth fifth lines formula guarantee timer persistent pre empted reset disabled execution completed 
definition pi exact specification timed scheduled program pi pi pi rt pi pi functions set set set set set set disjoint union function set set set equals elements set elements set correctness timed scheduled program determined respect specification refer variables modified scheduler variables hidden canonical specification phi delta phi phi shall specification section consider ways applying transformational approach real time scheduling 
proving timing properties scheduled programs consider implementation real time program real time scheduler satisfies property 
proof implementation satisfies high level timing property initial basis proofs detailed low level properties established 
easily shown oe oe assumption disjoint satisfies property phi implies satisfies represented proof rule phi treating effect scheduling transformation program specification allows specification scheduler policy prove timing properties implementation real time program 
feasibility definition verification timed scheduled program feasible phi refinement mapping implication proved phi phi notice correctness scheduler defined respect specification scheduling policy feasibility relates specification scheduled program requires time bounds operations met 
assuming feasibility proved rule implication phi phi formula manipulated steps refinement mapping 
step introduce auxiliary dummy timers corresponding timers understood allowing scheduler copy timers fh ag set auxiliary variables defined formulas timer timer respectively timer volatile bounds persistent persistent 
shall assume time bounds volatile 
delta timer timer equivalent phi phi step define refinement mapping 
recall internal variables assumed refinement mapping states timer states timer defined follows 
timer timer timer timer delta pi proved proving pi step discard identical substitutions 
recall pi pi rt 
obviously rt rt pi pi 
pi implies pi turn implies pi 
rt pi discarded right hand side implication 
step discard operations timers 
timer mintime timer maxtime appears left hand side remains proved implication holds operation maxtime mintime feasibility real time program proved rule 
maxtime mintime phi notice maxtime mintime contain primed state variables 
rules proving invariant properties directly establish premises rule 
provide rules introducing invariants 
prove premise rule rule 
maxtime symmetry premise rule running mintime converted normal form conjunction safety property liveness property lam theta sets variables theta state predicate action time divergence property 
formula denoted omega state predicate action occurrence state variable replaced primed version 
invariant omega proved rule theta initially holds step transition preserves omega scheduling open systems model programs far assumed real time program implements specification closed system values supplied program initial values variables executing nondeterministic input operation 
cases program linked external environment receives data send responses 
appearance inputs follows timing pattern example periodic aperiodic repetition 
open system delta consists program interacts environment set variables union sets local variables set interface variables interact 
program consist initial predicate theta local variables set atomic operations program variables partitioned processes 
environment consist initial predicate theta environment variables set atomic operations variables action formula defines state transitions changes values interface variables 
required ne define pi delta theta phi delta pi pi delta theta ne phi delta pi specification phi open system defines condition system guarantees property phi environment satisfies assumption phi 
phi delta phi phi conjunction phi phi describes closed system consisting environment theta theta ne vo program refines implements program environment iff phi phi phi phi reduces phi phi phi program environment treated respectively real time programs hp le ue time global program environment need advanced 
choose program advance time define psi delta timer pi real time open system specified phi delta psi phi real time environment implementation real time program scheduler set processors described transformation delta pi theta idle vp denotes variables may changed scheduler delta feasibility implementation relies proving implication psi phi psi phi psi phi phi easy see rules apply open systems 
canonical form open real time specification differs slightly sufficient purposes shall considering problem composing open systems 
example fixed priority scheduling preemption consider open system program consists independent processes tasks represented atomic actions invoked periodically environment ae period specification system specify system tla inv com integer variables representing number invocations completions task system specification theta delta inv com delta inv inv delta inv com com com delta com com ae period invocation ae basic requirement system invocation task completed invocation task phi inv com inv gamma rules proving invariant tla proved implication holds ae specification scheduling policy system implemented single processor preemptive fixed priority scheduler assume higher priority scheduling overhead 
scheduler denoted hs ui specified follows inv com sch delta idle running running running running sch sch sch time process running processor delta running running specification various scheduling policies 
feasibility computation time task interval assume ae non negative integers scheduling theory bw define recurrence relation worst case response time completion time task gamma dr ae theta initial value lim proved scheduling theory implementation program scheduler processor feasible iff condition shown necessary finding execution task misses deadline condition hold 
prove formally condition sufficient need prove refinement 
theorem program scheduler processor provided equivalent showing implication holds condition 
pi pi pi pi pi refinement mapping defined section 
giving proof discuss persistent timer predict completion time invocation task considering invocation 
consider time completion invocation task com 
worst case tasks time units computation time time spent executing higher priority processes comp delta gamma com theta gamma inv gamma com theta gamma gamma gamma gamma time spent far invocation formula comp gamma inv theta gamma gamma inv gamma com theta gamma assume ffi time spent 
comp ffi 
persistent time tasks higher priorities executed comp gamma ffi comp predicts cumulative time needed complete exceed gamma ffi time may divided smaller units sum invocation completed deadline exceed equal completion discussion shows need prove left hand side lhs implication predicate invariant com comp general time invocation completed gamma records time value time current invocation time set changed 
define comp comp delta gamma inv theta ae gamma gamma ae theta gamma gamma inv gamma com theta gamma leads lemma implies theorem 
lemma left hand side lns invariants delta com inv comp delta com inv comp gamma dnow ae theta delta com inv gamma dnow ae theta delta inv gamma com inv proof easy check invariants hold 
assume hold gamma 
prove hold prove special case invocation proof general case similar delta com comp delta inv gamma com inv delta com comp gamma dnow ae theta delta com gamma dnow ae theta comp gamma inv theta gamma gamma inv gamma com theta gamma initially holds analyse possible state transitions allowed lhs may change states variables occurring comp 
case 
gamma delta com inv inv unchanged case com comp gamma gamma easy prove lhs gamma gamma 
case 
gamma consider delta com com com unchanged induction assumption inv gamma com inv know equal com gamma inv theta gamma inv gamma com theta gamma holds 
case 
gamma define delta com com inv running gamma unchanged delta com inv gamma note inv gamma com iff com inv induction assumption com gamma gamma inv theta gamma inv gamma com theta gamma gamma gamma com gamma inv theta gamma gamma inv gamma com theta gamma holds 
case 
consider delta com running unchanged defined case taken account 
argument case leads com gamma inv theta gamma gamma inv gamma com theta gamma holds 
proof follows fact theta ae iff inv com inv gamma inv dnow ae theta ae ae prove invariant note maxtime forces comp allowed transition assume comp inequation comp gamma comp ae theta gamma dr ae theta general cases proved 
assumption guarantee deadline task met 
ensures holds 
notice proof gamma induction assumption 
proved lemma proof theorem follows straightforward way lemma 
example deals independent periodic tasks fixed priorities 
method scheduling analysis theory tasks extended deal communicating tasks 
example tasks may communicate asynchronously protected shared object pso bw 
tasks may periodic sporadic 
scheduler ceiling priorities worst response time task calculated recurrence relation gamma ae theta worst blocking time task lower priority maximum variation release called jitter 
feasibility analysis fault tolerant real time tasks bdp worst response time task calculated recurrence relation gamma ae theta theta maxfc ig minimum time occurrences faults 
formal method scheduling analysis section extended similar way 
allow combine previous fault tolerance real time lj lj provide powerful framework formally dealing real time program refinement fault tolerance schedulability single consistent framework 
formal verification functional timing properties real time program requires logical framework properties specified reasoned 
practical cases programs executed scheduler actions control program execution timing properties 
scheduling theory provides powerful techniques determining timing properties restricted class real time programs provide means verifying functional properties 
methods augmented traditional program verification techniques different analytical framework making hard relate results rigorous way 
particularly important mechanized verification performed program properties certified necessary safety critical applications 
previous showed schedulability real time program established logical framework similar 
important observation simplify verification useful reduce number operations specifying high level possible 
accurate verification timing properties necessary fine level granularity time bounds operation deadline require specifying operations low level possible pre emption precisely modelled timing properties related obtained scheduling theory 
address issue providing kinds timers persistent timers required continuously enabled volatile timers sum duration enabled 
volatile timers allows timing effects lower level operations pre emption considered abstractly higher level 
longer matters exactly operation pre empted important time executed pre emption time pre empted 
operation may pre empted number times single volatile timer record timing properties 
kinds timers solves problem cause major restriction application formal verification methods validation real time programs 
feasible automated verification programs specification level allowing timing properties considered details implementation finalized 
naturally implementation complete scheduling analysis required validate provide independent certification timing properties 
method independent programming language 
program scheduler specifications refined feasibility correctness preserved step 
great advantage proving feasibility require code program developed 
approaches formalizing real time scheduling 
duration calculus zhou zz separately specified scheduler program 
duration calculus moment powerful verification tools proving program refinement 
currently undergoing tools lr 
lz case study scheduling oriented model real time systems called tam 
approach tam suffers drawbacks 
timed process algebraic framework ccs jj deals dynamic scheduling presence faults modelling resources schedulers processes 
event process algebras tend different syntax traditional programming languages modelling somewhat unnatural specification verification real time scheduling complicated 
dealing schedulability analysis pre approach difficulties 
anders ravn gavin lowe comments suggestions earlier drafts 
abadi lamport 
existence refinement mapping 
proc 
rd ieee symposium logic computer science 
abadi lamport 
old fashioned recipe real time 
de rover de bakker huizing rozenberg editors real time theory practice lecture notes computer science 
springer verlag 
bdp burns davis 
feasibility analysis fault tolerant real time tasks 
technical report department computer science university york 
bw burns wellings 
advanced fixed priority scheduling 
joseph editor realtime systems specification verification analysis pages 
prentice hall 
cm chandy misra 
parallel program design foundation 
addison wesley publishing 
fs fix schneider 
reason programs exploiting environment 
technical report tr department computer science cornell university ithaca new york 
hmp henzinger manna pnueli 
temporal proof methodologies real time systems 
proceedings th acm annual symposium principles programming languages pages 
hoo 
specification compositional verification real time systems lncs 
springer verlag 
jj joseph 
dynamic scheduling presence faults specification verification 
jonsson editor proc 
rd international symposium formal techniques real time fault tolerant systems lecture notes computer science pages 
springer verlag 
lam lamport 
temporal logic actions 
acm transactions programming languages systems 
lj liu joseph 
specifying verifying recovery asynchronous communicating systems 
editor formal techniques real time fault tolerant systems pages 
kluwer academic publishers 
lj liu joseph 
verification fault tolerance real time 
proceedings th annual international symposium fault tolerant computing pages 
ieee computer society 
liu joseph 
verification schedulability 
formal aspects computing 
lr liu ravn 
link duration calculus timed transition systems 
technical report department maths computer science university leicester 
lz lowe 
refinement complex systems case study 
technical report prg tr oxford university computing laboratory 
zhou hoare ravn 
calculus durations 
information processing letters december 
zhou hansen ravn rischel 
duration specifications shared processors 
editor formal techniques real time fault tolerant systems lecture notes computer science 
springer verlag january 
zz zhang zhou 
formal proof deadline driven scheduler 

de roever editors formal techniques real time fault tolerant systems lecture notes computer science pages 
springer verlag 
