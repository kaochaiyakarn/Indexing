generalizing generalized tries november revised february ralf hinze institut fur informatik iii universitat bonn bonn germany mail ralf informatik uni bonn de trie search tree scheme employs structure search keys organize information 
tries originally devised means represent collection records indexed strings fixed alphabet 
wadsworth connelly morris generalized concept permit indexing elements arbitrary monomorphic datatype 
go step define tries operations tries generically arbitrary order polymorphic datatypes 
derivation techniques developed context polytypic programming 
known implementation generalized tries nested datatypes polymorphic recursion needed 
implementing tries polymorphic datatypes places greater demands type system requires rank type signatures higher order polymorphic nested datatypes 
despite requirements definition generalized tries polymorphic datatypes surprisingly simple due framework polytypic programming 
generalizations dangerous 
alexandre dumas concept trie introduced thue means represent set strings see knuth 
simplest form trie multiway branching tree edge labelled character 
example set strings fear earl east easy represented trie depicted right 
searching trie starts root proceeds traversing edge matches character traversing edge matches second character forth 
search key member represented set search stops node marked marked nodes drawn filled circles right 
tries represent finite maps 
case marked nodes additionally contain values associated strings 
interestingly move sets finite maps mere variation theme 
shall see essential development 
hinze level trie seen composition finite maps 
collection edges descending node constitutes finite map sending character trie 
interpretation mind relatively straightforward devise implementation string indexed tries 
concreteness programs functional programming language haskell peyton jones 
strings defined datatype data str nil cons char str represent string indexed tries follows 
data component constructor contains value associated nil type nil may domain finite map 
case component equals second component corresponds edge map 
keep example manageable assume suitable data structure associated look function predefined 
lookup non empty string say cons lookup edge map obtaining trie recursively searched str nil tc error nil just tc cons tn tc ffi tc wadsworth connelly morris generalized concept trie permit indexing elements arbitrary monomorphic datatype 
definition gives clue suitable generalization look trie tn tc contains finite map constructor datatype str lookup cons look functions components simply composed 
type constructor seen implementing finite maps unit datatype 
generally datatype constructors corresponding trie components 
lookup constructor components select corresponding finite map compose look functions appropriate types 
illustrate consider datatype external search trees 
data bin leaf str node bin char bin trie external search trees data type instance called nested datatype nest short 
term nested datatype coined bird meertens characterizes polymorphic datatypes definition involves recursive calls example substitution instances defined type 
functions operating nested datatypes known generalizing generalized tries require non schematic form recursion called polymorphic recursion mycroft 
look function external search trees may serve example 
bin leaf tl tn tl node tl tn ffi ffi tn looking node involves recursive calls 
second type bin substitution instance declared type 
haskell allows polymorphic recursion explicit type signature provided function 
rationale restriction type inference presence polymorphic recursion undecidable henglein 
note absolutely necessary parametric respect codomain finite maps 
restricted type bin fixed type definition longer type check 
explains construction finite set abstraction 
discussion clear define tries arbitrary monomorphic datatypes 
go step show generalize concept arbitrary order polymorphic datatypes 
answer particular intriguing question generalized trie nested datatype looks 
note question theoretical practical interest 
number data structures trees red black trees shown expressible nested declarations 
bird paterson nested datatype expressing de bruijn notation 
look structure de bruijn terms required say implement common subexpression elimination confronted problem constructing generalized tries nested datatype 
develop generalized tries polymorphic datatypes employ framework polytypic programming 
short generic polytypic function defined induction structure types 
simple example polytypic function flatten traverses element collects elements type left right list 
function flatten sensibly defined polymorphic type usually tiresome routine matter 
polytypic programming language enables user program flatten times 
specialization flatten concrete instances handled automatically system 
polytypic programming surprisingly simple 
companion hinze show suffices define polytypic function predefined types type variables sums products 
information sufficient specialize polytypic function arbitrary datatypes including mutually recursive nested datatypes 
generalized tries particularly interesting application polytypic programming 
central insight trie considered type indexed datatype 
possible define tries operations tries generically hinze arbitrary polymorphic datatypes 
necessary prerequisites hand know define tries sums products 
trie sum product tries trie product composition tries 
extension arbitrary datatypes uniquely defined 
seen nested datatypes polymorphic recursion necessary implementation generalized tries 
implementing tries polymorphic datatypes especially nested datatypes places greater demands type system requires rank type signatures mccracken higher order polymorphic datatypes jones higher order polymorphic nests 
fortunately major haskell system provide necessary extensions 
rest structured follows 
section briefly review theoretical background polytypic programming 
detailed account hinze 
section applies technique implement finite map abstraction generalized tries 
section discusses variations theme 
section reviews related points direction 
polytypic programming primer datatypes polytypic function parameterised datatype 
polytypic programming primer starts brief investigation structure types 
definitions serve running examples 
data list nil cons list data bintree leaf node bintree bintree data fork fork data perfect null succ perfect fork data sequ empty zero sequ fork sequ fork meaning datatypes nutshell equation defines ubiquitous datatype polymorphic lists bintree encompasses external binary search trees 
types perfect sequ examples nested datatypes perfect comprises perfect binary leaf trees sequ implements binary random access lists okasaki 
definitions auxiliary datatype fork elements may interpreted internal nodes 
haskell data construct combines features single coherent form sums products recursion 
conventional notation sums theta products omitting constructor names obtain recursion equations 
list theta list bintree bintree theta theta bintree fork theta perfect perfect fork sequ sequ fork theta sequ fork generalizing generalized tries list theta theta theta theta theta perfect fig 

types interpreted infinite type expressions 
treat theta datatype declarations 
data data inl inr data theta central idea polytypic programming set types set type expressions modelled datatype 
assuming fixed set type variables fa set primitive type constructors int thetag type expressions seen defined grammar 
type denotes application ary type constructor types 
omit parenthesis 
write similarly theta abbreviate defining unary type constructors 
question remains recursive types modelled 
answer probably comes surprise experienced haskell programmer recursive types modelled infinite type expressions 
displays infinite type expressions defined equations list perfect polytypic definitions polytypic function defined induction structure types 
general definition takes form 
poly poly type parameter written angle brackets distinguish ordinary parameters 
ary type constructor poly specified furthermore equation primitive type constructor hinze example function flatten structure defined follows 
inl inr theta equations specify action flatten nullary type constructors flatten int third equation defines flatten 
flatten flatten theta flatten case inr flatten theta information sufficient define unique function unary type expression courcelle 
course may infinite usually require types interpreted complete partial orders functions continuous functions 
conditions usually met 
infinite type expressions index sets polytypic functions distinguishes approach previous ones jeuring jansson jansson jeuring initial algebra semantics datatypes 
briefly approach major advantages simpler programmer consider cases general covers order polymorphic datatypes 
refer interested reader hinze detailed account pros cons 
specializing polytypic definitions main purpose polytypic programming system specialize polytypic function different instances unfortunately specialization inductive definition directly 
consider attempt specialize ai ai perfect fork poly poly fork poly poly perfect fork fork poly poly poly ai fork fork define ai require fork 
probably clear general hope obtain finite representation generalizing generalized tries way 
base specialization representation types datatype declarations necessity finite 
exhibit structure datatype declarations clearly shall rewrite functor equations 
functor expression arity grammar 
pi delta pi denote ary projection functor selecting th component 
familiar names id pi fst pi snd pi elements predefined functors arity int thetag 
expression delta denotes composition ary functor functors arity omit parenthesis write kt delta 
write delta similarly theta datatype definitions section rewritten functor equations 
list id theta list bintree fst bintree theta snd theta bintree fork id theta id perfect id perfect delta fork sequ sequ delta fork id theta sequ delta fork essence functor equations written compositional point free style data definitions written applicative pointwise style 
central idea define arity ary function poly hfi satisfying poly hfi function follow type ary functor mapping types likewise poly hfi ary function mapping polytypic functions shown definition satisfies condition poly hfi theta delta delta delta theta poly pi poly hf poly poly hf delta poly hfi 
poly hg poly hg th projection function denotes ary composition defined 

note 
ffi 
furthermore note definition poly hfi inductive structure functor expressions 
level view poly interpretation functor expressions pi interpreted poly delta 
hinze setting define poly terms poly poly hfi poly poly necessary prerequisites hand define specialization polytypic function instance assume type constructor defined system equations hf fm equation ary type constructor function definition form poly hf poly generated 
expression poly inductive definition additionally setting poly hf poly poly new function symbol 
defining equation poly poly poly poly poly added 
apply framework specialize perfect polymorphic type auxiliary functions flatten hfi take polymorphic functions polymorphic functions 
instance flatten hf 
words flatten hf rank type signature mccracken 
specialization proceeds entirely mechanically 
original constructor names abbreviating type names letter obtain perfect flatten flatten 
fork flatten fork flatten 
perfect flatten null flatten succ flatten flatten flattening perfect tree operates stages recursing flatten constructs tailor flattening function flatten type fork eventually applied base case 

unfortunately definitions pass hugs ghc type checker accept rank type signatures 
reason haskell provides limited form type constructor polymorphism 
consider subexpression flatten equation 
type fork unifiable expected type 
haskell deliberately omits type abstractions language type constructors jones instantiate fork 
fortunately way dilemma 
assign types flatten flatten flatten 
fork flatten 
perfect definitions type check 
trick works long definition generalizing generalized tries involve polymorphic recursion section get know polytypic function polymorphically recursive 
tries generically section apply framework polytypic programming implement generalized tries generically order polymorphic datatypes 
mentioned basic idea generalized tries considered type indexed datatype 
put idea concrete terms define datatype map hi assigns type constructor kind type constructor kind type represents set finite maps representation implement operations 
theta theta 

signature deviates slightly look function returns value type able signal key unbound 
functions take argument called combining function applied bindings key 
typically combining form fst snd finite maps type int addition may sensible choice 
interestingly see combining function convenient feature user necessary defining generically types 
type indexed tries mathematically speaking generalized tries isomorphisms known laws exponentials 
fin fin fin theta fin theta fin fin fin represents set finite maps fin isomorphisms rewritten defining equations 
patricia dict theta theta delta hinze assume existence suitable library implementing finite maps integer keys 
library instance data structure known patricia tree okasaki gill 
data structure fits particularly current setting patricia trees variety tries 
clarity qualified names referring entities defined hypothetical module patricia building techniques developed section specialize instance functor arity define ary higher order functor map hfi 
instance map 
type constructor map hf generalized trie polymorphic datatype 
takes argument generalized trie base type say yields generalized trie may come surprise framework specializing type indexed functions applicable type indexed datatypes 
reason quite simple definition poly hfi requires operations projection composition 
operations available world functors higher order functors 
specialize map hfi datatypes listed section 
better readability abbreviate type names letter omit arity functors write map list theta delta mapb theta mapb delta delta mapb mapf delta mapp theta mapp mapf maps theta maps mapf theta delta maps mapf haskell permits definition higher order polymorphic datatypes higher order functors directly coded datatypes 
bring equations applicative form 
data data mapb mapb mapb types polymorphic variants defined str list char mapb bin bintree str char 
things generalizing generalized tries interesting consider nested datatypes 
data mapf data mapp mapp mapf data maps tries maps mapf maps mapf generalized trie nested datatype higher order polymorphic nested datatype 
nest higher order polymorphic type parameter instantiated recursive call ranges type constructors kind 
contrast mapb order polymorphic nest instantiated type parameter kind quite easy produce generalized tries higher order nests 
change type sequ third constructor sequ fork third component tries type maps mapf maps consequently higher order nest 
empty singleton tries empty trie patricia empty theta definition illustrates interesting aspects programming generalized tries 
polymorphic type necessary definition 
consider equation theta type defined terms type means polymorphically 
words polymorphic recursion 
contrast definition section type checks type restricted fixed type polymorphic type empty hf takes polymorphic values polymorphic values 
instance empty hf 
maphf ki obtain signature expressible haskell employ specification map hf maphf map hf additionally setting fresh type variable 
empty hf 
map hf hinze take look examples 
mapf mapp second function illustrates polymorphic parameter type element 
definition employs higher order polymorphic recursion recursive call type mapf mapp mapf substitution instance declared type 
function illustrates point implementation generalized tries relies essential way lazy evaluation 
example consider empty trie perfect int represented infinite tree abbreviating patricia empty section shall discuss slightly modified representation generalized tries avoids problem 
singleton trie contains single binding defined follows 
theta just patricia single inl inr theta definition interesting falls back third fourth equation 
necessitates single hf parameterised 
obtain type signature single hf 
theta 
theta map hf specialize polytypic function lists perfect trees 
improve readability henceforth instances type signatures mandatory 
nil just cons singlef fork note hugs ghc syntax universal quantification peyton jones forces write 

generalizing generalized tries null succ singlef function singlef illustrates mechanically generated definitions slightly improved 
definition fork involve sums singlef require argument safely removed 
lookup look function implements scheme discussed 
patricia lookup inl inr theta ft sums look function selects appropriate map products composes look functions components 
result type composition amounts monad kleisli composition bird 
defining fa may write equation succinctly theta specializing concrete instances probably matter routine 
lookup hf type signature 
lookup hf 
map hf lists perfect trees obtain nil tn tc tn cons tn tc tc fork tf tf null ts tc ts succ ts tc tc note generalizes defined ffi just definition employs recursion scheme flatten recursing constructs tailor look function type fork mapf applied base case 
hinze inserting merging insertion defined terms 
theta 
note efficient implementation singleton tries general infinite trees 
implies running time proportional size inserted element expect 
problem vanishes employ alternative representation generalized tries introduced section 
merging tries surprisingly simple 
auxiliary function combining values type combine 
combine combine just just combine just just combine just just just define follows 

combine patricia merge theta interesting equation 
tries type theta 
merge supply combining function type moment reflection reveals desired combining function 
functional composition write equation quite succinctly theta ffi definition shows necessary implement operations general needed 
simplified type able give defining equation theta complete picture specialize merging operation lists perfect trees 
merge hf type signature 
merge hf 


map hf map hf map hf generalizing generalized tries different instances merge hf surprisingly concise 
tn tc tn tc combine tn tn tc tc tf tf tf tf ts tc ts tc ts ts tc tc variations theme spotted tries representation tries defined previous section major drawbacks relies essential way lazy evaluation ii inefficient 
disadvantages roots representation tries sums 
trie pair tries irrespective trie empty 
suggests devise special representation empty trie 
technically achieved called spot products connelly lockwood morris 
data theta ffl spot pair spot products known optional pairs 
changing definition theta ffl represent empty trie constant space 
spot representation course longer unique 
require empty trie sums represented spot maintaining invariant implementation trivial tries shrink 
situation different additionally supplied operation removing bindings trie 
remaining operations modified accordingly 
inl pair inr pair spot inl pair inr pair spot spot pair pair pair contains complete code generalized tries binary random access lists building representation 
remarks appropriate 
hinze generalized tries polymorphic binary random access lists data maps spots tries maps mapf maps mapf maps spots singles 
theta sequ theta maps singles empty tries just singles zero tries singles singlef singles tries singles singlef lookups sequ maps lookups empty tries te tz te lookups zero tries te tz lookups tz lookups tries te tz lookups merges 


maps maps maps merges spots merges spots merges tries te tz tries te tz tries combine te te merges tz tz merges generalized tries binary random access lists integers type maps patricia dict sequ int theta singles patricia empty patricia single sequ int lookups patricia lookup sequ int theta 

merges patricia merge fig 

generalized tries binary random access lists 
generalizing generalized tries datatype maps functor equation maps theta ffl maps mapf theta ffl delta maps mapf simplicity interpret theta ffl theta ffl type optional triples nested optional pairs 
data theta ffl theta ffl spot triple definition simplified omitting parameter required 
note listed implementation generalized tries datatype fork fork definition involve sums code identical section 
skinny tries extending idea previous section step additionally devise special representation singleton tries 
data ffl theta ffl ffl theta ffl theta ffl advantage need refer 
inl inr representation furthermore bit space economical 
potential disadvantage increased number cases consider defining 
inl inl inl inl remaining cases defined accordingly 
related knuth attributes idea trie thue introduced strings contain adjacent repeated substrings 
de la recommended tries computer searching 
generalization tries strings elements arbitrary datatype discovered wadsworth independently 
connelly morris formalized concept trie categorical setting showed trie functor corresponding look function hinze natural transformation 
interestingly despite framework category theory base development sorted signatures definitions somewhat unwieldy 
shows construction generalized tries simpler replace concept sorted signature categorical counterpart concept functor 
implementation generalized tries okasaki textbook functional data structures 
tries polymorphic types lists binary trees represented standard ml functors 
approach works regular datatypes fails nested datatypes perfect sequ 
case higher order polymorphic datatypes indispensable 
said direction suggests generalize tries arbitrary higher order polymorphic datatypes 
give impression extensions consider standard definition rose trees 
data rose branch list rose trie data mk trier mk mk abstracting list functor away obtain generalization rose trees 
data grose grose trie rose generalized similar way 
data mt mk mk mt mt mk note grose type constructor kind 
trie kind 
systematics applied generalize operations operations 
currently author working suitable extension framework allows define polytypic functions generically datatypes expressible haskell 
due chris okasaki helpful comments earlier draft 
bird richard 

functional programming haskell 
nd edn 
london prentice hall europe 
bird richard meertens lambert 

nested datatypes 
pages jeuring 
ed fourth international conference mathematics program construction mpc sweden 
lecture notes computer science vol 

springer verlag 
bird richard paterson ross 

de bruijn notation nested datatype 
journal functional programming 
appear 
generalizing generalized tries connelly richard lockwood morris 

generalization trie data structure 
mathematical structures computer science 
courcelle bruno 

fundamental properties infinite trees 
theoretical computer science 
de la ren 

file searching variable length keys 
pages proc 
western joint computer conference vol 

afips press 
victor anne 

simple efficient flexible implementation flexible arrays 
pages third international conference mathematics program construction mpc 
lecture notes computer science vol 

springer verlag 
henglein fritz 

type inference polymorphic recursion 
acm transactions programming languages systems 
hinze ralf 
february 
polytypic programming ease 
tech 
rept 
iai tr 
institut fur informatik iii universitat bonn 
jansson patrik jeuring johan 

polyp polytypic programming language extension 
pages conf 
record th acm sigplan sigact symp 
principles programming languages popl paris france 
new york acm press 
jeuring johan jansson patrik 

polytypic programming 
pages launchbury meijer sheard 
eds tutorial text nd international school advanced functional programming wa usa 
lecture notes computer science vol 

springer verlag 
jones mark 

functional programming overloading higher order polymorphism 
pages international spring school advanced functional programming techniques 
lecture notes computer science vol 

springer verlag 
knuth donald 

art computer programming volume sorting searching 
nd edn 
addison wesley publishing 
mccracken nancy jean 

typechecking programs implicit type structure 
pages kahn gilles macqueen david plotkin gordon 
eds semantics data types international symposium sophia antipolis france 
lecture notes computer science vol 

berlin springer verlag 
mycroft alan 

polymorphic type schemes recursive definitions 
paul robinet 
eds international symposium programming th colloquium toulouse 
lncs 
okasaki chris 

purely functional data structures 
cambridge university press 
okasaki chris gill andy 

fast mergeable integer maps 
pages workshop ml 
peyton jones simon 

explicit quantification haskell 
research microsoft com users simonpj haskell quantification 
wadsworth 

recursive type operators type schemes 
bulletin eatcs 
talk nd international workshop semantics programming languages bad germany march 
