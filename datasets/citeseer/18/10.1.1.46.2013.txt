formalizing automata theory finite automata robert constable paul jackson pavel juan uribe cornell university july article world wide web display computer checked proofs experiment formalization computational mathematics 
readers asked judge formalization adds value comparison careful informal account 
topic state minimization finite automata theory 
follow account hopcroft ullman book formal languages relation automata state minimization corollary myhill nerode theorem 
book constitutes compact elegant published accounts 
sets high standards compare formalization 
myhill nerode theorem chosen illustrates points critical formalization computational mathematics especially extraction important algorithm proof method knowing algorithm correct 
forces treat quotient sets computationally 
theorem proving methodology concept tactics pioneered robin milner 
theorem prover nuprl new pearl companion hol descendent lcf system milner gordon wadsworth 
supports constructive reasoning computation 
key words phrases automata constructivity congruence equivalence relation formal languages lcf martin lof semantics myhill nerode theorem nuprl program extraction propositions types quotient types regular languages state minimization tactics type theory 
supported part nsf ccr due 
library url www cs cornell edu info projects nuprl nuprl html 
contents background value formalization interpretations mathematics outline type theory preliminaries basic types cartesian products function types propositions universes subtypes finiteness algebraic structures dependent types reading nuprl proofs languages representation alphabets languages procedures algorithms representations languages finite automata definition semantics automata equivalence relations quotient types finite index equivalence relations equivalence relations strings induced finite automata myhill nerode theorem hopcroft ullman version formalizing formalizing formalizing state minimization textbook proof filling gaps textbook proof minimization theorem computational behavior background widely believed know formalize large tracts classical mathematics write style bourbaki version set theory fill details 
journal formalized mathematics publishes results formalized set theory checked mizar system 
fact topic state minimization finite automata formalized mizar 
despite belief formalizations accomplished massive formalization fait research issues related formalization effort computerization 
doubt appropriateness set theory expressing working mathematics 
contrast general agreement formalize computational mathematics article contribution understanding task exploring approach 
approach stresses formalized computational mathematics useful carrying computations 
subgoals illustrate utility particular way 
want show constructive proofs synthesize programs 
specifically want examine constructive type theory natural expression basic ideas computational mathematics sense set theory purely classical mathematics 
explored question elementary number theory num thy algebra polynomials general algebra elementary analysis elementary logic systematic efforts 
type theory martin lof semantics 
examine ideas setting basic automata theory reasons choice 

subject formalization closely allied subjects computer science programming languages semantics applied logic automated deduction problem solving environments computer algebra systems knowledge representation computing theory 
automata theory widely taught computer science building systems 
hope large sympathetic audience material create 

basic theorems finite automata theory myhill nerode theorem illustrates beautifully idea algorithms extracted constructive proofs test main subgoal 

account myhill nerode hopcroft ullman famous book constructive small points buried deep proof 
nonconstructive steps easy show proof entirely constructive trivial change theorem 

automata theory appears suited expression type theory 
account convincing material task harder imagine 
formal account clarifying helpful case compact elegant informal expositions automata theory 
claim formalism adds value put test 
worse people appreciate significant new problem see 

myhill nerode theorem illustrates phenomenon curious 
formalization expand text large factors factor case surface orders magnitude 
formalization theorem relies heavily results list theory algebra see impact knowledge base formalization task 
required building new basic material quotient type see formalization efforts laborious 

existence earlier formalization pumping lemma automata theory christoph nuprl allows compare progress tactic collection version version 

formalization reveals technical problems formalize computational mathematics 
question involves reasoning quotient sets central technical concern formalization 
value formalization readers evaluate formal text web resulted formalization efforts 
possible directly judge definitions faithful hopcroft ullman formal definitions help clarify concepts proofs sufficiently readable informative availability detail proof steps useful forth 
formal material provided underpinning definitions proof summaries refer complete formal library 
material foundation documents explain detailed proofs 
produced documents automata library see examples genre writing formal courseware section nuprl home page 
example stuart allen produced hybrid style formal informal proof accompany basic theorems functions proved paul jackson extensively formalization 
aspects products formalization directly evaluated reading formal text require experience system 
category experience confidence results comes learning trust nuprl 
know reading results checked human machine raises confidence correctness similar added confidence gained having trusted colleague check result 
value formalization interactivity provided underlying system 
nuprl show dependencies theorems definitions execute algorithms extracted proofs 
users modify proofs see effects execution try simpler proofs addition readable highly interactive formal text formalization created interesting digital artifact formal theory object manipulate measure transform explore 
experience capabilities learn system nuprl 
nuprl free software obtained web site mentioned earlier 
runs freely available common lisp linux free cmu common lisp unix 
interpretations mathematics formalization expressing ideas hopcroft ullman type theory especially nuprl opens possibility new interpretations mathematics 
definitions refer fragment set theory informally define algorithms procedures systematic way 
thing show treat computation systematically minor changes text 
presentation enables person imagine mathematics classical howe illustrates 
allows interpretation recursive mathematics functions turing machines lisp programs 
allows intuitionistic interpretation 
way describe style relate bishop showed real complex analysis formalized neutral way 
outline section basic ideas nuprl needed article 
surprisingly little required claim basic material readable mathematical preliminaries undergraduate textbook level hopcroft ullman 
section corresponds hopcroft ullman chapter 
try follow account closely 
section provides preliminaries automata hopcroft ullman closely 
section proves myhill nerode theorem 
section discusses proofs state minimization filling omission proof simplifying showing advantage formalization 
key ideas formalization self contained way reader understand issues thoroughly reading web library www cs cornell edu info projects nuprl nuprl html nuprl system read actual libraries 
article originally written html document accompany actual line theorems 
various nuprl libraries text 
html version hot click open referenced files 
type theory preliminaries accounts nuprl type theory sources 
basic types integers sigma sigma primitive type nuprl primitive operations gamma delta xi rem remainder equality order primitive 
natural numbers defined fi zj ig initial segments nk fi zj kg 
segment fx zj jg gamma fx zj jg 
nk gamma 
basic facts types libraries int int num thy 
type form type lists elements called list 
empty list denoted nil regardless type list construction consing takes element list say forms new list denoted adds element head list append operation lists critical article denoted defined usual recursive way nil booleans consists tt ff denoting true false 
normal case selection available standard operations write subscript distinguish operations propositional connectives see bool 
cartesian products types cartesian product theta elements ordered pairs ha bi example theta points integer ordinates plane 
theta common ways denote second components pair 
common ways second second 
ha bi ha bi ary product say theta theta regarded theta theta 
general theta delta delta delta theta theta theta delta delta delta theta 
theta theta nd component rd 
ll see selectors definition automaton section 
function types types denotes type computable total functions canonical elements type lambda terms 
denote substitution term free occurrences require terms denoting elements fa denotes application argument know fa see fun 
recursive functions defined style ml 
form lhs rhs introduce recursive definition example fact fact gamma fi invokes ml tactic called add rec def lhs rhs arguments 
tactic adds abstraction named function name fact 
abstraction recursion combinator example fact fact gamma fi combinator added factorial 
abstraction invisible various tactics fold unfold instances user need aware underlying calculus foundations 
automata library recursive function define analogue ffi hu 
informally definition ffi null da ffi ffi tl hd fi 
actual definition da null da ffi da da tl hd fi 
propositions universes called classical accounts logic proposition truth value consequently propositions treated boolean expressions 
boolean valued account restrictive need order discuss computability issues adopt account propositions 
want consider sense truth proposition 
particular interested computational sense 
course talk truth value proposition sense 
type propositions needed article denoted nuprl express higher order logic case larger propositions needed 
see jackson fuller accounts higher order logic 
distinguished atomic propositions canonically true canonically false 
propositions form compounds usual way written implies written written iff 
propositional function type map form propositions type holds type holds 
associated type atomic equality proposition 
definition equality type 
classical logic boolean value tt considered true proposition ff identified 
proposition associate boolean expression bexp atomic equality bexp tt bexp denote corresponding proposition true bexp 
clearly know true tt iff true ff iff 
denote true bexp bexp short 
call arrow assert 
types need belong universe types seen list types 
subtypes finiteness natural notion subtype 
type propositional function fx denotes type elements satisfying know fx build element find proof subtle computational point sets function fx access proof holds calculating value 
need universe small types denoted simply full discussion universes see allen jackson 
discussion constructive meaning types scope see 
finite type put correspondence cardinality write fin mean finite 
means find number functions inverses definition correspondence fun finiteness automata 
important fact finite types 
say type discrete iff function eq theta iff eq tt discrete iff equality decidable 
fact finite discrete 
true discrete decide eq ask function witnessing finiteness 
algebraic structures dependent types algebra automata theory definitions called algebraic structures 
example monoid type binary operation theta element operation associative identity 
monoid triple hm ei 
signature type structure theta op theta theta type called dependent product nuprl 
basic underlying form theta function types types theta theta explain bound variables op ways 
jackson thesis arise iterating binary dependent product construction follows 
type exactly element say fx zj 
take theta type parameter 
call 
build op theta theta 
call build theta 
see op just binding variables creating product 
approach consider type names fop ig subtype atom nuprl define function fop ig op theta monoid signature theta approach taken jason hickey 
reading nuprl proofs proofs nuprl trees 
nodes tree consist sequents justifications sequent list formulas called hypotheses paired single formula called goal hypotheses numbered sequents called goals displayed symbol called turnstile separates hypotheses 
sequent provable iff prove goal hypotheses justification component node gives reason goal sequent follows subgoal sequents generated justification 
justifications displayed justification text 
sequent justification subgoals constitute individual inference proofs 
schematic example hyp hyp subgoals subgoals general inference look delta delta delta lists formulas single formulas 
nuprl provides various tree traversal operations facilitate reading proof tree modifying 
proof trees meant read tree walking operations 
want print trees 
various schemes doing 
write vertical lines left margin connect subtree goal 
example printed 




hyp 


hyp languages representation alphabets languages hopcroft ullman book question language 
answer starts definition alphabet 
alphabet finite set symbols consider countably infinite set symbols drawn leave open just symbols countable number additional symbols reader finds convenient may added 
adopt ingredients definition needing specify countably infinite set 
simply require alphabet alph finite type say declare alph uis open definition open 
require alph finite postulating fin alph 
consequence finiteness equality relation alph decidable 
true finite set noted section 
hopcroft ullman read sentence alphabet string finite length composed symbols alphabet 
synonyms sentence string word 
definition incomplete define string 
learn really means 
lack fixed definition allows authors switch equivalent notions list array string depending needs 
note 
essentially introducing type fixing operations advance 
introduce notations 
alphabet set sentences include empty sentence 

language subset concrete definition 
sentence list elements alpha members type alph list 
nil list call empty sentence 
example alph alph list fnil language condition membership say predicate specifies element alph list belongs language 
language propositional function alph list element alph list language alph denote type languages alph 
library definitions called abstractions tag languages language alph alph list define equality languages language alph alph list 
library lang give operations languages union intersection complement product omega power closure hopcroft ullman raise questions 
specify language 
exist finite representation language 
note alph list countably infinite language alph uncountable 
conclude languages finite representations 
views consistent allow interpretations 
say language propositional function say 
say set set finite representation 
consistently take view function algorithm algorithm finitely representable 
languages finitely representable 
interpretation called recursive mathematics 
consistent interpretation mentioned take neutral view characteristic bishop style mathematics views results possible 
procedures algorithms section chapter hopcroft ullman concerned procedures algorithms part basic type theory 
case set theory computability need mentioned type theory computability basic concept 
covered ideas section 
interesting hopcroft ullman rely concept effective procedure open ended concept axiomatize type theory 
chapter turing machines formalization effective computability 
hopcroft ullman consider subject 
look mathematics outside 
noticing properties underlying procedures 
talk type meaning procedures computational behavior 
mathematics influenced great results logic new th century mathematics 
representations languages definition language propositional function alph list captures intuition know language know criteria saying sentence 
say language know prove 
agrees hopcroft ullman concerned certain special ways knowing 
especially simple kind representation arises proposition decidable function rl alph list iff rl tt language called decidable recursive 
way represent language function provide enumeration function el alph list iff el function el said represent function el interesting procedure arises specifying language procedure called real recognizer 
specify write function alph list iff el el gamma gamma hopcroft ullman go show real recognizer define enumerator 
basically enumerate fx alph list rr uniformly type non empty 
operation enum produces function interested mainly automata myhill nerode theorem chapter skip chapter grammars difficult formalize results 
interesting result theorem context sensitive grammar recursive 
finite automata definition hopcroft ullman say finite automaton alphabet alph system alph ffi finite nonempty set states alph finite input alphabet ffi mapping theta alph initial state set final states nuprl definition formalized nearly verbatim 
system just element product type 
notation automata alph states denote type automata input alphabet alph states states 
automaton triple transition initial state final states 
automata automata alph states states alph states theta states theta states da act ffia component da init initial state second component da fin final states third component da act wf alph states automata alph states ffia states alph states da init wf alph states automata alph states states da fin wf alph states automata alph states states symbol line indicates abstraction theorem semantics automata finite automaton da interpreted language recognizer methods discussed section 
defines function alph list language accepted consists sentences da computes true tt 
meaning automaton providing meaning function mapping automaton da automata alph states formal language map alph list propositions give meaning composing simpler functions 
function automaton input string state 
called compute list ml da null da ffi da da tl hd 
associating resulting state compute list ml boolean value final state component function states 
associating automaton propositional function saying final state tt 
final state function 
auto lang da true da write da hopcroft ullman follow approach function leave implicit simple 
define function ffi ffi xa ffi ffi string character alphabet 
say sentence said accepted ffi set accepted denoted 
fx ffi fg 
elegant definition compactly written ffi ffi ffi xa ffi ffi definition computation state automaton da string thought hd tl da nil da da ffi da tl hd recall da initial state 
notice definition automaton starts processing tail symbol working head 
input extended head consing symbols 
usual convention programming lisp scheme ml java display lists head left 
means automaton thought processing right left input extended left 
unfortunately hopcroft ullman chose display lists head right automata move left right input extended right 
speak right invariant behavior speak left invariant behavior 
keep terminology independent display term extension invariance 
define operation extend string added string extension added head write extend append operation 
hopcroft ullman equivalence relations quotient types hopcroft ullman say binary relation set set pairs elements accustomed seeing fact written arb 
set theory set pairs defined terms characteristic function theta type theory sets expressed functions theta propositions 
type theory functions computable maps set relation decidable 
relation said 
reflexive iff srs 
symmetric iff srt implies trs 
transitive iff srt tru imply 
reflexive symmetric transitive relation called equivalence relation 
equivalence relation write mod xry say equals modulo 
write xry rxy stressing function 
equivalence class element set fx denoted equivalence classes clearly disjoint equal arx transitivity arb set equivalence classes partition set theory structure denoted called quotient set map called canonical mapping common think classes new elements equality defined iff arb 
say functional compatible iff ara implies likewise binary operation theta say functional wrt iff ara implies quotient sets structures central mathematics representation set theory suitable computation elements quotient set equivalence classes infinite objects 
remedy computational defect set theory type theory uses notion quotient type 
type equivalence relation type called quotient written fully expanded form 
elements equality relation order qualify function function functional wrt canonical map just identity function functionality theorem functional wrt iff important fact nuprl rules quotient type 
elements elements subtype knowing sufficient conclude conversely 
know need know constructively 
conclude decidable 
understand feature quotient rules need point semantics computational content equality propositions trivial 
theory records propositions proved ignores details 
call computational triviality equality principle 
preserve semantic principle presence quotient types requires rules forget computational information proof asserting finite index equivalence relations equivalence relation said finite index iff finite 
index cardinality important result need decidable finite finite equal finite say size index finite index satisfies see quo finite relation library 
equivalence relations say refines iff write means equivalences classes possibly refined decomposed smaller classes 
suggestive picture discuss subtyping note general iff implies means subtype 
equivalence relations implies think iff clearly equivalence relations strings induced finite automata theory finite automata concerned natural equivalence relation strings induced automaton 
da automata alph states say strings alph list equivalent mod da mod da iff da da states iff strings taken state action automaton 
remarkable fact finite automaton characterized properties equivalence relation finite index invariant extension strings characters 
property stated terms appending characters say list head input means tape 
def equivalence relation alph list called extension invariant iff alph list extend extend note extend fact 
equivalence relation induced da automata alph states finite index extension invariant 
easy see true 
largest number equivalence class alph list number states da finite da da clearly da ffi da ffi da da fact 
extension invariant equivalence relation alph list finite defined finite automaton 
build automaton elements alph list states 
extension invariance allows define ffi 
links automata finite index extension invariant equivalence relations independent final states 
link defined terms compute list 
add final state information say equivalence relation 
remarkable fact emerges designate strings belonging certain equivalence classes accepted find minimal state automaton final states accept exactly designated strings 
automaton essentially unique 
fact 
language induces equivalence relation rll defined iff alph list call equivalence relation induced accepted finite automaton show equivalence relation induced automaton refinement rll build finite automaton alph list rl states unique minimal automaton accepting remarkable facts aggregated known myhill nerode theorem discuss prove 
hopcroft ullman section 
myhill nerode theorem subsection states proves hopcroft ullman version myhill nerode theorem 
modified account slightly enable constructive proof require effective union statement decidable induced equivalence relation rl 
changes highlighted enclosing parentheses 
terminology induced equivalence relation defined section defining relation statement theorem hu 
presenting hu proof discuss constructive formalization examine details proofs implications called mn called mn called mn 
include text line libraries 
hopcroft ullman version theorem 
statements equivalent 
set alph list accepted finite automaton 

effective union equivalence classes extension invariant equivalence relation finite index 

equivalence relation alph list induced finite index decidable 
proof 
assume accepted alph ffi 
equivalence relation xry ffi ffi 
extension invariant ffi ffi ffi ffi index finite index number states furthermore union equivalence classes include element ffi better notation overload write relation 
change library display point 

show equivalence relation satisfying refinement rl equivalence class entirely contained equivalence class rl 
index rl greater index finite 
assume xry 
extension invariant alph list equivalence class contained equivalence class rl 
conclude equivalence class contained equivalence class rl 
assume 
alph list rl extension invariant 
finite set equivalence classes rl element containing define ffi xa 
definition consistent rl extension invariant 
ffl lg 
finite automaton alph ffi accepts ffi note computable assume decidable 
qed theorem 
minimum state automaton accepting unique isomorphism renaming states theorem 
proof proof theorem saw alph ffi accepting defines equivalence relation refinement number states greater equal number states theorem 
equality holds states identified states state alph list ffi removed smaller automaton 
identify state ffi identification consistent 
ffi ffi theorem equivalence class ffi ffi qed note authors term myhill nerode relation refer extension invariant equivalence relation finite index refines terminology statement 
myhill nerode relation formalizing formalizing implication quite direct elegant type theory 
go step step 
say set alph list accepted finite automaton means automaton say auto accepting turn presupposes set states say st auto automata alph st 
mechanical translation accepted finite automaton st auto automata alph st fin st auto implicitly quantifying alph 
implicit translation revealed line proof accepted auto hk alph ffi statement union equivalence classes extension invariant equivalence relation finite index 
translating requires equivalence relation called proof call statement fr alph list alph list alph list rxy alph list rxy defined expect 
says equivalence relation alph list 
specialization rxy need assert finite index just fin alph list rxy 
extension invariant alph list rxy consider express idea statement effective union equivalence classes extension invariant equivalence relation finite index 
direct translation idea union equivalence classes say finitely 
write subset indexes say union effective say decidable set 
don want express union idea way language quotient types equivalence classes 
don need bring type equivalence classes type alph list 
transform statement alph list follows 
suppose function picks classes union tt iff notice alph list equivalence classes iff tt 
map respect equivalence relation defined function alph list effective union determines map conversely 
say effective union equivalence classes boolean valued function pick classes 
alph list rx alph list true iff tt note true denoted 
putting get fully expanded formulation 
named mn 
mn alph alph fin alph st auto automata alph st fin st auto fr alph list alph list alph list rxy alph list rxy fin alph list rxy alph list alph list rxy recall rxy fully expanded notation version theorem displayed web worked theorem proof readable 
instructive see done 
decided suppress detail statement equivalence relation detailed display form 
result display fr alph list alph list equivalence alph list agreed allow assertion boolean displaying assert symbol true just 
display extension invariance simple phrase extension invariant 
general abbreviation device suppressing leading universal quantifiers standard convention mathematics hopcroft ullman theorem 
result fin alph st auto automata alph st fin st auto fr alph list alph list equivalence alph listg alph list fin alph list alph list extension invariant 
proof theorem follows 

define rxy mean auto auto 
immediate extension invariant auto ffi auto ffi auto auto 

show finite index precisely show fin alph list 
know number states auto upper bound cardinality 
exact size fact number accessible states 
fact comes argue finiteness 
finiteness alph list proved invoking lemma automata inv fin fin fin dec fin 
prove preconditions lemmas mainly st dec alph proof requires showing auto short length number states 
done invoking pumping lemma corollary automata 
turn requires pigeon hole lemma automata lemma 
proof inv fin fin requires key automata lemma finite decidable subset fin dec fin ft tg 

define alph list tt exactly auto tt auto 
need show functional wrt follows directly definition main steps line proof displayed presentation format automatically generated mark original proof 
tools creating readable proofs provided stuart allen 
key format parts proof put aside read 
allen calls side proofs indicated phrase followed name 
line version possible click proof read 
fin alph st auto automata alph st fin st auto fr alph list alph list equivalence alph listg alph list fin alph list alph list extension invariant 
alph 
alph 
fin alph 
st 
auto automata alph st 
fin st 
auto fr alph list alph list equivalence alph listg alph list fin alph list alph list extension invariant 
auto auto st equivalence alph list mn read 
fin alph list auto auto st 
thm inv fin fin 



nn st 

auto 

auto auto st equivalence alph list 

st 

st 
dec alph list auto st 
mn read 
dec fl alph list ng auto st 
thm auto lemma mn read 



fl alph list ng 
dec auto st thm fin 
fin st 
alph list auto accepts 
auto auto st extension invariant thm compute inv formalizing seen formalize 
express need formalize condition 
define induced relation rl appears libraries 
language function language parameter displayed implicit 
lang rel rl list lang rel ref rl list list establish straight rl equivalence relation 
lang rel ref ref list rl lang rel symm sym list rl lang rel tran trans list rl formulation hopcroft ullman rl finite index 
see prove constructively need explicit decidable language 
take decidable rl finite index 
proof appears simplest implications 
know immediately decidable 
show refines rl index rl larger alph list alph list rl step show xry follows directly fact extension invariant iff rl story look details lemma rl index rl index requires prove relation rl decidable see auto lemma 
complication suggests elegant proof outline stating theorem 
second proof formalize 
mn list list fin list xry gamma nn list xry list xry list xry list gamma nm list rl list dec devices render theorem readable 
stuart allen version 
fin equivalence list nn list extension invariant list list nm list rl list dec proof key idea proof show alph list rl alph list rg rg rl defined quotient type boolean valued function function characterizes simple way easier 
leads equivalence relation rg rl 
proof essentially establishing isomorphisms alph list rg alph list rg nm 
isomorphism follows lemma called quo quo 

second isomorphism follows lemma quo finite 
heart proof 
requires rg decidable relation 
qed main line web proof appears applying allen technique full web proof 
rl displayed rll reveal dependence notice side proofs number lemma 
expanded line version just clicking names 




list 
list list 
fin 
equivalence list 
nn list 
extension invariant 
list 
list nm list rll list dec 
nm list rll mn read 

list dec thm mn lem 

rll equivalence list thm lang rel equi equi 

rg equivalence list thm rel equi 

list rll list rg thm mn rl equal rg 

list rg list rg thm quo quo 

nm list rg thm quotient finite 
mn read list dec real proving theorem spent building general facts quotients defining rg showing equivalence relation alph list required long sequence lemmas 
left implicit hopcroft ullman need properties quotient sets facts equivalence relations quotient sets 
mn quo append mn quo append wf list list list xry list xry list list xry list xry mn quo append assoc alph alph list alph list alph list xry alph list xry alph list alph list xry rel rg list gz gz rel wf list list list xry list xry list xry rg list xry list xry rel equi list list list xry list xry list xry list xry trl iff rg list list list xry list xry list xry list list formalizing goal build finite automaton called follow hopcroft ullman exactly set states alph list rl defining ffi ax nil start state defining tt exactly section refer automaton 
show defined finite automaton accepting need show ffi defined equivalence classes ffi ffi 
ffi ax ffi ay need know ax ay 
true iff ax iff ay instance definition iff iff alph list formal statement followed compressed proof 
compressed proof assertion indicate assertion cut proof assertion goal line 
direct computation key proof display main step writing formula fin alph fin alph list rll alph list dec st auto automata alph st fin st auto 
alph 
alph 
rl equivalence alph list thm lang rel equi equi 
fin alph 
fin alph list rll 
alph list dec st auto automata alph st fin st auto mn read 
alph list 
alph list auto automata alph alph list rll fin alph list rll auto assertion 
nil automata alph alph list rll mn read 
nil automata alph alph list rll 
nil 
alph list 
nil accepts 
nil accepts assertion 

nil accepts 
nil accepts le 
nil 

nil 
alph list nil 
nil 
nil alph list nil 
nil 
nil nil alph list 

alph 
alph list 

nil 
alph list 
nil 
alph list state minimization textbook proof recall theorem reproduced section 
restate theorem automaton theorem number states automaton accepting automaton accepting minimum number states isomorphic notable points theorem proof bear formalization 
notice statement theorem refers defined proof theorem 
economical device common definitions explicit lang auto 
defines automaton function define final states 
definitions lang auto lang auto wf alph language alph alph list automata alph alph list lang auto compute alph language alph alph list alph list review proof exactly written 
proof 
proof theorem saw finite automaton alph ffi accepting defines equivalence relation refinement number states greater equal number states theorem 
equality holds states identified states state alph list ffi removed smaller automaton 
identify state ffi identification consistent 
ffi ffi theorem equivalence class ffi ffi qed notice properties proved context specific theorem 
effort general principles 
example notion isomorphism mentioned proof defined 
explicit automata discussed 
addition key argument automaton accepting defines refinement rl observation proof theorem stated separate fact 
consequence number states greater number important general fact abstracted theorem 
state separate theorems card le card ge 
card le jsj jt inj card ge jsj jt surj notable point hopcroft ullman proof nice idea flawed key details omitted 
correspondence states shown isomorphism 
hopcroft ullman don hint proof mind 
failing prove led insert derivative fact automaton connected 
necessary 
outline argument 
filling gaps textbook proof proof specific machine call accepts 
call machine 
machine accepting theorem know jm jm minimal jm jm equality define map call show defined claim proof isomorphism 
definition connected set states say fq st alph list ffi qg string ffi define welldefined pick different string say ffi mod mod rl theorem 
alph list rl 
hard show isomorphism states implies st hopcroft ullman carry argument 
prove separately st see right argument show 
state notice ffi ffi means means jkj ja jkj ja jkj jm ja jkj jm assuming jm jm jkj jm jkj ja contradictory assert 
classical logic means 
constructively true property types decidable 
notice final steps subtle terms constructive reasoning 
basic facts finite sets considered immediately obviously true 
fact obvious nuprl prove 
gap proof glossed detailed account 
account assumes compute equivalence classes concrete objects 
sets infinite objects adopted approach quotient types discussed section 
order precisely define isomorphism discussed need assign element alph list rl said ffi find 
definition assures exists semantics set type allow witness proof fact 
stronger definition connected set states requiring string kept state 
take st theta fy alph list ffi qg function access witness second component pair 
approach similar hopcroft ullman proof notice compute string example pick string respect lexicographical ordering alph list 
suppose oe ordering 
ordering ffi define ffi computes formalize approaches 
turns define lexicographical ordering direct argument hopcroft ullman 
facts lexicographical ordering mentioned hopcroft ullman 
avoid entirely argument contradiction computational version complex 
briefly discuss approach 
automata web 
minimization theorem want compute automaton probably want convenient representation states natural numbers 
define directly terms finiteness theorem suppose states maps rep alph list rl alph list rl define canonical minimal automaton automata alph ffi rep ffi rep nil fm straight forward build isomorphism theorem 
case property proved 
summarize minimization way 
take disjoint union automata alph st finite types states 
type theory automata alph st theta fin st theta automata alph st minimization result stated automaton alph equivalent minimum number states 
formalize write equivalent mean accept languages alph list say minimal iff equivalent states 
equivalent alph list minimal automata alph states states easily prove minimization theorem alph fin alph automata alph automata alph equivalent minimal theorem extract function reduce ffl automata alph automata alph produces minimal machine 
automata show minimal automaton connected connected defined automata con st alph list define auto auto defined hs gi theorem min auto con alph st auto automata alph st fin alph fin st con auto show minimal automaton unique isomorphism connected automata 
isomorphism defined automata alph ffia ffia fs fs theorem iso min auto alph st auto automata alph st automata alph fin alph fin con gamma gamma correspondence alph list auto computational behavior nuprl system designed extract execute computational content constructive theorems implicitly mentioned 
possible perform state minimization automaton need write separate minimization algorithm 
just hopcroft ullman mention extract algorithm proof myhill nerode theorem 
illustrate point concretely note automaton auto theorem tells alph list rl set states minimal machine set finite 
able compute size alph list rl carried computation automata automata 
proofs initially completed complexity minimization algorithm exponential number states 
nogin formalization improving efficiency nuprl proofs reduced complexity low order polynomial displayed web 
believe nuprl formalizations hopcroft ullman account nerode theorem demonstrates added value formalization 
material created foundation grounding informal explanations refer detail precision 
cornell experimenting creating examples formally grounded explanations 
formalized parts hopcroft ullman example account grammars chapter nondeterministic automata 
judge possible formalize chapters person team eighteen months 
collaboration methods learned extend larger teams 
especially interesting collaborate theorem proving systems howe colleagues doing hol nuprl 
classical treatment languages easily re interpreted constructively 
especially fruitful collaborate constructive provers alf coq lego isabelle formalized martin lof type theory 
provers different formalizations constructive mathematics share critical properties computational notions expressed allow extraction code proofs 
render formal proofs clear readable informal ones 
simplest way accomplish results improve readability 
experiments nuprl editor improve readability proofs led devices wish explore structured presentation tactics ml structure editor side proofs suppress detail highlight main thread argument 
centaur group proofs readable expect modularity feature nuprl light refiner help structure theories part major effort improve readability proofs 
support acknowledgments acknowledge support granted national science foundation office naval research 
stuart allen karl crary discussions input concerning topic help preparing document 
stuart allen 
non type theoretic semantics type theoretic language 
phd thesis cornell university 
bertot kahn th ery 
proof pointing 
theoretical aspects computer software lecture notes computer science volume pages 
bishop 
foundations constructive analysis 
mcgraw hill ny 
cl ement despeyroux kahn lang 
centaur system 
software engineering notes volume 
third symposium software development environments 
bourbaki 
elements mathematics theory sets 
addison wesley reading ma 
robert constable 
reflection explain enhance type theory 
helmut schwichtenberg editor proof computation volume nato advanced study institute international summer school held marktoberdorf germany july august nato series pages 
springer berlin 
robert constable 
experience type theory foundation computer science 
proceedings tenth annual ieee symposium logic computer science pages 
lics june 
robert constable 
structure nuprl type theory logic computation 
nato asi series 
springer verlag 
robert constable stuart allen bromley cleaveland cremer harper douglas howe knoblock mendler panangaden james sasaki scott smith 
implementing mathematics nuprl development system 
prentice hall nj 
thierry coquand huet 
calculus constructions 
information computation 
kahn th ery 
extracting text proofs 
typed lambda calculus applications volume lecture notes computer science pages 
debruijn 
set theory type restrictions 
sos editor infinite finite sets pages 
vol 
coll 
math 
soc 
bolyai 
michael gordon melham 
hol theorem proving environment higher order logic 
university press cambridge 
michael gordon robin milner christopher wadsworth 
edinburgh lcf mechanized logic computation lecture notes computer science vol 

springer verlag ny 
jason hickey 
objects theories dependent types 
proceedings fool july 
jason hickey 
nuprl light implementation framework order logics 
th international conference automated deduction 
john hopcroft jeffrey ullman 
formal languages relation automata 
addison wesley reading massachusetts 
douglas howe 
importing mathematics hol nuprl 
von wright grundy harrison editors theorem proving higher order logics volume lncs pages 
springer verlag berlin 
douglas howe 
semantic foundations embedding hol nuprl 
martin wirsing maurice nivat editors algebraic methodology software technology volume lncs pages 
springer verlag berlin 
paul jackson 
enhancing nuprl proof development system applying computational algebra 
phd thesis cornell university ithaca ny january 
piotr rudnicki 
minimization finite state machines 
mizar user association 
dexter kozen 
automata computability 
springer 
kreitz 
constructive automata theory implemented nuprl proof development system 
technical report cornell university ithaca new york september 
magnusson nordstrom 
alf proof editor proof engine 
springerverlag editor types proofs programs volume lecture notes computer science pages 
martin lof 
constructive mathematics computer programming 
sixth international congress logic methodology philosophy science pages 
north holland amsterdam 
martin lof 
intuitionistic type theory studies proof theory lecture notes 
bibliopolis napoli 
alexei nogin 
improving efficiency nuprl proofs 
moscow state university unpublished 
nordstrom petersson smith 
programming martin lof type theory 
oxford sciences publication oxford 
paulson nipkow 
isabelle generic theorem prover 
lecture notes computer science vol 

paulson 
isabelle generic theorem prover lecture notes computer science vol 

springer verlag 
robert pollack 
theory lego proof checker extended calculus constructions 
phd thesis university edinburgh dept computer science bldg mayfield rd edinburgh eh jz april 
rabin scott 
finite automata decision problems 
ibm journal research development volume pages 
scott 
constructive validity 
editor symposium automatic demonstration volume lecture notes mathematics pages 
springer verlag new york 
th ery bertot kahn 
real theorem provers deserve real user interfaces 
software engineering notes volume pages 
th symposium software development environments 
thompson 
type theory functional programming 
addison wesley 
