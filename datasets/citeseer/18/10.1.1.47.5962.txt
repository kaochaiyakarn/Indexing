polyadic calculus tutorial robin milner laboratory foundations computer science computer science department university edinburgh king buildings edinburgh eh jz uk october calculus model concurrent computation notion naming simplest original form help illustrative applications 
generalized monadic polyadic form 
semantics done terms reduction system version labelled transitions called commitment known algebraic axiomatization strong bisimilarity new setting characterization modal logic 
theorems replication operator proved 
justification polyadic form provided concepts sort sorting supports 
illustrations different 
example presentation data structures processes respect particular sorting sorting known translation calculus calculus 
translation equational validity fi conversion proved help replication theorems 
ends extension calculus order processes brief account demonstration davide sangiorgi higher order processes may faithfully encoded order 
extends strengthens original result kind bent thomsen second order processes 
done support senior fellowship science engineering research council uk 
calculus way describing analysing systems consisting agents interact configuration neighbourhood continually changing 
presentation developed continues development main stream 
tutorial give central ideas calculus read people seen show current developments important reported 
model world computation part world ontological commitment mean loose sense commitment phenomena try capture mental constructions seen fit phenomena best 
obvious denotational models computing example set theoretic notion function chosen essence content deterministic sequential process result computed arguments 
mathematical operations adding square roots existed long set theory church creating calculus algorithm mind function sense word 
calculus ontological commitment computation 
emphasizes view computation arguments yielding results 
contrast gives direct representation heterarchical family agents changing state identity persists computation 
may say calculus owes success quite special focus argument result computations 
concurrent computation particular power concurrently active agents influence activity fly forced function set theoretic severe distortion 
course concurrent agents assumed constrained interact sorts different ways 
way treat precisely function computers agent interaction environment consist receiving arguments giving results expecting sub agents computing auxiliary functions behave similar way 
functional computation special case concurrent computation expect find calculus exactly represented general model concurrency 
looking basic notions model concurrency probably wrong extrapolate calculus follow example seeking small powerful 
analogy music art form wrong look aesthetic theory cover art forms extrapolation musical theory 
look 
point view embarrassingly wide range idea sources choose concurrent computation broadest sense operative activity independent agents human organizations distributed computing systems 
may hope model concurrency may attain breadth application comparable physics petri expressed hopes seminal concurrency guided analogy 
field large may doubt single unified theory concurrency possible possible research strategy seek early 
modest strategy seize single notion pervasive focus model submit model various tests intrinsic theory tractable appealing 
apply real situations useful building systems understanding existence 
strategy little hindsight led calculus 
pervasive notion seize naming 
reason doing naming strongly presupposes independence naturally assumes namer named existing concurrent entities 
reason act name address inextricably confused act communication 
thinking names bring focus aspects computing problems solutions 
naming involved communicating agree involved locating modifying data look way treating data access communication thing leads viewing data special kind process shall see treatment data arises naturally calculus 
topic hope understand better naming object oriented programming cornerstones topic treated informally way objects provide access naming 
term object paradigm describe models calculus agents objects assumed persist retain independent identity 
david walker initial success giving formal semantics simple object oriented languages calculus 
challenging problem reconcile assumption quite common world objectoriented programming object possess unique name view expressed chapter naming channels agents primitive calculus 
focussing naming give impression expect aspect concurrency explained 
focal notions yield different complementary view 
naming strong attraction notion distilled directly computing practice 
remains seen intuitions understanding concurrency arise practice way arise directly logic turn distillation kind computational experience inference 
sources 
example logical intuition concurrency light cast resource girard linear logic 
believe quite reasonable view sources intuition ultimately source understanding computation naming say just logical activity modal logics say computer science 
background related calculus really began failure time wrote ccs calculus communicating systems 
failure discussion mogens nielsen aarhus see full mobility processes handled algebraically 
wish motivated partly hewitt actor systems introduced earlier 
years engberg nielsen succeeded giving algebraic formulation 
calculus simplification strengthening 
authors invented applied formalisms processes restriction finite fixed initial connectivity 
prominent examples language kennaway sleep parametric channels astesiano zucca 
works comparable calculus achieve mobility enriching handling channels 
contrast achieve mobility powerful means transmitting processes messages higher order approach 
exemplified astesiano reggio context general algebraic specification nielson emphasis type structure boudol context calculus thomsen 
deliberate intention calculus avoid higher order initially goal demonstrate sense sufficiently powerful allow names channels content communications 
thomsen supports conjecture strengthens results comparing approaches 
see milner discussion contrasting approaches 
outline short chapters 
chapter reviews formalism monadic calculus essentially defines notion structural congruence reduction relation 
chapter entirely devoted applications defines simple mobile telephone protocol second encodes arithmetic calculus third presents useful disciplines name may obeyed operating system form properties invariant reduction 
chapter generalizes calculus polyadic communications introduces notions abstraction concretion enhance power expression calculus illustrated simple treatment truth values affirms reduction relation remains essentially unchanged 
chapter chapter provide technical basis 
chapter reduction congruence defined natural congruence reduction observability 
standard operational semantics reformulated terms new notion commitment flexibility abstractions concretions provide yields succinct presentation 
late bisimilarity restated polyadic setting axiomatization 
slightly weaker variant early bisimilarity discussed part ii shown induce congruence identical reduction congruence 
theorems replication 
modal logic provides characterizations late early bisimilarity formulated new way advantage new setting 
chapter introduces notions sort sorting somewhat analogous simple type hierarchy calculus significant differences 
data structures shown represented particularly behaved class processes respect distinctive sorting discipline 
help sorts new light cast encoding calculus calculus simple proof validity fi conversion interpretation calculus theorems chapter 
chapter explores higher order processes extending thomsen 
shown sorts sorting extend naturally second order processes data order key role played abstractions 
theorem sangiorgi asserts order processes faithfully encoded order calculus calculus chapter 
details encoding 
joachim parrow david walker insights came original calculus deeply informed development 
davide sangiorgi bent thomsen useful discussions particularly higher order processes 
am grateful dorothy help skill preparing manuscript 
carried senior fellowship funded science engineering research council uk 
monadic calculus basic ideas primitive entity calculus name 
names infinitely structure 
basic version calculus kind entity process 
processes built names syntax sigma finite indexing set case write sum 
summand prefix represents atomic action action performed basic forms prefix binds prefixed process means input name call link named xy bind means output name link named 
case call subject object action subject positive input negative output 
name refers link channel 
thought naming process channel polarity names name output input 
reasons naming process elementary notion 
process may referred names may satisfy different demands different channels clients 
second name may access processes may request resource service may cry help agent able supply 
fact names processes different kind names channels 
oppose parsimony essential basic model 
course human communities convenient convention certain name borne uniquely certain member name robin borne uniquely family larger community 
process communities convention name borne uniquely certain process sense member name positive subject addressing process name negative subject 
conventions maintained automatically require discipline 
fact name uniquely borne invariant useful prove certain process communities distributed operating systems 
length point naming illustrates point ontological commitment 
return describing calculus 
summation form sigma represents process able take part alternatives communication 
choice process commit alternative occurs occurrence precludes alternatives 
processes form called normal processes see processes converted normal form 
normal processes shall syntax version calculus confine summation normal processes previously allowed form arbitrary processes 
reason reduction rules section simpler constraint forms jq little significance 
adjusted allow general summation 
forms process mean 
jq par simply means concurrently active act independently communicate 
bang means jp copies wish 
risk infinite concurrent activity reduction rules see 
operator called replication 
common instance replication resource replicated requester communicates 
new restricts name way describing declares new unique name distinct external names behaviour subtle 
fact character calculus derives interplay binding operators binds somewhat binds calculus exact correlate calculi restriction operator ccs promoted influential role 
looking examples introduce convenient abbreviation 
processes xy common prefer omit trailing write just xy 
simple examples consider process xy uv xz abbreviate xy uv xz call communications occur channel send send alternatives result yv xz xy zv note yv zv communication determined channel output consider variant xy uv xz case free quite different bound communication happen yielding yv xz restriction vanished left restricted communication 
third consider xy uv xz differs case replicated 
spin copy communicate system yv xz spin copy communicate system yv zv just seen examples reduction transformation process corresponding single communication 
calculus reduction rules analogy reduction calculus striking differences 
structural congruence said binding operators input prefix binds restriction 
define free names fn bound names bn process usual way 
extend prefixes note bn fyg fn fxg bn xy fn xy fx yg names process def bn fn 
reduction system simple wish identify expressions 
typical case want commutative associative 
define structural congruence smallest congruence relation laws hold 
agents processes identified differ change bound names 
symmetric monoid 
symmetric monoid 


fn jq exercise show fn 
note laws allow restriction inside normal process pulled outermost position example xy yz yz xy yz xy yz xy transformation brought juxtaposition delta delta delta xy delta delta delta reducible rules follow 
structural laws bring juxtaposition suggested chemical machine berry boudol 
reduction rules section devoted defining reduction relation processes means transformed single computational step 
computation step consists interaction normal terms 
reduction rule communication comm delta delta delta delta delta delta xz pf yg ingredients 
communication occurs atomic normal processes complementary subjects complementary 
second discard alternatives instance delta delta delta course communication pre possible communications 
comm axiom inference rules number 
say reduction occur underneath composition restriction third simply says structurally congruent terms reductions 
par res 
struct exercise section previous exercise reductions informally 
check inferred rules 
important see rules allow 
allow reductions underneath prefix sum example xz 
prefixing imposes order reduction 
constraint necessary 
calculus changes non trivially relax shall consider possibility 
second rules allow reduction beneath replication 
sense reduce computational power inferring equivalent allowing unboundedly coexisting copies reduce infer delta delta delta times delta delta delta reductions reducing copies require finite require finitely third rules tell potential communication process processes 
reduction behaviour separately infer reduction behaviour say jq 
just calculus xx xxx reduction behaviour reductions applying term yy gives terms xx yy xxx yy different reduction behaviour 
wish identify potential communication process distinguish say xy xz involved familiar labelled transition systems process algebra introduced 
want 
technical reasons want little 
precise want distinguish processes perform external communication location ff name name 
give simple definitions 
say occurs unguarded occurs prefix 
example unguarded qjr say observable ff write ff occurs unguarded ff subject unrestricted 
xz xz xz reduction 
turns get interesting congruence terms ff set chapter digress chapter look applications 
applications section give simple illustrations calculus 
introducing convenient derived forms abbreviations 
derived forms applications want forms primitive basic constructions monadic calculus 
things find useful multiple inputs outputs channel 
natural abbreviation write yz xyz xy xz 
give misleading impression pair actions case 
consider yz xy xy example intention get bound adopt abbreviations third possibility mix get bound avoid mix way needed making single commitment multiple communication done private restricted names 
introduce abbreviations delta delta delta delta delta delta xy delta delta delta xw wy delta delta delta wy writing just 
check mix example longer possible 
abbreviation introduced extra communication case cause problem 
wish define parametric processes recursively 
example may define arity respectively def yz def yz wish allow parametric process definitions general form def add delta delta delta syntax processes ranges process identifiers definition add new structural congruence law xg section 
easier develop theory definition making taken primitive 
fact provided number recursive definitions finite encode replication new constants definitions just matter convenience 
shall content showing encode single recursive definition single parameter 
suppose def assume fn fxg may contain occurrences different parameters 
idea replace recursive call little process ay new copy 
new name 
denote result doing replacements replication corresponds parametric process 
take care outermost calls occur system replace az note places separate copy replication call alternatively single copy transform replacing call just az replace course translations behave identically original reduction call weakly congruent original sense require applications 
applications shall freely parametric recursive definitions knowing translation possible theoretical development shall ignore stick replication 
mobile telephones flowgraph application base give alert ae ae ae ae ae ae talk ae ae ae ae ae ae switch ae ae ae ae ae ae give ae ae ae ae ae ae alert pi pi pi xx car talk switch centre simplified version system parrow illustrate calculus 
centre permanent contact base stations different part country 
car mobile telephone moves country contact base 
gets far current base contact way model hand procedure initiated result car relinquishes contact base assumes contact 
flowgraph shows system state car contact base may written system def talk switch give alert car talk switch base centre components 
car parametric talk channel switch channel 
talk talk repeatedly time switch may receive new channels start car talk switch def talk car talk switch switch talk switch car talk switch base talk repeatedly car time receive give channel new channels communicate car idle define base def base st hand may told alert channel active def base define abbreviation base def base talk switch give alert similar abbreviation example base talk base give switch alert base centre initially knows car contact base decide information model transmit channels talk switch car base alert base fact 
define centre def give talk switch alert centre centre def give talk switch alert centre exercise check carefully system reduces steps system precisely system subscripts interchanged 
reduction set restricted channels system car talk switch base centre 
car talk switch switch talk switch alert centre 
car talk switch alert centre 
car talk switch base centre system course example highly simplified 
consider possible refinement 
reason number available talk switch channel pairs equal number bases base uses 
reader may experiment having arbitrary fixed number bases handover new base chosen random channel pair picked store available channel pairs maintained say queue 
numerals arithmetic second application show arithmetic done calculus way calculus 
church represented natural number calculus function iterates function argument times 
attempt calculus may choose represent parametric process def delta delta delta times abbreviate process tested zero arithmetic operators coded processes need test zero 
give parameters representing successor representing zero xz def arithmetic 
shall represent binary summation example parametric process add yw channels represent arguments represent result 
commas separating parameters add just clarity 
correctness representation expressed equation add yw yw means weak congruence 
achieve define copy successor mutual recursion copy xz yw def succ xz yw succ xz yw def copy xz yw developed machinery easily prove induction xz xz copy xz yw yw xz xz succ xz yw yw consider induction step example xz xz copy xz yw 
xz xz copy xz yw xz xz copy xz yw yw induction yw step argument needs justification extraction leading position 
complete argument show reduction line replaced 
routine consequences theory weak congruence 
having copy available define addition add yw def add yw copy yw exercise show add yw yw induction similar argument inductive proof earlier 
prove general correctness property add 
reader noticed numerals ephemeral xz accessed 
copying needed 
fact try define multiplication find need double xz produces copies xz 
natural expect replication come aid 
fact replication directly numerals defined general representation data structures treat 
invariants process communities look desirable behavioural properties mobile systems able find syntactic conditions ensure properties enjoyed 
unique names section mentioned unique naming discipline 
formalize simple way give conditions process community obeys discipline 
consider system delta delta delta delta delta delta call component say friendly obvious word 
satisfies conditions 
fn closed system 

contains composition replication 
systems friendly example mobile telephone system section friendly recursion coded replication 
thing notice stay friendly friendliness preserved reduction 
easy prove 
note reduction change friendly system works spinning copies replications required replica say process bears name occurs free positive subject 
clearly necessary condition receive input immediately 
sufficient occurrence unguarded 
example bears sending message addressing component name spin copy resource thing ensure friendly system time component receive message consider condition 
component bears clearly means output component determined destination 
condition preserved reduction 
thing replication may produce components bearing component may acquire bearing example vx clearly condition destroyed reduction 
gives hint extra conditions ensure preservation 
sigma jk jk jk bears 
expression occurs bear note allows bear condition says effect bearing name acquired 
quite obvious proved conditions invariant reduction 
say name uniquely borne satisfies condition 
intuitively means output determined destination 
able give syntactic conditions ensure uniquely borne system unique handles dual property unique naming useful ensure operating system sequential fortiori concurrent 
property time component handle resource 
things precise say handle name occurs free negative subject 
clearly necessary condition able send output immediately sufficient occurrence unguarded 
look friendly systems consider condition 
component handle means example sequence messages different components accidentally interleaved clearly desirable gives access printing device 
condition preserved reduction argued just condition 
wish proceed differently unique naming 
case conditions ensured bearing name acquired 
contrast want allow handling capability transmitted freely components subject 
wish impose condition inputs 
want impose condition outputs component transmits handle transmit 
naturally arrive conditions 
handle 
vz occurs contain free 
condition says effect agent transmits name forget 
note may bound may stand name received time component 
say name uniquely handled satisfies condition 
syntactic conditions ensure uniquely handled system exercise concentrated simplicity giving conditions 
try find slightly weaker conditions ensure name uniquely borne uniquely handled friendly system 
examples just looked suggest syntax calculus rich allow interesting structural invariants defined turn ensure useful behavioural properties 
cases reader may felt blanket condition inputs outputs unnecessarily strong 
weakened satisfactorily apply names particular sort introduced sorting discipline chapter 
polyadic calculus abstractions section saw polyadic input delta delta delta polyadic output xy delta delta delta encoded quite straightforwardly monadic calculus 
sight may regard mere device theoretical interest 
reason shall gain polyadic communication primitive 
reason abstractions 
second reason sorts deferred chapter 
abstraction takes form delta delta delta equivalently delta delta delta just abstraction names process 
quite different abstraction calculus bound name instantiated name compound term 
abstractions useful various ways 
essence parametric definition writing def naturally write def delta delta delta second abstraction defining combinators 
consider example process free names representing links oeae want chain processes link joining link right neighbour ccs renaming operator define chaining combinator def oeae oeae abstraction calculus renders renaming operator superfluous 
fact define chaining combinator processes binary abstractions def xy xz suppose xy xy obtain easily xy yg qf xg course substitution xg meta syntactic operator 
see abstraction handy definitional device calculus remain clear computational significance possesses calculus significance depends instantiating bound variable arbitrary term grammatically incorrect calculus 
abstraction earns place merit preserve distinction binding operator instantiation allowed input prefix 
simply declare abbreviation def factoring input prefix parts part abstraction shall call location 
location indicates name stands received 
course quite unreasonable allow polyadic input delta delta delta def delta delta delta notational question arises 
adopting form abstraction risk misconception calculus extension calculus 
serious misconception main motivations calculus belief order unify functional concurrent computation needed basic constructions primitive calculus 
ways lightweight form martin lof attractive 
forms binding abstraction restriction clearer mark symbol 
higher order processes chapter abstraction process variables closer calculus symbol appropriate smoother notation abstraction versions calculus 
study sorts shall find reasonable necessary allow polyadic input wish respect natural sort discipline 
shall say abstraction delta delta delta arity particular process abstraction zero arity 
concretions treat output dually input 
immediately suggests consider output prefix form derived form xy delta delta delta def delta delta delta ep factoring parts location concretion dy delta delta delta ep consider equivalent dy delta delta delta dy ep arity call datum name concretion 
process concretion zero arity 
abbreviations convenient write bd bd 
may useful consider concretions having arity agent abstraction concretion may integer arity 
consider simple form reduction pf yg name vectors equal length components distinct 
natural generalization comm polyadic case ignoring moment 
takes form abstraction concretion equal arity gamma gamma defined obvious way see section 
far concretions may appear notational elegance 
fact conceptual significance 
illustrate considering truth values case analysis illustrate importance admitting restriction concretions 
calculus terms taken represent truth values 
abstraction analogously define true def false def calculus 
truth value located boolean location process true 
located truth value may compared natural number xz section located pair names abstractions purer representation data shall extend general data structures 
consider concretion representing case analysis cases def occur represents offer select name fact pseudo application find true cases similarly false cases slightly imperfect prefer cases free names prefer represent case analysis restricted concretion cases def tf ensures distinct names 
true cases tf note right hand side reduces weakly congruent restriction 
emphasize role played concretions consider familiar conditional form calculus take mean inspect truth value located perform value 
see conditional form just located case analysis cases true cases true cases intriguing point abstraction restricted concretion offer subtly different forms closure arbitrary process free names may call closure bd concrete closure 
differ sense concrete closure ensures free names distinct distinct names environment hand closure offers arbitrary instantiation names 
allow mixed abstraction concretion allow enrich calculus valuable way 
leave version calculus natural rich purposes 
syntax structural congruence reduction moving monadic polyadic calculus main differences prefixes longer primitive abbreviations add forms abstractions concretions calling collectively agents ff fi range names names stand vectors names length xj yj normal processes ff processes abstractions concretions agents syntax wish represent identifications computational significance structural congruence processes laws structural congruence just section understanding change bound names allowed agent 
add rules 


interesting consequences laws immediately obvious 
fact laws convert abstraction standard form pushing restrictions inwards 
concretions datum name free 
laws pull restrictions data names outwards push restrictions inwards yielding standard form bd arity abstraction concretion just length vector standard form 
define pseudo application abstraction concretion confining case equal arity 
bd xj yj 
def xg help reduction system defined exactly monadic case definition reduction relation processes relation satisfying rules comm delta delta delta delta delta delta par res 
struct note reduction defined processes arbitrary agents 
comm equal arity 
reader may noticed defined application fy abstraction name 
formally need define def ff xg instance application eliminated structural congruence 
shall freely application 
fact wish introduce recursive definitions abstraction constants def abstraction may contain abstraction constants application indispensable device 
recall section parametric recursive definition freely examples ignore theoretical development eliminated favour replication weak congruence 
equivalence algebra logic reduction equivalence congruence recall section notions observability define new context polyadic calculus 
definition agent occurs unguarded occurrence prefix ff 
process observable ff written ff ff occurs unguarded ff unrestricted 
define natural notion bisimilarity takes observability account 
definition strong reduction equivalence largest equivalence relation processes jq implies 
jq 
ff ff ff notion called barbed bisimulation studied milner sangiorgi 
essentially barbed equivalence bisimilarity induced reduction relation extra condition observability 
reduction equivalence natural idea preserved process constructions 
example recall abbreviates left side reduction 
define definition strong reduction congruence largest congruence included reduction equivalence 
standard iff process contexts 
process context process term single hole placing process hole yields formed process 
reason imposing observability condition reduction equivalence reduction congruence coincides exactly strong early congruence relation 
proved 
example due erard boudol showing need observability condition 
purpose silent unobservable action shall introduce formally section 
define def def note reaches state reduction impossible 
congruent weakened omission observability condition 
shall weak reduction congruence defined essentially replacing transitive reflexive closure definition weak reduction equivalence largest equivalence relation processes jq implies 
jq 
ff ff ff shown condition relaxed simply means ff ff changing induced congruence 
shown weak version 
weak reduction congruence largest congruence included weak reduction equivalence 
turns congruence coincides weak analogue strong early congruence 
coincidences show satisfactory semantics calculus defined reduction observability 
sense definitions unsatisfactory quantification contexts far direct way characterizing congruence gives little insight 
proceed repeat treatment bisimilarity form appropriate new presentation calculus 
bisimilarity equivalences close induced congruences 
commitment congruence atomic normal process ff regarded action ff continuation 
accurate think ff location action term 
shall call ff commitment process committed act ff 
idea want formalize semantically process general set commitments 
means process semantically congruent normal process shall justify term set showing congruent way shall formalize defining relation ff processes commitments pronounced commit ff 
course exactly labelled transition system achieved different notation 
example labelled transition xy similarly transition 
joachim parrow suggested 
concretions effect allows 
usage just notational convenience yields satisfactory presentation calculus dynamics see 
preliminaries necessary 
introduce unobservable action henceforth allow ff fi stand name 
second wish extend composition operate abstractions concretions compose abstraction concretion 
line definition pseudo application section names occur def fact prefix definable def fn 
similarly bd bd names occur def bd clearly associative commutative general processes 
note process abstraction concretion defined agent process ja 
ready define operational semantics terms commitment 
definition commitment relation processes commitments smallest relation satisfying rules sum delta delta delta ff ff comm par ff ff res ff ff ff fx xg struct ff ff reader familiar notice simpler operational semantics 
course complexity concealed laws structural congruence laws speak concern dynamics action deserve factored apart dynamics 
treatment restriction derives benefit admission restricted concretions restriction rule res covers rules res open 
remaining side condition res essence restriction side conditions rules administrative avoiding clashes free bound names 
shall proceed define natural form bisimilarity terms commitment 
desirable property relations job simpler definition arbitrary binary relation agents 
say respectable includes structural congruence respected decomposition concretions application abstractions 
jd standard forms bd bd jq 

jg arities equal say length jg note dual congruence condition relation preserved decomposition composition 
define bisimulation bisimilarity agents processes follows definition relation agents strong simulation respectable jq ff ff ajb 
strong bisimulation converse simulations 
strong bisimilarity largest bisimulation 
may describe largest respectable equivalence closed commitment 
union bisimulations prove need exhibit bisimulation containing pair 
strong late bisimilarity 
pointed quite congruence relation 
fact preserved substitution names names example preserved agent construction abstraction 
closer induced congruence case reduction equivalence 
close gap need impose closure substitutions 
oe range substitutions replacements xg names distinct names 
definition strongly congruent written oe qoe substitutions oe 
proposition congruence 
proof lines 
axiomatization making minor adjustments allow abstractions concretions axiomatization complete finite agents replication 
definition theory sge strong ground equivalence smallest set equations agents satisfying write sge mean sge 
sge 
sge closed agent construction abstraction 
example sge sge 
sge fy gy sge 
sge 
sge ff 
expansion sge ff summand mg fi summand ng sigmaf summand resp 
summand resp 
ground equivalence synonym bisimilarity term ground indicates theory closed substitution names 
theorem soundness sge sge proof lines 
theorem completeness sge finite sge proof lines 
essence sge agents equivalent iff equivalent commitments 
proof completeness depends showing normal process sum commitments sge characterization allows show exactly strong congruence fact stronger strong reduction congruence processes equivalent commitments particular distinct behaves takes particular value behaves turns rule effect finitary hypothesis need proved name free new example commitment distinct commitment 
omit full details argument 
modify strong bisimilarity induced congruence coincides exactly answer relax condition positive commitments 
definition strong early bisimilarity largest respectable equivalence jq 
arity length exists jg 
jd 
condition positive commitments weaker effectively demands stronger condition clear nearly congruence closed construction abstraction 
define definition strongly early congruent written oe qoe substitutions oe proposition congruence 
recovered reduction congruence theorem sangiorgi strong early congruence coincides reduction congruence shall consider equational laws joachim parrow axiomatization involves extra process construction 
properties replication interesting process systems usually involve infinite behaviour replication 
equational theory sge hope prove true equations infinite systems fact recursively enumerable 
process algebras techniques purely algebraic reasoning 
shall technique bisimulation due park 
wish prove simple important properties replication needed 
proposition proof shown routine way bisimulation process part theta consists pairs empty ensures set pairs closed substitutions congruence holds 
property shows duplication replicable resource behavioural effect surprising 
shall look subtle property concerning may called private resources 
system contains subsystem may call private resource acquire replica 
course may contain free names replica active may interact rest 
suppose jp 
share private resource 
difference give private resource 
true moment thought reveals hold general 
take 
access resource lefthand side right hand side interact bisimilarity fails 
bears name terms section 
impose condition bears name occasion shall slightly different extra condition section property invariant action 
extra condition amounts saying access resource occur free object desired result follows 
precise proposition assume free occurrence negative subject 
proof shown bisimulation theta consists pairs occurs free negative subject 
checked relation closed substitutions result follows empty 
shall see section persistent data structures instance replicable resources 
proposition interpreted saying difference processes share data structure private copy 
way think previous proposition private resource distributed composition 
immediately suggests question 
obviously hope distributed replication true 
proposition assume free occurrence negative subject 
proof proceed notion bisimulation 
just means known exhibiting new bisimulations 
previous proposition shown bisimulation containing process pairs occurs free negative subject 
take empty get result 
striking consequence propositions shall see section fi conversion equationally valid interpretation calculus calculus 
essentially model application abstraction xm term calculus providing access resource appears properties replication quite wide applicability computational phenomena appear significantly different seen accessing resources 
logical characterization modal logic defined give alternative characterization bisimilarity relations calculus familiar line process algebra 
done ccs hennessy milner see milner chapter 
inference system defined logic aim just define satisfaction relation processes logical formulae way bisimilar iff satisfy exactly formulae 
main attention modalities particular modality input hx late early strong bisimilarity differ just requirement input transitions input modality versions hx iff yg yg hx iff yg yg highlighted difference quantifier inversion 
representing commitment factoring input prefix parts location abstraction allows simplify logic similar factoring 
holds output modalities 
fact find logical constructions abstraction concretion hope dependent product dependent sum action modality suitably primitive 
logic characterize late bisimilarity set formulae syntax hffi sigmax pix ff ranges names names 
sum product bind satisfied respectively concretions abstractions non zero arity 
hand hffi satisfied processes 
definition satisfaction relation agents formulae induction formula size follows iff iff iff name hffi iff ff sigmax iff fn sigmax case xg pix iff ay xg note hxi piy exactly hx shall consider hx 
intriguing point expected need restriction exact definition require fn form meaning place atomic formula presence logic cope output modality exactly bound data name concretion 
side condition sigmax case takes care restrictions agents 
clarify consider bisimilar view characterization theorem formula distinguishes 
fact take hxi 
proof done lines theorem logical characterisation iff iff task see weaken order achieve logic characterizes weaker larger equivalence reduction equivalence early bisimilarity 
key demand abstraction commit matched abstraction equivalence depends matching process instance abstraction pair logic weakened depend directly properties entails removing positive action modalities hxi replacing effect polyadic version hx hx iff yg yg call weakened logic theorem logical characterization iff iff sorts data structures functions look examples hitherto illustrate calculus see obeys discipline names 
mean simple just length nature vector names name may carry communication 
numerals section names carry empty vector 
mobile phones section interesting alert give talk carry empty vector switch carries pair 
just pair talk switch pair 
section carry boolean location carries pair 
may realistic application calculus disciplined natural way discipline different case 
loose analogy untyped calculus application studied right type discipline kind simple type hierarchy second order calculus system value dependent types 
kind name discipline comes mind calculus employ arities martin lof arity sense just properly nested sequence parentheses 
name carries arity name carries vector names arities arity delta delta delta 
simple 
hierarchy arities name carry name kind arity witness switch mobile phone example 
propose discipline sorts simple possible admitting kind circularity amounts admitting kind self 
sorts assume basic collection subject sorts infinity names subject sort write 
object sorts ob just sequences ob shall write delta delta delta possibly interspersed commas object sort empty object sort 
range object sorts 
sbt concatenation object sorts 

define sorting non empty partial function ob ob ob finite typically write 
ob 
ob sorting just describes name sort name vector carry 
numerals section uninteresting sorting succ 
zero 
succ zero 
phones section little interesting alert 
give 
talk 
switch 
talk switch alert alert switch switch 
note little reason distinguish alert give distinguish talk distinction gives precise information kind messages carried switch channel 
sorting ob give conditions agent said respect ob 
show ascribe object sort suitable agent equal length numeric arity process sort 
definition agent respects sorting ob sorted ob infer object sort formation rules ob ob bs bs exercise prove assume equal sort af xg prove assume 
assume change bound names name replaced equal sort 
recall definition application composition abstractions sections 
prove formation rules admissible bs fy sbt rule admissible proof rule transformed 
simple correspond familiar calculi 
simplest sorting name 
subject sort carrying just ccs simplest name 
name just monadic calculus 
course refined monadic calculus classify names clearly ob singleton sequence recall encoding multiple inputs outputs monadic calculus section example notation delta delta delta 
delta delta delta translation destroys 
different sorts subject sort choose right hand side ill sorted 
shows admits sort discipline possible monadic calculus 
second reason introducing promised chapter 
data structures representation natural numbers section rough ready generalize arbitrary data structures mean data freely constructed finitely constructors 
illustrate general method defining single level list structures elements represented subject sort val 
sorting list 
cons nil cons 
val list nil 
constructors cons nil cons def cn nil def cn cons val list cons nil nil cons nil 
think simple abstractions cons nil nodes data structure particular nil leaf node 
node case list node located name sort list 
cons value located cons corresponds familiar picture list cell cons think located node follows address send form sections filled 
value cons fills section components signs nil signs second section fill 
consider lists truth values setting val equal bool 
complete list containing say truth values true false 
restricted composition list nodes truth values def cons true cons false nil note free name 
diagram mark private locations cons true cons false nil note diagram standard way linked lists flow graph drawn usual manner process algebra 
exercise revisit numerals section 
give representation natural numbers analogous lists terms sorting nat 
succ zero succ 
nat zero 
point general pattern data structures clear clearly truth values section follow pattern 
analogy truth values defined earlier give concretion case analysis lists def cn little programming lists define sugared form located case analysis vl style standard ml follows case cons nil note constructions patterns binding variables define append function concatenate lists way defined addition numerals copy def case cons cons copy nil nil append def case cons cons append nil copy expressions representing lists expression representing concatenation lists shall lm append expression exhibits list built located values located nodes 
notice located list location location root node 
interestingly subexpression corresponds list containing true false sublist containing just false 
transform strongly bisimilar form contain subexpressions 
fact list values def cn bl true def cn bl false def nil def cn notice closed expressions just true false closed 
mean reasonable refer terms values 
persistent values treatment data structures purely ephemeral accessing destroys 
replication persistent 
reverting natural thing replicate nodes component values giving def cons true def cons false def nil see happens interrogate 
concretion get pf cons true seeing structure links note particularly sharing pointers cons true cons false nil get different story apply replication nodes just done sublists 
best done form consider located list def cn bl true def cn bl false def nil def cn interrogate 
time get true comparing see sharing pointers names free seeing different structure links cons true cons false nil true cons false nil diagram clear time complete list traversed new copy component encountered 
taken care phenomenon kind distinction give rise subtle errors programs sequential programs 
course distinction cause serious behavioural difference list elements just values true false storage cells stored values may updated 
distinction second case storage cell copied replication case list nodes copied 
reminiscent distinction pascal call value call name parameter passing mechanisms case scalar variables arrays 
burstall addressed problem giving rigorous proofs list processing tree processing including assignment 
interesting features common names locations list segments carried succinct program proofs terms standing list segment starting location finishing containing element sequence internal locations distinct 
intriguing encode entities proofs calculus restriction 
seen calculus model refined phenomena data storage 
lack space shall deal updatable storage cells quite straightforward method defining registers ccs chapter 
exercise seen behave differently bisimilar 
try find logical formula logic section satisfied 
hint test sharing 
functions shown translate lazy calculus calculus translation discussed fully shall go great detail 
worth repeating translation polyadic setting particularly sorting respects 
recall terms calculus xm mn ranges variables 
just section shall underline calculus distinguish calculus abstractions calculus abstractions 
reduction relations calculus satisfy rule fi xm mfn xg relations differ contexts admit reduction 
simplest sense admits reduction extreme left term 
known lazy reduction model theory investigated detail abramsky 
lazy reduction relation calculus terms smallest satisfies fi rule appl mn translation introduce subject sort var calculus take names sort var exactly variables calculus 
intuitively name location argument function 
introduce subject sort args names names locate argument sequences 
term calculus translated calculus abstraction reduces abstraction xn correspondingly reduction receive argument sequence name arguments fact argument sequence represented pair name argument name ensuing sequence 
reflected sorting var 
args args 
var args translation gamma easily seen respect sorting xm def def mn def note third equation argument list located note replication may argument repeatedly 
important note translation specific lazy reduction strategy 
theorems show lazy reduction closely simulated calculus reduction translated terms 
different translation plotkin call value calculus striking translation respects different sorting 
shall outline proof fi reduction equationally valid calculus interpretation lazy calculus 
prove term calculus provide replicable resource consisting located behaviourally equivalent mf xg lemma free mf xg proof note set equations form shown closed substitutions prove result place 
note equation abstractions applying sides arbitrary args need show mf xg proof proceeds induction structure shall give details draw attention important step 
case propositions replication section justify creation copies private resource separately 
cases involve little reduction inductive hypothesis 
sketch proof main result 
theorem xm mf xg 
proof assume occur free justified translation respects change bound variables calculus 
reasons need demonstrate weak bisimilarity conclude theorem 
doing single reduction show args xm remains apply lemma 
higher order calculus recall section pure ccs communication carries data corresponds sorting fname 
calculus 
flow data communication indirect way represent mobility processes dynamic change neighbourhood 
calculus allows names flow communication achieves mobility concrete way 
approach allow processes flow communication process may send process message consists third process various authors studied process flow 
particular thomsen developed algebra higher order processes chocs natural extension operational semantics ccs 
follows shall describe component concretion datum 
effectively chocs allows processes data calculus allows names 
processes data part motivation calculus get effect processes data simply names data 
crudely speaking sending process send name gives access simple example consider jq def def calculus defined concretion process datum abstraction name variable processes 
higher order calculus allows expect reduction get effect locating new name sending 
issues encoding 
general 
special case ignores complications 
second independently pleasant properties may higher order calculus enjoyed order calculus 
property may clarity expression encoding may encoded expressions may obscure 
address question encoding 
thomsen examined 
gave translation shall write plain chocs calculus exhibited detailed correspondence operational behaviours ideally prove double implication natural congruence thomsen came close proving observation congruence unfortunately double implication appears fail directions subtle reasons 
stimulated thomsen sangiorgi able show implication hold directions taken weak reduction congruence natural analogue strong reduction congruence introduced section 
furthermore results holds processes data sorting constraint data may process abstractions arbitrary high order 
syntax commitment rules extend syntax higher order decide data allow 
admit just processes data chocs 
prefer go admit parametrized processes abstractions data 
adds considerable expressive power admit processes name parameters example define chaining combinator section abstraction processes admitted data follows def xy xy zy stand processes abstracted names see parameterization things job renaming operator ccs 
go allow parameters abstractions may proceed directly order calculus just names data order calculus 
change needed syntax section slight 
give unsorted version treat higher order sorts section 
introduce abstraction variables syntax abstractions abstractions fx fg notice application introduced explicitly needed abstraction variables see example 
concretions may contain abstractions data concretions df ec processes remain unchanged admit abstraction expression example process add clause processes delta delta delta structural congruence rules section need obvious extensions example add rule concretions bdf ec df fn leave reader supply obvious rule application fg abstraction obvious extension definition change needed reduction rules section definitions observability ff section reduction equivalence congruence section commitment section 
minor point natural confine definitions agents free abstraction variables 
stark constrast subtle difficult question arises trying generalize definition strong bisimilarity section 
shall content intuitive description problem 
issue concretions hold require concretion corresponds suitably correspondence 
section demanded identical data bd bd appropriate data names data abstractions 
case appropriate ask bisimilar identical 
thomsen took course 
plausible requirement argue strong 
consider example cep bd ceq certainly sense bound restriction action observed directly 
take way action complemented case reasonable take equivalent 
example due eugenio moggi 
sangiorgi defined natural version strong bisimilarity achieves equivalence induced congruence coincides strong reduction congruence furthermore suitably ignoring actions corresponding weak bisimilarity induces congruence coincides weak reduction congruence defined section 
alternative characterization reduction congruences adds importance 
furthermore weak reduction congruence precise sense higher order processes encoded order processes 
section give encoding proof sangiorgi faithfulness immediate 
extend sorting higher order 
higher order sorts extension syntax ignored sorts reader may felt uncomfortable nonsense written unsorted calculus higher order 
example application clearly nonsense sorting discipline forbid 
recalling order sorting discipline section simple change 
object sort sequence subject sorts 

allow object sorts occur sequences allow 
words element sequence may data sort data sorts dat dat def ob disjoint union define mutual recursion ob def dat assume infinitely abstraction variables object sort write new arrangements formation rules section remain unchanged merely extend abstractions bt bt fx bt fg concretions df ec bt say sorted ob infer formation rules 
introduced rich sort discipline comparable simple type hierarchy calculus 
important see missing 
note naturally arrow sort representation giving syntax higher order object sorts syntax clear object sort form delta delta delta 
data sort 
done choose write form delta delta delta formation rules written bt familiar see missing sorts form delta delta delta 
inhabitant sort 
take data parameters return name 
presence calculation names simple subtle behaviour restriction operator scoping device names appears lost 
essence syntactic scoping scoped bound occurrences name syntactically manifest longer case name calculation 
point course equally relevant order calculus deserves examination 
sorting knowing sort name variable easy determine unique sort exists agent 
intriguing problem agent sorting sort information find sorting ob assignment sorts names variables sorted ob 
non trivial problem order 
remains seen sense general sorting find 
exercise find higher order sorting ob sorts names variable respects ob bd ce jx xy translating higher order order having generalized notion sort see relationship higher order calculus thomsen plain chocs 
clear 
thomsen allows processes names transmitted communication communicated datum chocs sort 
corresponds sorting name 
justified regarding chocs second order notice order calculus subsumed chocs 
define order sorting simply maximum depth nesting parentheses object sorts 
definition second order properly includes order calculus chocs admits admits containing object sorts 
section introduce illustration formally translation processes arbitrarily high order order effectively extending thomsen plain chocs 
translation denote operates sorts processes 
close operational correspondence shall illustrate correspondence express theorem 
wish state theorem expresses faithfulness translation terms preserving congruence 
theorem proved sangiorgi 
holds processes respect finite higherorder sorting contain free abstraction variables 
shall call proper processes 
theorem sangiorgi ob finite sorting arbitrarily high order proper processes respect ob 

respects ob 

ob order ob ob 
iff translation constructed iteratively 
iteration applies translation sorting process proof theorem proceeds showing asserted results hold exactly ob necessarily order 
ob finite ob lower ob clearly founded ordering completes proof 
illustrate 
suppose ob 


ob order choose highest order data sort object sort range ob 
choose 
replacing new subject sort adding 
sorting 
obtain ob 



clear iterating finite sorting reach order finite number steps 
exercise measure decreased 
slightly simpler sorting ob 

illustrate translation processes 
ob 


bdf eq xy xz respects ob provided 
describe outline 
translation affects subexpressions ff subject sort object sort ob changed 
case involved 
appropriate changes replace datum sort new restricted datum name new name place abstraction variable reader may point compare simpler example section dealing extra complication occurs twice variable abstractions processes 
note particularly replication datum may times recipient translation allow repeated access 
access bound note argument applied translation transmitted communication 
check reduction fy matched triple reduction translation fy fz fy fz fy fz note single application deals subexpressions ff ff example translation order sorting ob order 
general new prefixed expression may need treatment iteration noting case ob order 
ask theorem sufficiently general 
constraint free abstraction variables great concern 
questioned useful processes respect sorting 
remains constraint sorting finite 
interesting infinite conjecture process respects sorting respects finite sorting amenable translation 
true theorem quite general 
abramsky lazy lambda calculus appear declarative programming ed 
turner addison wesley 
astesiano reggio driven concurrent calculi lecture notes computer science vol pp springer verlag 
astesiano zucca parametric channels label expressions ccs journal theor 
comp 
science vol pp 
baeten weijland process algebra cambridge university press 
berry boudol chemical machine proc th annual symposium principles programming languages 
boudol lambda calculus concurrent communicating systems proc 
tapsoft lecture notes computer science vol pp springer verlag 
burstall techniques proving correctness programs alter data structures machine intelligence ed 
meltzer michie edinburgh university press pp 
engberg nielsen calculus communicating systems label passing report daimi pb computer science department university aarhus 
girard linear logic theoretical computer science vol pp 
hennessy algebraic theory processes mit press 
hennessy milner algebraic laws non determinism concurrency journal acm vol pp 
hewitt bishop steiger universal modular actor formalism artificial intelligence proc ijcai stanford california pp 
hoare communicating sequential processes prentice hall 
kennaway sleep syntax informal semantics parallel language lecture notes computer science vol pp springer verlag 
milner calculus communicating systems lecture notes computer science volume springer verlag 
milner communication concurrency prentice hall milner functions processes research report inria sophia antipolis february 
appear journal mathematical structures computer science 
milner sorts calculus proc 
third workshop concurrency compositionality germany appear volume springer verlag lecture notes computer science 
milner parrow walker calculus mobile processes reports ecs lfcs laboratory foundations computer science computer science department edinburgh university 
appear journal information computation 
milner parrow walker modal logics mobile processes report ecs lfcs laboratory foundations computer science computer science department edinburgh university 
appear proceedings concur amsterdam 
milner sangiorgi barbed bisimulation internal memorandum computer science dept university edinburgh 
nielson typed calculus class processes proc 
parle lecture notes computer science vol springer verlag 
parrow algebraic verification mobile network internal report sics sweden 
appear journal formal aspects computer science 
park concurrency automata infinite sequences lecture notes computer science vol springer verlag petri fundamentals theory asynchronous information flow proc 
ifip congress north holland pp 
sangiorgi forthcoming phd thesis university edinburgh 
thomsen calculi higher order communicating systems phd thesis imperial college london university 
walker calculus semantics object oriented programming languages report ecs lfcs laboratory foundations computer science computer science department edinburgh university 
proc 
conference theoretical aspects computer software university japan september 
