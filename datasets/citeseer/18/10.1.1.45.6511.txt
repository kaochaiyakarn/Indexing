lightweight guis functional programming ton daniel wolfram schulte fakultat fur informatik universitat ulm ulm germany email daniel informatik uni ulm de 
graphical user interfaces guis hard combine functional programming 
suitable combination monads able tame imperative aspects graphical straightforward elegant way 
concept integrate lightweight guis functional framework library basic functions layout combinators manipulate gui 
implementation library set high level graphical routines outlined 
examples demonstrate simple way applications written 
everybody wants graphical user interfaces 
everybody wants functional programming languages 
unfortunately concepts hard combine graphical particular imperative nature contradictory functional paradigm 
goal reconcile concepts developing framework functional programmer smoothly provide program graphical user interface 
various ways integrate general functional language nr 
chosen monadic choice firstly motivated advantage monadic combined threading global state programs 
secondly monadic programming expresses sequentialization actions better styles 
monads natural choice system 
implementation graphical deliberately chosen reinvent wheel existing high quality tool tcl tk ous 
tool visualizes user interface handles events console communicates functional program form strings 
reduced side functional program graphical textual primitives provided glasgow haskell gofer jon 
define library functions manipulating gui 
programmer write gui application structured defined way having knowledge tool 
communication takes place tool functional program completely hidden user 
advantages approach easy 
convenient abstraction level library functions main problems consider creation gui ones 
unity framework 
application programmer write user interface application proper language 
modularity 
gui state application state independent 
possible write modular reusable building blocks create larger applications 
generally applicable 
long monadic supported framework implemented functional language lazy eager 
simple implement 
lines written code gofer 
easy extend libraries 
organization 
section describes way monads reach desired abstraction level 
section gives glance structure interface functional gui library 
example applications sect 

relevant implementation aspects discussed sect 

comparison related sect 
drawn sect 

notation 
programs written gofer jon subset haskell 
characteristics syntax lambda abstraction 
function names infix operators placing placeholders values discarded 
monads seminal moggi mog monads increasingly popular 
wadler wad functional programming numerous applications published wad jd kl wad 
general monad serves record side effects functions 
example monad implemented glasgow haskell compiler laid new definition haskell language gofer language jon 
state reader monad enables user thread reading state program 
likewise monads handle exceptions non determinism continuations state reader monads relevant sequel 
concepts laws monad consists parts parameterized datatype polymorphic functions result 
bind 


datatype encapsulates value type action operation 
bind performs action retrieves proper value passes function monad 
result function encapsulates value void action 
programming monads writes functions typing 
strings bind 
bind replaces function application reflected monad laws bind associative result left right identity 
notation described jon 
expression fe replaces equivalent bind 
bind 
subexpression binds result result subexpression discarded 
monadic mutable variables clearly need perform predefined io monad comes primitive functions putchar char 
io io char writing reading characters 
secondly need means storing state 
mutable variables defined glasgow haskell gofer act io monad 
mutable variable manipulated functions newvar 
io var readvar var 
io writevar var 

io creating initial value reading value resp 
writing new value 
course multiple functions want access state stored mutable variable variable passed functions explicit argument 
example consider program fragment simple adder 
state consists integer viz 
running total 
function reads number calculates new running total looks add var int 
io add tot readvar getline result tot writevar value running total fetched variable line read 
new running total calculated written console stored variable defined generally purposes simplified version suffices 
combining monads monadic state reader integrate gui monadic framework 
gui changed dynamically part stored mutable variable 
variable accessible program threaded functions provided application 
problem specific guis library gives access global state library database functions cope 
need state reader monad consults fixed environment 
environment variable fixed contents may change 
consult need state transformer state reader suffice 
monads io state reader need combine 
done way bw jd data rio rio 
io rio 

rio 
rio rio rio 

rio rio io 
rio rio rio 
definition bind rio takes care state corresponding operations performed sequentially 
described functions act io monad putchar newvar embedded rio monad function rio 
embedded counterparts newvar readvar writevar appear sequel newstate programmer needs functions manipulate application state stored var 
gui state remains completely hidden programmer provide datatypes type gio rio var gui type action gio corresponding monad functions gio 
type action useful actions gui side effect proper result 
programmer worry defining state global application local window illustrated sect 

functional library graphical section presents relevant subset gofer library graphical user interfaces 
gui consists entities windows buttons events defined 
events caused user external process clock result action 
underlying application controlled way called event driven 
writing library graphical complex intensive job 
approach decided existing library graphical routines integrate library concept 
elegance power implementation tcl tk ous see sect 

library offers high level interface tool providing powerful set widget constructors layout combinators 
windows widgets basic building blocks graphical user interface windows widgets 
window container widgets 
widget graphical entity particular appearance behaviour 
distinguish kinds widgets buttons labels entries 
windows 
user interface may contain windows 
possible actions windows closing opening 
config 
widget 
action ident 
action type ident string functions yield actions 
action essentially produces side effects changes gui cf 
sect 

windows identified unique name 
name specified configuration list see 
closing window name provided 
widgets 
view widget atomic composite 
composite widgets see sect 

widgets form datatype 
atomic widget type library offers constructor function config 
widget config 

widget buttons labels static text line entry fields edit text line text fields edit text lines pull menus 
specifying external outline individual widgets windows done giving appropriate values configuration options name identifying window widget textual contents command performed pressing button data config name ident text string command action 
widget identified name configuration widget read modified read write textual contents functions ident 
gio string ident 
string 
action 
layout combinators widgets composed vertically horizontally layout combinators functions 
basic combinators widget 
widget 
widget combinators associative meaning 
places widget right widget places widget widget resulting new widget called father widget associate inherited occupied area 
inherited area area widget gets father 
occupied area displaying information centered subarea inherited 
initially occupied inherited area equal minimum dimensions needed widget display information 
combination widget occupied area father minimal 
concatenated sons placed left uppermost corner occupied area 
widget bigger widget inherited area equal occupied area inherited area equal rest occupied area father 
fill functions widget occupy inherited area horizontally vertically 
expand function widget claim father occupied area inherited sons 
expand widget 
widget fig 
see possible layout situations application variants combinators fill functions 
picture composed horizontally 
combined vertically second 
occupy inherited area horizontal direction 
result father grows full length third grow vertically 
fig 

layout combinators fill functions fig 
show result expanding widgets 
picture claim take area father 
likewise second area fig 

layout combinators expand functions claimed taken picture area claimed taken divided examples ex abbreviates expand additional combinators defined 





expand comb comb sketched layout mechanism combinators lay user interfaces arbitrary way 
additionally develop powerful layout functions widget expand matrix int 
widget 
widget matrix foldl map foldl function stretches empty widget pushing aside 
function matrix takes number columns list widgets composes row major order 
gives basic library user write window oriented applications 
may extended widget types configuration options essential structure remains 
running gui illustrate defined functions consider minimal hello world application see fig 

user presses button hello gofer window closed application terminates 
gofer program called main type io 
concept main call library function initial window setup 
sets user interface starts event loop 
window opened called main window 
main window closed termination follows 
main io main name title hello text hello gofer command fig 

hello world application applications order demonstrate usefulness approach illustrating examples 
describe calculator editor combination 
calculator take look simple desk calculator see fig 

calculator define state cf 
sect 
consisting actual value display accumulator function 
type var int int 
int function calculator initializes state opens window resets display 
main calculator calculator st newstate id title calculator calc st display user interface built entry widget matrix buttons keypad 
user presses digit displayed value component state updated 
operator pressed display reset accumulator function modified 
pressing button calculator evaluates accumulator function 
code listed implements calculator completely 
calc 
widget calc st disp keys disp name display relief width keys matrix map wid wid text command lift cmd width lift disp accu st disp accu result disp accu display show disp st disp accu cmd id cmd const cmd ord ord char op char op char op char op char op div function wid maps displayed character widget corresponding action 
action defined lift embeds associated command gio monad 
editor editor example illustrates layout combinators menus text fields see fig 

fig 

calculator editor editor state cut copy paste buffer implemented sequence strings 
details concerning state text widget actual position insertion cursor managed gui 
type buffer var string main editor editor buf newstate title editor name ed edit buf menubar editor pull menus 
left right 
applying configuration map raise relief menubar 
menubar placed 
edit buffer 
widget edit buf 


relief raised name text width height text file new warning really clear clear quit warning really quit ed text edit cut cute buf copy buf paste buf text help string 
action 
text command cut copy paste chosen edit menu buffer read overwritten 
implementation corresponding functions straightforward listed 
new quit chosen modal warning dialog opens 
user presses window closed confirmed action performed 
warning string 
action 
action warning modal name title warning 
text relief raised width text command text command cg combining examples demonstrate modularity gui components combine editor calculator 
calculator editor share editor buffer 
user able copy result calculation text editor vice versa 
handle extension minor changes previously programs 
add menu options editor containing item invoke calculator buffer 
edit buf 



relief raised name text width height text options calculator 
calculator buf 
definition calculator extended global buffer 
furthermore calculator needs copy paste commands 
simply add menubar calculator 
calculator buf st newstate id name cc title calculator calc st buf display calc st buf 

calc st text file quit cc text edit copy st buf paste st buf copy command writes value display global buffer paste command replaces contents buffer displayed value 
implementation shown 
note able reuse original definition calc 
nicely demonstrates define modular building blocks attractive user interfaces 
implementation section discusses runtime system particular communication gui library routines sect 
tcl tk toolkit 
tcl tk combination tcl tk ous provides simple comfortable programming system developing small applications graphical user interfaces 
tcl 
tcl tool command language interpretive script language controlling extending applications 
syntax semantics close unix shell 
tcl embeddable language language fact library designed linked applications 
tk 
tk toolkit window system sg tcl 
offers set widget commands creation motif user interfaces 
functionality tk applications available tcl evaluation events tk done invoking tcl commands 
underlying event loops call back display routines hidden away programmer 
communication surprising little tcl scripting necessary link functional program tcl tk 
fact simple quite effective method run program tcl tk separate processes linked bidirectional pipe 
tcl tk sends events program stdin part returns actions stdout tcl tk 
separating gui manager application processes poses problems communication protocol information stored 
decide store minimal amount gui information functional program viz 
call back list 
list associates widget identifiers actions 
suffices communicate events sending identifiers gui manager application 
identifier describes widget event happened 
event loop functional program evaluates corresponding command stored call back list 
tcl tk interpretive language tk operations high abstraction level represent actions change gui executable tcl tk scripts 
user manipulation gui triggers event typing text text field 
information functional program date 
need actual information gui request sent gui manager tcl tk script evaluated responds actual value 
case strategy leads synchronous communication 
example trace editor 
functional program see sect 

application user interface set 
generates script wm title editor pack frame pack frame fill 
pack relief raised menu text edit side left menu add command label cut command communicate add command label copy command communicate 
pack text text width height fill eom tcl tk interprets commands displays window widgets 
eom terminates action 
second suppose user entered text marked word generate event 
user chooses menu item copy gui communicates event order fill buffer application get actual value marked text gui 
application sends action text get sel sel evaluated responds actual marked part application reads string updates buffer 
sends eom terminate inter action 
gui gui starts evaluating init procedure 
uses tcl command open create gofer application prog subprocess 
created interaction possible pipe channel commands puts gets 
proc init prog global channel set channel open prog calling read eval loop read actions command init procedure 
procedure reads evaluates actions tcl tk scripts message eom read 
obviously set script gui message application 
proc global channel set act gets channel act eom eval act set act gets channel gives control tcl tk event handler 
user presses button tcl tk procedure communicate invoked writes events pipe starts read eval loop tcl tk interpret replied actions application 
proc communicate msg msg proc msg global channel puts channel msg flush channel script write tcl 
related integration referential transparent functional languages studied long time 
consider research integrate guis functional languages referential transparent way 
integrated gui functional language singh sin 
approach back back arrangement application written miranda gui written communicate pipes 
sides pipe supply primitive interpreters 
nearly abstraction graphical library low level requiring lot non portable implementation gui implemented ordinary state variable 
asserted gui representation miranda single threaded monadic framework ensures 
alternative solution problem proposed clean group avgp form unique types 
unique type guaranteed single threaded 
danger copying guis avoided 
developed library primitives similar macintosh toolbox implemented gui part runtime system 
different approach carlsson ch 
traditional widgets proposed fudgets functional equivalent 
fudgets may thought processes having streams high level messages connected application low level messages 
button instance process pressed low level message emits click high level message 
fudget guis streams programmed continuation style 
approach nice shortcomings 
problems mainly concern inherent combination stream coupling visualization widgets cf 
rs 
picks tcl tk gui basics sinclair sin 
proposes combine haskell tcl tk pipes 
hide tcl tk curtain uses command line oriented protocol processes 
basically approach sinclair pursued previous sv 
modify tcl shell 
furthermore showed structured functional code achievable approach 
disadvantage remains program user interface pure tcl tk 
lastly caml light pr linked tcl tk purely imperative way 
referential transparent functional library develop modular applications lightweight graphical user interface 
showed abstraction mechanisms monads layout combinators realize library 
solution enabled smooth high level interface application programmer fully concentrate core system fuzzy details window programming 
resulting system composed gofer gui library tcl tk script small easily extendable reasonably fast due robustness tcl tk stable 
furthermore technique require changes runtime systems approaches 
needed primitives limited bare basics reading writing characters 
implementation limited gofer adapted functional language long provides textual monadic alternatively improve efficiency choose embed tcl tk gofer runtime system 
tcl tk particularly suited requires local changes gofer runtime system 
reasons simplicity clarity decided transparent solution pipes 

erik meijer encouraging pursue research klaus max magnus carlsson thomas helpful comments 
avgp van groningen plasmeijer 
high level specification functional languages 
glasgow workshop functional programming 
springer verlag 
bw barr wells 
toposes triples theories 
springer verlag 
ch carlsson th 

fudgets graphical user interface lazy functional language 
conference functional programming computer architecture 
acm press 
hudak peyton jones ph 
wadler eds 
report programming language haskell version 
acm sigplan notices 
jd jones duponcheel 
composing monads 
research report rr yale university december 
jon jones 
release notes gofer 
included part standard gofer distribution 
jon jones 
gofer draft 
kl king launchbury 
lazy depth search linear graph algorithms haskell 
technical report university glasgow 
launchbury peyton jones 
lazy functional state threads 
technical report university glasgow november 
mog moggi 
computational lambda calculus monads 
symposium logic computer science pages washington dc 
ieee 
nr noble runciman 
functional languages graphical user interfaces review case study 
available ftp ftp york ac uk february 
ous ousterhout 
tcl tk toolkit 
addison wesley 
peyton jones ph 
wadler 
imperative functional programming 
proc 
th acm symposium principles programming languages charlotte north carolina january 
pr 
interface release beta 
available ftp ftp inria fr february 
rs reid singh 
implementing fudgets standard widget sets 
glasgow workshop functional programming 
sg getty 
window system 
acm transactions graphics 
sin singh 
miranda 
glasgow workshop functional programming workshops computing 
springer verlag 
sin sinclair 
graphical user interfaces haskell 
glasgow workshop functional programming 
springer verlag 
sv schulte 
linking reactive software window system 
technical report universitat ulm december 
wad ph 
wadler 
comprehending monads 
proc 
acm conference lisp functional programming 
wad ph 
wadler 
essence programming 
acm principles programming languages 
wad ph 
wadler 
monads composable continuations 
lisp symbolic computation pages january 
article processed macro package llncs style 
