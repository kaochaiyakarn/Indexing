semantic differencing reduce cost regression testing david binkley college maryland presents algorithm reduces cost regression testing reducing number test cases re run reducing size program run 
algorithm uses dependence graphs program slicing partition components new program sets preserved points components unchanged run time behavior affected points components changed run time behavior 
test cases test behavior affected points re run behavior preserved points guaranteed old new versions program 
furthermore algorithm produces program differences captures behavior affected points 
re testing large new program large number test cases possible certify new program running smaller program differences smaller number test cases 
cr categories subject descriptors software engineering tools techniques programmer workbench software engineering testing debugging programming languages language constructs control structures procedures functions subroutines data structures graphs 
software maintainers faced task regression testing process retesting software modification 
process may involve running modified program large number test cases smallest changes top entries weinberg list largest software disasters line changes tested weinberg 
effort required small change may minimal effort required program change may substantial 
begun author university wisconsin madison 
author current address comp 
sci 
dept college maryland charles st baltimore md 
copyright david binkley 
rights reserved 
presents method reducing cost program reducing number test cases re run reducing complexity program run 
program certified passes test suite modified version program modified algorithm described produces third program differences captures changes modified compared certified 
existing algorithms compare programs include test algorithms unix utility diff compare programs strings text 
approach general applied programs documents data files text objects 
clearly inadequate determining parts program retested 
example consider changes determining textual differences insufficient textual change produce change behavior 
case re testing necessary 
textual change location program causes change behavior stream procedure called procedure calling procedure 
contrast algorithm described uses language semantics identify program components exhibit different run time behavior behavior program formalized section 
algorithm partitions components modified preserved points program components compute values modified certified affected points program components compute different values modified certified 
result affected points re tested unix trademark bell laboratories 
behavior preserved points guaranteed modified certified 
addition algorithm produces program differences captures computation affected points 
re testing large program modified large number test cases possible certify modified running smaller program differences smaller number test cases 
previous algorithms determining semantic differences example horwitz apply limited programming languages 
chief difficulty determining semantic differences programs written real programming languages extending techniques handle procedures procedure calls 
algorithm described operates programs include procedures procedure calls language features simple scalar non global variables assignment statements conditional statements loops output statements 
support completed data structures arrays records pointers richer set control structures loops requires changes step algorithm 
step produces dependence graph representation modified certified called system dependence graph sdg 
algorithm computing semantic differences solely program slices weiser horwitz sdgs unaffected additional language features 
remainder organized follows section discusses related 
section presents background material sdgs interprocedural slicing algorithm discussed horwitz 
section presents main technical contribution defines semantic difference presence procedures procedure calls describes algorithm computing semantic differences certified modified 
fork section 
related reducing cost regression testing concentrated reducing number test cases re run fischer harrold 
approaches data flow analysis controlflow graphs 
goal analysis determine paths control flow graph affected change 
unfortunately control flow graph paths limits effectiveness techniques ways 
roughly put multiple computations share single control flow graph path 
example procedure contains single control flow graph path computations new values 
need re test computation includes path forces need re test 
second drawback existing approaches computational complexity 
unclear inherent problem control flow graph techniques just existing algorithms 
example approach identifies unchanged changed new path expressions 
unfortunately canonical form length path expression may exponential size program 
contrast technique described precise dependence graphs throw away unnecessary sequencing information contained control flow graph 
example capable identifying distinct computations procedure 
observed authors state program block modified example addition variable initialization program paths modified 
re tested 
may case small subset paths initialized variable 
furthermore technique requires space time linear size programs analyzed 
assumes program dependence graphs stored program done programming environment ottenstein 
approach addresses reduction number tests reduction size program tests run 
semantic differencing technique described binkley 
overview related semantics algorithms dependence graphs appears horwitz 
algorithms include semantics bases program integration program base variants created modifying separate copies base goal program integration determine modifications interfere create integrated program incorporates changed behavior respect base behavior common programs binkley horwitz 
changed behavior respect base captured term base compute differences 
gallagher gallagher defines decomposition slice similar model decomposition slice certified taken respect output statements particular variable updates 
subsequent modifications restricted certain statements slice 
statements outside decomposition slice affected modifications inside slice functionality statements decomposition slice re tested 
decomposition slice respect set output statements computed treating output statements strongly affected points see section 

system dependence graph interprocedural slicing section briefly summarizes definition system dependence graph sdg interprocedural slicing algorithm described horwitz 

system dependence graph sdg extends previous dependence representations accommodate collections procedures procedure calls just monolithic programs 
sdgs model flat language properties complete system consists single main procedure collection auxiliary procedures 
auxiliary procedures return statements main procedure ends statement lists variables values final state 
parameters passed value result 
assume systems contain call sites form global variable 
restriction potential copy back conflicts 
restriction permits global variables treated additional parameters procedure global variables discussed explicitly 
example 
shows example system part sdg 
sdg collection procedure dependence graphs pdgs connected interprocedural control flow dependence edges 
pdgs similar program dependence graphs representing programs vectorizing parallelizing compilers kuck ferrante include vertices edges representing call statements parameter passing transitive data dependences due calls 
vertices procedure pdg represent predicates assignment statements call statements parameter passing described system addition pdg distinguished vertex called entry vertex main procedure pdg contains initial definition vertex variable may defined final vertex variable named program statement 
programs viewed state transformers initial state define variables vertices final state variables listed statement defined 
parameter passing mechanisms supported algorithm discussed 
example parameters passed value result simply special cases value result 
changes necessary handle parameters introduces need handle aliasing 
see horwitz discussion handle parameters aliasing 
vertices representing parameters model value result parameter passing initial actual parameter values copied formal parameters called procedure invoked result formal parameter values copied back actual parameters 
represented sdg kinds parameter passing vertices actual actual vertices call site formal formal vertices procedure 
actual formal vertices included global variable may modified result call parameter formal vertices included global variables parameters may modified result call 
interprocedural data flow analysis required determine parameter vertices included procedure banning barth 
pdg kinds edges control dependence edges essence represent nesting structure program flow dependence edges represent def chains summary edges represent transitive dependences due calls meeting point edges represent common actual parameters called procedure 
meeting point edges described horwitz meeting point edges described binkley 
pdgs connected form sdg kinds edges call edge call site vertex corresponding procedure entry vertex parameter edge actual vertex call site corresponding formal vertex called procedure edge formal vertex called procedure corresponding actual vertex call site 

interprocedural slicing semantic differencing algorithm uses backward forward interprocedural slices 
backwards slice respect vertex sdg subgraph contains program components potentially affect interprocedural slicing defined reachability problem sdg 
slices obtained approach obtained weiser interprocedural slicing method weiser 
approach produces imprecise slice considers paths graph possible execution paths 
example path graph shown vertex procedure labeled vertex labeled path corresponds procedure add called call site returning second call site possible 
value second call independent value call vertex labeled included backward slice respect vertex labeled procedure main sum call sum od sum procedure call add call add return procedure add return enter call add call add enter add edge key control flow summary transitive dependence call parameter parameter 
example system sums numbers part sdg pdgs add shown 
achieve greater precision slice sdg respect set vertices computed passes pass summary edges permit moving call site having descend called procedure need keep track calling context ensure legal execution paths traversed 
pass starts vertices goes backwards target source flow edges control edges call edges summary edges meeting point edges parameter edges edges 
pass starts vertices reached pass goes backwards flow edges control edges summary edges meeting point edges parameter edges call parameter edges 
result interprocedural backward slice consists sets vertices encountered pass pass set edges induced vertex set 
algorithm finding vertices pass interprocedural backward slice stated 
example 
shows interprocedural backward slice sdg shown 
remainder uses operators designate individual passes backwards slice 
terminology operators defined follows parameter parameter call vertices full backward slice denoted computed composing 
backward slice including edges graph respect vertex set denoted induce induce sdg sdg function returns subgraph sdg induced vertex set 
function returns set vertices declare sdg worklist answer sets vertices set edge kinds vertices worklist answer worklist select remove vertex worklist mark insert answer unmarked vertex edge kind insert worklist od od return answer 
function returns vertices path vertex edges edge kind set 
procedure main call od procedure call add return procedure add return enter call add enter add edge key control flow summary transitive dependence call parameter parameter 
part slice sdg taken respect actual vertex labeled program corresponds 
program contains looping control program 
forward slicing operation forward slicing dual backward slicing operation backward slice discovers program components potentially affect component forward slice discovers components potentially affected component 
backward slicing interprocedural forward slice computed passes 
pass traverses certain kinds edges forward slice edges traversed source target 
pass slice ignores parameter call edges second pass slice ignores parameter edges 
full forward slice respect denoted induce defined induce 
remainder induce omitted ambiguity 

computing semantic differences section contains technical contributions definition semantic difference presence procedures 
algorithm computing ap modified certified safe approximation set affected points components modified exhibit different behavior modified certified 
algorithm computing modified certified safe approximation set modified components needed capture behavior components ap modified certified 
algorithm constructing program differences modified certified 
program captures semantic differences modified certified 
important property differences proven capture semantic differences modified certified 
proof slight modification correctness proof binkley 
section concludes example illustrating differences reducing cost regression testing 
determining non trivial property program undecidable algorithm identifying semantic differences approximate 
algorithm discussed safe correctly identifies semantically changed components program may identify unchanged components program changed 
component identified changed guaranteed behavior certified modified 

defining semantic difference defining semantic difference necessary language semantics identify correspondence components certified modified 
components system parts system represented vertices system sdg 
assume intuitive standard operational semantics 
formal semantics binkley proof roll introduced semantics preserving transformation 
proof important allows semantics systems related semantics roll outs 
correspondence components certified modified obtained syntactic matching algorithm yang special editor maintains statement tags 
semantics program defined sequence values produced component program 
sequence values produced program component means assignment statement parameter vertex sequence values assigned target variable predicate sequence boolean values predicate evaluates variable named statement singleton sequence containing variable final value 
sufficient programs procedures insufficient presence procedures components produce different sequences values different calling contexts 
refined definition program semantics correctly accounts calling context obtained concept roll exhaustive line expansion call statements produce program procedure calls 
rolled systems procedure calls semantic differences rolled systems defined terms sequences values 
turn defines differences systems roll semantics preserving transformation binkley 
emphasized roll outs may produce infinite programs performed roll concept conceptual device help properly formulate semantic differences systems 
set affected points defined roll contains components modified exhibit semantic difference compared certified 
correctly account calling context computing modified certified necessary partition set affected points strongly affected points weakly affected points 
affected point potentially exhibits changed behavior calling context strongly affected point potentially exhibits changed behavior calling contexts 
strongly affected points procedure caused changes procedures called procedures call weakly affected point affected point strongly affected 
weakly affected points procedure caused changes procedures call changes procedures called definitions sets 
definition affected points 
component modified affected point occurrences corresponding occurrence roll certified corresponding occurrences roll modified roll certified compute different sequences values programs evaluated initial state 
definition strongly affected points 
component procedure modified strongly affected point corresponding component certified corresponding occurrences roll modified roll certified compute different sequences values initial state initial values formal parameters 
definition weakly affected points 
component procedure modified weakly affected point affected point strongly affected point 

computing affected points section describes compute safe approximations sets affected points strongly affected points weakly affected points denoted ap modified certified sap modified certified wap modified certified respectively 
safe approximation set affected points computed full forward slice respect special subset affected points called directly affected points definition dap modified certified 
dap modified certified modified certified different incoming flow control edges modified certified 
def order edges additional flow dependence edges run definition definitions define variable reach common 
purposes defining incoming edges def order edge viewed hyper edge definitions common incoming edge 
discussions def order edges interprocedural edges ignored definition dap appear binkley 
set ap modified certified contains affected points defined dap modified certified follows definition ap modified certified 
ap modified certified modified dap modified certified 
safe approximation strongly affected points contained set sap modified certified 
recall strongly affected point procedure affected change procedure transitively called consistent observation sap modified certified defined forward pass slice 
slice taken respect vertex procedure called considers parameter edges call sites ignores parameter call edges procedures called define sap modified certified slice definition sap modified certified 
sap modified certified modified dap modified certified 
wap modified certified contains weakly affected points set affected points strongly affected definition wap modified certified 
wap modified certified ap modified certified sap modified certified 

constructing dd modified certified operator applied modified certified produces subgraph modified contains components necessary capture behavior components ap modified certified 
expressed defined parts part captures changes associated strongly affected points captures changes associated weakly affected points execution behavior strongly affected point potentially modified calling context executed necessary incorporate possible calling contexts accomplished slice respect 
execution behavior weakly affected point potentially modified calling contexts executed necessary incorporate possible calling contexts vertices call sites calling contexts potentially modified execution behavior affected points necessary take slice respect second point deserves clarification 
suppose weakly affected point 
slice respect include vertices procedures called include vertices procedures call initially may incorrect weakly affected point calling context changed 
call site actual vertices associated changed calling context affected point changed calling context included desired 
putting parts produces definition modified certified modified certified modified sap modified certified modified wap modified certified 
operationally main terms definition represents linear time passes sdg modified 
pass certain kinds edges traversed 

computing differences dd produce system differences sdg modified certified may require making modified certified feasible 
feasible sdg corresponds system 
modified certified augmented feasible system 
modified certified infeasible contains parameter mismatch 
mismatches involve call sites procedure informally contain different parameters 
formally kinds mismatches actual mismatch actual mismatch 
actual actual mismatch exists call sites actual actual vertex 
modified certified augmented remove actual actual mismatches program differences produced 
actual vertex added modified certified simply adding insufficient appropriate initial parameter value computed corresponding actual parameter 
order include program components compute value slice modified added modified certified 
additions continued actual mismatches exist 
actual mismatches removed simply adding missing actual vertices vertices represent dead code additional slicing necessary 
modified certified feasible program modified certified sdg 
accomplished projecting statements modified represented modified certified program differences 
words statements differences statements modified represented vertices modified certified statements appear modified order nesting level modified 
possible produce system modified certified case 
resulting program may missing parameters capture differences modified certified provided programs evaluated lazy demand semantics stoy 
evaluation values missing parameters demanded 

reducing cost regression testing due space limitation section presents differences reducing cost regression testing way example 
consider program modified shown 
set sap modified certified contains vertices representing statements boxes directly affected points set wap modified certified contains vertices representing procedure add 
shows program differences computed points algorithm developed sections 
stated section differences smaller efficient modified 
example program differences shown smaller efficient program modified shown contain computation variable sum 
section states may unnecessary run modified test cases test certified 
example assume certified tested test cases testing computation testing computation sum 
statements assign sum preserved points affected points test cases need re run modified guaranteed pass 
addition test case re run re run differences place modified reduces cost running test differences smaller efficient program 

knowing semantic differences programs clearly useful program maintenance activities 
reducing cost regression testing 
technique described reduces cost ways reduces number tests re run reduces complexity program run 
accomplished system dependence graph place control flow graph avoids unnecessary relation components path control flow graph 
includes better formalization test cases selected differences computed 
basic idea input statements modified certified analysis similar 
identifying tests rerun may possible reduce complexity test cases techniques analogous program slicing slice test inputs 
especially true test cases generated program case slice generating program taken respect output statements match input statements modified certified produces generating program produces test inputs required input statements differences 
procedure main sum prod call product prod call sum od sum prod procedure call add call add return procedure product count temp count call add temp call add count od temp return procedure add return 
system modified obtained system certified shown 
boxes indicate changes certified 
procedure main prod call product prod call od prod procedure call add return procedure product count temp count call add temp call add count od temp return procedure add return 
system differences obtained techniques described applied modified certified 
computing differences deals primarily computing slices 
example addition declaration dependences sdg allow reduced type definitions declarations included selected fields record included differences 
information declarations useful reducing size individual test inputs 
beneficial formal comparison cost method previous method reducing cost regression testing simple re run tests strategy 
comparison carried techniques leung produces model comparing cost selective regression testing strategies traditional retest strategy 
acknowledgments discussions keith gallagher improved dramatically 
author wishes reviewers especially reviewer helpful suggestions 
banning 
banning efficient way find side effects procedure calls aliases variables pp 
conference record sixth acm symposium principles programming languages san antonio tx jan acm new york ny 
barth 
barth practical interprocedural data flow analysis algorithm commun 
acm pp 
september 

cimitile de testing path change analysis pp 
proceedings ieee conference software maintenance phoenix arizona oct ieee computer society washington dc 
binkley 
binkley multi procedure program integration ph dissertation tech 
rep tr computer sciences department university wisconsin madison wi august 
ferrante 
ferrante ottenstein warren program dependence graph optimization acm transactions programming languages systems pp 
july 
fischer 
fischer methodology re testing modified software pp 
ieee national telecommunications conference proceedings nov 
gallagher 
gallagher lyle program slicing software maintenance ieee transactions software engineering se pp 

harrold 
harrold soffa incremental approach unit testing maintenance pp 
proceedings ieee conference software maintenance phoenix arizona oct ieee computer society washington dc 
horwitz 
horwitz identifying semantic textual differences versions program proceedings acm sigplan conference programming language design implementation white plains ny june acm sigplan notices pp 
june 
horwitz 
horwitz prins reps integrating noninterfering versions programs acm trans 
program 
lang 
syst 
pp 
july 
horwitz 
horwitz reps binkley interprocedural slicing dependence graphs acm trans 
program 
lang 
syst 
pp 
january 
horwitz 
horwitz reps program dependence graphs software engineering proceedings th ieee conference software engineering melbourne australia june ieee computer society washington dc 
kuck 
kuck kuhn padua wolfe dependence graphs compiler optimizations pp 
conference record eighth acm symposium principles programming languages williamsburg va january acm new york ny 
leung 
leung white cost model compare regression test strategies pp 
proceedings ieee conference software maintenance sorrento italy oct ieee computer society washington dc 
ottenstein 
ottenstein ottenstein program dependence graph software development environment proceedings acm sigsoft sigplan software engineering symposium practical software development environments pittsburgh pa apr acm sigplan notices pp 
may 
stoy 
stoy denotational semantics scott strachey approach programming language theory press cambridge ma 
weinberg 
weinberg kill code august 
weiser 
weiser program slicing pp 
proceedings fifth international conference software engineering san diego ca march 
weiser 
weiser program slicing ieee transactions software engineering se pp 
july 
yang 
yang identifying syntactic differences programs published software practice experience 
