order logic effects ian mason may describe progress operational implementation modern programming logic 
logic inspired variable type systems feferman designed reasoning imperative functional programs 
logic goes traditional programming logics hoare logic dynamic logic expressibility problematic encode higher order logics 
main focus axiomatization base order theory 
logic reasoning imperative functional programs inspired variable type systems feferman 
systems sorted theories operations classes initially developed formalization constructive mathematics applied study purely functional languages 
builds advances semantics languages effects goes traditional programming logics hoare logic dynamic logic treating richer language expressing properties 
close spirit specification logic evaluation logic 
underlying programming language mk call value lambda calculus extended primitives mk set get 
atoms lambda abstractions class values bound lambda variables stored returned procedures 
thought fragment untyped ml variant scheme 
logic combines features benefits equational calculi program specification logics 
layers 
foundation syntax semantics mk underlying term programming language 
second layer order theory built assertions program equivalence program modalities called contextual assertions 
third layer extends logic include class terms class membership quantification class variables 
concentrate layers 
main topic presentation hilbert style formal system proof completeness 
contextual assertions introduced means expressing constraint propogation 
quickly realized essential feature language reasoning effects programs 
earlier axiomatizing imperative features simple sequent system proving equations 
rules allocation updating primitives complicated ugly side conditions 
conditions ugly implementation system unfeasible 
main result generalize previous results full order language contextual assertions 
crucial point contextual assertions eliminate need side conditions 
overview notation remainder organized follows 
introduce syntax semantics terms 
introduce syntax semantics formulas 
proof theory 
relate semantics proof theory 
department mathematics computer science university new england australia conclude summary notation 
sets 
specify meta variable conventions form ranges read meta variable decorated variants 
range set usual notation set membership function application 
set sequences elements length set finite sequences elements sequence length ith element 
set finite subsets set finite maps set total functions domain range contained write dom domain function rng range 
function function dom dom fyg dom 
natural numbers range syntax semantics terms syntax syntax terms mk simple extension lambda calculus include basic atomic data lisp booleans nil practice natural numbers collection primitive operations fn fn possibly empty set ary operations 
booleans ft recognisers cell lambda unary operations fmk binary operations eq ternary operations primitive operations include memory operations mk get set allocating dereferencing updating unary cells usual operations strict branching br arithmetic recognizing operations atom cell lambda 
characteristic functions booleans nil respective domains 
treat application app binary operation sake uniformity 
atoms assume infinite set variables xand define mutual induction set abstractions set value expressions set value substitutions set expressions set contexts sets satisfying equations atoms ranges variables ranges lambda expressions ranges value expressions ranges value substitutions oe ranges expressions fn ranges contexts ffflg fn ranges binding operator free bound variables expressions defined usual 
fv set free variables value substitution finite map oe variables value expressions oe range value substitutions 
oe result simultaneous substitution free occurrences dom oe oe 
represent function maps fx vg 
fx vg result replacing free occurrences avoiding capture free variables 
contexts expressions holes 
ffl denote hole 
denotes result replacing holes free variables may bound process 
traps set variables trapped process filling holes abbreviations order programs easier read introduce abbreviations 
app letfx ge app seq seq fv app br nil fresh nil nil programming examples equality cells simplify matters omitted equality cells primitive operation 
easily definable 
eq 
cell cell letfx get get seq set nil set get seq set set nil landin recursion operator mk calculus extends call value usual call value fixed point combinator language 
somewhat different fixed point combinator primitives possible mk nil seq set app app get get version fixed point combinator essentially identical suggested landin 
applied functional form creates private local cell contents app app get returns privacy equivalent cf 

note example typable simply typed lambda calculus provably non empty types cf 

adding operations manipulating simply typed lambda calculus causes failure strong normalization nice mathematical properties 
integer streams point view stream simply possibly infinite sequence data 
mk calculus represent streams simply functional objects 
sequence corresponding mk stream values repeated application object fixed hopefully irrelevant argument 
simplest example non trivial mk stream stream natural numbers 
mk get seq set applied integer creates stream integers integer 
created stream queried applied value returns integer stream 
sieve eratosthenes somewhat interesting example stream sieve eratosthenes 
functional filter expects integer stream creates new stream 
new stream queried repeatedly calls stream argument integer divisible number argument returned 
number returned answer query 
filter nil divides filter nil sieve expression evaluated creates new sieve eratosthenes 
new stream stream prime numbers 
time stream queried returns current prime updates local stream filter prime 
sieve mk get sc nil seq set sc filter semantics terms operational semantics expressions reduction relation 
syntactic representation state machine referred computation descriptions 
state components current instruction current continuation current state memory 
syntactic counterparts redexes reduction contexts memory contexts respectively 
redexes describe primitive computation steps 
primitive step fi reduction application primitive operation sequence value expressions 
set redexes defined fn reduction contexts identify subexpression expression evaluated correspond standard reduction strategy left call value introduced 
set reduction contexts subset defined ffflg fm ranges expression value expression decomposes uniquely redex placed reduction context 
easy structural induction establishes vor written uniquely rand set memory contexts set contexts gamma form mk nil mk nil set set ffl include possibility case gamma ffl 
gamma ranges divided memory context allocation followed assignment allow construction cycles 
state memory constructible expression 
view memory contexts finite maps variables value expressions 
define domain gamma dom gamma fz gamma memory contexts considered viewed functions 
viewing memory contexts finite maps define modification memory contexts mk union memory contexts gamma gamma obvious way 
gamma oe result applying oe value range gamma 
set computations descriptions briefly descriptions defined set theta description pair component memory context second component arbitrary expression 
require free variables expression contained domain memory context 
allows define reductions uniformly parameters touched reduction step provide form symbolic evaluation 
gamma ranges closed description description form gamma fv dom gamma 
value descriptions descriptions expression component value expression description form gamma 
gamma oe gamma oe oe definition reduction relation 
reflexive transitive closure 
clauses fi gamma app 
gamma fx vg atom gamma atom 
ae gamma gamma nil dom gamma cell gamma cell 
ae gamma dom gamma gamma nil eq gamma eq 
ae gamma gamma nil dom gamma 
br gamma br 
ae gamma gamma dom gamma gamma nil mk gamma mk 
mk dom gamma fv get gamma get 
gamma dom gamma gamma set gamma set 
mk nil dom gamma note atom 
cell 
rules arguments variable domain memory context primitive reduction step determined 
case eq br get set rules 
definition closed description gamma defined written gamma evaluates value description 
description undefined written gamma defined 
descriptions gamma gamma written gamma gamma undefined reduct reduce particular description gamma gamma gamma 
gamma gamma gamma gamma gamma gamma gamma gamma gamma 
gamma gamma 
gamma closed expressions write mean mean iff mean simple consequences computation rules reduction functional modulo alpha conversion memory contexts may pulled reduction contexts computation uniform free variables unreferenced memory reduction contexts 
lemma cr gamma gamma gamma 
gamma ii gamma 
gamma fv dom gamma 
iii gamma 
gamma gamma oe 
gamma oe dom gamma dom oe fv rng oe dom gamma gamma dom gamma 
iv gamma 
gamma gamma gamma 
gamma gamma dom gamma dom gamma 
gamma 
gamma gamma 
gamma dom gamma fv dom gamma cr usual notion alpha equivalence 
explicit fact arbitrary choice cell allocation phenomenon arbitrary choice names bound variables 
operational equivalence terms section define operational equivalence relation study general properties 
operational equivalence formalizes notion equivalence black boxes 
treating programs black boxes requires observing effects values produce produce 
definition extends extensional equivalence relations defined computation memory structures 
shown operational equivalence approximation characterized various ways 
definition expressions operationally equivalent written closing context defined iff defined 
fv fv operational equivalence trivial inclusion branching implies nil equivalent 
definition operational equivalence congruence relation expressions congruence necessarily case substitution instances equivalent expressions equivalent instantiating expressions returns value 
counter example cell eq cell mk eq mk mk nil 
reason underlying case programs effects returning value appropriate characterization definedness 
particular returning value operationally equivalent value 
contrast purely functional case due presence effects 
example expressions returns value mk cell set cell get equivalent value value expression expressions 
allocation effect 
second write effect 
third read effect 
general difficult establish operational equivalence expressions 
desirable simpler characterization limits class contexts observations considered 
main context lemma case theorem ciu gamma oe fv gamma oe gamma oe gamma oe proof ciu appears 
syntax semantics formulas syntax order fragment logic minor generalization classical order logic 
atomic formulas assert operational equivalence expressions 
addition usual order formula constructions add assertion phi formula variable expression letfx phi formula 
definition letfx typographical convenience range class contexts 
denotes generic member letfx 
semantics meaning formulas tarskian satisfaction relation gamma phi oe 
definition gamma phi oe assume gamma oe phi satisfy fv phi oe fv oe dom gamma fv gamma 
define satisfaction relation gamma phi oe induction structure phi gamma oe iff gamma oe gamma oe gamma oe iff fv dom gamma gamma oe gamma oe gamma phi phi oe iff gamma phi oe implies gamma phi oe gamma letfx phi oe iff gamma oe 
gamma implies gamma phi vg gamma phi oe iff fv dom gamma gamma phi vg usual logic define notions validity logical consequence follows phi iff gamma oe fv phi oe dom gamma gamma phi oe phi phi iff phi phi examples counterexamples caveats negation definable phi just phi false false unsatisfiable assertion nil 
similarly conjunction disjunction biconditional definable usual manner 
note termination non termination simple abbreviations 
note assertion binding operator akin 
simple example axiom expresses effects mk letfx mk cell get note notions definedness express 
abbreviate letfx false abbreviate negation letfx false 
stronger notion definedness equivalent value 
notions important 
symbol denote binary relations logic 
important note equality order logic binary relations congruence sense falsifiable trapping occurs 
example get app seq set nil get app seq set nil obviously valid 
similarly false related principle phi letfx phi 
example get letfx set nil get clearly valid 
lines observation letfx letfx letfx valid converse false 
letfx mk mk letfx mk mk valid letfx mk mk 
violation privacy give impression point problem raised 
seemingly desirable logical principle contextual reasoning able replace operationally equivalent expression changing semantics contextual assertion letfx phi 
words principle desirable letfx phi letfx phi ways fail logic 
example may produce garbage garbage may detectable phi 
example letting seq mk mk mk phi cell cell eq nil provides counterexample 
troublesome counterexample relies fact may equivalent due privacy certain cells privacy respected contextual assertion 
simple example mk gw app get phi simple induction length computations similar establishes operationally equivalent valid 
essential observation cell local value object returned invisible contents outside scope 
case letfx phi letfx phi lost weaker principle letfx phi letfx phi valid 
extending syntax contextual assertions simplicity syntax contextual assertions simple statements 
earlier treatments dealt wider class contexts called contexts contexts 
largest natural class contexts symbolic evaluation unproblematic 
key restriction forbid hole appear scope non lambda preventing proliferation holes 
class contexts defined follows 
definition ffl letfx fm semantics simple generalization curious refered details 
main reason restricting attention contexts apart simplicity presentation left may considered abbreviations phi abbreviates phi 
seq phi abbreviates letfx letfx phi provided fresh 
letfx xn phi abbreviates letfx letfx phi provided fv 
phi phi abbreviates nil phi nil phi fresh phi abbreviates seq phi abbreviations fact sound derive theorem ca iii states generalized semantics theorem ca iii phi phi proof theory contextual assertions akin modalities give hilbert style presentation 
long run natural deduction style system style prawitz may desirable 
definition phi consequence relation smallest relation closed rules 
rules partitioned groups 
group rules label members group numbered 
example refers rule group equivalence evaluation rules second group 
rule possibly empty set premisses 
case set premisses non empty rule displayed horizontal bar separating premisses 
variable convention adopt barendregt convention particular mathematical situation free variables expressions distinct 
allow free variables expressions coincide bound variables contexts 
example assume vi free vii fv fv phi ii fv phi mk ii mk iii fv hand mk explicitly state variable distinct variables convention statement somewhat cumbersome 
axioms hold true operational equivalence case write principle twice symbol range equivalence relations 
important reason introducing important principles fails 
particular iii fails indicated 
basic equivalence axioms rules basic axiom concerning operational equivalence booleans nil equivalent 
non triviality 
nil second set rules concerning hold true operational equivalence 
equivalence relations ii iii 
satisfy certain restricted form substitutivity iv 
simple forms evaluation vi vii principles equivalent rules lambda calculus 
equivalence evaluation rules 
ii iii iv letfx ge letfx ge app fx vg letfx vi letfx egr vii letfx ge letfx ge ge remaining axioms rules concerning operational equivalence equivalence relation implies operational equivalence ii operational equivalence preserved collection garbage iii operational equivalence non trivial abstractions agree atoms cells iv 
operational equivalence rules 
ii gamma provided fv dom gamma iii rule iv cell contextual axioms rules contextual assertions modality possess rule akin necessitation 
note rule proof implication 
simple counterexample implication 
remaining axioms concerning contextual assertions ii contextual assertions distribute equivalences counterexample converse iii form contextual assertion involving corresponding principle operational equivalence false iv principle akin fi conversion principle allowing manipulation contexts 
contextual rules 
phi phi context ii iii letfx phi letfx phi iv letfx vg phi phi fx vg letfx phi letfx ge phi logical axioms rules propositional rules addition usual hilbert style presentation modus ponens iii generating set tautologies modal axiom corresponding converse ii 
propositional rules 
phi provided phi instance tautology ii phi phi phi phi iii phi phi phi phi modus ponens similarly quantifier axioms standard iv assert operations mk app allocation effect mk allocates value returns 
quantifier rules 
phi phi fy xg generalization ii phi phi phi phi iii phi phi fx vg iv phi phi gamma fmk mk phi mk phi phi note converses axioms easily derivable 
undefinedness principles basic principle concerning undefinedness undefined terms operationally indistinguishable 
rest principles concern partiality underlying operation 
note case memory operations mk set defined equivalent value 
cases true need express weaker form 
stronger forms derivable 
undefinedness rules 
ii mk iii set cell iv get cell get feq brg data operation axioms rules treat operation turn 
point grouped collection principles concern assertion propagates context 
may collection 
principles concerning mk definedness principle ii quite straightforward 
mk describes allocation effect call mk 
mk ii mk iii assert time allocation discernable effect resulting call 
world control effects free principle valid 
mk rules mk 
letfx mk cell get fresh ii mk ge letfx mk ge iii mk phi letfx mk phi contextual assertions regarding set analogous mk 
describe returned altered altered 
remaining principles involve commuting cancellation absorption idempotence calls set 
example set absorption principle set expresses certain simple conditions allocation followed assignment may replaced suitably altered allocation 
set rules set 
letfx set get nil ii get letfx set get iii seq set set seq set set iv seq set set set mk set mk ge vi get set nil rules concerning eq unproblematic 
true false eq 
note dichotomy imply call eq equivalent value 
true arguments atoms eq ii 
eq rules eq 
eq eq nil ii eq atom atom recognisers similarly simple 
true false equivalent values 
characteristic functions disjoint exhaustive sets ii 
correspond appropriate sets question iii 
rules 
nil ii gammaf nil iii atom provided iv lambda provided branching primitive simple eq 
argument false returns third argument br 
argument false returns second argument br ii 
imply call br equivalent value 
br rules br 
nil br ii nil br constraint propagation principles important class axioms allow assertions propagated assertions 
static rules 
letfx gamma fmk ii sigma letfx sigma iii letfx sigma sigma iv sigma letfx sigma provided gamma fget set 
letfx sigma sigma provided gamma fget set 
aside point provable set 
iv fget set principles simple counterexamples 
notes observations 
axioms rules concerning get mk set 

axioms new sense replaced principles appeared earlier treatments 
pointed jacob frost 
letfx phi phi ii letfx ge letfx gr free proof egr vi letfx phi letfx egr phi iii letfx phi phi 
proof ii letfx ge letfx ge gr vi 
letfx ge letfx gr vii ii 
letfx ge letfx gr vi ii ii 
ii 
similarly previous quantifier principle phi phi fv traps derivable pointed jacob frost 
proof phi phi iii phi phi phi phi ii modus ponens phi phi phi phi ii assumption fv derived rules modality akin deduction theorem 
easily establish weak form deduction theorem useful 
theorem weak deduction assume phi establish phi context rule iii generalization variable free phi phi phi proof weak deduction simple induction length proof 
simple corollary version reduction ad reductio ad phi false phi derivable derivation phi false context rule iii generalization variable free phi 
case fact weak deduction phi false strengthen theorem weakening condition formula assumption phi consequently definition phi 
similar observation reduces strong form phi phi phi phi fv phi derivable form phi phi phi phi fv phi simple counterexamples variations principles valid 
letfx fmk sigma letfx sigma get letfx sigma sigma get completeness say expression order ffi iff contains expressions non applications 
formula order phi ffi iff built order expressions 
appropriate order syntactic subclasses defined formally mutually recursive definitions definition ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi app ffi ffi fn gamma ffi ffi ffi ffi ffi ffi letfx ffi ffi ffi definition pi pi set constraints pi set complex constraints pi defined follows pi sigma ffi ffi gamma ffi ffi pi sigma ffi ffi gamma ffi ffi pi pi simple constraint set defined finite subset pi 
pi 
complex constraint element pi 
range simple constraints sets range complex constraints 
simple constraint said static subset pi gamma ffi 
complex constraint said static boolean combination elements pi gamma ffi 
note static constraints propagate contextual assertion 
defined simple constraints constraints 
reason define sets constraints facilitate single definition particular 
modulo definition reader may reasonably assume finite conjunction elements pi 
simple constraint set equivalent single complex constraint 
note constraint set finite collection formulas form fget atom cell lambda negations needed rewritten fresh 
abuse notation identify conjuction members treating simple constraint set special type complex constraint 
definition cells cells subset fv defined cells fx fv cell tg cells interpreted cell 
express constraints implicit memory context gamma define extension gamma relative set variables gamma definition gamma 
gamma dom gamma fv dom gamma define gamma follows gamma cells contents distinct cells dom gamma contents fget gamma dom gamma distinct fv dom gamma gamma fzg dom gamma completeness theorem proving quantifier free version main theorem 
full version simple generalization 
theorem completeness phi ffi order quantifier free complex constraint phi note propositional calculus ii principle phi phi phi phi suffices demonstrate theorem phi form ln reason define ffl letfx ffi gl range proof completeness theorem involves symbolic evaluation arbitrary formulas expressions respect suitable set constraints canonical form 
symbolic evaluation expression respect set constraints requires keeping track things newly allocated memory modifications original memory described remaining computation 
remainder computation simply expression 
newly allocated memory simply memory context 
modifications original memory represented special kind context called modification defining relative fixed constraint set symbolic reduction relation 
defined way contexts phi 
phi implies phi phi expressions 
implies definition requires notion modification corresponding decomposition contexts expressions 
effects evaluation expression original memory described constraints represented contexts called modifications 
simply sequences assignments variables domain memory context assumed cells 
definition modifications modification context form seq set set vn ffl implies define dom fz analogy gamma reduction analogy semantic reduction relations define 

order ensure definitions meaningful introduce coherence 
constraint pair memory modification contexts coherent written coh gamma dom gamma fv modifications elements cells decides equality cells distinct elements dom provably distinct contains get assertion cells 
condition technicality various definitions proofs simpler 
definition coherence gamma memory context modification say gamma coherent written coh gamma conditions hold dom gamma fv dom cells dom distinct 
cells 
cells formula get get cells 
write coh coh gamma dom gamma empty dom empty write coh gamma coh gamma dom gamma dom empty write coh coh gamma 
notion coherence ensure simplicity definition modification constraint set coherent modification implicit explicit construct remove set assertions concerning contents cells mutated set removed referred forget defined virtue coherence 
add gamma forget set assertions assign concerning cells updated definition coh define follows gamma forget assign assign fget dom forget get dom definition mk suppose modification coh cells 
mk defined modification dom dom fzg dom ae definition 
assume coh gamma gamma reduction relation 
expressions reflexive transitive closure 
fi gamma app 
gamma fx vg gamma 
ae gamma gamma nil nil provided eq gamma eq 
ae gamma psi gamma nil psi psi atom atom br gamma br 
ae gamma nil gamma nil mk gamma mk 
mk fresh get gamma get 
gamma get set gamma set 
ae mk nil dom gamma gamma mk nil cell definition phi 
phi assume coh gamma 
reduction relation 
formulas reflexive transitive closure 
val gamma letfx phi 
gamma phi fx vg red gamma letfx phi 
gamma letfx gl phi provided gamma gamma lemma coherence coherence preserved syntactic reduction 
context modification cmi generalizes contextual assertions concerning mk set arbitrary memory modification contexts pairs 
lemma cmi coh gamma fv gamma fv gamma gamma proof cmi cells dom gamma contents fget gamma dom gamma distinct dom gamma gamma fzg dom gamma suppose loss generality gamma mk nil mk nil seq set set zn vn ffl seq set set xm ffl mk nil mk nil propositional logic mk nil mk nil cells distinct mk propositional logic cells distinct seq set 
set zn ffl cells distinct contents set ii set propositional logic cut gamma gamma coherence may split disjoint sets forget get dom fx xm 
forget contains statements form get dom fx xm cells distinct seq set set xm ffl cells distinct set ii set propositional logic seq set set xm ffl fget mg set ii set propositional logic cut gamma gamma cmi simple useful corollary cmi corollary cmi coh gamma gamma gamma proof cmi gamma gamma cmi 
gamma assumption 
gamma facts cut 
gamma seq false definition 
seq gamma false repeated application gamma definition 
cmi state key lemmas require set definitions 
syntactic reduction defined contains information concerning nature free variables 
gamma corresponds stuck state reduce due simple type mismatches 
definition stuck state expression said stuck state written gamma gamma fget set gamma cell nil 
expression said reduce stuck state 
stuck state 
similarly formula phi said reduce stuck state phi 
gamma letfx phi coh gamma gamma stuck state 
order formalize notion constraint set containing information definitions 
accessor chain length reduction context form ffl note accessor chain length just ffl 
define notion completeness constraint sets relative finite set variables atoms 
idea constraint set contains sufficient information completely determine evaluation expression size built variables atoms 
definition complete complete theta theta accessor chains length theta theta nil ff ff ff ft nil cell implies get cell nil implies get definition atoms atoms set atoms occurring main lemmas lemmas enable straightforward proof completeness theorem 
lemmas 
hold full language lemma 
holds expressions order 
lemma complex constraints iff lemma 

ii phi 
phi phi phi 
lemma assume phi order fv atoms 
complete coh reduces stuck state exists memory context gamma modification 
gamma coh gamma gamma complete dom gamma atoms 
ii complete coh phi reduces stuck state exists memory context gamma modification substitution oe phi 
gamma phi oe coh gamma gamma complete dom gamma atoms rng oe 
lemma consistent 
exists family constraint sets complete atoms coh 
ii lemma suppose gamma coh gamma complete respect fv fv atoms 
static complex constraints ii ii ii proof completeness proof completeness fix particular fv atoms propositional logic lemma need show complex constraint phi assuming complete atoms coh suitably large max 
lemma ii reduces stuck state exists memory context gamma modification substitution oe 
gamma oe coh gamma gamma gamma complete dom gamma atoms rng oe 
consider cases turn suppose reduces stuck state phi 
gamma letfx phi coh gamma gamma stuck state 
fget set gamma cell nil 
situation lemma axioms undefinedness corollary cmi gamma letfx ffl obtain gamma letfx phi lemma ii tautological complex constraint suffice 
suppose 
gamma oe gamma oe oe coh gamma gamma gamma complete dom gamma atoms rng oe 
gamma oe lemma 
gamma gamma lemma cmi 
gamma lemma oe reduces stuck state exists memory context gamma modification oe 
gamma coh gamma 
apriori cases consider oe oe reduce stuck states exactly oe oe reduce stuck state oe oe reduces stuck state 

suppose oe oe reduce stuck states 
oe 
gamma fget set gamma cell nil 
lemma axioms undefinedness corollary cmi gamma lemma rules concerning undefinedness oe oe tautological complex constraint suffices 

suppose loss generality oe reduces stuck state 
oe 
gamma fget set gamma cell nil 
lemma axioms undefinedness cmi gamma oe hand exists memory context gamma modification oe 
gamma 
gamma coh gamma oe lemma oe oe cut false false complex constraint suffice 

suppose oe oe reduces stuck state 
assumption exists memory context gamma modification oe 
gamma coh gamma 
oe gamma lemma oe oe gamma gamma gamma gamma gamma consequently lemma obtain desired 
note coherence gamma provided lemma static 
gammai proofs lemmas lemma complex constraints iff proof nelson oppen 
lemma 

ii phi 
phi phi phi 
proof suffices show coh gamma gamma 
gamma implies gamma gamma ii gamma phi 
gamma phi implies gamma phi gamma phi gamma observe proof naturally divides cases corresponding definitions 
proving 
proof fi assume app 
case app fx vg axiom 
app fx vg axioms 
gamma app fx vg lemmas cmi cut 
gamma app gamma fx vg axioms ii 
assume case assumption ft 
lemma 
gamma lemmas cmi cut 
gamma gamma axioms ii 
eq assume eq 
case psi assumption 
atom atom definition psi atom atom lemma 
eq axiom eq ii 
gamma eq lemmas cmi cut 
gamma eq gamma axioms ii 
eq nil assume eq nil 
case psi assumption 
atom atom definition psi atom atom lemma 
eq axiom eq ii 
eq nil axioms eq 
gamma eq nil lemmas cmi cut 
gamma eq gamma nil axioms ii 
br assume br nil 
case nil assumption 
nil lemma 
br axioms br ii 
gamma br lemmas cmi cut 
gamma br gamma axioms ii 
br nil assume br nil 
case nil assumption 
nil lemma 
br axioms br 
gamma br lemmas cmi cut 
gamma br gamma axioms ii 
mk assume mk 
case mk mk gr fresh axiom vi 
gamma mk mk gr rule 
gamma mk gamma mk gr axiom ii 
gamma mk gamma mk axioms mk ii 
gamma mk gamma mk nil set axioms set 
gamma mk mk axioms mk ii 
gamma mk mk axioms 
get assume get 
case get assumption 
get lemma 
gamma get lemmas cmi cut 
gamma get gamma axioms ii 
set assume set 
set seq set nil axioms ii set 
gamma set seq set nil lemmas cmi cut 
gamma set gamma seq set nil axioms ii 
gamma set gamma seq set nil axioms vi 
consider cases dom gamma dom gamma 
case gamma set gamma seq set nil 
gamma set gamma seq set nil axioms set iii 
gamma set mk nil axioms set iii set iv 
case gamma set gamma seq set nil 
gamma set gamma gamma mk nil axioms set iii set iv 
note case mk set prove stronger result gamma 
gamma implies gamma useful proof second part lemma 
proof ii assume coh gamma 
cases val gamma letfx phi 
gamma phi fx vg red gamma letfx phi 
gamma letfx phi gamma gamma val case letfx vg phi phi fx vg axiom iv 
letfx vg phi phi fx vg axioms 
gamma letfx vg phi phi fx vg lemmas cmi cut 
gamma letfx vg phi gamma phi fx vg lemma cmi 
gamma letfx phi gamma phi fx vg definition 
red consider separate subcases depending nature reduction gamma 
gamma 
involve mk set stronger version lemma gamma axioms iii lemma cut obtain desired gamma letfx phi gamma letfx phi left cases reductions involves mk set 
mk ffl ffl abbreviate letfx ffl case need show gamma mk ffl phi mk ffl phi fresh gamma mk ffl phi gamma mk gr ffl phi axioms rule 
gamma mk ffl phi gamma mk ffl phi axioms mk iii 
gamma mk ffl phi gamma mk nil set ffl phi axioms set iii rule 
gamma mk ffl phi mk ffl phi mk iii 
set ffl ffl abbreviate letfx ffl case set consider possibilities dom gamma 
case show gamma set ffl phi mk nil ffl phi case show gamma set ffl phi gamma mk nil ffl phi case observing set seq set nil axioms ii set 
set ffl phi seq set nil ffl phi axiom iii 
set ffl phi seq set nil ffl phi axioms 
gamma set ffl phi seq set nil ffl phi axioms ii 
gamma set ffl phi seq set nil ffl phi axioms 
case simple set mk nil proof lemma 
gamma set ffl phi seq mk nil nil ffl phi axioms iii 
gamma set ffl phi mk nil ffl phi axioms iv iii 
gamma set ffl phi gamma mk nil ffl phi cut 
case gamma set seq set nil proof lemma 
gamma set ffl phi seq set nil nil ffl phi axioms iii 
gamma set ffl phi seq set nil ffl phi axioms iii iv 
gamma set ffl phi gamma seq set nil ffl phi lemma cut axioms ii 
gamma set ffl phi mk gm nil ffl phi axioms mk set iii set iv iii 
ii lemma assume phi order fv atoms 
complete coh reduces stuck state exists memory context gamma modification 
gamma coh gamma gamma complete dom gamma atoms 
ii complete coh phi reduces stuck state exists memory context gamma modification substitution oe phi 
gamma phi oe coh gamma gamma complete dom gamma atoms rng oe 
proof follow simple observation 
complete complete 
lemma consistent 
exists family constraint sets complete atoms coh 
ii proof suppose consistent complete atoms 
pick theta theta accessor chains length theta theta conditions fails 
repair possible failure turn 
condition fails tg fails fv ffg ff propositional logic ff ft nil fails fget zg fresh iv existential elimination 
fails inconsistent iv 
contradicts initial assumptions 
possible case possible enlarge branch enlarge particular failure 
generating required family ng trivial 
lemma suppose gamma coh gamma complete respect fv fv atoms 
static complex constraints ii ii ii proof define follows ae dom get dom supposition coh gamma complete respect fv atoms suffice ensure defined cells 
defined relation modulo suffices purposes 
loss generality may assume dom gamma dom gamma disjoint cardinality dom gamma dom gamma false static constraint suffice 
bijection dom gamma dom gamma define set fx gamma gamma dom gamma cells observe set static constraints 
desired static complex constraint just dom gamma dom gamma ii case slightly complex previous 
defining increasing sequences fffi ng subsets dom gamma induction 
ffi dom gamma fv having defined ffi define ffi ffi ffi fz dom gamma ffi fv gamma put ffi ffi claim dom gamma gamma ffi precisely garbage created consequently may assume sets ffi ffi disjoint cardinality ffi ffi static constraint suffice 
proceed fashion previous case 
bijection ffi ffi define set fx gamma gamma dom gamma cells observe set static constraints 
desired static complex constraint just ii ffi ffi ii second completeness theorem demonstrate quantifier free assumption eliminated completeness result previous section 
definition pi set quantified constraints pi defined pi sigma ffi ffi gamma ffi ffi pi pi pi theorem completeness ii phi ffi order quantified constraint phi proof completeness ii prove induction quantifier rank order phi 
new case need consider general situation simplify formula form phi 
fix particular phi fv phi atoms phi propositional logic lemma need show complex constraint phi assuming complete atoms coh suitably large max phi 
ii phi reduces stuck state exists memory context gamma modification substitution oe phi 
gamma phi oe coh gamma gamma gamma complete dom gamma atoms rng oe 
point general version ii stated restrictions formula inside contextual assertion 
case proceeds exactly proof completeness theorem 
left deal second case 
suppose phi 
gamma phi oe gamma oe oe coh gamma gamma gamma complete dom gamma atoms rng oe 
phi gamma phi oe lemma 
note gamma phi oe gamma phi oe obvious assumptions 
gamma phi oe gamma phi oe repeated application iv converse gamma phi oe gamma phi oe gamma dom gamma phi oe fx zg repeated application converse position apply induction hypothesis obtain gamma phi oe gamma dom gamma phi oe fx zg consequently phi reach desired 
obtain desired correspondence proof theory semantics elaborate lemma 
need analysis theory order structures language fget atom cell lambda satisfy principles enumerated 
theory known decidable weak monadic second order shown decidable rabin landmark 
consequently may conclude order phi ffi decidable 
directions continued investigations variable typed logic effects began 
particular axiomatization base order theory 
described encoding logic generic proof assistant isabelle 
encoding syntax proof theory logic relatively painless procedure 
especially compared required logics hoare dynamic ilk 
semantics underlying mk calculus operational semantics logic defined strictly terms syntactic entities unreasonable expect implementation capable encoding 
allow theoretical semantic reasoning carried time context 
obvious attractions 
allow system semantically verify proof system extremely attractive idea 

allow dynamic enrichment proof theory introducing new semantically verified principles 
logic implemented truly dynamic 
obstacle successfully encoding semantics problem encoding lambda calculus style contexts hole filling corresponding notion substitution variable binding capture 
achieve may necessary adopt binding structure approach developed 
completeness result substantial remains done 
mention open problems area expect obtain results year time frame 

axiom system contains axioms rules quantifiers structured data typically immutable pairs question axioms rules complete remains open 
conjectured techniques modified adapted framework obtain affirmative answer conjecture 

operational setting main tool establishing principles structural induction fixed point induction induction simulation induction induction length computation 
incorporating semantical proof theoretical principles proof environment solve problem computation induction formalized programming logic 

far studied systems control features systems imperative features 
unification theories studied detail 
nice meta theoretic properties completeness carry certain principles modified remain valid 

long term hoped concurrent distributed programming result unified approach underlying functional language 
avron honsell mason robert pollack 
typed lambda calculus implement formal systems machine 
journal automated reasoning 
abelson sussman 
structure interpretation computer programs 
mit press mcgrawhill book 
abramsky 
lazy lambda calculus 
turner editor research topics functional programming 
addison wesley 
abramsky 
domain theory logical form 
annals pure applied logic 
agha mason smith talcott 
theory actor computation 
third international conference concurrency theory concur volume lecture notes computer science pages 
springer verlag august 
agha mason smith talcott 
foundation actor computation 
appear 
apt 
years hoare logic survey part acm transactions programming languages systems 
barendregt 
lambda calculus syntax semantics 
north holland 
bloom 
lcf 
information computation 
chang keisler 
model theory 
north holland amsterdam 
honsell ronchi della rocca 
operational denotational logical descriptions case study 
fundamenta informaticae 
feferman 
language axioms explicit mathematics 
algebra logic volume springer lecture notes mathematics pages 
springer verlag 
feferman 
constructive theories functions classes 
logic colloquium pages 
northholland 
feferman 
theory variable types 
revista de 
feferman 
polymorphic typed lambda calculi type free axiomatic framework 
logic computation volume contemporary mathematics pages 
providence 
felleisen 
calculi lambda cs conversion syntactic theory control state imperative higher order programming languages 
phd thesis indiana university 
felleisen 
personal communication 
felleisen friedman 
control operators secd machine calculus 
wirsing editor formal description programming concepts iii pages 
north holland 
felleisen hieb 
revised report syntactic theories sequential control state 
theoretical computer science 
frost 
personal communication 
frost mason 
operational logic effects 
proceedings australasian theory symposium cats pages 
harel 
dynamic logic 
gabbay guenthner editors handbook philosophical logic vol 
ii pages 
reidel 
honsell mason smith talcott 
theory classes functional language effects 
proceedings csl volume lecture notes computer science pages 
springer berlin 
honsell mason smith talcott 
variable typed logic effects 
information computation may 
howe 
equality lazy lambda calculus 
fourth annual symposium logic computer science 
ieee 
jim meyer 
full abstraction context lemma 
theoretical aspects computer science volume lecture notes computer science pages 
springer verlag 
landin 
mechanical evaluation expressions 
computer journal 
mason 
semantics destructive lisp 
phd thesis stanford university 
available csli lecture notes center study language information stanford university 
mason talcott 
axiomatizing operational equivalence presence side effects 
fourth annual symposium logic computer science 
ieee 
mason talcott 
sound complete axiomatization operational equivalence programs memory 
technical report stan cs department computer science stanford university 
mason talcott 
reasoning programs effects 
programming language implementation logic programming plilp volume lecture notes computer science pages 
springerverlag 
mason talcott 
equivalence functional languages effects 
journal functional programming 
mason talcott 
inferring equivalence functional programs mutate data 
theoretical computer science 
mason talcott 
local variables operational reasoning 
seventh annual symposium logic computer science pages 
ieee 
mason talcott 
program transformation contextual assertions 
logic language computation 
festschrift honor satoru volume lecture notes computer science pages 
springer berlin 
mason 
hoare logic lf 
technical report ecs lfcs laboratory foundations computer science university edinburgh 
mason talcott 
reasoning object systems 
international journal foundations computer science 
milner 
fully models typed calculi 
theoretical computer science 
moggi 
computational lambda calculus monads 
fourth annual symposium logic computer science 
ieee 
morris 
lambda calculus models programming languages 
phd thesis massachusetts institute technology 
nelson oppen 
fast decision procedures congruence closure 
technical report department computer science stanford university 
ong 
lazy lambda calculus investigation foundations functional programming 
phd thesis imperial college university london 
lawrence paulson 
isabelle generic theorem prover 
number lecture notes computer science 
springer verlag berlin 
pitts 
evaluation logic 
higher order workshop banff volume workshops computing 
springer verlag 
pitts stark 
observable properties higher order functions dynamically create local names 
acm sigplan workshop state programming languages 
yaleu dcs rr 
plotkin 
call name call value lambda calculus 
theoretical computer science 
prawitz 
natural deduction proof theoretical study 
almquist wiksell 
michael rabin 
decidability second order theories automata infinite trees 
transactions american mathematical society 
reynolds 
idealized algol specification logic 
editor tools notions program construction pages 
cambridge university press 
smith 
operational 
mfps volume lecture notes computer science pages 
springer verlag 
talcott 
essence rum theory intensional extensional aspects lisp type computation 
phd thesis stanford university 
talcott 
binding structures 
vladimir lifschitz editor artificial intelligence mathematical theory computation 
academic press 
talcott 
theory program data type specification 
theoretical computer science 
talcott 
theory binding structures applications rewriting 
theoretical computer science 

decidable pairing functions 
phd thesis cornell university 
appears computer science tr 
weyhrauch 
prolegomena theory formal reasoning 
artificial intelligence 
