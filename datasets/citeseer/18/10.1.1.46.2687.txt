acm transactions graphics vol 
july pp 
approximating polyhedra spheres time critical collision detection philip hubbard program computer graphics cornell university july presents method approximating polyhedral objects support collision detection algorithm 
approximations hierarchies spheres allow time critical algorithm progressively refine accuracy detection stopping needed maintain real time performance essential interactive applications 
key approach preprocess automatically builds tightly fitting hierarchies rigid articulated objects 
preprocess uses medial axis surfaces skeletal representations objects 
skeletons guide optimization technique gives hierarchies accuracy properties appropriate collision detection 
sample application hierarchies built way allow time critical collision detection algorithm acceptable accuracy improving significantly possible hierarchies built previous techniques 
performance time critical algorithm application consistently times better previous collision detection algorithm maintaining low latency nearly constant frame rate frames second conventional graphics workstation 
time critical algorithm maintains real time performance objects complicated exceed previously reported complexity levels factor 
categories subject descriptors computer graphics computational geometry object modeling geometric algorithms languages systems object hierarchies physically modeling computer graphics dimensional graphics realism animation virtual reality 
general terms algorithms human factors performance 
additional key words phrases approximation collision detection interactive systems medial axis surfaces spheres time critical computing 
performance paramount interactive graphics applications virtual reality systems vehicle simulators 
brooks discusses case virtual reality applications copyright acm 
rights reserved 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
abstracting credit permitted 
copy republish post servers redistribute lists requires prior specific permission fee 
mailing address frank rhodes hall cornell university ithaca ny 
email address pmh graphics cornell edu 
url www graphics cornell edu pmh 
successful respond users actions real time rates 
particular frame rates high nearly constant latency lag low 
realistic modeling rendering animation important applications 
collision detection response example prevent moving objects passing making objects natural believable 
despite advances traditional algorithms detection algorithms fast interactive settings 
interactive applications forced collision detection 
promising way collision detection possible interactive applications time critical computing 
essence approach van dam calls negotiated graceful degradation trading accuracy speed 
time critical detection algorithm checks collisions successively tighter approximations objects real surfaces 
step progressive refinement application algorithm exceeds time budget 
processing approximations objects surfaces time critical algorithm maintain consistent real time performance surfaces complicated 
approach degrade accuracy detection small inaccuracies acceptable situations 
detection algorithms produce form inaccuracy algorithms sample time discretely 
algorithms adjust accuracy ensure real time performance provide advantages time critical algorithm 
section elaborates points 
key time critical collision detection method automatically approximating object surface 
presents preprocess approximates rigid articulated polyhedral objects sets spheres 
produces multiple levels detail arranged hierarchy exemplifies 
place spheres preprocess uses medial axis surface represents object skeletal form 
medial axis surface guides optimization process matches spheres object shape 
run application levels detail take place object real surface approximate fast collision detection response 
note difference approach traditional hierarchies focus collisions real surfaces 
desktop lamp triangles levels detail spheres 
time critical detection algorithm spirit time critical algorithms graphics problems examples include rendering algorithms static walk throughs funkhouser shirley iris performer application framework helman human animation algorithm 
extends earlier introduced idea time critical collision detection sophisticated approach hierarchies :10.1.1.42.7280
companion papers knowledge descriptions time critical collision detection complement current focusing framework time critical algorithm important details building sphere hierarchies :10.1.1.46.3524
novel contributions current follows ffl preprocess builds hierarchies spheres specifically addresses goal maximizing collision accuracy level detail fixed number spheres 
previous hierarchies addresses goal 
empirical evidence suggests improvement accuracy previous significant 
ffl empirical tests demonstrate time critical collision detection algorithm provides acceptable accuracy keeping latency low frame rate high nearly constant 
previous collision detection demonstrates real time performance nearly simultaneous collisions objects complicated highly non convex shapes 
specifically tests show significant speedup previous algorithm bsp trees ability maintain real time performance objects complex 
suggest time critical collision detection appropriate situation 
maximum possible accuracy needed applications simulation verifies precise fit parts mechanical assembly predicts behavior dependent sustained contact parts 
time critical algorithm increase number applications collision detection 
remainder proceeds follows 
section motivates idea trading accuracy speed 
section surveys benefits previous collision detection explains trading accuracy speed unnecessary 
section presents structure time critical detection algorithm 
sections describe build hierarchies spheres approximate objects multiple levels detail section shows examples hierarchies 
section presents results empirical tests detection algorithm 
results indicate algorithm balance performance accuracy effectively 
section summarizes discusses possible extensions 
need time critical collision detection state art collision detection improving 
detection algorithms provide realtime performance challenging test cases section describes 
demands interactive applications increasing arguments time critical detection algorithm meet demands 
detection algorithm maintain real time performance application geometric characteristics change 
changes occur application runs users perform actions bring multiple objects colliding nearly colliding configurations increasing geometric complexity regions objects 
changes occur runs designers upgrade application adding objects detail increasing geometric complexity runs 
time critical algorithm copes changes approximating object surfaces 
approximations resolution independent real surfaces performance degrade geometric complexity increases 
traditional non time critical detection algorithms hand process real surfaces objects processing times necessarily increase geometric complexity 
time growth unacceptable interactive applications increases complexity objects users care speed responsiveness 
uses approximation time critical detection algorithm decrease accuracy 
simplest measure detection algorithm inaccuracy separation distance objects considers colliding 
accuracy affected algorithm reports relative orientation colliding surfaces 
collision response separation distance exactly zero orientation incorrect alter course frames 
cumulative inaccuracy cause intolerable qualitative changes reasons believe acceptable 
time critical algorithm inaccuracy collision usually small section demonstrates 
colliding objects steered users cumulative inaccuracy quickly disappear cases humans skilled correcting subtle changes unconsciously riding bicycle 
effects objects may noticeable users correct behavior collision complicated shapes may difficult predict consider example trumpet hitting 
inaccuracies noticeable may better alternative degraded performance improved accuracy 
report users vehicle simulators suffer motion sickness frequently latency high 
poor performance cause simulator sickness render interactive applications unresponsive ineffective pausch example cite studies indicating latency decreases operator performance vehicle simulators 
full accuracy uncommon alternatives time critical algorithm 
traditional algorithms produce temporal inaccuracy sampling object positions discretely theory application choose sampling rate fastest algorithms support realtime performance limited sample frame 
temporal inaccuracy creates spatial inaccuracy equal distance object travels frames 
effect slow moving objects 
human walking slowly miles hour example travels inches frame frames second inaccuracy inches significant scale 
adaptive sampling reduce temporal inaccuracy current adaptive techniques generally increase sampling rate sacrificing real time performance 
presence temporal inaccuracy time traditional algorithm spends checking exact surface collisions time sample may wasted 
better approach seek collision accuracy real time constraints allow approach taken time critical algorithm 
application involves variety tasks collision detection 
application people control processing time distributed tasks balance speed effectiveness application 
detection algorithm power delay rest application produces accuracy deems important 
time critical algorithm produces accuracy fit time gives application flexibility handle competing demands 
related literature collision detection extensive 
published algorithms incorporate important techniques improve performance 
section argues algorithms meet goals previous section maintaining real time performance required sophisticated interactive applications 
put previous perspective helps consider idealized interactive application calls simple detection algorithm 
application generates frames simulation time scale may correspond wall clock time experience 
detection algorithm accurate deltat simulation time units minimum temporal resolution 
simple detection algorithm weaknesses describe detail :10.1.1.46.3524
fixed time step line cause inaccuracy inefficiency pairs loop line reduce performance 
intersection test line significant performance bottleneck 
application steps deltat get user input update object behavior collision detection collisions respond collisions render object collision detection curr collisions prev curr steps deltat pair objects intersects add collisions collisions prev return true prev return false idealized interactive application simple detection algorithm 
algorithms address weaknesses geometry extra dimension explicitly represents simulation time 
samet tamminen apply recursive subdivision dimensions space time 
canny derives polynomials roots represent time location collisions 
cameron extends approach samet tamminen adding mechanism prunes parts objects collide 
von herzen conditions accelerate form binary search space time 
duff applies interval analysis generalize idea recursive subdivision 
snyder combine interval analysis newton raphson root finding technique providing accurate detection date collisions involving curved surfaces 
techniques assume knowledge object exact position simulation time 
information available applications generate animations line algorithms setting 
interactive applications feature objects motion specified fly human users algorithms directly 
context algorithms need predict positions objects discuss related ideas section 
algorithms improve basic algorithm making assumptions objects motions 
moore wilhelms shaffer herb recursive subdivision form octree 
repeatedly subdividing regions space contain object octree helps algorithms avoid testing distant parts objects collisions 
algorithms update octree objects move associated computation significant 
algorithms appropriate interactive applications view collision detection phases 
replacing lines broad phase finds collisions simplified forms objects bounding boxes spheres 
line narrow phase checks exact intersections individual pairs objects simplified forms collide time broad phase turk zyda regular grid identify objects close 
baraff cohen describe sweep prune techniques exploit inter frame coherence efficiently sort bounding boxes identifying intersect 
authors describe ways adaptively change broad phase time step predictions objects positions predictions possible interactively guided objects 
mirtich canny upper bounds linear angular velocity priority queue tracks possible collision convex polyhedra 
bounds maximum acceleration derive space time bounds dimensional structures intersections predict bounding sphere collisions :10.1.1.46.3524
maximum accelerations predict collisions employing queuing scheme efficiently update predictions 
experience adaptive techniques clamp time step minimum temporal resolution deltat avoid slowing real time rates techniques eliminate temporal inaccuracy mentioned section 
algorithms perform empirical tests space time bounds time critical algorithm concentrate narrow phase remainder 
early narrow phase algorithm theoretical importance described dobkin kirkpatrick 
algorithm detects collision polyhedra log time total number vertices polyhedra 
practical disadvantage algorithm returns insufficient information forms collision response reports collision point multiple parts objects collide 
baraff presents algorithm exploits inter frame coherence efficiently detect collisions pairs convex objects 
nonconvex objects treated union convex pieces cause inefficiency objects complicated shapes 
sclaroff pentland improve narrow phase performance approximating object new representation deformed superquadric ellipsoid surface modulated displacement map 
approach works applies types objects spherical topology star shaped surface features 
recursive subdivision allows algorithm process objects general shapes 
earliest examples idea tamminen 
kitamura modern variation uses octrees 
algorithms narrow phases subdivision techniques smith garcia alonso ponamgi deserve particular attention 
broad phases create temporal inaccuracy discussed section algorithms advantage achieve real time performance challenging situations 
smith algorithm narrow phase builds octree subset faces polygonal objects faces intersecting bounding boxes broad phase 
sample run finds collision space faces algorithm performs seconds slowest time step occurs collision 
real applications collision 
unclear algorithm perform collision response cause multiple objects collect colliding nearly colliding configurations time steps 
garcia alonso algorithm level grid subdivision object 
narrow phase uses grids search intersecting faces overlap object bounding boxes 
detecting interference unfolding satellite antenna jointed objects total faces algorithm allows near real time animation frames second 
generality results unclear reasons 
satellite animation stops collision affect performance noted 
objects connected joints narrow phase uses inexpensive test joint limits number satellite components handled way unspecified 
objects handled way narrow phase deal rotations objects precomputed grids 
solution replace rotated grid cell axis aligned bounding box 
unfortunately box bound considerably original cell generated random rotations unit cube bounding box increased volume factor average worst case 
rotations reduce grid expected efficiency localizing collisions 
ponamgi narrow phase builds previous approaches 
uses incremental algorithm lin canny check convex hulls objects intersection 
intersection may involve part hull covers concavity 
case narrow phase descends precomputed octree subdivision concavity hierarchical version cohen sweep prune technique exploit inter frame coherence 
sample run interlocked tori faces bounce approach gives real time performance seconds frame 
single highly regular hole torus octree approach particularly effective 
multiple irregular holes pose challenge especially involving skinny faces precomputed octree leaves bound faces possible orientations octrees looser effective localizing collisions 
half faces torus lie convex hull interlocked configuration tori cause nearly half collisions involve hull faces algorithm optimized detect collisions quickly perform general situations unclear 
best evaluation new detection algorithm involves running previous algorithms application 
section step goal describing comparison time critical algorithm previous algorithm algorithm binary space partitioning bsp trees described thibault naylor 
interesting comparison involve subdivision algorithms example ponamgi 
algorithm bsp algorithm traverse trees subdivision algorithm advantage detect absence collisions reaching leaves 
hand bsp algorithm better preprocessing 
precomputed bsp tree transforms naturally match moving rigid object true precomputed octree axis aligned grid 
preprocess builds bsp tree optimize tree collision localizing properties naylor describes 
aware reports subdivision algorithms outperform bsp algorithm comparisons time critical algorithm approaches subdivision algorithms interesting 
time critical detection algorithm majority algorithms previous section process real surfaces objects surfaces complicated 
turns time critical detection algorithm avoids problem 
progressive refinement time critical algorithm assumes object approximated hierarchy spheres represents object multiple levels detail 
level object bounding sphere 
subsequent levels unions successively spheres approximating object higher resolutions 
spheres rotationally invariant rigid object hierarchy built preprocess running application applies hierarchy linear transformations applies object 
articulated objects approach applies articulated component individually 
sections describe hierarchy building preprocess focusing maximizes accuracy level detail 
time critical detection algorithm uses hierarchies implement progressive refinement 
called application algorithm detects collisions level spheres hierarchies objects bounding spheres 
broad phase approach section suffice step 
broad phase find level spheres collide time step algorithm enters narrow phase 
step narrow phase descends level hierarchies pair objects positions 
descending level involves obvious operations algorithm checks colliding spheres current level hierarchies see children collide 
spheres simple shapes collision checking efficient 
spheres hierarchies collide current level pair objects need processing algorithm returns colliding spheres current level application 
application devote current frame processing time detection returns control algorithm proceed refinement step 
algorithm continue steps long hierarchies levels application spare time 
application free refinement level available time exhausted 
spheres objects collide point application invoke collision response objects bounce colliding spheres approximation objects surface contact accuracy detection ensuing response depends tightly colliding spheres fit real surfaces objects 
application proceeds task current frame 
processing time algorithm depends resolutions sphere hierarchies 
independent objects geometric complexity algorithm hierarchies find parts objects real surfaces test collisions 
time allows algorithm test real surfaces colliding leaf spheres final level refinement 
note algorithm restricts progressive refinement narrow phase occurring broad phase 
section explains restriction limit performance suggests may provide solution 
choosing amount refinement approach previous section application determine time spend frame collision detection 
answer depends application performance goals set activities performs frame 
activities summarized code application 
ideally application time critical algorithms activities specific amount time 
current state art time critical algorithms rare 
tests traditional algorithms tasks collision detection 
main difficulty predicting time needed rendering algorithm 
simplest approach average rendering time number previous frames 
prediction application estimates time unused current frame time detection 
rendering faster predicted application slack time frame keep frame finishing quickly 
section presents results approach practice 
detection algorithm may find multiple objects sphere hierarchies collide current frame 
application refine collisions round robin fashion avoid spending available time just collision 
practice useful require collision refined level level better object single bounding sphere approach prevented variations predicted rendering time forcing undue inaccuracy collision detection 
sphere hierarchies hierarchies spheres discussed section involve design decisions 
spheres different levels need sort relationship 
obvious approach hierarchy tree sphere tree 
algorithm step narrow phase section straightforward similar hierarchical algorithms areas graphics see pseudocode 
algorithm efficient testing spheres intersection fast operation hierarchy prunes number spheres test 
form relationship implemented directed acyclic graph sphere dag parents share children 
case detection algorithm uses variation pseudocode marking nodes avoid repeated traversals shared children 
refine detection children intersect children intersect pair intersects add algorithm refines detection collision involving spheres different sphere trees putting result design decision involves sphere hierarchy covers object surface 
strictest policy fully conservative coverage children collectively cover parts object parent covers 
looser policy sample coverage children cover set specific points parent covers 
fully conservative coverage simpler implement sphere dag sphere tree section discusses 
final design decision automatically generate particular spheres hierarchy 
question topic sections 
building sphere hierarchies success time critical detection algorithm depends preprocess builds sphere hierarchies 
preprocess meet requirements 
automatic building useful hierarchies user intervention 
ensure hierarchy effective search structure level pruning parts level visited detection algorithm 
generate hierarchies level fits object tightly possible 
requirement critical detection algorithm level pass colliding spheres collision response 
response spheres accurate spheres surfaces closer objects real surfaces 
previous approaches final requirement tightness challenging meet limits applicability previous hierarchies 
octree recursive subdivision basis hierarchy building algorithms described liu previous :10.1.1.42.7280
octree object defines sphere tree occupied octant circumscribed sphere 
preprocess approach advantages straightforward implement quick execute 
sphere tree preprocess took seconds hewlett packard 
disadvantage approach produce hierarchies fit tightly 
figures illustrates problem figures section give examples 
hierarchies prevent time critical detection algorithm reaching acceptable accuracy empirical tests section demonstrate 
desktop lamp triangles levels octree sphere tree 
class algorithms builds bounding hierarchy leaves leaf spheres enclosing primitive pieces object 
algorithms require appropriate set primitives way designate siblings hierarchy level 
helman assume designer object addresses issues modeling object hierarchy pieces algorithms meet requirement producing hierarchies automatically 
ray tracing commonly bounding hierarchies reduce number ray object intersection tests 
algorithms build hierarchies application appropriate context collision detection reasons 
algorithms meant process scenes objects clearly defined primitives algorithms capable breaking single object primitives yield effective hierarchy 
second algorithms optimize hierarchy characteristics ray object intersection tests approach necessarily lead tightly fitting sphere hierarchies needed collision detection 
kay kajiya example build bounding shapes cheap intersect rays shapes rotational invariance necessary moving objects 
goldsmith salmon example show hierarchy prunes ray object intersection tests effectively minimizes surface area criteria necessarily encourage tight fit object create artifacts caps concavities 
successful approach tightly approximating object spheres rourke badler 
algorithm fits spheres polyhedron anchoring big spheres points polyhedron shrinking spheres just fit inside polyhedron 
badler rourke extend approach build level hierarchies consider general hierarchies greater depth necessary time critical detection algorithm 
section examines approach comparing new approach details topic intervening sections 
new approach inasmuch previous hierarchy building algorithms fully satisfy requirements time critical detection algorithm new approach 
motivation approach blum medial axis corresponds skeleton stick representation dimensional object 
shows example 
technical definition involves locus points equidistant sides object 
dimensional version heavy lines medial axis grey polygon 
voronoi diagram approximating medial axis 
medial axis surface 
structure contains surfaces lines remains analogous skeleton 
symmetries object medial axis surface suggest guide placement spheres approximate object 
spheres placed manner correspond closely spheres person choose approximating object manually 
section describes algorithm centers spheres medial axis surface merges reduce number optimizing accuracy object approximated 
precursor algorithm section discusses building medial axis surfaces 
building medial axis surfaces algorithm builds sphere hierarchy medial axis surface build surface 
problem simple literature contains solutions 
hoffmann presents exact algorithm complicated limited constructive solid geometry csg objects 
fortunately building sphere hierarchies require exact medial axis surfaces approximations suffice 
way approximate medial axis surface uses voronoi diagram 
voronoi diagram discrete set points identifies point region space closer point points 
regions called voronoi cells 
points cells convex polygons points convex polyhedra 
face cell equidistant points discrete set 
set points surface polyhedron voronoi diagram cells faces lying roughly medial axis 
shows analogous situation 
idea objects focuses polyhedral case 
develop idea algorithm 
algorithm identifies voronoi vertices corners voronoi cells lie medial axis surface 
description algorithm emphasize general properties expense specific details 
remainder section summarizes practical enhancements algorithm necessary successful implementation 
algorithm step places set points polyhedron surface 
number points parameter set user 
experience algorithm works better covers polyhedron uniformly simplest way achieve goal turk point placement algorithm 
creates random distribution points applies relaxation technique distribution 
second step building voronoi diagram points 
literature contains algorithms voronoi diagrams 
bowyer presents straightforward algorithm incrementally adds points diagram 
algorithm numerically robust rephrase algorithm topological properties necessarily inexact geometric computations 
unfortunately extensions compromise accuracy 
remedy extend algorithm choose equally valid topological situations estimated accuracy 
voronoi vertex center sphere lie points set points associated vertex forming points 
shows example spheres replaced circles number forming points reduced 
spheres circles centered voronoi vertices touch object forming points 
centered voronoi vertices associated forming points foundation algorithm building hierarchies medial axis surfaces section explain 
voronoi vertices interior polyhedron lie medial axis surface 
third step algorithm identifies vertices 
inclusion testing standard geometric problem extensions algorithms apply 
vertices voronoi diagram adjacent lie face voronoi cell 
faces may legitimately zero area case vertices coincide 
algorithm section convenient treat set coincident vertices vertex inherits adjacency set 
identify coincident vertices simple space subdivision helpful 
adjacency recorded medial axis surface sufficiently complete algorithm section 
possibility aliasing problems medial axis surface 
low density points narrow polyhedron narrow gaps cause medial axis surface disconnect bridge gap 
preventing problems advance difficult 
experience best solution detect problems occur add points correct 
process involves finding certain intersections voronoi cell faces polyhedron particular intersections parts polyhedron adjacent point contained cell 
intersection gets additional point projection region intersection 
complete details process appear 
building sphere hierarchies medial axis surfaces previous section algorithm generates large set voronoi vertices polyhedral object medial axis surface 
vertex forming points define sphere spheres tightly approximate polyhedron 
topic reducing number spheres preserving tightness approximation possible 
discussing reduction process section describe hierarchy building preprocess applies multiple times produce hierarchy multiple levels detail 
merger spheres forms strategy reducing number spheres merge adjacent spheres 
merging spheres involves replacing new sphere covers parts polyhedron cover 
efficiency preprocess approximates sphere covers terms forming points set points polyhedron surface defined previous section 
bounding sphere forming points associated ritter method compute nearly optimal bounding sphere 
illustrates example merging 
merge stores union forming points merge involving cover points 
producing level detail involves repeatedly merging pairs spheres 
choosing pairs merge optimization problem repetition choose minimum cost merger candidate pair merger preserves level tightness polyhedron 
note approach optimizing repetition independently greedy approach guarantee final result tightest possible fit approach produced tight fits test conducted 
identify candidate pairs merging preprocess uses adjacency properties medial axis surface defined previous section 
initially spheres centered voronoi vertices medial axis surface pair spheres merging candidate vertices adjacent voronoi diagram 
merge adjacent spheres adjacent restricting attention adjacent spheres preprocess avoids considering mergers spatially distant spheres results undesirably large spheres 
adjacent spheres reflect medial axis surface ability trace skeleton polyhedral object mergers adjacent spheres tend respect conceptual organization object 
cost function optimization return low value merger candidates form preserve tightness polyhedron 
useful approach hausdorff distance polyhedron 
distance defined maximum points surface minimum distance point polyhedron 
cost function computing distance return low costs appropriate cases way compute distance exactly nonconvex polyhedra explain straightforward algorithm albeit complicated correctness proof computes distance exactly convex polyhedra algorithm overestimate distance nonconvex polyhedra expressed unions convex pieces 
function approximates hausdorff distance 
forming point function measures distance surface normal direction polygon containing point maximum distances cost returned function 
compute distance forming point position function projects center plane polygon containing letting projection distance distance computing distance sphere 
radius distance gamma sigma add subtract depends relative positions illustrated 
form cost function strikes balance efficiency accuracy works merging operation 
section discusses different accurate approximation useful measuring tightness hierarchy merging complete 
control repetitions merging preprocess uses priority queue 
queue ranks pairs adjacent spheres merging cost allowing preprocess quickly find optimal merge 
merge preprocess updates queue reflect changes adjacency 
building queue initially takes time updating efficient 
building full hierarchy requires preprocess apply repeated merging technique multiple passes 
sphere tree preprocess merges spheres centered voronoi vertices produce fixed number children root polyhedron bounding sphere 
subsequently build children parent hierarchy preprocess starts voronoi vertices spheres merged form parent repeatedly merges spheres desired number children remain give parent children match branching factor octree 
sphere dag preprocess merges spheres centered voronoi vertices appropriate number level independently 
merging process guarantees forming points covered 
rest polyhedron tends get covered ensure fully conservative coverage techniques section necessary 
section shows sphere trees built merging process discusses preprocessing time involved 
completing hierarchies preprocess merging build sphere hierarchy approximates polyhedral object extra steps give hierarchy useful properties 
ensuring conservative coverage algorithm section tends produce spheres coverage object nearly conservative 
fully conservative coverage valuable 
form coverage time critical algorithm support final level exact detection leaf spheres store object polygons intersect algorithm compares polygons colliding leaves different hierarchies 
conservative coverage different requirements different types hierarchies 
safest policy children collectively cover parent covers 
spheres hierarchy level collectively cover polyhedron assuming parents level gamma children level sphere intersect 
case basic operation determining polyhedral face assumed triangle covered set spheres 
checking triangle coverage problem sphere intersects triangle corresponds solid disk triangle plane union disks cover triangle 
sphere trees disks need cover part triangle inside clipping disk corresponding parent sphere 
boundary lemma 
outer circles boundaries solid disks prominently solution problem 
specifically boundary lemma simplifies problem triangle clipping disk covered disks disk part boundary inside triangle clipping disk covered disks 
prove lemma gives intuitive justification note uncovered region uncovered portions disk boundaries 
implementing coverage checker boundary lemma straightforward book keeping involves primarily set operations dimensional intervals representing disk boundaries 
face covered simplest remedy iteratively enlarge spheres intersect face coverage 
experience applying safest policy sphere trees noticeably looser 
chose apply sphere dag policy sphere trees guarantees polygon fully covered set spheres 
section gives empirical results suggest approach conservative safest policy practice 
measuring accuracy running application want time critical detection algorithm report inaccuracy collision detected 
recall section important factor inaccuracy detection algorithm separation distance objects designates colliding 
unfortunately computing distance exactly expensive doing negates benefits time critical collision detection 
upper bound distance quickly computed preprocess stores sphere hierarchy distance sphere polyhedron 
distance defined section hausdorff distance maximum points sphere surface minimum distance point polyhedron 
spheres different hierarchies collide sum hausdorff distances upper bound enclosed polyhedra separation distance illustrated 
tighter upper bound sum minus overlap separation distance sum hausdorff distances heavy lines 
spheres 
collisions involving multiple pairs spheres hierarchies best estimate separation distance minimum upper bounds pairs 
approach gives true upper bound sphere hierarchy covers object conservatively technique section hierarchy nearly conservative advocate view accuracy general 
section mentions way compute exact hausdorff distance sphere nonconvex polyhedron 
section derived inexpensive approximation distance works merging operation 
purposes measuring separation distance expensive accurate approximation useful extra expense justified preprocess performs computation hierarchy complete 
approach involves computing minimum distance polyhedron discrete set points sphere vertices inscribed dodecahedron 
maximum distances approximates true hausdorff distance 
adding correction term maximum distance sphere surface nearest dodecahedron vertex approximation true upper bound 
computing minimum distance dodecahedron vertex polyhedron straightforward involving computing minimum distance polyhedral face 
space subdivision techniques prune set faces making computation efficient 
sphere hierarchy results hierarchy building algorithm sections worked tests 
figures show results 
sphere trees conservative policy section 
hewlett packard building sphere tree lamp took minutes minutes rocket minutes truck chassis hours 
times included operations including measuring accuracy section 
note preprocessing times amortized time object application 
results hierarchy building algorithm compare favorably octree algorithm terms accuracy 
figures show results octree algorithm visibly accurate 
quantitative comparison technique section measure hausdorff distance polyhedron sphere hierarchy 
level hierarchy measures inaccuracy average maximum hausdorff distances spheres level 
gives measures objects 
measures inaccuracy sphere trees built algorithm fraction inaccuracy octree sphere trees 
worth comparing algorithm sections badler rourke 
algorithm begins set points distributed surface polyhedron 
algorithm repeatedly chooses point anchors big sphere shrinks sphere bounds points process produces set spheres fit just octree 
medial axis surface 
bathroom triangles forms sphere trees 
octree 
medial axis surface 
rocket triangles forms sphere trees 
inside polyhedron 
articulated object algorithm bounds spheres associated jointed component sphere creating level hierarchy 
important early evidence objects successfully approximated spheres 
continues tradition adds significant improvements building hierarchies levels optimizing tightness spheres fit checking conservative coverage measuring accuracy techniques time critical context 
improvements essential detection algorithm meets needs interactive applications 
octree 
medial axis surface 
truck chassis seen triangles forms sphere trees 
fraction octree model level average inaccuracy maximum inaccuracy lamp rocket truck accuracy medial axis sphere trees compared octree sphere trees 
collision detection performance see time critical detection algorithm exploits sphere hierarchies tested performance empirically comparing algorithm bsp trees 
tests demonstrated hierarchies built medial axis surfaces provide acceptable accuracy improving hierarchies built octrees significant speedups 
importantly hierarchies allowed interactive performance possible maintained performance objects complex 
sample application context tests simple spaceship simulator 
simulator allows user interactively control ship flying autonomous ships 
user controls ship forward acceleration rotational velocity simulator computes motion simplified dynamics model solving ordinary differential equations second order runge kutta method adaptive step size 
move model pick control parameters random seconds 
ship free collide ship simulator detects collisions detection algorithms calls compare performance 
ships geometry models figures 
built bsp trees particular geometry preprocessing 
sphere trees levels depicted figures plus additional level 
bsp trees optimized avoid face splitting heuristic pilot studies indicated bsp trees efficient 
runtime detection algorithms broad phase space time bounds find bounding sphere collisions :10.1.1.46.3524
simulator collision response quite simple 
ships collide response algorithm determines ships converging checking relative velocities colliding spheres bsp trees uses bounding spheres 
converging applies energy momentum conservation change ships velocities causing bounce 
ignores rotational velocity simplicity 
user ship infinite mass affects ships affected 
collision response improves companion colliding objects non colliding positions start simulation 
performance hierarchy level set tests studied performance available level sphere trees 
ships lamp geometry chose shape deep concavities create complicated collision patterns 
simulator application called detection algorithms frame 
refined sphere trees deepest colliding level idea section comparing polygons stored leaf spheres giving extra level refinement designated level 
level recorded speedup sphere trees defined speedup processing time bsp trees processing time sphere trees level note speedup greater indicates sphere trees faster 
tests ran hewlett packard user controlled ship 
total number calls algorithm call corresponding pair ships bounding spheres collided calls featured ships wide variety relative orientations 
histograms speedups calls appear 
histograms show surprisingly speedup greater detection algorithm descended far sphere tree 
sphere trees significantly faster bsp trees levels level level objects real surfaces level sphere trees faster percent calls 
application refinement level colliding spheres invoke collision response objects quite touching creating inaccuracy 
section discusses algorithm report inaccuracy situation giving upper bound separation distance objects 
histograms show measure speedup bsp tree time sphere tree time level speedup bsp tree time sphere tree time level speedup bsp tree time sphere tree time level speedup bsp tree time sphere tree time level speedup bsp tree time sphere tree time level histograms speedup sphere trees bsp trees 
inaccuracy improved deeper levels sphere trees 
results histograms suggest time critical collision detection allow flexible trade speed accuracy 
tests suggest interesting conjecture conservative coverage 
level testing polygons stored level spheres sphere tree algorithm set collisions bsp tree algorithm detected 
expect result cover object conservatively 
applying simpler sphere dag policy conservative coverage sphere trees see section may useful practice generating full coverage 
separation distance fraction bounding sphere radius level separation distance fraction bounding sphere radius level separation distance fraction bounding sphere radius level separation distance fraction bounding sphere radius level histograms sphere tree accuracy 
sustainable real time performance second set tests evaluated detection algorithms ability maintain real time performance 
ran application bsp trees versions sphere trees 
runs sphere trees application strategy section stopping detection algorithm progressive refinement order meet target frame rate 
tests ran hewlett packard graphics acceleration 
operating system rendering available 
having components improve performance application interesting see time critical collision detection affects performance 
set tests involved user ship plus 
tests section ship triangle lamp geometry 
simulation time ran application rendering frames deltat time units 
minimum temporal resolution detection deltat units 
note detection algorithms sample object position twice frame 
application performance goal making simulation time match wall clock time computing frame seconds 
run involving collisions tracks frame processing time bsp trees 
time includes times broad phase collision response times insignificant 
number collisions large frames simple collision response required frames fully eliminate collisions 
simulation time bsp trees test involving lamps 
detection time mean std 
dev 
max 

graph indicates bsp trees caused application target frame time frames times slow 
mpeg animation run available world wide web url www acm org pubs tog hubbard follow link labeled run 
run time critical algorithm octree sphere trees depicted 
performance closer target seconds frame accuracy poor 
due looseness octree sphere trees objects separated large distances colliding sphere trees detection algorithm exhausted allowable processing time collision response objects bounce near touching 
world wide web page mentioned shows mpeg animation run follow link labeled run 
animation demonstrates disadvantages hierarchy building techniques address specific needs time critical collision detection 
third run time critical algorithm sphere trees built medial axis surfaces 
run involved collisions categorizes collisions sphere tree levels collision response invoked 
performance profile run appears 
graph shows time spent collision detection including broad phase collision response rendering slack time see section frame time note frame time meets target seconds frames deviations occur small 
accuracy quite reasonable seen mpeg animation world wide web page mentioned follow link labeled run 
shows frame animation 
test confirms time critical algorithm provide real time performance possible bsp algorithm 
final test ran application significantly complex geometry 
ships triangle truck geometry user ship lamp geometry 
total number triangles times number tested smith maximum literature nonconvex objects 
triangles rendering bottleneck hardware seconds frame 
application aimed target frame second target clearly interactive performance limits collision detection time budget allow interactive performance faster rendering 
collisions level application met target measure time spent solving differential equations motion control required time consuming calls system clock portions time included detection rendering times 
pilot studies indicated time application spent motion control insignificant 
level collisions sphere tree levels collision response invoked test involving lamps 
simulation time frame rendering detection solid slack dashed performance sphere trees medial axis surfaces test involving lamps 
frame time mean std 
dev 
max 

detection time mean std 
dev 
max 

frame rate illustrated profile 
shows snapshot run mpeg animation showing appears world wide web page mentioned follow link labeled run 
note detection algorithm average seconds frame 
results evidence time critical collision detection maintain real time performance objects complicated 
simulation time frame rendering slack dashed detection solid performance sphere trees medial axis surfaces test involving lamp truck 
detection time mean std 
dev 
max 
presents time critical collision detection algorithm trades accuracy speed 
foundation algorithm preprocess builds sphere hierarchies automatically medial axis surfaces polyhedral objects preprocess specifically optimizes tightness hierarchy level approximates object 
empirical results indicate preprocess improves previous hierarchy building techniques meeting needs time critical collision detection 
tests sample application demonstrate time critical detection algorithm provides acceptable accuracy maintaining real time performance possible previous algorithm 
tests indicate time critical algorithm preserve real time performance geometric complexity increases 
suggests extensions improvements 
hierarchy building algorithm works simple implement 
complicated part algorithm section medial axis surfaces simpler approach subproblem help 
version algorithm build sphere dags worth implementing 
issue explore redundancy spheres removal hierarchy affect conservative coverage 
boundary lemma section help detect redundancy experimented implementation 
hierarchies spheres may best way approximate objects 
flat wall example poses problems spheres required form tight approximation triangles 
solution problem hybrid hierarchies incorporate boxes flat side primitive addition spheres 
regardless hierarchy primitives algorithm traverses hierarchies may able exploit inter frame coherence 
remembering hierarchy nodes collided previous frame may reduce required find colliding nodes current frame 
algorithm progressive refinement occurs narrow phase may situations algorithm guarantee real time performance 
pairs objects simultaneously colliding nearly colliding broad phase may time detect collisions objects bounding spheres 
solving problem requires sort progressive refinement broad phase 
approach involve allowing broad phase selectively ignore collisions user designated unimportant objects 
broad phase devote time objects important particular application moving objects extra time 
majority conducted part author doctoral studies brown university 
guidance john spike hughes essential completion 
andy van dam jim kajiya franco preparata peter shirley don greenberg important contributions 
jim arvo deserves special mention implementing tests random cube rotations section 
brown cornell supported part nsf arpa science technology center computer graphics scientific visualization hewlett packard 
brown additional support provided sun microsystems onr arpa order ncr ibm digital equipment apple microsoft 
norman badler joseph rourke 
spherical representation human body visualizing movement 
proceedings ieee october 
david baraff 
curved surfaces coherence non penetrating rigid body simulation 
proceedings siggraph published computer graphics august 
david baraff 
dynamic simulation non penetrating rigid bodies 
phd thesis department computer science cornell university march 
harry blum 
transformation extracting new descriptors shape 
dunn editor models perception speech visual form pages 
mit press cambridge massachusetts 
adrian bowyer 
computing dirichlet tessellations 
computer journal 
frederick brooks jr grasping reality illusion interactive graphics serving science 
proceedings chi pages may 
stephen cameron 
collision detection dimensional intersection testing 
ieee transactions robotics automation june 
john canny 
collision detection moving polyhedra 
ieee transactions pattern analysis machine intelligence march 
jonathan cohen ming lin dinesh manocha ponamgi 
collide interactive exact collision detection system large scale environments 
proceedings symposium interactive graphics monterey california pages 
david dobkin david kirkpatrick 
fast detection polyhedral intersection 
theoretical computer science december 
tom duff 
interval arithmetic recursive subdivision implicit functions constructive solid geometry 
proceedings siggraph published computer graphics july 
andr vincent hayward st ephane 
awareness collision prediction 
proceedings ieee international conference robotics automation pages 
thomas funkhouser carlo 
adaptive display algorithm interactive frame rates visualization complex virtual environments 
proceedings siggraph published computer graphics proceedings annual conference series pages august 
alejandro garcia alonso nicol serrano juan 
solving collision detection problem 
ieee computer graphics applications may 
john yu alan knight dong 
constructing discrete medial axis objects 
international journal computational geometry applications 
jeffrey goldsmith john salmon 
automatic creation object hierarchies ray tracing 
ieee computer graphics applications may 
john jonathan crabtree norman badler 
production playback human motion virtual environments 
proceedings ieee virtual reality annual international symposium pages march 
lawrence gary 
visually induced motion sickness virtual environments 
presence summer 
christoph hoffmann 
construct skeleton csg objects 
adrian bowyer davenport editors mathematics surfaces iv 
oxford university press oxford 
available technical report csd tr computer sciences department purdue university 
philip hubbard :10.1.1.42.7280
interactive collision detection 
proceedings ieee symposium research frontiers virtual reality pages october 
philip hubbard 
collision detection interactive graphics applications 
phd thesis department computer science brown university october 
available ftp ftp cs brown edu pub techreports cs ps philip hubbard 
collision detection interactive graphics applications 
ieee transactions visualization computer graphics september 
philip hubbard 
real time collision detection time critical computing 
proceedings acm workshop simulation interaction virtual environments pages july 
hiroshi sugihara 
numerically robust incremental algorithm constructing threedimensional voronoi diagrams 
proceedings fourth canadian conference computational geometry pages 
timothy kay james kajiya 
ray tracing complex scenes 
proceedings siggraph published computer graphics august 
kitamura haruo narendra ahuja kishino 
efficient collision detection objects arbitrary motion multiple shape representations 
proceedings th iapr international conference pattern recognition pages october 
ming lin john canny 
fast algorithm incremental distance calculation 
proceedings ieee international conference robotics automation pages 
liu 
hierarchical sphere model hsm application checking interference moving robots 
proceedings ieee international workshop intelligent robots systems pages 
paulo peter shirley 
visual navigation large environments textured clusters 
proceedings symposium interactive graphics monterey california pages 
tamminen 
localized set operations solid modeling 
proceedings siggraph published computer graphics july 
brian mirtich john canny 
impulse simulation rigid bodies 
proceedings symposium interactive graphics monterey california pages 
matthew moore jane wilhelms 
collision detection response computer animation 
proceedings siggraph published computer graphics august 
bruce naylor 
constructing partitioning trees 
proceedings graphics interface pages may 
joseph rourke norman badler 
decomposition dimensional objects spheres 
ieee transactions pattern analysis machine intelligence pami july 
randy pausch thomas matthew conway 
literature survey virtual environments military flight simulator visual systems simulator sickness 
presence summer 
ponamgi dinesh manocha ming lin 
incremental algorithms collision detection solid models 
proceedings third acm symposium solid modeling applications pages may 
franco preparata michael shamos 
computational geometry 
springer verlag new york new york 
william press saul teukolsky william vetterling brian flannery 
numerical recipes cambridge university press cambridge england nd edition 
jack ritter 
efficient bounding sphere 
andrew glassner editor graphics gems pages 
academic press boston massachusetts 
john james helman 
iris performer high performance multiprocessing toolkit real time graphics 
proceedings siggraph published computer graphics proceedings annual conference series pages july 
hanan samet tamminen 
csg trees time 
proceedings siggraph published computer graphics july 
stan sclaroff alex pentland 
generalized implicit functions computer graphics 
proceedings siggraph published computer graphics august 
clifford shaffer gregory herb 
real time robot arm collision avoidance system 
ieee transactions robotics automation april 
andrew smith kitamura haruo kishino 
simple efficient method accurate collision detection deformable objects arbitrary motion 
proceedings ieee virtual reality annual international symposium pages march 
john snyder adam woodbury kurt fleischer alan barr 
interval methods multipoint collisions time dependent curved surfaces 
proceedings siggraph published computer graphics proceedings annual conference series pages august 
william thibault bruce naylor 
set operations polyhedra binary space partitioning trees 
proceedings siggraph published computer graphics july 
greg turk 
interactive collision detection molecular graphics 
technical report tr department computer science university north carolina chapel hill january 
greg turk 
generating textures arbitrary surfaces reaction diffusion 
proceedings siggraph published computer graphics august 
andries van dam 
vr forcing function software implications new paradigm 
proceedings ieee symposium research frontiers virtual reality pages october 
brian von herzen alan barr harold 
geometric collisions time dependent parametric surfaces 
proceedings siggraph published computer graphics august 
ji 
real time collision detection virtual reality applications 
proceedings ieee virtual reality annual international symposium pages september 
michael zyda william osborne james monahan david pratt 
real time vehicle collisions explosions terrain modifications 
journal visualization computer animation 
frame run profiled 
light colored lamps just collided 
frame run profiled 
light colored trucks just collided 
